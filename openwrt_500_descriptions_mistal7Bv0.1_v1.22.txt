



NEXT




<s> static bool aw9523_readable_reg(struct device *dev, unsigned int reg)
{
/* All available registers (minus holes) can be read */
return !aw9523_is_reg_hole(reg);
}

The above function is used to determine whether a given register is readable or not, but its performance is not good enough in my opinion. If it is true, why don't you use the function aw9523_is_reg_hole?
I'




NEXT




<s> mt7530_find_mapping(struct device_node *np)
{
const char *map;
int i;

if (of_property_read_string(np, "mediatek,portmap", &map))
return NULL;

for (i = 0; i < ARRAY_SIZE(mt7530_defaults); i++)
if (!strcmp(map, mt7530_defaults[i].name))
return &mt7530_defaults[i];

return NULL;
}

The above function is used to match mapping names provided by platform
description DTs and the existing mapping table. It will return a pointer
to the mapping structure if found, otherwise return NULL.

Device driver

Firstly, a mapping table should be specified in the




NEXT




<s> static inline void sata_oxnas_send_sync_escape(struct ata_port *ap)
{
struct sata_oxnas_port_priv *pd = ap->private_data;
u32 reg;

/* read the SSTATUS register and only send a sync escape if there is a
* link active */
if ((sata_oxnas_link_read(ap, 0x20) & 3) == 3) {
reg = ioread32(pd->port_base + SATA_COMMAND);
reg &= ~SATA_OPCODE_MASK;
reg |= CMD_SYNC_ESCAPE;
iowrite32(reg, pd->port_base + SATA_COMMAND);
}
}

The above function is used to send a sync escape command to a controller
over the PCI bus, for example after a link is established, or when the
FIS for a PIO transfer is received. So what happens when the link is not
established and the




NEXT




<s> static int rtl8367_write_phy_reg(struct rtl8366_smi *smi,
u32 phy_addr, u32 phy_reg, u32 val)
{
int timeout;
u32 data;
int err;

dev_dbg(smi->parent, "phy_write: addr:%02x, reg:%02x, val:%04x\n",
phy_addr, phy_reg, val);

if (phy_addr > RTL8367_PHY_ADDR_MAX)
return -EINVAL;

if (phy_reg > RTL8367_PHY_REG_MAX)
return -EINVAL;

REG_RD(smi, RTL8367_IA_STATUS_REG, &data);
if (data & RTL8367_IA_STATUS_PHY_BUSY)
return -ETIMEDOUT;

/* preapre data */
REG_WR(smi, RTL8367_IA_WRITE_DATA_REG, val);

/* prepare address */
REG_WR(smi, RTL8367_IA_ADDRESS_REG,
RTL8367_INTERNAL_PHY_REG(phy_addr, phy_reg));

/* send write command */
REG_WR(smi, RTL8367_IA_CTRL_REG,
RTL8367_IA_CTRL_CMD_MASK | RTL8367_IA_CTRL_RW_WRITE);

timeout = 5;
do {
REG_RD(smi, RTL8367_IA_STATUS_REG, &data);
if ((data & RTL8367_IA_STATUS_PHY_BUSY) == 0)
break;

if (timeout--) {
dev_err(smi->parent, "phy write timed out\n");
return -ETIMEDOUT;
}

udelay(1);
} while (1);

return 0;
}

The above function is used to write a certain register in the PHY device. It should be pretty simple. It takes a PHY address and register, and a value to write, then it generates the appropriate command to write the value to the register in the PHY. For




NEXT




<s> rtk_api_ret_t rtk_filter_igrAclPolarity_set(rtk_uint32 polarity)
{
/* Check initialization state */
RTK_CHK_INIT_STATE();

if(polarity > 1)
return RT_ERR_OUT_OF_RANGE;
return rtl8367c_setAsicAclGpioPolarity(polarity);
}

The above function is used to modify IGR ACL GPIO POLARITY. It can be modified by user, but need to be reset by system.

RTL8367C supports IGR ACL GPIO, which is shared with IGMP group




NEXT




<s> static void ar934x_nfc_get_addr(struct ar934x_nfc *nfc, int column,
int page_addr, u32 *addr0, u32 *addr1)
{
u32 a0, a1;

a0 = 0;
a1 = 0;

if (column == -1) {
/* ERASE1 */
a0 = (page_addr & 0xffff) << 16;
a1 = (page_addr >> 16) & 0xf;
} else if (page_addr != -1) {
/* SEQIN, READ0, etc.. */

/* TODO: handle 16bit bus width */
if (nfc->small_page) {
a0 = column & 0xff;
a0 |= (page_addr & 0xff) << 8;
a0 |= ((page_addr >> 8) & 0xff) << 16;
a0 |= ((page_addr >> 16) & 0xff) << 24;
} else {
a0 = column & 0x0FFF;
a0 |= (page_addr & 0xffff) << 16;

if (nfc->addr_count0 > 4)
a1 = (page_addr >> 16) & 0xf;
}
}

*addr0 = a0;
*addr1 = a1;
}

The above function is used to construct the required 32bit address to send to Nand controller
in the nfc_write_dqc(), nfc_get_addr(), nfc_write_dqs() & nfc_write_buf() functions




NEXT




<s> static void process_queue(unsigned long data)
{

DEU_WAKEUP_EVENT(deu_dma_priv.deu_thread_wait, AES_ASYNC_EVENT,
deu_dma_priv.aes_event_flags);
}

The above function is used to process pending deu events on the queue. However, if the function does not see something to process and returns, the queue size still increments.

The code to check the queue size is:

unsigned int
deu_dma




NEXT




<s> swconfig_send_link(struct sk_buff *msg, struct genl_info *info, int attr,
const struct switch_port_link *link)
{
struct nlattr *p = NULL;
int err = 0;

p = nla_nest_start(msg, attr);
if (link->link) {
if (nla_put_flag(msg, SWITCH_LINK_FLAG_LINK))
goto nla_put_failure;
}
if (link->duplex) {
if (nla_put_flag(msg, SWITCH_LINK_FLAG_DUPLEX))
goto nla_put_failure;
}
if (link->aneg) {
if (nla_put_flag(msg, SWITCH_LINK_FLAG_ANEG))
goto nla_put_failure;
}
if (link->tx_flow) {
if (nla_put_flag(msg, SWITCH_LINK_FLAG_TX_FLOW))
goto nla_put_failure;
}
if (link->rx_flow) {
if (nla_put_flag(msg, SWITCH_LINK_FLAG_RX_FLOW))
goto nla_put_failure;
}
if (nla_put_u32(msg, SWITCH_LINK_SPEED, link->speed))
goto nla_put_failure;
if (link->eee & ADVERTISED_100baseT_Full) {
if (nla_put_flag(msg, SWITCH_LINK_FLAG_EEE_100BASET))
goto nla_put_failure;
}
if (link->eee & ADVERTISED_1000baseT_Full) {
if (nla_put_flag(msg, SWITCH_LINK_FLAG_EEE_1000BASET))
goto nla_put_failure;
}
nla_nest_end(msg, p);

return err;

nla_put_failure:
nla_nest_cancel(msg, p);
return -1;
}

The above function is used to encode the structure of the SWITCH_LINK_SPEED to the corresponding NL messages.</s>




NEXT




<s> static int qca807x_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)
{
struct phy_device *phydev = upstream;
__ETHTOOL_DECLARE_LINK_MODE_MASK(support) = { 0, };
phy_interface_t iface;
int ret;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
DECLARE_PHY_INTERFACE_MASK(interfaces);

sfp_parse_support(phydev->sfp_bus, id, support, interfaces);
#else
sfp_parse_support(phydev->sfp_bus, id, support);
#endif
iface = sfp_select_interface(phydev->sfp_bus, support);

dev_info(&phydev->mdio.dev, "%s SFP module inserted\n", phy_modes(iface));

switch (iface) {
case PHY_INTERFACE_MODE_1000BASEX:
case PHY_INTERFACE_MODE_100BASEX:
/* Set PHY mode to PSGMII combo (1/4 copper + combo ports) mode */
ret = phy_modify(phydev,
QCA807X_CHIP_CONFIGURATION,
QCA807X_CHIP_CONFIGURATION_MODE_CFG_MASK,
QCA807X_CHIP_CONFIGURATION_MODE_PSGMII_FIBER);
/* Enable fiber mode autodection (1000Base-X or 100Base-FX) */
ret = phy_set_bits_mmd(phydev,
MDIO_MMD_AN,
QCA807X_MMD7_FIBER_MODE_AUTO_DETECTION,
QCA807X_MMD7_FIBER_MODE_AUTO_DETECTION_EN);
/* Select fiber page */
ret = phy_clear_bits(phydev,
QCA807X_CHIP_CONFIGURATION,
QCA807X_BT_BX_REG_SEL);

phydev->port = PORT_FIBRE;
break;
default:
dev_err(&phydev->mdio.dev, "Incompatible SFP module inserted\n");
return -EINVAL;
}

return ret;
}

The above function is used to insert an SFP module into the port. It will perform
the operation according to the interface type of the board.</s>




NEXT




<s> void print_title(WINDOW *dialog, const char *title, int width)
{
if (title) {
int tlen = MIN(width - 2, strlen(title));
wattrset(dialog, dlg.title.atr);
mvwaddch(dialog, 0, (width - tlen) / 2 - 1, ' ');
mvwaddnstr(dialog, 0, (width - tlen)/2, title, tlen);
waddch(dialog, ' ');
}
}

The above function is used to add title to the dialog box. But when adding title with “%s “ (title string), the title string is output only to the fourth row of the current cursor position in the dialog box.

Please help me solve the problem. Thank




NEXT




<s> int rtl8366_sw_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
struct switch_port *port;
u32 member = 0;
u32 untag = 0;
int err;
int i;

if (!smi->ops->is_vlan_valid(smi, val->port_vlan))
return -EINVAL;

port = &val->value.ports[0];
for (i = 0; i < val->len; i++, port++) {
int pvid = 0;
member |= BIT(port->id);

if (!(port->flags & BIT(SWITCH_PORT_FLAG_TAGGED)))
untag |= BIT(port->id);

/*
* To ensure that we have a valid MC entry for this VLAN,
* initialize the port VLAN ID here.
*/
err = rtl8366_get_pvid(smi, port->id, &pvid);
if (err < 0)
return err;
if (pvid == 0) {
err = rtl8366_set_pvid(smi, port->id, val->port_vlan);
if (err < 0)
return err;
}
}

return rtl8366_set_vlan(smi, val->port_vlan, member, untag, 0);
}

The above function is used to set the member ports and untag ports of a vlan.</s>




NEXT




<s> static void do_reboot(void)
{
fprintf(stderr, "Rebooting ...\n");
fflush(stderr);

/* try regular reboot method first */
system("/sbin/reboot");
sleep(2);

/* if we're still alive at this point, force the kernel to reboot */
syscall(SYS_reboot,LINUX_REBOOT_MAGIC1,LINUX_REBOOT_MAGIC2,LINUX_REBOOT_CMD_RESTART,NULL);
}

The above function is used to reboot from userland. The idea, of course, is that even if the kernel panics, you can still reboot. However, if you call this function without a recent commit from the Linux sources, you run into some difficulties:





NEXT




<s> ret_t rtl8367c_getAsicPortMirrorTxFunction(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_TX_OFFSET, pEnabled);
}

The above function is used to obtain the port mirror state. When calling the function, port mirroring is enabled. If it returns 1 and port mirroring is enabled means to send packets to the set port. If it returns 0 and port mirroring is




NEXT




<s> void set_dialog_backtitle(const char *backtitle)
{
dlg.backtitle = backtitle;
}

The above function is used to set up the title which displayed at the top of the dialog. You can use it to change the title, or to get rid of it entirely. If you need to change the title of most of your dialogs, it's preferable to




NEXT




<s> static int rtl9300_i2c_write(struct rtl9300_i2c *i2c, u8 *buf, int len)
{
return i2c_write(REG(i2c, RTL9300_I2C_DATA_WORD0), buf, len);
}

The above function is used to call rtl9300_i2c_write() and it is the only function which i2c_write is called. rtl9300_i2c_write has its own implementation. According to the source




NEXT




<s> ret_t rtl8367c_getAsicSystemLutLearnLimitNo(rtk_uint32 *pNumber)
{
if(NULL == pNumber)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicReg(RTL8367C_REG_LUT_SYS_LEARN_LIMITNO, pNumber);
}

The above function is used to get the limit number of learn entries for system LUT (for TAG type table).

This function will send an write command to read this field.

The field definition of RTL8367C  for AsicSystem




NEXT




<s> ret_t rtl8367c_setAsicRlppTrap8051(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLPP_8051_TRAP_OFFSET, enabled);
}

The above function is used to set trigger condition for LLPP Trap. The Trap is only triggered when all these 4 conditions happen at the same time:
1- Enabled by software
2- Ethernet type is 0x8051,




NEXT




<s> static ssize_t read_file_napi_stats(struct file *file, char __user *user_buf,
size_t count, loff_t *ppos)
{
struct ag71xx *ag = file->private_data;
struct ag71xx_napi_stats *stats = &ag->debug.napi_stats;
char *buf;
unsigned int buflen;
unsigned int len = 0;
unsigned long rx_avg = 0;
unsigned long tx_avg = 0;
int ret;
int i;

buflen = 2048;
buf = kmalloc(buflen, GFP_KERNEL);
if (!buf)
return -ENOMEM;

if (stats->rx_count)
rx_avg = stats->rx_packets / stats->rx_count;

if (stats->tx_count)
tx_avg = stats->tx_packets / stats->tx_count;

len += snprintf(buf + len, buflen - len, "%3s  %10s %10s\n",
"len", "rx", "tx");

for (i = 1; i <= AG71XX_NAPI_WEIGHT; i++)
len += snprintf(buf + len, buflen - len,
"%3d: %10lu %10lu\n",
i, stats->rx[i], stats->tx[i]);

len += snprintf(buf + len, buflen - len, "\n");

len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
"sum", stats->rx_count, stats->tx_count);
len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
"avg", rx_avg, tx_avg);
len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
"max", stats->rx_packets_max, stats->tx_packets_max);
len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
"pkt", stats->rx_packets, stats->tx_packets);

ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
kfree(buf);

return ret;
}

The above function is used to report napi stats in file format which are printed in
a format as shown below.

$ cat /sys/class/net/ag71xx/debug/napi_stats
len	rx	tx
1:	




NEXT




<s> static ssize_t age_out_write(struct file *filp, const char __user *buffer,
size_t count, loff_t *ppos)
{
struct rtl838x_port *p = filp->private_data;
u32 value;
size_t res = rtl838x_common_write(buffer, count, ppos, &value);
if (res < 0)
return res;

rtl83xx_fast_age(p->dp->ds, p->dp->index);

return res;
}

The above function is used to set the age-out timer in seconds.
The age-out threshold is configured as:
rtl83xx_fast_age(p->dp->ds, age_out);
So the value sent from user space must be




NEXT




<s> rtk_api_ret_t rtk_vlan_stg_get(rtk_vlan_t vid, rtk_stp_msti_id_t *pStg)
{
rtk_api_ret_t retVal;
rtl8367c_user_vlan4kentry vlan4K;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* vid must be 0~4095 */
if (vid > RTL8367C_VIDMAX)
return RT_ERR_VLAN_VID;

if(NULL == pStg)
return RT_ERR_NULL_POINTER;

/* update 4K table */
vlan4K.vid = vid;
if ((retVal = rtl8367c_getAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
return retVal;

*pStg = vlan4K.fid_msti;

return RT_ERR_OK;
}

The above function is used to search if a VLAN is Stp or not.

If an application needs to know the current status of the Stp of a VLAN, it
can use the rtk_vlan_stg_get API:






NEXT




<s> void __div0 (void)
{
while(-1);
}

The above function is used to detect the vulnerability by triggering a null pointer dereference. Function __div0 is being called from the application. So by creating a stack frame on which the null function pointer is stored and changing the top of stack can achieve this goal.





NEXT




<s> static void ag71xx_ethtool_get_strings(struct net_device *netdev, u32 sset,
u8 *data)
{
if (sset == ETH_SS_STATS) {
int i;

for (i = 0; i < ARRAY_SIZE(ag71xx_statistics); i++)
ethtool_puts(&data, ag71xx_statistics[i].name);
}
}

The above function is used to return the statistics strings to be displayed
by the ethtool utility.

Next, there’s a function to update stats and return the number of entries
that were incremented:

s32 ag71xx_update




NEXT




<s> static int aw9523_pconf_get(struct pinctrl_dev *pctldev, unsigned int pin,
unsigned long *config)
{
struct aw9523 *awi = pinctrl_dev_get_drvdata(pctldev);
enum pin_config_param param = pinconf_to_config_param(*config);
int regbit = pin % AW9523_PINS_PER_PORT;
unsigned int val;
u8 reg;
int rc;

rc = aw9523_pcfg_param_to_reg(param, pin, &reg);
if (rc)
return rc;

mutex_lock(&awi->i2c_lock);
rc = regmap_read(awi->regmap, reg, &val);
mutex_unlock(&awi->i2c_lock);
if (rc)
return rc;

switch (param) {
case PIN_CONFIG_BIAS_PULL_UP:
case PIN_CONFIG_INPUT_ENABLE:
case PIN_CONFIG_OUTPUT:
val &= BIT(regbit);
break;
case PIN_CONFIG_BIAS_PULL_DOWN:
case PIN_CONFIG_OUTPUT_ENABLE:
val &= BIT(regbit);
val = !val;
break;
case PIN_CONFIG_DRIVE_OPEN_DRAIN:
if (pin >= AW9523_PINS_PER_PORT)
val = 0;
else
val = !FIELD_GET(AW9523_GCR_GPOMD_MASK, val);
break;
case PIN_CONFIG_DRIVE_PUSH_PULL:
if (pin >= AW9523_PINS_PER_PORT)
val = 1;
else
val = FIELD_GET(AW9523_GCR_GPOMD_MASK, val);
break;
default:
return -ENOTSUPP;
}
if (val < 1)
return -EINVAL;

*config = pinconf_to_config_packed(param, !!val);

return rc;
}

The above function is used to extract the configuration from the AW9523 device. The function extracts the configuration value from the AW9523 device based on the pin and the parameter.  The function starts by obtaining the enum pin_config_param




NEXT




<s> rtk_api_ret_t rtk_trap_unknownMacPktAction_get(rtk_trap_ucast_action_t *pUcast_action)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pUcast_action)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortUnknownSaBehavior(pUcast_action)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get trap action of RUNTIME, which will be used by some functions in the upper layer. For example, some applications that support trap function need to judge action of pUcast_action and then make some decision of applications.</s>




NEXT




<s> int plla_set_config(int mhz)
{
int index = (mhz - PLL_LOW_FREQ) / PLL_FREQ_STEP;
const PLL_CONFIG *cfg;

if (index < 0 || index > ARRAY_SIZE(C_PLL_CONFIG)) {
debug("Freq %d MHz out of range, default to lowest\n", mhz);
index = 0;
}
cfg = &C_PLL_CONFIG[index];

printf("Attempting to set PLLA to %d MHz ...\n", (unsigned) cfg->mhz);
plla_configure(cfg->outdiv, cfg->refdiv, cfg->fbdiv, cfg->bwadj,
cfg->sfreq, cfg->sslope);

return cfg->mhz;
}

The above function is used to change the PLLA configuration, but for different
reasons I would like to set this directly.

Is there any other function that I can use to change the pll configuration
without going through this config file? The main reason I




NEXT




<s> struct rtl8366_smi *rtl8366_smi_probe(struct platform_device *pdev)
{
struct rtl8366_smi *smi;
int err;

smi = rtl8366_smi_alloc(&pdev->dev);
if (!smi)
return NULL;

if (pdev->dev.of_node)
err = rtl8366_smi_probe_of(pdev, smi);
else
err = rtl8366_smi_probe_plat(pdev, smi);

if (err)
goto free_smi;

return smi;

free_smi:
kfree(smi);
return ERR_PTR(err);
}

The above function is used to probe the device, it takes a pointer to the platform device structure as an argument and returns a pointer to the rtl8366_smi structure.The smi structure contains all the information related to the device, including the device ID




NEXT




<s> static void get_dep_str(struct gstr *r, struct expr *expr, const char *prefix)
{
if (!expr_is_yes(expr)) {
str_append(r, prefix);
expr_gstr_print(expr, r);
str_append(r, "\n");
}
}

The above function is used to print the dependency graph, including edges or arrows, using str_append.

To help understand how this works, let’s take a step back and take a look at the structure of an expr. The code from the code above that




NEXT




<s> uc_hostapd_bss_set_config(uc_vm_t *vm, size_t nargs)
{
struct hostapd_data *hapd = uc_fn_thisval("hostapd.bss");
struct hostapd_bss_config *old_bss;
struct hostapd_iface *iface;
struct hostapd_config *conf;
uc_value_t *file = uc_fn_arg(0);
uc_value_t *index = uc_fn_arg(1);
uc_value_t *files_only = uc_fn_arg(2);
unsigned int i, idx = 0;
int ret = -1;

if (!hapd || ucv_type(file) != UC_STRING)
goto out;

if (ucv_type(index) == UC_INTEGER)
idx = ucv_int64_get(index);

iface = hapd->iface;
conf = interfaces->config_read_cb(ucv_string_get(file));
if (!conf)
goto out;

if (idx > conf->num_bss || !conf->bss[idx])
goto free;

if (ucv_boolean_get(files_only)) {
struct hostapd_bss_config *bss = conf->bss[idx];
struct hostapd_bss_config *old_bss = hapd->conf;

#define swap_field(name)				\
do {								\
void *ptr = old_bss->name;		\
old_bss->name = bss->name;		\
bss->name = ptr;				\
} while (0)

swap_field(ssid.wpa_psk_file);
ret = bss_reload_vlans(hapd, bss);
goto done;
}

hostapd_bss_deinit_no_free(hapd);
hostapd_drv_stop_ap(hapd);
hostapd_free_hapd_data(hapd);

old_bss = hapd->conf;
for (i = 0; i < iface->conf->num_bss; i++)
if (iface->conf->bss[i] == hapd->conf)
iface->conf->bss[i] = conf->bss[idx];
hapd->conf = conf->bss[idx];
conf->bss[idx] = old_bss;

hostapd_setup_bss(hapd, hapd == iface->bss[0], true);
hostapd_ucode_update_interfaces();

done:
ret = 0;
free:
hostapd_config_free(conf);
out:
return ucv_int64_new(ret);
}

The above function is used to update the BSS (Basic Service Set) configuration in the HostAPD module for the configured access point (AP). The function takes in three arguments: a file object, an index, and a Boolean value representing whether only files or the full configuration




NEXT




<s> mtk_bmt_write(struct mtd_info *mtd, loff_t to,
struct mtd_oob_ops *ops)
{
struct mtd_oob_ops cur_ops = *ops;
int retry_count = 0;
loff_t cur_to;
int ret;

ops->retlen = 0;
ops->oobretlen = 0;

while (ops->retlen < ops->len || ops->oobretlen < ops->ooblen) {
u32 offset = to & (bmtd.blk_size - 1);
u32 block = to >> bmtd.blk_shift;
int cur_block;

cur_block = bmtd.ops->get_mapping_block(block);
if (cur_block < 0)
return -EIO;

cur_to = ((loff_t)cur_block << bmtd.blk_shift) + offset;

cur_ops.oobretlen = 0;
cur_ops.retlen = 0;
cur_ops.len = min_t(u32, bmtd.blk_size - offset,
ops->len - ops->retlen);
ret = bmtd._write_oob(mtd, cur_to, &cur_ops);
if (ret < 0) {
if (mtk_bmt_remap_block(block, cur_block, offset) &&
retry_count++ < 10)
continue;

return ret;
}

ops->retlen += cur_ops.retlen;
ops->oobretlen += cur_ops.oobretlen;

cur_ops.ooboffs = 0;
cur_ops.datbuf += cur_ops.retlen;
cur_ops.oobbuf += cur_ops.oobretlen;
cur_ops.ooblen -= cur_ops.oobretlen;

if (!cur_ops.len)
cur_ops.len = mtd->erasesize - offset;

to += cur_ops.len;
retry_count = 0;
}

return 0;
}

The above function is used to write data into flash.
When flash driver tries to write data into flash, it needs to pass in to, length, oob_ops, mtd_info, and so on.
To, length and length will be the data to




NEXT




<s> ret_t rtl8367c_setAsicOamParser(rtk_uint32 port, rtk_uint32 parser)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(parser > OAM_PARFWDCPU)
return RT_ERR_NOT_ALLOWED;

return rtl8367c_setAsicRegBits(RTL8367C_REG_OAM_PARSER_CTRL0 + port/8, RTL8367C_OAM_PARSER_MASK(port % 8), parser);
}

The above function is used to set the mode of VLAN OAM packet to be processed by the OAM forwarder. The valid mode is CPUFWD, CPUFWD2, CPUFWD3, PARFWDCPU, DSPFWDCPU.






NEXT




<s> void rtl839x_set_port_reg_be(u64 set, int reg)
{
sw_w32(set >> 32, reg);
sw_w32(set & 0xffffffff, reg + 4);
}

The above function is used to write to registers of rtl839x chip,
The chip have few register banks,
But in the source code, the registers are mixed, some registers of different bank,

For example, MAC_CONF register on the chip




NEXT




<s> void rtl931x_vlan_profile_dump(int index)
{
u64 profile[4];

if (index < 0 || index > 15)
return;

profile[0] = sw_r32(RTL931X_VLAN_PROFILE_SET(index));
profile[1] = (sw_r32(RTL931X_VLAN_PROFILE_SET(index) + 4) & 0x1FFFFFFFULL) << 32 |
(sw_r32(RTL931X_VLAN_PROFILE_SET(index) + 8) & 0xFFFFFFFF);
profile[2] = (sw_r32(RTL931X_VLAN_PROFILE_SET(index) + 16) & 0x1FFFFFFFULL) << 32 |
(sw_r32(RTL931X_VLAN_PROFILE_SET(index) + 12) & 0xFFFFFFFF);
profile[3] = (sw_r32(RTL931X_VLAN_PROFILE_SET(index) + 20) & 0x1FFFFFFFULL) << 32 |
(sw_r32(RTL931X_VLAN_PROFILE_SET(index) + 24) & 0xFFFFFFFF);

pr_info("VLAN %d: L2 learning: %d, L2 Unknown MultiCast Field %llx, \
IPv4 Unknown MultiCast Field %llx, IPv6 Unknown MultiCast Field: %llx",
index, (u32) (profile[0] & (3 << 14)), profile[1], profile[2], profile[3]);
}

The above function is used to dump VLAN profile. The parameter index is a VLAN index. By this function, we can have a look at some information of a VLAN. However, the information are not clear enough. For example, the function can not tell us whether




NEXT




<s> ret_t rtl8367c_getAsicPortMirrorOverride(rtk_uint32 *pRxMirror, rtk_uint32 *pTxMirror, rtk_uint32 *pAclMirror)
{
ret_t retVal;

if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_RX_OVERRIDE_EN_OFFSET, pRxMirror)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_TX_OVERRIDE_EN_OFFSET, pTxMirror)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_ACL_OVERRIDE_EN_OFFSET, pAclMirror)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read the status of the port mirror override of rtl8367c soc.

int main(){  rtk_uint32 retcode;         rtk_uint32 rxMirror, txMirror, acl




NEXT




<s> ar8327_hw_init(struct ar8xxx_priv *priv)
{
int ret;

priv->chip_data = kzalloc(sizeof(struct ar8327_data), GFP_KERNEL);
if (!priv->chip_data)
return -ENOMEM;

if (priv->pdev->of_node)
ret = ar8327_hw_config_of(priv, priv->pdev->of_node);
else
ret = ar8327_hw_config_pdata(priv,
priv->phy->mdio.dev.platform_data);

if (ret)
return ret;

ar8327_leds_init(priv);

ar8xxx_phy_init(priv);

return 0;
}

The above function is used to initialize the ar8xxx driver. When the hardware resources in ar8xx chip are used to initialize, which function is used to achieve the initialization?

I used to think that this function was ar8xxx_phy_init(). I thought




NEXT




<s> static int rtl8367_mii_write(struct mii_bus *bus, int addr, int reg, u16 val)
{
struct rtl8366_smi *smi = bus->priv;
u32 t;
int err;

err = rtl8367_write_phy_reg(smi, addr, reg, val);
if (err)
return err;

/* flush write */
(void) rtl8367_read_phy_reg(smi, addr, reg, &t);

return err;
}

The above function is used to write the register value. In addition to this, there are read functions for reading the different registers in the IPE chip. These are defined in the header file /kernel/drivers/net/ethernet/realtek/816




NEXT




<s> static int oxnas_pcie_wr_conf(struct pci_bus *bus, u32 devfn,
int where, int size, u32 val)
{
unsigned long flags;
struct oxnas_pcie *pcie = sys_to_pcie(bus->sysdata);
unsigned offset;
u32 value;
u32 lanes;

/* Only a single device per bus for PCIe point-to-point links */
if (PCI_SLOT(devfn) > 0)
return PCIBIOS_DEVICE_NOT_FOUND;

if (!pcie->haslink)
return PCIBIOS_DEVICE_NOT_FOUND;

offset = oxnas_pcie_cfg_to_offset(bus->sysdata, bus->number, devfn,
where);

value = val << (8 * (where & 3));
lanes = (0xf >> (4-size)) << (where & 3);
/* it race with mem and io write, but the possibility is low, normally
* all config writes happens at driver initialize stage, wont interleave
* with others.
* and many pcie cards use dword (4bytes) access mem/io access only,
* so not bother to copy that ugly work-around now. */
spin_lock_irqsave(&pcie->lock, flags);
set_out_lanes(pcie, lanes);
writel_relaxed(value, pcie->cfgbase + offset);
set_out_lanes(pcie, 0xf);
spin_unlock_irqrestore(&pcie->lock, flags);

return PCIBIOS_SUCCESSFUL;
}

The above function is used to write to PCIE IO port directly. However, the above code has a bug, please refer to code below.

unsigned long flags;
spin_lock_irqsave(&pcie->lock, flags);
set_out_lan




NEXT




<s> static int rtl8367_sw_get_port_mib(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
int i, len = 0;
unsigned long long counter = 0;
static char mib_buf[4096];

if (val->port_vlan >= RTL8367C_NUM_PORTS)
return -EINVAL;

len += snprintf(mib_buf + len, sizeof(mib_buf) - len,
"Port %d MIB counters\n",
val->port_vlan);

for (i = 0; i <rtl8367c_get_mibs_num(); ++i) {
len += snprintf(mib_buf + len, sizeof(mib_buf) - len,
"%-36s: ",rtl8367c_get_mib_name(i));
if (!rtl8367c_get_port_mib_counter(i, val->port_vlan,
&counter))
len += snprintf(mib_buf + len, sizeof(mib_buf) - len,
"%llu\n", counter);
else
len += snprintf(mib_buf + len, sizeof(mib_buf) - len,
"%s\n", "N/A");
}

val->value.s = mib_buf;
val->len = len;
return 0;
}

The above function is used to get mib variables in the switch_dev structure.

The sw_get_port_mib function in rtl8367_sw_chip.h reads the mib variables to
the val.value from the m




NEXT




<s> static void bcm6348_emac_refill_rx_timer(struct timer_list *t)
{
struct bcm6348_emac *emac = from_timer(emac, t, rx_timeout);
struct net_device *ndev = emac->net_dev;

spin_lock(&emac->rx_lock);
bcm6348_emac_refill_rx(ndev);
spin_unlock(&emac->rx_lock);
}

The above function is used to fire the callback when the timer expired. However when looking at the code, there is no timer callback being setup.</s>




NEXT




<s> ret_t rtl8367c_setAsicPortMirrorRxFunction(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_RX_OFFSET, enabled);
}

The above function is used to disable/enable Asic's port mirroring functionality.

The function in question is actually a set_enable_func(). set_func() simply maps
the functionality bit, in our case RTL8367C_




NEXT




<s> ar8327_led_unregister(struct ar8327_led *aled)
{
if (aled->mode == AR8327_LED_MODE_HW)
device_remove_file(aled->cdev.dev, &dev_attr_enable_hw_mode);

led_classdev_unregister(&aled->cdev);
cancel_work_sync(&aled->led_work);
}

The above function is used to unregister the device from kernel.</s>




NEXT




<s> ar8216_atu_flush_port(struct ar8xxx_priv *priv, int port)
{
u32 t;
int ret;

ret = ar8216_wait_bit(priv, AR8216_REG_ATU_FUNC0, AR8216_ATU_ACTIVE, 0);
if (!ret) {
t = (port << AR8216_ATU_PORT_NUM_S) | AR8216_ATU_OP_FLUSH_PORT;
t |= AR8216_ATU_ACTIVE;
ar8xxx_write(priv, AR8216_REG_ATU_FUNC0, t);
}

return ret;
}

The above function is used to flush the packet buffers belonging to a
specific port. I am testing this on the AR8216 chip which is the
hardware revision of my hardware. I don’t know if this is the case for
all hardware revision but




NEXT




<s> int rtl930x_eee_port_ability(struct rtl838x_switch_priv *priv, struct ethtool_eee *e, int port)
{
u32 link, a;

if (port >= 26)
return -ENOTSUPP;

pr_info("In %s, port %d\n", __func__, port);
link = sw_r32(RTL930X_MAC_LINK_STS);
link = sw_r32(RTL930X_MAC_LINK_STS);
if (!(link & BIT(port)))
return 0;

pr_info("Setting advertised\n");
if (sw_r32(rtl930x_mac_force_mode_ctrl(port)) & BIT(10))
e->advertised |= ADVERTISED_100baseT_Full;

if (sw_r32(rtl930x_mac_force_mode_ctrl(port)) & BIT(12))
e->advertised |= ADVERTISED_1000baseT_Full;

if (priv->ports[port].is2G5 && sw_r32(rtl930x_mac_force_mode_ctrl(port)) & BIT(13)) {
pr_info("ADVERTISING 2.5G EEE\n");
e->advertised |= ADVERTISED_2500baseX_Full;
}

if (priv->ports[port].is10G && sw_r32(rtl930x_mac_force_mode_ctrl(port)) & BIT(15))
e->advertised |= ADVERTISED_10000baseT_Full;

a = sw_r32(RTL930X_MAC_EEE_ABLTY);
a = sw_r32(RTL930X_MAC_EEE_ABLTY);
pr_info("Link partner: %08x\n", a);
if (a & BIT(port)) {
e->lp_advertised = ADVERTISED_100baseT_Full;
e->lp_advertised |= ADVERTISED_1000baseT_Full;
if (priv->ports[port].is2G5)
e->lp_advertised |= ADVERTISED_2500baseX_Full;
if (priv->ports[port].is10G)
e->lp_advertised |= ADVERTISED_10000baseT_Full;
}

/* Read 2x to clear latched state */
a = sw_r32(RTL930X_EEEP_PORT_CTRL(port));
a = sw_r32(RTL930X_EEEP_PORT_CTRL(port));
pr_info("%s RTL930X_EEEP_PORT_CTRL: %08x\n", __func__, a);

return 0;
}

The above function is used to get the ethtool advertise information. You could also do this using an existing script in linux for the advertise method. But I did not want to add additional dependency and preferred to look at source codes.</s>




NEXT




<s> int rtl83xx_port_mdb_del(struct dsa_switch *ds, int port,
const struct switchdev_obj_port_mdb *mdb)
{
struct rtl838x_switch_priv *priv = ds->priv;
u64 mac = ether_addr_to_u64(mdb->addr);
struct rtl838x_l2_entry e;
int err = 0, idx;
int vid = mdb->vid;
u64 seed = priv->r->l2_hash_seed(mac, vid);
u64 portmask;

pr_debug("In %s, port %d, mac %llx, vid: %d\n", __func__, port, mac, vid);

if (priv->is_lagmember[port]) {
pr_info("%s: %d is lag slave. ignore\n", __func__, port);
return 0;
}

mutex_lock(&priv->reg_mutex);

idx = rtl83xx_find_l2_hash_entry(priv, seed, true, &e);

if (idx >= 0) {
pr_debug("Found entry index %d, key %d and bucket %d\n", idx, idx >> 2, idx & 3);
portmask = rtl83xx_mc_group_del_port(priv, e.mc_portmask_index, port);
if (!portmask) {
e.valid = false;
priv->r->write_l2_entry_using_hash(idx >> 2, idx & 0x3, &e);
}
goto out;
}

/* Check CAM for spillover from hash buckets */
idx = rtl83xx_find_l2_cam_entry(priv, seed, true, &e);

if (idx >= 0) {
portmask = rtl83xx_mc_group_del_port(priv, e.mc_portmask_index, port);
if (!portmask) {
e.valid = false;
priv->r->write_cam(idx, &e);
}
goto out;
}
/* TODO: Re-enable with a newer kernel: err = -ENOENT; */

out:
mutex_unlock(&priv->reg_mutex);

return err;
}

The above function is used to remove the MDB from the switch table. The switch table is composed of two components, the hashed table and the CAM table. In case of LAG ports, there is an additional hashed table called hash_slave table stored in the




NEXT




<s> static inline struct des_container *des_container_cast(
struct ablkcipher_request *areq)
{
return container_of(areq, struct des_container, arequest);
}

The above function is used to extract the specific data structure from
struct ablkcipher_request *areq. The implementation needs to ensure that
the areq (the abstract base class) must have a container_of() operator.

Note:
The same




NEXT




<s> static inline void sata_oxnas_reset_dma(struct ata_port *ap, int assert)
{
struct sata_oxnas_port_priv *pd = ap->private_data;
u32 reg;

reg = ioread32(pd->dmactl_base + DMA_CONTROL);
if (assert)
reg |= DMA_CONTROL_RESET;
else
reg &= ~DMA_CONTROL_RESET;

iowrite32(reg, pd->dmactl_base + DMA_CONTROL);
};

The above function is used to assert and deassert the DMA_CONTROL_RESET dword in oxnas chipset, and then call following device function to program each phy for dma.</s>




NEXT




<s> ar8327_sw_set_eee(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
struct ar8327_data *data = priv->chip_data;
int port = val->port_vlan;
int phy;

if (port >= dev->ports)
return -EINVAL;
if (port == 0 || port == 6)
return -EOPNOTSUPP;

phy = port - 1;

data->eee[phy] = !!(val->value.i);

return 0;
}

The above function is used to read or write the EEE register.

On the device that I’m working on, I did it this way:

struct switch_val set_value = {
.value = {
.i = true,
}




NEXT




<s> static int rb4xx_cpld_cmd(struct rb4xx_cpld *cpld, const void *tx_buf,
unsigned int len)
{
struct spi_message m;
struct spi_transfer t = {
.tx_buf = tx_buf,
.len = len,
};

spi_message_init(&m);
spi_message_add_tail(&t, &m);
return spi_sync(cpld->spi, &m);
}

The above function is used to send data to the cpld.
I want to send a command which tells the cpld to power up or down some components
like the radio transceiver.

My question is which part of the cpld_spi_cmd.ld




NEXT




<s> void sata_oxnas_thaw_host(struct ata_port *ap)
{
struct sata_oxnas_host_priv *hd = ap->host->private_data;

DPRINTK("ENTER\n");
hd->port_in_eh &= ~BIT(ap->port_no);
smp_wmb();
}

The above function is used to thaw a disconnected host (when the port is down)
and
start to communicate to the port. This is done at the end of the device_eh function
when all the ports
have been scanned and their status changed to




NEXT




<s> rtk_api_ret_t rtk_stat_logging_counterCfg_set(rtk_uint32 idx, rtk_logging_counter_mode_t mode, rtk_logging_counter_type_t type)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(idx > RTL8367C_MIB_MAX_LOG_CNT_IDX)
return RT_ERR_OUT_OF_RANGE;

if((idx % 2) == 1)
return RT_ERR_INPUT;

if(mode >= LOGGING_MODE_END)
return RT_ERR_OUT_OF_RANGE;

if(type >= LOGGING_TYPE_END)
return RT_ERR_OUT_OF_RANGE;

if((retVal = rtl8367c_setAsicMIBsLoggingType((idx / 2), (rtk_uint32)type)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_setAsicMIBsLoggingMode((idx / 2), (rtk_uint32)mode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set a logging counter.

/* Set a logging counter */
rtk_api_ret_t rtk_stat_logging_counterCfg_get(rtk_uint32 *mode, rtk_uint32 *




NEXT




<s> static void rb4xx_nand_cmd_ctrl(struct nand_chip *chip, int dat,
unsigned int ctrl)
{
struct rb4xx_nand *nand = chip->priv;
struct rb4xx_cpld *cpld = nand->cpld;
u8 data = dat;

if (ctrl & NAND_CTRL_CHANGE) {
gpiod_set_value_cansleep(nand->cle, !!(ctrl & NAND_CLE));
gpiod_set_value_cansleep(nand->ale, !!(ctrl & NAND_ALE));
gpiod_set_value_cansleep(nand->nce,  !(ctrl & NAND_NCE));
}

if (dat != NAND_CMD_NONE)
cpld->write_nand(cpld, &data, 1);
}

The above function is used to write the NAND command register and control lines. This function uses pointers instead of direct access for GPIO control.

I have been doing work on NAND flash recently and had a look at their driver and saw the function above. I checked




NEXT




<s> static DEFINE_SPINLOCK(ssb_fbs_lock);
static struct list_head ssb_fbs_list = LIST_HEAD_INIT(ssb_fbs_list);

int ssb_get_fallback_sprom(struct ssb_bus *bus, struct ssb_sprom *out)
{
struct ssb_fbs *pos;
u32 pci_bus, pci_dev;

if (bus->bustype != SSB_BUSTYPE_PCI)
return -ENOENT;

pci_bus = bus->host_pci->bus->number;
pci_dev = PCI_SLOT(bus->host_pci->devfn);

list_for_each_entry(pos, &ssb_fbs_list, list) {
if (pos->pci_bus != pci_bus ||
pos->pci_dev != pci_dev)
continue;

if (pos->devid_override)
bus->host_pci->device = pos->sprom.dev_id;

memcpy(out, &pos->sprom, sizeof(struct ssb_sprom));
dev_info(pos->dev, "requested by [%x:%x]",
pos->pci_bus, pos->pci_dev);

return 0;
}

pr_err("unable to fill SPROM for [%x:%x]\n", pci_bus, pci_dev);

return -EINVAL;
}

The above function is used to fill the device sprom data structures for legacy spi devices at time of initialization. This will be called only once after the chip is initialized.

```
int ssb_get_fallback_sprom(struct ssb_




NEXT




<s> static int mt7621_nfc_remove(struct platform_device *pdev)
{
struct mt7621_nfc *nfc = platform_get_drvdata(pdev);
struct nand_chip *nand = &nfc->nand;
struct mtd_info *mtd = nand_to_mtd(nand);

mtk_bmt_detach(mtd);
mtd_device_unregister(mtd);
nand_cleanup(nand);
clk_disable_unprepare(nfc->nfi_clk);

return 0;
}

The above function is used to remove the NFC device from the platform
device subsystem. It mainly consists of three parts:

1. Detaching the NFC device from the BMT device
2. Unregistering the MTD device
3. Cleaning




NEXT




<s> static AT91S_DataFlashStatus AT91F_WriteBufferToMain (
AT91PS_DataFlash pDataFlash,
unsigned char BufferCommand,
unsigned int dest )
{
int cmdsize;
/* Test if the buffer command is correct */
if ((BufferCommand != DB_BUF1_PAGE_PGM) &&
(BufferCommand != DB_BUF1_PAGE_ERASE_PGM) &&
(BufferCommand != DB_BUF2_PAGE_PGM) &&
(BufferCommand != DB_BUF2_PAGE_ERASE_PGM) )
return AT91C_DATAFLASH_BAD_COMMAND;

/* no data to transmit or receive */
pDataFlash->pDataFlashDesc->tx_data_size = 0;

cmdsize = 4;
if (pDataFlash->pDevice->pages_number >= 16384)
cmdsize = 5;
/* Send the command to the dataflash */
return(AT91F_DataFlashSendCommand (pDataFlash, BufferCommand, cmdsize, dest));
}

The above function is used to write the data from RAM to M25P80.
AT91F_WriteBufferToMain is called with the DB[x]_PAGE_PGM  or DB[x]_PAGE_ERASE_PGM




NEXT




<s> mtdsplit_jimage_parse_generic(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
return __mtdsplit_parse_jimage(master, pparts, data,
jimage_verify_default);
}

The above function is used to parse the information included in a NAND
flash chip mounted on the board from the header of the image file. In
the file system of the board, the header is in the form of a text
file, and its format is shown as




NEXT




<s> int spi_nor_read_id(void)
{
int ret;

const uint8_t tx_buf[1] = {CMD_READ_ID};
uint8_t rx_buf[3] = {};
struct spi_transfer t[2] = {{
.tx_buf = tx_buf,
.rx_buf = NULL,
.len = sizeof(tx_buf),
}, {
.tx_buf = NULL,
.rx_buf = rx_buf,
.len = sizeof(rx_buf),
}};

ret = spi_xfer(t, ARRAY_SIZE(t));
if (ret) {
puts("SPI transfer failed\n");
return ret;
}

puts("Flash JECED ID: ");
put_array(rx_buf, sizeof(rx_buf));

return 0;
}

The above function is used to read the JECED ID of the Flash device connected to SPI.</s>




NEXT




<s> static bool aw9523_writeable_reg(struct device *dev, unsigned int reg)
{
return !aw9523_is_reg_hole(reg) && reg != AW9523_REG_CHIPID;
}

The above function is used to check writeable register in aw9523.

The below code will change the data of 0x10 register to 0x22.

struct aw952x_platform_data pdata = ;




NEXT




<s> static int rtc_release(UNUSED struct inode *inode, UNUSED struct file *filp)
{
/* No need for locking here. */
rtc_status &= ~RTC_IS_OPEN;
return 0;
}

The above function is used to close an open file. It sets the rtc_status value
to clear the "isOpen" flag (RTC_IS_OPEN, set in rtc_open()). Note that, however,
because rtc_release() does




NEXT




<s> void write_pcap_header(FILE *o)
{
pcap_hdr_t ghdr = {
.magic_number  = 0xa1b2c3d4,
.version_major = 2,
.version_minor = 4,
.thiszone      = 0,
.sigfigs       = 0,
.snaplen       = 0xFFFF,
.network       = DLT_IEEE802_11_RADIO
};

fwrite(&ghdr, 1, sizeof(ghdr), o);
}

The above function is used to write  the pcap header and contains the value as mentioned above.

void write_eth_header(FILE *o, unsigned char *src, unsigned char *dest)

{
unsigned char *ethhdr;
size_




NEXT




<s> int __init psb6970_init(void)
{
phy_register_fixup_for_id(PHY_ANY_ID, psb6970_fixup);
return phy_driver_register(&psb6970_driver, THIS_MODULE);
}

The above function is used to initialize the psb6970 PHY and register the required PHY driver.

# PHY driver¶

The PHY driver is the layer that defines the PHY interaction in Linux. On a PCIe connection, we




NEXT




<s> int on_key_esc(WINDOW *win)
{
int key;
int key2;
int key3;

nodelay(win, TRUE);
keypad(win, FALSE);
key = wgetch(win);
key2 = wgetch(win);
do {
key3 = wgetch(win);
} while (key3 != ERR);
nodelay(win, FALSE);
keypad(win, TRUE);
if (key == KEY_ESC && key2 == ERR)
return KEY_ESC;
else if (key != ERR && key != KEY_ESC && key2 == ERR)
ungetch(key);

return -1;
}

The above function is used to determine if the user pressed the Escape key and
if so, what happens next is up to the application developer.

The Escape key (the key is used to exit any textmode command or in DOS, a
program)




NEXT




<s> static void rtl931x_led_init(struct rtl838x_switch_priv *priv)
{
u64 pm_copper = 0, pm_fiber = 0;
struct device_node *node;

pr_info("%s called\n", __func__);
node = of_find_compatible_node(NULL, NULL, "realtek,rtl9300-leds");
if (!node) {
pr_info("%s No compatible LED node found\n", __func__);
return;
}

for (int i = 0; i < priv->cpu_port; i++) {
int pos = (i << 1) % 32;
u32 set;
u32 v;

sw_w32_mask(0x3 << pos, 0, RTL931X_LED_PORT_FIB_SET_SEL_CTRL(i));
sw_w32_mask(0x3 << pos, 0, RTL931X_LED_PORT_COPR_SET_SEL_CTRL(i));

if (!priv->ports[i].phy)
continue;

v = 0x1; /* Found on the EdgeCore, but we do not have any HW description */
sw_w32_mask(0x3 << pos, v << pos, RTL931X_LED_PORT_NUM_CTRL(i));

if (priv->ports[i].phy_is_integrated)
pm_fiber |= BIT_ULL(i);
else
pm_copper |= BIT_ULL(i);

set = priv->ports[i].led_set;
sw_w32_mask(0, set << pos, RTL931X_LED_PORT_COPR_SET_SEL_CTRL(i));
sw_w32_mask(0, set << pos, RTL931X_LED_PORT_FIB_SET_SEL_CTRL(i));
}

for (int i = 0; i < 4; i++) {
const __be32 *led_set;
char set_name[9];
u32 setlen;
u32 v;

sprintf(set_name, "led_set%d", i);
pr_info(">%s<\n", set_name);
led_set = of_get_property(node, set_name, &setlen);
if (!led_set || setlen != 16)
break;
v = be32_to_cpup(led_set) << 16 | be32_to_cpup(led_set + 1);
sw_w32(v, RTL931X_LED_SET0_0_CTRL - 4 - i * 8);
v = be32_to_cpup(led_set + 2) << 16 | be32_to_cpup(led_set + 3);
sw_w32(v, RTL931X_LED_SET0_0_CTRL - i * 8);
}

/* Set LED mode to serial (0x1) */
sw_w32_mask(0x3, 0x1, RTL931X_LED_GLB_CTRL);

rtl839x_set_port_reg_le(pm_copper, RTL931X_LED_PORT_COPR_MASK_CTRL);
rtl839x_set_port_reg_le(pm_fiber, RTL931X_LED_PORT_FIB_MASK_CTRL);
rtl839x_set_port_reg_le(pm_copper | pm_fiber, RTL931X_LED_PORT_COMBO_MASK_CTRL);

for (int i = 0; i < 32; i++)
pr_info("%s %08x: %08x\n",__func__, 0xbb000600 + i * 4, sw_r32(0x0600 + i * 4));
}

The above function is used to set the LED settings on rtl931x chips. This function will be called from platform data.</s>




NEXT




<s> void rtl9300_sds_rxcal_leq_offset_manual(u32 sds_num, bool manual, u32 offset)
{
if (manual) {
rtl9300_sds_field_w(sds_num, 0x2e, 0x17, 6, 2, offset);
} else {
rtl9300_sds_field_w(sds_num, 0x2e, 0x17, 6, 2, offset);
mdelay(1);
}
}

The above function is used to set the LEQ-offset manually and it has a little bit trick, since you can set the LEQ-offset via bit9 and bit10 in register 0x2e by 0x02, but since it has a




NEXT




<s> void ifx_ptm_get_fw_ver(unsigned int *major, unsigned int *mid, unsigned int *minor)
{
ASSERT(major != NULL, "pointer is NULL");
ASSERT(minor != NULL, "pointer is NULL");

if ( *(volatile unsigned int *)FW_VER_ID_NEW == 0 ) {
*major = FW_VER_ID->major;
*mid   = ~0;
*minor = FW_VER_ID->minor;
}
else {
*major = FW_VER_ID_NEW->major;
*mid   = FW_VER_ID_NEW->middle;
*minor = FW_VER_ID_NEW->minor;
}
}

The above function is used to get the firmware version. The firmware version is encoded in memory. If the version of the firmware is changed from

  - major version
  - minor version

the whole memory mapping changes.

With the current version




NEXT




<s> mt7530_apply_mapping(struct mt7530_priv *mt7530, struct mt7530_mapping *map)
{
int i = 0;

for (i = 0; i < MT7530_NUM_PORTS; i++)
mt7530->port_entries[i].pvid = map->pvids[i];

for (i = 0; i < MT7530_NUM_VLANS; i++) {
mt7530->vlan_entries[i].member = map->members[i];
mt7530->vlan_entries[i].etags = map->etags[i];
mt7530->vlan_entries[i].vid = map->vids[i];
}
}

The above function is used to apply vlan mapping to mt7530 chip
The function is executed at driver init (mii probe success)
The function above does not use a struct to maintain the vlan info, so it’s only used with mt7




NEXT




<s> static inline void reset_ppe(struct platform_device *pdev);
static inline void init_pdma(void);
static inline void init_mailbox(void);
static inline void init_atm_tc(void);
static inline void clear_share_buffer(void);

#define IFX_PMU_MODULE_PPE_SLL01  BIT(19)
#define IFX_PMU_MODULE_PPE_TC     BIT(21)
#define IFX_PMU_MODULE_PPE_EMA    BIT(22)
#define IFX_PMU_MODULE_PPE_QSB    BIT(18)
#define IFX_PMU_MODULE_AHBS       BIT(13)
#define IFX_PMU_MODULE_DSL_DFE    BIT(9)


static inline void init_pmu(void)
{
ltq_pmu_enable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_AHBS |
IFX_PMU_MODULE_DSL_DFE);

}

The above function is used to set the power down mode by calling

static inline void init_pdma(void)
{
/* disable pdma */
if_lmac0203_regs.pdmaprocctl &= 0xfffffffe;




NEXT




<s> ret_t rtl8367c_setAsicMLDv2Opeartion(rtk_uint32 port, rtk_uint32 mldv2_op)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(mldv2_op >= PROTOCOL_OP_END)
return RT_ERR_INPUT;

/* MLDv2 operation */
if(port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_MLDv2_OP_MASK, mldv2_op);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_MLDv2_OP_MASK, mldv2_op);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set the value of MLDv2 operation used to the selected port. It enables the specified MLDv2 operation function. The supported MLDv2 operation includes:

- 0x0: Forward MLDv1 and




NEXT




<s> static int do_unset(nvram_handle_t *nvram, const char *var)
{
return nvram_unset(nvram, var);
}

The above function is used to remove an entry from nvram.

This is done by calling the nvram_unset function on nvram and then returning the value.

The function takes two arguments: the nvram_handle_t structure that represents the nv




NEXT




<s> rtk_api_ret_t rtk_led_serialModePortmask_get(rtk_led_serialOutput_t *pOutput, rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(pOutput == NULL)
return RT_ERR_NULL_POINTER;

if(pPortmask == NULL)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLedSerialOutput((rtk_uint32 *)pOutput, &pmask))!=RT_ERR_OK)
return retVal;

if((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to assign the LED_SERIAL output channel to the specified portmask.

Parameters:
pOutput: LED_SERIAL output channel.
pPortmask: portmask for the port configuration corresponding to the LED_SERIAL output channel.




NEXT




<s> ret_t rtl8367c_getAsicIpMulticastVlanLeaky(rtk_uint32 port, rtk_uint32 *ptr_enabled)
{
ret_t  retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IPMCAST_VLAN_LEAKY, port, ptr_enabled);

return retVal;
}

The above function is used to set/get a bit of an 8367C register. The register is identified by the register number and the bit is identified in relation to the register word defined by RTL8367C_REG_xxx.






NEXT




<s> rtk_api_ret_t rtk_storm_bypass_set(rtk_storm_bypass_t type, rtk_enable_t enable)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;
rtk_uint32 tmp;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= BYPASS_END)
return RT_ERR_INPUT;

if (enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if (type >= 0 && type <= BYPASS_UNDEF_GARP_2F)
{
if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.discard_storm_filter = enable;

if ((retVal = rtl8367c_setAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;
}
else if(type == BYPASS_IGMP)
{
if ((retVal = rtl8367c_setAsicIGMPBypassStormCTRL(enable)) != RT_ERR_OK)
return retVal;
}
else if (type == BYPASS_CDP)
{
if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.discard_storm_filter = enable;

if ((retVal = rtl8367c_setAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (type  == BYPASS_CSSTP)
{
if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.discard_storm_filter = enable;

if ((retVal = rtl8367c_setAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (type  == BYPASS_LLDP)
{
if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.discard_storm_filter = enable;

if ((retVal = rtl8367c_setAsicRmaLldp(tmp, &rmacfg)) != RT_ERR_OK)
return retVal;
}
else
return RT_ERR_INPUT;

return RT_ERR_OK;
}

The above function is used to set Storm filter bypass enable for the specified Storm Bypass type

Parameters:

type (IN): Bypass type. The value ranges from RTK_STORM_BYPASS_UNDEF_GARP_2




NEXT




<s> const char *str_get(struct gstr *gs)
{
return gs->s;
}

The above function is used to determine and retrieve the string from the gstr variable.

In the code above, the str_get function is a user defined function that takes the gstr variable as an argument and returns the string associated with that variable. The gstr variable




NEXT




<s> void aes_encrypt (struct crypto_tfm *tfm, uint8_t *out, const uint8_t *in)
{
struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
ifx_deu_aes (ctx, out, in, NULL, AES_BLOCK_SIZE,
CRYPTO_DIR_ENCRYPT, 0);
}

The above function is used to encrypt a 16 byte block of data using AES. AES
requires that the data is always padded out to a 16 byte block, no matter how
much data is available, but it only returns 




NEXT




<s> machine_arch_initcall(firebox_t10, mpc85xx_common_publish_devices);

/*
* Called very early, device-tree isn't unflattened
*/
static int __init firebox_t10_probe(void)
{
if (of_machine_is_compatible("watchguard,firebox-t10"))
return 1;
return 0;
}

The above function is used to probe that the device is indeed the firebox t10.


### Loading the initcall

A link is added to the linux rc.order file and then linked to firebox_t10-init. Then




NEXT




<s> static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to read the LEDs status of
the device.

static u8 g_adsl_link = 0;
static u16 g_adsl_link_rate;

static u8 g_adsl_up




NEXT




<s> struct file *file_lookup(const char *name)
{
struct file *file;

for (file = file_list; file; file = file->next) {
if (!strcmp(name, file->name)) {
return file;
}
}

file = xmalloc(sizeof(*file));
memset(file, 0, sizeof(*file));
file->name = xstrdup(name);
file->next = file_list;
file_list = file;
return file;
}

The above function is used to create a new object by parsing a string.

However, I'm currently having some errors with it, and I'm a little bit lost on how to fix it. I know that it's trying to print strings that are




NEXT




<s> ar8xxx_sw_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
val->value.i = priv->vlan_id[val->port_vlan];
return 0;
}

The above function is used to retrieve the value of VLAN ID at a certain port. I have made it such that it is always zero. What is the difference between these 2 values?</s>




NEXT




<s> rtk_api_ret_t rtk_port_macStatus_get(rtk_port_t port, rtk_port_mac_ability_t *pPortstatus)
{
rtk_api_ret_t retVal;
rtl8367c_port_status_t status;
rtk_uint32 hsgsel;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pPortstatus)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortStatus(rtk_switch_port_L2P_get(port), &status)) != RT_ERR_OK)
return retVal;


pPortstatus->duplex    = status.duplex;
pPortstatus->link      = status.link;
pPortstatus->nway      = status.nway;
pPortstatus->txpause   = status.txpause;
pPortstatus->rxpause   = status.rxpause;

if( (retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, &hsgsel)) != RT_ERR_OK)
return retVal;

if( (rtk_switch_isHsgPort(port) == RT_ERR_OK) && (hsgsel == 1) )
pPortstatus->speed = PORT_SPEED_2500M;
else
pPortstatus->speed = status.speed;

return RT_ERR_OK;
}

The above function is used to get the ability status of a single port.

The following example code shows how to use it.

rtk_port_mac_ability_t PortAbility;
if(RT_ERR_OK !=
                         r




NEXT




<s> rtk_api_ret_t rtk_switch_portmask_P2L_get(rtk_uint32 physicalPortmask, rtk_portmask_t *pLogicalPmask)
{
rtk_uint32 log_port, phy_port;

if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(NULL == pLogicalPmask)
return RT_ERR_NULL_POINTER;

RTK_PORTMASK_CLEAR(*pLogicalPmask);

for(phy_port = halCtrl->min_phy_port; phy_port <= halCtrl->max_phy_port; phy_port++)
{
if(physicalPortmask & (0x0001 << phy_port))
{
log_port = rtk_switch_port_P2L_get(phy_port);
if(log_port != UNDEFINE_PORT)
{
RTK_PORTMASK_PORT_SET(*pLogicalPmask, log_port);
}
}
}

return RT_ERR_OK;
}

The above function is used to convert logical port to physical port. If logical port mask is valid, the corresponding physical port mask will be returned. Otherwise, the physical mask will be returned as logical mask is NULL pointer.

The physical port mask is not used in Ether




NEXT




<s> swconfig_list_attrs(struct sk_buff *skb, struct genl_info *info)
{
struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
const struct switch_attrlist *alist;
struct switch_dev *dev;
struct swconfig_callback cb;
int err = -EINVAL;
int i;

/* defaults */
struct switch_attr *def_list;
unsigned long *def_active;
int n_def;

dev = swconfig_get_dev(info);
if (!dev)
return -EINVAL;

switch (hdr->cmd) {
case SWITCH_CMD_LIST_GLOBAL:
alist = &dev->ops->attr_global;
def_list = default_global;
def_active = &dev->def_global;
n_def = ARRAY_SIZE(default_global);
break;
case SWITCH_CMD_LIST_VLAN:
alist = &dev->ops->attr_vlan;
def_list = default_vlan;
def_active = &dev->def_vlan;
n_def = ARRAY_SIZE(default_vlan);
break;
case SWITCH_CMD_LIST_PORT:
alist = &dev->ops->attr_port;
def_list = default_port;
def_active = &dev->def_port;
n_def = ARRAY_SIZE(default_port);
break;
default:
WARN_ON(1);
goto out;
}

memset(&cb, 0, sizeof(cb));
cb.info = info;
cb.fill = swconfig_dump_attr;
for (i = 0; i < alist->n_attr; i++) {
if (alist->attr[i].disabled)
continue;
cb.args[0] = i;
err = swconfig_send_multipart(&cb, (void *) &alist->attr[i]);
if (err < 0)
goto error;
}

/* defaults */
for (i = 0; i < n_def; i++) {
if (!test_bit(i, def_active))
continue;
cb.args[0] = SWITCH_ATTR_DEFAULTS_OFFSET + i;
err = swconfig_send_multipart(&cb, (void *) &def_list[i]);
if (err < 0)
goto error;
}
swconfig_put_dev(dev);

if (!cb.msg)
return 0;

return genlmsg_reply(cb.msg, info);

error:
if (cb.msg)
nlmsg_free(cb.msg);
out:
swconfig_put_dev(dev);
return err;
}

The above function is used to list all of the supported attributes in their respective attributes lists. This attribute list is basically a list of struct switch_attributes which is defined like this

swswitch_core::switch_attrs::struct_switch_attribute::attributes_list





NEXT




<s> static int __init rtc_init(void)
{
int cr1;

platform_detect();

if (sda_index == scl_index) {
printk(KERN_ERR "RTC-RV5C386A: unrecognized platform!\n");
return -ENODEV;
}

i2c_init();

/*
* Switch RTC to 24h mode
*/
spin_lock_irq(&rtc_lock);
i2c_start();
i2c_outb(RTC_I2C_ADDRESS | I2C_WRITE_MASK);
i2c_outb(0xE4); /* start at address 0xE, transmission mode 4 */
cr1 = i2c_inb(I2C_NAK);
i2c_stop();
spin_unlock_irq(&rtc_lock);
if ((cr1 & RTC_24HOUR_MODE_MASK) == 0) {
/* RTC is running in 12h mode */
printk(KERN_INFO "rtc.o: switching to 24h mode\n");
spin_lock_irq(&rtc_lock);
i2c_start();
i2c_outb(RTC_I2C_ADDRESS | I2C_WRITE_MASK);
i2c_outb(0xE0);
i2c_outb(cr1 | RTC_24HOUR_MODE_MASK);
i2c_stop();
spin_unlock_irq(&rtc_lock);
}

misc_register(&rtc_dev);

printk(KERN_INFO "RV5C386A Real Time Clock Driver loaded\n");

return 0;
}

The above function is used to register the misc driver. RV5C386A has a
maximum of 256 bytes of flash area that needs to be used to store all
the system parameters and system data. So, all the non volatile




NEXT




<s> ar8xxx_sw_get_mirror_tx_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
val->value.i = priv->mirror_tx;
return 0;
}

The above function is used to get the value of mirror_tx. It
returns zero if the value is successfully returned to the caller.

The value of mirror_tx is passed to the ar8xxx_sw_set_mirror_tx_enable()





NEXT




<s> static int __init panda_probe(void)
{
if (of_machine_is_compatible("ocedo,panda"))
return 1;
return 0;
}

The above function is used to determine whether the board is PANDA.
If board is PANDA, return 1, which means it will invoke the probe routine of PANDA driver.
If not PANDA, return 0 means that the rest of




NEXT




<s> IFX_MEI_MailboxWrite (DSL_DEV_Device_t * pDev, u16 * msgsrcbuffer,
u16 msgsize)
{
int i;
u32 arc_mailbox_status = 0x0;
u32 temp = 0;
DSL_DEV_MeiError_t meiMailboxError = DSL_DEV_MEI_ERR_SUCCESS;

//      Write to mailbox
meiMailboxError =
IFX_MEI_DMAWrite (pDev, MEI_TO_ARC_MAILBOX, (u32 *) msgsrcbuffer, msgsize / 2);
meiMailboxError =
IFX_MEI_DMAWrite (pDev, MEI_TO_ARC_MAILBOXR, (u32 *) (&temp), 1);

//      Notify arc that mailbox write completed
DSL_DEV_PRIVATE(pDev)->cmv_waiting = 1;
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_ME2ARC_INT, MEI_TO_ARC_MSGAV);

i = 0;
while (i < WHILE_DELAY) {	// wait for ARC to clear the bit
IFX_MEI_LongWordReadOffset (pDev, (u32) ME_ME2ARC_INT, &arc_mailbox_status);
if ((arc_mailbox_status & MEI_TO_ARC_MSGAV) != MEI_TO_ARC_MSGAV)
break;
i++;
if (i == WHILE_DELAY) {
IFX_MEI_EMSG (">>> Timeout waiting for ARC to clear MEI_TO_ARC_MSGAV!!!"
" MEI_TO_ARC message size = %d DWORDs <<<\n", msgsize/2);
meiMailboxError = DSL_DEV_MEI_ERR_FAILURE;
}
}

return meiMailboxError;
}

The above function is used to write to Mail-Box to send DLL information to arc.</s>




NEXT




<s> static int aw9523_gpio_get_multiple(struct gpio_chip *chip,
unsigned long *mask,
unsigned long *bits)
{
struct aw9523 *awi = gpiochip_get_data(chip);
u8 m, state = 0;
int ret;

mutex_lock(&awi->i2c_lock);

/* Port 0 (gpio 0-7) */
m = *mask & U8_MAX;
if (m) {
ret = _aw9523_gpio_get_multiple(awi, 0, &state, m);
if (ret)
goto out;
}
*bits = state;

/* Port 1 (gpio 8-15) */
m = (*mask >> 8) & U8_MAX;
if (m) {
ret = _aw9523_gpio_get_multiple(awi, AW9523_PINS_PER_PORT,
&state, m);
if (ret)
goto out;

*bits |= (state << 8);
}
out:
mutex_unlock(&awi->i2c_lock);
return ret;
}

The above function is used to get the status of 2 GPIOs.
First the function get the status of gpio 0-7, then it get the status of
gpio 8-15 and return.

The definition of mask and bits as follow




NEXT




<s> static int psb6970_set_ports(struct switch_dev *dev, struct switch_val *val)
{
struct psb6970_priv *priv = to_psb6970(dev);
u8 *vt = &priv->vlan_table[val->port_vlan];
int i, j;

*vt = 0;
for (i = 0; i < val->len; i++) {
struct switch_port *p = &val->value.ports[i];

if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED))
priv->vlan_tagged |= (1 << p->id);
else {
priv->vlan_tagged &= ~(1 << p->id);
priv->pvid[p->id] = val->port_vlan;

/* make sure that an untagged port does not
* appear in other vlans */
for (j = 0; j < PSB6970_MAX_VLANS; j++) {
if (j == val->port_vlan)
continue;
priv->vlan_table[j] &= ~(1 << p->id);
}
}

*vt |= 1 << p->id;
}
return 0;
}

The above function is used to set ports on the switch</s>




NEXT




<s> static void fe_free_dma(struct fe_priv *priv)
{
fe_clean_tx(priv);
fe_clean_rx(priv);
}

The above function is used to clean the DMA buffers and TX queues after
a reset. It does not actually free the memory used by those buffers or
queues. This is done in fe_free_all. So why not just call fe_free_all





NEXT




<s> static void _smi_writeBit(rtk_uint16 signal, rtk_uint32 bitLen)
{
for( ; bitLen > 0; bitLen--)
{
CLK_DURATION(DELAY);

/* prepare data */
if ( signal & (1<<(bitLen-1)) )
{
GPIO_DATA_SET(smi_SDA, 1);
}
else
{
GPIO_DATA_SET(smi_SDA, 0);
}
CLK_DURATION(DELAY);

/* clocking */
GPIO_DATA_SET(smi_SCK, 1);
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SCK, 0);
}
}

The above function is used to implement the writing bit for SM interface.</s>




NEXT




<s> static int rtl8214fc_resume(struct phy_device *phydev)
{
if (rtl8214fc_media_is_fibre(phydev)) {
rtl8214fc_power_set(phydev, PORT_MII, false);
rtl8214fc_power_set(phydev, PORT_FIBRE, true);
} else {
rtl8214fc_power_set(phydev, PORT_FIBRE, false);
rtl8214fc_power_set(phydev, PORT_MII, true);
}

return 0;
}

The above function is used to resume the ethernet adapter on an OMAC2 device. The first part of the function sets the hardware to detect that it has woken up from hibernation, and the last part enables the ethernet transceivers.





NEXT




<s> int rtl839x_write_phy(u32 port, u32 page, u32 reg, u32 val)
{
u32 v;
int err = 0;

val &= 0xffff;
if (port > 63 || page > 4095 || reg > 31)
return -ENOTSUPP;

/* Take bug on RTL839x Rev <= C into account */
if (port >= RTL839X_CPU_PORT)
return -EIO;

mutex_lock(&smi_lock);

/* Set PHY to access */
rtl839x_set_port_reg_le(BIT_ULL(port), RTL839X_PHYREG_PORT_CTRL);

sw_w32_mask(0xffff0000, val << 16, RTL839X_PHYREG_DATA_CTRL);

v = reg << 5 | page << 10 | ((page == 0x1fff) ? 0x1f : 0) << 23;
sw_w32(v, RTL839X_PHYREG_ACCESS_CTRL);

sw_w32(0x1ff, RTL839X_PHYREG_CTRL);

v |= BIT(3) | 1; /* Write operation and execute */
sw_w32(v, RTL839X_PHYREG_ACCESS_CTRL);

err = rtl839x_smi_wait_op(100000);
if (err)
goto errout;

if (sw_r32(RTL839X_PHYREG_ACCESS_CTRL) & 0x2)
err = -EIO;

errout:
mutex_unlock(&smi_lock);

return err;
}

The above function is used to write the value to phy register.

Then, the main procedure of the pcie hotplug to pcie pcie reconfigure is as follows：

When pcie hotplug occurs, first to get the device id of the newly




NEXT




<s> rx_handler_result_t trelay_handle_frame(struct sk_buff **pskb)
{
struct net_device *dev;
struct sk_buff *skb = *pskb;

dev = rcu_dereference(skb->dev->rx_handler_data);
if (!dev)
return RX_HANDLER_PASS;

if (skb->protocol == htons(ETH_P_PAE))
return RX_HANDLER_PASS;

skb_push(skb, ETH_HLEN);
skb->dev = dev;
skb_forward_csum(skb);
dev_queue_xmit(skb);

return RX_HANDLER_CONSUMED;
}

The above function is used to process all incoming packets that have the protocol 0x86DD(PAE) or 0x88CC(ERSPAN) on them. When a frame like this is received the function will strip the Ethertype checksum




NEXT




<s> static int bcm6328_pcie_read(struct pci_bus *bus, unsigned int devfn,
int where, int size, u32 *val)
{
struct bcm6328_pcie *priv = &bcm6328_pcie;
u32 data;
u32 reg = where & ~3;

if (!bcm6328_pcie_can_access(bus, devfn))
return PCIBIOS_DEVICE_NOT_FOUND;

if (bus->number == PCIE_BUS_DEVICE)
reg += PCIE_DEVICE_OFFSET;

data = __raw_readl(priv->base + reg);
*val = postprocess_read(data, where, size);

return PCIBIOS_SUCCESSFUL;
}

The above function is used to read a register value, and the value will be filtered through some logic.  It returns 0 (no error) if operation completed.

I'm curious as to what is "postprocess_read" and how does it affect the




NEXT




<s> rtk_api_ret_t rtk_qos_dscpRemarkEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/*for whole system function, the port value should be 0xFF*/
if (port != RTK_WHOLE_SYSTEM)
return RT_ERR_PORT_ID;

if ((retVal = rtl8367c_getAsicRemarkingDscpAbility(pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the DSCP Remark enable status of whole system, where the port value is RTK_WHOLE_SYSTEM.
If the returned enable value is 1, it means that the DSCP Remark is enabled; 




NEXT




<s> static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to set the tx link (DSL) and rx link (ATM) rates.

static unsigned int g_adsl_state[2] = {0};

The above parameter is used as a workaround for ATM-




NEXT




<s> int cfb_aes_decrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int dec_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = dec_bytes = walk.nbytes) && (walk.nbytes >= AES_BLOCK_SIZE)) {
dec_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_cfb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, dec_bytes, CRYPTO_DIR_DECRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

/* to handle remaining bytes < AES_BLOCK_SIZE */
if (walk.nbytes) {
ifx_deu_aes_cfb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, walk.nbytes, CRYPTO_DIR_DECRYPT, 0);
err = skcipher_walk_done(&walk, 0);
}

return err;
}

The above function is used to decrypt, if a non-block-aligned data is available which is less than AES_BLOCK_SIZE.

There is a problem in the above function which is discussed in detail below.

Let us assume we are given a




NEXT




<s> void spl_block_device_init(void)
{
ide_init();
}

The above function is used to initialize the ide block device, but it seems that this function is never called.
Ide_init() is used to initialize block devices and create ide devices.
The ide block device initialization routine contains two functions:
Ide init();





NEXT




<s> rtk_api_ret_t rtk_ptp_tpid_set(rtk_ptp_tpid_t outerId, rtk_ptp_tpid_t innerId)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((outerId>RTK_MAX_NUM_OF_TPID) ||(innerId>RTK_MAX_NUM_OF_TPID))
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicEavTpid(outerId, innerId)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the outer and inner TPID.
The outer TPID is the 16-bit TPID(VLAN_TPID) for packet which is out of IEEE 802.3 MAC. The outer




NEXT




<s> static int nct5104d_gpio_probe(struct platform_device *pdev)
{
int err;
int i;
struct nct5104d_sio *sio = pdev->dev.platform_data;
struct nct5104d_gpio_data *data;

data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
if (!data)
return -ENOMEM;

switch (sio->type) {
case nct5104d:
data->nr_bank = ARRAY_SIZE(nct5104d_gpio_bank);
data->bank = nct5104d_gpio_bank;
break;
default:
return -ENODEV;
}
data->sio = sio;

platform_set_drvdata(pdev, data);

/* For each GPIO bank, register a GPIO chip. */
for (i = 0; i < data->nr_bank; i++) {
struct nct5104d_gpio_bank *bank = &data->bank[i];

bank->chip.parent = &pdev->dev;
bank->data = data;

err = gpiochip_add(&bank->chip);
if (err) {
dev_err(&pdev->dev,
"Failed to register gpiochip %d: %d\n",
i, err);
goto err_gpiochip;
}
}

return 0;

err_gpiochip:
for (i = i - 1; i >= 0; i--) {
struct nct5104d_gpio_bank *bank = &data->bank[i];

gpiochip_remove (&bank->chip);
}

return err;
}

The above function is used to register the gpio driver based on the GPIO configuration of the device. In addition, since GPIO chip sharing is allowed, there are more GPIO configuration options for the device to selectively set, rather than using the entire driver to register and initialize.





NEXT




<s> static void rtl839x_setup_notify_ring_buffer(struct rtl838x_eth_priv *priv)
{
struct notify_b *b = priv->membase + sizeof(struct ring_b);

for (int i = 0; i < NOTIFY_BLOCKS; i++)
b->ring[i] = KSEG1ADDR(&b->blocks[i]) | 1 | (i == (NOTIFY_BLOCKS - 1) ? WRAP : 0);

sw_w32((u32) b->ring, RTL839X_DMA_IF_NBUF_BASE_DESC_ADDR_CTRL);
sw_w32_mask(0x3ff << 2, 100 << 2, RTL839X_L2_NOTIFICATION_CTRL);

/* Setup notification events */
sw_w32_mask(0, 1 << 14, RTL839X_L2_CTRL_0); /* RTL8390_L2_CTRL_0_FLUSH_NOTIFY_EN */
sw_w32_mask(0, 1 << 12, RTL839X_L2_NOTIFICATION_CTRL); /* SUSPEND_NOTIFICATION_EN */

/* Enable Notification */
sw_w32_mask(0, 1 << 0, RTL839X_L2_NOTIFICATION_CTRL);
priv->lastEvent = 0;
}

The above function is used to initialize the
Notify Events.</s>




NEXT




<s> uc_bpf_map_iter_next_int(uc_vm_t *vm, size_t nargs)
{
struct uc_bpf_map_iter *iter = uc_fn_thisval("bpf.map_iter");
uint64_t intval;
uc_value_t *rv;

if (!iter->has_next)
return NULL;

if (iter->key_size == 4)
intval = *(uint32_t *)iter->key;
else if (iter->key_size == 8)
intval = *(uint64_t *)iter->key;
else
return NULL;

rv = ucv_int64_new(intval);
iter->has_next = !bpf_map_get_next_key(iter->fd, &iter->key, &iter->key);

return rv;
}

The above function is used to iterate through the elements of a bpf map in uc_bpfvm. It has access to map elements, their keys and values. It is used by uc_bpfcall_map_ops functions to perform actions (e




NEXT




<s> static bool nmbm_block_walk(struct nmbm_instance *ni, bool ascending,
uint32_t ba, uint32_t *nba, int32_t count,
int32_t limit)
{
if (ascending)
return nmbm_block_walk_asc(ni, ba, nba, count, limit);

return nmbm_block_walk_desc(ni, ba, nba, count, limit);
}

The above function is used to walk blocks, from the starting point (ba, specified
in 32-bit binary address with the high value set to zero). The number of blocks is
read from the count variable and the destination buffer is set by the nba variable




NEXT




<s> void mt7620_handle_carrier(struct fe_priv *priv)
{
if (!priv->phy)
return;

if (mt7620_has_carrier(priv))
netif_carrier_on(priv->netdev);
else
netif_carrier_off(priv->netdev);
}

The above function is used to update carrier status, however, mt7620_has_carrier()
always return false, netif_carrier_off() will be invoked, so eth0 goes DOWN.

Then, the code is changed in




NEXT




<s> int pcibios_plat_dev_init(struct pci_dev *pci_dev)
{
return PCIBIOS_SUCCESSFUL;
}

The above function is used to initialize the PCI bus and to do some
PCI I/O operation initializations. We need to check whether the CPU
supports this function or not. If it supports, then we just call the
above function instead of initializing PCI




NEXT




<s> static int conf_touch_dep(const char *name)
{
int fd, ret;
char *d;

/* check overflow: prefix + name + '\0' must fit in buffer. */
if (depfile_prefix_len + strlen(name) + 1 > sizeof(depfile_path))
return -1;

d = depfile_path + depfile_prefix_len;
strcpy(d, name);

/* Assume directory path already exists. */
fd = open(depfile_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
if (fd == -1) {
if (errno != ENOENT)
return -1;

ret = make_parent_dir(depfile_path);
if (ret)
return ret;

/* Try it again. */
fd = open(depfile_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
if (fd == -1)
return -1;
}
close(fd);

return 0;
}

The above function is used to create a dependency file for modules that
are built using the CONFIG_CMDLINE_MODULE option. When built this
way you can specify the configuration options using a command line.
This is useful for the kernel upgrade script which needs to
update




NEXT




<s> static void env_add(const char *name, const char *value)
{
struct env *e;

e = xmalloc(sizeof(*e));
e->name = xstrdup(name);
e->value = xstrdup(value);

list_add_tail(&e->node, &env_list);
}

The above function is used to add environment variables to list, and when the code encounters a case like

static void env_add(const char *name, const char *value)
{
if (strcmp(name, "FOO1") == 0




NEXT




<s> hostapd_bss_wps_status(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
int rc;
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);

blob_buf_init(&b, 0);

blobmsg_add_string(&b, "pbc_status", pbc_status_enum_str(hapd->wps_stats.pbc_status));
blobmsg_add_string(&b, "last_wps_result",
(hapd->wps_stats.status == WPS_STATUS_SUCCESS ?
"Success":
(hapd->wps_stats.status == WPS_STATUS_FAILURE ?
"Failed" : "None")));

/* If status == Failure - Add possible Reasons */
if(hapd->wps_stats.status == WPS_STATUS_FAILURE &&
hapd->wps_stats.failure_reason > 0)
blobmsg_add_string(&b, "reason", wps_ei_str(hapd->wps_stats.failure_reason));

if (hapd->wps_stats.status)
blobmsg_printf(&b, "peer_address", MACSTR, MAC2STR(hapd->wps_stats.peer_addr));

ubus_send_reply(ctx, req, b.head);

return 0;
}

The above function is used to get the list of Peer address, PBC status, current WPS status.</s>




NEXT




<s> arc_ping_testing (DSL_DEV_Device_t *pDev)
{
#define MEI_PING 0x00000001
uint32_t wr_mbox[10], rd_mbox[10];
int i;

for (i = 0; i < 10; i++) {
wr_mbox[i] = 0;
rd_mbox[i] = 0;
}

FX_MEI_DMSG("send ping msg\n");
wr_mbox[0] = MEI_PING;
WriteMbox (&wr_mbox[0], 10);

while (got_int == 0) {
MEI_WAIT (100);
}

IFX_MEI_DMSG("send start event\n");
got_int = 0;

wr_mbox[0] = 0x4;
wr_mbox[1] = 0;
wr_mbox[2] = 0;
wr_mbox[3] = (uint32_t) 0xf5acc307e;
wr_mbox[4] = 5;
wr_mbox[5] = 2;
wr_mbox[6] = 0x1c000;
wr_mbox[7] = 64;
wr_mbox[8] = 0;
wr_mbox[9] = 0;
WriteMbox (&wr_mbox[0], 10);
DSL_ENABLE_IRQ (pDev->nIrq[IFX_DFEIR]);
//printk("IFX_MEI_MailboxWrite ret=%d\n",i);
IFX_MEI_LongWordWriteOffset (&dsl_devices[0],
(u32) ME_ME2ARC_INT,
MEI_TO_ARC_MSGAV);
IFX_MEI_DMSG("sleeping\n");
while (1) {
if (got_int > 0) {

if (got_int > 3)
IFX_MEI_DMSG("got_int >>>> 3\n");
else
IFX_MEI_DMSG("got int = %d\n", got_int);
got_int = 0;
//schedule();
DSL_ENABLE_IRQ (pDev->nIrq[IFX_DFEIR]);
}
//mbox_read(&rd_mbox[0],6);
MEI_WAIT (100);
}
return 0;
}

The above function is used to receive a start event message on the MEOC interface. It is invoked
from the interrupt handler. All we do in this function is to send this message to
arc and sleep in wait for other messages.

As seen from this test




NEXT




<s> MODULE_DEVICE_TABLE(of, rtl8231_gpio_of_match);

static int rtl8231_gpio_probe(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct device_node *np = dev->of_node;
struct rtl8231_gpios *gpios;
int err;

pr_info("Probing RTL8231 GPIOs\n");

if (!np) {
dev_err(&pdev->dev, "No DT found\n");
return -EINVAL;
}

gpios = devm_kzalloc(dev, sizeof(*gpios), GFP_KERNEL);
if (!gpios)
return -ENOMEM;

gpios->id = soc_info.id;
if (soc_info.family == RTL8380_FAMILY_ID) {
gpios->ext_gpio_indrt_access = RTL838X_EXT_GPIO_INDRT_ACCESS;
}

if (soc_info.family == RTL8390_FAMILY_ID) {
gpios->ext_gpio_indrt_access = RTL839X_EXT_GPIO_INDRT_ACCESS;
}

err = of_property_read_u32(np, "indirect-access-bus-id", &gpios->smi_bus_id);
if (!err && gpios->smi_bus_id > RTL8231_SMI_BUS_ID_MAX)
err = -EINVAL;

if (err) {
dev_err(dev, "invalid or missing indirect-access-bus-id\n");
return err;
}

err = rtl8231_init(gpios);
if (err) {
dev_err(dev, "no device found at bus address %d\n", gpios->smi_bus_id);
return err;
}

gpios->dev = dev;
gpios->gc.base = -1;
gpios->gc.ngpio = 37;
gpios->gc.label = "rtl8231";
gpios->gc.parent = dev;
gpios->gc.owner = THIS_MODULE;
gpios->gc.can_sleep = true;

gpios->gc.direction_input = rtl8231_direction_input;
gpios->gc.direction_output = rtl8231_direction_output;
gpios->gc.set = rtl8231_gpio_set;
gpios->gc.get = rtl8231_gpio_get;
gpios->gc.get_direction = rtl8231_get_direction;

return devm_gpiochip_add_data(dev, &gpios->gc, gpios);
}

The above function is used to create a GPIO chip with the GPIO functions.

static const struct of_device_id rtl8231_gpio_of_match[] = {
{ .compatible = "realtek,rtl8231-




NEXT




<s> static void msdc_dump_ocr_reg(struct msdc_host *host, u32 resp)
{
if (resp & (1 << 7))
N_MSG(RSP, "[OCR] Low Voltage Range");
if (resp & (1 << 15))
N_MSG(RSP, "[OCR] 2.7-2.8 volt");
if (resp & (1 << 16))
N_MSG(RSP, "[OCR] 2.8-2.9 volt");
if (resp & (1 << 17))
N_MSG(RSP, "[OCR] 2.9-3.0 volt");
if (resp & (1 << 18))
N_MSG(RSP, "[OCR] 3.0-3.1 volt");
if (resp & (1 << 19))
N_MSG(RSP, "[OCR] 3.1-3.2 volt");
if (resp & (1 << 20))
N_MSG(RSP, "[OCR] 3.2-3.3 volt");
if (resp & (1 << 21))
N_MSG(RSP, "[OCR] 3.3-3.4 volt");
if (resp & (1 << 22))
N_MSG(RSP, "[OCR] 3.4-3.5 volt");
if (resp & (1 << 23))
N_MSG(RSP, "[OCR] 3.5-3.6 volt");
if (resp & (1 << 24))
N_MSG(RSP, "[OCR] Switching to 1.8V Accepted (S18A)");
if (resp & (1 << 30))
N_MSG(RSP, "[OCR] Card Capacity Status (CCS)");
if (resp & (1 << 31))
N_MSG(RSP, "[OCR] Card Power Up Status (Idle)");
else
N_MSG(RSP, "[OCR] Card Power Up Status (Busy)");
}

The above function is used to display MSDC ocr register status .</s>




NEXT




<s> radius_add_attr(struct radius_parse_attr_state *state,
u32 vendor, u8 type, u8 len)
{
struct hostapd_radius_attr *attr;
struct wpabuf *buf;
void *val;

val = state->attrdata;

buf = state->buf++;
buf->buf = val;

attr = state->attr++;
attr->val = buf;
attr->type = type;

if (state->prev)
state->prev->next = attr;
state->prev = attr;

if (vendor) {
u8 *vendor_hdr = val + 4;

WPA_PUT_BE32(val, vendor);
vendor_hdr[0] = type;
vendor_hdr[1] = len + 2;

len += VENDOR_ATTR_SIZE;
val += VENDOR_ATTR_SIZE;
attr->type = RADIUS_ATTR_VENDOR_SPECIFIC;
}

buf->size = buf->used = len;
state->attrdata += len;

return val;
}

The above function is used to add attributes to the response. The main problem is that it only allocates a space for a fixed amount of attributes (RADIUS_MAX_ATTRS). So if the response gets too many attributes, a segmentation fault occurs. I




NEXT




<s> static int qca807x_read_status(struct phy_device *phydev)
{
if (linkmode_test_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, phydev->supported)) {
switch (phydev->port) {
case PORT_FIBRE:
return qca807x_read_fiber_status(phydev);
case PORT_TP:
return qca807x_read_copper_status(phydev);
default:
return -EINVAL;
}
} else
return qca807x_read_copper_status(phydev);
}

The above function is used to read the status of copper or fiber using QCA807x.</s>




NEXT




<s> static int b53_spi_write32(struct b53_device *dev, u8 page, u8 reg, u32 value)
{
struct spi_device *spi = dev->priv;
int ret;
u8 txbuf[6];

ret = b53_prepare_reg_access(spi, page);
if (ret)
return ret;

txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
txbuf[1] = reg;
put_unaligned_le32(value, &txbuf[2]);

return spi_write(spi, txbuf, sizeof(txbuf));
}

The above function is used to write 32bit values to SPI registers and the
function b53_prepare_reg_access() does the following:

static int b53_prepare_reg_access(struct spi_device *spi, u




NEXT




<s> static int rtl8367_extif_init_of(struct rtl8366_smi *smi, int id,
const char *name)
{
return -EINVAL;
}

The above function is used to initialize EXTIF interfaces based on EEPROM data,
the data structure is as follows:

union { struct { int id;
int of_size;
int of_offset;
};
char name[1




NEXT




<s> static int rtl838x_pie_rule_add(struct rtl838x_switch_priv *priv, struct pie_rule *pr)
{
int idx, block, j;

pr_debug("In %s\n", __func__);

mutex_lock(&priv->pie_mutex);

for (block = 0; block < priv->n_pie_blocks; block++) {
for (j = 0; j < 3; j++) {
int t = (sw_r32(RTL838X_ACL_BLK_TMPLTE_CTRL(block)) >> (j * 3)) & 0x7;
pr_debug("Testing block %d, template %d, template id %d\n", block, j, t);
idx = rtl838x_pie_verify_template(priv, pr, t, block);
if (idx >= 0)
break;
}
if (j < 3)
break;
}

if (block >= priv->n_pie_blocks) {
mutex_unlock(&priv->pie_mutex);
return -EOPNOTSUPP;
}

pr_debug("Using block: %d, index %d, template-id %d\n", block, idx, j);
set_bit(idx, priv->pie_use_bm);

pr->valid = true;
pr->tid = j;  /* Mapped to template number */
pr->tid_m = 0x3;
pr->id = idx;

rtl838x_pie_lookup_enable(priv, idx);
rtl838x_pie_rule_write(priv, idx, pr);

mutex_unlock(&priv->pie_mutex);

return 0;
}

The above function is used to add rules to PIE.
Rule adding may take some while: a block of rules from sw has to be copied to the FPGA, which only contains 3 templates each.
So for a block of 50 rules, it




NEXT




<s> ar8xxx_sw_set_arl_age_time(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
int age_time = val->value.i;
u32 age_time_val;

if (age_time < 0)
return -EINVAL;

age_time_val = ar8xxx_age_time_val(age_time);
if (age_time_val == 0 || age_time_val > 0xffff)
return -EINVAL;

priv->arl_age_time = age_time;
return 0;
}

The above function is used to set the "age" time associated with ARL table entries. This is a value used during ARL table maintenance cycles to determine if older entries in the table should be removed. If the value is 0, these entries will not be deleted.




NEXT




<s> ar8xxx_phy_check_aneg(struct phy_device *phydev)
{
int ret;

if (phydev->autoneg != AUTONEG_ENABLE)
return 0;
/*
* BMCR_ANENABLE might have been cleared
* by phy_init_hw in certain kernel versions
* therefore check for it
*/
ret = phy_read(phydev, MII_BMCR);
if (ret < 0)
return ret;
if (ret & BMCR_ANENABLE)
return 0;

dev_info(&phydev->mdio.dev, "ANEG disabled, re-enabling ...\n");
ret |= BMCR_ANENABLE | BMCR_ANRESTART;
return phy_write(phydev, MII_BMCR, ret);
}

The above function is used to restore the PHY Autonegotiation if the
kernel version does not have it enabled. My problem is that the above
code only checks for the `BMCR_ANENABLE (1<<31)&BMCR_ANRESTART





NEXT




<s> static void bcm6318_pcie_setup(struct bcm6318_pcie *priv)
{
u32 val;

__raw_writel(CPU_INT_PCIE_INTA | CPU_INT_PCIE_INTB |
CPU_INT_PCIE_INTC | CPU_INT_PCIE_INTD,
priv->base + PCIE_CPU_INT1_MASK_CLEAR_REG);

val = bcm6318_pcie_mem_resource.end & C2P_BASELIMIT_LIMIT_MASK;
val |= (bcm6318_pcie_mem_resource.start >> C2P_BASELIMIT_LIMIT_SHIFT)
<< C2P_BASELIMIT_BASE_SHIFT;
__raw_writel(val, priv->base + PCIE_CPU_2_PCIE_MEM_WIN0_BASELIMIT_REG);

/* setup class code as bridge */
val = __raw_readl(priv->base + PCIE_IDVAL3_REG);
val &= ~IDVAL3_CLASS_CODE_MASK;
val |= (PCI_CLASS_BRIDGE_PCI << IDVAL3_SUBCLASS_SHIFT);
__raw_writel(val, priv->base + PCIE_IDVAL3_REG);

/* disable bar1 size */
val = __raw_readl(priv->base + PCIE_CONFIG2_REG);
val &= ~CONFIG2_BAR1_SIZE_MASK;
__raw_writel(val, priv->base + PCIE_CONFIG2_REG);

/* set bar0 to little endian */
val = __raw_readl(priv->base + PCIE_CPU_2_PCIE_MEM_WIN0_LO_REG);
val |= bcm6318_pcie_mem_resource.start & C2P_MEM_WIN_BASE_ADDR_MASK;
val |= C2P_MEM_WIN_ENDIAN_HALF_BYTE_SWAP;
__raw_writel(val, priv->base + PCIE_CPU_2_PCIE_MEM_WIN0_LO_REG);

__raw_writel(SPECIFIC_ENDIAN_MODE_BYTE_ALIGN,
priv->base + PCIE_SPECIFIC_REG);

__raw_writel(RC_BAR_CFG_LO_SIZE_256MB,
priv->base + PCIE_RC_BAR1_CONFIG_LO_REG);

__raw_writel(BAR1_CFG_REMAP_ACCESS_EN,
priv->base + PCIE_UBUS_BAR1_CFG_REMAP_REG);

__raw_writel(PCIE_BUS_DEVICE << EXT_CFG_BUS_NUM_SHIFT,
priv->base + PCIE_EXT_CFG_INDEX_REG);
}

The above function is used to setup the register space for 6318 device.

It clears the INTERRUPT MASK register and setup class code as bridge.

It also configure C2P_MEM_WIN0_BASELIMIT register which




NEXT




<s> const char *sym_get_string_value(struct symbol *sym)
{
tristate val;

switch (sym->type) {
case S_BOOLEAN:
case S_TRISTATE:
val = sym_get_tristate_value(sym);
switch (val) {
case no:
return "n";
case mod:
sym_calc_value(modules_sym);
return (modules_sym->curr.tri == no) ? "n" : "m";
case yes:
return "y";
}
break;
default:
;
}
return (const char *)sym->curr.val;
}

The above function is used to access the symbol's value.
If the type is not BOOLEAN then the value is returned as it is, else it is converted to y/n according to the tristate value.

I do not understand this logic...




NEXT




<s> static int sata_oxnas_cleanup(struct ata_host *ah);
static void sata_oxnas_tf_load(struct ata_port *ap,
const struct ata_taskfile *tf);
static void sata_oxnas_irq_on(struct ata_port *ap);
static void sata_oxnas_post_reset_init(struct ata_port *ap);

static int sata_oxnas_acquire_hw(struct ata_port *ap, int may_sleep,
int timeout_jiffies);
static void sata_oxnas_release_hw(struct ata_port *ap);

static const void *HW_LOCKER_UID = (void *)0xdeadbeef;

/***************************************************************************
* ASIC access
***************************************************************************/
static void wait_cr_ack(void __iomem *phy_base)
{
while ((ioread32(phy_base + PHY_STAT) >> 16) & 0x1f)
; /* wait for an ack bit to be set */
}

The above function is used to wait for a command register read completion.

static void _oxnas_tx_byte(void __iomem *phy_base, u32 data, u8 tx_id)
{
wait(phy_base + PH




NEXT




<s> IFX_MEI_LongWordReadOffset (DSL_DEV_Device_t * pDev, u32 ul_address,
u32 * pul_data)
{
*pul_data = IFX_MEI_READ_REGISTER_L (pDev->base_address + ul_address);
rmb();
return;
}

The above function is used to update the address, read the value of ECM0_CCS register field, and then write it to the pDev->ul_ecm0_delay_max variable. However, according to the code, after executing the above function




NEXT




<s> char * nvram_get(nvram_handle_t *h, const char *name)
{
uint32_t i;
nvram_tuple_t *t;
char *value;

if (!name)
return NULL;

/* Hash the name */
i = hash(name) % NVRAM_ARRAYSIZE(h->nvram_hash);

/* Find the associated tuple in the hash table */
for (t = h->nvram_hash[i]; t && strcmp(t->name, name); t = t->next);

value = t ? t->value : NULL;

return value;
}

The above function is used to fetch a single attribute from nvram. Here’s another example of the implementation of nvram_get in Busybox (version 1.11.1):

/*
static char *nvram_get(struct nvram




NEXT




<s> static int ag71xx_ring_rx_init(struct ag71xx *ag)
{
struct ag71xx_ring *ring = &ag->rx_ring;
int ring_size = BIT(ring->order);
int ring_mask = BIT(ring->order) - 1;
unsigned int i;
int ret;

ret = 0;
for (i = 0; i < ring_size; i++) {
struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);

desc->next = (u32) (ring->descs_dma +
AG71XX_DESC_SIZE * ((i + 1) & ring_mask));

DBG("ag71xx: RX desc at %p, next is %08x\n",
desc, desc->next);
}

for (i = 0; i < ring_size; i++) {
struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);

if (!ag71xx_fill_rx_buf(ag, &ring->buf[i], ag->rx_buf_offset,
netdev_alloc_frag)) {
ret = -ENOMEM;
break;
}

desc->ctrl = DESC_EMPTY;
}

/* flush descriptors */
wmb();

ring->curr = 0;
ring->dirty = 0;

return ret;
}

The above function is used to initialize the Rx Ring with its Descriptors. A lot of descriptors are allocated and the driver attaches one per descriptor a receive buffer. This incurrs a performance hit as all the memory is allocated for the hardware regardless of whether all these




NEXT




<s> static int rb4xx_gpio_direction_output(struct gpio_chip *chip,
unsigned int offset, int value)
{
return rb4xx_gpio_cpld_set(gpiochip_get_data(chip), offset, value);
}

The above function is used to set GPIO output value for the gpio of the rb4xx
boards.

For rb532 board, its CP1 and CP2 need to be set together when setting GPIO
output value.

I'm confused that




NEXT




<s> ret_t rtl8367c_getAsicOutputQueueMappingIndex(rtk_uint32 port, rtk_uint32 *pIndex )
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_QOS_PORT_QUEUE_NUMBER_REG(port), RTL8367C_QOS_PORT_QUEUE_NUMBER_MASK(port), pIndex);
}

The above function is used to extract the queue_index in outqos entry for each queue on r8367c port.

The implementation of function in RAL (r8367_get_out_qosq_index) in AS




NEXT




<s> static INLINE void adsl_led_flash(void);

/*
*  buffer manage functions
*/
static INLINE struct sk_buff* alloc_skb_rx(void);
//static INLINE struct sk_buff* alloc_skb_tx(unsigned int);
static INLINE struct sk_buff *get_skb_rx_pointer(unsigned int);
static INLINE int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static INLINE int mailbox_rx_irq_handler(unsigned int);
static irqreturn_t mailbox_irq_handler(int, void *);
static INLINE void mailbox_signal(unsigned int, int);
#ifdef CONFIG_IFX_PTM_RX_TASKLET
static void do_ptm_tasklet(unsigned long);
#endif

/*
*  Debug Functions
*/
#if defined(DEBUG_DUMP_SKB) && DEBUG_DUMP_SKB
static void dump_skb(struct sk_buff *, u32, char *, int, int, int);
#else
#define dump_skb(skb, len, title, port, ch, is_tx)    do {} while (0)

The above function is used to dump a buffer on screen on receiving it or transmittiong one.
*/
enum {
	TX_BUF_COUNT_IN, /* number of bytes in Tx queues */
	TX_BUF_COUNT_OUT /*




NEXT




<s> BIGNUM *BN_new(void)
{
BIGNUM *ret;

if ((ret=(BIGNUM *)malloc(sizeof(BIGNUM))) == NULL)
{
return(NULL);
}
ret->flags=BN_FLG_MALLOCED;
ret->top=0;
ret->neg=0;
ret->dmax=0;
ret->d=NULL;
return(ret);
}

The above function is used to make a new BIGNUM structure. The function above is used to allocate the memory for bignum in this function and it was done well. We need to know that we call the function above twice in each function as you may see I mentioned




NEXT




<s> uc_wpas_iface_status(uc_vm_t *vm, size_t nargs)
{
struct wpa_supplicant *wpa_s = uc_fn_thisval("wpas.iface");
struct wpa_bss *bss;
uc_value_t *ret, *val;

if (!wpa_s)
return NULL;

ret = ucv_object_new(vm);

val = ucv_string_new(wpa_supplicant_state_txt(wpa_s->wpa_state));
ucv_object_add(ret, "state", ucv_get(val));

bss = wpa_s->current_bss;
if (bss) {
int sec_chan = 0;
const u8 *ie;

ie = wpa_bss_get_ie(bss, WLAN_EID_HT_OPERATION);
if (ie && ie[1] >= 2) {
const struct ieee80211_ht_operation *ht_oper;
int sec;

ht_oper = (const void *) (ie + 2);
sec = ht_oper->ht_param & HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK;
if (sec == HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE)
sec_chan = 1;
else if (sec == HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW)
sec_chan = -1;
}

ucv_object_add(ret, "sec_chan_offset", ucv_int64_new(sec_chan));
ucv_object_add(ret, "frequency", ucv_int64_new(bss->freq));
}

#ifdef CONFIG_MESH
if (wpa_s->ifmsh) {
struct hostapd_iface *ifmsh = wpa_s->ifmsh;

ucv_object_add(ret, "sec_chan_offset", ucv_int64_new(ifmsh->conf->secondary_channel));
ucv_object_add(ret, "frequency", ucv_int64_new(ifmsh->freq));
}
#endif

return ret;
}

The above function is used to set the frequency of the WPA interface. When called it takes a single parameter: the frequency of the interface.

## 1-10: Setting the SSID

In this example, we will set the SSID of our




NEXT




<s> static void rtl93xx_hw_en_rxtx(struct rtl838x_eth_priv *priv)
{
/* Setup CPU-Port: RX Buffer truncated at DEFAULT_MTU Bytes */
sw_w32((DEFAULT_MTU << 16) | RX_TRUNCATE_EN_93XX, priv->r->dma_if_ctrl);

for (int i = 0; i < priv->rxrings; i++) {
int pos = (i % 3) * 10;
u32 v;

sw_w32_mask(0x3ff << pos, priv->rxringlen << pos, priv->r->dma_if_rx_ring_size(i));

/* Some SoCs have issues with missing underflow protection */
v = (sw_r32(priv->r->dma_if_rx_ring_cntr(i)) >> pos) & 0x3ff;
sw_w32_mask(0x3ff << pos, v, priv->r->dma_if_rx_ring_cntr(i));
}

/* Enable Notify, RX done, RX overflow and TX done interrupts */
sw_w32(0xffffffff, priv->r->dma_if_intr_rx_runout_msk);
sw_w32(0xffffffff, priv->r->dma_if_intr_rx_done_msk);
sw_w32(0x0000000f, priv->r->dma_if_intr_tx_done_msk);

/* Enable DMA */
sw_w32_mask(0, RX_EN_93XX | TX_EN_93XX, priv->r->dma_if_ctrl);

/* Restart TX/RX to CPU port, enable CRC checking */
sw_w32_mask(0x0, 0x3 | BIT(4), priv->r->mac_port_ctrl(priv->cpu_port));

if (priv->family_id == RTL9300_FAMILY_ID)
sw_w32_mask(0, BIT(priv->cpu_port), RTL930X_L2_UNKN_UC_FLD_PMSK);
else
sw_w32_mask(0, BIT(priv->cpu_port), RTL931X_L2_UNKN_UC_FLD_PMSK);

if (priv->family_id == RTL9300_FAMILY_ID)
sw_w32(0x217, priv->r->mac_force_mode_ctrl + priv->cpu_port * 4);
else
sw_w32(0x2a1d, priv->r->mac_force_mode_ctrl + priv->cpu_port * 4);
}

The above function is used to set the 93xx device to fully working state when the device is not in Reset or Sleep modes</s>




NEXT




<s> rtk_api_ret_t rtk_cpu_enable_set(rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicCputagEnable(enable)) != RT_ERR_OK)
return retVal;

if (DISABLED == enable)
{
if ((retVal = rtl8367c_setAsicCputagPortmask(0)) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to enable and disable the CPU tagging feature of ASIC. If a packet is tagged with CPU tag by H/W, this packet will be delivered to CPU; and if this packet is not tagged with CPU tag, this packet will be




NEXT




<s> static int rtl83xx_port_ipv4_resolve(struct rtl838x_switch_priv *priv,
struct net_device *dev, __be32 ip_addr)
{
struct neighbour *n = neigh_lookup(&arp_tbl, &ip_addr, dev);
int err = 0;
u64 mac;

if (!n) {
n = neigh_create(&arp_tbl, &ip_addr, dev);
if (IS_ERR(n))
return PTR_ERR(n);
}

/* If the neigh is already resolved, then go ahead and
* install the entry, otherwise start the ARP process to
* resolve the neigh.
*/
if (n->nud_state & NUD_VALID) {
mac = ether_addr_to_u64(n->ha);
pr_info("%s: resolved mac: %016llx\n", __func__, mac);
rtl83xx_l3_nexthop_update(priv, ip_addr, mac);
} else {
pr_info("%s: need to wait\n", __func__);
neigh_event_send(n, NULL);
}

neigh_release(n);

return err;
}

The above function is used to either resolve an IP to a MAC address or update
the existing MAC address for the corresponding IP address.
An IP address can be resolved to MAC address only after sending an ARP request to
the ARP table. When receiving an ARP




NEXT




<s> static void fe_txcsum_config(bool enable)
{
if (enable)
fe_w32(fe_r32(FE_CDMA_CSG_CFG) | (FE_ICS_GEN_EN |
FE_TCS_GEN_EN | FE_UCS_GEN_EN),
FE_CDMA_CSG_CFG);
else
fe_w32(fe_r32(FE_CDMA_CSG_CFG) & ~(FE_ICS_GEN_EN |
FE_TCS_GEN_EN | FE_UCS_GEN_EN),
FE_CDMA_CSG_CFG);
}

The above function is used to set/reset the CDMA CSR
functionality. The function is called at the boot time as well
as while applying a reset. Due to these reasons, this function
should be very careful and only set the relevant bits of TCS




NEXT




<s> static inline int pinmux_get(struct dc_ep_dev *dev, u32 gpio, int *func)
{
if (WARN_ON(!dev || !func))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_pinmux_get(dev->priv, gpio, func);
}

The above function is used to read the GPIO function registered by the user with EPCFG utility.</s>




NEXT




<s> send_attr_link(struct nl_msg *msg, struct switch_val *val)
{
struct switch_port_link *link = val->value.link;
struct nlattr *n;

n = nla_nest_start(msg, SWITCH_ATTR_OP_VALUE_LINK);
if (!n)
goto nla_put_failure;

if (link->duplex)
NLA_PUT_FLAG(msg, SWITCH_LINK_FLAG_DUPLEX);
if (link->aneg)
NLA_PUT_FLAG(msg, SWITCH_LINK_FLAG_ANEG);
NLA_PUT_U32(msg, SWITCH_LINK_SPEED, link->speed);

nla_nest_end(msg, n);

return 0;

nla_put_failure:
return -1;
}

The above function is used to update the attributes of link in case of any changes.

In the case of switch_get_link_op_handler, we are getting the link via attr_get_op_link, followed by calling get_link and update attributes




NEXT




<s> struct gstr get_relations_str(struct symbol **sym_arr, struct list_head *head)
{
struct symbol *sym;
struct gstr res = str_new();
int i;

for (i = 0; sym_arr && (sym = sym_arr[i]); i++)
get_symbol_str(&res, sym, head);
if (!i)
str_append(&res, "No matches found.\n");
return res;
}

The above function is used to fetch all relations stored in the gtklist store. It also stores into a list head. This helps to easily create the relations string later on (the gtklist store uses a linked-list type structure, so as to fetch the required symbol




NEXT




<s> static const char *rtl8367c_get_mib_name(int idx)
{

return rtl8367c_mib_counters[idx].name;
}

The above function is used to return the string value of MIB statistics.

static const char *const rtl8367c_mib_counters[RTL865X_MIB_ENTRIES_NUM] = {






NEXT




<s> void rtl838x_vlan_profile_dump(int profile)
{
u32 p;

if (profile < 0 || profile > 7)
return;

p = sw_r32(RTL838X_VLAN_PROFILE(profile));

pr_info("VLAN profile %d: L2 learning: %d, UNKN L2MC FLD PMSK %d, \
UNKN IPMC FLD PMSK %d, UNKN IPv6MC FLD PMSK: %d",
profile, p & 1, (p >> 1) & 0x1ff, (p >> 10) & 0x1ff, (p >> 19) & 0x1ff);
}

The above function is used to extract rtl838x vlan profile number.

But i dont see the way u extract profile number based on VLAN interface.

so can anybody help me on how to find the respective profile number

for each v




NEXT




<s> static int bcm6348_cb_write(struct pci_bus *bus, unsigned int devfn,
int where, int size, u32 val)
{
struct bcm6348_pci *priv = &bcm6348_pci;
struct bcm6348_cb *cb = &priv->cb;

if (!bus->parent && PCI_SLOT(devfn) == FAKE_CB_BRIDGE_SLOT) {
priv->cb_bus = bus->number;
return bcm6348_cb_bridge_write(where, size, val);
}

if (cb->bus_assigned &&
bus->number == cb->cardbus_busn &&
PCI_SLOT(devfn) == 0)
return bcm6348_do_cfg_write(0, 0,
PCI_DEVFN(CARDBUS_PCI_IDSEL, 0),
where, size, val);

return PCIBIOS_DEVICE_NOT_FOUND;
}

The above function is used to write values to bus cardbus slot #0 of the cardbus bridge. But when the value is written to the address where Fake Cardbus Brige SLOT is supposed to be found i.e. for PCI_SLOT(devfn




NEXT




<s> ret_t rtl8367c_setAsicStormFilterUnknownMulticastMeter(rtk_uint32 port, rtk_uint32 meter)
{
ret_t retVal;

if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(meter > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_STORM_UNMC_METER_CTRL_REG(port), RTL8367C_STORM_UNMC_METER_CTRL_MASK(port), meter);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_UNMC_METER_CTRL4 + ((port - 8) >> 1), RTL8367C_STORM_UNMC_METER_CTRL_MASK(port), meter);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set AsicStormFilterUnknownMulticastMeter register (set bit of AsicStormFilterUnknownMulticastMeter register),
the bit meaning of this register can be found in 8367C_REGISTER




NEXT




<s> static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to provide a platform dependant link rate for
the EDSR to provide to the upstream. It should read the link up and
downstream rates and copy it to the global g_tx_link_rate[] array


static




NEXT




<s> static char *variable_expand(const char *name, int argc, char *argv[])
{
struct variable *v;
char *res;

v = variable_lookup(name);
if (!v)
return NULL;

if (argc == 0 && v->exp_count)
pperror("Recursive variable '%s' references itself (eventually)",
name);

if (v->exp_count > 1000)
pperror("Too deep recursive expansion");

v->exp_count++;

if (v->flavor == VAR_RECURSIVE)
res = expand_string_with_args(v->value, argc, argv);
else
res = xstrdup(v->value);

v->exp_count--;

return res;
}

The above function is used to do a variable expansion. But as we can see from the comments. variable_expand() handles recursive expansion. I am not sure why this check is required, but I suppose it is good to have it anyways to avoid infinite loops.





NEXT




<s> static int rtl8367c_set_vlan( unsigned short vid, u32 mbr, u32 untag, u8 fid)
{
rtk_vlan_cfg_t vlan_cfg;
int i;

memset(&vlan_cfg, 0x00, sizeof(rtk_vlan_cfg_t));

for (i = 0; i < RTL8367C_NUM_PORTS; i++) {
if (mbr & (1 << i)) {
RTK_PORTMASK_PORT_SET(vlan_cfg.mbr, rtl8367c_sw_to_phy_port(i));
if(untag & (1 << i))
RTK_PORTMASK_PORT_SET(vlan_cfg.untag, rtl8367c_sw_to_phy_port(i));
}
}
vlan_cfg.fid_msti=fid;
vlan_cfg.ivl_en = 1;
return rtk_vlan_set(vid, &vlan_cfg);
}

The above function is used to set vlan membership and untagged ports according to a specific vlan id in sw layer.

And if the function calls successfully, return value is non-zero.

To debug the issue, you can try to:
1




NEXT




<s> SHA256_Init(SHA256_CTX * ctx)
{

/* Zero bits processed so far */
ctx->count = 0;

/* Magic initialization constants */
ctx->state[0] = 0x6A09E667;
ctx->state[1] = 0xBB67AE85;
ctx->state[2] = 0x3C6EF372;
ctx->state[3] = 0xA54FF53A;
ctx->state[4] = 0x510E527F;
ctx->state[5] = 0x9B05688C;
ctx->state[6] = 0x1F83D9AB;
ctx->state[7] = 0x5BE0CD19;
}

The above function is used to initialize SHA256 Context variable state with 8 zero bytes to start with. Note that the Context variable consists of 8 zero bytes.

SHA256(SHA256_CTX * ctx, const void * data,




NEXT




<s> ret_t rtl8367c_setAsicPortEgressRate(rtk_uint32 port, rtk_uint32 rate)
{
ret_t retVal;
rtk_uint32 regAddr, regData;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(rate > RTL8367C_QOS_GRANULARTY_MAX)
return RT_ERR_QOS_EBW_RATE;

regAddr = RTL8367C_PORT_EGRESSBW_LSB_REG(port);
regData = RTL8367C_QOS_GRANULARTY_LSB_MASK & rate;

retVal = rtl8367c_setAsicReg(regAddr, regData);

if(retVal != RT_ERR_OK)
return retVal;

regAddr = RTL8367C_PORT_EGRESSBW_MSB_REG(port);
regData = (RTL8367C_QOS_GRANULARTY_MSB_MASK & rate) >> RTL8367C_QOS_GRANULARTY_MSB_OFFSET;

retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_PORT6_EGRESSBW_CTRL1_MASK, regData);

return retVal;
}

The above function is used to set an ingress rate for a particular port to the chip. This will be added at some point to be more intuitive for the user. But the function above does provide the desired functionality. Just a word of warning, the egress rate is




NEXT




<s> ret_t rtl8367c_setAsicI2CStopCmd(void)
{

rtk_uint32 regData;
ret_t retVal;

/* Bits [4-1] = 0b0001, Stop Command; Bit [0] = 1, Trigger the Command */
if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
return retVal;
regData &= 0xFFE0;
regData |= 0x0003;

if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
return retVal;


/* wait for command finished */
do{
if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
return retVal;
}while( regData != 0x0);

return RT_ERR_OK ;
}

The above function is used to execute the I2C STOP command in the MIPS environment. Currently, this function is just a stub function to help developers debug in the MIPS environment.</s>




NEXT




<s> ret_t rtl8367c_setAsicInterruptStatus(rtk_uint32 ims)
{
return rtl8367c_setAsicReg(RTL8367C_REG_INTR_IMS, ims);
}

The above function is used to set ASIC interrupt status, however, I have not found it is used. If not used, can we just make it as "static-line" and remove the functions that use this function? I have checked some platforms' source codes and find




NEXT




<s> static int rtc_open(UNUSED struct inode *inode, UNUSED struct file *filp)
{
spin_lock_irq(&rtc_lock);

if (rtc_status & RTC_IS_OPEN) {
spin_unlock_irq(&rtc_lock);
return -EBUSY;
}

rtc_status |= RTC_IS_OPEN;

/*
* The following call is only necessary if we use both this driver and
* the proprietary one from asus at the same time (which, b.t.w. only
* makes sense during development). Otherwise, each access via the asus
* driver will make access via this driver impossible.
*/
i2c_init();

spin_unlock_irq(&rtc_lock);

return 0;
}

The above function is used to initialize the hardware and to make sure
that only one program may access the driver at the same time. Note how
we check the status before locking and unlocking the mutex so that the
mutex will not be held unnecessarily long




NEXT




<s> static int rtl8367_sw_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
{
struct switch_port *port;
u32 member = 0;
u32 untag = 0;
u8 fid=0;
int err;
int i;

if (!rtl8367c_is_vlan_valid(val->port_vlan))
return -EINVAL;

port = &val->value.ports[0];
for (i = 0; i < val->len; i++, port++) {
int pvid = 0;
member |= BIT(port->id);

if (!(port->flags & BIT(SWITCH_PORT_FLAG_TAGGED)))
untag |= BIT(port->id);

/*
* To ensure that we have a valid MC entry for this VLAN,
* initialize the port VLAN ID here.
*/
err = rtl8367c_get_pvid(port->id, &pvid);
if (err < 0)
return err;
if (pvid == 0) {
err = rtl8367c_set_pvid(port->id, val->port_vlan);
if (err < 0)
return err;
}
}

//pr_info("[%s] vid=%d , mem=%x,untag=%x,fid=%d \n",__func__,val->port_vlan,member,untag,fid);

return rtl8367c_set_vlan(val->port_vlan, member, untag, fid);

}

The above function is used to set the VLAN members and Untagged ports for VLANs. rtl8367c_set_vlan() is one of the API used to set the VLAN members and Untagged ports. To understand




NEXT




<s> void chip_version(void);
void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to swap the data. If your
board needs to swap the endianness of the data, replace this
function.

/*! \fn int32 __init ifxdanube_init (void)
*
*  \ing




NEXT




<s> adm6996_reset_switch(struct switch_dev *dev)
{
struct adm6996_priv *priv = to_adm(dev);

pr_devel("reset\n");

mutex_lock(&priv->reg_mutex);
adm6996_perform_reset (priv);
mutex_unlock(&priv->reg_mutex);
return 0;
}

The above function is used to put adm6996 chip into reset mode.

The reset process is performed in the following way:

1. Set the control register of reset (addr = 0x2, bit offset = 21)
(




NEXT




<s> static inline u32 dma_readl(struct bcm6348_iudma *iudma, u32 off)
{
u32 val;

spin_lock(&iudma->dma_base_lock);
val = __raw_readl(iudma->dma_base + off);
spin_unlock(&iudma->dma_base_lock);

return val;
}

The above function is used to read the data from DMA device. It is the general procedure to read the data from a
device in Linux. The function does the following tasks:

1. Locks the DMA device
2. Read the data from the DMA device via




NEXT




<s> DSL_BSP_ATMLedCBRegister (int (*ifx_adsl_ledcallback) (void))
{
g_adsl_ledcallback = ifx_adsl_ledcallback;
return 0;
}

The above function is used to register the callback API for handling the ATM_LED_CB_EVENT_T event from the host CPU. This function only needs to be executed during the initialization of the ADSL driver module.
The callback API to be registered need have the




NEXT




<s> static bool ag71xx_fill_rx_buf(struct ag71xx *ag, struct ag71xx_buf *buf,
int offset,
void *(*alloc)(unsigned int size))
{
struct ag71xx_ring *ring = &ag->rx_ring;
struct ag71xx_desc *desc = ag71xx_ring_desc(ring, buf - &ring->buf[0]);
void *data;

data = alloc(ag71xx_buffer_size(ag));
if (!data)
return false;

buf->rx_buf = data;
buf->dma_addr = dma_map_single(&ag->pdev->dev, data, ag->rx_buf_size,
DMA_FROM_DEVICE);
desc->data = (u32) buf->dma_addr + offset;
return true;
}

The above function is used to fill the RX descriptor buffer in the DMA region at
DMA_ADDRESS(offset).
However offset is not initialized here.

The struct ag71xx_buf is used to get the offset.


static inline struct ag




NEXT




<s> static int fe_get_link_ksettings(struct net_device *ndev,
struct ethtool_link_ksettings *cmd)
{
struct fe_priv *priv = netdev_priv(ndev);

if (!priv->phy_dev)
return -ENODEV;

if (priv->phy_flags == FE_PHY_FLAG_ATTACH) {
if (phy_read_status(priv->phy_dev))
return -ENODEV;
}

phy_ethtool_ksettings_get(ndev->phydev, cmd);

return 0;
}

The above function is used to read ethtool phy registers.

The following function is used to convert the ethtool register address and value into a physical address and physical value on the SGMII interface.
As you can see, we need to use an




NEXT




<s> rtk_api_ret_t rtk_switch_isPortMaskValid(rtk_portmask_t *pPmask)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(NULL == pPmask)
return RT_ERR_NULL_POINTER;

if( (pPmask->bits[0] | halCtrl->valid_portmask) != halCtrl->valid_portmask )
return RT_ERR_FAILED;
else
return RT_ERR_OK;
}

The above function is used to check whether the Portmask is valid.</s>




NEXT




<s> swlib_list(void)
{
if (swlib_priv_init() < 0)
return;
swlib_call(SWITCH_CMD_GET_SWITCH, list_switch, NULL, NULL);
swlib_priv_free();
}

The above function is used to get the listing of all switches added to the switch fabric system.

swlib_list_ap_port(char *port_id)
{
if (swlib_priv_init() < 0)
return;




NEXT




<s> int bh_event_add_var(struct bh_event *event, int argv, const char *format, ...)
{
char buf[128];
char *s;
va_list args;
int len;

if (argv)
return 0;

va_start(args, format);
len = vsnprintf(buf, sizeof(buf), format, args);
va_end(args);

if (len >= sizeof(buf)) {
WARN(1, "buffer size too small");
return -ENOMEM;
}

s = skb_put(event->skb, len + 1);
strcpy(s, buf);

pr_debug(PFX "added variable '%s'\n", s);

return 0;
}

The above function is used to add additional strings to a given event. It'd be nice if I found a bug here...

#1 PF_NETLINK_CLT(PF_INET, AF_INET, PF_ROUTE, NET




NEXT




<s> rtk_api_ret_t rtk_l2_table_clearStatus_get(rtk_l2_clearStatus_t *pStatus)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pStatus)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLutFlushAllStatus((rtk_uint32 *)pStatus)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the L2 table clears status.
If asic has finished the LUT clear, then the status will be RT_ERR_OK.
If asic is still busy, the return value will be RT_ERR_BUSY




NEXT




<s> void SHA1Init(SHA1_CTX* context)
{
/* SHA1 initialization constants */
context->state[0] = 0x67452301;
context->state[1] = 0xEFCDAB89;
context->state[2] = 0x98BADCFE;
context->state[3] = 0x10325476;
context->state[4] = 0xC3D2E1F0;
context->count[0] = context->count[1] = 0;
}

The above function is used to initialize a SHA1_CTX structure and its member variables. In this case, it is used to initialize the SHA1_CTX structure.
This function performs the following operations during its execution:
# Initializes the SHA1_CTX structure,




NEXT




<s> static int mt7621_nfc_send_address(struct mt7621_nfc *nfc, const u8 *addr,
unsigned int naddrs)
{
int ret;

while (naddrs) {
ret = mt7621_nfc_send_address_byte(nfc, *addr);
if (ret)
return ret;

addr++;
naddrs--;
}

return 0;
}

The above function is used to send data to the device, it expects an address and length.

We assume that naddress is 0x144. The corresponding hex notation of the address is 144. And the corresponding decimal notation is 21




NEXT




<s> static int rtl8366rb_is_vlan_valid(struct rtl8366_smi *smi, unsigned vlan)
{
unsigned max = RTL8366RB_NUM_VLANS;

if (smi->vlan4k_enabled)
max = RTL8366RB_NUM_VIDS - 1;

if (vlan == 0 || vlan >= max)
return 0;

return 1;
}

The above function is used to validate if Vid = 0 or Vid >= max or if they are within the range. A bug in the firmware has been found when a unicast ACSL2 frame is received by the port configured for untagged frames




NEXT




<s> static INLINE int stricmp(const char *, const char *);
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static INLINE int strincmp(const char *, const char *, int);
#endif
static INLINE int ifx_ptm_version(char *);

/*
*  Init & clean-up functions
*/
static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to check when the showtime mechanism (SHOWTIME feature) is implemented
in ATM_CPE chip. This function is needed when SHOWTIME_F_DISABLE is defined.
#endif


/*
*  Interface




NEXT




<s> static int rtl8366_smi_write_byte(struct rtl8366_smi *smi, u8 data)
{
rtl8366_smi_write_bits(smi, data, 8);
return rtl8366_smi_wait_for_ack(smi);
}

The above function is used to write a single byte to the FPGA over the
PCIe configuration space. It will send up to four “bytes” to
the FPGA, and wait for an ACK from the FPGA to ensure that the
write




NEXT




<s> static int psb6970_config_aneg(struct phy_device *phydev)
{
return 0;
}

The above function is used to configure the PHY for asymmetric NIC pair. The device driver that is implemented with PHY has the responsibility of configuring this function if the function pointer for this function pointer is provided by firmware in PHY register. What exactly this is




NEXT




<s> ret_t rtl8367c_setAsicFlowControlSystemJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SYS_OFF, RTL8367C_FLOWCTRL_JUMBO_SYS_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SYS_ON, RTL8367C_FLOWCTRL_JUMBO_SYS_ON_MASK, onThreshold);

return retVal;
}

The above function is used to configure system jumbo flow control threshold.

The value of onThreshold is used to set asic jumbo receive flow control register. When the number of bytes in receive buffer is higher than the value in the register, FIFO




NEXT




<s> DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID,
tl_wdr4900_v1_pci_wmac_fixup);
#endif /* CONFIG_PCI */

/*
* Setup the architecture
*/
static void __init tl_wdr4900_v1_setup_arch(void)
{
if (ppc_md.progress)
ppc_md.progress("tl_wdr4900_v1_setup_arch()", 0);

fsl_pci_assign_primary();

printk(KERN_INFO "TL-WDR4900 v1 board from TP-Link\n");
}

The above function is used to set up the architeture in TL-WDR4900 v1 wireless
gateway, the core of which are to set the primary PCI address (0x000c0)
and to configure the PCI device with




NEXT




<s> rtk_api_ret_t rtk_trap_lldpEnable_get(rtk_enable_t *pEnabled)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnabled)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicRmaLldp(pEnabled, &rmacfg)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get LLDP enable configuration via API function.

rtk_api_ret_t rtk_trap_lldpDisable_set(rtk_enable_t enabled)
{
rtk_api_ret_




NEXT




<s> static int block_load_image_fat_os(void)
{
int err;

err = file_fat_read(CONFIG_SPL_FAT_LOAD_ARGS_NAME,
(void *)CONFIG_SYS_SPL_ARGS_ADDR, 0);
if (err <= 0) {
return -1;
}

return block_load_image_fat(CONFIG_SPL_FAT_LOAD_KERNEL_NAME);
}

The above function is used to read an image located under the /boot
directory, on an FAT system with the following configuration:

#define CONFIG_FAT_ROOT
#define CONFIG_SYS_SPL_ARGS_ADDR 0x840




NEXT




<s> rtl_phy_save(struct switch_dev *dev, int port, struct rtl_phyregs *regs)
{
regs->nway = rtl_get(dev, RTL_PORT_REG(port, NWAY));
regs->speed = rtl_get(dev, RTL_PORT_REG(port, SPEED));
regs->duplex = rtl_get(dev, RTL_PORT_REG(port, DUPLEX));
}

The above function is used to save register content of RTL8367S switch.
There is a problem as following:
When switch starts, we do not use rtl_get() or rtl_set() to set the register values at first. We




NEXT




<s> static int msdc_app_cmd(struct mmc_host *mmc, struct msdc_host *host)
{
struct mmc_command cmd;
struct mmc_request mrq;
u32 err;

memset(&cmd, 0, sizeof(struct mmc_command));
cmd.opcode = MMC_APP_CMD;
#if 0   /* bug: we meet mmc->card is null when ACMD6 */
cmd.arg = mmc->card->rca << 16;
#else
cmd.arg = host->app_cmd_arg;
#endif
cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;

memset(&mrq, 0, sizeof(struct mmc_request));
mrq.cmd = &cmd; cmd.mrq = &mrq;
cmd.data = NULL;

err = msdc_do_command(host, &cmd, 0, CMD_TIMEOUT);
return err;
}

The above function is used to enter appcmd mode by cmd55 then use appcmd(ACMD6) to set the RCA to access.

Before I wrote the msdc_app_cmd() when I test it , I met an Error that A




NEXT




<s> static int from_bcd(int bcdnum)
{
int fac, num = 0;

for (fac = 1; bcdnum; fac *= 10) {
num += (bcdnum % 16) * fac;
bcdnum /= 16;
}

return num;
}

The above function is used to perform the reverse operation to the
one above:

static int to_bcd(int num)
{
int decdigit;
int bcd = 0, remainder;

for (; num; num /=




NEXT




<s> ret_t rtl8367c_setAsicShareMeterBucketSize(rtk_uint32 index, rtk_uint32 lbthreshold)
{

if(index > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(index < 32)
return rtl8367c_setAsicReg(RTL8367C_METER_BUCKET_SIZE_REG(index), lbthreshold);
else
return rtl8367c_setAsicReg(RTL8367C_REG_METER32_BUCKET_SIZE + index - 32, lbthreshold);
}

The above function is used to set/get ASIC Share Meter Bucket Size of 32-bit register and 48-bit register(R32 and R8) which is defined as:
0:31 - 32:46





NEXT




<s> __md5_to64(char *s, unsigned v, int n)
{
while (--n >= 0) {
*s++ = ascii64[v & 0x3f];
v >>= 6;
}
return s;
}

The above function is used to convert from a 2^32-sized md5 output to a 64 character ASCII string.

An MD5 hash is 128 bit output, that is 16 bytes or 32 hex characters




NEXT




<s> void yyrestart ( FILE *input_file  );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
void yy_delete_buffer ( YY_BUFFER_STATE b  );
void yy_flush_buffer ( YY_BUFFER_STATE b  );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to create a buffer and assign it to `YY_CURRENT_BUFFER'.
In this way, the buffer itself can do the `load' operation when it is empty. (This scheme,
in particular, is used in the interactive mode to allow




NEXT




<s> ret_t rtl8367c_getAsicCputagMode(rtk_uint32 *pMode)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_FORMAT_OFFSET, pMode);
}

The above function is used to get  r8218 mode in Linux driver. It get value from hardware register, so it is the fastest way. But in uBoot, it is a waste time to access hardware register. It takes more time than just read/write




NEXT




<s> rtk_api_ret_t rtk_port_phyReg_get(rtk_port_t port, rtk_port_phy_reg_t reg, rtk_port_phy_data_t *pData)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), reg, pData)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the phy registers of specific port.</s>




NEXT




<s> t_fromhex(dst, src)
register char *dst, *src;
{
register char *chp = dst;
register unsigned size = strlen(src);

/* FIXME: handle whitespace and non-hex digits by setting size and src
appropriately. */

if(size % 2 == 1) {
*chp++ = hexDigitToInt(*src++);
--size;
}
while(size > 0) {
*chp++ = (hexDigitToInt(*src) << 4) | hexDigitToInt(*(src + 1));
src += 2;
size -= 2;
}
return chp - dst;
}

The above function is used to convert ASCII hexadecimal digits to integers.
It is used in an early implementation of t_fromhex() which I had
which used some kind of "state" variable.  I'm pretty much sure that




NEXT




<s> ret_t rtl8367c_getAsicPortMirrorMask(rtk_uint32 *pSourcePortmask)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_MIRROR_SRC_PMSK, RTL8367C_MIRROR_SRC_PMSK_MASK, pSourcePortmask);
}

The above function is used to read the port mirroring source portmask register. There are a number of bit fields in the source portmask register, and we can mask off a specific bit and store the mask in a pointer, but is it the same with destination portmask




NEXT




<s> static void set_config_filename(const char *config_filename)
{
static char menu_backtitle[PATH_MAX+128];

snprintf(menu_backtitle, sizeof(menu_backtitle), "%s - %s",
config_filename, rootmenu.prompt->text);
set_dialog_backtitle(menu_backtitle);

snprintf(filename, sizeof(filename), "%s", config_filename);
}

The above function is used to update the back title of the rootmenu.
In the function definition, the type of the config_filename parameter,
i.e., const char *, is defined in the standard <cstddef>
header file. Because it's




NEXT




<s> static int ip17xx_get_phy(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);

val->value.i = state->proc_mii.p;
return 0;
}

The above function is used to receive the value of interface. In the above function the
IP17XX_PHY_STATE attribute is added.

The following file is used, to add this interface of driver.

The addition is made through:

dev




NEXT




<s> static bool nmbm_set_block_state(struct nmbm_instance *ni, uint32_t ba,
uint32_t state)
{
uint32_t unit, shift, orig;
u32 uv;

unit = ba / NMBM_BITMAP_BLOCKS_PER_UNIT;
shift = (ba % NMBM_BITMAP_BLOCKS_PER_UNIT) * NMBM_BITMAP_BITS_PER_BLOCK;

orig = (ni->block_state[unit] >> shift) & BLOCK_ST_MASK;
state &= BLOCK_ST_MASK;

uv = ni->block_state[unit] & (~(BLOCK_ST_MASK << shift));
uv |= state << shift;
ni->block_state[unit] = uv;

if (orig != state) {
ni->block_state_changed++;
return true;
}

return false;
}

The above function is used to set the bitmap block_state field. It is called
in nmbm_clear_block_state function (it is called in nmbm_clear_block_state
and in nmbm_reset_bitmap if you want




NEXT




<s> zconf_endhelp();
return T_HELPTEXT;
}
YY_BREAK

case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ASSIGN_VAL):
{

The above function is used to initialize the values from 0 to 255.


This was my attempt. I tried reading the example provided in the book and couldn’t understand why the example doesn’t compile. In the example, there is one state




NEXT




<s> static int b53_spi_read64(struct b53_device *dev, u8 page, u8 reg, u64 *val)
{
int ret = b53_spi_read(dev, page, reg, (u8 *)val, 8);

if (!ret)
*val = le64_to_cpu(*val);

return ret;
}

The above function is used to read out a long value from SPI. As you may see the last 64 bits gets swapped with Cpu to host endian.

But this is not the case for b53_spi_read32 as the following




NEXT




<s> static int __init mt_msdc_init(void)
{
int ret;

ret = platform_driver_register(&mt_msdc_driver);
if (ret) {
printk(KERN_ERR DRV_NAME ": Can't register driver");
return ret;
}

#if defined(MT6575_SD_DEBUG)
msdc_debug_proc_init();
#endif
return 0;
}

The above function is used to register an msdc driver.

The driver will be registered when MIPS (MT6575) boots and start to run.

This function will return error or success result. The error result will print a message to show




NEXT




<s> rtk_api_ret_t rtk_qos_portPri_set(rtk_port_t port, rtk_pri_t int_pri)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (int_pri > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

if ((retVal = rtl8367c_setAsicPriorityPortBased(rtk_switch_port_L2P_get(port), int_pri)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to assign the priority of packets sent to an Egress queues of a port.
qos_portPri_set() assigns port specific priority of ingress packets in order to control which packets will be sent to which egress queues




NEXT




<s> static int bcm6368_enetsw_remove(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct net_device *ndev = platform_get_drvdata(pdev);
struct bcm6368_enetsw *priv = netdev_priv(ndev);
unsigned int i;

pm_runtime_put_sync(dev);
for (i = 0; priv->pm && i < priv->num_pms; i++) {
dev_pm_domain_detach(priv->pm[i], true);
device_link_del(priv->link_pm[i]);
}

for (i = 0; i < priv->num_resets; i++)
reset_control_assert(priv->reset[i]);

for (i = 0; i < priv->num_clocks; i++)
clk_disable_unprepare(priv->clock[i]);

return 0;
}

The above function is used to remove the bcm6368 ethernet controller driver from the kernel. The function begins by freeing any memory that was allocated during the init phase. Next, the function disables the various clocks that were used by the controller.




NEXT




<s> ret_t rtl8367c_getAsicAclPortRange(rtk_uint32 index, rtk_uint32* pType, rtk_uint32* pUpperPort, rtk_uint32* pLowerPort)
{
ret_t retVal;

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL2 + index*3, RTL8367C_ACL_SDPORT_RANGE_ENTRY0_CTRL2_MASK, pType);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL1 + index*3, pUpperPort);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL0 + index*3, pLowerPort);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get acl entry configuration from RTL8367C register. Since the acl port entry range from register address 0xbe8 to 0xbf7 in B0 mode, the entry address is calculated by multiplying 




NEXT




<s> static int rtl9300_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)
{
struct rtl9300_mux *mux = i2c_mux_priv(muxc);

/* Set SCL pin */
REG_MASK(channels[chan].scl_num, 0,
BIT(RTL9300_I2C_CTRL1_GPIO8_SCL_SEL), RTL9300_I2C_CTRL1);

/* Set SDA pin */
REG_MASK(channels[chan].scl_num, 0x7 << RTL9300_I2C_CTRL1_SDA_OUT_SEL,
channels[chan].sda_num << RTL9300_I2C_CTRL1_SDA_OUT_SEL, RTL9300_I2C_CTRL1);

mux->i2c->sda_num = channels[chan].sda_num;
mux->i2c->scl_num = channels[chan].scl_num;

return 0;
}

The above function is used to select a specific I2C controller between different I2C channels. I modified the code to map I2C3 to SDA3 and SCL8, and I2C4 to SDA7 and SCL7. I2C




NEXT




<s> bool conf_get_changed(void)
{
return conf_changed;
}

The above function is used to query the change status of the configuration
file. When changes are detected, it returns true; if no changes are
detected, it returns false.

I could have solved the problem by setting the modified time to zero and
using f




NEXT




<s> __md5_Encode(unsigned char *output, uint32_t *input, unsigned int len)
{
unsigned int i, j;

for (i = 0, j = 0; j < len; i++, j += 4) {
output[j] = input[i];
output[j+1] = (input[i] >> 8);
output[j+2] = (input[i] >> 16);
output[j+3] = (input[i] >> 24);
}
}

The above function is used to Encode a byte array into MD5 hash in .c using __md5_Encode() function. Please help me in converting the above function C to Delphi (Pascal).
I have tried to convert __md5_Encode




NEXT




<s> static int sata_oxnas_port_start(struct ata_port *ap)
{
struct sata_oxnas_host_priv *host_priv = ap->host->private_data;
struct device *dev = ap->host->dev;
struct sata_oxnas_port_priv *pp;
void *mem;
dma_addr_t mem_dma;

DPRINTK("ENTER\n");

pp = kzalloc(sizeof(*pp), GFP_KERNEL);
if (!pp)
return -ENOMEM;

pp->port_base = host_priv->port_base +
(ap->port_no ? PORT_SIZE : 0);
pp->dmactl_base = host_priv->dmactl_base +
(ap->port_no ? DMA_CORESIZE : 0);
pp->sgdma_base = host_priv->sgdma_base +
(ap->port_no ? SGDMA_CORESIZE : 0);
pp->core_base = host_priv->core_base;

/* preallocated */
if (host_priv->dma_size >= SATA_OXNAS_DMA_SIZE * host_priv->n_ports) {
DPRINTK("using preallocated DMA\n");
mem_dma = host_priv->dma_base +
(ap->port_no ? SATA_OXNAS_DMA_SIZE : 0);
mem = ioremap(mem_dma, SATA_OXNAS_DMA_SIZE);
} else {
mem = dma_alloc_coherent(dev, SATA_OXNAS_DMA_SIZE, &mem_dma,
GFP_KERNEL);
}
if (!mem)
goto err_ret;

pp->sgdma_request_pa = mem_dma;
pp->sgdma_request = mem;

ap->bmdma_prd_dma = mem_dma + sizeof(struct sgdma_request);
ap->bmdma_prd = mem + sizeof(struct sgdma_request);

ap->private_data = pp;

sata_oxnas_post_reset_init(ap);

return 0;

err_ret:
kfree(pp);
return -ENOMEM;

}

The above function is used to start a SAT port (initialize).  This
function is invoked by its host’s start function.  sata_oxnas_port_start
allocates memory for this port and registers that memory with the
maintainer of




NEXT




<s> ret_t rtl8367c_setAsicPortPriorityDecisionIndex(rtk_uint32 port, rtk_uint32 index )
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(index >= PRIDEC_IDX_END)
return RT_ERR_ENTRY_INDEX;

return rtl8367c_setAsicRegBit(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_IDX_CTRL, port, index);
}

The above function is used to set up a specific port's priority decision index and return an error code (RTK_O.K, RTK_TIMEOUT, RTK_FAIL, RTK_ERR_PORT_ID, or RTK_ERR_ENTRY_




NEXT




<s> static void qsb_global_set(void);
static inline void set_htu_entry(unsigned int, unsigned int, unsigned int, int, int);
static inline void clear_htu_entry(unsigned int);
static void validate_oam_htu_entry(void);
static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to put OAM packets received on CP/UP OAM port to
CP OAM Queue.
#endif

/*
*  Receive processing
*/
static int rx_vci_cell(struct sk_buff *skb




NEXT




<s> ar8xxx_sw_set_mib_poll_interval(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

if (!ar8xxx_has_mib_counters(priv))
return -EOPNOTSUPP;

ar8xxx_mib_stop(priv);
priv->mib_poll_interval = val->value.i;
ar8xxx_mib_start(priv);

return 0;
}

The above function is used to set the poll interval between polling for mib_counters, but mib_poll_interval is initialized by
#define ar82161a_mib_poll_interval		5

So the mib




NEXT




<s> ret_t rtl8367c_setAsicLutIpMulticastVidLookup(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG2, RTL8367C_LUT_IPMC_VID_HASH_OFFSET, enabled);
}

The above function is used to enable and disable the 802.3 multi-cast video lookup function. When this function is called, the following operations will be performed in the sequence specified below:

1.    To enable the function to use the current hardware configuration




NEXT




<s> static int rtl83xx_vlan_prepare(struct dsa_switch *ds, int port,
const struct switchdev_obj_port_vlan *vlan)
{
struct rtl838x_vlan_info info;
struct rtl838x_switch_priv *priv = ds->priv;

priv->r->vlan_tables_read(0, &info);

pr_debug("VLAN 0: Tagged ports %llx, untag %llx, profile %d, MC# %d, UC# %d, FID %x\n",
info.tagged_ports, info.untagged_ports, info.profile_id,
info.hash_mc_fid, info.hash_uc_fid, info.fid);

priv->r->vlan_tables_read(1, &info);
pr_debug("VLAN 1: Tagged ports %llx, untag %llx, profile %d, MC# %d, UC# %d, FID %x\n",
info.tagged_ports, info.untagged_ports, info.profile_id,
info.hash_mc_fid, info.hash_uc_fid, info.fid);
priv->r->vlan_set_untagged(1, info.untagged_ports);
pr_debug("SET: Untagged ports, VLAN %d: %llx\n", 1, info.untagged_ports);

priv->r->vlan_set_tagged(1, &info);
pr_debug("SET: Tagged ports, VLAN %d: %llx\n", 1, info.tagged_ports);

return 0;
}

The above function is used to set VLAN specific tags and untagged status. The profile ID (priv->r->vlan_set_tagged) and ID (info.profile_id) are set to 1. A problem arises in that when the




NEXT




<s> static int ip_phy_write(struct ip17xx_state *state, int port, int reg, u16 val)
{
int err;

#ifdef DUMP_MII_IO
pr_debug("IP17xx: Write MII(%d,%d) <- %04x\n", port, reg, val);
#endif
err = mdiobus_write(state->mii_bus, port, reg, val);
if (err < 0)
pr_warn("IP17xx: Unable to write MII register %d,%d: error %d\n", port, reg, -err);
return err;
}

The above function is used to write to phy registers and mii registers. It will always return 0 on success even if there is no phy present at the phy address. However, I have no option as the same routine is being used from both the network interface




NEXT




<s> static int rtl8231_write(struct rtl8231_gpios *gpios, u32 reg, u32 data)
{
u32 t = 0, n = 0;

pr_debug("%s: %x, %x, %x\n", __func__, gpios->smi_bus_id, reg, data);
reg &= 0x1f;

t = (gpios->smi_bus_id << 2) | (reg << 7) | (data << 16);
/* Set write bit */
t |= 2;

/* Set execution bit: cleared when operation completed */
t |= 1;

/* Start execution */
sw_w32(t, gpios->ext_gpio_indrt_access);
do {
udelay(1);
t = sw_r32(gpios->ext_gpio_indrt_access);
} while ((t & 1) && (n < USEC_TIMEOUT));

if (n >= USEC_TIMEOUT)
return -1;

return 0;
}

The above function is used to write operation to the GPIO register.
This function is called multiple times each time a write of data takes
place. And we have to add a delay between the data transfer to wait for
the other part to get it.

Because the




NEXT




<s> image_check(int imagefd, const char *mtd)
{
uint32_t magic;
int ret = 1;
int bufread;

while (buflen < sizeof(magic)) {
bufread = read(imagefd, buf + buflen, sizeof(magic) - buflen);
if (bufread < 1)
break;

buflen += bufread;
}

if (buflen < sizeof(magic)) {
fprintf(stdout, "Could not get image magic\n");
return 0;
}

magic = ((uint32_t *)buf)[0];

if (be32_to_cpu(magic) == opt_trxmagic)
imageformat = MTD_IMAGE_FORMAT_TRX;
else if (be32_to_cpu(magic) == SEAMA_MAGIC)
imageformat = MTD_IMAGE_FORMAT_SEAMA;
else if (le32_to_cpu(magic) == WRG_MAGIC)
imageformat = MTD_IMAGE_FORMAT_WRG;
else if (le32_to_cpu(magic) == WRGG03_MAGIC)
imageformat = MTD_IMAGE_FORMAT_WRGG03;

switch (imageformat) {
case MTD_IMAGE_FORMAT_TRX:
if (trx_check)
ret = trx_check(imagefd, mtd, buf, &buflen);
break;
case MTD_IMAGE_FORMAT_SEAMA:
case MTD_IMAGE_FORMAT_WRG:
case MTD_IMAGE_FORMAT_WRGG03:
break;
default:
#ifdef target_brcm
if (!strcmp(mtd, "firmware"))
ret = 0;
#endif
break;
}

return ret;
}

The above function is used to check a valid firmware.</s>




NEXT




<s> static inline u32 dmac_readl(struct bcm6348_iudma *iudma, u32 off, int chan)
{
return __raw_readl(iudma->dma_chan + chan * DMA_CHAN_WIDTH + off);
}

The above function is used to read a 32-bit register from the DMA channel register banks. However, the DMA register banks are actually memory maps of the respective DMA channels. When the __raw_readl macro was used to read the address, the processor was made




NEXT




<s> rtk_api_ret_t rtk_l2_limitSystemLearningCnt_get(rtk_mac_cnt_t *pMac_cnt)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pMac_cnt)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicSystemLutLearnLimitNo(pMac_cnt)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set  the MAC address table limit counter. Its declaration and meaning:

rtk_api_ret_t rtk_l2_limitSystemLearningCnt_set(rtk_mac_cnt_t *p




NEXT




<s> int rt3050_esw_init(struct fe_priv *priv)
{
struct device_node *np = priv->switch_np;
struct platform_device *pdev = of_find_device_by_node(np);
struct switch_dev *swdev;
struct rt305x_esw *esw;
const __be32 *rgmii;
int ret;

if (!pdev)
return -ENODEV;

if (!of_device_is_compatible(np, ralink_esw_match->compatible))
return -EINVAL;

esw = platform_get_drvdata(pdev);
if (!esw)
return -EPROBE_DEFER;

priv->soc->swpriv = esw;
esw->priv = priv;

esw_hw_init(esw);

rgmii = of_get_property(np, "ralink,rgmii", NULL);
if (rgmii && be32_to_cpu(*rgmii) == 1) {
/*
* External switch connected to RGMII interface.
* Unregister the switch device after initialization.
*/
dev_err(&pdev->dev, "RGMII mode, not exporting switch device.\n");
unregister_switch(&esw->swdev);
platform_set_drvdata(pdev, NULL);
return -ENODEV;
}

swdev = &esw->swdev;
swdev->of_node = pdev->dev.of_node;
swdev->name = "rt305x-esw";
swdev->alias = "rt305x";
swdev->cpu_port = RT305X_ESW_PORT6;
swdev->ports = RT305X_ESW_NUM_PORTS;
swdev->vlans = RT305X_ESW_NUM_VIDS;
swdev->ops = &esw_ops;

ret = register_switch(swdev, NULL);
if (ret < 0) {
dev_err(&pdev->dev, "register_switch failed\n");
return ret;
}

ret = devm_request_irq(&pdev->dev, esw->irq, esw_interrupt, 0, "esw",
esw);
if (!ret) {
esw_w32(esw, RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_ISR);
esw_w32(esw, ~RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_IMR);
}

dev_info(&pdev->dev, "mediatek esw at 0x%08lx, irq %d initialized\n",
(long unsigned int)esw->base, esw->irq);

return 0;
}

The above function is used to register the switch, which returns a negative value if the switch is still busy or is in the middle of being used by another task. If the function is executed successfully, the following information is displayed:

mediatek esw at 0x




NEXT




<s> static void bcm6348_emac_set_multicast_list(struct net_device *ndev)
{
struct bcm6348_emac *emac = netdev_priv(ndev);
struct netdev_hw_addr *ha;
u32 val;
unsigned int i;

val = emac_readl(emac, ENET_RXCFG_REG);

if (ndev->flags & IFF_PROMISC)
val |= ENET_RXCFG_PROMISC_MASK;
else
val &= ~ENET_RXCFG_PROMISC_MASK;

/* only 3 perfect match registers left, first one is used for
* own mac address */
if ((ndev->flags & IFF_ALLMULTI) || netdev_mc_count(ndev) > 3)
val |= ENET_RXCFG_ALLMCAST_MASK;
else
val &= ~ENET_RXCFG_ALLMCAST_MASK;

/* no need to set perfect match registers if we catch all
* multicast */
if (val & ENET_RXCFG_ALLMCAST_MASK) {
emac_writel(emac, val, ENET_RXCFG_REG);
return;
}

i = 0;
netdev_for_each_mc_addr(ha, ndev) {
u8 *dmi_addr;
u32 tmp;

if (i == 3)
break;

/* update perfect match registers */
dmi_addr = ha->addr;
tmp = (dmi_addr[2] << 24) | (dmi_addr[3] << 16) |
(dmi_addr[4] << 8) | dmi_addr[5];
emac_writel(emac, tmp, ENET_PML_REG(i + 1));

tmp = (dmi_addr[0] << 8 | dmi_addr[1]);
tmp |= ENET_PMH_DATAVALID_MASK;
emac_writel(emac, tmp, ENET_PMH_REG(i++ + 1));
}

for (; i < 3; i++) {
emac_writel(emac, 0, ENET_PML_REG(i + 1));
emac_writel(emac, 0, ENET_PMH_REG(i + 1));
}

emac_writel(emac, val, ENET_RXCFG_REG);
}

The above function is used to set the multicast filter for the device.
After calling this function the device will receive any multicast transmission which is
registered as a multicast address by the operating system kernel.

It is very important to call the




NEXT




<s> static int b53_flush_arl(struct b53_device *dev)
{
unsigned int i;

b53_write8(dev, B53_CTRL_PAGE, B53_FAST_AGE_CTRL,
FAST_AGE_DONE | FAST_AGE_DYNAMIC | FAST_AGE_STATIC);

for (i = 0; i < 10; i++) {
u8 fast_age_ctrl;

b53_read8(dev, B53_CTRL_PAGE, B53_FAST_AGE_CTRL,
&fast_age_ctrl);

if (!(fast_age_ctrl & FAST_AGE_DONE))
return 0;

mdelay(1);
}

pr_warn("time out while flushing ARL\n");

return -EINVAL;
}

The above function is used to flush a stale arp entry in a cache using fast aging algorithm. This function contains a loop with some magic numbers.

So I tried to find out what is going on.
At first it is not very clear if the function is




NEXT




<s> handle_b(void)
{
struct ead_msg_number *num = EAD_DATA(msg, number);
int len = ntohl(msg->len) - sizeof(struct ead_msg_number);

B.data = bbuf;
B.len = len;
memcpy(bbuf, num->data, len);
return true;
}

The above function is used to handle a particular message type, and it is located within the Ead_client.cpp file. We can use Ollydbg to analyze the function and it appears that function takes some time to execute. This analysis is shown in Figure 4.




NEXT




<s> static void rtl838x_read_pie_fixed_fields(u32 r[], struct pie_rule *pr)
{
pr->spmmask_fix = (r[6] >> 22) & 0x3;
pr->spn = (r[6] >> 16) & 0x3f;
pr->mgnt_vlan = (r[6] >> 15) & 1;
pr->dmac_hit_sw = (r[6] >> 14) & 1;
pr->not_first_frag = (r[6] >> 13) & 1;
pr->frame_type_l4 = (r[6] >> 10) & 7;
pr->frame_type = (r[6] >> 8) & 3;
pr->otag_fmt = (r[6] >> 7) & 1;
pr->itag_fmt = (r[6] >> 6) & 1;
pr->otag_exist = (r[6] >> 5) & 1;
pr->itag_exist = (r[6] >> 4) & 1;
pr->frame_type_l2 = (r[6] >> 2) & 3;
pr->tid = r[6] & 3;

pr->spmmask_fix_m = (r[13] >> 22) & 0x3;
pr->spn_m = (r[13] >> 16) & 0x3f;
pr->mgnt_vlan_m = (r[13] >> 15) & 1;
pr->dmac_hit_sw_m = (r[13] >> 14) & 1;
pr->not_first_frag_m = (r[13] >> 13) & 1;
pr->frame_type_l4_m = (r[13] >> 10) & 7;
pr->frame_type_m = (r[13] >> 8) & 3;
pr->otag_fmt_m = (r[13] >> 7) & 1;
pr->itag_fmt_m = (r[13] >> 6) & 1;
pr->otag_exist_m = (r[13] >> 5) & 1;
pr->itag_exist_m = (r[13] >> 4) & 1;
pr->frame_type_l2_m = (r[13] >> 2) & 3;
pr->tid_m = r[13] & 3;

pr->valid = r[14] & BIT(31);
pr->cond_not = r[14] & BIT(30);
pr->cond_and1 = r[14] & BIT(29);
pr->cond_and2 = r[14] & BIT(28);
pr->ivalid = r[14] & BIT(27);

pr->drop = (r[17] >> 14) & 3;
pr->fwd_sel = r[17] & BIT(13);
pr->ovid_sel = r[17] & BIT(12);
pr->ivid_sel = r[17] & BIT(11);
pr->flt_sel = r[17] & BIT(10);
pr->log_sel = r[17] & BIT(9);
pr->rmk_sel = r[17] & BIT(8);
pr->meter_sel = r[17] & BIT(7);
pr->tagst_sel = r[17] & BIT(6);
pr->mir_sel = r[17] & BIT(5);
pr->nopri_sel = r[17] & BIT(4);
pr->cpupri_sel = r[17] & BIT(3);
pr->otpid_sel = r[17] & BIT(2);
pr->itpid_sel = r[17] & BIT(1);
pr->shaper_sel = r[17] & BIT(0);
}

The above function is used to get some of the values used by the Rule Engine from the RLK. However, this function relies on the values being retrieved from the EMM, and thus this function is not used when dumping the Rule Engine (when a rule




NEXT




<s> int spi_nor_read_data(void *dest, size_t pos, size_t len)
{
int ret;

while (len > 0) {
uint8_t cmd[4] = {CMD_READ, pos >> 16, pos >> 8, pos};
size_t block_len = min(len, spi_max_xfer() - sizeof(cmd));

struct spi_transfer t[2] = {{
.tx_buf = cmd,
.rx_buf = NULL,
.len = sizeof(cmd),
}, {
.tx_buf = NULL,
.rx_buf = dest,
.len = block_len,
}};

ret = spi_xfer(t, ARRAY_SIZE(t));
if (ret) {
puts("SPI transfer failed\n");
return ret;
}

pos += block_len;
dest += block_len;
len -= block_len;
}

return 0;
}

The above function is used to read a block of data (len bytes) from the SPI flash at a given position 'pos'. It has been modified such that now a buffer (dest) is passed to the the 'spi_read_data' function and data read from the




NEXT




<s> static int b53_mmap_read16(struct b53_device *dev, u8 page, u8 reg, u16 *val)
{
u8 __iomem *regs = dev->priv;

if (WARN_ON(reg % 2))
return -EINVAL;

if (dev->pdata && dev->pdata->big_endian)
*val = readw_be(regs + (page << 8) + reg);
else
*val = readw(regs + (page << 8) + reg);

return 0;
}

The above function is used to read the RSS_HASH_* values from
the RSS_HASH register in the 5316.

Looking at the readw() and readw_be() macros, we find that
readw




NEXT




<s> static int rt3883_fwd_config(struct fe_priv *priv)
{
int ret;

ret = fe_set_clock_cycle(priv);
if (ret)
return ret;

fe_fwd_config(priv);
fe_w32(FE_PSE_FQFC_CFG_256Q, FE_PSE_FQ_CFG);
fe_csum_config(priv);

return ret;
}

The above function is used to setup the internal FQ registers of the DEMUX, FE and RX units.

However, in the following code, I see there are some values that are being setup during init of the chip:

static void set_f




NEXT




<s> static int b53_global_set_jumbo_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct b53_device *priv = sw_to_b53(dev);

priv->enable_jumbo = val->value.i;

return 0;
}

The above function is used to enable/disable large frames. You can use
the following commands to set the value to enable/disable jumbo frames
of the switch.

* To enable jumbo frames, the switch is configured as follows:







NEXT




<s> static u64 rtl930x_l2_hash_seed(u64 mac, u32 vid)
{
u64 v = vid;

v <<= 48;
v |= mac;

return v;
}

The above function is used to produce a 64-bit hash, for use with the L3-L2 hash-table. The function, however, is not perfect. With the code below, the table becomes very unbalanced

static RTL_R




NEXT




<s> void dc_ep_icu_disable(struct dc_ep_priv *priv)
{
/* Disable all PCIe related interrupts */
wr32(0, PCIE_APPL_MSI_EN);

wr32(PCI_MSI_8_MODE, RCU_MSI);

/* Disable all interrupts in ICU level */
wr32(0, ICU_DMA_TX_IMER);
wr32(0, ICU_DMA_RX_IMER);
wr32(0, ICU_IMER);
}

The above function is used to disable DC3/DEPC4 EP_ICU interrupts.
This function will not be called as part of initialisation for EP devices.
It is only used for stopping DC3/DEPC4 EP_ICU interrupts when




NEXT




<s> static int bcm6348_emac_stop(struct net_device *ndev)
{
struct bcm6348_emac *emac = netdev_priv(ndev);
struct bcm6348_iudma *iudma = emac->iudma;
struct device *dev = &emac->pdev->dev;
unsigned int i;

netif_stop_queue(ndev);
napi_disable(&emac->napi);
if (ndev->phydev)
phy_stop(ndev->phydev);
del_timer_sync(&emac->rx_timeout);

/* mask all interrupts */
emac_writel(emac, 0, ENET_IRMASK_REG);
dmac_writel(iudma, 0, DMAC_IRMASK_REG, emac->rx_chan);
dmac_writel(iudma, 0, DMAC_IRMASK_REG, emac->tx_chan);

/* disable dma & emac */
bcm6348_iudma_chan_stop(iudma, emac->tx_chan);
bcm6348_iudma_chan_stop(iudma, emac->rx_chan);
bcm6348_emac_disable_mac(emac);

/* force reclaim of all tx buffers */
bcm6348_emac_tx_reclaim(ndev, 1);

/* free the rx skb ring */
for (i = 0; i < emac->rx_ring_size; i++) {
struct bcm6348_iudma_desc *desc;

if (!emac->rx_skb[i])
continue;

desc = &emac->rx_desc_cpu[i];
dma_unmap_single_attrs(dev, desc->address, emac->rx_skb_size,
DMA_FROM_DEVICE,
DMA_ATTR_SKIP_CPU_SYNC);
kfree_skb(emac->rx_skb[i]);
}

/* free remaining allocated memory */
kfree(emac->rx_skb);
kfree(emac->tx_skb);
dma_free_coherent(dev, emac->rx_desc_alloc_size, emac->rx_desc_cpu,
emac->rx_desc_dma);
dma_free_coherent(dev, emac->tx_desc_alloc_size, emac->tx_desc_cpu,
emac->tx_desc_dma);
free_irq(emac->irq_tx, ndev);
free_irq(emac->irq_rx, ndev);
free_irq(ndev->irq, ndev);

netdev_reset_queue(ndev);

return 0;
}

The above function is used to stop the EMAC driver when link down occurs. When we stop the driver, we would not allow any more interrupts. We would disable DMA engine first before stopping the EMAC device to make sure no interrupt would occur. Then we would free all




NEXT




<s> static struct symbol *sym_check_expr_deps(struct expr *e)
{
struct symbol *sym;

if (!e)
return NULL;
switch (e->type) {
case E_OR:
case E_AND:
sym = sym_check_expr_deps(e->left.expr);
if (sym)
return sym;
return sym_check_expr_deps(e->right.expr);
case E_NOT:
return sym_check_expr_deps(e->left.expr);
case E_EQUAL:
case E_GEQ:
case E_GTH:
case E_LEQ:
case E_LTH:
case E_UNEQUAL:
sym = sym_check_deps(e->left.sym);
if (sym)
return sym;
return sym_check_deps(e->right.sym);
case E_SYMBOL:
return sym_check_deps(e->left.sym);
default:
break;
}
fprintf(stderr, "Oops! How to check %d?\n", e->type);
return NULL;
}

The above function is used to check that all the dependencies to a symbol are listed in its DEPENDS.  It walks the syntax tree and when it hits a symbol, it checks that its dependencies are in the symbol's DEPENDS list.  For the example above




NEXT




<s> static int rttm_cpu_starting(unsigned int cpu)
{
struct timer_of *to = per_cpu_ptr(&rttm_to, cpu);

RTTM_DEBUG(to->of_base.base);
to->clkevt.cpumask = cpumask_of(cpu);
irq_force_affinity(to->of_irq.irq, to->clkevt.cpumask);
clockevents_config_and_register(&to->clkevt, RTTM_TICKS_PER_SEC,
RTTM_MIN_DELTA, RTTM_MAX_DELTA);
rttm_enable_irq(to->of_base.base);

return 0;
}

The above function is used to start the TSC tick timer on a target CPU where “RTTM” is a generic representation for a real time tick monitor, and “TSC” stands for time stamp counter where it basically is a CPU clock source. So, what is an




NEXT




<s> esw_get_port_tr_badgood(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

int idx = val->port_vlan;
int shift = attr->id == RT5350_ESW_ATTR_PORT_TR_GOOD ? 0 : 16;
u32 reg;

if ((ralink_soc != RT305X_SOC_RT5350) && (ralink_soc != MT762X_SOC_MT7628AN) && (ralink_soc != MT762X_SOC_MT7688))
return -EINVAL;

if (idx < 0 || idx >= RT305X_ESW_NUM_LANWAN)
return -EINVAL;

reg = esw_r32(esw, RT5350_ESW_REG_PXTPC(idx));
val->value.i = (reg >> shift) & 0xffff;

return 0;
}

The above function is used to get the bandgood and bandbad port statistics. The two fields are defined in port_tr.h. Here is the definition:

enum port_statistics {
#define STAT_PORT_STATISTICS_LEN 2





NEXT




<s> static int mt7621_nfc_write_page_hwecc(struct nand_chip *nand,
const uint8_t *buf, int oob_required,
int page)
{
struct mt7621_nfc *nfc = nand_get_controller_data(nand);
struct mtd_info *mtd = nand_to_mtd(nand);

if (mt7621_nfc_check_empty_page(nand, buf)) {
/*
* MT7621 ECC engine always generates parity code for input
* pages, even for empty pages. Doing so will write back ECC
* parity code to the oob region, which means such pages will
* no longer be empty pages.
*
* To avoid this, stop write operation if current page is an
* empty page.
*/
return 0;
}

nand_prog_page_begin_op(nand, page, 0, NULL, 0);

nfi_write16(nfc, NFI_CNFG, (CNFG_OP_CUSTOM << CNFG_OP_MODE_S) |
CNFG_AUTO_FMT_EN | CNFG_HW_ECC_EN);

mt7621_ecc_encoder_op(nfc, true);

mt7621_nfc_write_fdm(nfc);

nfi_write16(nfc, NFI_CON,
CON_NFI_BWR | (nand->ecc.steps << CON_NFI_SEC_S));

if (buf)
mt7621_nfc_write_data(nfc, buf, mtd->writesize);
else
mt7621_nfc_write_data_empty(nfc, mtd->writesize);

mt7621_nfc_wait_write_completion(nfc, nand);

mt7621_ecc_encoder_op(nfc, false);

nfi_write16(nfc, NFI_CON, 0);

return nand_prog_page_end_op(nand);
}

The above function is used to configure ECC settings for a NAND page read during read_page() function. The MT7621 SoC uses a 65-byte address and 131-byte data buffer for the NAND. However, the




NEXT




<s> int item_is_selected(void)
{
return (item_cur->node.selected != 0);
}

The above function is used to check if an item is selected, or "highlighted". So, how does GtkTreeView choose which item is selected, and how does it deselect that item when the mouse button is released?</s>




NEXT




<s> mvswitch_remove(struct phy_device *pdev)
{
struct mvswitch_priv *priv = to_mvsw(pdev);

kfree(priv);
}

The above function is used to handle a device remove from the switching controller.

int mvswitch_probe(struct platform_device *pdev, const char *name,
struct mvswitch_platform_data *pdata)
{
struct mvswitch_




NEXT




<s> ret_t rtl8367c_getAsicLutIpMulticastVidLookup(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG2, RTL8367C_LUT_IPMC_VID_HASH_OFFSET, pEnabled);
}

The above function is used to query the value of rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG2, RTL8367C_LUT_IPMC_VID_




NEXT




<s> ret_t rtl8367c_setAsicAclGpioPolarity(rtk_uint32 polarity)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_ACL_GPIO_POLARITY, RTL8367C_ACL_GPIO_POLARITY_OFFSET, polarity);
}

The above function is used to config the ACL GPIO input polarity. In switch boot, it will be used frequently. In order to save performance and resource consumption, we will use cache to reserve the polarity configuration.
AsicRegBit is a kind of memory allocated




NEXT




<s> t_openpwbyname(pwname)
const char * pwname;
{
FILE * fp;
struct t_pw * t;

if(pwname == NULL)            /* Deprecated */
return t_openpw(NULL);

if((fp = fopen(pwname, "r")) == NULL)
return NULL;

t = t_openpw(fp);
t->close_on_exit = 1;
return t;
}

The above function is used to open a password file other than the traditional /etc/passwd file, and has been deprecated since version 4.3 of the 4.4BSD-Lite kernel.

The password file is called /etc/passwd




NEXT




<s> void rtl9300_do_rx_calibration_dfe_disable(u32 sds_num)
{
u32 tap1_list[4] = {0};
u32 tap2_list[4] = {0};
u32 tap3_list[4] = {0};
u32 tap4_list[4] = {0};

rtl9300_sds_rxcal_tap_manual(sds_num, 1, true, tap1_list);
rtl9300_sds_rxcal_tap_manual(sds_num, 2, true, tap2_list);
rtl9300_sds_rxcal_tap_manual(sds_num, 3, true, tap3_list);
rtl9300_sds_rxcal_tap_manual(sds_num, 4, true, tap4_list);

mdelay(10);
}

The above function is used to disable DFE calibration via s/w.

What does s/w mean ? Is it possible in kernel to use this kind method , that is , no need to switch to another mode/profile to do this function. If possible,




NEXT




<s> rtk_api_ret_t rtk_ptp_portTrap_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicEavTrap(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the trap setting for specific port. To change the trap setting, users should use the rtk_portTrap_set.

rtk_api_ret_t rtk_portTrap_set(
rtk_




NEXT




<s> ret_t rtl8367c_getAsicIGMPAllowDynamicRouterPort(rtk_uint32 *pPmsk)
{
return rtl8367c_getAsicReg(RTL8367C_REG_IGMP_MLD_CFG4, pPmsk);
}

The above function is used to read ASIC's igmppmsk register , and the structure of the igmppmsk register is like this.In the above picture,we will get the rtl8367c_getAsicReg(RT




NEXT




<s> rtl_attr_set_int(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
int idx = attr->id + (val->port_vlan * attr->ofs);
struct rtl_phyregs port;

if (attr->id >= ARRAY_SIZE(rtl_regs))
return -EINVAL;

if ((attr->max > 0) && (val->value.i > attr->max))
return -EINVAL;

/* access to phy register 22 on port 4/5
* needs phy status save/restore */
if ((val->port_vlan > 3) &&
(rtl_regs[idx].reg == 22) &&
(rtl_regs[idx].page == 0)) {

rtl_phy_save(dev, val->port_vlan, &port);
rtl_set(dev, idx, val->value.i);
rtl_phy_restore(dev, val->port_vlan, &port);
} else {
rtl_set(dev, idx, val->value.i);
}

return 0;
}

The above function is used to configure one or more (on different ports & on the same port) TIAs depending on the id associated with the configuration attribute.

If the id is greater than or equal to 32, then all the following attributes have a negative




NEXT




<s> rtk_api_ret_t rtk_filter_vidrange_set(rtk_uint32 index, rtk_filter_vidrange_t type, rtk_uint32 upperVid, rtk_uint32 lowerVid)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

if(type >= VIDRANGE_END)
return RT_ERR_OUT_OF_RANGE;

if(lowerVid > upperVid)
return RT_ERR_INPUT;

if( (upperVid > RTL8367C_VIDMAX) || (lowerVid > RTL8367C_VIDMAX))
return RT_ERR_OUT_OF_RANGE;

if((ret = rtl8367c_setAsicAclVidRange(index, type, upperVid, lowerVid)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to set the range of video.

#include</s>




NEXT




<s> static int rtl8366s_switch_init(struct rtl8366_smi *smi)
{
struct switch_dev *dev = &smi->sw_dev;
int err;

dev->name = "RTL8366S";
dev->cpu_port = RTL8366S_PORT_NUM_CPU;
dev->ports = RTL8366S_NUM_PORTS;
dev->vlans = RTL8366S_NUM_VIDS;
dev->ops = &rtl8366_ops;
dev->alias = dev_name(smi->parent);

err = register_switch(dev, NULL);
if (err)
dev_err(smi->parent, "switch registration failed\n");

return err;
}

The above function is used to initialize the switch driver. However, the switch is only created at the point specified in rtl8366s_mdio_probe. Therefore, when the switch probe is successful, it is necessary to call rtl8366




NEXT




<s> static int rtl9310_i2c_write(struct rtl9300_i2c *i2c, u8 *buf, int len)
{
return i2c_write(REG(i2c, RTL9310_I2C_DATA), buf, len);
}

The above function is used to write some data from userspace to an i2c bus using the interface defined for rtl9300 chipset.

I would like to use this function to do some experiment using i2c bus.

My plan is




NEXT




<s> rtk_api_ret_t rtk_led_serialMode_set(rtk_led_active_t active)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ( active >= LED_ACTIVE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicLedSerialModeConfig(active,1))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the LED serial mode according to the parameter given, The active parameter shall be in the following range:
* RTL8367C Led active mode 0-3

void rtl8367c_setAs




NEXT




<s> ar8327_led_set_brightness(struct led_classdev *led_cdev,
enum led_brightness brightness)
{
struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
u8 pattern;
bool active;

active = (brightness != LED_OFF);
active ^= aled->active_low;

pattern = (active) ? AR8327_LED_PATTERN_ON :
AR8327_LED_PATTERN_OFF;

spin_lock(&aled->lock);

aled->enable_hw_mode = false;
ar8327_led_schedule_change(aled, pattern);

spin_unlock(&aled->lock);
}

The above function is used to turn off a specific led, which is used when we switch that led to off, we have to inform the core layer that we don't want that led to be on, so we have to set it to LED_OFF which will trigger the




NEXT




<s> int rtl8366_sw_get_port_stats(struct switch_dev *dev, int port,
struct switch_port_stats *stats,
int txb_id, int rxb_id)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
unsigned long long counter = 0;
int ret;

if (port >= smi->num_ports)
return -EINVAL;

ret = smi->ops->get_mib_counter(smi, txb_id, port, &counter);
if (ret)
return ret;

stats->tx_bytes = counter;

ret = smi->ops->get_mib_counter(smi, rxb_id, port, &counter);
if (ret)
return ret;

stats->rx_bytes = counter;

return 0;
}

The above function is used to get switch port statistics.</s>




NEXT




<s> static inline int fe_max_frag_size(int mtu)
{
/* make sure buf_size will be at least MAX_RX_LENGTH */
if (mtu + FE_RX_ETH_HLEN < MAX_RX_LENGTH)
mtu = MAX_RX_LENGTH - FE_RX_ETH_HLEN;

return SKB_DATA_ALIGN(FE_RX_HLEN + mtu) +
SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
}

The above function is used to calculate the maximum size of buffer needed
to receive packets of size mtu bytes or greater. The maximum frame size is
SKB_DATA_ALIGN(FE_RX_HLEN + mtu). We need to also add the minimum size




NEXT




<s> static int esw_reset_switch(struct switch_dev *dev)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

esw->global_vlan_enable = 0;
memset(esw->ports, 0, sizeof(esw->ports));
memset(esw->vlans, 0, sizeof(esw->vlans));
esw_hw_init(esw);

return 0;
}

The above function is used to reset an RT305x ethernet switch.

It’s part of the rt305x_esu driver and is called from switch_dev_reset.

It’s defined in drivers/staging




NEXT




<s> rtk_api_ret_t rtk_ptp_intControl_get(rtk_ptp_intType_t type, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtk_uint32 mask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type>=PTP_INT_TYPE_ALL)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_getAsicEavInterruptMask(&mask)) != RT_ERR_OK)
return retVal;

if (0 == (mask&(1<<type)))
*pEnable=DISABLED;
else
*pEnable=ENABLED;

return RT_ERR_OK;
}

The above function is used to set the ptp_intType_t type of Interrupt. Please refer to the rtl8367c_ptp_intmap.h to check the list of ptp_intType_t for the interrupt name.




NEXT




<s> ar8xxx_id_chip(struct ar8xxx_priv *priv)
{
int ret;

ret = ar8xxx_read_id(priv);
if(ret)
return ret;

switch (priv->chip_ver) {
case AR8XXX_VER_AR8216:
priv->chip = &ar8216_chip;
break;
case AR8XXX_VER_AR8236:
priv->chip = &ar8236_chip;
break;
case AR8XXX_VER_AR8316:
priv->chip = &ar8316_chip;
break;
case AR8XXX_VER_AR8327:
priv->chip = &ar8327_chip;
break;
case AR8XXX_VER_AR8337:
priv->chip = &ar8337_chip;
break;
default:
pr_err("ar8216: Unknown Atheros device [ver=%d, rev=%d]\n",
priv->chip_ver, priv->chip_rev);

return -ENODEV;
}

return 0;
}

The above function is used to find out the chip in the driver, which in turn calls the
ar8xxx_read_id(priv) function, which in the case of ar8216 is defined as below :

static int ar8216




NEXT




<s> ret_t rtl8367c_setAsicStormFilterBroadcastMeter(rtk_uint32 port, rtk_uint32 meter)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(meter > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

return rtl8367c_setAsicRegBits(RTL8367C_STORM_BCAST_METER_CTRL_REG(port), RTL8367C_STORM_BCAST_METER_CTRL_MASK(port), meter);
}

The above function is used to set the port's broadcast meter id. This means at most 4 ports can set the same broadcast meter id, one packet per second only. As for storm control function, the broadcast packets are checked, so that storm control function will prevent the




NEXT




<s> static int rtl8366s_probe(struct platform_device *pdev)
{
static int rtl8366_smi_version_printed;
struct rtl8366_smi *smi;
int err;

if (!rtl8366_smi_version_printed++)
printk(KERN_NOTICE RTL8366S_DRIVER_DESC
" version " RTL8366S_DRIVER_VER"\n");

smi = rtl8366_smi_probe(pdev);
if (IS_ERR(smi))
return PTR_ERR(smi);

smi->clk_delay = 10;
smi->cmd_read = 0xa9;
smi->cmd_write = 0xa8;
smi->ops = &rtl8366s_smi_ops;
smi->cpu_port = RTL8366S_PORT_NUM_CPU;
smi->num_ports = RTL8366S_NUM_PORTS;
smi->num_vlan_mc = RTL8366S_NUM_VLANS;
smi->mib_counters = rtl8366s_mib_counters;
smi->num_mib_counters = ARRAY_SIZE(rtl8366s_mib_counters);

err = rtl8366_smi_init(smi);
if (err)
goto err_free_smi;

platform_set_drvdata(pdev, smi);

err = rtl8366s_switch_init(smi);
if (err)
goto err_clear_drvdata;

return 0;

err_clear_drvdata:
platform_set_drvdata(pdev, NULL);
rtl8366_smi_cleanup(smi);
err_free_smi:
kfree(smi);
return err;
}

The above function is used to initialize the RTL8366S switch using the SMI interface. It will first try to find the SMI module using the rtl8366_smi_probe function. It will then set the clk_delay,




NEXT




<s> ret_t rtl8367c_getAsicVlanEgressTagMode(rtk_uint32 port, rtl8367c_egtagmode *pTagMode)
{
rtk_uint32 regData;
ret_t  retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if((retVal = rtl8367c_getAsicRegBits(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_VLAN_EGRESS_MDOE_MASK, &regData)) != RT_ERR_OK)
return retVal;

*pTagMode = (rtl8367c_egtagmode)regData;
return RT_ERR_OK;
}

The above function is used to get the current mode of Asic Vlan Egress Tag mode.
The input is the port number, the output is the AsicVlanEgressTagMode.
The type of AsicVlanEgressTagMode is
ty




NEXT




<s> void ag71xx_phy_disconnect(struct ag71xx *ag)
{
phy_disconnect(ag->phy_dev);
}

The above function is used to disconnect from the phy, however it is called without ensuring that the phy disconnect is done properly, which can introduce unexpected behavior.

The bug is triggered by uninitializing the ag71xx driver and then issuing a




NEXT




<s> static bool sprom_override_devid(struct ssb_fbs *priv, struct ssb_sprom *out,
const u16 *in)
{
SPEX(dev_id, SSB_SPROM1_PID, 0xFFFF, 0);
return !!out->dev_id;
}

The above function is used to test whether we should
override the embedded device ID of the chip. The macro
SSB_SPROM1_PID is used to retrieve the ID from the first
8 bytes of the SPROM (SPI programmable one time




NEXT




<s> handle_ping(struct ead_packet *pkt, int len, int *nstate)
{
struct ead_msg *msg = &pktbuf->msg;
struct ead_msg_pong *pong = EAD_DATA(msg, pong);
int slen;

slen = strlen(dev_name);
if (slen > 1024)
slen = 1024;

msg->len = htonl(sizeof(struct ead_msg_pong) + slen);
strncpy(pong->name, dev_name, slen);
pong->name[slen] = 0;
pong->auth_type = htons(EAD_AUTH_MD5);

return true;
}

The above function is used to handle the ping packet. It is very straight forward. First it gets the packet length, and then it gets the content of the packet and check the name. If the name matches, it sends out a pong packet with the client name filled




NEXT




<s> static int rtl8366rb_get_mc_index(struct rtl8366_smi *smi, int port, int *val)
{
u32 data;
int err;

if (port >= RTL8366RB_NUM_PORTS)
return -EINVAL;

err = rtl8366_smi_read_reg(smi, RTL8366RB_PORT_VLAN_CTRL_REG(port),
&data);
if (err)
return err;

*val = (data >> RTL8366RB_PORT_VLAN_CTRL_SHIFT(port)) &
RTL8366RB_PORT_VLAN_CTRL_MASK;

return 0;

}

The above function is used to get the MC index (VID) of
a given port.

int rtl8366rb_port_vlan_idx(struct rtl8366_local *lp, int port,
int *v




NEXT




<s> static int  rtl8367b_probe(struct platform_device *pdev)
{
struct rtl8366_smi *smi;
int err;

smi = rtl8366_smi_probe(pdev);
if (IS_ERR(smi))
return PTR_ERR(smi);

smi->clk_delay = 1500;
smi->cmd_read = 0xb9;
smi->cmd_write = 0xb8;
smi->ops = &rtl8367b_smi_ops;
smi->num_ports = RTL8367B_NUM_PORTS;
if (of_property_read_u32(pdev->dev.of_node, "cpu_port", &smi->cpu_port)
|| smi->cpu_port >= smi->num_ports)
smi->cpu_port = RTL8367B_CPU_PORT_NUM;
smi->num_vlan_mc = RTL8367B_NUM_VLANS;
smi->mib_counters = rtl8367b_mib_counters;
smi->num_mib_counters = ARRAY_SIZE(rtl8367b_mib_counters);

err = rtl8366_smi_init(smi);
if (err)
goto err_free_smi;

platform_set_drvdata(pdev, smi);

err = rtl8367b_switch_init(smi);
if (err)
goto err_clear_drvdata;

return 0;

err_clear_drvdata:
platform_set_drvdata(pdev, NULL);
rtl8366_smi_cleanup(smi);
err_free_smi:
kfree(smi);
return err;
}

The above function is used to identify the PHY for RTL8367B device.

This patch will also need an addition to driver/of/phy.c

static const struct of_phy_auxdata pcmcia_rtl83




NEXT




<s> ret_t rtl8367c_setAsicUnknownIPv4MulticastBehavior(rtk_uint32 port, rtk_uint32 behave)
{
if(port >  RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(behave >= L3_UNKOWN_MULTICAST_END)
return RT_ERR_NOT_ALLOWED;

return rtl8367c_setAsicRegBits(RTL8367C_UNKNOWN_IPV4_MULTICAST_REG(port), RTL8367C_UNKNOWN_IPV4_MULTICAST_MASK(port), behave);
}

The above function is used to configure which way multicast frames are treated when they are arriving a port.
The ports should be set to a behavior of at least MCAST_L3_PROCESSING or else when the MAC layer forwards an unknown IPv4




NEXT




<s> int b53_swconfig_switch_register(struct b53_device *dev)
{
int ret;

if (dev->pdata) {
dev->chip_id = dev->pdata->chip_id;
dev->enabled_ports = dev->pdata->enabled_ports;
dev->sw_dev.alias = dev->pdata->alias;
}

if (!dev->chip_id && b53_swconfig_switch_detect(dev))
return -EINVAL;

ret = b53_switch_init(dev);
if (ret)
return ret;

pr_info("found switch: %s, rev %i\n", dev->sw_dev.name, dev->core_rev);

return register_switch(&dev->sw_dev, NULL);
}

The above function is used to probe a B53 PCI device and
configure it to function as a (potentially software based) switch. The
actual hardware based switch (which runs in B53's PLD-accelerated ASIC core)





NEXT




<s> static int rtl8366s_set_vlan_4k(struct rtl8366_smi *smi,
const struct rtl8366_vlan_4k *vlan4k)
{
u32 data[2];
int err;
int i;

if (vlan4k->vid >= RTL8366S_NUM_VIDS ||
vlan4k->member > RTL8366S_VLAN_MEMBER_MASK ||
vlan4k->untag > RTL8366S_VLAN_UNTAG_MASK ||
vlan4k->fid > RTL8366S_FIDMAX)
return -EINVAL;

data[0] = vlan4k->vid & RTL8366S_VLAN_VID_MASK;
data[1] = (vlan4k->member & RTL8366S_VLAN_MEMBER_MASK) |
((vlan4k->untag & RTL8366S_VLAN_UNTAG_MASK) <<
RTL8366S_VLAN_UNTAG_SHIFT) |
((vlan4k->fid & RTL8366S_VLAN_FID_MASK) <<
RTL8366S_VLAN_FID_SHIFT);

for (i = 0; i < 2; i++) {
err = rtl8366_smi_write_reg(smi,
RTL8366S_VLAN_TABLE_WRITE_BASE + i,
data[i]);
if (err)
return err;
}

/* write table access control word */
err = rtl8366_smi_write_reg(smi, RTL8366S_TABLE_ACCESS_CTRL_REG,
RTL8366S_TABLE_VLAN_WRITE_CTRL);

return err;
}

The above function is used to set the VLAN table,
to set the VLAN-tagging policy for given packet.

The code structure is in the following:
if
for
if
err =
if
err =

if the index (




NEXT




<s> void dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);
void chip_version(void);
void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to define big and litte endian as defined in PCR.
It might be used if deusource pointer is used in the deu_dma_priv.


/*! \fn u32 deu_dma_priv_




NEXT




<s> static int rtl83xx_alloc_router_mac(struct rtl838x_switch_priv *priv, u64 mac)
{
int free_mac = -1;
struct rtl93xx_rt_mac m;

mutex_lock(&priv->reg_mutex);
for (int i = 0; i < MAX_ROUTER_MACS; i++) {
priv->r->get_l3_router_mac(i, &m);
if (free_mac < 0 && !m.valid) {
free_mac = i;
continue;
}
if (m.valid && m.mac == mac) {
free_mac = i;
break;
}
}

if (free_mac < 0) {
pr_err("No free router MACs, cannot offload\n");
mutex_unlock(&priv->reg_mutex);
return -1;
}

m.valid = true;
m.mac = mac;
m.p_type = 0; /* An individual port, not a trunk port */
m.p_id = 0x3f;			/* Listen on any port */
m.p_id_mask = 0;
m.vid = 0;			/* Listen on any VLAN... */
m.vid_mask = 0; 		/* ... so mask needs to be 0 */
m.mac_mask = 0xffffffffffffULL;	/* We want an exact match of the interface MAC */
m.action = L3_FORWARD;		/* Route the packet */
priv->r->set_l3_router_mac(free_mac, &m);

mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to add/update a port configuration for L3 routing.
Before updating the configuration we always try to find an available hardware port and if one is
available, we update the configuration. Otherwise we fail-open and assume that
updating the




NEXT




<s> static int wlc_iovar(wlc_param param, void *data, void *value)
{
int *val = (int *) value;
char *iov = *((char **) data);
int ret = 0;

if (param & SET) {
switch(param & PARAM_TYPE) {
case INT:
ret = wl_iovar_setint(interface, iov, *val);
break;
case MAC:
ret = wl_iovar_set(interface, iov, value, 6);
break;
}
}
if (param & GET) {
switch(param & PARAM_TYPE) {
case INT:
ret = wl_iovar_get(interface, iov, val, sizeof(int));
break;
case MAC:
ret = wl_iovar_get(interface, iov, value, 6);
break;
}
}

return ret;
}

The above function is used to set/get wireless NIC parameters or to register them with the kernel module.

The wlc_init_param function is as follows:

static int wlc_init_param(struct adapter *padapter, struct wlc




NEXT




<s> static int rtl8366rb_sw_get_mirror_tx_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366RB_PMCR, &data);
if (data & RTL8366RB_PMCR_MIRROR_TX)
val->value.i = 1;
else
val->value.i = 0;

return 0;
}

The above function is used to get TX port mirror
enable capability. We get current TX mirror enable
state if the MAC mirror is enabled, then this is OK,
but if the MAC mirror is disabled, we have no way to
return FALSE.

So the




NEXT




<s> struct expr *expr_trans_compare(struct expr *e, enum expr_type type, struct symbol *sym)
{
struct expr *e1, *e2;

if (!e) {
e = expr_alloc_symbol(sym);
if (type == E_UNEQUAL)
e = expr_alloc_one(E_NOT, e);
return e;
}
switch (e->type) {
case E_AND:
e1 = expr_trans_compare(e->left.expr, E_EQUAL, sym);
e2 = expr_trans_compare(e->right.expr, E_EQUAL, sym);
if (sym == &symbol_yes)
e = expr_alloc_two(E_AND, e1, e2);
if (sym == &symbol_no)
e = expr_alloc_two(E_OR, e1, e2);
if (type == E_UNEQUAL)
e = expr_alloc_one(E_NOT, e);
return e;
case E_OR:
e1 = expr_trans_compare(e->left.expr, E_EQUAL, sym);
e2 = expr_trans_compare(e->right.expr, E_EQUAL, sym);
if (sym == &symbol_yes)
e = expr_alloc_two(E_OR, e1, e2);
if (sym == &symbol_no)
e = expr_alloc_two(E_AND, e1, e2);
if (type == E_UNEQUAL)
e = expr_alloc_one(E_NOT, e);
return e;
case E_NOT:
return expr_trans_compare(e->left.expr, type == E_EQUAL ? E_UNEQUAL : E_EQUAL, sym);
case E_UNEQUAL:
case E_LTH:
case E_LEQ:
case E_GTH:
case E_GEQ:
case E_EQUAL:
if (type == E_EQUAL) {
if (sym == &symbol_yes)
return expr_copy(e);
if (sym == &symbol_mod)
return expr_alloc_symbol(&symbol_no);
if (sym == &symbol_no)
return expr_alloc_one(E_NOT, expr_copy(e));
} else {
if (sym == &symbol_yes)
return expr_alloc_one(E_NOT, expr_copy(e));
if (sym == &symbol_mod)
return expr_alloc_symbol(&symbol_yes);
if (sym == &symbol_no)
return expr_copy(e);
}
break;
case E_SYMBOL:
return expr_alloc_comp(type, e->left.sym, sym);
case E_LIST:
case E_RANGE:
case E_NONE:
/* panic */;
}
return NULL;
}

The above function is used to compare two expressions. If “type” is equal, it will return true; if “type” is not equal, it will return false. “symbol” is an operation to be performed.
Here is an example:
expr_trans_




NEXT




<s> static void print_entry_value(const struct tffs_entry *entry)
{
/* These are NOT NULL terminated. */
fwrite(entry->val, 1, entry->len, stdout);
}

The above function is used to print the value of the currently parsed
TFFS entry by first getting the TFFS entry and then printing the entire
value as-is. We cannot simply call __tffs_print_entry() because it prints
the complete




NEXT




<s> static int mt7530_get_port_stats(struct switch_dev *dev, int port,
struct switch_port_stats *stats)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

if (port < 0 || port >= MT7530_NUM_PORTS)
return -EINVAL;

stats->tx_bytes = get_mib_counter_port_7620(priv, MT7530_PORT_MIB_TXB_ID, port);
stats->rx_bytes = get_mib_counter_port_7620(priv, MT7530_PORT_MIB_RXB_ID, port);

return 0;
}

The above function is used to get the port statistics of MT7530 switch.
# Port statistics in mt7530.c

The port statistics function mt7530_get_port_stats() is called by the switch_dev_




NEXT




<s> ret_t rtl8367c_setAsicIGMPPortMAXGroup(rtk_uint32 port, rtk_uint32 max_group)
{
ret_t retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(max_group > RTL8367C_IGMP_MAX_GOUP)
return RT_ERR_OUT_OF_RANGE;

if(port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT01_MAX_GROUP + (port/2), RTL8367C_PORT0_MAX_GROUP_MASK << (RTL8367C_PORT1_MAX_GROUP_OFFSET * (port%2)), max_group);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT89_MAX_GROUP + (port/2), RTL8367C_PORT0_MAX_GROUP_MASK << (RTL8367C_PORT1_MAX_GROUP_OFFSET * (port%2)), max_group);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to define the number of groups the port can record per group (the port-recorded MLD group number per port) at the same time.

```
{
	struct net_device * dev;
	int err;





NEXT




<s> static int mt7530_sw_get_port_mib(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
static char buf[4096];
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
int i, len = 0;

if (val->port_vlan >= MT7530_NUM_PORTS)
return -EINVAL;

len += snprintf(buf + len, sizeof(buf) - len,
"Port %d MIB counters\n", val->port_vlan);

for (i = 0; i < ARRAY_SIZE(mt7620_port_mibs); ++i) {
u64 counter;
len += snprintf(buf + len, sizeof(buf) - len,
"%-11s: ", mt7620_port_mibs[i].name);
counter = get_mib_counter_port_7620(priv, i, val->port_vlan);
len += snprintf(buf + len, sizeof(buf) - len, "%llu\n",
counter);
}

val->value.s = buf;
val->len = len;
return 0;
}

The above function is used to read MIB counters of ports.</s>




NEXT




<s> static int lq_des3_ede_setkey(struct crypto_ablkcipher *tfm, const u8 *in_key,
unsigned int keylen)
{
struct des_ctx *dctx = crypto_ablkcipher_ctx(tfm);

//printk("setkey in %s\n", __FILE__);

dctx->controlr_M = keylen/8 + 1;   // des
dctx->key_length = keylen;

memcpy ((u8 *) (dctx->expkey), in_key, keylen);

return 0;
}

The above function is used to set the master secret key

dctx->controlr_M = keylen/8+1;

where

keylen is the size of the key used initially.

keylen/8+1 is the the key




NEXT




<s> static const char *aw9523_pinctrl_get_group_name(struct pinctrl_dev *pctldev,
unsigned int selector)
{
return aw9523_pins[selector].name;
}

The above function is used to get the name of a group. This function will
return aw9523_pins[] value according to selector, not NULL. However, the
implementation of Pinctrl's aw9523 group didn't




NEXT




<s> void fe_w32(u32 val, unsigned reg)
{
__raw_writel(val, fe_base + reg);
}

The above function is used to write a u32 value to a FE. Note that we still use __raw_writel as it is declared as a macro.

In the FE_WRITE_REGISTER struct,
1. fe_w32 is used




NEXT




<s> void rtl838x_dbgfs_cleanup(struct rtl838x_switch_priv *priv)
{
debugfs_remove_recursive(priv->dbgfs_dir);

/*	kfree(priv->dbgfs_entries); */
}

The above function is used to remove the rtl838x_dbgfs directory to release  resources and its data-structure.

The above code snippet shows

This is the first step that must be performed before the cleanup function is invoked. It is




NEXT




<s> static int __init mtdsplit_uimage_init(void)
{
register_mtd_parser(&uimage_generic_parser);

return 0;
}

The above function is used to register the uimage parsing function uimage_generic_parser. mtdsplit parses device memory and tries to detect an image. If it finds a mtd partition table and the mtd partition at the beginning of it points to an u




NEXT




<s> static int rtl8366rb_sw_get_mirror_rx_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366RB_PMCR, &data);
if (data & RTL8366RB_PMCR_MIRROR_RX)
val->value.i = 1;
else
val->value.i = 0;

return 0;
}

The above function is used to get the mirror_rx enabled stati, which
is 1 for enabled, 0 for disabled.
We can use this stati bit as a mirror rx enabled stati.
We need some steps:

1. Modify




NEXT




<s> uc_bpf_module_get_maps(uc_vm_t *vm, size_t nargs)
{
struct bpf_object *obj = uc_fn_thisval("bpf.module");
struct bpf_map *map = NULL;
uc_value_t *rv;
int i = 0;

if (!obj)
err_return(EINVAL, NULL);

rv = ucv_array_new(vm);
bpf_object__for_each_map(map, obj)
ucv_array_set(rv, i++, ucv_string_new(bpf_map__name(map)));

return rv;
}

The above function is used to create an array of map names present in the object.

The bpf_object__for_each_map macro expects the current map as the argument. BPF's API doesn't provide a method to retrieve BPF maps from




NEXT




<s> server_handle_sigint(int sig)
{
struct ead_instance *in;
struct list_head *p, *tmp;

list_for_each_safe(p, tmp, &instances) {
in = list_entry(p, struct ead_instance, list);
stop_server(in, true);
}
exit(1);
}

The above function is used to stop the server instances (EAD instances as we call them) after receiving the SIGINT signal (Ctrl-C pressed, generally). This function is registered as the sigint handler and it terminates all of the EAD instances. The actual code




NEXT




<s> static void gpio_keys_irq_work_func(struct work_struct *work)
{
struct gpio_keys_button_data *bdata = container_of(work,
struct gpio_keys_button_data, work.work);

gpio_keys_handle_button(bdata);
}

The above function is used to handle the interrupt request, which is set by our own method at the stage of config_gpio_button_data.

For the implementation of gpio_keys_handle_button, the work will be added to the workqueue.





NEXT




<s> yyterminate();
}
YY_BREAK
case 64:
YY_RULE_SETUP
YY_FATAL_ERROR( "flex scanner jammed" );
YY_BREAK

case YY_END_OF_BUFFER:
{

The above function is used to return the lexical token number that the lexical analyzer returned.

The above functions are used to return strings which describe the types of tokens that the lexical analyzer returned.  The string returned by the third function is




NEXT




<s> static inline int aca_init(struct dc_ep_dev *dev, struct aca_param *aca,
struct aca_modem_param *mdm)
{
if (WARN_ON(!dev || !aca))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_aca_init(dev->priv, aca, mdm);
}

The above function is used to initialize DC AC’A hardware. It is used to call the AC’A ACPI 3 4 interface that is located in the driver  driver/dc/dc_device_drivers/dca/drivers/v




NEXT




<s> void hostapd_ucode_free_iface(struct hostapd_iface *iface)
{
wpa_ucode_registry_remove(iface_registry, iface->ucode.idx);
}

The above function is used to remove a user space driver from hostapd iface when hostapd closes the interface.
For example, say you have 5 ifaces registered through hostapd_ucode_register. Each of them has registered 2 users




NEXT




<s> t_changepw(pwname, diff)
const char * pwname;
const struct t_pwent * diff;
{
char * bakfile;
char * bakfile2;
struct stat st;
FILE * passfp;
FILE * bakfp;

if(pwname == NULL)
pwname = DEFAULT_PASSWD;

if((passfp = fopen(pwname, "rb")) == NULL || fstat(fileno(passfp), &st) < 0)
return -1;

if((bakfile = malloc(strlen(pwname) + 5)) == NULL) {
fclose(passfp);
return -1;
}
else if((bakfile2 = malloc(strlen(pwname) + 5)) == NULL) {
fclose(passfp);
free(bakfile);
return -1;
}

sprintf(bakfile, "%s.bak", pwname);
sprintf(bakfile2, "%s.sav", pwname);

if((bakfp = fopen(bakfile2, "wb")) == NULL &&
(unlink(bakfile2) < 0 || (bakfp = fopen(bakfile2, "wb")) == NULL)) {
fclose(passfp);
free(bakfile);
free(bakfile2);
return -1;
}

#ifdef NO_FCHMOD
chmod(bakfile2, st.st_mode & 0777);
#else
fchmod(fileno(bakfp), st.st_mode & 0777);
#endif

t_pwcopy(bakfp, passfp, diff);

fclose(bakfp);
fclose(passfp);

#ifdef USE_RENAME
unlink(bakfile);
if(rename(pwname, bakfile) < 0) {
free(bakfile);
free(bakfile2);
return -1;
}
if(rename(bakfile2, pwname) < 0) {
free(bakfile);
free(bakfile2);
return -1;
}
#else
unlink(bakfile);
link(pwname, bakfile);
unlink(pwname);
link(bakfile2, pwname);
unlink(bakfile2);
#endif
free(bakfile);
free(bakfile2);

return 0;
}

The above function is used to change passwd database with one entry
either removed or added. Removed by deleting from existing file with
bakfile, added by creating a new file with bakfile2 and rename to
file pwname.





NEXT




<s> rtk_api_ret_t rtk_ptp_init(void)
{
/* Check initialization state */
RTK_CHK_INIT_STATE();


return RT_ERR_OK;
}

The above function is used to perform initial configuration for PTP protocol.

<hr>


rtk_api_ret_t rtk_ptp_set(rtk_ptp_set_t *ptp_set)
{





NEXT




<s> int rtl838x_write_mmd_phy(u32 port, u32 addr, u32 reg, u32 val)
{
int err;
u32 v;

pr_debug("MMD write: port %d, dev %d, reg %d, val %x\n", port, addr, reg, val);
val &= 0xffff;
mutex_lock(&smi_lock);

err = rtl838x_smi_wait_op(100000);
if (err)
goto errout;

sw_w32(1 << port, RTL838X_SMI_ACCESS_PHY_CTRL_0);
mdelay(10);

sw_w32_mask(0xffff0000, val << 16, RTL838X_SMI_ACCESS_PHY_CTRL_2);

sw_w32_mask(0x1f << 16, addr << 16, RTL838X_SMI_ACCESS_PHY_CTRL_3);
sw_w32_mask(0xffff, reg, RTL838X_SMI_ACCESS_PHY_CTRL_3);
/* mmd-access | write | cmd-start */
v = 1 << 1 | 1 << 2 | 1;
sw_w32(v, RTL838X_SMI_ACCESS_PHY_CTRL_1);

err = rtl838x_smi_wait_op(100000);
if (err)
goto errout;

err = 0;

errout:
mutex_unlock(&smi_lock);
return err;
}

The above function is used to send MMD write commands to the PHY. It takes 4 parameters, the first one is the physical port number. The second parameter is the phy address. The third and fourth parameters are the register address and the value to write.





NEXT




<s> uc_bpf_module_get_program(uc_vm_t *vm, size_t nargs)
{
struct bpf_object *obj = uc_fn_thisval("bpf.module");
struct bpf_program *prog;
uc_value_t *name = uc_fn_arg(0);
struct uc_bpf_fd *f;
int fd;

if (!obj || !name || ucv_type(name) != UC_STRING)
err_return(EINVAL, NULL);

prog = bpf_object__find_program_by_name(obj, ucv_string_get(name));
if (!prog)
err_return(errno, NULL);

fd = bpf_program__fd(prog);
if (fd < 0)
err_return(EINVAL, NULL);

f = xalloc(sizeof(*f));
f->fd = fd;

return uc_resource_new(program_type, f);
}

The above function is used to get a resource of bpf.module.program type.

It is passed the name of a module's program and the module pointer into
which it was loaded. If you need to get a program by name and without its
module




NEXT




<s> static int __rtl8366_smi_write_reg(struct rtl8366_smi *smi,
u32 addr, u32 data, bool ack)
{
unsigned long flags;
int ret;

spin_lock_irqsave(&smi->lock, flags);

rtl8366_smi_start(smi);

/* send WRITE command */
ret = rtl8366_smi_write_byte(smi, smi->cmd_write);
if (ret)
goto out;

/* set ADDR[7:0] */
ret = rtl8366_smi_write_byte(smi, addr & 0xff);
if (ret)
goto out;

/* set ADDR[15:8] */
ret = rtl8366_smi_write_byte(smi, addr >> 8);
if (ret)
goto out;

/* write DATA[7:0] */
ret = rtl8366_smi_write_byte(smi, data & 0xff);
if (ret)
goto out;

/* write DATA[15:8] */
if (ack)
ret = rtl8366_smi_write_byte(smi, data >> 8);
else
ret = rtl8366_smi_write_byte_noack(smi, data >> 8);
if (ret)
goto out;

ret = 0;

out:
rtl8366_smi_stop(smi);
spin_unlock_irqrestore(&smi->lock, flags);

return ret;
}

The above function is used to perform a write register operation. What is the
meaning of the following comment?

/* write DATA[15:8] */
if (ack)
ret = rtl8366_smi_write_byte




NEXT




<s> ret_t rtl8367c_setAsicRemarkingDot1pAbility(rtk_uint32 port, rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_1QREMARK_ENABLE_OFFSET, enabled);
}

The above function is used to enable/disable per-port 1Q Rx remarking support, 1Q Rx remarking allows RX traffic in 1Q to be marked and re-queued differently to the same packet in queues other than the 




NEXT




<s> swlib_get_attr(struct switch_dev *dev, struct switch_attr *attr, struct switch_val *val)
{
int cmd;
int err;

switch(attr->atype) {
case SWLIB_ATTR_GROUP_GLOBAL:
cmd = SWITCH_CMD_GET_GLOBAL;
break;
case SWLIB_ATTR_GROUP_PORT:
cmd = SWITCH_CMD_GET_PORT;
break;
case SWLIB_ATTR_GROUP_VLAN:
cmd = SWITCH_CMD_GET_VLAN;
break;
default:
return -EINVAL;
}

memset(&val->value, 0, sizeof(val->value));
val->len = 0;
val->attr = attr;
val->err = -EINVAL;
err = swlib_call(cmd, store_val, send_attr, val);
if (!err)
err = val->err;

return err;
}

The above function is used to read the specified attribute that is stored inside switch_dev structure.

Let’s take an example for port speed that is defined using following macro in switch_types.h header file:

SWLIB_ATTR(port_speed,




NEXT




<s> void update_leds(rule_t *rules, int q)
{
rule_t *rule = rules;
while (rule)
{
int b;
/* offset and factore correction according to rule */
b = ( q + rule->boffset ) * rule->bfactor;
if ( b < 0 )
b=0;
if ( b > 255 )
b=255;

if ( q >= rule->minq && q <= rule->maxq )
set_led(rule->led, (unsigned char)b);
else
set_led(rule->led, 0);

rule = rule->next;
}
}

The above function is used to change one LED to a specific brightness depending on a variable q from 0 to 255. I would like q to act as a multiplicative factor that does the following: It will turn the LED off if q is less than




NEXT




<s> static void rtl838x_mac_pcs_get_state(struct phylink_config *config,
struct phylink_link_state *state)
{
u32 speed;
struct net_device *dev = container_of(config->dev, struct net_device, dev);
struct rtl838x_eth_priv *priv = netdev_priv(dev);
int port = priv->cpu_port;

pr_info("In %s\n", __func__);

state->link = priv->r->get_mac_link_sts(port) ? 1 : 0;
state->duplex = priv->r->get_mac_link_dup_sts(port) ? 1 : 0;

pr_info("%s link status is %d\n", __func__, state->link);
speed = priv->r->get_mac_link_spd_sts(port);
switch (speed) {
case 0:
state->speed = SPEED_10;
break;
case 1:
state->speed = SPEED_100;
break;
case 2:
state->speed = SPEED_1000;
break;
case 5:
state->speed = SPEED_2500;
break;
case 6:
state->speed = SPEED_5000;
break;
case 4:
state->speed = SPEED_10000;
break;
default:
state->speed = SPEED_UNKNOWN;
break;
}

state->pause &= (MLO_PAUSE_RX | MLO_PAUSE_TX);
if (priv->r->get_mac_rx_pause_sts(port))
state->pause |= MLO_PAUSE_RX;
if (priv->r->get_mac_tx_pause_sts(port))
state->pause |= MLO_PAUSE_TX;
}

The above function is used to get RTL/855E Rx/Tx link statistics.

In the main loop of the kernel driver, RTL855E_LOOPBACK_LINK_STATE
will be set, and the network link state




NEXT




<s> radius_user_parse_methods(struct eap_user *eap, struct blob_attr *data)
{
struct blob_attr *cur;
int rem, n = 0;

if (!data)
return;

blobmsg_for_each_attr(cur, data, rem) {
const char *method;

if (blobmsg_type(cur) != BLOBMSG_TYPE_STRING)
continue;

if (n == EAP_MAX_METHODS)
break;

method = blobmsg_get_string(cur);
eap->methods[n].method = eap_server_get_type(method, &eap->methods[n].vendor);
if (eap->methods[n].vendor == EAP_VENDOR_IETF &&
eap->methods[n].method == EAP_TYPE_NONE) {
if (!strcmp(method, "TTLS-PAP")) {
eap->ttls_auth |= EAP_TTLS_AUTH_PAP;
continue;
}
if (!strcmp(method, "TTLS-CHAP")) {
eap->ttls_auth |= EAP_TTLS_AUTH_CHAP;
continue;
}
if (!strcmp(method, "TTLS-MSCHAP")) {
eap->ttls_auth |= EAP_TTLS_AUTH_MSCHAP;
continue;
}
if (!strcmp(method, "TTLS-MSCHAPV2")) {
eap->ttls_auth |= EAP_TTLS_AUTH_MSCHAPV2;
continue;
}
}
n++;
}
}

The above function is used to construct the list of supported EAP methods. The methods supported by both vendor and IETF are stored in the array of struct eap_method.</s>




NEXT




<s> ar8xxx_sw_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

if (val->port_vlan >= dev->vlans)
return -EINVAL;

priv->vlan_id[val->port_vlan] = val->value.i;
return 0;
}

The above function is used to set SW_ATTR_PORT_VID switch attribute
(defined as ar8xxx_sw_attr_port_vid, it tells which port is assigned with
vlan tag), for example, when we set the same vlan tag 




NEXT




<s> static void rtl83xx_phylink_mac_link_down(struct dsa_switch *ds, int port,
unsigned int mode,
phy_interface_t interface)
{
struct rtl838x_switch_priv *priv = ds->priv;

/* Stop TX/RX to port */
sw_w32_mask(0x3, 0, priv->r->mac_port_ctrl(port));

/* No longer force link */
sw_w32_mask(0x3, 0, priv->r->mac_force_mode_ctrl(port));
}

The above function is used to call when link is down. We can check by dmesg that when it is called.

But the link was not really down. The reason for that is that the mac port ctrl register does not have
bit that tells you if link




NEXT




<s> extern int rtl838x_phy_init(struct rtl838x_eth_priv *priv);
extern int rtl838x_read_sds_phy(int phy_addr, int phy_reg);
extern int rtl839x_read_sds_phy(int phy_addr, int phy_reg);
extern int rtl839x_write_sds_phy(int phy_addr, int phy_reg, u16 v);
extern int rtl930x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl930x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl931x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl931x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl930x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl930x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);
extern int rtl931x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl931x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);

/* On the RTL93XX, the RTL93XX_DMA_IF_RX_RING_CNTR track the fill level of
* the rings. Writing x into these registers substracts x from its content.
* When the content reaches the ring size, the ASIC no longer adds
* packets to this receive queue.
*/
void rtl838x_update_cntr(int r, int released)
{
/* This feature is not available on RTL838x SoCs */
}

The above function is used to tell the driver to stop inserting packets into
this queue. In the RTL93XX, it is used to update the CNTR registers located
in the DMA IF. The following function is used to set the CNTR to




NEXT




<s> static void rtl838x_vlan_profile_setup(int profile)
{
u32 pmask_id = UNKNOWN_MC_PMASK;
/* Enable L2 Learning BIT 0, portmask UNKNOWN_MC_PMASK for unknown MC traffic flooding */
u32 p = 1 | pmask_id << 1 | pmask_id << 10 | pmask_id << 19;

sw_w32(p, RTL838X_VLAN_PROFILE(profile));

/* RTL8380 and RTL8390 use an index into the portmask table to set the
* unknown multicast portmask, setup a default at a safe location
* On RTL93XX, the portmask is directly set in the profile,
* see e.g. rtl9300_vlan_profile_setup
*/
rtl838x_write_mcast_pmask(UNKNOWN_MC_PMASK, 0x1fffffff);
}

The above function is used to set vlan profile in RTL8390.</s>




NEXT




<s> ret_t rtl8367c_setAsicStormFilterExtEnablePortMask(rtk_uint32 portmask)
{
ret_t retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_EXT_EN_PORTMASK_MASK, portmask & 0x3FF);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_EXT_EN_PORTMASK_EXT_MASK, (portmask >> 10)&1);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set Storm Filter’s portmask, the portmask is actually bit map. This function set the portmask of RTL8367C_REG_STORM_EXT_CFG’s STORM_EXT_EN_PORTMASK




NEXT




<s> static inline bool __ar934x_nfc_is_dma_ready(struct ar934x_nfc *nfc)
{
u32 status;

status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_DMA_CTRL);
return (status & AR934X_NFC_DMA_CTRL_DMA_READY) != 0;
}

The above function is used to check if interrupt is enabled after

struct ar934x_nfc nfc;
nfc.nfc_reg = ar934x_get_nfc_reg(dev); /* This can take a while




NEXT




<s> static void rtl838x_pie_lookup_enable(struct rtl838x_switch_priv *priv, int index)
{
int block = index / PIE_BLOCK_SIZE;
u32 block_state = sw_r32(RTL838X_ACL_BLK_LOOKUP_CTRL);

/* Make sure rule-lookup is enabled in the block */
if (!(block_state & BIT(block)))
sw_w32(block_state | BIT(block), RTL838X_ACL_BLK_LOOKUP_CTRL);
}

The above function is used to enable some rules in the switch’s Forwarding Table. It was added by the developers to make sure that rule-lookup is enabled in the block before adding new rules. A couple of lines below, it calls sw_w32 to




NEXT




<s> rtk_api_ret_t rtk_vlan_tagMode_get(rtk_port_t port, rtk_vlan_tagMode_t *pTag_mode)
{
rtk_api_ret_t retVal;
rtl8367c_egtagmode  mode;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pTag_mode)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicVlanEgressTagMode(rtk_switch_port_L2P_get(port), &mode)) != RT_ERR_OK)
return retVal;

*pTag_mode = (rtk_vlan_tagMode_t)mode;
return RT_ERR_OK;
}

The above function is used to get the current operation mode of the VLAN tagging.
The possible tagging modes are:

* RTK_VID_TAG (VLAN ID tagging) and

* RTK_CPUID_TAG (80




NEXT




<s> void hostapd_ubus_remove_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
{
hostapd_ubus_vlan_action(hapd, vlan, "vlan_remove");
}

The above function is used to remove the VLAN configuration entries from Ubuntu’s ubus daemon (used for dbus interaction).  It calls the following function which is meant to perform the actual removal of the vlan entries, after first ensuring that no active




NEXT




<s> mtk_bmt_init_bbt(struct device_node *np)
{
int buf_size = round_up(bmtd.total_blks >> 2, bmtd.blk_size);
int ret;

bmtd.bbt_buf = kmalloc(buf_size, GFP_KERNEL);
if (!bmtd.bbt_buf)
return -ENOMEM;

memset(bmtd.bbt_buf, 0xff, buf_size);
bmtd.mtd->size -= 4 * bmtd.mtd->erasesize;

ret = mtk_bmt_read_bbt();
if (ret)
return ret;

bmtd.bmt_pgs = buf_size / bmtd.pg_size;

return 0;
}

The above function is used to initialize the bad block table in the
main.c mtd (nv memtech dev).

I tried to comment out the above line "bmtd.bmt_pgs = buf_size / bmtd.pg_size




NEXT




<s> ret_t rtl8367c_getAsicFlowControlPortPrivateThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_PORT_PRIVATE_OFF_MASK, pOffThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_PORT_PRIVATE_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to get Port private threshold.
If the function is called in PCP mode,then the threshold value of the port is the value returned by the above function.
I need to check the port private mode of a specific port and if it is in




NEXT




<s> ar8xxx_start(struct ar8xxx_priv *priv)
{
int ret;

priv->init = true;

ret = priv->chip->hw_init(priv);
if (ret)
return ret;

ret = ar8xxx_sw_reset_switch(&priv->dev);
if (ret)
return ret;

priv->init = false;

ar8xxx_mib_start(priv);

return 0;
}

The above function is used to initialize the driver. If the initialization successfully finished it will set the init flag as true. The function ar8xxx_mib_start()
will be discussed below. But, before that I will give some idea about the function hw_init




NEXT




<s> static int b53_srab_op(struct b53_device *dev, u8 page, u8 reg, u32 op)
{
int i;
u32 cmdstat;
u8 __iomem *regs = dev->priv;

/* set register address */
cmdstat = (page << B53_SRAB_CMDSTAT_PAGE) |
(reg << B53_SRAB_CMDSTAT_REG) |
B53_SRAB_CMDSTAT_GORDYN |
op;
writel(cmdstat, regs + B53_SRAB_CMDSTAT);

/* check if operation completed */
for (i = 0; i < 5; ++i) {
cmdstat = readl(regs + B53_SRAB_CMDSTAT);
if (!(cmdstat & B53_SRAB_CMDSTAT_GORDYN))
break;
usleep_range(10, 100);
}

if (WARN_ON(i == 5))
return -EIO;

return 0;
}

The above function is used to write or read to the SRAM register. It just
sets the register address and the operation type, and uses 200us as the poll
interval.

Below are the two functions used by the SRAM driver to access




NEXT




<s> struct symbol *prop_get_symbol(struct property *prop)
{
if (prop->expr && (prop->expr->type == E_SYMBOL ||
prop->expr->type == E_LIST))
return prop->expr->left.sym;
return NULL;
}

The above function is used to get a property with type E_SYMBOL (a symbol) and
E_LIST (a list).</s>




NEXT




<s> void AT91F_MCI_Handler(void)
{
int status;

status = ( AT91C_BASE_MCI->MCI_SR & AT91C_BASE_MCI->MCI_IMR );

AT91F_MCI_Device_Handler(&MCI_Device,status);
}

The above function is used to check if there is a MCI interrupt occuring or not. If there is an interrupt occuring, a call to MCI_Device_Handler function is made by checking the status of MCI Registers and their respective masks to see which M




NEXT




<s> int rt3050_esw_has_carrier(struct fe_priv *priv)
{
struct rt305x_esw *esw = priv->soc->swpriv;
u32 link;
int i;
bool cpuport;

link = esw_r32(esw, RT305X_ESW_REG_POA);
link >>= RT305X_ESW_POA_LINK_SHIFT;
cpuport = link & BIT(RT305X_ESW_PORT6);
link &= RT305X_ESW_POA_LINK_MASK;
for (i = 0; i <= RT305X_ESW_PORT5; i++) {
if (priv->link[i] != (link & BIT(i)))
dev_info(esw->dev, "port %d link %s\n", i, link & BIT(i) ? "up" : "down");
priv->link[i] = link & BIT(i);
}

return !!link && cpuport;
}

The above function is used to determine if there is carrier on all ports of the
switch, and this function is called by the fe_has_carrier function (line 830), which
returns TRUE or FALSE to indicate if there is carrier. If fe_




NEXT




<s> void rtk_hal_qos_get_dscp2pri(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;
rtk_pri_t Int_pri;

ret = rtk_qos_dscpPriRemap_get(data->qos_dscp, &Int_pri);
if (ret != 0)
printk("rtk_qos_dscpPriRemap_set failed\n");
else
printk("dscp%d priority is %d\n", data->qos_dscp, Int_pri);
}

The above function is used to get DSCP-priority mapping relationship
of a certain priority. For an 802.1p priority, the mapped DSCP is
0x10 and the corresponding priority is 1. When the device only
sup




NEXT




<s> adm6996_set_data(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);

if (val->value.i > 65535)
return -EINVAL;

w16(priv, priv->addr, val->value.i);

return 0;
};

The above function is used to set a value in the EEPROM. The only trouble is that it takes a 16 bit integer and it will write the most-significant 16 bits into a 32-bit register. The least-sign




NEXT




<s> static int rtl8367b_is_vlan_valid(struct rtl8366_smi *smi, unsigned vlan)
{
unsigned max = RTL8367B_NUM_VLANS;

if (smi->vlan4k_enabled)
max = RTL8367B_NUM_VIDS - 1;

if (vlan == 0 || vlan >= max)
return 0;

return 1;
}

The above function is used to validate the VLAN id before adding any
VLAN interface.

Now, this codepath has a bug that smi is accessed directly (it is
never initialized) instead of taking reference with vlan_get() or
vlan




NEXT




<s> ar8327_led_register(struct ar8327_led *aled)
{
int ret;

ret = led_classdev_register(NULL, &aled->cdev);
if (ret < 0)
return ret;

if (aled->mode == AR8327_LED_MODE_HW) {
ret = device_create_file(aled->cdev.dev,
&dev_attr_enable_hw_mode);
if (ret)
goto err_unregister;
}

return 0;

err_unregister:
led_classdev_unregister(&aled->cdev);
return ret;
}

The above function is used to register an led device with the led_classdev which is not mandatory always. You may need to just directly call the led_hw_mode_register().</s>




NEXT




<s> int pcibios_map_irq(const struct pci_dev *pci_dev, u8 slot, u8 pin)
{
return bmips_pci_irq;
}

The above function is used to map irq to different slot in the board. Since there is only one PCI device in this example. The above mapping will be same as the slot number. This is also reflected in the below code. So the slot number and irq number will be same




NEXT




<s> rtk_api_ret_t rtk_switch_greenEthernet_set(rtk_enable_t enable)
{
rtk_api_ret_t retVal;
rtk_uint32 port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

RTK_SCAN_ALL_LOG_PORT(port)
{
if(rtk_switch_isUtpPort(port) == RT_ERR_OK)
{
if ((retVal = rtl8367c_setAsicPowerSaving(rtk_switch_port_L2P_get(port),enable))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicGreenEthernet(rtk_switch_port_L2P_get(port), enable))!=RT_ERR_OK)
return retVal;
}
}

return RT_ERR_OK;
}

The above function is used to enable/disable Green Ethernet features for all ports.</s>




NEXT




<s> swconfig_set_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct switch_port *ports = val->value.ports;
const struct switch_dev_ops *ops = dev->ops;
int i;

if (val->port_vlan >= dev->vlans)
return -EINVAL;

/* validate ports */
if (val->len > dev->ports)
return -EINVAL;

if (!ops->set_vlan_ports)
return -EOPNOTSUPP;

for (i = 0; i < val->len; i++) {
if (ports[i].id >= dev->ports)
return -EINVAL;

if (ops->set_port_pvid &&
!(ports[i].flags & (1 << SWITCH_PORT_FLAG_TAGGED)))
ops->set_port_pvid(dev, ports[i].id, val->port_vlan);
}

return ops->set_vlan_ports(dev, val);
}

The above function is used to add/remove the port from/to the VLAN.

In OVSV3 switch, VID is not managed internally, it must be configured
via command line configuration. The VID is allocated before adding the
ports into




NEXT




<s> ret_t rtl8367c_getAsicRldpMagicNum(ether_addr_t *pSeed)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint16 *accessPtr;
rtk_uint32 i;

accessPtr = (rtk_uint16*)pSeed;

for(i = 0; i < 3; i++)
{
retVal = rtl8367c_getAsicReg(RTL8367C_RLDP_MAGIC_NUM_REG_BASE + i, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*accessPtr = regData;
accessPtr++;
}

return retVal;
}

The above function is used to get the magic number, and there should be three values according to the spec.

It has a different issue now. The access_ptr seems to be just a random memory. A breakpoint shows it's

0x81




NEXT




<s> void hostapd_ucode_reload_bss(struct hostapd_data *hapd)
{
uc_value_t *val;

if (wpa_ucode_call_prepare("bss_reload"))
return;

val = hostapd_ucode_bss_get_uval(hapd);
uc_value_push(ucv_get(ucv_string_new(hapd->conf->iface)));
uc_value_push(ucv_get(val));
ucv_put(wpa_ucode_call(2));
ucv_gc(vm);
}

The above function is used to reload bss config. After passing the
wpa data and bss config, the function creates an UC VM and push the
string data of wpa data and bss config(using an ucv_put function) to be




NEXT




<s> static int __init queue_gamma_map_setup(char *line)
{
char *p;
int i;

for ( i = 0, p = line; i < ARRAY_SIZE(queue_gamma_map) && isxdigit(*p); i++ )
{
queue_gamma_map[i] = simple_strtoul(p, &p, 0);
if ( *p == ',' || *p == ';' || *p == ':' )
p++;
}

return 0;
}

The above function is used to initialize queue_gamma_map using the data from
the cmdline. The data has already been parsed by parse_param() and stored
in the queuelang_param structure.

The following data structure defines a table that the above




NEXT




<s> static int b53_srab_read8(struct b53_device *dev, u8 page, u8 reg, u8 *val)
{
u8 __iomem *regs = dev->priv;
int ret = 0;

ret = b53_srab_request_grant(dev);
if (ret)
goto err;

ret = b53_srab_op(dev, page, reg, 0);
if (ret)
goto err;

*val = readl(regs + B53_SRAB_RD_L) & 0xff;

err:
b53_srab_release_grant(dev);

return ret;
}

The above function is used to read values.

You might say I could be a little less picky on this. Sure, I could have done, but its a nice example of how easy it is to make mistakes in code and how easy that can be to mask at




NEXT




<s> swconfig_reset_switch(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
/* don't complain if not supported by the switch driver */
if (!dev->ops->reset_switch)
return 0;

return dev->ops->reset_switch(dev);
}

The above function is used to reset the switch.

If the switch successfully resets, the return value is 1 and if unsuccessful the return value is 0.


switch_reset(struct switch_dev *dev, enum switch_property p)




NEXT




<s> ar8xxx_phy_init(struct ar8xxx_priv *priv)
{
int i;
struct mii_bus *bus;

bus = priv->sw_mii_bus ?: priv->mii_bus;
for (i = 0; i < AR8XXX_NUM_PHYS; i++) {
if (priv->chip->phy_fixup)
priv->chip->phy_fixup(priv, i);

/* initialize the port itself */
mdiobus_write(bus, i, MII_ADVERTISE,
ADVERTISE_ALL | ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
if (ar8xxx_has_gige(priv))
mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
}

ar8xxx_phy_poll_reset(bus);
}

The above function is used to reset the Ar8040(8072) phy and bring it into the
operational mode. The above function is called by the ar8xxx_startup()
which is called by ar71xx_start




NEXT




<s> ret_t rtl8367c_setAsicPortForceLink(rtk_uint32 port, rtl8367c_port_ability_t *pPortAbility)
{
rtk_uint32 regData = 0;

/* Invalid input parameter */
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

regData |= pPortAbility->forcemode << 12;
regData |= pPortAbility->mstfault << 9;
regData |= pPortAbility->mstmode << 8;
regData |= pPortAbility->nway << 7;
regData |= pPortAbility->txpause << 6;
regData |= pPortAbility->rxpause << 5;
regData |= pPortAbility->link << 4;
regData |= pPortAbility->duplex << 2;
regData |= pPortAbility->speed;

return rtl8367c_setAsicReg(RTL8367C_REG_MAC0_FORCE_SELECT+port, regData);
}

The above function is used to set the MAC port attributes, when RMII is not used. However, when the MAC ports are connected to RMII PHYs, this function cannot work. Because:

There is no 0x1D value in the




NEXT




<s> int cbc_des_encrypt(struct skcipher_request *req)
{
struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int enc_bytes, nbytes;

DPRINTF(1, "\n");
err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = enc_bytes = walk.nbytes)) {
u8 *iv = walk.iv;
enc_bytes -= (nbytes % DES_BLOCK_SIZE);
ifx_deu_des_cbc(ctx, walk.dst.virt.addr, walk.src.virt.addr,
iv, enc_bytes, CRYPTO_DIR_ENCRYPT, 0);
nbytes &= DES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

return err;
}

The above function is used to encrypt data that was written to a buffer that was set up for encryption at the start of the call to skcipher_walk_virt. Since we are using CBC mode, which requires initialization, the first data processed by the function will




NEXT




<s> ar8xxx_sw_get_mirror_monitor_port(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
val->value.i = priv->monitor_port;
return 0;
}

The above function is used to get the monitor port in the Ar8216. After
receiving a ping-from-firmware interrupt, the kernel calls ar8xxx_sw_get_monitor_port()
which eventually calls ar8xxx




NEXT




<s> static int qca807x_get_downshift(struct phy_device *phydev, u8 *data)
{
int val, cnt, enable;

val = phy_read(phydev, MII_NWAYTEST);
if (val < 0)
return val;

enable = FIELD_GET(QCA807X_SMARTSPEED_EN, val);
cnt = FIELD_GET(QCA807X_SMARTSPEED_RETRY_LIMIT_MASK, val) + 2;

*data = enable ? cnt : DOWNSHIFT_DEV_DISABLE;

return 0;
}

The above function is used to retrieve the smartspeed downshift values. The code works as expected but this function is not been called by any driver.

I am facing this problem that I could not find the caller of above function in the driver and how I can get an




NEXT




<s> void lowlevel_init(void)
{
}

The above function is used to initialize the low level hardware.

void lowlevel_init( void )
{
	printf( "\e[1;32m[DEBUG]\e[0m: Low level initialization (lowlevel_init) called\n




NEXT




<s> static void rtk_hal_get_phy_reg(unsigned int port ,unsigned int reg_addr )
{
ret_t retVal;
rtk_port_phy_data_t Data;

retVal = rtk_port_phyReg_get(port, reg_addr, &Data);
if (retVal == RT_ERR_OK)
printk("Get: phy[%d].reg[%d] = 0x%04x\n", port, reg_addr, Data);
else
printk("read phy reg failed\n");
}

The above function is used to display the value of the register by the shell ( / # rtk_hal_get_phy_reg 0, 0 ). However, using that shell command, you will always encounter Read Failed. Is there any way to get the




NEXT




<s> static irqreturn_t bcm6348_emac_isr_dma(int irq, void *dev_id)
{
struct net_device *ndev = dev_id;
struct bcm6348_emac *emac = netdev_priv(ndev);
struct bcm6348_iudma *iudma = emac->iudma;

/* mask rx/tx interrupts */
dmac_writel(iudma, 0, DMAC_IRMASK_REG, emac->rx_chan);
dmac_writel(iudma, 0, DMAC_IRMASK_REG, emac->tx_chan);

napi_schedule(&emac->napi);

return IRQ_HANDLED;
}

The above function is used to configure the interrupt status on the iudma. It will only work if IRQ_MODE=0.</s>




NEXT




<s> ret_t rtl8367c_setAsicMaxLength(rtk_uint32 port, rtk_uint32 type, rtk_uint32 cfgId)
{
ret_t retVal;

if(port < 8)
{
retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MAX_LENGTH_CFG, (type * 8) + port, cfgId);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MAX_LENGTH_CFG_EXT, (type * 3) + port - 8, cfgId);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to get or set the maximum frame size of a port.

It may receive the data from the link side in a bigger size (due to jumbo packet or some other reason)
If the switch receive it, the switch may check the




NEXT




<s> rtk_api_ret_t rtk_svlan_init(void)
{
rtk_uint32 i;
rtk_api_ret_t retVal;
rtl8367c_svlan_memconf_t svlanMemConf;
rtl8367c_svlan_s2c_t svlanSP2CConf;
rtl8367c_svlan_mc2s_t svlanMC2SConf;
rtk_uint32 svidx;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/*default use C-priority*/
if ((retVal = rtl8367c_setAsicSvlanPrioritySel(SPRISEL_CTAGPRI)) != RT_ERR_OK)
return retVal;

/*Drop SVLAN untag frame*/
if ((retVal = rtl8367c_setAsicSvlanIngressUntag(UNTAG_DROP)) != RT_ERR_OK)
return retVal;

/*Drop SVLAN unmatch frame*/
if ((retVal = rtl8367c_setAsicSvlanIngressUnmatch(UNMATCH_DROP)) != RT_ERR_OK)
return retVal;

/*Set TPID to 0x88a8*/
if ((retVal = rtl8367c_setAsicSvlanTpid(0x88a8)) != RT_ERR_OK)
return retVal;

/*Clean Uplink Port Mask to none*/
if ((retVal = rtl8367c_setAsicSvlanUplinkPortMask(0)) != RT_ERR_OK)
return retVal;

/*Clean SVLAN Member Configuration*/
for (i=0; i<= RTL8367C_SVIDXMAX; i++)
{
memset(&svlanMemConf, 0, sizeof(rtl8367c_svlan_memconf_t));
if ((retVal = rtl8367c_setAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;
}

/*Clean C2S Configuration*/
for (i=0; i<= RTL8367C_C2SIDXMAX; i++)
{
if ((retVal = rtl8367c_setAsicSvlanC2SConf(i, 0,0,0)) != RT_ERR_OK)
return retVal;
}

/*Clean SP2C Configuration*/
for (i=0; i <= RTL8367C_SP2CMAX ; i++)
{
memset(&svlanSP2CConf, 0, sizeof(rtl8367c_svlan_s2c_t));
if ((retVal = rtl8367c_setAsicSvlanSP2CConf(i, &svlanSP2CConf)) != RT_ERR_OK)
return retVal;
}

/*Clean MC2S Configuration*/
for (i=0 ; i<= RTL8367C_MC2SIDXMAX; i++)
{
memset(&svlanMC2SConf, 0, sizeof(rtl8367c_svlan_mc2s_t));
if ((retVal = rtl8367c_setAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;
}


if ((retVal = rtk_svlan_lookupType_set(SVLAN_LOOKUP_S64MBRCGF)) != RT_ERR_OK)
return retVal;


for (svidx = 0; svidx <= RTL8367C_SVIDXMAX; svidx++)
{
svlan_mbrCfgUsage[svidx] = FALSE;
}


return RT_ERR_OK;
}

The above function is used to initialize SVLAN feature. Before using SVLAN feature, it has to initialize it firstly. Before using SVLAN feature, all of the data on it has to be clean out. So, the function above clean all of the SVLAN structure data




NEXT




<s> int __rtl8366_mdio_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
{
u32 phy_id = MDC_REALTEK_PHY_ADDR;
struct mii_bus *mbus = smi->ext_mbus;

BUG_ON(in_interrupt());

mutex_lock(&mbus->mdio_lock);
/* Write Start command to register 29 */
mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);

/* Write address control code to register 31 */
mbus->write(mbus, phy_id, MDC_MDIO_CTRL0_REG, MDC_MDIO_ADDR_OP);

/* Write Start command to register 29 */
mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);

/* Write address to register 23 */
mbus->write(mbus, phy_id, MDC_MDIO_ADDRESS_REG, addr);

/* Write Start command to register 29 */
mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);

/* Write read control code to register 21 */
mbus->write(mbus, phy_id, MDC_MDIO_CTRL1_REG, MDC_MDIO_READ_OP);

/* Write Start command to register 29 */
mbus->write(smi->ext_mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);

/* Read data from register 25 */
*data = mbus->read(mbus, phy_id, MDC_MDIO_DATA_READ_REG);

mutex_unlock(&mbus->mdio_lock);

return 0;
}

The above function is used to read a MDIO register through the SPI MDIO register. In this case, the phy_id is equal to 0001. Therefore, only one device would be connected to the MDIO bus to avoid conflicts. A valid address




NEXT




<s> extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to send packets over the MII link without
causing any interrupts to the other OAM subsystem (OAMII).  This function
is used to support the GbE link (MII1 link).
*/






NEXT




<s> static int rtl83xx_port_fdb_dump(struct dsa_switch *ds, int port,
dsa_fdb_dump_cb_t *cb, void *data)
{
struct rtl838x_l2_entry e;
struct rtl838x_switch_priv *priv = ds->priv;

mutex_lock(&priv->reg_mutex);

for (int i = 0; i < priv->fib_entries; i++) {
priv->r->read_l2_entry_using_hash(i >> 2, i & 0x3, &e);

if (!e.valid)
continue;

if (e.port == port || e.port == RTL930X_PORT_IGNORE)
cb(e.mac, e.vid, e.is_static, data);

if (!((i + 1) % 64))
cond_resched();
}

for (int i = 0; i < 64; i++) {
priv->r->read_cam(i, &e);

if (!e.valid)
continue;

if (e.port == port)
cb(e.mac, e.vid, e.is_static, data);
}

mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to search
addresses in FIB table and CAM table and return all relevant information.</s>




NEXT




<s> static int getPhy(struct ip17xx_state *state, reg mii)
{
if (!REG_SUPP(mii))
return -EFAULT;
return ip_phy_read(state, mii.p, mii.m);
}

The above function is used to get the MII read data, and it is directly called by the I2C interface read operation of the PHY chip. The internal process of the function is not involved.

static int setPhy(struct ip17xx_




NEXT




<s> static int rtl8366rb_sw_set_mirror_rx_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

if (val->value.i)
data = RTL8366RB_PMCR_MIRROR_RX;
else
data = 0;

return rtl8366_smi_rmwr(smi, RTL8366RB_PMCR, RTL8366RB_PMCR_MIRROR_RX, data);
}

The above function is used to set mirror Rx enable bit in PMC Register(PMCR), however there is a question:

where are the mirror Rx enabled bits in PMCR set by the above function?

As far as I am concern, the mirror




NEXT




<s> void rtl838x_mask_port_reg(u64 clear, u64 set, int reg)
{
sw_w32_mask((u32)clear, (u32)set, reg);
}

The above function is used to set specific masks of the values
read from a register.

The following functions define the way the value to be masked
using a specific mask. They return a bit string that is used in
the mask_port_reg() function




NEXT




<s> static int sha1_hmac_init(struct shash_desc *desc)
{
struct sha1_hmac_ctx *sctx =  crypto_shash_ctx(desc->tfm);

//printk("debug ln: %d, fn: %s\n", __LINE__, __func__);
sctx->dbn = 0; //dbn workaround
sctx->started = 0;
sctx->count = 0;

return 0;
}

The above function is used to initialize the sha1_hmac in the crypto core in linux kernel.

But you find there is no return value in the implementation of this function, so it must be implemented at user level. A simple implementation is as below:





NEXT




<s> yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
{
YYFPRINTF (stderr, "Stack now");
for (; yybottom <= yytop; yybottom++)
{
int yybot = *yybottom;
YYFPRINTF (stderr, " %d", yybot);
}
YYFPRINTF (stderr, "\n");
}

The above function is used to print a stack which is passed to it as a range: it starts at *yybottom and ends at *yytop, plus one.

I have made no effort to verify that yy_stack_print works, I have just copied in




NEXT




<s> static int rtl838x_pie_rule_write(struct rtl838x_switch_priv *priv, int idx, struct pie_rule *pr)
{
/* Access IACL table (1) via register 0 */
struct table_reg *q = rtl_table_get(RTL8380_TBL_0, 1);
u32 r[18];
int err;
int block = idx / PIE_BLOCK_SIZE;
u32 t_select = sw_r32(RTL838X_ACL_BLK_TMPLTE_CTRL(block));

pr_debug("%s: %d, t_select: %08x\n", __func__, idx, t_select);

for (int i = 0; i < 18; i++)
r[i] = 0;

if (!pr->valid) {
err = -EINVAL;
pr_err("Rule invalid\n");
goto errout;
}

rtl838x_write_pie_fixed_fields(r, pr);

pr_debug("%s: template %d\n", __func__, (t_select >> (pr->tid * 3)) & 0x7);
rtl838x_write_pie_templated(r, pr, fixed_templates[(t_select >> (pr->tid * 3)) & 0x7]);

err = rtl838x_write_pie_action(r, pr);
if (err) {
pr_err("Rule actions too complex\n");
goto errout;
}

/*	rtl838x_pie_rule_dump_raw(r); */

for (int i = 0; i < 18; i++)
sw_w32(r[i], rtl_table_data(q, i));

errout:
rtl_table_write(q, idx);
rtl_table_release(q);

return err;
}

The above function is used to save rule to register. The basic function
called by the above function is:

static int rtl838x_write_pie_fixed_fields(u32 rules[], struct pie_rule *pr)
{





NEXT




<s> yy_next_state = yy_try_NUL_trans( yy_current_state );

yy_bp = (yytext_ptr) + YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ++(yy_c_buf_p);
yy_current_state = yy_next_state;
goto yy_match;
}

The above function is used to find the next state and next token when a NUL token is encountered while a single action or multiple YY_DO_ACCEPT() is issued. It is different to the other shift, reduce or default dispatcher functions in that it has only




NEXT




<s> struct property *sym_get_range_prop(struct symbol *sym)
{
struct property *prop;

for_all_properties(sym, prop, P_RANGE) {
prop->visible.tri = expr_calc_value(prop->visible.expr);
if (prop->visible.tri != no)
return prop;
}
return NULL;
}

The above function is used to check the expression specified in the range property for the given symbol.

Now, for a simple example, I want to give the range 3 to 6 for a given symbol, in a way that it doesn't allow expressions.





NEXT




<s> static inline int rtl839x_l2_port_new_salrn(int p)
{
return RTL839X_L2_PORT_NEW_SALRN(p);
}

The above function is used to get the SALRN number of port p.

static inline int rtl839x_l2_port_new_salrn_set(void *dev, int p, int s)
{
return R




NEXT




<s> static int rtl8366s_read_phy_reg(struct rtl8366_smi *smi,
u32 phy_no, u32 page, u32 addr, u32 *data)
{
u32 reg;
int ret;

if (phy_no > RTL8366S_PHY_NO_MAX)
return -EINVAL;

if (page > RTL8366S_PHY_PAGE_MAX)
return -EINVAL;

if (addr > RTL8366S_PHY_ADDR_MAX)
return -EINVAL;

ret = rtl8366_smi_write_reg(smi, RTL8366S_PHY_ACCESS_CTRL_REG,
RTL8366S_PHY_CTRL_READ);
if (ret)
return ret;

reg = 0x8000 | (1 << (phy_no + RTL8366S_PHY_NO_OFFSET)) |
((page << RTL8366S_PHY_PAGE_OFFSET) & RTL8366S_PHY_PAGE_MASK) |
(addr & RTL8366S_PHY_REG_MASK);

ret = rtl8366_smi_write_reg(smi, reg, 0);
if (ret)
return ret;

ret = rtl8366_smi_read_reg(smi, RTL8366S_PHY_ACCESS_DATA_REG, data);
if (ret)
return ret;

return 0;
}

The above function is used to read the RGMII register on the RGMII PHYs. First, we need to make sure about two things: (1) we need to be sure that the phy_no (the PHY number which should be between 




NEXT




<s> const char *conf_get_configname(void)
{
char *name = getenv("KCONFIG_CONFIG");

return name ? name : ".config";
}

The above function is used to obtain the name of the current configuration file from the kernel. Typically, this file is located in the /proc/config.gz file and is used to provide a means of determining the version of the kernel that is currently running on the system.




NEXT




<s> static void rtl9300_sda_sel(struct i2c_mux_core *muxc, int pin)
{
struct rtl9300_mux *mux = i2c_mux_priv(muxc);
u32 v;

/* Set SDA pin to I2C functionality */
v = readl(REG(0, RTL9300_I2C_MST_GLB_CTRL));
v |= BIT(pin);
writel(v, REG(0, RTL9300_I2C_MST_GLB_CTRL));
}

The above function is used to control whether SDA is used for GPIO or I2C functionality.
If the functionality of SDA pin is switched from GPIO, we will also change the function of SCL pin.

// TODO:

Change the function of S




NEXT




<s> int rtl8366_sw_get_vlan_info(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
int i;
u32 len = 0;
struct rtl8366_vlan_4k vlan4k;
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
char *buf = smi->buf;
int err;

if (!smi->ops->is_vlan_valid(smi, val->port_vlan))
return -EINVAL;

memset(buf, '\0', sizeof(smi->buf));

err = smi->ops->get_vlan_4k(smi, val->port_vlan, &vlan4k);
if (err)
return err;

len += snprintf(buf + len, sizeof(smi->buf) - len,
"VLAN %d: Ports: '", vlan4k.vid);

for (i = 0; i < smi->num_ports; i++) {
if (!(vlan4k.member & (1 << i)))
continue;

len += snprintf(buf + len, sizeof(smi->buf) - len, "%d%s", i,
(vlan4k.untag & (1 << i)) ? "" : "t");
}

len += snprintf(buf + len, sizeof(smi->buf) - len,
"', members=%04x, untag=%04x, fid=%u",
vlan4k.member, vlan4k.untag, vlan4k.fid);

val->value.s = buf;
val->len = len;

return 0;
}

The above function is used to translate the port VLAN information of the rtl8366 card to the switch.

Note that rtl8366_smi_get_vlan_4k() needs to fill the vlan4k structure




NEXT




<s> static bool nmbm_generate_info_table_cache(struct nmbm_instance *ni)
{
bool changed = false;

memset(ni->info_table_cache, 0xff, ni->info_table_size);

memcpy(ni->info_table_cache + ni->info_table.state_table_off,
ni->block_state, ni->state_table_size);

memcpy(ni->info_table_cache + ni->info_table.mapping_table_off,
ni->block_mapping, ni->mapping_table_size);

ni->info_table.header.magic = NMBM_MAGIC_INFO_TABLE;
ni->info_table.header.version = NMBM_VER;
ni->info_table.header.size = ni->info_table_size;

if (ni->block_state_changed || ni->block_mapping_changed) {
ni->info_table.write_count++;
changed = true;
}

memcpy(ni->info_table_cache, &ni->info_table, sizeof(ni->info_table));

nmbm_update_checksum((struct nmbm_header *)ni->info_table_cache);

return changed;
}

The above function is used to regenerate the info table for a partition. It is
called regularly in nmbm_read() and in the various info table write routines.
When run with the new checksum in-place, it will check the checksum and




NEXT




<s> u64 rtl839x_get_port_reg_le(int reg)
{
u64 v = sw_r32(reg + 4);

v <<= 32;
v |= sw_r32(reg);

return v;
}

The above function is used to grab various port values for testing.
Most times, I had problems with one particular line in the above…the line that says “v <<= 32.” For some reason, my compiler was complaining. I believe it was due to the




NEXT




<s> static int b53_spi_read(struct b53_device *dev, u8 page, u8 reg, u8 *data,
unsigned len)
{
struct spi_device *spi = dev->priv;
int ret;

ret = b53_prepare_reg_access(spi, page);
if (ret)
return ret;

ret = b53_spi_prepare_reg_read(spi, reg);
if (ret)
return ret;

return b53_spi_read_reg(spi, B53_SPI_DATA, data, len);
}

The above function is used to read from the SoC using SPI. Let’s take a look at the first line:

struct spi_device *spi = dev->priv;

The variable spi is used to store the instance of the spi_




NEXT




<s> static int rtl838x_mdio_write(struct mii_bus *bus, int mii_id,
int regnum, u16 value)
{
return rtl838x_mdio_write_paged(bus, mii_id, 0, regnum, value);
}

The above function is used to write data to any of the register on the PHY.

In this situation, I have to change the PHY mode from MII to 10BT and back to MII mode again at runtime.

When I tried to




NEXT




<s> static void aca_dma_ctrl_init(struct dc_ep_priv *priv)
{
u32 val;
struct dc_aca *aca = to_aca(priv);

/* Global software reset CDMA */
wr32_mask(0, BIT(CTRL_RST), ADMA_CTRL);
while ((rd32(ADMA_CTRL) & BIT(CTRL_RST)))
;

val = rd32(ADMA_ID);
/* Record max dma channels for later usage */
aca->adma_chans = MS(val, ADMA_ID_CHNR);
val = rd32(ADMA_CTRL);
/*
* Enable Packet Arbitration
* Enable Meta data copy
* Enable Dedicated Descriptor port
*/
val |= BIT(CTRL_PKTARB) | BIT(CTRL_MDC) | BIT(CTRL_DSRAM);
set_mask_bit(val, 1, 1, CTRL_ENBE); /* Enable byte enable */
set_mask_bit(val, 1, 1, CTRL_DCNF); /* 2DW descriptor format */
set_mask_bit(val, 1, 1, CTRL_DDBR); /* Descriptor read back */
set_mask_bit(val, 1, 1, CTRL_DRB); /* Dynamic burst read */
wr32(val, ADMA_CTRL);

/* Polling cnt cfg */
wr32(ADMA_CPOLL_EN | SM(ADMA_DEFAULT_POLL, ADMA_CPOLL_CNT),
ADMA_CPOLL);
}

The above function is used to initialize the core when the ACAP is powered up
and then when the ACAP is activated. To begin with, the core needs to be
de-initialized. This is done by disabling the global clock to the core and
asserting




NEXT




<s> int AT91F_MCI_SDCard_SetBusWidth(AT91PS_MciDevice pMCI_Device)
{
volatile int	ret_value;
char			bus_width;

do
{
ret_value =AT91F_MCI_GetStatus(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address);
}
while((ret_value > 0) && ((ret_value & AT91C_SR_READY_FOR_DATA) == 0));

// Select Card
AT91F_MCI_SendCommand(pMCI_Device,
AT91C_SEL_DESEL_CARD_CMD,
(pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address)<<16);

// Set bus width for Sdcard
if(pMCI_Device->pMCI_DeviceDesc->SDCard_bus_width == AT91C_MCI_SCDBUS)
bus_width = AT91C_BUS_WIDTH_4BITS;
else	bus_width = AT91C_BUS_WIDTH_1BIT;

if (AT91F_MCI_SDCard_SendAppCommand(pMCI_Device,AT91C_SDCARD_SET_BUS_WIDTH_CMD,bus_width) != AT91C_CMD_SEND_OK)
return AT91C_CMD_SEND_ERROR;

return AT91C_CMD_SEND_OK;
}

The above function is used to set the bus width between 1 and 4 bits through the SD card command ‘SET_BUS_WIDTH’. This allows the card to be correctly detected.

This is an alternative way of setting the bus width for the SDCARD,




NEXT




<s> handle_done_auth(void)
{
struct ead_msg_auth *auth = EAD_DATA(msg, auth);
if (t_clientverify(tc, auth->data) != 0) {
fprintf(stderr, "Client auth verify failed\n");
return false;
}
return true;
}

The above function is used to check any form of authentication that the client
(sshd) performs, the function can be used for password, pk or host based
authentication.

## Answer: 121

2010
by




NEXT




<s> static const struct firmware *aca_fetch_fw_file(struct dc_ep_priv *priv,
char *dir, const char *file)
{
int ret;
char filename[100] = {0};
const struct firmware *fw;

if (file == NULL)
return ERR_PTR(-ENOENT);

if (dir == NULL)
dir = ".";

snprintf(filename, sizeof(filename), "%s/%s", dir, file);
ret = request_firmware(&fw, filename, priv->dev);
if (ret)
return ERR_PTR(ret);

return fw;
}

The above function is used to fetch firmware image from a specified source.
In case of Acer Aspire one this source could be different. The image
can be stored in a flash memory device or in a file located inside the
system RAM. This function first




NEXT




<s> static int mt7621_nfc_read_oob_raw(struct nand_chip *nand, int page)
{
return mt7621_nfc_read_page_raw(nand, NULL, 1, page);
}

The above function is used to retrieve raw OOB data.

In this implementation, we use mt7621_nfc_read_page_raw to obtain raw OOB data.

If the nand chip has a cache, mt762




NEXT




<s> void zconf_nextfile(const char *name)
{
glob_t gl;
int err;
int i;
char path[PATH_MAX], *p;

err = glob(name, GLOB_ERR | GLOB_MARK, NULL, &gl);

/* ignore wildcard patterns that return no result */
if (err == GLOB_NOMATCH && strchr(name, '*')) {
err = 0;
gl.gl_pathc = 0;
}

if (err == GLOB_NOMATCH) {
p = strdup(current_file->name);
if (p) {
snprintf(path, sizeof(path), "%s/%s", dirname(p), name);
err = glob(path, GLOB_ERR | GLOB_MARK, NULL, &gl);
free(p);
}
}

if (err) {
const char *reason = "unknown error";

switch (err) {
case GLOB_NOSPACE:
reason = "out of memory";
break;
case GLOB_ABORTED:
reason = "read error";
break;
case GLOB_NOMATCH:
reason = "No files found";
break;
default:
break;
}

printf("%s:%d: glob failed: %s \"%s\"\n", zconf_curname(), zconf_lineno(),
reason, name);

exit(1);
}

for (i = 0; i < gl.gl_pathc; i++)
__zconf_nextfile(gl.gl_pathv[i]);
}

The above function is used to traverse the files inside a directory to
parse in the zconf_nextfile function, the function is called zconf_nextfile
and the function call chain is as follows: zconf_nextfile -> glob_t ->
__




NEXT




<s> int rtl8366_debugfs_open(struct inode *inode, struct file *file)
{
file->private_data = inode->i_private;
return 0;
}

The above function is used to open the debugfs file. The function sets the private_data field of the file structure to the i_private field of the inode structure (containing information about the file and its associated directory). This is necessary for later code to access the opened




NEXT




<s> ret_t rtl8367c_getAsicAprEnable(rtk_uint32 port, rtk_uint32 *aprEnable)
{
ret_t retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

retVal = rtl8367c_getAsicRegBit(RTL8367C_SCHEDULE_APR_CTRL_REG, RTL8367C_SCHEDULE_APR_CTRL_OFFSET(port), aprEnable);

return retVal;
}

The above function is used to retrieve the value of the Port APR Enable field from the RTL8367C_SCHEDULE_APR_CTRL_REG
register.  Please refer to Table 4-31 of ASIC Register List for more




NEXT




<s> ret_t rtl8367c_getAsicAclActCtrl(rtk_uint32 index, rtk_uint32 *pAclActCtrl)
{
ret_t retVal;
rtk_uint32 regData;

if(index > RTL8367C_ACLRULEMAX)
return RT_ERR_OUT_OF_RANGE;

if(index >= 64)
retVal = rtl8367c_getAsicRegBits(RTL8367C_ACL_ACTION_CTRL2_REG(index), RTL8367C_ACL_OP_ACTION_MASK(index), &regData);
else
retVal = rtl8367c_getAsicRegBits(RTL8367C_ACL_ACTION_CTRL_REG(index), RTL8367C_ACL_OP_ACTION_MASK(index), &regData);

if(retVal != RT_ERR_OK)
return retVal;

*pAclActCtrl = regData;

return RT_ERR_OK;
}

The above function is used to get the Acl Act control for a specified rule index.</s>




NEXT




<s> static ssize_t hc_tag_show_hwoptions(const u8 *pld, u16 pld_len, char *buf)
{
char *out = buf;
u32 data;	// cpu-endian
int i;

if (sizeof(data) != pld_len)
return -EINVAL;

data = *(u32 *)pld;
out += sprintf(out, "raw\t\t: 0x%08x\n\n", data);

for (i = 0; i < ARRAY_SIZE(hc_hwopts); i++)
out += sprintf(out, "%s: %s\n", hc_hwopts[i].str,
(data & hc_hwopts[i].bit) ? "true" : "false");

return out - buf;
}

The above function is used to retrieve the raw configuration data, which stores the actual bit-field of the register. It does not have to be a u32 but I thought it would be easier to work with.

Here's the definition of the hc_




NEXT




<s> static bool nmbm_erase_phys_block(struct nmbm_instance *ni, uint64_t addr)
{
int tries, ret;

for (tries = 0; tries < NMBM_TRY_COUNT; tries++) {
struct erase_info ei = {
.addr = addr,
.len = bmtd.mtd->erasesize,
};

ret = bmtd._erase(bmtd.mtd, &ei);
if (!ret)
return true;
}

nlog_err(ni, "Block erasure failed at address 0x%08llx\n", addr);

return false;
}

The above function is used to erasing each physical block on the block device.

The following function is used to remove one or more of the existing log blocks
struct nmbm_log *nmbm_remove_log_blocks;

static void n




NEXT




<s> static inline int my_ether_ntoa(unsigned char *ea, char *buf)
{
return sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x",
ea[0], ea[1], ea[2], ea[3], ea[4], ea[5]);
}

The above function is used to print the MAC address.

But if I add the following code in it: if (buf)

and make call my_ether_ntoa(ether_addr(skb->dev)->addr, buf);

in my_




NEXT




<s> rtk_api_ret_t rtk_igmp_robustness_get(rtk_uint32 *pRobustness)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pRobustness)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPRobVar(pRobustness))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the IGMP max robustness value.


rtk_api_ret_t rtk_igmp_robustness_set(rtk_uint32 robustness)
{
rtk_api_




NEXT




<s> static int rtcl_839x_set_rate(int clk_idx, const struct rtcl_reg_set *reg)
{
unsigned long vpflags;
unsigned long irqflags;
/*
* Runtime of this function (including locking)
* CPU: up to 31000 cycles / up to 89 us at 350 MHz (half default speed)
*/
spin_lock_irqsave(&rtcl_ccu->lock, irqflags);
vpflags = dvpe();
rtcl_839x_sram_set_rate(clk_idx, reg->ctrl0, reg->ctrl1);
evpe(vpflags);
spin_unlock_irqrestore(&rtcl_ccu->lock, irqflags);

return 0;
}

The above function is used to set the runtime clock rate, which is then
fed straight into the sram. This method of using the sram is very slow,
taking up to two seconds with a half default 180MHz CLK_DV




NEXT




<s> ret_t rtl8367c_getAsicWFQBurstSize(rtk_uint32 *burstsize)
{
ret_t retVal;

retVal = rtl8367c_getAsicReg(RTL8367C_SCHEDULE_WFQ_BURST_SIZE_REG, burstsize);

return retVal;
}

The above function is used to set up WFQ burst size. The default size set on the device is 32. Setting is done by writing the value in a register.

The WFQ (Weighted Fair Queuing) module allows a router to prior




NEXT




<s> static int read_sectoroob(off_t pos)
{
struct mtd_oob_buf oob = {
.start = pos,
.length = TFFS_SECTOR_OOB_SIZE,
.ptr = oobbuf
};

if (ioctl(mtdfd, MEMREADOOB, &oob) < 0)	{
return -1;
}

return 0;
}

The above function is used to read the obituary buffer from the flash chip. The function is pretty simple
and is part of the Tffs driver, it is not used by any other driver and it is not called except for one driver
in the kernel, the




NEXT




<s> mvswitch_fixup(struct phy_device *dev)
{
struct mii_bus *bus = dev->mdio.bus;
u16 reg;

if (dev->mdio.addr != 0x10)
return 0;

reg = bus->read(bus, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;
if (reg != MV_IDENT_VALUE)
return 0;

dev->phy_id = MVSWITCH_MAGIC;
return 0;
}

The above function is used to check and to correct bad vendor ids.

While this works well in Linux kernel, it is a shame for me that this function does not work in other platforms. So I decided to try to add the patch that I have into Linux to Free




NEXT




<s> void rtl838x_vlan_port_pvid_set(int port, enum pbvlan_type type, int pvid)
{
if (type == PBVLAN_TYPE_INNER)
sw_w32_mask(0xfff << 2, pvid << 2, RTL838X_VLAN_PORT_PB_VLAN + (port << 2));
else
sw_w32_mask(0xfff << 16, pvid << 16, RTL838X_VLAN_PORT_PB_VLAN + (port << 2));
}

The above function is used to set pvid for the specified port.

However, when using GPL_HACK, this function is redeclared as:
extern __attribute__((naked )) __asm__(
“
mov r4, r0




NEXT




<s> static void rtl838x_packet_cntr_clear(int counter)
{
/* Access LOG table (3) via register RTL8380_TBL_0 */
struct table_reg *r = rtl_table_get(RTL8380_TBL_0, 3);

pr_debug("In %s, id %d\n", __func__, counter);
/* The table has a size of 2 registers */
if (counter % 2)
sw_w32(0, rtl_table_data(r, 0));
else
sw_w32(0, rtl_table_data(r, 1));

rtl_table_write(r, counter / 2);

rtl_table_release(r);
}

The above function is used to clear the packet count at the end of the packet transmission. One of the
parameters needed for this code sequence to work, is the number of registers which has to be cleared.
This value might be different depending on the hardware revision, and is




NEXT




<s> ret_t rtl8367c_setAsicEavEnable(rtk_uint32 port, rtk_uint32 enabled)
{
if(port > RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_REG_EAV_CTRL0, port, enabled);
}

The above function is used to control the EAV enable / disable.

rtk_uint32 rtl8367c_getAsicEavEnable(rtk_uint32 port)
{
rtk_uint32 enable;




NEXT




<s> rtk_api_ret_t rtk_oam_init(void)
{
return RT_ERR_OK;
} /* end of rtk_oam_init */

The above function is used to initialize the OAM.

rtk_api_ret_t rtk_oam_loopback_set(rtk_port_t port, rtk_oam_loopback_type_t loopback_type




NEXT




<s> void ifxdeu_fini_md5_hmac (void)
{
crypto_unregister_shash(&ifxdeu_md5_hmac_alg);
}

The above function is used to unload an installed MDF5 HMAC driver from the MDF5 hashing library.

An MDF5 HMAC driver is to generate a secure hash that consists of a secure HASH of key material and data. This algorithm is




NEXT




<s> ar8327_led_enable_hw_mode_show(struct device *dev,
struct device_attribute *attr,
char *buf)
{
struct led_classdev *led_cdev = dev_get_drvdata(dev);
struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
ssize_t ret = 0;

ret += scnprintf(buf, PAGE_SIZE, "%d\n", aled->enable_hw_mode);

return ret;
}

The above function is used to show the current value of “enable_hw_mode” variable in the /sys/class/leds/kali-backlight/enable_hw_mode file.

ar8327_led_enable_hw_




NEXT




<s> static inline int rbytes(void)
{
return erasesize - (ofs % erasesize);
}

The above function is used to compute the number of bytes to be cleared (erased) per operation, while the following is used to compute the number of bits:

static inline int rbits(void)
{
return rbytes() / 8;
}




NEXT




<s> void put_ptr(const void *p)
{
put_u32((uint32_t)p);
}

The above function is used to pass a pointer to a device driver (or to any other user-mode software which can use it as necessary). How is the address interpreted by the device driver and by the user-mode software?

The only way that I can think of




NEXT




<s> BigIntegerAdd(B, B, v);
if(BigIntegerCmp(B, n) > 0)
BigIntegerSub(B, B, n);

ts->B.len = BigIntegerToBytes(B, ts->B.data);

BigIntegerFree(v);
BigIntegerFree(B);
BigIntegerFree(b);
BigIntegerFree(g);
BigIntegerFree(n);

SHA1Update(&ts->oldckhash, ts->B.data, ts->B.len);

return &ts->B;
}

_TYPE( unsigned char * )
t_servergetkey(ts, clientval)
struct t_server * ts;
struct t_num * clientval;
{

The above function is used to generate a shared secret shared key. The key length is 16 bytes.

The above functions are used to generate a secret session key for the session being negotiated.

The above function is used to generate a secret session key for




NEXT




<s> static int ag71xx_change_mtu(struct net_device *dev, int new_mtu)
{
struct ag71xx *ag = netdev_priv(dev);

dev->mtu = new_mtu;
ag71xx_wr(ag, AG71XX_REG_MAC_MFL,
ag71xx_max_frame_len(dev->mtu));

return 0;
}

The above function is used to set or change the maximum frame length (MFL) value.
This article will discuss the details of how to calculate the MFL value.

1) When the frame size is less than or equal to the RL value, then R




NEXT




<s> static void rtl838x_write_cam(int idx, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL8380_TBL_L2, 1); /* Access L2 Table 1 */

rtl838x_fill_l2_row(r, e);

for (int i = 0; i < 3; i++)
sw_w32(r[i], rtl_table_data(q, i));

rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to write an L2 entry to the hardware, with idx being an index into the L2 table. The first time I saw this function, my immediate thought was: “that’s nice, but why does it look so familiar?”

After




NEXT




<s> nct5104d_gpio_device_add(const struct nct5104d_sio *sio)
{
int err;

nct5104d_gpio_pdev = platform_device_alloc(DRVNAME, -1);
if (!nct5104d_gpio_pdev)
pr_err(DRVNAME ": Error platform_device_alloc\n");
if (!nct5104d_gpio_pdev)
return -ENOMEM;

err = platform_device_add_data(nct5104d_gpio_pdev,
sio, sizeof(*sio));
if (err) {
pr_err(DRVNAME "Platform data allocation failed\n");
goto err;
}

err = platform_device_add(nct5104d_gpio_pdev);
if (err) {
pr_err(DRVNAME "Device addition failed\n");
goto err;
}
pr_info(DRVNAME ": Device added\n");
return 0;

err:
platform_device_put(nct5104d_gpio_pdev);

return err;
}

The above function is used to add the GPIO device into the kernel.
The kernel then detects it and registers it under
/sys/devices/platform/nct5104d
folder. The gpio_export function in the
nct51




NEXT




<s> void menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep)
{
menu_add_prop(type, expr, dep);
}

The above function is used to add dependencies like those in the above example and it uses the same add function as the regular property.  In this case the "enum prop_type" is set to the type of dependency.  The above has already declared "EXPR_TYPE




NEXT




<s> static int rtl930x_find_l3_slot(struct rtl83xx_route *rt, bool must_exist)
{
int slot_width, algorithm, addr, idx;
u32 hash;
struct rtl83xx_route route_entry;

/* IPv6 entries take up 3 slots */
slot_width = (rt->attr.type == 0) || (rt->attr.type == 2) ? 1 : 3;

for (int t = 0; t < 2; t++) {
algorithm = (sw_r32(RTL930X_L3_HOST_TBL_CTRL) >> (2 + t)) & 0x1;
hash = rtl930x_l3_hash4(rt->dst_ip, algorithm, false);

pr_debug("%s: table %d, algorithm %d, hash %04x\n", __func__, t, algorithm, hash);

for (int s = 0; s < 6; s += slot_width) {
addr = (t << 12) | ((hash & 0x1ff) << 3) | s;
pr_debug("%s physical address %d\n", __func__, addr);
idx = ((addr / 8) * 6) + (addr % 8);
pr_debug("%s logical address %d\n", __func__, idx);

rtl930x_host_route_read(idx, &route_entry);
pr_debug("%s route valid %d, route dest: %pI4, hit %d\n", __func__,
rt->attr.valid, &rt->dst_ip, rt->attr.hit);
if (!must_exist && rt->attr.valid)
return idx;
if (must_exist && route_entry.dst_ip == rt->dst_ip)
return idx;
}
}

return -1;
}

The above function is used to find the physical slot (rtl83xx_route is a pointer of rtl83xx_route_t) in L3 table.

```
        void rtl83xx_l3_table_clear




NEXT




<s> static void ar934x_nfc_read_status(struct ar934x_nfc *nfc)
{
u32 cmd_reg;
u32 status;

cmd_reg = NAND_CMD_STATUS << AR934X_NFC_CMD_CMD0_S;
cmd_reg |= AR934X_NFC_CMD_SEQ_S;

ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);

ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
ar934x_nfc_wait_dev_ready(nfc);

status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_READ_STATUS);

nfc_dbg(nfc, "read status, cmd:%08x status:%02x\n",
cmd_reg, (status & 0xff));

if (nfc->swap_dma)
nfc->buf[0 ^ 3] = status;
else
nfc->buf[0] = status;
}

The above function is used to read status registers on NFC.

Status register is actually a register bank which has multiple status,
so the function has to read status from multiple registers.

Ideally, it should read from only 3 registers after reading page




NEXT




<s> static void aw9523_gpio_set_multiple(struct gpio_chip *chip,
unsigned long *mask,
unsigned long *bits)
{
struct aw9523 *awi = gpiochip_get_data(chip);
u8 mask_lo, mask_hi, bits_lo, bits_hi;
unsigned int reg;
int ret = 0;

mask_lo = *mask & U8_MAX;
mask_hi = (*mask >> 8) & U8_MAX;
mutex_lock(&awi->i2c_lock);
if (mask_hi) {
reg = AW9523_REG_OUT_STATE(AW9523_PINS_PER_PORT);
bits_hi = (*bits >> 8) & U8_MAX;

ret = regmap_write_bits(awi->regmap, reg, mask_hi, bits_hi);
if (ret) {
dev_warn(awi->dev, "Cannot write port1 out level\n");
goto out;
}
}
if (mask_lo) {
reg = AW9523_REG_OUT_STATE(0);
bits_lo = *bits & U8_MAX;
ret = regmap_write_bits(awi->regmap, reg, mask_lo, bits_lo);
if (ret)
dev_warn(awi->dev, "Cannot write port0 out level\n");
}
out:
mutex_unlock(&awi->i2c_lock);
}

The above function is used to set multiple levels of a GPIO chip connected to
aw9523, but it fails to correctly set the levels when I call the above function
with two ports, e.g. for port0, mask = 0x1 and




NEXT




<s> rtk_api_ret_t rtk_dot1x_guestVlan_set(rtk_vlan_t vid)
{
rtk_api_ret_t retVal;
rtk_uint32 index;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* vid must be 0~4095 */
if (vid > RTL8367C_VIDMAX)
return RT_ERR_VLAN_VID;

if((retVal = rtk_vlan_checkAndCreateMbr(vid, &index)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsic1xGuestVidx(index)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the Vid value as the dot1x guest Vid.

The following function could only be called after the dot1x guest Vid is
already set.
And the input vid will not be checked.

rt




NEXT




<s> srg_led_i2c_write(struct srg_led_ctrl *sysled_ctrl, u8 reg, u8 value)
{
return i2c_smbus_write_byte_data(sysled_ctrl->client, reg, value);
}

The above function is used to write a specific value to a specific I2C address. Since it is a common need, i2c-core contains a generic framework for reading and writing byte, word and byte-array data from I2C registers. The relevant functions are




NEXT




<s> static int ip175c_update_state(struct ip17xx_state *state);
static int ip175c_set_vlan_mode(struct ip17xx_state *state);
static int ip175c_reset(struct ip17xx_state *state);

static const struct register_mappings IP178C = {
.NAME = "IP178C",
.MODEL_NO = 0x18,
.VLAN_DEFAULT_TAG_REG = {
{30,3},{30,4},{30,5},{30,6},{30,7},{30,8},
{30,9},{30,10},{30,11},
},

.ADD_TAG_REG = {30,12},
.ADD_TAG_BIT = {0,1,2,3,4,5,6,7,8},
.REMOVE_TAG_REG = {30,13},
.REMOVE_TAG_BIT = {4,5,6,7,8,9,10,11,12},

.SIMPLE_VLAN_REGISTERS = 1,

.VLAN_LOOKUP_REG = {31,0},// +N
.VLAN_LOOKUP_REG_5 = NOTSUPPORTED, // not used with SIMPLE_VLAN_REGISTERS
.VLAN_LOOKUP_EVEN_BIT = {0,1,2,3,4,5,6,7,8},
.VLAN_LOOKUP_ODD_BIT = {0,1,2,3,4,5,6,7,8},

.TAG_VLAN_MASK_REG = {30,14}, // +N
.TAG_VLAN_MASK_EVEN_BIT = {0,1,2,3,4,5,6,7,8},
.TAG_VLAN_MASK_ODD_BIT = {0,1,2,3,4,5,6,7,8},

.RESET_VAL = 0x55AA,
.RESET_REG = {30,0},
.MODE_VAL = 0,
.MODE_REG = NOTSUPPORTED,

.ROUTER_CONTROL_REG = {30,30},
.ROUTER_EN_BIT = 11,
.NUMLAN_GROUPS_MAX = 8,
.NUMLAN_GROUPS_BIT = 8, // {0-2}

.VLAN_CONTROL_REG = {30,13},
.TAG_VLAN_BIT = 3,

.CPU_PORT = 8,
.NUM_PORTS = 9,

.MII_REGISTER_EN = NOTSUPPORTED,

.update_state = ip175c_update_state,
.set_vlan_mode = ip175c_set_vlan_mode,
.reset = ip175c_reset,
};

The above function is used to configure Layer 2 VLAN Tags and Layer 3 IP Addresses for all ports except for Port 1 and 9 (CPU) for this example.

The following is a short summary of the functions, refer to the




NEXT




<s> ret_t rtl8367c_setAsicMaxLengthCfg(rtk_uint32 cfgId, rtk_uint32 maxLength)
{
return rtl8367c_setAsicRegBits(RTL8367C_REG_MAX_LEN_RX_TX_CFG0 + cfgId, RTL8367C_MAX_LEN_RX_TX_CFG0_MASK, maxLength);
}

The above function is used to set the value of RTL8367C_REG_MAX_LEN_RX_TX_CFG0_MAX_TX_LEN
This value is the default length of a user-provided packet frame for the RJ4




NEXT




<s> void ifx_deu_des_decrypt (struct crypto_tfm *tfm, uint8_t * out, const uint8_t * in)
{
struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(tfm);
ifx_deu_des (ctx, out, in, NULL, DES_BLOCK_SIZE,
CRYPTO_DIR_DECRYPT, 0);
}

The above function is used to decrypt data using DES
algorithm. In this exercise, the function below contains
the cryptographic implementation using DES and is being used
by the previous function.

void ifx_deu_des (struct ifx_deu




NEXT




<s> static void platform_detect(void)
{
char buf[20];
int et0phyaddr, et1phyaddr;

/* Based on "model_no".  */
if (bcm47xx_nvram_getenv("model_no", buf, sizeof(buf)) >= 0) {
if (startswith(buf, "WL700")) { /* WL700* */
sda_index = 2;
scl_index = 5;
return;
}
}

if (bcm47xx_nvram_getenv("et0phyaddr", buf, sizeof(buf)) >= 0 )
et0phyaddr = simple_strtoul(buf, NULL, 0);
if (bcm47xx_nvram_getenv("et1phyaddr", buf, sizeof(buf)) >= 0 )
et1phyaddr = simple_strtoul(buf, NULL, 0);

if (bcm47xx_nvram_getenv("hardware_version", buf, sizeof(buf)) >= 0) {
/* Either WL-300g or WL-HDD, do more extensive checks */
if (startswith(buf, "WL300-") && et0phyaddr == 0 && et1phyaddr == 1) {
sda_index = 4;
scl_index = 5;
return;
}
}
/* not found */
}

The above function is used to detect which port the I2C is on. Here we are
checking model_no and then we are also reading values from nvram
hardware_version and et0phyaddr and et1phyaddr. These values are determined by




NEXT




<s> static void rtl838x_validate(struct phylink_config *config,
unsigned long *supported,
struct phylink_link_state *state)
{
__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };

pr_debug("In %s\n", __func__);

if (!phy_interface_mode_is_rgmii(state->interface) &&
state->interface != PHY_INTERFACE_MODE_1000BASEX &&
state->interface != PHY_INTERFACE_MODE_MII &&
state->interface != PHY_INTERFACE_MODE_REVMII &&
state->interface != PHY_INTERFACE_MODE_GMII &&
state->interface != PHY_INTERFACE_MODE_QSGMII &&
state->interface != PHY_INTERFACE_MODE_INTERNAL &&
state->interface != PHY_INTERFACE_MODE_SGMII) {
bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
pr_err("Unsupported interface: %d\n", state->interface);
return;
}

/* Allow all the expected bits */
phylink_set(mask, Autoneg);
phylink_set_port_modes(mask);
phylink_set(mask, Pause);
phylink_set(mask, Asym_Pause);

/* With the exclusion of MII and Reverse MII, we support Gigabit,
* including Half duplex
*/
if (state->interface != PHY_INTERFACE_MODE_MII &&
state->interface != PHY_INTERFACE_MODE_REVMII) {
phylink_set(mask, 1000baseT_Full);
phylink_set(mask, 1000baseT_Half);
}

phylink_set(mask, 10baseT_Half);
phylink_set(mask, 10baseT_Full);
phylink_set(mask, 100baseT_Half);
phylink_set(mask, 100baseT_Full);

bitmap_and(supported, supported, mask,
__ETHTOOL_LINK_MODE_MASK_NBITS);
bitmap_and(state->advertising, state->advertising, mask,
__ETHTOOL_LINK_MODE_MASK_NBITS);
}

The above function is used to validate MII and RGMII configs. RTL838X supports Autoneg.</s>




NEXT




<s> static int ag71xx_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
struct ag71xx *ag = netdev_priv(dev);


switch (cmd) {
case SIOCSIFHWADDR:
if (copy_from_user
((void*)dev->dev_addr, ifr->ifr_data, sizeof(dev->dev_addr)))
return -EFAULT;
return 0;

case SIOCGIFHWADDR:
if (copy_to_user
(ifr->ifr_data, dev->dev_addr, sizeof(dev->dev_addr)))
return -EFAULT;
return 0;

case SIOCGMIIPHY:
case SIOCGMIIREG:
case SIOCSMIIREG:
if (ag->phy_dev == NULL)
break;

return phy_mii_ioctl(ag->phy_dev, ifr, cmd);

default:
break;
}

return -EOPNOTSUPP;
}

The above function is used to handle ioctl requests to the device driver from the processes running in the user-space.</s>




NEXT




<s> static LIST_HEAD(rtl83xx_block_cb_list);

int rtl83xx_setup_tc(struct net_device *dev, enum tc_setup_type type, void *type_data)
{
struct rtl838x_switch_priv *priv;
struct flow_block_offload *f = type_data;
static bool first_time = true;
int err;

pr_debug("%s: %d\n", __func__, type);

if(!netdev_uses_dsa(dev)) {
pr_err("%s: no DSA\n", __func__);
return 0;
}
priv = dev->dsa_ptr->ds->priv;

switch (type) {
case TC_SETUP_BLOCK:
if (first_time) {
first_time = false;
err = rhashtable_init(&priv->tc_ht, &tc_ht_params);
if (err)
pr_err("%s: Could not initialize hash table\n", __func__);
}

f->unlocked_driver_cb = true;
return flow_block_cb_setup_simple(type_data,
&rtl83xx_block_cb_list,
rtl83xx_setup_tc_block_cb,
priv, priv, true);
default:
return -EOPNOTSUPP;
}

return 0;
}

The above function is used to setup TC, which is a new Linux network
framework introduced in kernel 2.6.24. It should be invoked by
rtl83xx_setup_switches before doing any registration with netlink.

The




NEXT




<s> static void rtl839x_stp_set(struct rtl838x_switch_priv *priv, u16 msti, u32 port_state[])
{
u32 cmd = 1 << 16 | /* Execute cmd */
1 << 15 | /* Write */
5 << 12 | /* Table type 0b101 */
(msti & 0xfff);
for (int i = 0; i < 4; i++)
sw_w32(port_state[i], priv->r->tbl_access_data_0(i));
priv->r->exec_tbl0_cmd(cmd);
}

The above function is used to write data
into rtl838x switch table
static void rtl839x_stp_set(struct rtl838x_switch_priv *priv, u16 msti, u3




NEXT




<s> static int rtl8226_config_aneg(struct phy_device *phydev)
{
int ret = 0;
u32 v;

pr_debug("In %s\n", __func__);
if (phydev->autoneg == AUTONEG_ENABLE) {
ret = rtl8226_advertise_aneg(phydev);
if (ret)
goto out;
/* AutoNegotiationEnable */
v = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1);
if (v < 0)
goto out;

v |= MDIO_AN_CTRL1_ENABLE; /* Enable AN */
ret = phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1, v);
if (ret < 0)
goto out;

/* RestartAutoNegotiation */
v = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xA400);
if (v < 0)
goto out;
v |= MDIO_AN_CTRL1_RESTART;

ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, 0xA400, v);
}

/*	TODO: ret = __genphy_config_aneg(phydev, ret); */

out:
return ret;
}

The above function is used to perform Autoneg. It will perform the following flow:
1.Enable Autoneg
2.Start the AN process.
3.Wait until the AN process complete.

We notice that in line 3, the rtl




NEXT




<s> static int rtl931x_mdio_reset(struct mii_bus *bus)
{
struct rtl838x_eth_priv *priv = bus->priv;
u32 c45_mask = 0;
u32 poll_sel[4];
u32 poll_ctrl = 0;
bool mdc_on[4];

pr_info("%s called\n", __func__);
/* Disable port polling for configuration purposes */
sw_w32(0, RTL931X_SMI_PORT_POLLING_CTRL);
sw_w32(0, RTL931X_SMI_PORT_POLLING_CTRL + 4);
msleep(100);

mdc_on[0] = mdc_on[1] = mdc_on[2] = mdc_on[3] = false;
/* Mapping of port to phy-addresses on an SMI bus */
poll_sel[0] = poll_sel[1] = poll_sel[2] = poll_sel[3] = 0;
for (int i = 0; i < 56; i++) {
u32 pos;

pos = (i % 6) * 5;
sw_w32_mask(0x1f << pos, priv->smi_addr[i] << pos, RTL931X_SMI_PORT_ADDR + (i / 6) * 4);
pos = (i * 2) % 32;
poll_sel[i / 16] |= priv->smi_bus[i] << pos;
poll_ctrl |= BIT(20 + priv->smi_bus[i]);
mdc_on[priv->smi_bus[i]] = true;
}

/* Configure which SMI bus is behind which port number */
for (int i = 0; i < 4; i++) {
pr_info("poll sel %d, %08x\n", i, poll_sel[i]);
sw_w32(poll_sel[i], RTL931X_SMI_PORT_POLLING_SEL + (i * 4));
}

/* Configure which SMI busses */
pr_info("%s: WAS RTL931X_MAC_L2_GLOBAL_CTRL2 %08x\n", __func__, sw_r32(RTL931X_MAC_L2_GLOBAL_CTRL2));
pr_info("c45_mask: %08x, RTL931X_SMI_GLB_CTRL0 was %X", c45_mask, sw_r32(RTL931X_SMI_GLB_CTRL0));
for (int i = 0; i < 4; i++) {
/* bus is polled in c45 */
if (priv->smi_bus_isc45[i])
c45_mask |= 0x2 << (i * 2);  /* Std. C45, non-standard is 0x3 */
/* Enable bus access via MDC */
if (mdc_on[i])
sw_w32_mask(0, BIT(9 + i), RTL931X_MAC_L2_GLOBAL_CTRL2);
}

pr_info("%s: RTL931X_MAC_L2_GLOBAL_CTRL2 %08x\n", __func__, sw_r32(RTL931X_MAC_L2_GLOBAL_CTRL2));
pr_info("c45_mask: %08x, RTL931X_SMI_GLB_CTRL0 was %X", c45_mask, sw_r32(RTL931X_SMI_GLB_CTRL0));

/* We have a 10G PHY enable polling
* sw_w32(0x01010000, RTL931X_SMI_10GPHY_POLLING_SEL2);
* sw_w32(0x01E7C400, RTL931X_SMI_10GPHY_POLLING_SEL3);
* sw_w32(0x01E7E820, RTL931X_SMI_10GPHY_POLLING_SEL4);
*/
sw_w32_mask(0xff, c45_mask, RTL931X_SMI_GLB_CTRL1);

return 0;
}

The above function is used to perform the required SMI configuration after calling rtl8367x_mdio_reset() in stmmac_smi_reset_config_init().</s>




NEXT




<s> static int b53_phy_config_aneg(struct phy_device *phydev)
{
return 0;
}

The above function is used to setup phy using auto-neg. So, the above function was renamed on the last commit to something more appropriate, b53_phy_config_an. Now this patch:

static void b53_phy_nway




NEXT




<s> ret_t rtl8367c_setAsicLedOutputEnable(rtk_uint32 enabled)
{
ret_t retVal;
rtk_uint32 regdata;

if (enabled == 1)
regdata = 0;
else
regdata = 1;

/* Enable/Disable H/W IGMP/MLD */
retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_LED_IO_DISABLE_OFFSET, regdata);

return retVal;
}

The above function is used to enable/disable the 48 IGMP/MLD LEDs. When the enable flag is on 1, then the LEDs are disabled. Since the LEDs are on pmu. If we don't make sure that the




NEXT




<s> static int sha1_hmac_init_tfm(struct crypto_tfm *tfm)
{
struct sha1_hmac_ctx *sctx = crypto_tfm_ctx(tfm);
sctx->temp = kzalloc(4 * SHA1_HMAC_DBN_TEMP_SIZE, GFP_KERNEL);
if (IS_ERR(sctx->temp)) return PTR_ERR(sctx->temp);
sctx->desc = kzalloc(sizeof(struct shash_desc), GFP_KERNEL);
if (IS_ERR(sctx->desc)) return PTR_ERR(sctx->desc);

return 0;
}

The above function is used to allocate SHA1 HMAC context that is needed for hashing using the SHA1HMAC_KEYTPL parameter. The crypto_tfm_ctx() is used to access the user defined context. crypto_tfm_ctx(tfm




NEXT




<s> void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to allocate the input buffer.
YACC uses malloc for internal use only, such as buffer allocation, so yyensurce_buffer_stack needs to be defined to call malloc.

The definition of yy_create_buffer




NEXT




<s> int mtd_replace_jffs2(const char *mtd, int fd, int ofs, const char *filename)
{
outfd = fd;
mtdofs = ofs;

buf = malloc(erasesize);
target_ino = 1;
if (!last_ino)
last_ino = 1;
add_file(filename, target_ino);
pad(erasesize);

/* add eof marker, pad to eraseblock size and write the data */
add_data(JFFS2_EOF, sizeof(JFFS2_EOF) - 1);
pad(erasesize);
free(buf);

return (mtdofs - ofs);
}

The above function is used to write only a file (without it's parent directory).
I'm trying to create a function to write a directory (which may contain subdirectories and files). How should the jffs2_add_file(..) function




NEXT




<s> swlib_map_settings(struct switch_dev *dev, int type, int port_vlan, struct uci_section *s)
{
struct swlib_setting *setting;
struct switch_attr *attr;
struct uci_element *e;
struct uci_option *o;

uci_foreach_element(&s->options, e) {
o = uci_to_option(e);

if (o->type != UCI_TYPE_STRING)
continue;

if (!strcmp(e->name, "device"))
continue;

/* map early settings */
if (type == SWLIB_ATTR_GROUP_GLOBAL) {
int i;

for (i = 0; i < ARRAY_SIZE(early_settings); i++) {
if (strcmp(e->name, early_settings[i].name) != 0)
continue;

early_settings[i].val = o->v.string;
goto skip;
}
}

attr = swlib_lookup_attr(dev, type, e->name);
if (!attr)
continue;

setting = malloc(sizeof(struct swlib_setting));
memset(setting, 0, sizeof(struct swlib_setting));
setting->attr = attr;
setting->port_vlan = port_vlan;
setting->val = o->v.string;
*head = setting;
head = &setting->next;
skip:
continue;
}
}

The above function is used to map settings from the config tree to the
switch device
struct settings. The map function loops over the setting options as
seen in the config
file. On each iteration, we determine if we want the setting mapped
based on the type and




NEXT




<s> static void rtl930x_net6_mask(int prefix_len, struct in6_addr *ip6_m)
{
int o, b;
/* Define network mask */
o = prefix_len >> 3;
b = prefix_len & 0x7;
memset(ip6_m->s6_addr, 0xff, o);
ip6_m->s6_addr[o] |= b ? 0xff00 >> b : 0x00;
}

The above function is used to convert an IPv6 prefix of a given length to
a network mask. There's no mask for an IPv6 address of zero length, nor
for an address of full length 128 bits.

Now the trick




NEXT




<s> static int clk_mt7988_ethwarp_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(ARRAY_SIZE(ethwarp_clks));

if (!clk_data)
return -ENOMEM;

mtk_clk_register_gates(node, ethwarp_clks, ARRAY_SIZE(ethwarp_clks),
clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_data;
}
return r;

free_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to create the one cell provider. Let's step through this function's code. It starts with:

struct clk_onecell_data *clk_data;

We will use this variable for the one cell provider data.





NEXT




<s> ar8216_phy_write(struct ar8xxx_priv *priv, int addr, int regnum, u16 val)
{
u32 t;
int ret;

if (addr >= AR8216_NUM_PORTS)
return -EINVAL;

t = (addr << AR8216_MDIO_CTRL_PHY_ADDR_S) |
(regnum << AR8216_MDIO_CTRL_REG_ADDR_S) |
AR8216_MDIO_CTRL_MASTER_EN |
AR8216_MDIO_CTRL_BUSY |
AR8216_MDIO_CTRL_CMD_WRITE |
val;

ar8xxx_write(priv, AR8216_REG_MDIO_CTRL, t);
ret = ar8xxx_reg_wait(priv, AR8216_REG_MDIO_CTRL,
AR8216_MDIO_CTRL_BUSY, 0, 5);

return ret;
}

The above function is used to program the phy address and register number. There are six fields that are sent by means of the mdio bus to write to the internal registers of the phy. The ar8xxx_write function will send the value only after confirming that




NEXT




<s> static int b53_srab_probe(struct platform_device *pdev)
{
struct b53_platform_data *pdata = pdev->dev.platform_data;
struct b53_device *dev;

if (!pdata)
return -EINVAL;

dev = b53_swconfig_switch_alloc(&pdev->dev, &b53_srab_ops, pdata->regs);
if (!dev)
return -ENOMEM;

if (pdata)
dev->pdata = pdata;

platform_set_drvdata(pdev, dev);

return b53_swconfig_switch_register(dev);
}

The above function is used to register the platform device with the kernel platform framework (using platform_device_register() function). The arguments to the platform_device_register() function are:

* pdev, a pointer to the platform device data structure that contains information about




NEXT




<s> rtk_api_ret_t rtk_switch_isPortMaskUtp(rtk_portmask_t *pPmask)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(NULL == pPmask)
return RT_ERR_NULL_POINTER;

if( (pPmask->bits[0] | halCtrl->valid_utp_portmask) != halCtrl->valid_utp_portmask )
return RT_ERR_FAILED;
else
return RT_ERR_OK;
}

The above function is used to enable or disable a given port.





/*
 * Example
 */


include
<stdio.h>
#include
"driver_types.h"
#include
"rtk_api




NEXT




<s> static int lzma_init_props(void)
{
unsigned char props[LZMA_PROPERTIES_SIZE];
int res;
int i;

/* read lzma properties */
for (i = 0; i < LZMA_PROPERTIES_SIZE; i++)
props[i] = lzma_get_byte();

/* read the lower half of uncompressed size in the header */
lzma_outsize = ((SizeT) lzma_get_byte()) +
((SizeT) lzma_get_byte() << 8) +
((SizeT) lzma_get_byte() << 16) +
((SizeT) lzma_get_byte() << 24);

/* skip rest of the header (upper half of uncompressed size) */
for (i = 0; i < 4; i++)
lzma_get_byte();

res = LzmaDecodeProperties(&lzma_state.Properties, props,
LZMA_PROPERTIES_SIZE);
return res;
}

The above function is used to obtain the lzma_state structure of the lzma_state_t data member
of lzma_dec.

LzmaDecodeProperties takes a structure and some arguments as inputs, and an error return, as output




NEXT




<s> static inline struct ar934x_nfc *mtd_to_ar934x_nfc(struct mtd_info *mtd)
{
struct nand_chip *chip = mtd_to_nand(mtd);

return container_of(chip, struct ar934x_nfc, nand_chip);
}

The above function is used to obtain the ar934x_nfc structure from mtd_info structure of the memory controller.

static int ar934x_nfc_read_oob(struct mtd_info *mtd, struct




NEXT




<s> ret_t rtl8367c_getAsicShareMeter(rtk_uint32 index, rtk_uint32 *pRate, rtk_uint32 *pIfg)
{
rtk_uint32 regData;
rtk_uint32 regData2;
ret_t retVal;

if(index > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(index < 32)
{
/*17-bits Rate*/
retVal = rtl8367c_getAsicReg(RTL8367C_METER_RATE_REG(index), &regData);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicReg(RTL8367C_METER_RATE_REG(index) + 1, &regData2);
if(retVal != RT_ERR_OK)
return retVal;

*pRate = ((regData2 << 16) & 0x70000) | regData;
/*IFG*/
retVal = rtl8367c_getAsicRegBit(RTL8367C_METER_IFG_CTRL_REG(index), RTL8367C_METER_IFG_OFFSET(index), pIfg);

return retVal;
}
else
{
/*17-bits Rate*/
retVal = rtl8367c_getAsicReg(RTL8367C_REG_METER32_RATE_CTRL0 + ((index-32) << 1), &regData);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_METER32_RATE_CTRL0 + ((index-32) << 1) + 1, &regData2);
if(retVal != RT_ERR_OK)
return retVal;

*pRate = ((regData2 << 16) & 0x70000) | regData;
/*IFG*/
retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_METER_IFG_CTRL2 + ((index-32) >> 4), RTL8367C_METER_IFG_OFFSET(index), pIfg);

return retVal;
}
}

The above function is used to query the given Meter to determine the rate and Interval For Group (IFG).

A Meter rate is programmed using 17 bits. The 17 bits are arranged in three sets of 5 bits per set. The first




NEXT




<s> static int rtl83xx_netevent_event(struct notifier_block *this,
unsigned long event, void *ptr)
{
struct rtl838x_switch_priv *priv;
struct net_device *dev;
struct neighbour *n = ptr;
int err, port;
struct net_event_work *net_work;

priv = container_of(this, struct rtl838x_switch_priv, ne_nb);

switch (event) {
case NETEVENT_NEIGH_UPDATE:
if (n->tbl != &arp_tbl)
return NOTIFY_DONE;
dev = n->dev;
port = rtl83xx_port_dev_lower_find(dev, priv);
if (port < 0 || !(n->nud_state & NUD_VALID)) {
pr_debug("%s: Neigbour invalid, not updating\n", __func__);
return NOTIFY_DONE;
}

net_work = kzalloc(sizeof(*net_work), GFP_ATOMIC);
if (!net_work)
return NOTIFY_BAD;

INIT_WORK(&net_work->work, rtl83xx_net_event_work_do);
net_work->priv = priv;

net_work->mac = ether_addr_to_u64(n->ha);
net_work->gw_addr = *(__be32 *) n->primary_key;

pr_debug("%s: updating neighbour on port %d, mac %016llx\n",
__func__, port, net_work->mac);
schedule_work(&net_work->work);
if (err)
netdev_warn(dev, "failed to handle neigh update (err %d)\n", err);
break;
}

return NOTIFY_DONE;
}

The above function is used to process neighbour change event notification. This notification allows
us to update the ARP cache in the switch. This is achieved by adding / removing ARP entries as per
our requirements.

We need to add certain changes to allow the switch to




NEXT




<s> void rtl9300_do_rx_calibration_4(u32 sds_num)
{
rtl9300_do_rx_calibration_4_1(sds_num);
rtl9300_do_rx_calibration_4_2(sds_num);
}

The above function is used to do rtl9300 Rx calibration. You can use Wireshark, ethereal, tcpdump and other tools to see the output, because the RX data is correct.

However, according to the Linux driver




NEXT




<s> uc_value_t *uc_wpa_getpid(uc_vm_t *vm, size_t nargs)
{
return ucv_int64_new(getpid());
}

The above function is used to get process ID

It is a wrapper written around getpid() system call.

ucp_value_t *uc_sleep(uc_vm_t *vm, size_t nargs)
{
static unsigned long




NEXT




<s> ar8327_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
{
u32 t;
u32 egress, ingress;
u32 pvid = priv->vlan_id[priv->pvid[port]];

if (priv->vlan) {
egress = AR8327_PORT_VLAN1_OUT_MODE_UNMOD;
ingress = AR8216_IN_SECURE;
} else {
egress = AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH;
ingress = AR8216_IN_PORT_ONLY;
}

t = pvid << AR8327_PORT_VLAN0_DEF_SVID_S;
t |= pvid << AR8327_PORT_VLAN0_DEF_CVID_S;
if (priv->vlan && priv->port_vlan_prio[port]) {
u32 prio = priv->port_vlan_prio[port];

t |= prio << AR8327_PORT_VLAN0_DEF_SPRI_S;
t |= prio << AR8327_PORT_VLAN0_DEF_CPRI_S;
}
ar8xxx_write(priv, AR8327_REG_PORT_VLAN0(port), t);

t = AR8327_PORT_VLAN1_PORT_VLAN_PROP;
t |= egress << AR8327_PORT_VLAN1_OUT_MODE_S;
if (priv->vlan && priv->port_vlan_prio[port])
t |= AR8327_PORT_VLAN1_VLAN_PRI_PROP;

ar8xxx_write(priv, AR8327_REG_PORT_VLAN1(port), t);

t = members;
t |= AR8327_PORT_LOOKUP_LEARN;
t |= ingress << AR8327_PORT_LOOKUP_IN_MODE_S;
t |= AR8216_PORT_STATE_FORWARD << AR8327_PORT_LOOKUP_STATE_S;
ar8xxx_write(priv, AR8327_REG_PORT_LOOKUP(port), t);
}

The above function is used to setup a given port of ar8216 device. This function is used when a PHY device has been configured and a port needs to be setup as an interface. The function can be divided in following three parts.

1. AR




NEXT




<s> rtk_api_ret_t rtk_stat_port_getAll(rtk_port_t port, rtk_stat_port_cntr_t *pPort_cntrs)
{
rtk_api_ret_t retVal;
rtk_uint32 mibIndex;
rtk_uint64 mibCounter;
rtk_uint32 *accessPtr;
/* address offset to MIBs counter */
CONST_T rtk_uint16 mibLength[STAT_PORT_CNTR_END]= {
2,1,1,1,1,1,1,1,1,
2,1,1,1,1,1,1,1,1,1,1,
2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPort_cntrs)
return RT_ERR_NULL_POINTER;

/* Check port valid */
RTK_CHK_PORT_VALID(port);

accessPtr = (rtk_uint32*)pPort_cntrs;
for (mibIndex=0;mibIndex<STAT_PORT_CNTR_END;mibIndex++)
{
if ((retVal = rtk_stat_port_get(port, mibIndex, &mibCounter)) != RT_ERR_OK)
{
if (retVal == RT_ERR_CHIP_NOT_SUPPORTED)
mibCounter = 0;
else
return retVal;
}

if (2 == mibLength[mibIndex])
*(rtk_uint64*)accessPtr = mibCounter;
else if (1 == mibLength[mibIndex])
*accessPtr = mibCounter;
else
return RT_ERR_FAILED;

accessPtr+=mibLength[mibIndex];
}

return RT_ERR_OK;
}

The above function is used to view port statistics. Since all counters must be set to zero before they can be incremented, the RT_STAT_PORT_CLEARALL operation, which zeros all counters in all ports, should be completed in advance.






NEXT




<s> int setmode(int fbd, const struct pixelformat *pixf,const struct vidsize *vids){
struct fb_var_screeninfo var;
int stat;
stat = ioctl (fbd, FBIOGET_VSCREENINFO,&var);
if (stat<0) return -2;

var.xres= vids->width;
var.xres_virtual = vids->width;
var.yres= vids->height;
var.yres_virtual = vids->height;

var.bits_per_pixel = pixf->bpp;
var.red = pixf->red;
var.green = pixf->green;
var.blue = pixf->blue;
var.transp = pixf->transp;

stat = ioctl (fbd, FBIOPUT_VSCREENINFO,&var);
if (stat<0) return -1;
return 0;
}

The above function is used to get current screen attributes (i.e resolution and color format) so that they can be modified programmatically .

For the given arguments, the function will try to change the resolution (i.e. width and height) of the screen




NEXT




<s> ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);

int
trx_fixup(int fd, const char *name)
{
struct mtd_info_user mtdInfo;
unsigned long len;
struct trx_header *trx;
void *ptr, *scan;
int bfd;

if (ioctl(fd, MEMGETINFO, &mtdInfo) < 0) {
fprintf(stderr, "Failed to get mtd info\n");
goto err;
}

len = mtdInfo.size;
if (mtdInfo.size <= 0) {
fprintf(stderr, "Invalid MTD device size\n");
goto err;
}

bfd = mtd_open(name, true);
ptr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, bfd, 0);
if (!ptr || (ptr == (void *) -1)) {
perror("mmap");
fprintf(stderr, "Mapping the TRX header failed\n");
goto err1;
}

trx = ptr;
if (ntohl(trx->magic) != opt_trxmagic) {
fprintf(stderr, "TRX header not found\n");
goto err;
}

scan = ptr + offsetof(struct trx_header, flag_version);
trx->crc32 = crc32buf(scan, trx->len - (scan - ptr));
msync(ptr, sizeof(struct trx_header), MS_SYNC|MS_INVALIDATE);
munmap(ptr, len);
close(bfd);
return 0;

err1:
close(bfd);
err:
return -1;
}

The above function is used to write the trx header (and possibly other data) to an nand or other flash device. The trx header is just a big magic number that indicates this data is formatted in some sort of way. It is followed by a struct containing




NEXT




<s> static inline unsigned int rtl8367c_portmask_phy_to_sw(rtk_portmask_t phy_portmask)
{
int i;
for (i = 0; i < RTL8367C_NUM_PORTS; i++) {
if(RTK_PORTMASK_IS_PORT_SET(phy_portmask,rtl8367c_sw_to_phy_port(i))) {
RTK_PORTMASK_PORT_CLEAR(phy_portmask,rtl8367c_sw_to_phy_port(i));
RTK_PORTMASK_PORT_SET(phy_portmask,i);
}

}
return (unsigned int)phy_portmask.bits[0];
}

The above function is used to convert portmask of PHY to corresponding SW portmask. And it is used in r8367c_hw_portmask_set, rtl8367c_clear_portmask and clear_portmask






NEXT




<s> int AT91F_ReadLine (const char *const prompt, char *console_buffer)
{
char *p = console_buffer;
int	n = 0;					/* buffer index		*/
int	plen = strlen (prompt);	/* prompt length	*/
int	col;					/* output column cnt	*/
char	c;

/* print prompt */
if (prompt)
printf(prompt);
col = plen;

for (;;) {
c = getc();

switch (c) {
case '\r':				/* Enter		*/
case '\n':
*p = '\0';
puts ("\n");
return (p - console_buffer);

case 0x03:				/* ^C - break	*/
console_buffer[0] = '\0';	/* discard input */
return (-1);

case 0x08:				/* ^H  - backspace	*/
case 0x7F:				/* DEL - backspace	*/
if (n) {
--p;
printf(erase_seq);
col--;
n--;
}
continue;

default:
/*
* Must be a normal character then
*/
if (n < (AT91C_CB_SIZE -2))
{
++col;		/* echo input		*/
putc(c);
*p++ = c;
++n;
}
else
{			/* Buffer full		*/
putc('\a');
}
}
}
}

The above function is used to implement menu selection. Let's examine an example which is an alternative way to select the menu item as mentioned in Part1. In this example we don't need to do menu selection for the second level and below from the main menu. So




NEXT




<s> int rtl838x_read_mmd_phy(u32 port, u32 addr, u32 reg, u32 *val)
{
int err;
u32 v;

mutex_lock(&smi_lock);

err = rtl838x_smi_wait_op(100000);
if (err)
goto errout;

sw_w32(1 << port, RTL838X_SMI_ACCESS_PHY_CTRL_0);
mdelay(10);

sw_w32_mask(0xffff0000, port << 16, RTL838X_SMI_ACCESS_PHY_CTRL_2);

v = addr << 16 | reg;
sw_w32(v, RTL838X_SMI_ACCESS_PHY_CTRL_3);

/* mmd-access | read | cmd-start */
v = 1 << 1 | 0 << 2 | 1;
sw_w32(v, RTL838X_SMI_ACCESS_PHY_CTRL_1);

err = rtl838x_smi_wait_op(100000);
if (err)
goto errout;

*val = sw_r32(RTL838X_SMI_ACCESS_PHY_CTRL_2) & 0xffff;

err = 0;

errout:
mutex_unlock(&smi_lock);

return err;
}

The above function is used to read MMD register of phy. It is very important to call smi_wait_op prior to accessing a phy register. smi_wait_op is a wrapper function to wait if the phy is busy (sw_




NEXT




<s> static int __init nct5104d_gpio_init(void)
{
int err;
struct nct5104d_sio sio;

if (nct5104d_find(0x2e, &sio) &&
nct5104d_find(0x4e, &sio))
return -ENODEV;

err = platform_driver_register(&nct5104d_gpio_driver);
if (!err) {
pr_info(DRVNAME ": platform_driver_register\n");
err = nct5104d_gpio_device_add(&sio);
if (err)
platform_driver_unregister(&nct5104d_gpio_driver);
}

return err;
}

The above function is used to initialise both nct5104d based on i2c or PCNT, you don't need to call nct5104d_pinctl_init(). If both fail, it will return -ENODEV




NEXT




<s> static int pci_msi_vec_num(struct pci_dev *dev)
{
int ret;
u16 msgctl;

if (!dev->msi_cap)
return -EINVAL;

pci_read_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, &msgctl);
ret = 1 << ((msgctl & PCI_MSI_FLAGS_QMASK) >> 1);

return ret;
}

The above function is used to determine the number of support MSI-Vector for a device. The reason it is needed is because different PCI functions may use a different number of MSI-Vector to support their features. A device may support multiple devices but they may not all use




NEXT




<s> void rtl930x_dbgfs_init(struct rtl838x_switch_priv *priv)
{
struct dentry *dbg_dir;

pr_info("%s called\n", __func__);
dbg_dir = debugfs_lookup(RTL838X_DRIVER_NAME, NULL);
if (!dbg_dir)
dbg_dir = debugfs_create_dir(RTL838X_DRIVER_NAME, NULL);

priv->dbgfs_dir = dbg_dir;

debugfs_create_file("drop_counters", 0400, dbg_dir, priv, &drop_counter_fops);

debugfs_create_file("l2_table", 0400, dbg_dir, priv, &l2_table_fops);
}

The above function is used to initialize the debugfs directory of rtl930x switch.

The first thing I will do is to trace the execution of “debugfs_create_dir(RTL838X_DRIVER_NAME, NULL);




NEXT




<s> rtk_api_ret_t rtk_svlan_c2s_add(rtk_vlan_t vid, rtk_port_t src_port, rtk_vlan_t svid)
{
rtk_api_ret_t retVal, i;
rtk_uint32 empty_idx;
rtk_uint32 evid, pmsk, svidx, c2s_svidx;
rtl8367c_svlan_memconf_t svlanMemConf;
rtk_port_t phyPort;
rtk_uint16 doneFlag;


/* Check initialization state */
RTK_CHK_INIT_STATE();


if (vid > RTL8367C_VIDMAX)
return RT_ERR_VLAN_VID;

if (svid > RTL8367C_VIDMAX)
return RT_ERR_SVLAN_VID;

/* Check port Valid */
RTK_CHK_PORT_VALID(src_port);

phyPort = rtk_switch_port_L2P_get(src_port);

empty_idx = 0xFFFF;
svidx = 0xFFFF;
doneFlag = FALSE;

for (i = 0; i<= RTL8367C_SVIDXMAX; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;

if (svid == svlanMemConf.vs_svid)
{
svidx = i;
break;
}
}

if (0xFFFF == svidx)
return RT_ERR_SVLAN_VID;

for (i=RTL8367C_C2SIDXMAX; i>=0; i--)
{
if ((retVal = rtl8367c_getAsicSvlanC2SConf(i, &evid, &pmsk, &c2s_svidx)) != RT_ERR_OK)
return retVal;

if (evid == vid)
{
/* Check Src_port */
if(pmsk & (1 << phyPort))
{
/* Check SVIDX */
if(c2s_svidx == svidx)
{
/* All the same, do nothing */
}
else
{
/* New svidx, remove src_port and find a new slot to add a new enrty */
pmsk = pmsk & ~(1 << phyPort);
if(pmsk == 0)
c2s_svidx = 0;

if ((retVal = rtl8367c_setAsicSvlanC2SConf(i, vid, pmsk, c2s_svidx)) != RT_ERR_OK)
return retVal;
}
}
else
{
if(c2s_svidx == svidx && doneFlag == FALSE)
{
pmsk = pmsk | (1 << phyPort);
if ((retVal = rtl8367c_setAsicSvlanC2SConf(i, vid, pmsk, svidx)) != RT_ERR_OK)
return retVal;

doneFlag = TRUE;
}
}
}
else if (evid==0&&pmsk==0)
{
empty_idx = i;
}
}

if (0xFFFF != empty_idx && doneFlag ==FALSE)
{
if ((retVal = rtl8367c_setAsicSvlanC2SConf(empty_idx, vid, (1<<phyPort), svidx)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}
else if(doneFlag == TRUE)
{
return RT_ERR_OK;
}

return RT_ERR_OUT_OF_RANGE;
}

The above function is used to add an entry to the Control to Source SVLAN Mapping table and it will map the L2 Port with a particular VID to a SVLAN with particular SVID in the Source to Control SVLAN Mapping table.
For example, add




NEXT




<s> ret_t rtl8367c_getAsic1xGuestVidx(rtk_uint32 *pIndex)
{
return rtl8367c_getAsicRegBits(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_GVIDX_MASK, pIndex);
}

The above function is used to obtain the index of the GVID.
The below function is used to set the GVLAN index for the specified vlanIndex of GVID to 1xVlanVID

ret_t rtl8367c_




NEXT




<s> static void print_arrows(WINDOW * win, int item_no, int scroll, int y, int x,
int height)
{
int cur_y, cur_x;

getyx(win, cur_y, cur_x);

wmove(win, y, x);

if (scroll > 0) {
wattrset(win, dlg.uarrow.atr);
waddch(win, ACS_UARROW);
waddstr(win, "(-)");
} else {
wattrset(win, dlg.menubox.atr);
waddch(win, ACS_HLINE);
waddch(win, ACS_HLINE);
waddch(win, ACS_HLINE);
waddch(win, ACS_HLINE);
}

y = y + height + 1;
wmove(win, y, x);
wrefresh(win);

if ((height < item_no) && (scroll + height < item_no)) {
wattrset(win, dlg.darrow.atr);
waddch(win, ACS_DARROW);
waddstr(win, "(+)");
} else {
wattrset(win, dlg.menubox_border.atr);
waddch(win, ACS_HLINE);
waddch(win, ACS_HLINE);
waddch(win, ACS_HLINE);
waddch(win, ACS_HLINE);
}

wmove(win, cur_y, cur_x);
wrefresh(win);
}

The above function is used to print the up and down arrows above/below the menu items.</s>




NEXT




<s> ret_t rtl8367c_getAsicPriorityDscpBased(rtk_uint32 dscp, rtk_uint32 *pPriority )
{
if(dscp > RTL8367C_DSCPMAX)
return RT_ERR_QOS_DSCP_VALUE;

return rtl8367c_getAsicRegBits(RTL8367C_QOS_DSCP_TO_PRIORITY_REG(dscp), RTL8367C_QOS_DSCP_TO_PRIORITY_MASK(dscp), pPriority);
}

The above function is used to match a specified DSCP field to a priority value, and then return the latter into rthPri. It is called by qosRtkPriorityAssigned, which does almost nothing but convert the internal priority index to a real priority value




NEXT




<s> swconfig_trig_set_brightness(struct swconfig_trig_data *trig_data,
enum led_brightness brightness)
{
led_set_brightness(trig_data->led_cdev, brightness);
trig_data->prev_brightness = brightness;
}

The above function is used to set the brightness of the LED using a
trig_id of LC_BRIGHTNESS. Trig_data and led_cdev are passed from
another function that registers the callback function which is
called when the property




NEXT




<s> static void mt7621_nfc_write_fdm(struct mt7621_nfc *nfc)
{
struct nand_chip *nand = &nfc->nand;
u32 vall, valm;
u8 *oobptr;
int i, j;

for (i = 0; i < nand->ecc.steps; i++) {
vall = 0;
valm = 0;
oobptr = oob_fdm_ptr(nand, i);

for (j = 0; j < 4; j++)
vall |= (u32)oobptr[j] << (j * 8);

for (j = 0; j < 4; j++)
valm |= (u32)oobptr[j + 4] << (j * 8);

nfi_write32(nfc, NFI_FDML(i), vall);
nfi_write32(nfc, NFI_FDMM(i), valm);
}
}

The above function is used to write 0 to FDM registers, which is the same
as erase all FDM registers. If we replace this function with

#define NFI_FDML(_n)	NFI_ERML(_n)
#




NEXT




<s> rtk_api_ret_t rtk_svlan_sp2c_add(rtk_vlan_t svid, rtk_port_t dst_port, rtk_vlan_t cvid)
{
rtk_api_ret_t retVal, i;
rtk_uint32 empty_idx, svidx;
rtl8367c_svlan_memconf_t svlanMemConf;
rtl8367c_svlan_s2c_t svlanSP2CConf;
rtk_port_t port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (svid > RTL8367C_VIDMAX)
return RT_ERR_SVLAN_VID;

if (cvid > RTL8367C_VIDMAX)
return RT_ERR_VLAN_VID;

/* Check port Valid */
RTK_CHK_PORT_VALID(dst_port);
port = rtk_switch_port_L2P_get(dst_port);

svidx = 0xFFFF;

for (i = 0; i < RTL8367C_SVIDXNO; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;

if (svid == svlanMemConf.vs_svid)
{
svidx = i;
break;
}
}

if (0xFFFF == svidx)
return RT_ERR_SVLAN_ENTRY_NOT_FOUND;

empty_idx = 0xFFFF;

for (i=RTL8367C_SP2CMAX; i >=0 ; i--)
{
if ((retVal = rtl8367c_getAsicSvlanSP2CConf(i, &svlanSP2CConf)) != RT_ERR_OK)
return retVal;

if ( (svlanSP2CConf.svidx == svidx) && (svlanSP2CConf.dstport == port) && (svlanSP2CConf.valid == 1))
{
empty_idx = i;
break;
}
else if (svlanSP2CConf.valid == 0)
{
empty_idx = i;
}
}

if (empty_idx!=0xFFFF)
{
svlanSP2CConf.valid     = 1;
svlanSP2CConf.vid       = cvid;
svlanSP2CConf.svidx     = svidx;
svlanSP2CConf.dstport   = port;

if ((retVal = rtl8367c_setAsicSvlanSP2CConf(empty_idx, &svlanSP2CConf)) != RT_ERR_OK)
return retVal;
return RT_ERR_OK;
}

return RT_ERR_OUT_OF_RANGE;

}

The above function is used to add an SVID-CPID translation entry into the SVLAN-CVID database of the switch chip. In the function, if svlanMemConf.vs_svid is equal to svid and if svlanSP2CConf.




NEXT




<s> static void soc_type_to_str(u32 soc)
{
memset(soc_str, 0, sizeof(soc_str));

if ((soc & ACA_SOC_XRX300))
strcat(soc_str, "xrx300 ");

if ((soc & ACA_SOC_XRX500))
strcat(soc_str, "xrx500 ");

if ((soc & ACA_SOC_PUMA))
strcat(soc_str, "puma ");

if ((soc & ACA_SOC_3RD_PARTY))
strcat(soc_str, "third party SoC ");
}

The above function is used to obtain a string representation of the type of SoC in use on the device. This can be useful when, for example, parsing a string containing a chip ID, you wish to print the type of the SoC. Instead of parsing for




NEXT




<s> static inline u32 fe_empty_txd(struct fe_tx_ring *ring)
{
barrier();
return (u32)(ring->tx_ring_size -
((ring->tx_next_idx - ring->tx_free_idx) &
(ring->tx_ring_size - 1)));
}

The above function is used to determine the number of free transmision
descriptor indexes, from the currently free index to the beginning of
the ring. In this case, we just check for the index wrap.  If tx_free_idx
wraps, there is




NEXT




<s> static int mtk_bmt_debug_bbt(void *data, u64 val)
{
char buf[5];
int i, k;

switch (val) {
case 0:
for (i = 0; i < bmtd.total_blks; i += 4) {
u8 cur = bmtd.bbt_buf[i / 4];

for (k = 0; k < 4; k++, cur >>= 2)
buf[k] = (cur & 3) ? 'B' : '.';

buf[4] = 0;
printk("[%06x] %s\n", i * bmtd.blk_size, buf);
}
break;
case 100:
#if 0
for (i = bmtd.bmt_blk_idx; i < bmtd.total_blks - 1; i++)
bbt_nand_erase(bmtd.bmt_blk_idx);
#endif

bmtd.bmt_blk_idx = bmtd.total_blks - 1;
bbt_nand_erase(bmtd.bmt_blk_idx);
write_bmt(bmtd.bmt_blk_idx, bmtd.bbt_buf);
break;
default:
break;
}
return 0;
}

The above function is used to debug bbt from the user space by print bbt to stdout, erase all bbt or update a single bbt entry.

The following list shows different values to be used along with mt_bmt_debug_bbt




NEXT




<s> rtk_api_ret_t rtk_switch_isPtpPort(rtk_port_t logicalPort)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(logicalPort >= RTK_SWITCH_PORT_NUM)
return RT_ERR_FAILED;

if(halCtrl->ptp_port[logicalPort] == 1)
return RT_ERR_OK;
else
return RT_ERR_FAILED;
}

The above function is used to determine a logical port whether supports PTP on not.

The following APIs is used to turn on/turn off a PTP port.

rtk_api_ret_t rtk_switch_p2p_on




NEXT




<s> rtl_set_use_cpuport(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct rtl_priv *priv = to_rtl(dev);
priv->do_cpu = val->value.i;
rtl_hw_init(dev);
return 0;
}

The above function is used to enable CPU-side port 0 in RTL8192c.
However, in the rtl_hw_init function, the rtl_set_pcie_bw function is used to set the bandwith of the PCI




NEXT




<s> static int rtl8366rb_mii_write(struct mii_bus *bus, int addr, int reg, u16 val)
{
struct rtl8366_smi *smi = bus->priv;
u32 t;
int err;

err = rtl8366rb_write_phy_reg(smi, addr, 0, reg, val);
/* flush write */
(void) rtl8366rb_read_phy_reg(smi, addr, 0, reg, &t);

return err;
}

The above function is used to write a given value to a given PHY reg
and it's not working.</s>




NEXT




<s> void workaround5458(struct ata_host *ah)
{
struct sata_oxnas_host_priv *hd = ah->private_data;
void __iomem *phy_base = hd->phy_base;
u16 rx_control;
unsigned i;

for (i = 0; i < 2; i++) {
rx_control = read_cr(phy_base, 0x201d + (i << 8));
rx_control &= ~(PH_GAIN_MASK | FR_GAIN_MASK);
rx_control |= PH_GAIN << PH_GAIN_OFFSET;
rx_control |= (FR_GAIN << FR_GAIN_OFFSET) | USE_INT_SETTING;
write_cr(phy_base, rx_control, 0x201d+(i<<8));
}
}

The above function is used to workaround an obscure issue with the oxnas drivers (which is at least 3 years old from looking at the git history). The code is pretty simple, and it just sets the preamble and framing gain registers to some special values




NEXT




<s> rtk_api_ret_t rtk_rate_stormControlExtPortmask_get(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicStormFilterExtEnablePortMask(&pmask)) != RT_ERR_OK)
return retVal;

if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve a given port mask in internal representation format (Port Mask).
The rate storm control filter module supports packet storm control policy which applies global packet storm filter policy on the given port mask. The function requires an empty portmask array. The portmask




NEXT




<s> static inline void fe_set_txd(struct fe_tx_dma *txd, struct fe_tx_dma *dma_txd)
{
dma_txd->txd1 = txd->txd1;
dma_txd->txd3 = txd->txd3;
dma_txd->txd4 = txd->txd4;
/* clean dma done flag last */
dma_txd->txd2 = txd->txd2;
}

The above function is used to synchronize DMA descriptors for a DMA FIFO
transfer between two separate physical DMA regions on a unified buffer
region.

Bug 67446 : Reorder of FE DMA descriptors with the same ID is




NEXT




<s> void aes_set_key_hw (void *ctx_arg)
{
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
volatile struct aes_t *aes = (volatile struct aes_t *) AES_START;
struct aes_ctx *ctx = (struct aes_ctx *)ctx_arg;
u8 *in_key = ctx->buf;
int key_len = ctx->key_length;
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

if (ctx->use_tweak) in_key = ctx->tweakkey;

/* 128, 192 or 256 bit key length */
aes->controlr.K = key_len / 8 - 2;
if (key_len == 128 / 8) {
aes->K3R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 0));
aes->K2R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 1));
aes->K1R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 2));
aes->K0R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 3));
}
else if (key_len == 192 / 8) {
aes->K5R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 0));
aes->K4R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 1));
aes->K3R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 2));
aes->K2R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 3));
aes->K1R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 4));
aes->K0R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 5));
}
else if (key_len == 256 / 8) {
aes->K7R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 0));
aes->K6R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 1));
aes->K5R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 2));
aes->K4R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 3));
aes->K3R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 4));
aes->K2R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 5));
aes->K1R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 6));
aes->K0R = DEU_ENDIAN_SWAP(*((u32 *) in_key + 7));
}
else {
printk (KERN_ERR "[%s %s %d]: Invalid key_len : %d\n", __FILE__, __func__, __LINE__, key_len);
return; //-EINVAL;
}

/* let HW pre-process DEcryption key in any case (even if
ENcryption is used). Key Valid (KV) bit is then only
checked in decryption routine! */
aes->controlr.PNK = 1;

}

The above function is used to set the desired key to the hardware accelerator. The accelerator supports 128-bit or 256-bit key. This accelerator automatically selects the size of the key depending upon the size of the key provided to it




NEXT




<s> ret_t rtl8367c_getAsicPortForceLink(rtk_uint32 port, rtl8367c_port_ability_t *pPortAbility)
{
ret_t retVal;
rtk_uint32 regData;

/* Invalid input parameter */
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_MAC0_FORCE_SELECT + port, &regData);
if(retVal != RT_ERR_OK)
return retVal;

pPortAbility->forcemode = (regData >> 12) & 0x0001;
pPortAbility->mstfault  = (regData >> 9) & 0x0001;
pPortAbility->mstmode   = (regData >> 8) & 0x0001;
pPortAbility->nway      = (regData >> 7) & 0x0001;
pPortAbility->txpause   = (regData >> 6) & 0x0001;
pPortAbility->rxpause   = (regData >> 5) & 0x0001;
pPortAbility->link      = (regData >> 4) & 0x0001;
pPortAbility->duplex    = (regData >> 2) & 0x0001;
pPortAbility->speed     = regData & 0x0003;

return RT_ERR_OK;
}

The above function is used to get the ability of the given specific port.</s>




NEXT




<s> static void rtl839x_set_igr_filter(int port,  enum igr_filter state)
{
sw_w32_mask(0x3 << ((port & 0xf)<<1), state << ((port & 0xf)<<1),
RTL839X_VLAN_PORT_IGR_FLTR + (((port >> 4) << 2)));
}

The above function is used to set/clear igr filter for various VLAN port.

Here are igr filters for CPU port 0 (VLAN_PORT_CP):

When igmp host mode is 2, ingress filter is always enabled.




NEXT




<s> static void radius_userdata_init(struct radius_user_data *u)
{
kvlist_init(&u->users, kvlist_blob_len);
avl_init(&u->user_state, avl_strcmp, false, NULL);
}

The above function is used to initialize the structure we declared in the previous article here. I haven't tested them with any authentication tool myself, but I'm always keen to hear feedback.

Also see the previous article, or head to the project page on K




NEXT




<s> static void ag71xx_hw_set_macaddr(struct ag71xx *ag, const unsigned char *mac)
{
u32 t;

t = (((u32) mac[5]) << 24) | (((u32) mac[4]) << 16)
| (((u32) mac[3]) << 8) | ((u32) mac[2]);

ag71xx_wr(ag, AG71XX_REG_MAC_ADDR1, t);

t = (((u32) mac[1]) << 24) | (((u32) mac[0]) << 16);
ag71xx_wr(ag, AG71XX_REG_MAC_ADDR2, t);
}

The above function is used to set the MAC address at compile time.

At runtime, I was able to use the ioctl() set address function but the change never gets recognized by Netgear WNDR3800 router when I try to connect with different




NEXT




<s> static int rtc_do_ioctl(unsigned int cmd, unsigned long arg)
{
struct rtc_time rtc_tm;

switch (cmd) {
case RTC_RD_TIME:
memset(&rtc_tm, 0, sizeof(struct rtc_time));
get_rtc_time(&rtc_tm);
if (copy_to_user((void *)arg, &rtc_tm, sizeof(rtc_tm)))
return -EFAULT;
break;

case RTC_SET_TIME:
if (!capable(CAP_SYS_TIME))
return -EACCES;

if (copy_from_user(&rtc_tm, (struct rtc_time *)arg,
sizeof(struct rtc_time)))
return -EFAULT;

set_rtc_time(&rtc_tm);
break;

default:
return -ENOTTY;
}

return 0;
}

The above function is used to setup or get the system time, while the
following function is used to setup the alarm time.

static unsigned int rtc_alarm = { 0, 100 };
static int rtc_get_al




NEXT




<s> static int read_file(char *file_name)
{
int ret = EXIT_FAILURE;
uint32_t file_size = 0;
FILE *fp;

fp = fopen(file_name, "r");

if (!fp) {
ERR("Failed to open config input file %s", file_name);
goto out;
}

fseek(fp, 0L, SEEK_END);
file_size = ftell(fp);
fseek(fp, 0L, SEEK_SET);

buffer = malloc(file_size);
VERBOSE("Allocated %d bytes.", file_size);

if (fread(buffer, 1, file_size, fp) != file_size) {
ERR("Failed to read config input file %s", file_name);
goto out_free_buf;
}

VERBOSE("Read %d bytes of config input file %s", file_size, file_name);
config_size = file_size;
ret = EXIT_SUCCESS;
goto out;

out_free_buf:
free(buffer);
fclose(fp);
out:
return ret;
}

The above function is used to get content for a file
```</s>




NEXT




<s> int rtl8367s_swconfig_init(void (*reset_func)(void))
{
struct rtl8367_priv  *priv = &rtl8367_priv_data;
struct switch_dev *dev=&priv->swdev;
int err=0;

rtl8367_switch_reset_func = reset_func ;

memset(priv, 0, sizeof(struct rtl8367_priv));
priv->global_vlan_enable =0;

dev->name = "RTL8367C";
dev->cpu_port = RTL8367C_SW_CPU_PORT;
dev->ports = RTL8367C_NUM_PORTS;
dev->vlans = RTL8367C_NUM_VIDS;
dev->ops = &rtl8367_sw_ops;
dev->alias = "RTL8367C";
err = register_switch(dev, NULL);

pr_info("[%s]\n",__func__);

return err;
}

The above function is used to set up Switch and call the register_switch function to register the switch.
It can be called in the startup.c and it will register the switch by calling the above function.
This is the normal flow to register the RTL83




NEXT




<s> static int rb4xx_gpio_cpld_set(struct rb4xx_gpio *gpio, unsigned int offset,
int value)
{
struct rb4xx_cpld *cpld = gpio->cpld;
u16 values;
int ret;

mutex_lock(&gpio->lock);
values = gpio->values;

if (value)
values |= BIT(offset);
else
values &= ~(BIT(offset));

if (values == gpio->values) {
ret = 0;
goto unlock;
}

if (offset < 8) {
ret = cpld->gpio_set_0_7(cpld, values & 0xff);
} else if (offset == 8) {
ret = cpld->gpio_set_8(cpld, values >> 8);
}

if(likely(!ret))
gpio->values = values;

unlock:
mutex_unlock(&gpio->lock);
return ret;
}

The above function is used to set a specific bit of
a GPIO register (offset) to a specific value (value).

We can see that some GPIO registers actually have multiple bits,
which are set separately by two separate functions:

cpld->gpio_




NEXT




<s> rtk_api_ret_t rtk_eee_portEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t   retVal;
rtk_uint32      regData;
rtk_uint32    phy_port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port is UTP port */
RTK_CHK_PORT_IS_UTP(port);

if (enable>=RTK_ENABLE_END)
return RT_ERR_INPUT;

phy_port = rtk_switch_port_L2P_get(port);

if ((retVal = rtl8367c_setAsicEee100M(phy_port,enable))!=RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicEeeGiga(phy_port,enable))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicPHYReg(phy_port, RTL8367C_PHY_PAGE_ADDRESS, 0))!=RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_getAsicPHYReg(phy_port, 0, &regData))!=RT_ERR_OK)
return retVal;
regData |= 0x0200;
if ((retVal = rtl8367c_setAsicPHYReg(phy_port, 0, regData))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable automatic EEE control for a specified port.

The function prototype is as follows:

#define rtk_eee_portEnable_set(unsigned int port, rtk_enable_t enable)

where:




NEXT




<s> ret_t rtl8367c_getAsicAclNot(rtk_uint32 index, rtk_uint32* pNot)
{
if(index > RTL8367C_ACLRULEMAX)
return RT_ERR_OUT_OF_RANGE;

if(index < 64)
return rtl8367c_getAsicRegBit(RTL8367C_ACL_ACTION_CTRL_REG(index), RTL8367C_ACL_OP_NOT_OFFSET(index), pNot);
else
return rtl8367c_getAsicRegBit(RTL8367C_ACL_ACTION_CTRL2_REG(index), RTL8367C_ACL_OP_NOT_OFFSET(index), pNot);

}

The above function is used to read the ACL Not bit from Acl Action Control and Acl Action Control Bit2 and 0xFFFF is returned if the function index is over 63.

ret_t rtl8367c_getAs




NEXT




<s> void item_reset(void)
{
struct dialog_list *p, *next;

for (p = item_head; p; p = next) {
next = p->next;
free(p);
}
item_head = NULL;
item_cur = &item_nil;
}

The above function is used to free the item which is used by the dialog list. First it stores the next pointer of the pointer 'p' in 'next' variable and then frees the item 'p'. The next pointer is again set to 'p' in the '




NEXT




<s> int read_phy(u32 port, u32 page, u32 reg, u32 *val)
{
switch (soc_info.family) {
case RTL8380_FAMILY_ID:
return rtl838x_read_phy(port, page, reg, val);
case RTL8390_FAMILY_ID:
return rtl839x_read_phy(port, page, reg, val);
case RTL9300_FAMILY_ID:
return rtl930x_read_phy(port, page, reg, val);
case RTL9310_FAMILY_ID:
return rtl931x_read_phy(port, page, reg, val);
}

return -1;
}

The above function is used to read RTL registers on the platform
driver side. Can anybody please tell me about the details of function
in details that are, what is soc_inf, where it is getting populated? and
what this soc_info.family represent




NEXT




<s> static void rtl83xx_port_disable(struct dsa_switch *ds, int port)
{
struct rtl838x_switch_priv *priv = ds->priv;
u64 v;

pr_debug("%s %x: %d", __func__, (u32)priv, port);
/* you can only disable user ports */
if (!dsa_is_user_port(ds, port))
return;

/* BUG: This does not work on RTL931X */
/* remove port from switch mask of CPU_PORT */
priv->r->traffic_disable(priv->cpu_port, port);

/* remove all other ports in the same bridge from switch mask of port */
v = priv->r->traffic_get(port);
v &= ~priv->ports[port].pm;
priv->r->traffic_set(port, v);

priv->ports[port].enable = false;
}

The above function is used to disable a port on the RTL8380 (and all
its revisions) switch chip. It is only safe to call on a user port
(ie, a port that has not already had its pmd registered) and




NEXT




<s> static inline int rtl930x_mac_link_spd_sts(int p)
{
return RTL930X_MAC_LINK_SPD_STS(p);
}

The above function is used to get value of LINK_SPD_STS register.

RTL930X_MAC_LINK_SPD_STS = 0x0;

This register is bitmapped as bellow.





NEXT




<s> static void print_error()
{
fprintf(stderr, "%s", strerror(errno));
exit(1);
}

The above function is used to do error handling for Linux.  This function
prints the error code, then exits the program.

However, on Solaris, this function results in errno and $! being undefined</s>




NEXT




<s> int init_dialog(const char *backtitle)
{
int height, width;

initscr();		/* Init curses */

/* Get current cursor position for signal handler in mconf.c */
getyx(stdscr, saved_y, saved_x);

getmaxyx(stdscr, height, width);
if (height < WINDOW_HEIGTH_MIN || width < WINDOW_WIDTH_MIN) {
endwin();
return -ERRDISPLAYTOOSMALL;
}

dlg.backtitle = backtitle;
color_setup(getenv("MENUCONFIG_COLOR"));

keypad(stdscr, TRUE);
cbreak();
noecho();
dialog_clear();

return 0;
}

The above function is used to initialize the dialog window to the values
specified by the environment variables (or, if none are present,
the default values).

The values are the following:

color  - color scheme for the dialog window. Supported colors




NEXT




<s> static int ar934x_nfc_remove(struct platform_device *pdev)
{
struct ar934x_nfc *nfc;

nfc = platform_get_drvdata(pdev);
if (nfc) {
mtd_device_unregister(nand_to_mtd(&nfc->nand_chip));
nand_cleanup(&nfc->nand_chip);
ar934x_nfc_free_buf(nfc);
}

return 0;
}

The above function is used to unregister nand device and free its
resources when ar934x_nfc device is removed. But it will lead to memory
leak after unregistering nfc, because ar934x_nfc_free




NEXT




<s> static int rb4xx_gpio_remove(struct platform_device *pdev)
{
struct rb4xx_gpio *gpio = platform_get_drvdata(pdev);

gpiochip_remove(&gpio->chip);
mutex_destroy(&gpio->lock);

return 0;
}

The above function is used to remove the gpio module from the board.

static int rb4xx_gpio_probe(struct platform_device *pdev)
{
struct rb4xx_gpio *gpio = devm_kzalloc(&pdev->dev




NEXT




<s> ret_t rtl8367c_setAsicLedSerialModeConfig(rtk_uint32 active, rtk_uint32 serimode)
{
ret_t retVal;

/* Invalid input parameter */
if( active >= LEDSERACT_MAX)
return RT_ERR_INPUT;
if( serimode >= LEDSER_MAX)
return RT_ERR_INPUT;

/* Set Active High or Low */
if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_SERI_LED_ACT_LOW_OFFSET, active)) !=  RT_ERR_OK)
return retVal;

/*set to 8G mode (not 16G mode)*/
if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_MODE, RTL8367C_DLINK_TIME_OFFSET, serimode))!=  RT_ERR_OK)
return retVal;


return RT_ERR_OK;
}

The above function is used to set the Serial LED Mode configuration. The active parameter sets the active polarity for the LEDs and the serimode parameter is set to the type of mode that the serial LED uses.

The active parameter can have a valid value within 




NEXT




<s> static int block_load_image_raw(block_dev_desc_t * device, lbaint_t sector)
{
int n;
u32 image_size_sectors;
struct image_header *header;

header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
sizeof(struct image_header));

/* read image header to find the image size & load address */
n = device->block_read(device->dev, sector, 1, header);

if (n != 1) {
printf("spl: blk read err\n");
return 1;
}

spl_parse_image_header(header);

/* convert size to sectors - round up */
image_size_sectors = (spl_image.size + 512 - 1) / 512;
n = device->block_read(device->dev, sector, image_size_sectors,
(void *)spl_image.load_addr);

if (n != image_size_sectors) {
printf("spl: blk read err\n");
return 1;
}
return 0;
}

The above function is used to load U-Boot image from raw data into memory. The function first reads the image header info like image size and load address. Then it will read image data by sector into image. The block device in U-Boot is usually NAND flash.




NEXT




<s> ret_t rtl8367c_getAsicPriorityPortBased(rtk_uint32 port, rtk_uint32 *pPriority )
{
ret_t retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_QOS_PORTBASED_PRIORITY_REG(port), RTL8367C_QOS_PORTBASED_PRIORITY_MASK(port), pPriority);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_QOS_PORTBASED_PRIORITY_CTRL2, 0x7 << ((port - 8) << 2), pPriority);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to get the priority for the port in priority queue with priority port base mode.
The input is the port and output is priorty.

In a prioritized switched environment, the port priority is normally a configurable value, which provides




NEXT




<s> static void handle_f3(int *key, struct menu *current_item);
static void handle_f4(int *key, struct menu *current_item);
static void handle_f5(int *key, struct menu *current_item);
static void handle_f6(int *key, struct menu *current_item);
static void handle_f7(int *key, struct menu *current_item);
static void handle_f8(int *key, struct menu *current_item);
static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to handle various F keys available on the keypad or laptop keyboards.
The handling of various F keys is based on the key value returned which are listed below.

The handler corresponding to these F key value will be called when these keys




NEXT




<s> static int rtl8367_extif_init(struct rtl8366_smi *smi, int id,
struct rtl8367_extif_config *cfg)
{
enum rtl8367_extif_mode mode;
int err;

mode = (cfg) ? cfg->mode : RTL8367_EXTIF_MODE_DISABLED;

err = rtl8367_extif_set_mode(smi, id, mode);
if (err)
return err;

if (mode != RTL8367_EXTIF_MODE_DISABLED) {
err = rtl8367_extif_set_force(smi, id, &cfg->ability);
if (err)
return err;

err = rtl8367_extif_set_rgmii_delay(smi, id, cfg->txdelay,
cfg->rxdelay);
if (err)
return err;
}

return 0;
}

The above function is used to intialize the extifier before its use. I see
there is no reference to the above function from other sections of the
codebase(apart from some other driver code, not sure how it's used).

Also please




NEXT




<s> inline void rtl_table_data_w(struct table_reg *r, u32 v, int i)
{
sw_w32(v, rtl_table_data(r, i));
}

The above function is used to write the field v to the register rtl_table_data(r,i).

The below are some comments that are generated by
python_gen_func_cgen.py

/* table register type, table_reg




NEXT




<s> static void mt7620_set_mac(struct fe_priv *priv, unsigned char *mac)
{
struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
unsigned long flags;

spin_lock_irqsave(&priv->page_lock, flags);
mtk_switch_w32(gsw, (mac[0] << 8) | mac[1], GSW_REG_SMACCR1);
mtk_switch_w32(gsw, (mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
GSW_REG_SMACCR0);
spin_unlock_irqrestore(&priv->page_lock, flags);
}

The above function is used to set the MAC Address to use in TX packets. But I noticed that the code is in an unprotected branch, and the pointer to the MAC address used in the TX packets can be re-initialized with mtk_switch_w32(




NEXT




<s> inline u16 rtl_table_data(struct table_reg *r, int i)
{
if (i >= r->max_data)
i = r->max_data - 1;
return r->data + i * 4;
}

The above function is used to get the pointer to an entry in a lookup_table table. lookup_table_index() uses it to calculate the byte to load (e.g. a 0, 1 or 2 to load from the data pointer with different masks




NEXT




<s> uint32_t compute_crc32(uint32_t crc, off_t start, size_t compute_len, int fd)
{
uint8_t readbuf[1024];
ssize_t res;
off_t offset = start;

/* Read a buffer's worth of bytes  */
while (fd && (compute_len >= sizeof(readbuf))) {
res = pread(fd, readbuf, sizeof(readbuf), offset);
crc = crc32(crc, readbuf, res);
compute_len = compute_len - res;
offset += res;
}

/* Less than buffer-size bytes remains, read compute_len bytes */
if (fd && (compute_len > 0)) {
res = pread(fd, readbuf, compute_len, offset);
crc = crc32(crc, readbuf, res);
}

return crc;
}

The above function is used to compute the CRC32 hash of a number of files and then save
it to a specified file. I do the same with an MD5 hash in a second function. I believe
these functions work correctly - I verified my results with 




NEXT




<s> static int rtl838x_serdes_probe(struct phy_device *phydev)
{
int addr = phydev->mdio.addr;

if (soc_info.family != RTL8380_FAMILY_ID)
return -ENODEV;
if (addr < 24)
return -ENODEV;

/* On the RTL8380M, PHYs 24-27 connect to the internal SerDes */
if (soc_info.id == 0x8380) {
if (addr == 24)
return rtl8380_configure_serdes(phydev);
return 0;
}

return -ENODEV;
}

The above function is used to probe the internal SerDes for RTL8380M
phy. To configure the SerDes, it calls rtl8380_configure_serdes, and
returns after success.</s>




NEXT




<s> int BN_lshift(BIGNUM *r, const BIGNUM *a, int n)
{
int i,nw,lb,rb;
BN_ULONG *t,*f;
BN_ULONG l;

r->neg=a->neg;
if (bn_wexpand(r,a->top+(n/BN_BITS2)+1) == NULL) return(0);
nw=n/BN_BITS2;
lb=n%BN_BITS2;
rb=BN_BITS2-lb;
f=a->d;
t=r->d;
t[a->top+nw]=0;
if (lb == 0)
for (i=a->top-1; i>=0; i--)
t[nw+i]=f[i];
else
for (i=a->top-1; i>=0; i--)
{
l=f[i];
t[nw+i+1]|=(l>>rb)&BN_MASK2;
t[nw+i]=(l<<lb)&BN_MASK2;
}
memset(t,0,nw*sizeof(t[0]));
/*      for (i=0; i<nw; i++)
t[i]=0;*/
r->top=a->top+nw+1;
bn_fix_top(r);
return(1);
}

The above function is used to shift the bits by n/8 bits to the left.
```</s>




NEXT




<s> ret_t rtl8367c_setAsicTrunkingHashSelect(rtk_uint32 hashsel)
{
return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_HASH_MASK, hashsel);
}

The above function is used to change the hash select bit in the switch CPU to switch the hash method from internal hash method to external hash method.

We tested in the testbench. The testbench will first change this bit to 0 (internal hash method) and then




NEXT




<s> srg_led_remove(struct i2c_client *client)
{
struct srg_led_ctrl *sysled_ctrl = i2c_get_clientdata(client);

srg_led_disable(client);
mutex_destroy(&sysled_ctrl->lock);

#if LINUX_VERSION_CODE < KERNEL_VERSION(5,16,0)
return 0;
#endif
}

The above function is used to remove sysfs node that is used to control the LED. The following function is called to create that sysfs entry:

static void srg_led_create_attr_sysfs(struct srg_led_ctrl *sysled




NEXT




<s> static void rtl8366_smi_mii_cleanup(struct rtl8366_smi *smi)
{
mdiobus_unregister(smi->mii_bus);
mdiobus_free(smi->mii_bus);
}

The above function is used to remove MDI-OBus bus when unloading the rtl8366_smi driver.

static int
rtl8366_smi_mii_init(struct rtl8366_




NEXT




<s> static void ag71xx_restart_work_func(struct work_struct *work)
{
struct ag71xx *ag = container_of(work, struct ag71xx, restart_work.work);

rtnl_lock();
ag71xx_hw_disable(ag);
ag71xx_hw_enable(ag);
if (ag->link)
__ag71xx_link_adjust(ag, false);
rtnl_unlock();
}

The above function is used to do a hard reset of the ag71xx driver, so that it is
always in the same state, but also to restart it.</s>




NEXT




<s> static void rtl839x_setup_port_macs(struct rtl838x_switch_priv *priv)
{
struct net_device *dev;
u64 mac;

pr_debug("%s: got port %08x\n", __func__, (u32)priv->ports[priv->cpu_port].dp);
dev = priv->ports[priv->cpu_port].dp->slave;
mac = ether_addr_to_u64(dev->dev_addr);

for (int i = 0; i < 15; i++) {
mac++;  /* BUG: VRRP for testing */
sw_w32(mac >> 32, RTL839X_ROUTING_SA_CTRL + i * 8);
sw_w32(mac, RTL839X_ROUTING_SA_CTRL + i * 8 + 4);
}
}

The above function is used to register the MAC address of all the ports of the board. To test, the below function is used to get a MAC address for the VRRP daemon.

vrrp_test_get_interface_mac(int ifindex




NEXT




<s> ret_t rtl8367c_setAsicStormFilterUnknownMulticastEnable(rtk_uint32 port, rtk_uint32 enabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_STORM_UNKNOWN_MCAST_REG, port, enabled);
}

The above function is used to set AsicStormFilterUnknownMulticastEnable register

static rt_err_t rtl8367c_getAsicStormFilterUnknownMulticastEnable(rtk_uint32* port, r




NEXT




<s> static struct mtd_info *ar934x_nfc_to_mtd(struct ar934x_nfc *nfc)
{
return nand_to_mtd(&nfc->nand_chip);
}

The above function is used to obtain a generic MTD structure.

The nand_to_mtd function performs some housekeeping to make sure
there are no bad addresses or bad sizes. It then returns a struct
mtd_info which contains useful information about




NEXT




<s> static void ar934x_nfc_write_buf(struct nand_chip *chip, const u8 *buf, int len)
{
struct ar934x_nfc *nfc = chip->priv;
int i;

WARN_ON(nfc->buf_index + len > nfc->buf_size);

if (nfc->swap_dma) {
for (i = 0; i < len; i++) {
nfc->buf[nfc->buf_index ^ 3] = buf[i];
nfc->buf_index++;
}
} else {
for (i = 0; i < len; i++) {
nfc->buf[nfc->buf_index] = buf[i];
nfc->buf_index++;
}
}
}

The above function is used to write data to the shared buffer that the DMA controller uses to feed data to the R1000, the NAND flash controller. This buffer is 256 bytes long and it's location depends on the architecture and kernel.





NEXT




<s> static const char * pbc_status_enum_str(enum pbc_status status)
{
switch (status) {
case WPS_PBC_STATUS_DISABLE:
return "Disabled";
case WPS_PBC_STATUS_ACTIVE:
return "Active";
case WPS_PBC_STATUS_TIMEOUT:
return "Timed-out";
case WPS_PBC_STATUS_OVERLAP:
return "Overlap";
default:
return "Unknown";
}
}

The above function is used to associate a string, representing the status of a PBC, with an enumerated value indicating the status of a PBC

/* Get a PBC description with the given index */
static int pbc_get_status(int pbc




NEXT




<s> static int rtl8366s_sw_get_green(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;
int err;

err = rtl8366_smi_read_reg(smi, RTL8366S_GREEN_ETHERNET_CTRL_REG, &data);
if (err)
return err;

val->value.i = ((data & (RTL8366S_GREEN_ETHERNET_TX_BIT | RTL8366S_GREEN_ETHERNET_RX_BIT)) != 0) ? 1 : 0;

return 0;
}

The above function is used to determine the status of the feature which is implemented in Firmware. The above firmware shows that the above implemented feature is using the bit level access. This is the reason that we are not able to access the above implemented feature through the user interface




NEXT




<s> static int aes_generic_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
unsigned int keylen)
{
return aes_setkey(tfm, key, keylen);
}

The above function is used to set key into the kernel’s AES module via kernel interface. However, it is not allowed to use the above function as its keylen parameter is not flexible enough: it only accepts a fixed keylen value (16, 24




NEXT




<s> void plat_time_init_fallback(void)
{
struct device_node *np;
u32 freq = 500000000;

np = of_find_node_by_name(NULL, "cpus");
if (!np) {
pr_err("Missing 'cpus' DT node, using default frequency.");
} else {
if (of_property_read_u32(np, "frequency", &freq) < 0)
pr_err("No 'frequency' property in DT, using default.");
else
pr_info("CPU frequency from device tree: %dMHz", freq / 1000000);
of_node_put(np);
}
mips_hpt_frequency = freq / 2;
}

The above function is used to find the CPU frequency from Device Tree. It
uses of_find_node_by_name() to find the child node named cpus of the top
node, i.e., /. The second argument to of_find_node




NEXT




<s> static int msdc_debug_show(struct inode *inode, struct file *file)
{
return single_open(file, msdc_debug_proc_read, NULL);
}

The above function is used to open a file in the ProcFS. We will
now implement the file read function.

static ssize_t msdc_debug_proc_read(struct file *file, char __user *userbuf,
	




NEXT




<s> void hostapd_ubus_add_bss(struct hostapd_data *hapd)
{
struct ubus_object *obj = &hapd->ubus.obj;
char *name;
int ret;

#ifdef CONFIG_MESH
if (hapd->conf->mesh & MESH_ENABLED)
return;
#endif

if (!hostapd_ubus_init())
return;

if (asprintf(&name, "hostapd.%s", hapd->conf->iface) < 0)
return;

avl_init(&hapd->ubus.banned, avl_compare_macaddr, false, NULL);
obj->name = name;
obj->type = &bss_object_type;
obj->methods = bss_object_type.methods;
obj->n_methods = bss_object_type.n_methods;
ret = ubus_add_object(ctx, obj);
hostapd_ubus_ref_inc();
}

The above function is used to initialize the uBus object when a new interface is added. As we can see it is using name and type (bss_object_type) for a variable object. It also tries to add a banned list of MAC addresses in a new variable for




NEXT




<s> ar8xxx_phy_read(struct mii_bus *bus, int phy_addr, int reg_addr)
{
struct ar8xxx_priv *priv = bus->priv;
return priv->chip->phy_read(priv, phy_addr, reg_addr);
}

The above function is used to read register's value and the priv is the
structure variable of 8371 chip, the code of the function is below
[root@localhost chip]# cat ar8xxx-chip-8371.c





NEXT




<s> static void uencrypt_clear_free(void *ptr, size_t len)
{
if (ptr) {
memset(ptr, 0, len);
free(ptr);
}
}

The above function is used to free a pointer containing some memory which is
encrypted by USM. This function takes in two parameters (The pointer, and the
size of the memory to be freed). This function just uses memset to first set all
bytes of the




NEXT




<s> void rtk_hal_qos_get_port2table(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;
rtk_qos_priDecTbl_t Index;

ret = rtk_qos_portPriSelIndex_get(data->port, &Index);
if (ret != 0)
printk("rtk_qos_portPriSelIndex_set failed\n");
else
printk("port%d belongs to table%d\n", data->port, Index);
}

The above function is used to get the priority decoding table of an input port.

void rtk_hal_qos_set_port2table(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t




NEXT




<s> static void print_quoted_string(FILE *out, const char *str)
{
const char *p;
int len;

putc('"', out);
while ((p = strchr(str, '"'))) {
len = p - str;
if (len)
fprintf(out, "%.*s", len, str);
fputs("\\\"", out);
str = p + 1;
}
fputs(str, out);
putc('"', out);
}

The above function is used to print quoted strings - I need to find out
if it's correct, but that's not the crux of my query.

Now I can use `fputc('"', out) to insert that quote character into the




NEXT




<s> __md5_Decode(uint32_t *output, const unsigned char *input, unsigned int len)
{
unsigned int i, j;

for (i = 0, j = 0; j < len; i++, j += 4)
output[i] = ((uint32_t)input[j]) | (((uint32_t)input[j+1]) << 8) |
(((uint32_t)input[j+2]) << 16) | (((uint32_t)input[j+3]) << 24);
}

The above function is used to convert characters to MD5 code. It will be more convenient to convert text to MD5 code in this way. The following will illustrate how to use this method.</s>




NEXT




<s> static void rtl839x_route_read(int idx, struct rtl83xx_route *rt)
{
u64 v;
/* Read ROUTING table (2) via register RTL8390_TBL_1 */
struct table_reg *r = rtl_table_get(RTL8390_TBL_1, 2);

pr_debug("In %s\n", __func__);
rtl_table_read(r, idx);

/* The table has a size of 2 registers */
v = sw_r32(rtl_table_data(r, 0));
v <<= 32;
v |= sw_r32(rtl_table_data(r, 1));
rt->switch_mac_id = (v >> 12) & 0xf;
rt->nh.gw = v >> 16;

rtl_table_release(r);
}

The above function is used to retrieve rtl.route[idx] content from switch.

In order to make this work, we need to define rtl.route[idx][0] as 0xfffff000 and also need to enable this register in




NEXT




<s> ret_t rtl8367c_setAsic1xPBOpdirConfig(rtk_uint32 port, rtk_uint32 opdir)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_PORT_OPDIR_REG, port, opdir);
}

The above function is used to config the traffic direction of 8367 port. If DOT1X config is in service for a port, the opdir(out port direction) is valid. By default opdir(out port direction) is set as TX with




NEXT




<s> uc_value_t *wpa_ucode_registry_get(uc_value_t *reg, int idx)
{
if (!idx)
return NULL;

return ucv_array_get(reg, idx - 1);
}

The above function is used to retrieve a uc_value_t object for any index for a given uc_value_t object.

uc_value_t *uc_array_get(reg, idx)

For this particular, the compiler is




NEXT




<s> static void write_file(const char *path, size_t len, bool pem, bool cert)
{
mode_t mode = S_IRUSR | S_IWUSR;
const char *buf_start = buf;
int fd = STDERR_FILENO;
ssize_t written;
int err;

if (!pem)
buf_start += sizeof(buf) - len;

if (!len) {
fprintf(stderr, "No data to write\n");
exit(1);
}

if (cert)
mode |= S_IRGRP | S_IROTH;

if (path)
fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);

if (fd < 0) {
fprintf(stderr, "error: I/O error\n");
exit(1);
}

written = write(fd, buf_start, len);
if (written != len) {
fprintf(stderr, "writing key failed with: %s\n", strerror(errno));
exit(1);
}
err = fsync(fd);
if (err < 0) {
fprintf(stderr, "syncing key failed with: %s\n", strerror(errno));
exit(1);
}
if (path)
close(fd);
}

The above function is used to write the private keys to files from a PEM
format buffer to a specific file. This function was used to copy the
private keys to an appropriate place later for signing.

In a case similar to this, but where the signing had




NEXT




<s> rtl_set_ports(struct switch_dev *dev, struct switch_val *val)
{
unsigned int mask = 0;
unsigned int oldmask;
int i;

for(i = 0; i < val->len; i++)
{
struct switch_port *port = &val->value.ports[i];
bool tagged = false;

mask |= (1 << port->id);

if (port->id == dev->cpu_port)
continue;

if ((i == dev->cpu_port) ||
(port->flags & (1 << SWITCH_PORT_FLAG_TAGGED)))
tagged = true;

/* fix up PVIDs for added ports */
if (!tagged)
rtl_set(dev, RTL_PORT_REG(port->id, PVID), val->port_vlan);

rtl_set(dev, RTL_PORT_REG(port->id, NON_PVID_DISCARD), (tagged ? 0 : 1));
rtl_set(dev, RTL_PORT_REG(port->id, VID_INSERT), (tagged ? 0 : 1));
rtl_set(dev, RTL_PORT_REG(port->id, TAG_INSERT), (tagged ? 2 : 1));
}

oldmask = rtl_get(dev, RTL_VLAN_REG(val->port_vlan, PORTMASK));
rtl_set(dev, RTL_VLAN_REG(val->port_vlan, PORTMASK), mask);

/* fix up PVIDs for removed ports, default to last vlan */
oldmask &= ~mask;
for (i = 0; i < RTL8306_NUM_PORTS; i++) {
if (!(oldmask & (1 << i)))
continue;

if (i == dev->cpu_port)
continue;

if (rtl_get(dev, RTL_PORT_REG(i, PVID)) == val->port_vlan)
rtl_set(dev, RTL_PORT_REG(i, PVID), dev->vlans - 1);
}

return 0;
}

The above function is used to define which device ports to set for VLAN configuration. You’ll notice that when configuring the VLAN tag insertion, the CPU port mask is not included in the calculation for PortMask used with the switch VLAN configuration. This is done




NEXT




<s> rtk_api_ret_t rtk_switch_isCPUPort(rtk_port_t logicalPort)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(logicalPort >= RTK_SWITCH_PORT_NUM)
return RT_ERR_FAILED;

if( ((0x01 << logicalPort) & halCtrl->valid_cpu_portmask) != 0)
return RT_ERR_OK;
else
return RT_ERR_FAILED;
}

The above function is used to check a logical port to be a cpu port.</s>




NEXT




<s> ret_t rtl8367c_getAsicVlanAccpetFrameType(rtk_uint32 port, rtl8367c_accframetype *pFrameType)
{
rtk_uint32 regData;
ret_t  retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if((retVal = rtl8367c_getAsicRegBits(RTL8367C_VLAN_ACCEPT_FRAME_TYPE_REG(port), RTL8367C_VLAN_ACCEPT_FRAME_TYPE_MASK(port), &regData)) != RT_ERR_OK)
return retVal;

*pFrameType = (rtl8367c_accframetype)regData;
return RT_ERR_OK;
}

The above function is used to get the VLAN packet's frame type.

In order to use it in C language, we define a structure to store the parameter that the register contains:

typedef enum
{
RTL8367C




NEXT




<s> static int rtl8367_init_regs0(struct rtl8366_smi *smi, unsigned mode)
{
const struct rtl8367_initval *initvals;
int count;
int err;

switch (mode) {
case 0:
initvals = rtl8367_initvals_0_0;
count = ARRAY_SIZE(rtl8367_initvals_0_0);
break;

case 1:
case 2:
initvals = rtl8367_initvals_0_1;
count = ARRAY_SIZE(rtl8367_initvals_0_1);
break;

default:
dev_err(smi->parent, "%s: unknow mode %u\n", __func__, mode);
return -ENODEV;
}

err = rtl8367_write_initvals(smi, initvals, count);
if (err)
return err;

/* TODO: complete this */

return 0;
}

The above function is used to load the configuration of hardware device. However, we can notice that it is the function defined out of the file and included in the source file, because the file was defined with “extern”. It means that this function is also contained in some other




NEXT




<s> adm6996_get_port_link(struct switch_dev *dev, int port,
struct switch_port_link *link)
{
struct adm6996_priv *priv = to_adm(dev);

u16 reg = 0;

if (port >= ADM_NUM_PORTS)
return -EINVAL;

switch (port) {
case 0:
reg = r16(priv, ADM_PS0);
break;
case 1:
reg = r16(priv, ADM_PS0);
reg = reg >> 8;
break;
case 2:
reg = r16(priv, ADM_PS1);
break;
case 3:
reg = r16(priv, ADM_PS1);
reg = reg >> 8;
break;
case 4:
reg = r16(priv, ADM_PS1);
reg = reg >> 12;
break;
case 5:
reg = r16(priv, ADM_PS2);
/* Bits 0, 1, 3 and 4. */
reg = (reg & 3) | ((reg & 24) >> 1);
break;
default:
return -EINVAL;
}

link->link = reg & ADM_PS_LS;
if (!link->link)
return 0;
link->aneg = true;
link->duplex = reg & ADM_PS_DS;
link->tx_flow = reg & ADM_PS_FCS;
link->rx_flow = reg & ADM_PS_FCS;
if (reg & ADM_PS_SS)
link->speed = SWITCH_PORT_SPEED_100;
else
link->speed = SWITCH_PORT_SPEED_10;

return 0;
}

The above function is used to get the link status from the SWITCH_DEV.

static int adm6996_get_stats(struct switch_dev *dev, int port,
struct switch_port_stats *stats)
static int adm




NEXT




<s> ret_t rtl8367c_getAsicIpMulticastPortIsoLeaky(rtk_uint32 port, rtk_uint32 *enabled)
{
ret_t   retVal;
rtk_uint32  regData;

retVal = rtl8367c_getAsicRegBits(RTL8367C_IPMCAST_PORTISO_LEAKY_REG, (0x0001 << port), &regData);
if(retVal != RT_ERR_OK)
return retVal;

*enabled = regData;
return RT_ERR_OK;
}

The above function is used to get the ISOL/LEAKY port’s multicast mode for a given port port.

rtl8367c_writeAsicIpMulticastPortIsoLeaky(rtk_uint32




NEXT




<s> ret_t rtl8367c_setAsicIGMPDropLeaveZero(rtk_uint32 drop)
{
ret_t   retVal;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG1, RTL8367C_DROP_LEAVE_ZERO_OFFSET, drop);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the bit(s) in Asic register RTL8367C_REG_IGMP_MLD_CFG1 under a given mask.
#define RTL8367C_DROP_LEAVE




NEXT




<s> rtk_api_ret_t rtk_switch_isUtpPort(rtk_port_t logicalPort)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(logicalPort >= RTK_SWITCH_PORT_NUM)
return RT_ERR_FAILED;

if(halCtrl->log_port_type[logicalPort] == UTP_PORT)
return RT_ERR_OK;
else
return RT_ERR_FAILED;
}

The above function is used to make it clear what type the specified port is. For example, if we want to know whether the specified port's type is UTP, we can call this function to check. It will return RT_ERR_OK if the port that we




NEXT




<s> void rtl839x_pie_rule_dump(struct  pie_rule *pr)
{
pr_info("Drop: %d, fwd: %d, ovid: %d, ivid: %d, flt: %d, log: %d, rmk: %d, meter: %d tagst: %d, mir: %d, nopri: %d, cpupri: %d, otpid: %d, itpid: %d, shape: %d\n",
pr->drop, pr->fwd_sel, pr->ovid_sel, pr->ivid_sel, pr->flt_sel, pr->log_sel, pr->rmk_sel, pr->log_sel, pr->tagst_sel, pr->mir_sel, pr->nopri_sel,
pr->cpupri_sel, pr->otpid_sel, pr->itpid_sel, pr->shaper_sel);
if (pr->fwd_sel)
pr_info("FWD: %08x\n", pr->fwd_data);
pr_info("TID: %x, %x\n", pr->tid, pr->tid_m);
}

The above function is used to dump a rule from an array that is used for PIE, PIE stands for Port-based Internet Equalizer.

Below mentioned is an example of the structure of such an array in the RTL839x Linux driver




NEXT




<s> static int lq_des_decrypt(struct ablkcipher_request *areq)
{
struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);
struct des_ctx *ctx = crypto_ablkcipher_ctx(cipher);

return lq_queue_mgr(ctx, areq, NULL, CRYPTO_DIR_DECRYPT, 5);
}

The above function is used to schedule deblocking of DES cipher
module in kernel. There’s an additional function that has similar
functionality in kernel in order to schedule encryption of packets in
the network driver stack.

It is not mandatory to use Linux




NEXT




<s> ret_t rtl8367c_setAsicPortMirrorVlanRxLeaky(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_RX_VLAN_LEAKY_OFFSET, enabled);
}

The above function is used to enable (enable = 1) or disable (enable = 0) mirror vlan leakage in the TX stream from the port. The mirrored TX stream is allowed to have vlan tagged in. Otherwise, a frame with a




NEXT




<s> mvswitch_wait_mask(struct phy_device *pdev, int addr, int reg, u16 mask, u16 val)
{
int i = 100;
u16 r;

do {
r = r16(pdev, addr, reg) & mask;
if (r == val)
return 0;
} while(--i > 0);
return -ETIMEDOUT;
}

The above function is used to set the mask of a register (like port status for Ethernet PHY) and wait that the port to set the correct values.

But when phy_reset is called before the actual port speed,  it's not 




NEXT




<s> void mtd_parse_jffs2data(const char *buf, const char *dir)
{
struct jffs2_unknown_node *node = (struct jffs2_unknown_node *) buf;
unsigned int ofs = 0;

while (ofs < erasesize) {
node = (struct jffs2_unknown_node *) (buf + ofs);
if (node->magic != 0x1985)
break;

ofs += PAD(node->totlen);
if (node->nodetype == JFFS2_NODETYPE_DIRENT) {
struct jffs2_raw_dirent *de = (struct jffs2_raw_dirent *) node;

/* is this the right directory name and is it a subdirectory of / */
if (*dir && (de->pino == 1) && !strncmp((char *) de->name, dir, de->nsize))
target_ino = de->ino;

/* store the last inode and version numbers for adding extra files */
if (last_ino < de->ino)
last_ino = de->ino;
if (last_version < de->version)
last_version = de->version;
}
}
}

The above function is used to parse the inodes (one per line) in the JFFS2 image and store their inodes in the "target_ino" and "last_ino" variables.

This function was modified to store the inode number of any directory




NEXT




<s> static int rtl8218b_get_eee(struct phy_device *phydev,
struct ethtool_eee *e)
{
u32 val;
int addr = phydev->mdio.addr;

pr_debug("In %s, port %d, was enabled: %d\n", __func__, addr, e->eee_enabled);

/* Set GPHY page to copper */
phy_write_paged(phydev, RTL821X_PAGE_GPHY, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_COPPER);

val = phy_read_paged(phydev, 7, MDIO_AN_EEE_ADV);
if (e->eee_enabled) {
/* Verify vs MAC-based EEE */
e->eee_enabled = !!(val & BIT(7));
if (!e->eee_enabled) {
val = phy_read_paged(phydev, RTL821X_PAGE_MAC, 25);
e->eee_enabled = !!(val & BIT(4));
}
}
pr_debug("%s: enabled: %d\n", __func__, e->eee_enabled);

/* GPHY page to auto */
phy_write_paged(phydev, RTL821X_PAGE_GPHY, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_AUTO);

return 0;
}

The above function is used to retrieve EEE information. The driver has to fill in information like EEE state or capabilities through ethtool-related function calls for the network interface. So the ethtool-related functions have to call to the above function internally. Since




NEXT




<s> ret_t rtl8367c_setAsicRldpLeaveLoopedPortmask(rtk_uint32 portmask)
{
return rtl8367c_setAsicReg(RTL8367C_REG_RLDP_RELEASED_INDICATOR, portmask);
}

The above function is used to clear any “looped port masks” (portmask) from the Register RTL8367C_REG_RLDP_RELEASED_INDICATOR.
The problem is that in its original configuration, the looped ports




NEXT




<s> static void rttm_stop_timer(void __iomem *base)
{
rttm_disable_timer(base);
rttm_ack_irq(base);
}

The above function is used to stop a timer. The timer is actually stopped and disabled by setting the appropriate bits in the
TIMCTL_REG. However, the hardware does not immediately go into the stop state until there are no ongoing writes to the
RTTM_DATA_




NEXT




<s> swconfig_trig_port_mask_store(struct device *dev, struct device_attribute *attr,
const char *buf, size_t size)
{
struct led_classdev *led_cdev = dev_get_drvdata(dev);
struct swconfig_trig_data *trig_data = led_cdev->trigger_data;
unsigned long port_mask;
int ret;
bool changed;

ret = kstrtoul(buf, 0, &port_mask);
if (ret)
return ret;

write_lock(&trig_data->lock);
changed = (trig_data->port_mask != port_mask);
trig_data->port_mask = port_mask;
write_unlock(&trig_data->lock);

if (changed) {
if (port_mask == 0)
swconfig_trig_set_brightness(trig_data, LED_OFF);

swconfig_trig_update_port_mask(led_cdev->trigger);
}

return size;
}

The above function is used to configure the trigger mask of the ports. If the value of the mask is 0
all of the ports must be on the brightness of 0 in order for the LCD to turn off and
only one port could be turned on at




NEXT




<s> static int nct5104d_gpio_get(struct gpio_chip *chip, unsigned offset);
static int nct5104d_gpio_direction_out(struct gpio_chip *chip,
unsigned offset, int value);
static void nct5104d_gpio_set(struct gpio_chip *chip, unsigned offset, int value);

#define NCT5104D_GPIO_BANK(_base, _ngpio, _regbase)			\
{								\
.chip = {						\
.label            = DRVNAME,			\
.owner            = THIS_MODULE,		\
.direction_input  = nct5104d_gpio_direction_in,	\
.get              = nct5104d_gpio_get,		\
.direction_output = nct5104d_gpio_direction_out,	\
.set              = nct5104d_gpio_set,		\
.base             = _base,			\
.ngpio            = _ngpio,			\
.can_sleep        = true,			\
},							\
.regbase = _regbase,					\
}

The above function is used to handle the GPIO pins on the iMX233.
This function takes the chip as a parameter and also contains the number of
possible GPIO pins.

In our case we are using the NCT5104D




NEXT




<s> ret_t rtl8367c_getAsicEavSysTimeCtrl(rtk_uint32* pControl)
{
ret_t  retVal;
rtk_uint32 regData;
rtk_uint32 mask;

mask = RTL8367C_CFG_TIMER_EN_FRC_MASK | RTL8367C_CFG_TIMER_1588_EN_MASK;

if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PTP_TIME_CFG, &regData)) != RT_ERR_OK)
return retVal;

if( (regData & mask) == mask)
*pControl = PTP_TIME_CTRL_START;
else if( (regData & mask) == 0)
*pControl = PTP_TIME_CTRL_STOP;
else
return RT_ERR_NOT_ALLOWED;

return RT_ERR_OK;
}

The above function is used to check if the rtl8367c is running PTP in time control mode.

This is a function to check if the RTD1296 driver is running PTP in time control mode. Basically it will check




NEXT




<s> static void rt5350_set_mac(struct fe_priv *priv, unsigned char *mac)
{
unsigned long flags;

spin_lock_irqsave(&priv->page_lock, flags);
fe_w32((mac[0] << 8) | mac[1], RT5350_SDM_MAC_ADRH);
fe_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
RT5350_SDM_MAC_ADRL);
spin_unlock_irqrestore(&priv->page_lock, flags);
}

The above function is used to set the MAC address of the Ethernet controller on a router or switch based on the RTL8306(x) hardware.

Note that this code was used to compile the V2.1-10090




NEXT




<s> static int ag71xx_hw_enable(struct ag71xx *ag)
{
int ret;

ret = ag71xx_rings_init(ag);
if (ret)
return ret;

napi_enable(&ag->napi);
ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->tx_ring.descs_dma);
ag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->rx_ring.descs_dma);
netif_start_queue(ag->dev);

return 0;
}

The above function is used to enable the hardware. It starts
napi_enable(&ag->napi);
after the ring initialization.</s>




NEXT




<s> static int ip17xx_set_val(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int myval, err = -EINVAL;

myval = val->value.i;
if (myval <= 0xffff && myval >= 0 && REG_SUPP(state->proc_mii)) {
err = setPhy(state, state->proc_mii, (u16)myval);
}
return err;
}

The above function is used to set the register value (via MMIO).

In the following line,

if (myval <= 0xffff && myval >= 0 && REG_SUPP(state->proc_mii))

I doubt




NEXT




<s> int rtl9300_sds_clock_wait(int timeout)
{
u32 v;
unsigned long start = jiffies;

do {
rtl9300_sds_field_w(2, 0x1f, 0x2, 15, 0, 53);
v = rtl9300_sds_field_r(2, 0x1f, 20, 5, 4);
if (v == 3)
return 0;
} while (jiffies < start + (HZ / 1000) * timeout);

return 1;
}

The above function is used to wait for the clock on rtl9300 to be set to the proper value (v). This function is called on the following path in the RTL9300 driver, which is itself a branch of the main rtl9




NEXT




<s> rtk_api_ret_t rtk_igmp_static_router_port_get(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(pPortmask == NULL)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPStaticRouterPort(&pmask))!=RT_ERR_OK)
return retVal;

if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get IGMP Static Router Port

The following functions can be used to enable/disable unicast and multicast query on IGMP static router port.

rtk_api_ret_t rtk_




NEXT




<s> static u16 upload_bmt(struct bbbt *bbt, int n)
{
u16 block;

retry:
if (n < 0 || bmt_tbl(bbt)[n].mapped == NORMAL_MAPPED) {
pr_info("nand: FATAL ERR: no space to store BMT!\n");
return (u16)-1;
}

block = bmt_tbl(bbt)[n].block;
BBT_LOG("n = 0x%x, block = 0x%x", n, block);
if (bbt_nand_erase(block)) {
bmt_tbl(bbt)[n].block = 0;
/* erase failed, try the previous block: bmt_tbl[n - 1].block */
n--;
goto retry;
}

/* The signature offset is fixed set to 0,
* oob signature offset is fixed set to 1
*/
memcpy(bbt->signature + MAIN_SIGNATURE_OFFSET, "BMT", 3);
bbt->version = BBMT_VERSION;

if (write_bmt(block, (unsigned char *)bbt)) {
bmt_tbl(bbt)[n].block = 0;

/* write failed, try the previous block in bmt_tbl[n - 1] */
n--;
goto retry;
}

/* Return the current index(n) of BMT pool (bmt_tbl[n]) */
return n;
}

The above function is used to insert BMT to NAND and return n.
The n value has the next meaning: if insert failed, it should be 255; otherwize insert success, it's the
block of which the bmt_tbl




NEXT




<s> rtk_api_ret_t rtk_led_enable_get(rtk_led_group_t group, rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (group >= LED_GROUP_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_getAsicLedGroupEnable(group, &pmask)) != RT_ERR_OK)
return retVal;

if((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;

}

The above function is used to retrieve the LED group enable and put it to a port mask variable to retrieve.</s>




NEXT




<s> static int fe_vlan_rx_add_vid(struct net_device *dev,
__be16 proto, u16 vid)
{
struct fe_priv *priv = netdev_priv(dev);
u32 idx = (vid & 0xf);
u32 vlan_cfg;

if (!((fe_reg_table[FE_REG_FE_DMA_VID_BASE]) &&
(dev->features & NETIF_F_HW_VLAN_CTAG_TX)))
return 0;

if (test_bit(idx, &priv->vlan_map)) {
netdev_warn(dev, "disable tx vlan offload\n");
dev->wanted_features &= ~NETIF_F_HW_VLAN_CTAG_TX;
netdev_update_features(dev);
} else {
vlan_cfg = fe_r32(fe_reg_table[FE_REG_FE_DMA_VID_BASE] +
((idx >> 1) << 2));
if (idx & 0x1) {
vlan_cfg &= 0xffff;
vlan_cfg |= (vid << 16);
} else {
vlan_cfg &= 0xffff0000;
vlan_cfg |= vid;
}
fe_w32(vlan_cfg, fe_reg_table[FE_REG_FE_DMA_VID_BASE] +
((idx >> 1) << 2));
set_bit(idx, &priv->vlan_map);
}

return 0;
}

The above function is used to add VID to the mapping. This mapping
allows fe device to know which VID belongs to which VLAN for TX purpose.

This function is located in `vlan_receive.c`

# VXLAN




NEXT




<s> static void rtl930x_eth_set_multicast_list(struct net_device *ndev)
{
/* Flood all classes of RMA addresses (01-80-C2-00-00-{01..2F})
* CTRL_0_FULL = GENMASK(31, 2) = 0xFFFFFFFC
* Lower two bits are reserved, corresponding to RMA 01-80-C2-00-00-00
* CTRL_1_FULL = CTRL_2_FULL = GENMASK(31, 0)
*/
if (ndev->flags & (IFF_ALLMULTI | IFF_PROMISC)) {
sw_w32(GENMASK(31, 2), RTL930X_RMA_CTRL_0);
sw_w32(GENMASK(31, 0), RTL930X_RMA_CTRL_1);
sw_w32(GENMASK(31, 0), RTL930X_RMA_CTRL_2);
} else {
sw_w32(0x0, RTL930X_RMA_CTRL_0);
sw_w32(0x0, RTL930X_RMA_CTRL_1);
sw_w32(0x0, RTL930X_RMA_CTRL_2);
}
}

The above function is used to add a MAC address to the RMA address filter, either using PROMISC mode (all MAC addresses are added) or adding one MAC address specifically. The filter for PROMISC mode is as follows:

Flood all




NEXT




<s> static __inline__ unsigned long get_be32(void *buf)
{
unsigned char *p = buf;

return (((unsigned long) p[0] << 24) +
((unsigned long) p[1] << 16) +
((unsigned long) p[2] << 8) +
(unsigned long) p[3]);
}

The above function is used to convert a 4 bytes long array from little endian to big endian. In this post I am not going to explain how this function works.

Let's try this function.

#include <stdio.h>





NEXT




<s> static long int dram_size (long int *base, long int maxsize)
{
volatile long int *addr, *b = base;
long int cnt, val, save1, save2;

#define STARTVAL (CONFIG_MIN_SDRAM_SIZE / 2)	/* start test at half size */
for (cnt = STARTVAL / sizeof (long); cnt < maxsize / sizeof (long);
cnt <<= 1) {
addr = base + cnt;	/* pointer arith! */

save1 = *addr;	/* save contents of addr */
save2 = *b;	/* save contents of base */

*addr = cnt;	/* write cnt to addr */
*b = 0;		/* put null at base */

/* check at base address */
if ((*b) != 0) {
*addr = save1;	/* restore *addr */
*b = save2;	/* restore *b */
return (0);
}
val = *addr;	/* read *addr */

*addr = save1;
*b = save2;

if (val != cnt) {
/* fix boundary condition.. STARTVAL means zero */
if (cnt == STARTVAL / sizeof (long))
cnt = 0;
return (cnt * sizeof (long));
}
}
return maxsize;
}

The above function is used to determine the size of the DRAM. If you compile the MMU example, you can see the function in operation, with its output like this:

/* DRAM size is 0x8000000 (3




NEXT




<s> static int rtl8366rb_set_mc_index(struct rtl8366_smi *smi, int port, int index)
{
if (port >= RTL8366RB_NUM_PORTS || index >= RTL8366RB_NUM_VLANS)
return -EINVAL;

return rtl8366_smi_rmwr(smi, RTL8366RB_PORT_VLAN_CTRL_REG(port),
RTL8366RB_PORT_VLAN_CTRL_MASK <<
RTL8366RB_PORT_VLAN_CTRL_SHIFT(port),
(index & RTL8366RB_PORT_VLAN_CTRL_MASK) <<
RTL8366RB_PORT_VLAN_CTRL_SHIFT(port));
}

The above function is used to set multicast index/tag.

If i have multiple switch like: S1-RTL8364S, S2-RTL8366RB. If S2-RTL8366RB




NEXT




<s> static void __exit ehci_oxnas_cleanup(void)
{
platform_driver_unregister(&ehci_oxnas_driver);
}

The above function is used to free any resources that may have been allocated to the EHCI
controller, such as driver and platform data. The platform_driver_unregister() function is used to
unregister the platform driver created for the EHCI controller from the system.




NEXT




<s> static inline void u64_add_u32(ppe_u64_t, unsigned int, ppe_u64_t *);

/*
*  buffer manage functions
*/
static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline void atm_free_tx_skb_vcc(struct sk_buff *, struct atm_vcc *);
static inline struct sk_buff *get_skb_rx_pointer(unsigned int);
static inline int get_tx_desc(unsigned int);

/*
*  mailbox handler and signal function
*/
static inline void mailbox_oam_rx_handler(void);
static inline void mailbox_aal_rx_handler(void);
static irqreturn_t mailbox_irq_handler(int, void *);
static inline void mailbox_signal(unsigned int, int);
static void do_ppe_tasklet(unsigned long);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
DECLARE_TASKLET(g_dma_tasklet, do_ppe_tasklet, 0);
#else
DECLARE_TASKLET_OLD(g_dma_tasklet, do_ppe_tasklet);
#endif

/*
*  QSB & HTU setting functions
*/
static void set_qsb(struct atm_vcc *, struct atm_qos *, unsigned int);
static void qsb_global_set(void);
static inline void set_htu_entry(unsigned int, unsigned int, unsigned int, int, int);
static inline void clear_htu_entry(unsigned int);
static void validate_oam_htu_entry(void);
static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to send OAM cell into network. This function
is implemented as part of OAM application.
#endif

/*
*  Scheduler related functions
*/
static inline int is_oam_enabled(void);
static inline




NEXT




<s> swlib_priv_free(void)
{
if (family)
nl_object_put((struct nl_object*)family);
if (cache)
nl_cache_free(cache);
if (handle)
nl_socket_free(handle);
family = NULL;
handle = NULL;
cache = NULL;
}

The above function is used to free resources that were allocated by
nl_socket_connect(). The three parameters family, handle, and cache
should be the same values that are received by nl_socket_connect(), in
that order.</s>




NEXT




<s> void	LED_set(unsigned int led)
{
AT91PS_PIO	PIOB	= AT91C_BASE_PIOB;
PIOB->PIO_SODR		= (led ^ 0x7) & 0x7;		// All 0's => Set PIO high => OFF
PIOB->PIO_CODR		=  led & 0x7;			// All 1's => Set PIO low   => ON
}

The above function is used to set the LEDs on or off.
Now there is a problem here. The above function is called periodically by the main loop of the program, 5 times a second. Since the function takes 0.25ms to execute (




NEXT




<s> ar8316_hw_init(struct ar8xxx_priv *priv)
{
u32 val, newval;

val = ar8xxx_read(priv, AR8316_REG_POSTRIP);

if (priv->phy->interface == PHY_INTERFACE_MODE_RGMII) {
if (priv->port4_phy) {
/* value taken from Ubiquiti RouterStation Pro */
newval = 0x81461bea;
pr_info("ar8316: Using port 4 as PHY\n");
} else {
newval = 0x01261be2;
pr_info("ar8316: Using port 4 as switch port\n");
}
} else if (priv->phy->interface == PHY_INTERFACE_MODE_GMII) {
/* value taken from AVM Fritz!Box 7390 sources */
newval = 0x010e5b71;
} else {
/* no known value for phy interface */
pr_err("ar8316: unsupported mii mode: %d.\n",
priv->phy->interface);
return -EINVAL;
}

if (val == newval)
goto out;

ar8xxx_write(priv, AR8316_REG_POSTRIP, newval);

if (priv->port4_phy &&
priv->phy->interface == PHY_INTERFACE_MODE_RGMII) {
/* work around for phy4 rgmii mode */
ar8xxx_phy_dbg_write(priv, 4, 0x12, 0x480c);
/* rx delay */
ar8xxx_phy_dbg_write(priv, 4, 0x0, 0x824e);
/* tx delay */
ar8xxx_phy_dbg_write(priv, 4, 0x5, 0x3d47);
msleep(1000);
}

ar8xxx_phy_init(priv);

out:
priv->initialized = true;
return 0;
}

The above function is used to initialize hardware in the ar8316_hw.c file in the kernel. If the function fails to
initialize hardware then a message is printed to the console, but nothing is returned.

The code checks for the interface to be




NEXT




<s> void rtl9310_sds_field_w(int sds, u32 page, u32 reg, int end_bit, int start_bit, u32 v)
{
int l = end_bit - start_bit + 1;
u32 data = v;

if (l < 32) {
u32 mask = BIT(l) - 1;

data = rtl930x_read_sds_phy(sds, page, reg);
data &= ~(mask << start_bit);
data |= (v & mask) << start_bit;
}

rtl931x_write_sds_phy(sds, page, reg, data);
}

The above function is used to write/update the content of an SDS register. It is called from various functions.

The problem lies here:
If "start_bit" is equal to "end_bit", the field covers the whole width of the SDS




NEXT




<s> static void sym_set_all_changed(void)
{
struct symbol *sym;
int i;

for_all_symbols(i, sym)
sym_set_changed(sym);
}

The above function is used to make sure that the current symbol has had its
value updated before the next instruction runs.

For example, consider the following code:

x <- 3
y <- x + 1

After executing the first




NEXT




<s> static int mtdsplit_parse_seama(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct seama_header hdr;
size_t hdr_len, retlen, kernel_ent_size;
size_t rootfs_offset;
struct mtd_partition *parts;
enum mtdsplit_part_type type;
int err;

hdr_len = sizeof(hdr);
err = mtd_read(master, 0, hdr_len, &retlen, (void *) &hdr);
if (err)
return err;

if (retlen != hdr_len)
return -EIO;

/* sanity checks */
if (be32_to_cpu(hdr.magic) != SEAMA_MAGIC)
return -EINVAL;

kernel_ent_size = hdr_len + be32_to_cpu(hdr.size) +
be16_to_cpu(hdr.metasize);
if (kernel_ent_size > master->size)
return -EINVAL;

/* Check for the rootfs right after Seama entity with a kernel. */
err = mtd_check_rootfs_magic(master, kernel_ent_size, &type);
if (!err) {
rootfs_offset = kernel_ent_size;
} else {
/*
* On some devices firmware entity might contain both: kernel
* and rootfs. We can't determine kernel size so we just have to
* look for rootfs magic.
* Start the search from an arbitrary offset.
*/
err = mtd_find_rootfs_from(master, SEAMA_MIN_ROOTFS_OFFS,
master->size, &rootfs_offset, &type);
if (err)
return err;
}

parts = kzalloc(SEAMA_NR_PARTS * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = sizeof hdr + be16_to_cpu(hdr.metasize);
parts[0].size = rootfs_offset - parts[0].offset;

if (type == MTDSPLIT_PART_TYPE_UBI)
parts[1].name = UBI_PART_NAME;
else
parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = master->size - rootfs_offset;

*pparts = parts;
return SEAMA_NR_PARTS;
}

The above function is used to parse the Split partition from MTD. Here following function are used:

The purpose of check_rootfs_magic is to check the Magic number which is required to check the rootfs is present.

The function find_




NEXT




<s> void __init rtl83xx_setup_qos(struct rtl838x_switch_priv *priv)
{
switch_priv = priv;

pr_info("In %s\n", __func__);

if (priv->family_id == RTL8380_FAMILY_ID)
return rtl838x_config_qos();
else if (priv->family_id == RTL8390_FAMILY_ID)
return rtl839x_config_qos();

if (priv->family_id == RTL8380_FAMILY_ID)
rtl838x_rate_control_init(priv);
else if (priv->family_id == RTL8390_FAMILY_ID)
rtl839x_rate_control_init(priv);
}

The above function is used to setup Quality of the Service , in rtl838x and rtl839x family. It is used to get rate controlling. It is used as follows:-

if (priv->family_id == RTL83




NEXT




<s> DSL_DEV_MeiError_t DSL_BSP_FWDownload (DSL_DEV_Device_t *, const char *, unsigned long, long *, long *);
DSL_DEV_MeiError_t DSL_BSP_Showtime (DSL_DEV_Device_t *, DSL_uint32_t, DSL_uint32_t);
DSL_DEV_MeiError_t DSL_BSP_AdslLedInit (DSL_DEV_Device_t *, DSL_DEV_LedId_t, DSL_DEV_LedType_t, DSL_DEV_LedHandler_t);
//DSL_DEV_MeiError_t DSL_BSP_AdslLedSet (DSL_DEV_Device_t *, DSL_DEV_LedId_t, DSL_DEV_LedMode_t);
DSL_DEV_MeiError_t DSL_BSP_MemoryDebugAccess (DSL_DEV_Device_t *, DSL_BSP_MemoryAccessType_t, DSL_uint32_t, DSL_uint32_t*, DSL_uint32_t);
DSL_DEV_MeiError_t DSL_BSP_SendCMV (DSL_DEV_Device_t *, u16 *, int, u16 *);

int DSL_BSP_KernelIoctls (DSL_DEV_Device_t *, unsigned int, unsigned long);

static DSL_DEV_MeiError_t IFX_MEI_RunAdslModem (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_CpuModeSet (DSL_DEV_Device_t *, DSL_DEV_CpuMode_t);
static DSL_DEV_MeiError_t IFX_MEI_DownloadBootCode (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_ArcJtagEnable (DSL_DEV_Device_t *, int);
static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to download the bootloader to the ME. The actual download process begins when the function has been called. The function shall be executed only before booting the kernel.
*/
DSL_DEV_MeiError_t IFX_MEI




NEXT




<s> static void conf_rewrite_mod_or_yes(enum conf_def_mode mode)
{
struct symbol *sym;
int i;
tristate old_val = (mode == def_y2m) ? yes : mod;
tristate new_val = (mode == def_y2m) ? mod : yes;

for_all_symbols(i, sym) {
if (sym_get_type(sym) == S_TRISTATE &&
sym->def[S_DEF_USER].tri == old_val)
sym->def[S_DEF_USER].tri = new_val;
}
sym_clear_all_valid();
}

The above function is used to rewrite symbol definitions. It currently
rewrites a "yes" to "mod" and a "mod" to "yes". Note that it could easily
be extended to rewrite mod to yes if another configuration option is
valid,




NEXT




<s> void print_autowrap(WINDOW * win, const char *prompt, int width, int y, int x)
{
int newl, cur_x, cur_y;
int prompt_len, room, wlen;
char tempstr[MAX_LEN + 1], *word, *sp, *sp2, *newline_separator = 0;

strcpy(tempstr, prompt);

prompt_len = strlen(tempstr);

if (prompt_len <= width - x * 2) {	/* If prompt is short */
wmove(win, y, (width - prompt_len) / 2);
waddstr(win, tempstr);
} else {
cur_x = x;
cur_y = y;
newl = 1;
word = tempstr;
while (word && *word) {
sp = strpbrk(word, "\n ");
if (sp && *sp == '\n')
newline_separator = sp;

if (sp)
*sp++ = 0;

/* Wrap to next line if either the word does not fit,
or it is the first word of a new sentence, and it is
short, and the next word does not fit. */
room = width - cur_x;
wlen = strlen(word);
if (wlen > room ||
(newl && wlen < 4 && sp
&& wlen + 1 + strlen(sp) > room
&& (!(sp2 = strpbrk(sp, "\n "))
|| wlen + 1 + (sp2 - sp) > room))) {
cur_y++;
cur_x = x;
}
wmove(win, cur_y, cur_x);
waddstr(win, word);
getyx(win, cur_y, cur_x);

/* Move to the next line if the word separator was a newline */
if (newline_separator) {
cur_y++;
cur_x = x;
newline_separator = 0;
} else
cur_x++;

if (sp && *sp == ' ') {
cur_x++;	/* double space */
while (*++sp == ' ') ;
newl = 1;
} else
newl = 0;
word = sp;
}
}
}

The above function is used to format a prompt like you type them into gnus. It splits a prompt into words, and if any of the words are too big, it will add to the next line.</s>




NEXT




<s> void doit(char *);

int Configindex = -1;
char *Passfile = DEFAULT_PASSWD;

int main(int argc, char **argv)
{
int c;

Progname = *argv;

/* Parse option arguments. */

while ((c = getopt(argc, argv, "n:p:")) != EOF) {
switch (c) {

case 'n':
Configindex = atoi(optarg);
break;

case 'p':
Passfile = optarg;
break;

default:
USAGE();
exit(1);
}
}
argc -= optind;
argv += optind;

if (argc != 1) {
USAGE();
exit(1);
}
doit(argv[0]);

return 0;
}

The above function is used to parse the command line parameters.

This post was a part of series of posts on writing Unix application in
C language. If read the first post of this series then you can skip this
step.</s>




NEXT




<s> ar8xxx_phy_match(u32 phy_id)
{
int i;

for (i = 0; i < ARRAY_SIZE(ar8xxx_phy_ids); i++)
if (phy_id == ar8xxx_phy_ids[i])
return true;

return false;
}

The above function is used to detect how many phy chips does the device have.
The problem is:
I only have a 100mb net connection and 1mbit uplink.
If i disable one of the phy chips, the link




NEXT




<s> alloc_string(yytext, yyleng);
yylval.string = text;
return T_ASSIGN_VAL;
}
YY_BREAK
case 53:
/* rule 53 can match eol */
YY_RULE_SETUP
{ BEGIN(INITIAL); return T_EOL; }
YY_BREAK
case 54:
YY_RULE_SETUP

YY_BREAK

case 55:
YY_RULE_SETUP
append_expanded_string(yytext);
YY_BREAK
case 56:
YY_RULE_SETUP
{

The above function is used to append the current token into a global buffer.  If
we have no limit, then it's simply appended.  Once it's full, we split the
value and append any leftover content from the current token.




NEXT




<s> rtk_api_ret_t rtk_trunk_mode_set(rtk_trunk_mode_t mode)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(mode >= TRUNK_MODE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicTrunkingMode((rtk_uint32)mode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the trunk mode.
The mode should be between TRUNK_MODE_END which is 2.
The function returns RT_ERR_OK if successful.</s>




NEXT




<s> static int rtl83xx_find_l2_cam_entry(struct rtl838x_switch_priv *priv, u64 seed,
bool must_exist, struct rtl838x_l2_entry *e)
{
int idx = -1;
u64 entry;

for (int i = 0; i < 64; i++) {
entry = priv->r->read_cam(i, e);
if (!must_exist && !e->valid) {
if (idx < 0) /* First empty entry? */
idx = i;
break;
} else if ((entry & 0x0fffffffffffffffULL) == seed) {
pr_debug("Found entry in CAM\n");
idx = i;
break;
}
}

return idx;
}

The above function is used to determine if there's
a l2 entry in CAM which matches the given input.

The code inside the for loop isn't actually doing anything,
instead, it's calling a function.
Since that function is




NEXT




<s> static inline void nfc_debug_data(const char *label, void *data, int len) {}

The above function is used to trigger internal debugging log. It is usually
used at the end of every block of functions that process important data.

This function should be used with caution, because in debug compilation only,
this function will make debug data print to the




NEXT




<s> static void sata_oxnas_dev_config(struct ata_device *pdev)
{
struct sata_oxnas_port_priv *pd = pdev->link->ap->private_data;
void __iomem *port_base = pd->port_base;
u32 reg;

DPRINTK("ENTER\n");
/* Set the bits to put the port into 28 or 48-bit node */
reg = ioread32(port_base + DRIVE_CONTROL);
reg &= ~3;
reg |= (pdev->flags & ATA_DFLAG_LBA48) ? DR_CON_48 : DR_CON_28;
iowrite32(reg, port_base + DRIVE_CONTROL);

/* if this is an ATA-6 disk, put port into ATA-5 auto translate mode */
if (pdev->flags & ATA_DFLAG_LBA48) {
reg = ioread32(port_base + PORT_CONTROL);
reg |= 2;
iowrite32(reg, port_base + PORT_CONTROL);
}
}

The above function is used to configure the Oxnas SATA 2.5 port</s>




NEXT




<s> static int rtl8366s_detect(struct rtl8366_smi *smi)
{
u32 chip_id = 0;
u32 chip_ver = 0;
int ret;

ret = rtl8366_smi_read_reg(smi, RTL8366S_CHIP_ID_REG, &chip_id);
if (ret) {
dev_err(smi->parent, "unable to read chip id\n");
return ret;
}

switch (chip_id) {
case RTL8366S_CHIP_ID_8366:
break;
default:
dev_err(smi->parent, "unknown chip id (%04x)\n", chip_id);
return -ENODEV;
}

ret = rtl8366_smi_read_reg(smi, RTL8366S_CHIP_VERSION_CTRL_REG,
&chip_ver);
if (ret) {
dev_err(smi->parent, "unable to read chip version\n");
return ret;
}

dev_info(smi->parent, "RTL%04x ver. %u chip found\n",
chip_id, chip_ver & RTL8366S_CHIP_VERSION_MASK);

return 0;
}

The above function is used to detect the chip id which is used to tell the realteak 8366 card has been identified or not. if yes, the firmware will be loaded automatically, and the device will work properly.

The next step is that




NEXT




<s> static void __init panda_setup_arch(void)
{
if (ppc_md.progress)
ppc_md.progress("panda_setup_arch()", 0);

mpc85xx_smp_init();

fsl_pci_assign_primary();

pr_info("Panda board from OCEDO\n");
}

The above function is used to set it up on the panda board. It currently sets up the smp and the primary PCI, and also puts out an informative message about the board.</s>




NEXT




<s> static void msdc_dma_stop(struct msdc_host *host)
{
void __iomem *base = host->base;
//u32 retries=500;
u32 wints = MSDC_INTEN_XFER_COMPL | MSDC_INTEN_DATTMO | MSDC_INTEN_DATCRCERR;

N_MSG(DMA, "DMA status: 0x%.8x", sdr_read32(MSDC_DMA_CFG));
//while (sdr_read32(MSDC_DMA_CFG) & MSDC_DMA_CFG_STS);

sdr_set_field(MSDC_DMA_CTRL, MSDC_DMA_CTRL_STOP, 1);
while (sdr_read32(MSDC_DMA_CFG) & MSDC_DMA_CFG_STS)
;

//dsb(); /* --- by chhung */
sdr_clr_bits(MSDC_INTEN, wints); /* Not just xfer_comp */

N_MSG(DMA, "DMA stop");
}

The above function is used to stop the transfer of the DMA and then
disable the DMA interrupt to the host.  However, I am unable to locate
the start of the DMA function and hence how to stop it before a
transfer starts.  It seems to me that




NEXT




<s> rtk_api_ret_t rtk_vlan_keep_get(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask)
{
rtk_api_ret_t retVal;
rtk_uint32    pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(egr_port);

if(NULL == pIgr_pmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicVlanEgressKeep(rtk_switch_port_L2P_get(egr_port), &pmask)) != RT_ERR_OK)
return retVal;

if(rtk_switch_portmask_P2L_get(pmask, pIgr_pmask) != RT_ERR_OK)
return RT_ERR_FAILED;

return RT_ERR_OK;
}

The above function is used to read the port mask of the keep-vlan(ingress + egress) of a certain port. But the return value is a portmask of the ingress portmask which has been configured in the VLAN.

Suppose the




NEXT




<s> ret_t rtl8367c_setAsicCputagInsertMode(rtk_uint32 mode)
{
if(mode >= CPUTAG_INSERT_END)
return RT_ERR_NOT_ALLOWED;

return rtl8367c_setAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_INSERTMODE_MASK, mode);
}

The above function is used to configure insert the PCU tag to the packet and insert mode.

The bit field format:

Bit[12] RX_PCU_TAG_INSERT_MODE_0(4bits)

RX_PCU




NEXT




<s> ret_t rtl8367c_setAsicSystemLutLearnOverAct(rtk_uint32 action)
{
if(action >= LRNOVERACT_END)
return RT_ERR_NOT_ALLOWED;

return rtl8367c_setAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_OVER_ACT_MASK, action);
}

The above function is used to set the action of learning rate over activity of learning LUT in the Asic.

As indicated from the function, the register RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL




NEXT




<s> rtk_api_ret_t rtk_led_operation_get(rtk_led_operation_t *pMode)
{
rtk_api_ret_t retVal;
rtk_uint32 regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pMode)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLedOperationMode(&regData)) != RT_ERR_OK)
return retVal;

if (regData == LEDOP_SERIAL)
*pMode = LED_OP_SERIAL;
else if (regData ==LEDOP_PARALLEL)
*pMode = LED_OP_PARALLEL;
else
return RT_ERR_FAILED;

return RT_ERR_OK;
}

The above function is used to get the operation mode of LED (serial or parallel) for 8367C. It is a simple query function with out any modification to the platform operation LED(s).</s>




NEXT




<s> void rtl9300_do_rx_calibration_2_2(int sds_num)
{
/* Force Rx-Run = 0 */
rtl9300_sds_field_w(sds_num, 0x2e, 0x15, 8, 8, 0x0);

rtl930x_sds_rx_rst(sds_num, PHY_INTERFACE_MODE_10GBASER);
}

The above function is used to calibrate Rx chain2 only. If I want to
include Rx2 to rtl9300_do_rx_calibration() function, I suppose I  need to
combine 2_2.c




NEXT




<s> static int rtl93xx_get_mac_eee(struct dsa_switch *ds, int port,
struct ethtool_eee *e)
{
struct rtl838x_switch_priv *priv = ds->priv;

e->supported = SUPPORTED_100baseT_Full |
SUPPORTED_1000baseT_Full |
SUPPORTED_2500baseX_Full;

priv->r->eee_port_ability(priv, e, port);

e->eee_enabled = priv->ports[port].eee_enabled;

e->eee_active = !!(e->advertised & e->lp_advertised);

return 0;
}

The above function is used to query whether the MAC is supported for
enabling the EEE function.
The problem is that e->eee_active is not correct as e->eee_enabled cannot
be trusted.

To workaround the problem, please




NEXT




<s> static void wait_xfered(void)
{
unsigned int val;

do {
val = READREG(UART_BASE + UART_IR_REG);
if (val & (1 << 5))
break;
} while (1);
}

The above function is used to wait for the end of a Rx or Tx operation.

I was not able to understand why the while 1 condition is still used.
What does it do? It causes an infinite loop.

- Is that loop really




NEXT




<s> IFX_MEI_ControlModeSet (DSL_DEV_Device_t * pDev, int mode)
{
u32 temp = 0x0;

IFX_MEI_LongWordReadOffset (pDev, (u32) ME_DBG_MASTER, &temp);
switch (mode) {
case JTAG_MASTER_MODE:
temp &= ~(HOST_MSTR);
break;
case MEI_MASTER_MODE:
temp |= (HOST_MSTR);
break;
default:
IFX_MEI_EMSG ("IFX_MEI_ControlModeSet: unkonwn mode [%d]\n", mode);
return;
}
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_DBG_MASTER, temp);
}

The above function is used to set a single bit in the hardware config (ME_DBG_MASTER register). When I tried calling it from my driver on the host side it works, but on the slave side nothing happens.  I have also tried changing the bit in the




NEXT




<s> rtl8306_config_aneg(struct phy_device *pdev)
{
struct rtl_priv *priv = pdev->priv;

/* Only for WAN */
if (pdev->mdio.addr == 0)
return 0;

/* Restart autonegotiation */
rtl_set(&priv->dev, RTL_PORT_REG(4, NWAY), 1);
rtl_set(&priv->dev, RTL_PORT_REG(4, NRESTART), 1);

return 0;
}

The above function is used to autonegotiation.

As you can see, there is no any function for PHY_is_up(), PHY_reset_aneg(), PHY_start_aneg().
How to let the RTL83




NEXT




<s> u32 spl_boot_device(void)
{
return CONFIG_SPL_BOOT_DEVICE;
}

The above function is used to return the boot device index so that we can use it in a switch-case block.

So I'm wondering if CONFIG_SPL_BOOT_DEVICE needs to be defined anywhere in my linker script so that this function can




NEXT




<s> static int rt3050_fwd_config(struct fe_priv *priv)
{
int ret;

if (ralink_soc != RT305X_SOC_RT3052) {
ret = fe_set_clock_cycle(priv);
if (ret)
return ret;
}

fe_fwd_config(priv);
if (ralink_soc != RT305X_SOC_RT3352)
fe_w32(FE_PSE_FQFC_CFG_INIT, FE_PSE_FQ_CFG);
fe_csum_config(priv);

return 0;
}

The above function is used to set clock to 48Mhz in RT3050 platform</s>




NEXT




<s> ret_t rtl8367c_getAsicLutFlushMode(rtk_uint32* pMode)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL2, RTL8367C_LUT_FLUSH_MODE_MASK, pMode);
}

The above function is used to get the configured MAC-based address field flushing operation mode setting for the LUT-5K-FW. In the following, the description for the MAC-based address field flushing mode bits is given to clarify its functionality.






NEXT




<s> ret_t rtl8367c_getAsicSystemLutLearnOverAct(rtk_uint32 *pAction)
{
if(NULL == pAction)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_OVER_ACT_MASK, pAction);
}

The above function is used to get the value of Asic System Learn Limit Control register's Lut System Learn Over Action value.
It returns RT_ERR_NULL_POINTER if the parameter Action is NULL.
It returns RT_ERR_FAIL if getting




NEXT




<s> static void conf_usage(const char *progname)
{
printf("Usage: %s [options] <kconfig-file>\n", progname);
printf("\n");
printf("Generic options:\n");
printf("  -h, --help              Print this message and exit.\n");
printf("  -s, --silent            Do not print log.\n");
printf("      --fatalrecursive    Treat recursive depenendencies as a fatal error\n");
printf("\n");
printf("Mode options:\n");
printf("  --listnewconfig         List new options\n");
printf("  --helpnewconfig         List new options and help text\n");
printf("  --oldaskconfig          Start a new configuration using a line-oriented program\n");
printf("  --oldconfig             Update a configuration using a provided .config as base\n");
printf("  --syncconfig            Similar to oldconfig but generates configuration in\n"
"                          include/{generated/,config/}\n");
printf("  --olddefconfig          Same as oldconfig but sets new symbols to their default value\n");
printf("  --defconfig <file>      New config with default defined in <file>\n");
printf("  --savedefconfig <file>  Save the minimal current configuration to <file>\n");
printf("  --allnoconfig           New config where all options are answered with no\n");
printf("  --allyesconfig          New config where all options are answered with yes\n");
printf("  --allmodconfig          New config where all options are answered with mod\n");
printf("  --alldefconfig          New config with all symbols set to default\n");
printf("  --randconfig            New config with random answer to all options\n");
printf("  --yes2modconfig         Change answers from yes to mod if possible\n");
printf("  --mod2yesconfig         Change answers from mod to yes if possible\n");
printf("  (If none of the above is given, --oldaskconfig is the default)\n");
}

The above function is used to print out usage if the user requests 'configuration'
usage.

There are actually a couple of modes that must be run in the right order for our
build system to work like we want.

  - oldaskconfig
   




NEXT




<s> void rtl839x_port_eee_set(struct rtl838x_switch_priv *priv, int port, bool enable)
{
u32 v;

/* This works only for Ethernet ports, and on the RTL839X, ports above 47 are SFP */
if (port >= 48)
return;

enable = true;
pr_debug("In %s: setting port %d to %d\n", __func__, port, enable);
v = enable ? 0xf : 0x0;

/* Set EEE for 100, 500, 1000MBit and 10GBit */
sw_w32_mask(0xf << 8, v << 8, rtl839x_mac_force_mode_ctrl(port));

/* Set TX/RX EEE state */
v = enable ? 0x3 : 0x0;
sw_w32(v, RTL839X_EEE_CTRL(port));

priv->ports[port].eee_enabled = enable;
}

The above function is used to set whether the port is in EEE mode.

You noticed we get 16 ports above 48 and I haven’t yet figured out how to make those 16 ports work. The only thing I do know is they




NEXT




<s> static void rtl838x_vlan_set_untagged(u32 vlan, u64 portmask)
{
/* Access UNTAG table (0) via register 1 */
struct table_reg *r = rtl_table_get(RTL8380_TBL_1, 0);

sw_w32(portmask & 0x1fffffff, rtl_table_data(r, 0));
rtl_table_write(r, vlan);
rtl_table_release(r);
}

The above function is used to configure the untagged vlan for a particular port.

The portmask is a 32bit mask where all bits are set which are enabled for vlan tag

ie. The following code snippet will make all bits of




NEXT




<s> uc_hostapd_add_iface(uc_vm_t *vm, size_t nargs)
{
uc_value_t *iface = uc_fn_arg(0);
int ret;

if (ucv_type(iface) != UC_STRING)
return ucv_int64_new(-1);

ret = hostapd_add_iface(interfaces, ucv_string_get(iface));
hostapd_ucode_update_interfaces();

return ucv_int64_new(ret);
}

The above function is used to add a new interface. The iface argument should be an UCL string as name of interface. Note the return code is only 0 on success and -1 otherwise, so an explicit check will have to be performed by the hostapd VM




NEXT




<s> void ifx_deu_des_cfb (void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
ifx_deu_des (ctx, dst, src, iv, nbytes, encdec, 3);
}

The above function is used to read or write from or to a stream using a
3-DES encoding or decoding scheme.  It allows a user to optionally supply
an init vector and the function will check to see if the key is of sufficient
quality in




NEXT




<s> int routerboot_rle_decode(const u8 *in, size_t inlen, u8 *out, size_t *outlen)
{
int ret, run, nbytes;	// use native types for speed
u8 byte;

if (!in || (inlen < 2) || !out)
return -EINVAL;

ret = -ENOSPC;
nbytes = 0;
while (inlen >= 2) {
run = *in++;
inlen--;

/* Verbatim copies */
if (run & 0x80) {
/* Invert run byte sign */
run = ~run & 0xFF;
run++;

if (run > inlen)
goto fail;

inlen -= run;

nbytes += run;
if (nbytes > *outlen)
goto fail;

/* Basic memcpy */
while (run-- > 0)
*out++ = *in++;
}
/* Stream of half-words RLE: <run><byte>. run == 0 is ignored */
else {
byte = *in++;
inlen--;

nbytes += run;
if (nbytes > *outlen)
goto fail;

while (run-- > 0)
*out++ = byte;
}
}

ret = 0;
fail:
*outlen = nbytes;
return ret;
}

The above function is used to uncompress a stream of RLE data, with the ability to do literal runs and multi-byte RLE runs: (run, byte)

For example, if we have a compressed block with a total of 114 bytes




NEXT




<s> adm6996_set_addr(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);

if (val->value.i > 1023)
return -EINVAL;

priv->addr = val->value.i;

return 0;
};

The above function is used to set the address of the switch from user space. Since, there can be 1024 devices on the bus, the value should not be greater than 1023. So, we must ensure that in our driver.</s>




NEXT




<s> static int md5_hmac_setkey(struct crypto_shash *tfm, const u8 *key, unsigned int keylen)
{
struct md5_hmac_ctx *mctx = crypto_shash_ctx(tfm);
int err;
//printk("copying keys to context with length %d\n", keylen);

if (keylen > MAX_HASH_KEYLEN) {
char *hash_alg_name = "md5";

mctx->desc->tfm = crypto_alloc_shash(hash_alg_name, 0, 0);
if (IS_ERR(mctx->desc->tfm)) return PTR_ERR(mctx->desc->tfm);

memset(mctx->key, 0, MAX_HASH_KEYLEN);
err = crypto_shash_digest(mctx->desc, key, keylen, mctx->key);
if (err) return err;

mctx->keylen = MD5_DIGEST_SIZE;

crypto_free_shash(mctx->desc->tfm);
} else {
memcpy(mctx->key, key, keylen);
mctx->keylen = keylen;
}
memset(mctx->key + mctx->keylen, 0, MAX_HASH_KEYLEN - mctx->keylen);

return 0;
}

The above function is used to initialize the hash context of the HMAC. What you do is to simply verify that the code that does the copy is not allowed to copy too much input to the context (which would be a denial of service, of course) and then also




NEXT




<s> static int rtl8226_read_status(struct phy_device *phydev)
{
int ret = 0;
u32 val;

/* TODO: ret = genphy_read_status(phydev);
* 	if (ret < 0) {
* 		pr_info("%s: genphy_read_status failed\n", __func__);
* 		return ret;
* 	}
*/

/* Link status must be read twice */
for (int i = 0; i < 2; i++)
val = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xA402);

phydev->link = val & BIT(2) ? 1 : 0;
if (!phydev->link)
goto out;

/* Read duplex status */
val = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xA434);
if (val < 0)
goto out;
phydev->duplex = !!(val & BIT(3));

/* Read speed */
val = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xA434);
switch (val & 0x0630) {
case 0x0000:
phydev->speed = SPEED_10;
break;
case 0x0010:
phydev->speed = SPEED_100;
break;
case 0x0020:
phydev->speed = SPEED_1000;
break;
case 0x0200:
phydev->speed = SPEED_10000;
break;
case 0x0210:
phydev->speed = SPEED_2500;
break;
case 0x0220:
phydev->speed = SPEED_5000;
break;
default:
break;
}

out:
return ret;
}

The above function is used to read the LED status, but in this function,
it will first read the link status twice to ensure that the obtained link status
is correct, and in the MII section, we have found that there will be a corresponding
bit of data




NEXT




<s> static int msp430_brightness_set(struct led_classdev *led_cdev,
enum led_brightness brightness)
{
struct msp430_led *led =
container_of(led_cdev, struct msp430_led, cdev);
u8 tx[MSP430_CMD_BYTES] = {led->id, 0, 0, 0, 0, 0};
u8 rx[MSP430_CMD_BYTES];
u8 val = (u8) brightness;

switch (val)
{
case LED_OFF:
tx[1] = MSP430_LED_OFF;
break;
case MSP430_LED_BRIGHTNESS_MAX:
tx[1] = MSP430_LED_ON;
break;
default:
tx[1] = MSP430_LED_LEVEL;
tx[2] = val - 1;
break;
}

return msp430_cmd(led->spi, tx, rx);
}

The above function is used to set the brightness for the LED.
The LED_Brightness structure above defines an enumeration of possible
brightness levels. For more information on enumerations, see the Enumerations
section in the chapter "C Language Program




NEXT




<s> static void get_rtc_time(struct rtc_time *rtc_tm)
{
int cr2;

/*
* Read date and time from the RTC. We use read method (3).
*/

spin_lock_irq(&rtc_lock);
i2c_start();
i2c_outb(RTC_I2C_ADDRESS | I2C_READ_MASK);
cr2             = i2c_inb(I2C_ACK);
rtc_tm->tm_sec  = i2c_inb(I2C_ACK);
rtc_tm->tm_min  = i2c_inb(I2C_ACK);
rtc_tm->tm_hour = i2c_inb(I2C_ACK);
rtc_tm->tm_wday = i2c_inb(I2C_ACK);
rtc_tm->tm_mday = i2c_inb(I2C_ACK);
rtc_tm->tm_mon  = i2c_inb(I2C_ACK);
rtc_tm->tm_year = i2c_inb(I2C_NAK);
i2c_stop();
spin_unlock_irq(&rtc_lock);

if (cr2 & RTC_VDET_MASK) {
printk(KERN_WARNING "***RTC BATTERY FAILURE***\n");
}

/* Handle century bit */
if (rtc_tm->tm_mon & RTC_Y2K_MASK) {
rtc_tm->tm_mon &= ~RTC_Y2K_MASK;
rtc_tm->tm_year += 0x100;
}

rtc_tm->tm_sec  = from_bcd(rtc_tm->tm_sec);
rtc_tm->tm_min  = from_bcd(rtc_tm->tm_min);
rtc_tm->tm_hour = from_bcd(rtc_tm->tm_hour);
rtc_tm->tm_mday = from_bcd(rtc_tm->tm_mday);
rtc_tm->tm_mon  = from_bcd(rtc_tm->tm_mon) - 1;
rtc_tm->tm_year = from_bcd(rtc_tm->tm_year);

rtc_tm->tm_isdst = -1; /* DST not known */
}

The above function is used to read out the actual register values of the DS1684 and form a time structure which could be used by all programs for further calculations.</s>




NEXT




<s> static int md5_hmac_final_impl(struct shash_desc *desc, u8 *out, bool hash_final);

/*! \fn static void md5_hmac_transform(struct crypto_tfm *tfm, u32 const *in)
*  \ingroup IFX_MD5_HMAC_FUNCTIONS
*  \brief save input block to context
*  \param tfm linux crypto algo transform
*  \param in 64-byte block of input
*/
static void md5_hmac_transform(struct shash_desc *desc, u32 const *in)
{
struct md5_hmac_ctx *mctx = crypto_shash_ctx(desc->tfm);

if ( ((mctx->dbn<<4)+1) > MD5_HMAC_DBN_TEMP_SIZE )
{
//printk("MD5_HMAC_DBN_TEMP_SIZE exceeded\n");
md5_hmac_final_impl(desc, (u8 *)mctx->hash, false);
}

memcpy(&mctx->temp[mctx->dbn], in, 64); //dbn workaround
mctx->dbn += 1;
}

The above function is used to store input block of the data to the context.

Here, the 64-byte input are stored through the function memcpy().

As per function call the MD5 HMAC context structure is accessed using the
parameter tfm and




NEXT




<s> int BN_ucmp(const BIGNUM *a, const BIGNUM *b)
{
int i;
BN_ULONG t1,t2,*ap,*bp;

bn_check_top(a);
bn_check_top(b);

i=a->top-b->top;
if (i != 0) return(i);
ap=a->d;
bp=b->d;
for (i=a->top-1; i>=0; i--)
{
t1= ap[i];
t2= bp[i];
if (t1 != t2)
return(t1 > t2?1:-1);
}
return(0);
}

The above function is used to compare two BN structs for size.
If the size of 2 BN structs is not equal then it will return 1 else it will zero.

# #include <openssl/bn.h>
void main




NEXT




<s> static void xfer_wr_shadow_to_orbs(int device)
{
*(sata_regs_base[device] + SATA_ORB1_OFF) = wr_sata_orb1[device];
*(sata_regs_base[device] + SATA_ORB2_OFF) = wr_sata_orb2[device];
*(sata_regs_base[device] + SATA_ORB3_OFF) = wr_sata_orb3[device];
*(sata_regs_base[device] + SATA_ORB4_OFF) = wr_sata_orb4[device];
}

The above function is used to program a shadow register's value
into the on-chip Shadow RAM.
If there is already a valid shadow, this is simply a no-op,
other wise it will be written to the ORBs.

The following




NEXT




<s> uc_bpf_map_create(int fd, unsigned int key_size, unsigned int val_size, bool close)
{
struct uc_bpf_map *uc_map;

uc_map = xalloc(sizeof(*uc_map));
uc_map->fd.fd = fd;
uc_map->key_size = key_size;
uc_map->val_size = val_size;
uc_map->fd.close = close;

return uc_resource_new(map_type, uc_map);
}

The above function is used to create a BPF map, with two parameters being used to specify the size of key and value. There is a third parameter which is used to determine if the user-space program should close the resource. Note that this function is defined in uc




NEXT




<s> IFX_MEI_RunArc (DSL_DEV_Device_t * pDev)
{
u32 arc_debug_data = 0x0;

//      Switch arc control from JTAG mode to MEI mode- write '1' to bit0
IFX_MEI_ControlModeSet (pDev, MEI_MASTER_MODE);
_IFX_MEI_DBGLongWordRead (pDev, MEI_DEBUG_DEC_AUX_MASK,
AUX_STATUS, &arc_debug_data);

//      Write debug data reg with content ANDd with 0xFDFFFFFF (halt bit cleared)
arc_debug_data &= ~ARC_AUX_HALT;
_IFX_MEI_DBGLongWordWrite (pDev, MEI_DEBUG_DEC_AUX_MASK,
AUX_STATUS, arc_debug_data);

//      Switch arc control from MEI mode to JTAG mode- write '0' to bit0
IFX_MEI_ControlModeSet (pDev, JTAG_MASTER_MODE);
//      Enable mask for arc codeswap interrupts
IFX_MEI_IRQEnable (pDev);

return DSL_DEV_MEI_ERR_SUCCESS;

}

The above function is used to start the ARC when using Arc+Mei configuration.</s>




NEXT




<s> rtk_api_ret_t rtk_igmp_checksumErrorAction_get(rtk_igmp_checksumErrorAction_t *pAction)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pAction)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPCRCErrOP((rtk_uint32 *)pAction))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the field of rtk_igmp_checksumErrorAction_t.</s>




NEXT




<s> int BN_sub_word(BIGNUM *a, BN_ULONG w)
{
int i;

if (BN_is_zero(a) || a->neg)
{
a->neg=0;
i=BN_add_word(a,w);
a->neg=1;
return(i);
}

w&=BN_MASK2;
if ((a->top == 1) && (a->d[0] < w))
{
a->d[0]=w-a->d[0];
a->neg=1;
return(1);
}
i=0;
for (;;)
{
if (a->d[i] >= w)
{
a->d[i]-=w;
break;
}
else
{
a->d[i]=(a->d[i]-w)&BN_MASK2;
i++;
w=1;
}
}
if ((a->d[i] == 0) && (i == (a->top-1)))
a->top--;
return(1);
}

The above function is used to compute a new top half of the BIGNUM a.
Since a->top remains unchanged, nothing needs to be done in BN_sub_word and the
function only returns 1. In this regard it can be argued that




NEXT




<s> static int rb4xx_nand_dev_ready(struct nand_chip *chip)
{
struct rb4xx_nand *nand = chip->priv;

return gpiod_get_value_cansleep(nand->rdy);
}

The above function is used to check if the Flash is ready or not (see driver/nand/chips/rb4xx-nand.c).

The reason why I’m asking is that if Flash is not ready initially, the flash controller hardware will




NEXT




<s> static int gpio_rb91x_key_probe(struct platform_device *pdev)
{
struct gpio_rb91x_key *drvdata;
struct gpio_chip *gc;
struct device *dev = &pdev->dev;
struct device_node *of_node = dev->of_node;
int r;

drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
if (!drvdata)
return -ENOMEM;

mutex_init(&drvdata->mutex);
mutex_init(&drvdata->poll_mutex);

drvdata->gpio = devm_gpiod_get(dev, NULL, GPIOD_OUT_LOW);
if (IS_ERR(drvdata->gpio)) {
if (PTR_ERR(drvdata->gpio) != -EPROBE_DEFER) {
dev_err(dev, "failed to get gpio: %ld\n",
PTR_ERR(drvdata->gpio));
}
return PTR_ERR(drvdata->gpio);
}

gc = &drvdata->gc;
gc->label = GPIO_RB91X_KEY_DRIVER_NAME;
gc->can_sleep = 1;
gc->base = -1;
gc->ngpio = GPIO_RB91X_KEY_NGPIOS;
gc->get = gpio_rb91x_key_get;
gc->set = gpio_rb91x_key_set;
gc->direction_output = gpio_rb91x_key_direction_output;
gc->direction_input = gpio_rb91x_key_direction_input;
gc->of_node = of_node;

platform_set_drvdata(pdev, drvdata);

r = gpiochip_add(&drvdata->gc);
if (r) {
dev_err(dev, "gpiochip_add() failed: %d\n", r);
return r;
}

return 0;
}

The above function is used to probe the GPIORB91x driver. The first step is to allocate memory for the driver data structure, which will store the gpio chip and other related information. Then, the GPIORB91x driver registers with the platform bus by calling




NEXT




<s> static u32 scr_read(int device, unsigned int sc_reg)
{
/* Setup adr of required register. std regs start eight into async region */
*(sata_regs_base[device] + SATA_LINK_RD_ADDR) = sc_reg
* 4+ SATA_STD_ASYNC_REGS_OFF;

/* Wait for data to be available */
int loops = MAX_SRC_READ_LOOPS;
do {
if (*(sata_regs_base[device] + SATA_LINK_CONTROL) & 1UL) {
break;
}
udelay(10);
} while (--loops);

if (!loops) {
printf("scr_read() Timed out of wait for read completion\n");
}

/* Read the data from the async register */
return *(sata_regs_base[device] + SATA_LINK_DATA);
}

The above function is used to read data from async registers. For example, to read the device ID register we would call:

u32 port = scr_read(device,SC_deviceID);

The sata_ctrl_func.c file handles




NEXT




<s> int __init b53_phy_fixup_register(void)
{
return phy_register_fixup_for_id(PHY_ANY_ID, b53_phy_fixup);
}

The above function is used to register a fixup function for a specific PHY using PHY_ANY_ID which matches any PHY registered with the driver. When this function gets called it will trigger the b53_phy_fixup() function to fixup any




NEXT




<s> static void reset_subtitle(void)
{
struct subtitle_list *pos, *tmp;

for (pos = subtitles; pos != NULL; pos = tmp) {
tmp = pos->next;
free(pos);
}
subtitles = NULL;
set_dialog_subtitles(subtitles);
}

The above function is used to free the subtitles list, which is used for both the dialogue subtitles and the hardsubs generated from it by vqf_display_subtitle().
For dialogues, this is done when all the dialogue is done,




NEXT




<s> ret_t rtl8367c_getAsicEgressFlowControlPortDropGap(rtk_uint32 *pGap)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_GAP, RTL8367C_FLOWCTRL_PORT_GAP_MASK, pGap);
}

The above function is used to retrieve the Asic Egress FlowControlPort DropGap. I’m trying to modify it and store the value into a struct as below:

struct rtl8367c_struct_rtl8367c_




NEXT




<s> handle_pong(void)
{
struct ead_msg_pong *pong = EAD_DATA(msg, pong);
int len = ntohl(msg->len) - sizeof(struct ead_msg_pong);

if (len <= 0)
return false;

pong->name[len] = 0;
auth_type = ntohs(pong->auth_type);
if (nid == 0xffff)
printf("%04x: %s\n", ntohs(msg->nid), pong->name);
sid = msg->sid;
return true;
}

The above function is used to handle the authentication handshake packets which is triggered by the server (client).
In the above function, only the name and auth_type are read for now.

The nid is the network interface driver number, in this case, it




NEXT




<s> static void enter_image(uint32_t addr)
{
typedef void (*entry_t)(void);
entry_t entry = (entry_t)addr;

puts("Starting image...\n");
entry();
}

The above function is used to start the new address on the LCD screen and the previous address stays as the start address that was there before.

I am building an image display board where you can connect a VGA cable and it will display the image on the LCD




NEXT




<s> static rtk_api_ret_t _rtk_filter_igrAcl_writeDataField(rtl8367c_aclrule *aclRule, rtk_filter_field_t *fieldPtr);


/* Function Name:
*      rtk_filter_igrAcl_init
* Description:
*      ACL initialization function
* Input:
*      None
* Output:
*      None
* Return:
*      RT_ERR_OK           - OK
*      RT_ERR_FAILED       - Failed
*      RT_ERR_SMI          - SMI access error
*      RT_ERR_NULL_POINTER - Pointer pFilter_field or pFilter_cfg point to NULL.
* Note:
*      This function enable and intialize ACL function
*/
rtk_api_ret_t rtk_filter_igrAcl_init(void)
{
rtl8367c_acltemplate_t       aclTemp;
rtk_uint32                 i, j;
rtk_api_ret_t          ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((ret = rtk_filter_igrAcl_cfg_delAll()) != RT_ERR_OK)
return ret;

for(i = 0; i < RTL8367C_ACLTEMPLATENO; i++)
{
for(j = 0; j < RTL8367C_ACLRULEFIELDNO;j++)
aclTemp.field[j] = filter_templateField[i][j];

if ((ret = rtl8367c_setAsicAclTemplate(i, &aclTemp)) != RT_ERR_OK)
return ret;
}

for(i = 0; i < RTL8367C_FIELDSEL_FORMAT_NUMBER; i++)
{
if ((ret = rtl8367c_setAsicFieldSelector(i, field_selector[i][0], field_selector[i][1])) != RT_ERR_OK)
return ret;
}

RTK_SCAN_ALL_PHY_PORTMASK(i)
{
if ((ret = rtl8367c_setAsicAcl(i, TRUE)) != RT_ERR_OK)
return ret;

if ((ret = rtl8367c_setAsicAclUnmatchedPermit(i, TRUE)) != RT_ERR_OK)
return ret;
}

return RT_ERR_OK;
}

The above function is used to initialize the ACL table, it is executed during the initialization stage of the ACL function, to complete the initialization and setting of the ACL template on all the ports.

/* Function Name:
 *      rtk_filter_igr




NEXT




<s> swconfig_unlock(void)
{
mutex_unlock(&swdevs_lock);
}

The above function is used to unlock a mutex that is used for accessing a list of software drivers.  I noticed a call to this function in a thread from a bug report. In particular, the thread complained that the driver was crashing due to corrupt data that was




NEXT




<s> static void nmbm_erase_range(struct nmbm_instance *ni, uint32_t ba,
uint32_t limit)
{
bool success;

while (ba < limit) {
if (nmbm_get_block_state(ni, ba) != BLOCK_ST_GOOD)
goto next_block;

/* Insurance to detect unexpected bad block marked by user */
if (nmbm_check_bad_phys_block(ni, ba)) {
nmbm_set_block_state(ni, ba, BLOCK_ST_BAD);
goto next_block;
}

success = nmbm_erase_block_and_check(ni, ba);
if (success)
goto next_block;

nmbm_mark_phys_bad_block(ni, ba);
nmbm_set_block_state(ni, ba, BLOCK_ST_BAD);

next_block:
ba++;
}
}

The above function is used to erase a range of blocks on the NAND flash partition, if they haven;t met their endurance (aka worn-out) already. Note that we don’t need to check whether the erase command actually succeeds each time as




NEXT




<s> static void danube_fw_ver(unsigned int *major, unsigned int *minor)
{
ASSERT(major != NULL, "pointer is NULL");
ASSERT(minor != NULL, "pointer is NULL");

*major = FW_VER_ID->major;
*minor = FW_VER_ID->minor;
}

The above function is used to access the major and minor revision numbers of
the Danube framework of a UWB device. To access the major and minor
revisions, the function danube_fw_ver() is called:

unsigned int major;





NEXT




<s> static void mt7620_auto_poll(struct mt7620_gsw *gsw, int port)
{
int phy;
int lsb = -1, msb = 0;

for_each_set_bit(phy, &gsw->autopoll, 32) {
if (lsb < 0)
lsb = phy;
msb = phy;
}

if (lsb == msb && port ==  4)
msb++;
else if (lsb == msb && port ==  5)
lsb--;

mtk_switch_w32(gsw, PHY_AN_EN | PHY_PRE_EN | PMY_MDC_CONF(5) |
(msb << 8) | lsb, ESW_PHY_POLLING);
}

The above function is used to configure autopolling for different physical layer ports on switch. The PHY_AN_EN field is set according to the auto-negotiation status. It is set to 1 if the auto-negotiation is done for the




NEXT




<s> static int b53_switch_reset(struct b53_device *dev)
{
int ret = 0;
u8 mgmt;

b53_switch_reset_gpio(dev);

if (is539x(dev)) {
b53_write8(dev, B53_CTRL_PAGE, B53_SOFTRESET, 0x83);
b53_write8(dev, B53_CTRL_PAGE, B53_SOFTRESET, 0x00);
}

b53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);

if (!(mgmt & SM_SW_FWD_EN)) {
mgmt &= ~SM_SW_FWD_MODE;
mgmt |= SM_SW_FWD_EN;

b53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, mgmt);
b53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);

if (!(mgmt & SM_SW_FWD_EN)) {
pr_err("Failed to enable switch!\n");
return -EINVAL;
}
}

/* enable all ports */
b53_enable_ports(dev);

if (dev->dev->of_node)
ret = b53_configure_ports_of(dev);
else
ret = b53_configure_ports(dev);

if (ret)
return ret;

b53_enable_mib(dev);

return b53_flush_arl(dev);
}

The above function is used to reset the switch and its sub-tasks
(i.e., set the switch to switch forward enable mode, set all
port control register to be switch forward enable mode, enable
all ports, and flush ARL).</s>




NEXT




<s> ar8xxx_mii_read32(struct ar8xxx_priv *priv, int phy_id, int regnum)
{
struct mii_bus *bus = priv->mii_bus;
u16 lo, hi;

lo = bus->read(bus, phy_id, regnum);
hi = bus->read(bus, phy_id, regnum + 1);

return (hi << 16) | lo;
}

The above function is used to read the register file at any specified PHY id and register number by accessing the chip through MII bus.

This is the simple definition of functions that performs read of any register in PHY.  And this is achieved by the help




NEXT




<s> u32 rtl930x_hash(struct rtl838x_switch_priv *priv, u64 seed)
{
u32 k0, k1, h1, h2, h;

k0 = (u32) (((seed >> 55) & 0x1f) ^
((seed >> 44) & 0x7ff) ^
((seed >> 33) & 0x7ff) ^
((seed >> 22) & 0x7ff) ^
((seed >> 11) & 0x7ff) ^
(seed & 0x7ff));

h1 = (seed >> 11) & 0x7ff;
h1 = ((h1 & 0x1f) << 6) | ((h1 >> 5) & 0x3f);

h2 = (seed >> 33) & 0x7ff;
h2 = ((h2 & 0x3f) << 5) | ((h2 >> 6) & 0x3f);

k1 = (u32) (((seed << 55) & 0x1f) ^
((seed >> 44) & 0x7ff) ^
h2 ^
((seed >> 22) & 0x7ff) ^
h1 ^
(seed & 0x7ff));

/* Algorithm choice for block 0 */
if (sw_r32(RTL930X_L2_CTRL) & BIT(0))
h = k1;
else
h = k0;

/* Algorithm choice for block 1
* Since k0 and k1 are < 2048, adding 2048 will offset the hash into the second
* half of hash-space
* 2048 is in fact the hash-table size 16384 divided by 4 hashes per bucket
* divided by 2 to divide the hash space in 2
*/
if (sw_r32(RTL930X_L2_CTRL) & BIT(1))
h |= (k1 + 2048) << 16;
else
h |= (k0 + 2048) << 16;

return h;
}

The above function is used to produce the hash for the MAC address.
However, RTL9300 have bugs in the block 1 algorithm choice and can be
tricked to reduce the size of the hash-space to 64/2/4=




NEXT




<s> static uint32_t strntoul(char *str, char **endptr, int base, size_t len) {
char *newstr;
uint32_t res = 0;

newstr = calloc(len + 1, sizeof(char));
if (newstr) {
strncpy(newstr, str, len);
res = strtoul(newstr, endptr, base);
free(newstr);
}
return res;
}

The above function is used to extract a certain number of UTF16 characters from a utf16 string and convert it to a unsigned 32bit
integer.
As with most of my function prototypes, most of the work is done in the function itself




NEXT




<s> static int rtl8366rb_detect(struct rtl8366_smi *smi)
{
u32 chip_id = 0;
u32 chip_ver = 0;
int ret;

ret = rtl8366_smi_read_reg(smi, RTL8366RB_CHIP_ID_REG, &chip_id);
if (ret) {
dev_err(smi->parent, "unable to read chip id\n");
return ret;
}

switch (chip_id) {
case RTL8366RB_CHIP_ID_8366:
break;
default:
dev_err(smi->parent, "unknown chip id (%04x)\n", chip_id);
return -ENODEV;
}

ret = rtl8366_smi_read_reg(smi, RTL8366RB_CHIP_VERSION_CTRL_REG,
&chip_ver);
if (ret) {
dev_err(smi->parent, "unable to read chip version\n");
return ret;
}

dev_info(smi->parent, "RTL%04x ver. %u chip found\n",
chip_id, chip_ver & RTL8366RB_CHIP_VERSION_MASK);

return 0;
}

The above function is used to determine the RTL8366RB PHY chip in the
platform.</s>




NEXT




<s> static void rtl931x_sds_rx_rst(u32 sds)
{
u32 asds = rtl931x_get_analog_sds(sds);

if (sds < 2)
return;

rtl931x_write_sds_phy(asds, 0x2e, 0x12, 0x2740);
rtl931x_write_sds_phy(asds, 0x2f, 0x0, 0x0);
rtl931x_write_sds_phy(asds, 0x2f, 0x2, 0x2010);
rtl931x_write_sds_phy(asds, 0x20, 0x0, 0xc10);

rtl931x_write_sds_phy(asds, 0x2e, 0x12, 0x27c0);
rtl931x_write_sds_phy(asds, 0x2f, 0x0, 0xc000);
rtl931x_write_sds_phy(asds, 0x2f, 0x2, 0x6010);
rtl931x_write_sds_phy(asds, 0x20, 0x0, 0xc30);

mdelay(50);
}

The above function is used to reset some registers related to RX. Here is some explanation about it.

0x20: Data filter and symbol clock.
0x2e: AFE clock for PLL1 and PLL2
0x2f




NEXT




<s> static void _rtl8367c_VlanMCStSmi2User(rtk_uint16 *pSmiVlanCfg, rtl8367c_vlanconfiguser *pVlanCg)
{
pVlanCg->mbr            = pSmiVlanCfg[0] & 0x07FF;
pVlanCg->fid_msti       = pSmiVlanCfg[1] & 0x000F;
pVlanCg->meteridx       = (pSmiVlanCfg[2] >> 5) & 0x003F;
pVlanCg->envlanpol      = (pSmiVlanCfg[2] >> 4) & 0x0001;
pVlanCg->vbpri          = (pSmiVlanCfg[2] >> 1) & 0x0007;
pVlanCg->vbpen          = pSmiVlanCfg[2] & 0x0001;
pVlanCg->evid           = pSmiVlanCfg[3] & 0x1FFF;
}

The above function is used to decode an SMIs VlanCfg array
into a user mode VlanConfig structure.
This function is being used to validate an SMIs table during
initialization. This function should never be called in userspace.

Note to the




NEXT




<s> static const char *aw9523_pmx_get_fname(struct pinctrl_dev *pctl,
unsigned int sel)
{
return aw9523_pmx[sel].name;
}

The above function is used to get the pmm name, which is used
by the driver to name the pwm channels.

# Suggested Commit Messages

Use our "suggested" commit messages as templates
for new commits. Choose the




NEXT




<s> static int rtl8366rb_sw_get_port_stats(struct switch_dev *dev, int port,
struct switch_port_stats *stats)
{
return (rtl8366_sw_get_port_stats(dev, port, stats,
RTL8366RB_MIB_TXB_ID, RTL8366RB_MIB_RXB_ID));
}

The above function is used to get port stat,
but in switch_port_stats struct, it has RXB_COUNT and TXB_COUNT.

In SW, we need to get this stat only once, if the SW had some issues,
the




NEXT




<s> ret_t rtl8367c_setAsicIGMPLeaveTimer(rtk_uint32 leave_timer)
{
ret_t  retVal;

if(leave_timer > RTL8367C_MAX_LEAVE_TIMER)
return RT_ERR_OUT_OF_RANGE;

/* Leave timer */
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_LEAVE_TIMER_MASK, leave_timer);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set an IP device's asic leave timer. The asic will send all IGMP/MLD reports and group leave messages when the reported or
left group is within the range of the leave timer. The range of the timer is




NEXT




<s> static void routerboot_mtd_notifier_add(struct mtd_info *mtd)
{
/* Currently routerboot is only known to live on NOR flash */
if (mtd->type != MTD_NORFLASH)
return;

/*
* We ignore the following return values and always register.
* These init() routines are designed so that their failed state is
* always manageable by the corresponding exit() calls.
* Notifier is called with MTD mutex held: use __get/__put variants.
* TODO: allow partition names override
*/
if (!strcmp(mtd->name, RB_MTD_HARD_CONFIG))
rb_hardconfig_init(rb_kobj, mtd);
else if (!strcmp(mtd->name, RB_MTD_SOFT_CONFIG))
rb_softconfig_init(rb_kobj, mtd);
}

The above function is used to register devices on NOR flash that need to
be probed after flash recovery.

The below is a simple example of a device that just uses some predefined
information to register itself.

static void __get_softconfig_




NEXT




<s> ret_t rtl8367c_getAsicPortBcastFloodingPortmask(rtk_uint32 *pPortmask)
{
return rtl8367c_getAsicReg(RTL8367C_BCAST_FLOADING_PMSK_REG, pPortmask);
}

The above function is used to fetch Bcast Flooding Port Mask, a register that defines the port(s) over which MAC broadcast/multicast/promisc frames will be port replicated.
In order for a port to be set up as a flooding device




NEXT




<s> int br_foreach_bridge(int (*iterator)(const char *, void *), void *arg)
{
return new_foreach_bridge(iterator, arg);
}

The above function is used to iterate through all the entries in /etc/bridge/br0 but not sure what it means.

The above function uses the name of the bridge as a parameter to do some stuff with:

int br_foreach_bridge(




NEXT




<s> rtk_api_ret_t rtk_eee_portEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtk_uint32 regData1, regData2;
rtk_uint32    phy_port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port is UTP port */
RTK_CHK_PORT_IS_UTP(port);

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

phy_port = rtk_switch_port_L2P_get(port);

if ((retVal = rtl8367c_getAsicEee100M(phy_port,&regData1))!=RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_getAsicEeeGiga(phy_port,&regData2))!=RT_ERR_OK)
return retVal;

if (regData1==1&&regData2==1)
*pEnable = ENABLED;
else
*pEnable = DISABLED;

return RT_ERR_OK;
}

The above function is used to get port EEE status.

/* Get port EEE status */
rtk_enable_t EEE_portEnable_get(rtk_port_t port)
{
rtk_enable_t   eee




NEXT




<s> static inline void m_array_u16(const char *id, const uint16_t *value, size_t len) {
void *c = blobmsg_open_array(&b, id);

for (size_t i = 0; i < len; ++i)
blobmsg_add_u16(&b, "", value[i]);

blobmsg_close_array(&b, c);
}

The above function is used to encode a buffer of uint16_t into a
blob. The function has an array parameter and a single field
parameter which has a unique field name. The function generates a
blob with the value in all the fields of the array.




NEXT




<s> static int ag71xx_mdio_get_divider(struct device_node *np, u32 *div)
{
struct clk *ref_clk = of_clk_get(np, 0);
unsigned long ref_clock;
u32 mdio_clock;
const u32 *table;
int ndivs, i;

if (IS_ERR(ref_clk))
return -EINVAL;

ref_clock = clk_get_rate(ref_clk);
clk_put(ref_clk);

if(of_property_read_u32(np, "qca,mdio-max-frequency", &mdio_clock)) {
if (of_property_read_bool(np, "builtin-switch"))
mdio_clock = 5000000;
else
mdio_clock = 2000000;
}

if (of_device_is_compatible(np, "qca,ar9330-mdio") ||
of_device_is_compatible(np, "qca,ar9340-mdio")) {
table = ar933x_mdio_div_table;
ndivs = ARRAY_SIZE(ar933x_mdio_div_table);
} else if (of_device_is_compatible(np, "qca,ar7240-mdio")) {
table = ar7240_mdio_div_table;
ndivs = ARRAY_SIZE(ar7240_mdio_div_table);
} else {
table = ar71xx_mdio_div_table;
ndivs = ARRAY_SIZE(ar71xx_mdio_div_table);
}

for (i = 0; i < ndivs; i++) {
unsigned long t;

t = ref_clock / table[i];
if (t <= mdio_clock) {
*div = i;
return 0;
}
}

return -ENOENT;
}

The above function is used to find the MDIO clock divider so that it meets the requirement.</s>




NEXT




<s> rtl_set_cpuport(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
dev->cpu_port = val->value.i;
rtl_hw_init(dev);
return 0;
}

The above function is used to set the cpu_port variable to be stored within hw_info. It is called from the switch_cmd function of rtl8723be_cmd.c

When the command “set” is given by user at console,




NEXT




<s> void ifx_deu_des_ecb (void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
ifx_deu_des (ctx, dst, src, NULL, nbytes, encdec, 0);
}

The above function is used to either encrypt or decrypt
an array of bytes. The mode of encryption or decryption is
controlled by the enc_dec parameter.

In general the function can be used like this:

#include
#include





NEXT




<s> tristate sym_toggle_tristate_value(struct symbol *sym)
{
tristate oldval, newval;

oldval = newval = sym_get_tristate_value(sym);
do {
switch (newval) {
case no:
newval = mod;
break;
case mod:
newval = yes;
break;
case yes:
newval = no;
break;
}
if (sym_set_tristate_value(sym, newval))
break;
} while (oldval != newval);
return newval;
}

The above function is used to toggle the value of a tristate value for a given symbol, and is used in some options which allow toggling of certain features (options in the CONFIG_*) or for toggling options which are defined via the following #define.






NEXT




<s> int ehci_hcd_stop(int index)
{
reset_block(SYS_CTRL_RST_USBHS, 1);
disable_clock(SYS_CTRL_CLK_USBHS);
return 0;
}

The above function is used to turn off the usb controller. But I am confused here.

1. The reset is done using

reset_block(SYS_CONT_RST_USBHS, 1);

which refers to the reset of USB controller.




NEXT




<s> bbt_block_is_bad(u16 block)
{
u8 cur = bmtd.bbt_buf[block / 4];

return cur & (3 << ((block % 4) * 2));
}

The above function is used to check whether a given block should be marked as a bad block. It takes a block number as an argument and returns true if the block is marked as bad in the bitmask table.

Note that the bitmask table consists of a series of




NEXT




<s> ret_t rtl8367c_setAsicStormFilterExtBroadcastMeter(rtk_uint32 meter)
{
if(meter > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

return rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG0, RTL8367C_BC_STORM_EXT_METERIDX_MASK, meter);
}

The above function is used to program the extended storm filter meter. This operation is supported by the STORM_METER register, but as the same register is used to program the broadcast storm meter, we introduce a new register group to implement the extended storm meter function. The group




NEXT




<s> ar8xxx_sw_get_arl_table(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
struct mii_bus *bus = priv->mii_bus;
const struct ar8xxx_chip *chip = priv->chip;
char *buf = priv->arl_buf;
int i, j, k, len = 0;
struct arl_entry *a, *a1;
u32 status;

if (!chip->get_arl_entry)
return -EOPNOTSUPP;

mutex_lock(&priv->reg_mutex);
mutex_lock(&bus->mdio_lock);

chip->get_arl_entry(priv, NULL, NULL, AR8XXX_ARL_INITIALIZE);

for(i = 0; i < AR8XXX_NUM_ARL_RECORDS; ++i) {
a = &priv->arl_table[i];
duplicate:
chip->get_arl_entry(priv, a, &status, AR8XXX_ARL_GET_NEXT);

if (!status)
break;

/* avoid duplicates
* ARL table can include multiple valid entries
* per MAC, just with differing status codes
*/
for (j = 0; j < i; ++j) {
a1 = &priv->arl_table[j];
if (!memcmp(a->mac, a1->mac, sizeof(a->mac))) {
/* ignore ports already seen in former entry */
a->portmap &= ~a1->portmap;
if (!a->portmap)
goto duplicate;
}
}
}

mutex_unlock(&bus->mdio_lock);

len += snprintf(buf + len, sizeof(priv->arl_buf) - len,
"address resolution table\n");

if (i == AR8XXX_NUM_ARL_RECORDS)
len += snprintf(buf + len, sizeof(priv->arl_buf) - len,
"Too many entries found, displaying the first %d only!\n",
AR8XXX_NUM_ARL_RECORDS);

for (j = 0; j < priv->dev.ports; ++j) {
for (k = 0; k < i; ++k) {
a = &priv->arl_table[k];
if (!(a->portmap & BIT(j)))
continue;
len += snprintf(buf + len, sizeof(priv->arl_buf) - len,
"Port %d: MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
j,
a->mac[5], a->mac[4], a->mac[3],
a->mac[2], a->mac[1], a->mac[0]);
}
}

val->value.s = buf;
val->len = len;

mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to print the Address Resolution Information (ARL) to the user space process.

ar8xxx_hw_write_ar_tbl(struct switch_dev *dev,
struct switch_attr *attr,
struct switch_val




NEXT




<s> static __inline__ unsigned char get_byte(void)
{
unsigned char *buffer;
UInt32 fake;

return read_byte(0, &buffer, &fake), *buffer;
}

The above function is used to read a byte after jumping to ROM.
Unfortunately, it doesn't work well in QEmu (it hangs) because read_byte isn't well implemented;
the original code is:
Code:
static inline




NEXT




<s> static int mac_tbl_read(struct seq_file *seq, void *v)
{
rtk_hal_dump_table();
return 0;
}

The above function is used to output the content of the MAC Address Table.
rtk_hal_dump_table()  function is used to read and output the content of MAC Address Table, here we use the seq_file API to output the content of MAC Address Table




NEXT




<s> int do_crypt(FILE *infile, FILE *outfile, ctx_t *ctx)
{
unsigned char inbuf[CRYPT_BUF_SIZE];
unsigned char outbuf[CRYPT_BUF_SIZE + MBEDTLS_MAX_BLOCK_LENGTH];
size_t inlen, outlen, step;
int ret;

if (mbedtls_cipher_get_cipher_mode(ctx) == MBEDTLS_MODE_ECB) {
step = mbedtls_cipher_get_block_size(ctx);
if (step > CRYPT_BUF_SIZE) {
step = CRYPT_BUF_SIZE;
}
} else {
step = CRYPT_BUF_SIZE;
}

for (;;) {
inlen = fread(inbuf, 1, step, infile);
if (inlen <= 0)
break;
ret = mbedtls_cipher_update(ctx, inbuf, inlen, outbuf, &outlen);
if (ret) {
fprintf(stderr, "Error: mbedtls_cipher_update: %d\n", ret);
return ret;
}
ret = fwrite(outbuf, 1, outlen, outfile);
if (ret != outlen) {
fprintf(stderr, "Error: cipher_update short write.\n");
return ret - outlen;
}
}
ret = mbedtls_cipher_finish(ctx, outbuf, &outlen);
if (ret) {
fprintf(stderr, "Error: mbedtls_cipher_finish: %d\n", ret);
return ret;
}
ret = fwrite(outbuf, 1, outlen, outfile);
if (ret != outlen) {
fprintf(stderr, "Error: cipher_finish short write.\n");
return ret - outlen;
}

return 0;
}

The above function is used to encrypt or decrypt a file. It uses the `mbedtls_cipher_init` function to initialize the context, and then repeatedly reads data from the input file and writes it to the output file, calling the `mbedtls




NEXT




<s> static int md5_hmac_final(struct shash_desc *desc, u8 *out)
{
return md5_hmac_final_impl(desc, out, true);
}

The above function is used to finalise the HMAC computation and set a
hash result to the array pointed to by in_buf.  The function is quite
complex and performs a lot more work than strictly necessary to build the
HMAC message digest. It assumes that




NEXT




<s> ret_t rtl8367c_setAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 ocpData )
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint32 busyFlag, checkCounter;
rtk_uint32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;

/*Check internal phy access busy or not*/
/*retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_INDRECT_ACCESS_STATUS, RTL8367C_INDRECT_ACCESS_STATUS_OFFSET,&busyFlag);*/
retVal = rtl8367c_getAsicReg(RTL8367C_REG_INDRECT_ACCESS_STATUS,&busyFlag);
if(retVal != RT_ERR_OK)
return retVal;

if(busyFlag)
return RT_ERR_BUSYWAIT_TIMEOUT;

/* OCP prefix */
ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_GPHY_OCP_MSB_0, RTL8367C_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix)) != RT_ERR_OK)
return retVal;

/*prepare access data*/
retVal = rtl8367c_setAsicReg(RTL8367C_REG_INDRECT_ACCESS_WRITE_DATA, ocpData);
if(retVal != RT_ERR_OK)
return retVal;

/*prepare access address*/
ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
regData = RTL8367C_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367C_PHY_OFFSET) | ocpAddr5_1;
retVal = rtl8367c_setAsicReg(RTL8367C_REG_INDRECT_ACCESS_ADDRESS, regData);
if(retVal != RT_ERR_OK)
return retVal;

/*Set WRITE Command*/
retVal = rtl8367c_setAsicReg(RTL8367C_REG_INDRECT_ACCESS_CTRL, RTL8367C_CMD_MASK | RTL8367C_RW_MASK);

checkCounter = 100;
while(checkCounter)
{
retVal = rtl8367c_getAsicReg(RTL8367C_REG_INDRECT_ACCESS_STATUS,&busyFlag);
if((retVal != RT_ERR_OK) || busyFlag)
{
checkCounter --;
if(0 == checkCounter)
return RT_ERR_BUSYWAIT_TIMEOUT;
}
else
{
checkCounter = 0;
}
}

return retVal;
}

The above function is used to
access the phy chip using on-chip
physical (OCP) interface. For
further details, please refer to
section 5.3,
PHY OCP Operations, in the
_RTL836




NEXT




<s> int saveenv(void)
{
env_t	env_new;
ssize_t	len;
char	*res;
block_dev_desc_t *dev_desc = NULL;
int dev = EXT4_ENV_DEVICE;
int part = EXT4_ENV_PART;
int err;

res = (char *)&env_new.data;
len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, 0, NULL);
if (len < 0) {
error("Cannot export environment: errno = %d\n", errno);
return 1;
}

dev_desc = get_dev(EXT4_ENV_INTERFACE, dev);
if (dev_desc == NULL) {
printf("Failed to find %s%d\n",
EXT4_ENV_INTERFACE, dev);
return 1;
}

err = ext4_register_device(dev_desc, part);
if (err) {
printf("Failed to register %s%d:%d\n",
EXT4_ENV_INTERFACE, dev, part);
return 1;
}

env_new.crc = crc32(0, env_new.data, ENV_SIZE);
err = ext4fs_write(EXT4_ENV_FILE, (void *)&env_new, sizeof(env_t));
ext4fs_close();
if (err == -1) {
printf("\n** Unable to write \"%s\" from %s%d:%d **\n",
EXT4_ENV_FILE, EXT4_ENV_INTERFACE, dev, part);
return 1;
}

puts("done\n");
return 0;
}

The above function is used to save the environment data contained in the
environment variable, ENV_SIZE, to the file EXT4_ENV_FILE of the Linux
ext4 file system (e.g. /env_data_ext4).
The EN




NEXT




<s> rtk_api_ret_t rtk_dot1x_guestVlan_get(rtk_vlan_t *pVid)
{
rtk_api_ret_t retVal;
rtk_uint32 gvidx;
rtl8367c_vlanconfiguser vlanMC;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pVid)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsic1xGuestVidx(&gvidx)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicVlanMemberConfig(gvidx, &vlanMC)) != RT_ERR_OK)
return retVal;

*pVid = vlanMC.evid;

return RT_ERR_OK;
}

The above function is used to get the GuestVid of dot1x.</s>




NEXT




<s> rtk_api_ret_t rtk_mirror_isolationLeaky_get(rtk_enable_t *pTxenable, rtk_enable_t *pRxenable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if( (NULL == pTxenable) || (NULL == pRxenable) )
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortMirrorIsolationTxLeaky(pTxenable)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicPortMirrorIsolationRxLeaky(pRxenable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to access mirror isolation configuration on leaky ports.The 8367C has 1024 ports and 2048 MAC addresses. Each of them is individually configured with mirror isolation for Tx and Rx and a bitmap




NEXT




<s> swconfig_init(void)
{
INIT_LIST_HEAD(&swdevs);

return genl_register_family(&switch_fam);
}

The above function is used to initialize switchdev module of Linux kernel.

When genl_register_family() function is called, first it registers the following family name as the new family which is handled by “genl_family”:

[sourcecode language




NEXT




<s> static void pm_line_sec_counters_total(int fd, DSL_XTUDir_t direction) {
IOCTL_DIR(DSL_PM_LineSecCountersTotal_t, DSL_FIO_PM_LINE_SEC_COUNTERS_TOTAL_GET, direction)

m_u32("es", out.data.nES);
m_u32("ses", out.data.nSES);
m_u32("loss", out.data.nLOSS);
m_u32("uas", out.data.nUAS);
m_u32("lofs", out.data.nLOFS);
#ifndef INCLUDE_DSL_CPE_API_DANUBE
m_u32("fecs", out.data.nFECS);
#endif
}

The above function is used to process the results received from the DSL CPE. The output data will change depending on the method used. There are two different counters that will be reported by the CPE depending on the DSL CPE driver used. On both types of




NEXT




<s> rtk_api_ret_t rtk_dot1x_portBasedDirection_set(rtk_port_t port, rtk_dot1x_direction_t port_direction)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if (port_direction >= DIRECTION_END)
return RT_ERR_DOT1X_PORTBASEDOPDIR;

if ((retVal = rtl8367c_setAsic1xPBOpdirConfig(rtk_switch_port_L2P_get(port), port_direction)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set direction of dynamic 802.1x port based authentication. When this port connected with a RADIUS server, the direction (uplink or downlink) of this port can be changed dynamically based on 80




NEXT




<s> static void msdc_reset_hw(struct msdc_host *host)
{
void __iomem *base = host->base;

sdr_set_bits(MSDC_CFG, MSDC_CFG_RST);
while (sdr_read32(MSDC_CFG) & MSDC_CFG_RST)
cpu_relax();
}

The above function is used to configure the MSDC_CFG register and set MSDC_CFG_RST bit to bring MSDC module to reset. In MSDC V1.5 specification document, there is a chapter that is dedicated for this kind of




NEXT




<s> rtk_api_ret_t rtk_mirror_keep_get(rtk_mirror_keep_t *pMode)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pMode)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortMirrorRealKeep(pMode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the MIRROR_KEEP current settings.

#include</s>




NEXT




<s> uc_value_t *uc_wpa_sha1(uc_vm_t *vm, size_t nargs)
{
u8 hash[SHA1_MAC_LEN];
char hash_hex[2 * ARRAY_SIZE(hash) + 1];
uc_value_t *val;
size_t *lens;
const u8 **args;
int i;

if (!nargs)
return NULL;

args = alloca(nargs * sizeof(*args));
lens = alloca(nargs * sizeof(*lens));
for (i = 0; i < nargs; i++) {
val = uc_fn_arg(i);
if (ucv_type(val) != UC_STRING)
return NULL;

args[i] = ucv_string_get(val);
lens[i] = ucv_string_length(val);
}

if (sha1_vector(nargs, args, lens, hash))
return NULL;

for (i = 0; i < ARRAY_SIZE(hash); i++)
sprintf(hash_hex + 2 * i, "%02x", hash[i]);

return ucv_string_new_length(hash_hex, 2 * ARRAY_SIZE(hash));
}

The above function is used to calculate SHA1 of the given string and generate SHA1 HEX string instead of byte sequence like below.

SHA1("hello") -> 14aef23431647c1159a8af




NEXT




<s> i = memcmp(expected, resp, sizeof(expected));
if(i == 0) {
SHA1Update(&ts->hash, expected, sizeof(expected));
SHA1Update(&ts->hash, ts->session_key, sizeof(ts->session_key));
SHA1Final(ts->session_response, &ts->hash);
}

The above function is used to process client's session and session_key,
then call SHA1 to generate the response with original session and session_key.
Now, when a packet arrives for the same session, server will generate
another reply with the same session




NEXT




<s> static int rtl83xx_fib4_del(struct rtl838x_switch_priv *priv,
struct fib_entry_notifier_info *info)
{
struct fib_nh *nh = fib_info_nh(info->fi, 0);
struct rtl83xx_route *r;
struct rhlist_head *tmp, *list;

pr_debug("In %s, ip %pI4, len %d\n", __func__, &info->dst, info->dst_len);
rcu_read_lock();
list = rhltable_lookup(&priv->routes, &nh->fib_nh_gw4, route_ht_params);
if (!list) {
rcu_read_unlock();
pr_err("%s: no such gateway: %pI4\n", __func__, &nh->fib_nh_gw4);
return -ENOENT;
}
rhl_for_each_entry_rcu(r, tmp, list, linkage) {
if (r->dst_ip == info->dst && r->prefix_len == info->dst_len) {
pr_info("%s: found a route with id %d, nh-id %d\n",
__func__, r->id, r->nh.id);
break;
}
}
rcu_read_unlock();

rtl83xx_l2_nexthop_rm(priv, &r->nh);

pr_debug("%s: Releasing packet counter %d\n", __func__, r->pr.packet_cntr);
set_bit(r->pr.packet_cntr, priv->packet_cntr_use_bm);
priv->r->pie_rule_rm(priv, &r->pr);

rtl83xx_route_rm(priv, r);

nh->fib_nh_flags &= ~RTNH_F_OFFLOAD;

return 0;
}

The above function is used to get a route from fib and deletes
the route that matches the fib4 entry. The logic for this
function is the same as rtl83xx_fib4_add function which is
discussed below

The




NEXT




<s> static inline int rtl930x_mac_port_ctrl(int p)
{
return RTL930X_MAC_L2_PORT_CTRL(p);
}

The above function is used to handle RTL930X_MAC_L2_PORT_CTRL register. In the function, a parameter rtl930x_mac_port_ctrl is declared. But in the function, rtl930x




NEXT




<s> static int sprom_extract(struct ssb_fbs *priv, const u16 *in, u16 size)
{
struct ssb_sprom *out = &priv->sprom;

memset(out, 0, sizeof(*out));

out->revision = in[size - 1] & 0x00FF;

switch (out->revision) {
case 1:
case 2:
case 3:
sprom_extract_r123(out, in);
break;
case 4:
case 5:
sprom_extract_r45(out, in);
break;
case 8:
sprom_extract_r8(out, in);
break;
default:
dev_warn(priv->dev,
"Unsupported SPROM revision %d detected."
" Will extract v1\n",
out->revision);
out->revision = 1;
sprom_extract_r123(out, in);
}

if (out->boardflags_lo == 0xFFFF)
out->boardflags_lo = 0;  /* per specs */
if (out->boardflags_hi == 0xFFFF)
out->boardflags_hi = 0;  /* per specs */

return 0;
}

The above function is used to take care of the ssb_sprom struct that
is returned by the userland application during the
usb_control_msg operation.

The main purpose of this function is to extract the revision number from
the provided input parameter in




NEXT




<s> static void rtl838x_rate_control_init(struct rtl838x_switch_priv *priv)
{
pr_info("Enabling Storm control\n");
/* TICK_PERIOD_PPS */
if (priv->id == 0x8380)
sw_w32_mask(0x3ff << 20, 434 << 20, RTL838X_SCHED_LB_TICK_TKN_CTRL_0);

/* Set burst rate */
sw_w32(0x00008000, RTL838X_STORM_CTRL_BURST_0); /* UC */
sw_w32(0x80008000, RTL838X_STORM_CTRL_BURST_1); /* MC and BC */

/* Set burst Packets per Second to 32 */
sw_w32(0x00000020, RTL838X_STORM_CTRL_BURST_PPS_0); /* UC */
sw_w32(0x00200020, RTL838X_STORM_CTRL_BURST_PPS_1); /* MC and BC */

/* Include IFG in storm control, rate based on bytes/s (0 = packets) */
sw_w32_mask(0, 1 << 6 | 1 << 5, RTL838X_STORM_CTRL);
/* Bandwidth control includes preamble and IFG (10 Bytes) */
sw_w32_mask(0, 1, RTL838X_SCHED_CTRL);

/* On SoCs except RTL8382M, set burst size of port egress */
if (priv->id != 0x8382)
sw_w32_mask(0xffff, 0x800, RTL838X_SCHED_LB_THR);

/* Enable storm control on all ports with a PHY and limit rates,
* for UC and MC for both known and unknown addresses
*/
for (int i = 0; i < priv->cpu_port; i++) {
if (priv->ports[i].phy) {
sw_w32((1 << 18) | 0x8000, RTL838X_STORM_CTRL_PORT_UC(i));
sw_w32((1 << 18) | 0x8000, RTL838X_STORM_CTRL_PORT_MC(i));
sw_w32(0x8000, RTL838X_STORM_CTRL_PORT_BC(i));
rtl838x_storm_enable(priv, i, true);
}
}

/* Attack prevention, enable all attack prevention measures */
/* sw_w32(0x1ffff, RTL838X_ATK_PRVNT_CTRL); */
/* Attack prevention, drop (bit = 0) problematic packets on all ports.
* Setting bit = 1 means: trap to CPU
*/
/* sw_w32(0, RTL838X_ATK_PRVNT_ACT); */
/* Enable attack prevention on all ports */
/* sw_w32(0x0fffffff, RTL838X_ATK_PRVNT_PORT_EN); */
}

The above function is used to intiiallize Storm control (rate control). The function sets Storm thresholds (Rate), in case of threshold match burst rate is limited. Note, that in case of burst size (8 Byte) and tick time(45 μ




NEXT




<s> uc_value_t *uc_wpa_udebug_set(uc_vm_t *vm, size_t nargs)
{
uc_value_t *name = uc_fn_arg(0);
uc_value_t *ubus = uc_fn_arg(1);
static bool enabled = false;
struct ubus_context *ctx;
bool cur_en;

cur_en = ucv_type(name) == UC_STRING;
ctx = ucv_resource_data(ubus, "ubus.connection");
if (!ctx)
cur_en = false;

if (enabled == cur_en)
return ucv_boolean_new(true);

enabled = cur_en;
if (enabled) {
udebug_service = strdup(ucv_string_get(name));
udebug_init(&ud);
udebug_auto_connect(&ud, NULL);
udebug_ubus_init(&ud_ubus, ctx, udebug_service, wpa_udebug_config);
} else {
udebug_ubus_free(&ud_ubus);
for (size_t i = 0; i < ARRAY_SIZE(udebug_rings); i++)
if (udebug_buf_valid(udebug_rings[i].buf))
udebug_buf_free(udebug_rings[i].buf);
udebug_free(&ud);
free(udebug_service);
}

return ucv_boolean_new(true);
}

The above function is used to enable the logging, for which we’re
using the UBus logging daemon that I blogged about in an earlier
post. Please read the original post for technical details.</s>




NEXT




<s> static int b53_spi_write16(struct b53_device *dev, u8 page, u8 reg, u16 value)
{
struct spi_device *spi = dev->priv;
int ret;
u8 txbuf[4];

ret = b53_prepare_reg_access(spi, page);
if (ret)
return ret;

txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
txbuf[1] = reg;
put_unaligned_le16(value, &txbuf[2]);

return spi_write(spi, txbuf, sizeof(txbuf));
}

The above function is used to set the SPI CSR for page 0.</s>




NEXT




<s> static irqreturn_t gsw_interrupt_mt7620(int irq, void *_priv)
{
struct fe_priv *priv = (struct fe_priv *)_priv;
struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
u32 status;
int i, max = (gsw->port4_ephy) ? (4) : (3);

status = mtk_switch_r32(gsw, GSW_REG_ISR);
if (status & PORT_IRQ_ST_CHG)
for (i = 0; i <= max; i++) {
u32 status = mtk_switch_r32(gsw, GSW_REG_PORT_STATUS(i));
int link = status & 0x1;

if (link != priv->link[i])
mt7620_print_link_state(priv, i, link,
(status >> 2) & 3,
(status & 0x2));

priv->link[i] = link;
}
mt7620_handle_carrier(priv);
mtk_switch_w32(gsw, status, GSW_REG_ISR);

return IRQ_HANDLED;
}

The above function is used to register ISRs of MT7620 GSW switch.
To initialize and start GSW switch, following initialization flow should to be followed.

1. MT7620 GSW switch initializations

MT76




NEXT




<s> int rtl838x_set_egress_rate(struct rtl838x_switch_priv *priv, int port, u32 rate)
{
u32 old_rate;

if (port > priv->cpu_port)
return -1;

old_rate = sw_r32(RTL838X_SCHED_P_EGR_RATE_CTRL(port));
sw_w32(rate, RTL838X_SCHED_P_EGR_RATE_CTRL(port));

return old_rate;
}

The above function is used to set the tx rate for each port. It is expected to return the old rate or set it to port 0 if it fails to change. What happens is that it does return the old tx rate for all the ports except the cpu port. When




NEXT




<s> static void rtl8366rb_switch_cleanup(struct rtl8366_smi *smi)
{
unregister_switch(&smi->sw_dev);
}

The above function is used to unregister smi switch device when the switch is
detached.

I see that currently the only thing that is done is just to call
rtl8366rb_switch_cleanup() in rtl8366




NEXT




<s> static int conf_string(struct menu *menu)
{
struct symbol *sym = menu->sym;
const char *def;

while (1) {
printf("%*s%s ", indent - 1, "", menu->prompt->text);
printf("(%s) ", sym->name);
def = sym_get_string_value(sym);
if (def)
printf("[%s] ", def);
if (!conf_askvalue(sym, def))
return 0;
switch (line[0]) {
case '\n':
break;
case '?':
/* print help */
if (line[1] == '\n') {
print_help(menu);
def = NULL;
break;
}
/* fall through */
default:
line[strlen(line)-1] = 0;
def = line;
}
if (def && sym_set_string_value(sym, def))
return 0;
}
}

The above function is used to ask the user for a string, that you would use for configuration:

struct symbol *sym = menu->sym;

This struct symbol contains the string of configuration for which you want to ask.

Menu prompt:

If




NEXT




<s> static void ag71xx_fast_reset(struct ag71xx *ag)
{
struct net_device *dev = ag->dev;
u32 rx_ds;
u32 mii_reg;

ag71xx_hw_stop(ag);
wmb();

mii_reg = ag71xx_rr(ag, AG71XX_REG_MII_CFG);
rx_ds = ag71xx_rr(ag, AG71XX_REG_RX_DESC);

ag71xx_tx_packets(ag, true, 0);

reset_control_assert(ag->mac_reset);
udelay(10);
reset_control_deassert(ag->mac_reset);
udelay(10);

ag71xx_dma_reset(ag);
ag71xx_hw_setup(ag);
ag->tx_ring.curr = 0;
ag->tx_ring.dirty = 0;
netdev_reset_queue(ag->dev);

/* setup max frame length */
ag71xx_wr(ag, AG71XX_REG_MAC_MFL,
ag71xx_max_frame_len(ag->dev->mtu));

ag71xx_wr(ag, AG71XX_REG_RX_DESC, rx_ds);
ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->tx_ring.descs_dma);
ag71xx_wr(ag, AG71XX_REG_MII_CFG, mii_reg);

ag71xx_hw_set_macaddr(ag, dev->dev_addr);
}

The above function is used to reset the hardware when the user tries to restart the device. We should start by stopping the network hardware as well disabling DMA before resetting the hardware. Then we should re-initialize the hardware before allowing new packets to be transmitted or received.




NEXT




<s> static int nct5104d_gpio_direction_out(struct gpio_chip *chip,
unsigned offset, int value);
static void nct5104d_gpio_set(struct gpio_chip *chip, unsigned offset, int value);

#define NCT5104D_GPIO_BANK(_base, _ngpio, _regbase)			\
{								\
.chip = {						\
.label            = DRVNAME,			\
.owner            = THIS_MODULE,		\
.direction_input  = nct5104d_gpio_direction_in,	\
.get              = nct5104d_gpio_get,		\
.direction_output = nct5104d_gpio_direction_out,	\
.set              = nct5104d_gpio_set,		\
.base             = _base,			\
.ngpio            = _ngpio,			\
.can_sleep        = true,			\
},							\
.regbase = _regbase,					\
}

The above function is used to define an instance of nct5104d gpio device driver. It is required that the three argument:

- _base is a value that can be used to identify the bank in code, this value have

- _




NEXT




<s> ret_t rtl8367c_setAsicSystemLutLearnPortMask(rtk_uint32 portmask)
{
ret_t retVal;

if(portmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_PMASK_MASK, portmask & 0xff);
if(retVal != RT_ERR_OK)
return retVal;
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_PMASK1_MASK, (portmask>>8) & 0x7);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;

}

The above function is used to set the learn port mask. We need to update the hardware when
some ports have been disabled.

rtl8367c_getAsicSystemLutLearnPortMask

ret_t rtl83




NEXT




<s> int sata_core_has_fast_waiters(struct ata_host *ah)
{
int has_waiters;
unsigned long flags;
struct sata_oxnas_host_priv *hd = ah->private_data;

spin_lock_irqsave(&hd->core_lock, flags);
has_waiters = !list_empty(&hd->fast_wait_queue.head);
spin_unlock_irqrestore(&hd->core_lock, flags);

return has_waiters;
}

The above function is used to determine whether the SATA controller has fast waiters or not, then to determine whether to use the fast_wait_queue method for the SCSI transaction wait process.</s>




NEXT




<s> static int b53_configure_ports_of(struct b53_device *dev)
{
struct device_node *dn, *pn;
u32 port_num;

dn = of_get_child_by_name(dev_of_node(dev->dev), "ports");

for_each_available_child_of_node(dn, pn) {
struct device_node *fixed_link;

if (of_property_read_u32(pn, "reg", &port_num))
continue;

if (port_num > B53_CPU_PORT)
continue;

fixed_link = of_get_child_by_name(pn, "fixed-link");
if (fixed_link) {
u32 spd;
u8 po = GMII_PO_LINK;
phy_interface_t mode;

of_get_phy_mode(pn, &mode);

if (!of_property_read_u32(fixed_link, "speed", &spd)) {
switch (spd) {
case 10:
po |= GMII_PO_SPEED_10M;
break;
case 100:
po |= GMII_PO_SPEED_100M;
break;
case 2000:
if (is_imp_port(dev, port_num))
po |= PORT_OVERRIDE_SPEED_2000M;
else
po |= GMII_PO_SPEED_2000M;
fallthrough;
case 1000:
po |= GMII_PO_SPEED_1000M;
break;
}
}

if (of_property_read_bool(fixed_link, "full-duplex"))
po |= PORT_OVERRIDE_FULL_DUPLEX;
if (of_property_read_bool(fixed_link, "pause"))
po |= GMII_PO_RX_FLOW;
if (of_property_read_bool(fixed_link, "asym-pause"))
po |= GMII_PO_TX_FLOW;

if (is_imp_port(dev, port_num)) {
po |= PORT_OVERRIDE_EN;

if (is5325(dev) &&
mode == PHY_INTERFACE_MODE_REVMII)
po |= PORT_OVERRIDE_RV_MII_25;

b53_write8(dev, B53_CTRL_PAGE,
B53_PORT_OVERRIDE_CTRL, po);

if (is5325(dev) &&
mode == PHY_INTERFACE_MODE_REVMII) {
b53_read8(dev, B53_CTRL_PAGE,
B53_PORT_OVERRIDE_CTRL, &po);
if (!(po & PORT_OVERRIDE_RV_MII_25))
pr_err("Failed to enable reverse MII mode\n");
return -EINVAL;
}
} else {
po |= GMII_PO_EN;
b53_write8(dev, B53_CTRL_PAGE,
B53_GMII_PORT_OVERRIDE_CTRL(port_num),
po);
}
}
}

return 0;
}

The above function is used to enable an override setting for a port
during system initialization to allow the port to be configured at
run time. The function takes a pointer to a b53_device structure that
was created by the caller. A port number in the




NEXT




<s> bool menu_is_visible(struct menu *menu)
{
struct menu *child;
struct symbol *sym;
tristate visible;

if (!menu->prompt)
return false;

if (menu->visibility) {
if (expr_calc_value(menu->visibility) == no)
return false;
}

sym = menu->sym;
if (sym) {
sym_calc_value(sym);
visible = menu->prompt->visible.tri;
} else
visible = menu->prompt->visible.tri = expr_calc_value(menu->prompt->visible.expr);

if (visible != no)
return true;

if (!sym || sym_get_tristate_value(menu->sym) == no)
return false;

for (child = menu->list; child; child = child->next) {
if (menu_is_visible(child)) {
if (sym)
sym->flags |= SYMBOL_DEF_USER;
return true;
}
}

return false;
}

The above function is used to determine if a menu is visible. The only argument is a
pointer to the menu itself. This function returns true if the menu is visible.

In menus.c:

#define MENU_VISIBLE() ((




NEXT




<s> BFMWait (u32 cycle)
{
u32 i;
for (i = 0; i < cycle; i++);
}

The above function is used to wait for a pre-determined number of cycles, usually to slow down execution. Unfortunately, a while loop (of the form while (!flag) bfmwait_cycles();) can be a slow loop as it does not yield after




NEXT




<s> ret_t rtl8367c_getAsicTotalPage(rtk_uint32 *pPageCount)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_TOTAL_PAGE_COUNTER, RTL8367C_FLOWCTRL_TOTAL_PAGE_COUNTER_MASK, pPageCount);
}

The above function is used to get the total page counter of RTL8367C switch and the implementation of rtl8367d is shown below: (The difference between 8367c and 8367d is only the register




NEXT




<s> static int aw9523_pcfg_param_to_reg(enum pin_config_param pcp, int pin, u8 *r)
{
u8 reg;

switch (pcp) {
case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
case PIN_CONFIG_BIAS_PULL_DOWN:
case PIN_CONFIG_BIAS_PULL_UP:
reg = AW9523_REG_IN_STATE(pin);
break;
case PIN_CONFIG_DRIVE_OPEN_DRAIN:
case PIN_CONFIG_DRIVE_PUSH_PULL:
reg = AW9523_REG_GCR;
break;
case PIN_CONFIG_INPUT_ENABLE:
case PIN_CONFIG_OUTPUT_ENABLE:
reg = AW9523_REG_CONF_STATE(pin);
break;
case PIN_CONFIG_OUTPUT:
reg = AW9523_REG_OUT_STATE(pin);
break;
default:
return -ENOTSUPP;
}
*r = reg;

return 0;
}

The above function is used to get the register for a pin configuration parameter for the AW9523 device. I have added two new parameters PIN_CONFIG_OUTPUT_ENABLE and PIN_CONFIG_OUTPUT. They are used together to enable/disable pins




NEXT




<s> void rtl930x_vlan_port_keep_tag_set(int port, bool keep_outer, bool keep_inner)
{
sw_w32(FIELD_PREP(RTL930X_VLAN_PORT_TAG_STS_CTRL_EGR_OTAG_STS_MASK,
keep_outer ? RTL930X_VLAN_PORT_TAG_STS_TAGGED : RTL930X_VLAN_PORT_TAG_STS_UNTAG) |
FIELD_PREP(RTL930X_VLAN_PORT_TAG_STS_CTRL_EGR_ITAG_STS_MASK,
keep_inner ? RTL930X_VLAN_PORT_TAG_STS_TAGGED : RTL930X_VLAN_PORT_TAG_STS_UNTAG),
RTL930X_VLAN_PORT_TAG_STS_CTRL(port));
}

The above function is used to set the VLAN tag forwarding direction.

If an entry port receives a frame with an inner VLAN tag, it will forward
the frame in the direction which is determined by keep_inner. If an
entry port receives a frame




NEXT




<s> static void radius_userdata_free(struct radius_user_data *u)
{
struct radius_user_state *s, *tmp;

kvlist_free(&u->users);
free(u->wildcard);
u->wildcard = NULL;
avl_remove_all_elements(&u->user_state, s, node, tmp)
free(s);
}

The above function is used to remove a user from the cache with the corresponding id but at the end of the function (which is already written), this is where the user_state is cleared or freed.

So here in the above function,

How to use





NEXT




<s> swconfig_set_pvid(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
if (val->port_vlan >= dev->ports)
return -EINVAL;

if (!dev->ops->set_port_pvid)
return -EOPNOTSUPP;

return dev->ops->set_port_pvid(dev, val->port_vlan, val->value.i);
}

The above function is used to set the VLAN pvid of switch ports. And the switch port VLAN PVID is used by the switch core to mark the incoming packets on ports and outgoing packets on ports.

The following table shows the status of the packet on




NEXT




<s> int dc_ep_dev_info_req(int dev_idx, enum dc_ep_int module,
struct dc_ep_dev *dev)
{
int i;
struct dc_ep_priv *priv;

if ((dev_idx < 0) || (dev_idx >= DC_EP_MAX_NUM)) {
dev_err(dev->dev, "%s invalid device index %d\n",
__func__, dev_idx);
return -EIO;
}

priv = &g_dc_ep_info.pcie_ep[dev_idx];
if (atomic_read(&priv->refcnt) >= DC_EP_MAX_REFCNT) {
dev_err(dev->dev,
"%s mismatch request/release module usage\n", __func__);
return -EIO;
}

switch (module) {
case DC_EP_INT_PPE:
dev->irq = priv->irq_base;
if (priv->msi_mode == DC_EP_8_MSI_MODE) {
dev->aca_tx_irq = priv->irq_base + 7;
dev->aca_rx_irq = priv->irq_base + 6;
} else if (priv->msi_mode == DC_EP_4_MSI_MODE) {
dev->aca_tx_irq = priv->irq_base + 2;
dev->aca_rx_irq = priv->irq_base + 3;
} else {
dev_err(dev->dev, "%s ACA should never occur\n",
__func__);
}
break;
case DC_EP_INT_MEI:
dev->irq = priv->irq_base + 1;
break;
default:
dev->irq = priv->irq_base;
break;
}

dev->dev = priv->dev;
dev->membase = priv->mem;
dev->phy_membase = priv->phymem;
dev->peer_num = priv->peer_num;
for (i = 0; i < dev->peer_num; i++) {
dev->peer_membase[i] = priv->peer_mem[i];
dev->peer_phy_membase[i] = priv->peer_phymem[i];
}
dev->switch_attached = priv->switch_attached;
dev->priv = priv;
dev->hw_ops = &dc_ep_hw_ops;
atomic_inc(&priv->refcnt);
return 0;
}

The above function is used to obtain the configuration information for the
DC_EP device. The configuration includes, DMA buffer base address, DMA
buffer size, IRQ base address, and the physical device address. The
function receives device index dev_idx as input. This




NEXT




<s> ret_t rtl8367c_getAsicStormFilterMulticastMeter(rtk_uint32 port, rtk_uint32 *pMeter)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_STORM_MCAST_METER_CTRL_REG(port), RTL8367C_STORM_MCAST_METER_CTRL_MASK(port), pMeter);
}

The above function is used to set StormFilterMode.
rtl8367c_setAsicStormFilterMode

static ret_t rtl8367c_setAsicStormFilterMode(int enable)
{
uint




NEXT




<s> bool rtl930x_decode_tag(struct p_hdr *h, struct dsa_tag *t)
{
t->reason = h->cpu_tag[7] & 0x3f;
t->queue =  (h->cpu_tag[2] >> 11) & 0x1f;
t->port = (h->cpu_tag[0] >> 8) & 0x1f;
t->crc_error = h->cpu_tag[1] & BIT(6);

pr_debug("Reason %d, port %d, queue %d\n", t->reason, t->port, t->queue);
if (t->reason >= 19 && t->reason <= 27)
t->l2_offloaded = 0;
else
t->l2_offloaded = 1;

return t->l2_offloaded;
}

The above function is used to decode information from the cpu_tag bitmask. This data is used by the dsa_tag structures.

At the time of writing, I was only using that data for the l2_offloaded bool.

For the time




NEXT




<s> static ssize_t igmp_ops(struct file *file,
const char __user *buffer, size_t count,
loff_t *data)
{
char buf[8];
unsigned int ops;

if (copy_from_user(buf, buffer, count))
return -EFAULT;

if(sscanf(buf, "%d", &ops) == -1)
return -EFAULT;

if(ops == 0)
rtk_hal_disable_igmpsnoop();
else if (ops == 1)
rtk_hal_enable_igmpsnoop(0);
else //hw igmp
rtk_hal_enable_igmpsnoop(1);

return count;
}

The above function is used to set
the mode of IGMP snooping. The user can select the
mode
“0”, “1”, or “2”.The second type of IGMP snooping mode is called “hw” mode,
it




NEXT




<s> t_tohex(dst, src, size)
register char *dst, *src;
register unsigned size;
{
int notleading = 0;

register char *chp = dst;
if (size != 0) do {
if(notleading || *src != '\0') {
notleading = 1;
sprintf(chp, "%.2x", * (unsigned char *) src);
chp += 2;
}
++src;
} while (--size != 0);
return dst;
}

The above function is used to convert ASCII array characters into their corresponding hexadecimal values.

For example:
t_tohex("0x0000", "12345678", 3);
will translate the




NEXT




<s> static int rtl8214c_match_phy_device(struct phy_device *phydev)
{
return phydev->phy_id == PHY_ID_RTL8214C;
}

The above function is used to identify a device before the
proper phy driver is registered with the chip to make use
of the hardware capabilities. Without this there’s no way a
platform which can’t easily identify the chip would get to
use the driver




NEXT




<s> static inline int rtl839x_mac_port_ctrl(int p)
{
return RTL839X_MAC_PORT_CTRL(p);
}

The above function is used to get the hardware port number in RTL839X chipset. In fact, the RTL8366 chip has a MAC address per chip and the 8390 has two MAC addresses per chip. Therefore, we cannot




NEXT




<s> static int rtl9310_i2c_read(struct rtl9300_i2c *i2c, u8 *buf, int len)
{
return i2c_read(REG(i2c, RTL9310_I2C_DATA), buf, len);
}

The above function is used to communicate with the I2C master.

This function is part of the
rtl93_phy_i2c_probe()
function.  The first time it attempts to allocate and register the
i2c_master




NEXT




<s> static int rtl8390_configure_generic(struct phy_device *phydev)
{
int mac = phydev->mdio.addr;
u32 val, phy_id;

val = phy_read(phydev, 2);
phy_id = val << 16;
val = phy_read(phydev, 3);
phy_id |= val;
pr_debug("Phy on MAC %d: %x\n", mac, phy_id);

/* Read internal PHY ID */
phy_write_paged(phydev, 31, 27, 0x0002);
val = phy_read_paged(phydev, 31, 28);

/* Internal RTL8218B, version 2 */
phydev_info(phydev, "Detected unknown %x\n", val);

return 0;
}

The above function is used to read physical layer device ID and check physical layer device ID. This function also is used to
determine the chip is RTL8390 or not. The above function needs some information of PHY-chip. This information is got from




NEXT




<s> void rtl931x_fast_age(struct dsa_switch *ds, int port)
{
struct rtl838x_switch_priv *priv = ds->priv;

pr_info("%s port %d\n", __func__, port);
mutex_lock(&priv->reg_mutex);
sw_w32(port << 11, RTL931X_L2_TBL_FLUSH_CTRL + 4);

sw_w32(BIT(24) | BIT(28), RTL931X_L2_TBL_FLUSH_CTRL);

do { } while (sw_r32(RTL931X_L2_TBL_FLUSH_CTRL) & BIT (28));

mutex_unlock(&priv->reg_mutex);
}

The above function is used to speed up aging (flushing static entries from MAC table)
Nowadays every switch can do something about it.

I see it as an useful feature with some limitations and possible side effects. It is useful because if we don't clean




NEXT




<s> ar7240sw_init_globals(struct ar8xxx_priv *priv)
{

/* Enable CPU port, and disable mirror port */
ar8xxx_write(priv, AR8216_REG_GLOBAL_CPUPORT,
AR8216_GLOBAL_CPUPORT_EN |
(15 << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));

/* Setup TAG priority mapping */
ar8xxx_write(priv, AR8216_REG_TAG_PRIORITY, 0xfa50);

/* Enable ARP frame acknowledge, aging, MAC replacing */
ar8xxx_write(priv, AR8216_REG_ATU_CTRL,
AR8216_ATU_CTRL_RESERVED |
0x2b /* 5 min age time */ |
AR8216_ATU_CTRL_AGE_EN |
AR8216_ATU_CTRL_ARP_EN |
AR8216_ATU_CTRL_LEARN_CHANGE);

/* Enable Broadcast frames transmitted to the CPU */
ar8xxx_reg_set(priv, AR8216_REG_FLOOD_MASK,
AR8216_FM_CPU_BROADCAST_EN);

/* setup MTU */
ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
AR8216_GCTRL_MTU,
AR8216_GCTRL_MTU);

/* setup Service TAG */
ar8xxx_rmw(priv, AR8216_REG_SERVICE_TAG, AR8216_SERVICE_TAG_M, 0);
}

The above function is used to setup some of the global variables. For more
explanation, you should open ar8216.c in the linux kernel directory.

Let’s focus on the following lines:
ar8xxx_write(priv




NEXT




<s> ret_t rtl8367c_setAsicLutCamTbUsage(rtk_uint32 enabled)
{
ret_t retVal;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_BCAM_DISABLE_OFFSET, enabled ? 0 : 1);

return retVal;
}

The above function is used to set the status of
BCAM. It also includes a function that set the status of UCD.

ret_t rtl8367c_setAsicUcLutCam(rtk_uint32 enabled




NEXT




<s> static int aca_fw_download(struct dc_ep_priv *priv)
{
int i, j;
u32 val;
size_t size;
u32 id, load_addr;
const char *fw_base;
struct aca_fw_dl_addr *fw_dl = to_fw_addr(priv);

for (i = 0; i < fw_dl->fw_num; i++) {
id = fw_dl->fw_addr[i].fw_id;
load_addr = fw_dl->fw_addr[i].fw_load_addr;
size = fw_dl->fw_addr[i].fw_size;
fw_base = fw_dl->fw_addr[i].fw_base;

if (size % 4) {
dev_err(priv->dev,
"aca %s fw size is not a multiple of 4\n",
fw_id_to_str(id));
return -EINVAL;
}

for (j = 0; j < size; j += 4) {
val = *((u32 *)(fw_base + j));
wr32(cpu_to_be32(val), load_addr + j);
}
/* Write flush */
rd32(load_addr);
#ifdef DEBUG
{
u32 src, dst;

for (j = 0; j < size; j += 4) {
dst = rd32(load_addr + j);
src = *((u32 *)(fw_base + j));
if (dst != cpu_to_be32(src)) {
dev_info(priv->dev,
"dst 0x%08x != src 0x%08x\n", dst, src);
return -EIO;
}
}
}
#endif /* DEBUG */
}
return 0;
}

The above function is used to download firmware onto the host through the ACA bridge. Since the ACA driver is on device tree overlay, and the firmware will be downloaded during runtime, this function is implemented to support firmware file modification through U-Boot command




NEXT




<s> static inline void rtl838x_exec_tbl0_cmd(u32 cmd)
{
sw_w32(cmd, RTL838X_TBL_ACCESS_CTRL_0);
do { } while (sw_r32(RTL838X_TBL_ACCESS_CTRL_0) & BIT(15));
}

The above function is used to issue the command.

static inline sw_u32 rtl838x_tbl0_read(u32 address)
{
static uint8_t xtbl_access_cmd[3];
uint




NEXT




<s> unregister_switch(struct switch_dev *dev)
{
swconfig_destroy_led_trigger(dev);
kfree(dev->portbuf);
mutex_lock(&dev->sw_mutex);
swconfig_lock();
list_del(&dev->dev_list);
swconfig_unlock();
mutex_unlock(&dev->sw_mutex);
}

The above function is used to delete the corresponding software switch device.


register_switch_sdevent_call_back is used to register a software switch callback function. The corresponding callback function includes SDC_PORT_DOWN, SDC_PORT_UP,




NEXT




<s> void rtk_hal_set_phy_test_mode(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;

ret = rtk_port_phyTestMode_set(data->port, data->mode);
if (ret != RT_ERR_OK)
printk("rtk_port_phyTestMode_set failed\n");
else
printk("set port%d in test mode %d.\n", data->port, data->mode);
}

The above function is used to set the PHY test mode.
The data structures that need to be prepared are defined as follows
struct ra_switch_ioctl_data {
rtk_port_t port;
rtk_oid_t phy_test




NEXT




<s> ret_t rtl8367c_getAsicCputagPortmask(rtk_uint32 *pPortmask)
{
return rtl8367c_getAsicReg(RTL8367C_CPU_PORT_MASK_REG, pPortmask);
}

The above function is used to query the asic to know which ports can be used as CPU ports. I have used the following functions for this purpose. I am not able to test the code now.

If its the correct one then just add the above code in the




NEXT




<s> rtk_api_ret_t rtk_dot1x_macBasedEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsic1xMBEnConfig(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the current setting of macro-based DOT1X (802.1 X)/EAPOL enable status for the given Port.
The input port parameter is used to refer to the MAC base and the output parameter pEnable is




NEXT




<s> static ssize_t trelay_add_write(struct file *file, const char __user *ubuf,
size_t count, loff_t *ppos)
{
char buf[256];
char *dev1, *dev2, *tmp;
ssize_t len, ret;

len = min(count, sizeof(buf) - 1);
if (copy_from_user(buf, ubuf, len))
return -EFAULT;

buf[len] = 0;

if ((tmp = strchr(buf, '\n')))
*tmp = 0;

dev1 = strchr(buf, ',');
if (!dev1)
return -EINVAL;

*(dev1++) = 0;

dev2 = strchr(dev1, ',');
if (!dev2)
return -EINVAL;

*(dev2++) = 0;
if (strchr(dev2, ','))
return -EINVAL;

if (!strlen(buf) || !strlen(dev1) || !strlen(dev2))
return -EINVAL;

ret = trelay_do_add(buf, dev1, dev2);
if (ret < 0)
return ret;

return count;
}

The above function is used to append to a list of devices. It basically
takes the list of devices to add into the buffer buf and returns the number
of devices added. It returns a negative value if there was an error.

The do_add function takes




NEXT




<s> static struct property *sym_get_default_prop(struct symbol *sym)
{
struct property *prop;

for_all_defaults(sym, prop) {
prop->visible.tri = expr_calc_value(prop->visible.expr);
if (prop->visible.tri != no)
return prop;
}
return NULL;
}

The above function is used to obtain the default value of a symbol that is present in a structure. This function checks if the symbol has properties attached to it. If there are properties attached then the value of that symbol is checked and the default value is set accordingly. If no properties




NEXT




<s> extern int rtl839x_read_sds_phy(int phy_addr, int phy_reg);
extern int rtl839x_write_sds_phy(int phy_addr, int phy_reg, u16 v);
extern int rtl930x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl930x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl931x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl931x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl930x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl930x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);
extern int rtl931x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl931x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);

/* On the RTL93XX, the RTL93XX_DMA_IF_RX_RING_CNTR track the fill level of
* the rings. Writing x into these registers substracts x from its content.
* When the content reaches the ring size, the ASIC no longer adds
* packets to this receive queue.
*/
void rtl838x_update_cntr(int r, int released)
{
/* This feature is not available on RTL838x SoCs */
}

The above function is used to update the ring counters
on the Receive Interface of the DMA IF.

void rtl933x_update_cntr(int r, int released)
{
/* This feature is not available on RTL




NEXT




<s> irqreturn_t rtl930x_switch_irq(int irq, void *dev_id)
{
struct dsa_switch *ds = dev_id;
u32 ports = sw_r32(RTL930X_ISR_PORT_LINK_STS_CHG);
u32 link;

/* Clear status */
sw_w32(ports, RTL930X_ISR_PORT_LINK_STS_CHG);

for (int i = 0; i < 28; i++) {
if (ports & BIT(i)) {
/* Read the register twice because of issues with latency at least
* with the external RTL8226 PHY on the XGS1210
*/
link = sw_r32(RTL930X_MAC_LINK_STS);
link = sw_r32(RTL930X_MAC_LINK_STS);
if (link & BIT(i))
dsa_port_phylink_mac_change(ds, i, true);
else
dsa_port_phylink_mac_change(ds, i, false);
}
}

return IRQ_HANDLED;
}

The above function is used to handle the port status changes on RTL8306E based switches. However, the phylink_change(ds,i,status) function is missing in the switch_ops.
If the driver developer does not want to




NEXT




<s> static int rtl83xx_configure_flower(struct rtl838x_switch_priv *priv,
struct flow_cls_offload *f)
{
struct rtl83xx_flow *flow;
int err = 0;

pr_debug("In %s\n", __func__);

rcu_read_lock();
pr_debug("Cookie %08lx\n", f->cookie);
flow = rhashtable_lookup(&priv->tc_ht, &f->cookie, tc_ht_params);
if (flow) {
pr_info("%s: Got flow\n", __func__);
err = -EEXIST;
goto rcu_unlock;
}

rcu_unlock:
rcu_read_unlock();
if (flow)
goto out;
pr_debug("%s: New flow\n", __func__);

flow = kzalloc(sizeof(*flow), GFP_KERNEL);
if (!flow) {
err = -ENOMEM;
goto out;
}

flow->cookie = f->cookie;
flow->priv = priv;

err = rhashtable_insert_fast(&priv->tc_ht, &flow->node, tc_ht_params);
if (err) {
pr_err("Could not insert add new rule\n");
goto out_free;
}

rtl83xx_add_flow(priv, f, flow); /* TODO: check error */

/* Add log action to flow */
flow->rule.packet_cntr = rtl83xx_packet_cntr_alloc(priv);
if (flow->rule.packet_cntr >= 0) {
pr_debug("Using packet counter %d\n", flow->rule.packet_cntr);
flow->rule.log_sel = true;
flow->rule.log_data = flow->rule.packet_cntr;
}

err = priv->r->pie_rule_add(priv, &flow->rule);
return err;

out_free:
kfree(flow);
out:
pr_err("%s: error %d\n", __func__, err);

return err;
}

The above function is used to add a Flow. However, this function does not exist in the Realtek SDK. So, in order to make our code a bit more portable, we need to add the function above to the Realtek SDK in the location specified above.




NEXT




<s> static void aca_sw_reset(struct dc_ep_priv *priv)
{
u32 val = SW_RST_GENRISC | SW_RST_HOSTIF_REG | SW_RST_RXIN
| SW_RST_RXOUT | SW_RST_TXIN | SW_RST_TXOUT;

wr32(val, HT_SW_RST_ASSRT);
udelay(1);
wr32(val, HT_SW_RST_RELEASE);
wmb();
}

The above function is used to reset the AC_A hardware registers.

After the reset, the registers in AC_A will be all set to be default. The default value we should set in this case is '0'. That means to set all the AC_A




NEXT




<s> u64 rtl931x_traffic_get(int source)
{
u32 v;
struct table_reg *r = rtl_table_get(RTL9310_TBL_0, 6);

rtl_table_read(r, source);
v = sw_r32(rtl_table_data(r, 0));
rtl_table_release(r);
v = v >> 3;

return v;
}

The above function is used to return traffic count. But I get below error,
[ -22] *ERROR* Function ../rtl931x_traffic.c:8 rtl931x_traffic_get failed: bad data




NEXT




<s> static inline void sdahi(void)
{
gpio_direction_input(sda_index);
udelay(ADAP_DELAY);
}

The above function is used to convert the output signal from the computer as input signal to the sdahi chip and the signal is stored in the sda in porta.

```
static inline void sdaoh(void)  gpio_direction_output




NEXT




<s> void ide_input_data(int device, ulong *sect_buf, int words)
{
/* Only permit accesses to disks found to be present during ide_preinit() */
if (!disk_present[device]) {
return;
}

/* Select the required internal SATA drive */
device_select(device);

/* Start the DMA channel receiving data from the SATA core into the passed buffer */
dma_start_read(sect_buf, words << 2);

/* Sata core should finish before DMA */
if (wait_not_busy(device, 30)) {
printf("Timed out of wait for SATA device %d to have BUSY clear\n",
device);
}
if (!wait_no_error(device)) {
printf("oxnas_sata_output_data() Wait for ATA no-error timed-out\n");
}

/* Wait for DMA to finish */
if (!wait_dma_not_busy(device)) {
printf("Timed out of wait for DMA channel for SATA device %d to have in-progress clear\n",
device);
}

if (words == ATA_SECTORWORDS)
sata_bug_6320_workaround(device, sect_buf + words - 2);
}

The above function is used to read data directly from the SATA drive with a DMA transfer. The DMA is started here in the ide_input_data function, which in turn is called from various places in the IDE driver. The code is not perfect, but it works




NEXT




<s> ret_t rtl8367c_getAsicMIBsUsageMode(rtk_uint32* pMode)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_CTRL4, RTL8367C_MIB_USAGE_MODE_OFFSET, pMode);
}

The above function is used to read the usage modes of the ASIC MIMS (the ASIC is used or not) and MIHS(the ASIC host is used or not) in the MIB Control Register 4.
The following table shows the meaning of every




NEXT




<s> IFX_MEI_ExitDevice (int num)
{
DSL_DEV_Device_t *pDev;
pDev = &dsl_devices[num];

if (pDev == NULL)
return -EIO;

disable_irq (pDev->nIrq[IFX_DFEIR]);
disable_irq (pDev->nIrq[IFX_DYING_GASP]);

free_irq(pDev->nIrq[IFX_DFEIR], pDev);
free_irq(pDev->nIrq[IFX_DYING_GASP], pDev);

return 0;
}

The above function is used to de-allocate interrupts which have been used by the devices.
Un-register the devices from the kernel.
We are also calling dsl_remove_driver() function in the above code block.
In this way, we remove




NEXT




<s> int cbc_aes_encrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int enc_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = enc_bytes = walk.nbytes)) {
u8 *iv = walk.iv;
enc_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_cbc(ctx, walk.dst.virt.addr, walk.src.virt.addr,
iv, enc_bytes, CRYPTO_DIR_ENCRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

return err;
}

The above function is used to perform a AES block size operation on the input
data. During the first iteration, both the source and destination address
fields of the skcipher struct are used to indicate the input and output
blocks respectively. Encrypt() function is used




NEXT




<s> ret_t rtl8367c_getAsicPriorityDot1qRemapping(rtk_uint32 srcpriority, rtk_uint32 *pPriority )
{
if(srcpriority > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_getAsicRegBits(RTL8367C_QOS_1Q_PRIORITY_REMAPPING_REG(srcpriority), RTL8367C_QOS_1Q_PRIORITY_REMAPPING_MASK(srcpriority), pPriority);
}

The above function is used to access 1Q priority remapping register.

Here is the content of RTL8367C_QOS_1Q_PRIORITY_REMAPPING_REG register in datasheet,

QOS




NEXT




<s> static void fe_rxcsum_config(bool enable)
{
if (enable)
fe_w32(fe_r32(FE_GDMA1_FWD_CFG) | (FE_GDM1_ICS_EN |
FE_GDM1_TCS_EN | FE_GDM1_UCS_EN),
FE_GDMA1_FWD_CFG);
else
fe_w32(fe_r32(FE_GDMA1_FWD_CFG) & ~(FE_GDM1_ICS_EN |
FE_GDM1_TCS_EN | FE_GDM1_UCS_EN),
FE_GDMA1_FWD_CFG);
}

The above function is used to configure GDMA and FRDMA in Hantro video decoder driver, I have changed the following code lines

static void hantro_drv_fe_rxcsum_config(bool enable)
{
if (enable




NEXT




<s> static void __md5_Update(struct MD5Context *, const unsigned char *, unsigned int);
static void __md5_Pad(struct MD5Context *);
static void __md5_Final(unsigned char [16], struct MD5Context *);
static void __md5_Transform(uint32_t [4], const unsigned char [64]);


#define MD5_MAGIC_STR "$1$"
#define MD5_MAGIC_LEN (sizeof(MD5_MAGIC_STR) - 1)
static const unsigned char __md5__magic[] = MD5_MAGIC_STR;


#ifdef i386
#define __md5_Encode memcpy
#define __md5_Decode memcpy
#else /* i386 */

/*
* __md5_Encodes input (uint32_t) into output (unsigned char). Assumes len is
* a multiple of 4.
*/
static void
__md5_Encode(unsigned char *output, uint32_t *input, unsigned int len)
{
unsigned int i, j;

for (i = 0, j = 0; j < len; i++, j += 4) {
output[j] = input[i];
output[j+1] = (input[i] >> 8);
output[j+2] = (input[i] >> 16);
output[j+3] = (input[i] >> 24);
}
}

The above function is used to encode 32bit ints into unint8_t arrays.


The opposite operation:

/*
* __md5_Decode input (unsigned char) into output (uint32_t). Assumes len is




NEXT




<s> u32 _mt7620_mii_read(struct mt7620_gsw *gsw, int phy_addr, int phy_reg)
{
u32 d;

if (mt7620_mii_busy_wait(gsw))
return 0xffff;

mtk_switch_w32(gsw, GSW_MDIO_ACCESS | GSW_MDIO_START | GSW_MDIO_READ |
(phy_reg << GSW_MDIO_REG_SHIFT) |
(phy_addr << GSW_MDIO_ADDR_SHIFT),
MT7620A_GSW_REG_PIAC);

if (mt7620_mii_busy_wait(gsw))
return 0xffff;

d = mtk_switch_r32(gsw, MT7620A_GSW_REG_PIAC) & 0xffff;

return d;
}

The above function is used to read phy register, and the second line is:

if (mt7620_mii_busy_wait(gsw))
return 0xffff;

To call mt7620_mii




NEXT




<s> rtk_api_ret_t rtk_i2c_gpioPinGroup_set( rtk_I2C_gpio_pin_t pins_group )
{
rtk_uint32 retVal;


if( ( pins_group > I2C_GPIO_PIN_END )|| ( pins_group < I2C_GPIO_PIN_8_9) )
return RT_ERR_INPUT;

if( (retVal = rtl8367c_setAsicI2CGpioPinGroup(pins_group) ) != RT_ERR_OK )
return retVal ;

return RT_ERR_OK;
}

The above function is used to set the pins which I2C bus is associated with

#endif

#ifdef CONFIG_RTK_IIC_PIN_FUNC_DYNAMIIC

This #ifdef is for the I2C PIN




NEXT




<s> static void ag71xx_mux_select_sgmii_qca956x(struct device_node *np)
{
struct device_node *np_dev;
void __iomem *gmac_base;
u32 t;

np = of_get_child_by_name(np, "gmac-config");
if (!np)
return;

np_dev = of_parse_phandle(np, "device", 0);
if (!np_dev)
goto out;

gmac_base = of_iomap(np_dev, 0);
if (!gmac_base) {
pr_err("%pOF: can't map GMAC registers\n", np_dev);
goto err_iomap;
}

t = __raw_readl(gmac_base + QCA956X_GMAC_REG_ETH_CFG);
t |= QCA956X_ETH_CFG_GE0_SGMII;
__raw_writel(t, gmac_base + QCA956X_GMAC_REG_ETH_CFG);

iounmap(gmac_base);
err_iomap:
of_node_put(np_dev);
out:
of_node_put(np);
}

The above function is used to configure the GMAC. The SGMII option is
selected by setting the "GE0_SGMII" bit in the
QCA956X_GMAC_REG_ETH_CFG register.</s>




NEXT




<s> static inline u32 emac_readl(struct bcm6348_emac *emac, u32 off)
{
return __raw_readl(emac->base + off);
}

The above function is used to read the specified location from the EMAC register.

static inline void emac_writel(struct bcm6348_emac *emac, u16 off, u32 val)
{
__raw




NEXT




<s> void dc_aca_shutdown(struct dc_ep_priv *priv)
{
struct dc_aca *aca = to_aca(priv);

if (aca->initialized) {
aca_xbar_ia_reset(priv, ACA_ACC_IA04);
aca_xbar_ia_reset(priv, ACA_M_IA06);
}
}

The above function is used to shutdown the DC hardware before resetting. I need to do this to work around a kernel bug where it hangs in reconfiguring a reset.

With ACA_ACC_IA06 on, the reset is very fast and




NEXT




<s> DSL_BSP_DriverHandleDelete (DSL_DEV_Device_t * nHandle)
{
DSL_DEV_Device_t *pDev = (DSL_DEV_Device_t *) nHandle;
if (pDev->nInUse)
pDev->nInUse--;
module_put(pDev->owner);
return 0;
}

The above function is used to delete handles. I am trying to make a handle
deleter for a custom DSL driver which I am coding, but I have no idea how
to implement it since there is no function in dsl_drv.c that will help




NEXT




<s> static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to create a variable that stores the path of
the configuration file. If the buffer pointer is NULL, it means the buffer
isn't ready to be initialized

#### 2.1.2.18.3. File management




NEXT




<s> static int rtl83xx_netdevice_event(struct notifier_block *this,
unsigned long event, void *ptr)
{
struct net_device *ndev = netdev_notifier_info_to_dev(ptr);
struct rtl838x_switch_priv *priv;
int err;

pr_debug("In: %s, event: %lu\n", __func__, event);

if ((event != NETDEV_CHANGEUPPER) && (event != NETDEV_CHANGELOWERSTATE))
return NOTIFY_DONE;

priv = container_of(this, struct rtl838x_switch_priv, nb);
switch (event) {
case NETDEV_CHANGEUPPER:
err = rtl83xx_handle_changeupper(priv, ndev, ptr);
break;
}

if (err)
return err;

return NOTIFY_DONE;
}

The above function is used to register with netdev to listen to
changes made to a sublayer. For ethernet interfaces, there are upper
and lower layers. The upper layer indicates the interface on which
the physical data was moved. The lower layer indicates the




NEXT




<s> static void rtl83xx_port_bridge_leave(struct dsa_switch *ds, int port,
struct net_device *bridge)
{
struct rtl838x_switch_priv *priv = ds->priv;
u64 port_bitmap = 0, v;

pr_debug("%s %x: %d", __func__, (u32)priv, port);
mutex_lock(&priv->reg_mutex);
for (int i = 0; i < ds->num_ports; i++) {
/* Remove this port from the port matrix of the other ports
* in the same bridge. If the port is disabled, port matrix
* is kept and not being setup until the port becomes enabled.
* And the other port's port matrix cannot be broken when the
* other port is still a VLAN-aware port.
*/
if (dsa_is_user_port(ds, i) && i != port) {
if (dsa_to_port(ds, i)->bridge_dev != bridge)
continue;
if (priv->ports[i].enable)
priv->r->traffic_disable(i, port);

priv->ports[i].pm &= ~BIT_ULL(port);
port_bitmap |= BIT_ULL(i);
}
}

/* Remove all other ports from this port matrix. */
if (priv->ports[port].enable) {
v = priv->r->traffic_get(port);
v &= ~port_bitmap;
priv->r->traffic_set(port, v);
}
priv->ports[port].pm &= ~port_bitmap;

if (priv->r->set_static_move_action)
priv->r->set_static_move_action(port, true);

mutex_unlock(&priv->reg_mutex);
}

The above function is used to clear all the port matrix in a bridge,
which is responsible for handling the port to port move traffic
(802.1Q).

And there are two key points in the above code:
(1) the dsa




NEXT




<s> static inline struct aca_fw_info *to_fw_info(struct dc_ep_priv *priv)
{
return &priv->aca.fw_info;
}

The above function is used to retrieve a pointer to the private fw driver data

struct dc_cmd_buffer {
u32 header;
u32 length;
u32 data;
};

The structure describes a command buffer. There are




NEXT




<s> static irqreturn_t ar934x_nfc_irq_handler(int irq, void *data)
{
struct ar934x_nfc *nfc = data;
u32 status;

status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS);

ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
/* flush write */
ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS);

status &= ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_MASK);
if (status) {
nfc_dbg(nfc, "got IRQ, status:%08x\n", status);

nfc->irq_status = status;
nfc->spurious_irq_expected = true;
wake_up(&nfc->irq_waitq);
} else {
if (nfc->spurious_irq_expected)
nfc->spurious_irq_expected = false;
else
dev_warn(nfc->parent, "spurious interrupt\n");
}

return IRQ_HANDLED;
}

The above function is used to handle interrupt from AR934x and process the data to send to the host. And in nfc866x.c, we have

void nfc_866x_wqe_complete(struct nfc




NEXT




<s> static int process_special_keys(int *key, struct menu *menu)
{
int i;

if (*key == KEY_RESIZE) {
setup_windows();
return 1;
}

for (i = 0; i < function_keys_num; i++) {
if (*key == KEY_F(function_keys[i].key) ||
*key == '0' + function_keys[i].key){
function_keys[i].handler(key, menu);
return 1;
}
}

return 0;
}

The above function is used to process the SPECIAL KEYS. Special keystrokes, such as F1-F10, Ctrl+letter, etc. are processed here. The first if block does the function of terminating the special key, whereas the second




NEXT




<s> BigIntegerSub(B, B, n);

ts->B.len = BigIntegerToBytes(B, ts->B.data);

BigIntegerFree(v);
BigIntegerFree(B);
BigIntegerFree(b);
BigIntegerFree(g);
BigIntegerFree(n);

SHA1Update(&ts->oldckhash, ts->B.data, ts->B.len);

return &ts->B;
}

_TYPE( unsigned char * )
t_servergetkey(ts, clientval)
struct t_server * ts;
struct t_num * clientval;
{

The above function is used to get the elliptic curve public key from the client.  The client first constructs the ECDSA signature for a challenge of its choice:

x = get_newrandom_num(32);               /* 32 byte




NEXT




<s> rtk_api_ret_t rtk_oam_state_get(rtk_enable_t *pEnabled)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_getAsicOamEnable(pEnabled))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the current operation state of OAM. It supports R/W .
<br><br>Parameters: <br>
* enabled_ptr - Operation state
</p></p>

Return value: <br>
RT




NEXT




<s> static int sata_oxnas_acquire_hw(struct ata_port *ap, int may_sleep,
int timeout_jiffies);
static void sata_oxnas_release_hw(struct ata_port *ap);

static const void *HW_LOCKER_UID = (void *)0xdeadbeef;

/***************************************************************************
* ASIC access
***************************************************************************/
static void wait_cr_ack(void __iomem *phy_base)
{
while ((ioread32(phy_base + PHY_STAT) >> 16) & 0x1f)
; /* wait for an ack bit to be set */
}

The above function is used to wait for acknowledge bit to turn low and then ack bit to turn high. The acknowledge bit is set
inside the firmware to allow host controller to access the chip to prevent it from hanging (e.g. the case when hardware is




NEXT




<s> ret_t rtl8367c_setAsicI2CStartCmd(void)
{
rtk_uint32 regData;
ret_t retVal;

/* Bits [4-1] = 0b0000, Start Command; Bit [0] = 1, Trigger the Command */
if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
return retVal;
regData &= 0xFFE0;
regData |= 0x0001;

if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
return retVal;

/* wait for command finished */
do{
if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
return retVal;
}while( regData != 0x0);

return RT_ERR_OK ;
}

The above function is used to send Start Command to I2C chip (i2c_sda = 0, i2c_scl = 1). Before we send Start Command, there is a low level command first in order to prepare for command issuing




NEXT




<s> ret_t rtl8367c_getAsicPortEgressRateIfg(rtk_uint32 *ifg)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SCHEDULE_WFQ_CTRL, RTL8367C_SCHEDULE_WFQ_CTRL_OFFSET, ifg);

return retVal;
}

The above function is used to check ifg in the RTL8367C chip.
If the return value of the function is successful then check ifg, if not,
report and debug.

rtk_uint32 check_ifg(




NEXT




<s> UBNT_LEDBAR_CONTROL_RGBS(blue);


static int ubnt_ledbar_init_led(struct device_node *np, struct ubnt_ledbar *ledbar,
struct led_classdev *led_cdev)
{
struct led_init_data init_data = {};
int ret;

if (!np)
return 0;

init_data.fwnode = of_fwnode_handle(np);

led_cdev->max_brightness = UBNT_LEDBAR_MAX_BRIGHTNESS;

ret = devm_led_classdev_register_ext(&ledbar->client->dev, led_cdev,
&init_data);
if (ret)
dev_err(&ledbar->client->dev, "led register err: %d\n", ret);

return ret;
}

The above function is used to initialize the LED device and register it with the LED class. The `np` parameter is the device node of the LED device, and the `led_cdev` parameter is a pointer to the struct led_classdev structure that represents the LED




NEXT




<s> static int ip17xx_config_aneg(struct phy_device *pdev)
{
return 0;
}

The above function is used to configure Aneg values, based on which the
PHY calculates and returns the transmitter output power. It’s usually
implemented as:

static int ip17xx_config_aneg(struct phy_device *




NEXT




<s> void ifxdeu_fini_sha1_hmac (void)
{

crypto_unregister_shash(&ifxdeu_sha1_hmac_alg);


}

The above function is used to unregister the shash from crypto API. After calling the above function, no more operations (shash related) can be performed on sha1 hmac shash.</s>




NEXT




<s> ret_t rtl8367c_getAsicEgressFlowControlPortDropThreshold(rtk_uint32 port, rtk_uint32 *pThreshold)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_FLOWCTRL_PORT_DROP_ON_REG(port), RTL8367C_FLOWCTRL_PORT_DROP_ON_MASK, pThreshold);
}

The above function is used to retreive the flow control drop threshold value of a given port in the Tx flow control drop threshold register within the flow control register bank.

The format of the register for getting the flow control field is as follow:</s>




NEXT




<s> rtk_api_ret_t rtk_l2_agingEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if(enable == 1)
enable = 0;
else
enable = 1;

if ((retVal = rtl8367c_setAsicLutDisableAging(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable/disable aging timer on the forwarding engine. The LUT aging mechanism is used for L2/L3 Aging.

rtk_api_ret_t rtk_l2_agingTmEnable_set(




NEXT




<s> show_port(struct switch_dev *dev, int port)
{
struct switch_val val;

printf("Port %d:\n", port);
val.port_vlan = port;
show_attrs(dev, dev->port_ops, &val);
}

The above function is used to display the list of attributes associated
with a port using a port. The following is an example output of this
function:

Port 1:

Attribute: Port Enable: 0

Attribute: Port Status: 0





NEXT




<s> rtk_api_ret_t rtk_rate_stormControlPortEnable_set(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (stormType >= STORM_GROUP_END)
return RT_ERR_SFC_UNKNOWN_GROUP;

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

switch (stormType)
{
case STORM_GROUP_UNKNOWN_UNICAST:
if ((retVal = rtl8367c_setAsicStormFilterUnknownUnicastEnable(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_UNKNOWN_MULTICAST:
if ((retVal = rtl8367c_setAsicStormFilterUnknownMulticastEnable(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_MULTICAST:
if ((retVal = rtl8367c_setAsicStormFilterMulticastEnable(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_BROADCAST:
if ((retVal = rtl8367c_setAsicStormFilterBroadcastEnable(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;
break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to setup Storm Control Port Enable.

The function prototype of Storm Control Port Enable function:
rtk_api_ret_t rtk_rate_stormControlPortEnable_set(rtk_port_t port, rtk_




NEXT




<s> static void rtl9310_i2c_config_io(struct rtl9300_i2c *i2c, int scl_num, int sda_num)
{
u32 v;

/* Set SCL pin */
REG_MASK(i2c, 0, BIT(RTL9310_I2C_MST_IF_SEL_GPIO_SCL_SEL + scl_num), RTL9310_I2C_MST_IF_SEL);

/* Set SDA pin */
REG_MASK(i2c, 0x7 << RTL9310_I2C_CTRL_SDA_OUT_SEL,
i2c->sda_num << RTL9310_I2C_CTRL_SDA_OUT_SEL, RTL9310_I2C_CTRL);

/* Set SDA pin to I2C functionality */
v = readl(i2c->base + RTL9310_I2C_MST_IF_SEL);
v |= BIT(i2c->sda_num);
writel(v, i2c->base + RTL9310_I2C_MST_IF_SEL);
}

The above function is used to set SCL and SDA pins of I2C.
We have only one SCL but the function needs two parameters. Hence the number of
parameters should be two. The second parameter is used for SDA pin configuration.






NEXT




<s> rtk_api_ret_t rtk_port_efid_get(rtk_port_t port, rtk_data_t *pEfid)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pEfid)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortIsolationEfid(rtk_switch_port_L2P_get(port), pEfid))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the efid number of a given port from the ASIC.</s>




NEXT




<s> static char *mt7530_print_arl_table_row(u32 atrd,
u32 mac1,
u32 mac2,
char *buf,
size_t *size)
{
int ret;
size_t port;
size_t i;
u8 port_map;
u8 mac[ETH_ALEN];

mac1 = ntohl(mac1);
mac2 = ntohl(mac2);
port_map = (u8)((atrd & REG_ATRD_PORT_MASK) >> 4);
memcpy(mac, &mac1, sizeof(mac1));
memcpy(mac + sizeof(mac1), &mac2, sizeof(mac) - sizeof(mac1));
for (port = 0, i = 1; port < MT7530_NUM_PORTS; ++port, i <<= 1) {
if (port_map & i) {
ret = snprintf(buf, *size, "Port %d: MAC %pM\n", port, mac);
if (ret >= *size || ret <= 0) {
*buf = 0;
buf = NULL;
goto out;
}
buf += ret;
*size = *size - ret;
}
}
out:
return buf;
}

The above function is used to display the MAC addresses in the ARP table. It receives the port and MAC address from the switch and displays the MAC address of the corresponding port.


static char *mt7530_print_arl_table(void)




NEXT




<s> static INLINE void proc_file_create(void);
static INLINE void proc_file_delete(void);
static int proc_read_version(char *, char **, off_t, int, int *, void *);
static int proc_read_wanmib(char *, char **, off_t, int, int *, void *);
static int proc_write_wanmib(struct file *, const char *, unsigned long, void *);
#if defined(ENABLE_FW_PROC) && ENABLE_FW_PROC
static int proc_read_genconf(char *, char **, off_t, int, int *, void *);
#endif
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static int proc_read_dbg(char *, char **, off_t, int, int *, void *);
static int proc_write_dbg(struct file *, const char *, unsigned long, void *);
#endif

/*
*  Proc Help Functions
*/
static INLINE int stricmp(const char *, const char *);
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static INLINE int strincmp(const char *, const char *, int);
#endif
static INLINE int ifx_ptm_version(char *);

/*
*  Init & clean-up functions
*/
static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to confirm that showtime function is not enabled
and return an index to the corresponding entry of the showtime index table.
This index is used when showtime is actually enabled and the showtime values
are to be displayed.
#endif





NEXT




<s> rtl_exit(void)
{
phy_driver_unregister(&rtl8306_driver);
}

The above function is used to stop module operation by unregistering the driver. As per my observation, this function is never called. When the module is removed (e.g. using modprobe rm rtl8306), the module driver registration is reverted.




NEXT




<s> static bool nmbm_write_info_table(struct nmbm_instance *ni, uint32_t ba,
uint32_t limit, uint32_t *actual_start_ba,
uint32_t *actual_end_ba)
{
return nmbm_write_mgmt_range(ni, ba, limit, ni->info_table_cache,
ni->info_table_size, actual_start_ba,
actual_end_ba);
}

The above function is used to write to the “Management Range” which contains various tables which
inform the RAS manager and other clients about the status of the disks, etc. In
this particular case we are writing to the MIB-II table.






NEXT




<s> rtk_api_ret_t rtk_dot1x_guestVlan2Auth_get(rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsic1xGVOpdir(pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the setting of dot1x guest vlan authentication port.
The dot1x guest vlan authentication ports can provide guest users to get the access to the vlan of the wired guest vlan authentication port.

rtk_




NEXT




<s> static u32 rtl838x_packet_cntr_read(int counter)
{
u32 v;

/* Read LOG table (3) via register RTL8380_TBL_0 */
struct table_reg *r = rtl_table_get(RTL8380_TBL_0, 3);

pr_debug("In %s, id %d\n", __func__, counter);
rtl_table_read(r, counter / 2);

pr_debug("Registers: %08x %08x\n",
sw_r32(rtl_table_data(r, 0)), sw_r32(rtl_table_data(r, 1)));
/* The table has a size of 2 registers */
if (counter % 2)
v = sw_r32(rtl_table_data(r, 0));
else
v = sw_r32(rtl_table_data(r, 1));

rtl_table_release(r);

return v;
}

The above function is used to acquire the contents of counter 2 (Rx packet drops on
the 1st queue).

We have another function to set the value on this counter:

static void rtl838x_packet_cntr_update




NEXT




<s> ret_t rtl8367c_setAsicRemarkingDscp2Dscp(rtk_uint32 dscp, rtk_uint32 rmkDscp)
{
if((dscp > RTL8367C_DSCPMAX ) || (rmkDscp > RTL8367C_DSCPMAX))
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBits(RTL8367C_QOS_DSCP_TO_DSCP_REG(dscp), RTL8367C_QOS_DSCP_TO_DSCP_MASK(dscp), rmkDscp);
}

The above function is used to map DSCP field to new DSCP field before forwarding it to next device/hop.

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#




NEXT




<s> static int mt7621_nfc_read_page_raw(struct nand_chip *nand, uint8_t *buf,
int oob_required, int page)
{
struct mt7621_nfc *nfc = nand_get_controller_data(nand);
int i;

nand_read_page_op(nand, page, 0, NULL, 0);

nfi_write16(nfc, NFI_CNFG, (CNFG_OP_CUSTOM << CNFG_OP_MODE_S) |
CNFG_READ_MODE);

nfi_write16(nfc, NFI_CON,
CON_NFI_BRD | (nand->ecc.steps << CON_NFI_SEC_S));

for (i = 0; i < nand->ecc.steps; i++) {
/* Read data */
if (buf)
mt7621_nfc_read_data(nfc, page_data_ptr(nand, buf, i),
nand->ecc.size);
else
mt7621_nfc_read_data_discard(nfc, nand->ecc.size);

/* Read FDM */
mt7621_nfc_read_data(nfc, oob_fdm_ptr(nand, i), NFI_FDM_SIZE);

/* Read ECC parity data */
mt7621_nfc_read_data(nfc, oob_ecc_ptr(nfc, i),
nfc->spare_per_sector - NFI_FDM_SIZE);
}

nfi_write16(nfc, NFI_CON, 0);

return 0;
}

The above function is used to read a page of data out of the flash chip. You
can see it begins by reading the page data into the buffer, just like the
previous version of this code did – but that’s it. It doesn’t go on to




NEXT




<s> ret_t rtl8367c_getAsicFlowControlDropAll(rtk_uint32* pDropall)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_CTRL0, RTL8367C_DROP_ALL_THRESHOLD_MASK, pDropall);
}

The above function is used to get the value of bit 8 (RTL8367C_DROP_ALL_THRESHOLD_MASK) located in “RTL8367C_REG_FLOWCTRL_CTRL0 (0xF




NEXT




<s> u32 input_swap(u32 input)
{
if (!ifx_danube_pre_1_4) {
u8 *ptr = (u8 *)&input;
return ((ptr[3] << 24) | (ptr[2] << 16) | (ptr[1] << 8) | ptr[0]);
}
else
return input;
}

The above function is used to swap the bytes in u32 variable for udp_data_saving to work properly. But ifx_danube_pre_1_4 compile time define is 0 by default. Now how to check the value of a variable




NEXT




<s> static int mtk_bmt_debug_mark_bad(void *data, u64 val)
{
u32 block = val >> bmtd.blk_shift;
int cur_block;

cur_block = bmtd.ops->get_mapping_block(block);
if (cur_block < 0)
return -EIO;

mtk_bmt_remap_block(block, cur_block, bmtd.blk_size);

return 0;
}

The above function is used to mark blocks as “bad” so that they can be avoided
later on in the allocation algorithm.

The mtk_bmt_remap_block() function replaces the mapping of block
block with the mapping of block cur




NEXT




<s> static u32 rtl931x_l2_hash_key(struct rtl838x_switch_priv *priv, u64 seed)
{
u32 h, h0, h1, h2, h3, h4, k0, k1;

h0 = seed & 0xfff;
h1 = (seed >> 12) & 0xfff;
h2 = (seed >> 24) & 0xfff;
h3 = (seed >> 36) & 0xfff;
h4 = (seed >> 48) & 0xfff;
h4 = ((h4 & 0x7) << 9) | ((h4 >> 3) & 0x1ff);
k0 = h0 ^ h1 ^ h2 ^ h3 ^ h4;

h0 = seed & 0xfff;
h0 = ((h0 & 0x1ff) << 3) | ((h0 >> 9) & 0x7);
h1 = (seed >> 12) & 0xfff;
h1 = ((h1 & 0x3f) << 6) | ((h1 >> 6) & 0x3f);
h2 = (seed >> 24) & 0xfff;
h3 = (seed >> 36) & 0xfff;
h3 = ((h3 & 0x3f) << 6) | ((h3 >> 6) & 0x3f);
h4 = (seed >> 48) & 0xfff;
k1 = h0 ^ h1 ^ h2 ^ h3 ^ h4;

/* Algorithm choice for block 0 */
if (sw_r32(RTL931X_L2_CTRL) & BIT(0))
h = k1;
else
h = k0;

/* Algorithm choice for block 1
* Since k0 and k1 are < 4096, adding 4096 will offset the hash into the second
* half of hash-space
* 4096 is in fact the hash-table size 32768 divided by 4 hashes per bucket
* divided by 2 to divide the hash space in 2
*/
if (sw_r32(RTL931X_L2_CTRL) & BIT(1))
h |= (k1 + 4096) << 16;
else
h |= (k0 + 4096) << 16;

return h;
}

The above function is used to hash the destination address (mac
address) for the port. The hash is based on the destination address in
the current L2 header and two random numbers that are stored in
RTL931x_L2_CTRL. Each




NEXT




<s> static void AT91F_SpiEnable(int cs) {
switch(cs) {
case 0:	/* Configure SPI CS0 for Serial DataFlash AT45DBxx */
AT91C_BASE_SPI->SPI_MR &= 0xFFF0FFFF;
AT91C_BASE_SPI->SPI_MR |= ((AT91C_SPI_PCS0_SERIAL_DATAFLASH << 16) & AT91C_SPI_PCS);
break;
case 3:	/* Configure SPI CS3 for Serial DataFlash Card */
/* Set up PIO SDC_TYPE to switch on DataFlash Card and not MMC/SDCard */
AT91C_BASE_PIOB->PIO_PER = AT91C_PIO_PB7;	/* Set in PIO mode */
AT91C_BASE_PIOB->PIO_OER = AT91C_PIO_PB7;	/* Configure in output */
/* Clear Output */
AT91C_BASE_PIOB->PIO_CODR = AT91C_PIO_PB7;
/* Configure PCS */
AT91C_BASE_SPI->SPI_MR &= 0xFFF0FFFF;
AT91C_BASE_SPI->SPI_MR |= ((AT91C_SPI_PCS3_DATAFLASH_CARD<<16) & AT91C_SPI_PCS);
break;
}

/* SPI_Enable */
AT91C_BASE_SPI->SPI_CR = AT91C_SPI_SPIEN;
}

The above function is used to select the SPI-CS line according to the cs (SPI CS line number). We have SPI CS 0 and CS 3 and the code selects the CS based on the cs parameter passed thru to this function. The code also sets up




NEXT




<s> static int oxnas_pcie_setup(int nr, struct pci_sys_data *sys)
{
struct oxnas_pcie *pcie = sys_to_pcie(sys);

pci_add_resource_offset(&sys->resources, &pcie->non_mem, sys->mem_offset);
pci_add_resource_offset(&sys->resources, &pcie->pre_mem, sys->mem_offset);
pci_add_resource_offset(&sys->resources, &pcie->io, sys->io_offset);
pci_add_resource(&sys->resources, &pcie->busn);
if (sys->busnr == 0) { /* default one */
sys->busnr = pcie->busn.start;
}
/* do not use devm_ioremap_resource, it does not like cfg resource */
pcie->cfgbase = devm_ioremap(&pcie->pdev->dev, pcie->cfg.start,
resource_size(&pcie->cfg));
if (!pcie->cfgbase)
return -ENOMEM;

oxnas_pcie_setup_hw(pcie);

return 1;
}

The above function is used to setup PCI Express device during device creation.
Then the config space registers of PCIe root complex will be mapped to user
space as virtual address. Next, the function will copy PCIe hardware registers
and other necessary information to pcie_ops




NEXT




<s> static inline void sata_oxnas_reset_ucode(struct ata_host *ah, int force,
int no_microcode)
{
struct sata_oxnas_host_priv *hd = ah->private_data;

DPRINTK("ENTER\n");
if (no_microcode) {
u32 reg;

sata_oxnas_set_mode(ah, UNKNOWN_MODE, force);
reg = ioread32(hd->core_base + DEVICE_CONTROL);
reg |= DEVICE_CONTROL_ATA_ERR_OVERRIDE;
iowrite32(reg, hd->core_base + DEVICE_CONTROL);
} else {
/* JBOD uCode */
sata_oxnas_set_mode(ah, OXNASSATA_NOTRAID, force);
/* Turn the work around off as it may have been left on by any
* HW-RAID code that we've been working with */
iowrite32(0x0, hd->core_base + PORT_ERROR_MASK);
}
}

The above function is used to reset OXNAS AHCI firmware and SATA hardware.

It calls the following function to reset OXNAS AHCI firmware.

void sata_oxnas_reset_ucode (struct at




NEXT




<s> extern int wpa_supplicant_main(int argc, char **argv);

int main(int argc, char **argv)
{
bool restart = false;
const char *prog = argv[0];

restart:
if (strstr(argv[0], "hostapd"))
return hostapd_main(argc, argv);
else if (strstr(argv[0], "wpa_supplicant"))
return wpa_supplicant_main(argc, argv);

if (!restart && argc > 1) {
argv++;
argc--;
restart = true;
goto restart;
}

fprintf(stderr, "Invalid command.\nUsage: %s wpa_supplicant|hostapd [<arguments>]\n", prog);
return 255;
}

The above function is used to find the location where wpa_supplicant.exe and hostapd.exe are and to make the changes in the above function we need to make use of the below function to include the path where the wpa_supplic




NEXT




<s> ar8327_led_enable_hw_mode_store(struct device *dev,
struct device_attribute *attr,
const char *buf,
size_t size)
{
struct led_classdev *led_cdev = dev_get_drvdata(dev);
struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
u8 pattern;
u8 value;
int ret;

ret = kstrtou8(buf, 10, &value);
if (ret < 0)
return -EINVAL;

spin_lock(&aled->lock);

aled->enable_hw_mode = !!value;
if (aled->enable_hw_mode)
pattern = AR8327_LED_PATTERN_RULE;
else
pattern = AR8327_LED_PATTERN_OFF;

ar8327_led_schedule_change(aled, pattern);

spin_unlock(&aled->lock);

return size;
}

The above function is used to store the value of HW LED (enabled/disabled) into the device tree.
Now we can implement the following command to enable the HW LED or disable it (as per the status the system is in HW or SW)
echo




NEXT




<s> static int rtl83xx_sw_remove(struct platform_device *pdev)
{
/* TODO: */
pr_debug("Removing platform driver for rtl83xx-sw\n");

return 0;
}

The above function is used to clean up resources of rtl83xx-sw module.
However, in some implementations the resources of 802.11b wireless LAN
transceiver are allocated either through sysfs (sysfs/class) or




NEXT




<s> ret_t rtl8367c_getAsicLutFlushType(rtk_uint32* pType)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_L2_FLUSH_CTRL2, RTL8367C_LUT_FLUSH_TYPE_OFFSET,pType);
}

The above function is used to see whether the MCU/CPU is in control of the LUT flush operation in the ASIC.
(For example, when you want to flush a table of MCU (which is very useful for debugging purpose).)

This




NEXT




<s> rtk_api_ret_t rtk_svlan_l2mc2s_get(rtk_mac_t mac, rtk_mac_t macMsk, rtk_vlan_t *pSvid)
{
rtk_api_ret_t retVal;
rtk_uint32 i;
rtk_uint32 l2add,l2Mask;
rtl8367c_svlan_memconf_t svlanMemConf;
rtl8367c_svlan_mc2s_t svlanMC2SConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pSvid)
return RT_ERR_NULL_POINTER;

if (mac.octet[0]!= 1&&mac.octet[1]!=0)
return RT_ERR_INPUT;

l2add = (mac.octet[2] << 24) | (mac.octet[3] << 16) | (mac.octet[4] << 8) | mac.octet[5];
l2Mask = (macMsk.octet[2] << 24) | (macMsk.octet[3] << 16) | (macMsk.octet[4] << 8) | macMsk.octet[5];

for (i = 0; i <= RTL8367C_MC2SIDXMAX; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;

if (TRUE == svlanMC2SConf.valid)
{
if (svlanMC2SConf.format == SVLAN_MC2S_MODE_MAC &&
svlanMC2SConf.sdata==l2add&&
svlanMC2SConf.smask==l2Mask)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(svlanMC2SConf.svidx, &svlanMemConf)) != RT_ERR_OK)
return retVal;
*pSvid = svlanMemConf.vs_svid;

return RT_ERR_OK;
}
}
}

return RT_ERR_OUT_OF_RANGE;
}

The above function is used to retrieve the SVID mapping corresponding to a L2 Mac Address in the Multicast VLAN Index Table. Note that in the Multicast VLAN Index Table, 32 entries can be used with a L3 address while as many as




NEXT




<s> static void prep_eraseblock(void);

static void pad(int size)
{
if ((ofs % size == 0) && (ofs < erasesize))
return;

if (ofs < erasesize) {
memset(buf + ofs, 0xff, (size - (ofs % size)));
ofs += (size - (ofs % size));
}
ofs = ofs % erasesize;
if (ofs == 0) {
while (mtd_block_is_bad(outfd, mtdofs) && (mtdofs < mtdsize)) {
if (!quiet)
fprintf(stderr, "\nSkipping bad block at 0x%08x   ", mtdofs);

mtdofs += erasesize;

/* Move the file pointer along over the bad block. */
lseek(outfd, erasesize, SEEK_CUR);
}
mtd_erase_block(outfd, mtdofs);
write(outfd, buf, erasesize);
mtdofs += erasesize;
}
}

The above function is used to pad and write at the mtdofs offset, but this needs to be done only if the offset is not a multiple of erasesize bytes. Also, notice how we have an erasesize global variable. But that’s not a problem




NEXT




<s> int rtcl_init_sram(void)
{
struct gen_pool *sram_pool;
phys_addr_t sram_pbase;
unsigned long sram_vbase;
struct device_node *node;
struct platform_device *pdev = NULL;
void *dram_start;
int dram_size;
const char *wrn = ", rate setting disabled.\n";

switch (rtcl_ccu->soc) {
case SOC_RTL838X:
dram_start = &rtcl_838x_dram_start;
dram_size = rtcl_838x_dram_size;
break;
case SOC_RTL839X:
dram_start = &rtcl_839x_dram_start;
dram_size = rtcl_839x_dram_size;
break;
default:
return -ENXIO;
}

for_each_compatible_node(node, NULL, "mmio-sram") {
pdev = of_find_device_by_node(node);
if (pdev) {
of_node_put(node);
break;
}
}

if (!pdev) {
dev_warn(&rtcl_ccu->pdev->dev, "no SRAM device found%s", wrn);
return -ENXIO;
}

sram_pool = gen_pool_get(&pdev->dev, NULL);
if (!sram_pool) {
dev_warn(&rtcl_ccu->pdev->dev, "SRAM pool unavailable%s", wrn);
goto err_put_device;
}

sram_vbase = gen_pool_alloc(sram_pool, dram_size);
if (!sram_vbase) {
dev_warn(&rtcl_ccu->pdev->dev, "can not allocate SRAM%s", wrn);
goto err_put_device;
}

sram_pbase = gen_pool_virt_to_phys(sram_pool, sram_vbase);
memcpy((void *)sram_pbase, dram_start, dram_size);
flush_icache_range((unsigned long)sram_pbase, (unsigned long)(sram_pbase + dram_size));

switch (rtcl_ccu->soc) {
case SOC_RTL838X:
RTCL_SRAM_FUNC(838x, sram_pbase, set_rate);
break;
case SOC_RTL839X:
RTCL_SRAM_FUNC(839x, sram_pbase, set_rate);
break;
}

rtcl_ccu->sram.pmark = (int *)((void *)sram_pbase + (dram_size - 4));
rtcl_ccu->sram.vbase = sram_vbase;

return 0;

err_put_device:
put_device(&pdev->dev);

return -ENXIO;
}

The above function is used to initialize the SRAM for 83xx and 839x processors. The SRAM is defined as a linear array with a fixed length. During the initialization, it is read from DRAM and copied to the SRAM address space




NEXT




<s> swlib_connect(const char *name)
{
struct swlib_scan_arg arg;

if (!refcount) {
if (swlib_priv_init() < 0)
return NULL;
};

arg.head = NULL;
arg.ptr = NULL;
arg.name = name;
swlib_call(SWITCH_CMD_GET_SWITCH, add_switch, NULL, &arg);

if (!refcount)
swlib_priv_free();

return arg.head;
}

The above function is used to scan the switchlist, looking for a switch with a given name. It requires the switch module be built into the switch and it requires a switch with the same name be installed so that scanning is possible.

If the function finds a matching




NEXT




<s> ret_t rtl8367c_getAsicRemarkingDscpAbility(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REMARKING_CTRL_REG, RTL8367C_REMARKING_DSCP_ENABLE_OFFSET, pEnabled);
}

The above function is used to retrieve information on if DSCP marking is supported.

If it is supported, the function returns 0 if it encounters an error as it goes and retrieves the information from the chipset.
If it is not supported,




NEXT




<s> static void ssb_fbs_fixup(struct ssb_fbs *priv, u16 *sprom)
{
struct device_node *node = priv->dev->of_node;
u32 fixups, off, val;
int i = 0;

if (!of_get_property(node, "brcm,sprom-fixups", &fixups))
return;

fixups /= sizeof(u32);

dev_info(priv->dev, "patching SPROM with %u fixups...\n", fixups >> 1);

while (i < fixups) {
if (of_property_read_u32_index(node, "brcm,sprom-fixups",
i++, &off)) {
dev_err(priv->dev, "error reading fixup[%u] offset\n",
i - 1);
return;
}

if (of_property_read_u32_index(node, "brcm,sprom-fixups",
i++, &val)) {
dev_err(priv->dev, "error reading fixup[%u] value\n",
i - 1);
return;
}

dev_dbg(priv->dev, "fixup[%d]=0x%04x\n", off, val);

sprom[off] = val;
}
}

The above function is used to fixup device-specific SPROM sections.
Right now, it simply patches the brcm,sprom-fixups property in DT. There
has to be some magic behind this function, as that data is not shown in DT.




NEXT




<s> static ssize_t sc_tag_show_boolts(const u8 *pld, u16 pld_len, char *buf,
const struct sc_boolts *bts)
{
const char *fmt;
char *out = buf;
u32 data;	// cpu-endian

if (sizeof(data) != pld_len)
return -EINVAL;

read_lock(&sc_bufrwl);
data = *(u32 *)pld;		// pld aliases sc_buf
read_unlock(&sc_bufrwl);

fmt = (data) ? "%s [%s]\n" : "[%s] %s\n";
out += sprintf(out, fmt, bts->strfalse, bts->strtrue);

return out - buf;
}

The above function is used to check the current status of a particular boolean.

You will find more about boolean tags in the tags.h file.

There are two boolean tags, namely the BOOLTS and the TIMED_BOOLTS. Each boolean has two




NEXT




<s> static inline int rtl838x_port_iso_ctrl(int p)
{
return RTL838X_PORT_ISO_CTRL(p);
}

The above function is used to get and set port's Iso Ctrl. RTL838X_PORT_ISO_CTRL(p) returns the Iso CTL of port p, it's equal to 1 when the RTL838




NEXT




<s> static int i2c_inb(int ack)
{
int i;
unsigned int indata = 0;

/* assert: scl is low */

sdahi();
for (i = 0; i < 8; i++) {
if (sclhi() < 0) {
return -ETIMEDOUT;
};
indata *= 2;
if (getsda())
indata |= 0x01;
scllo();
}
if (ack) {
sdalo();
} else {
sdahi();
}

if (sclhi() < 0) {
sdahi();
return -ETIMEDOUT;
}
scllo();
sdahi();

if (rtc_debug)
printk(KERN_DEBUG "i2c_inb() -> 0x%02x\n", indata);

/* assert: scl is low */
return indata & 0xff;
}

The above function is used to read a byte from the RTC. This is a very basic i2c function and can be used as a basis for your own function.

static void rtc_set_time(time_t * t)
{
	




NEXT




<s> wpas_bss_reload(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);

if (wpa_supplicant_reload_configuration(wpa_s))
return UBUS_STATUS_UNKNOWN_ERROR;
else
return 0;
}

The above function is used to make a call to the reload configuration API(call is made when /etc/wpa_supplicant.conf file is reconfigured) of the WPA supplicant from the user space.

The same function is implemented




NEXT




<s> static void get_symbol_str(struct gstr *r, struct symbol *sym,
struct list_head *head)
{
struct property *prop;

if (sym && sym->name) {
str_printf(r, "Symbol: %s [=%s]\n", sym->name,
sym_get_string_value(sym));
str_printf(r, "Type  : %s\n", sym_type_name(sym->type));
if (sym->type == S_INT || sym->type == S_HEX) {
prop = sym_get_range_prop(sym);
if (prop) {
str_printf(r, "Range : ");
expr_gstr_print(prop->expr, r);
str_append(r, "\n");
}
}
}

/* Print the definitions with prompts before the ones without */
for_all_properties(sym, prop, P_SYMBOL) {
if (prop->menu->prompt) {
get_def_str(r, prop->menu);
get_prompt_str(r, prop->menu->prompt, head);
}
}

for_all_properties(sym, prop, P_SYMBOL) {
if (!prop->menu->prompt) {
get_def_str(r, prop->menu);
get_dep_str(r, prop->menu->dep, "  Depends on: ");
}
}

get_symbol_props_str(r, sym, P_SELECT, "Selects: ");
if (sym->rev_dep.expr) {
expr_gstr_print_revdep(sym->rev_dep.expr, r, yes, "Selected by [y]:\n");
expr_gstr_print_revdep(sym->rev_dep.expr, r, mod, "Selected by [m]:\n");
expr_gstr_print_revdep(sym->rev_dep.expr, r, no, "Selected by [n]:\n");
}

get_symbol_props_str(r, sym, P_IMPLY, "Implies: ");
if (sym->implied.expr) {
expr_gstr_print_revdep(sym->implied.expr, r, yes, "Implied by [y]:\n");
expr_gstr_print_revdep(sym->implied.expr, r, mod, "Implied by [m]:\n");
expr_gstr_print_revdep(sym->implied.expr, r, no, "Implied by [n]:\n");
}

str_append(r, "\n\n");
}

The above function is used to print some info on a module selection
symbol (M_SELECT). The function is called from the various menu_select
implementations in module_menu_select.C.</s>




NEXT




<s> static void ath79_mii1_ctrl_set_if(struct ag71xx *ag)
{
unsigned int mii_if;

switch (ag->phy_if_mode) {
case PHY_INTERFACE_MODE_RMII:
mii_if = AR71XX_MII1_CTRL_IF_RMII;
break;
case PHY_INTERFACE_MODE_RGMII:
case PHY_INTERFACE_MODE_RGMII_ID:
case PHY_INTERFACE_MODE_RGMII_RXID:
case PHY_INTERFACE_MODE_RGMII_TXID:
mii_if = AR71XX_MII1_CTRL_IF_RGMII;
break;
default:
WARN(1, "Impossible PHY mode defined.\n");
return;
}

ath79_mii_ctrl_set_if(ag, mii_if);
}

The above function is used to switch between the modes.
This method is used to implement the PHY switching in the device driver.</s>




NEXT




<s> static int bmemcmp(const void *av, const void *bv, size_t bits)
{
const uint8_t *a = av, *b = bv;
size_t bytes = bits / 8;
bits %= 8;

int res = memcmp(a, b, bytes);
if (res == 0 && bits > 0)
res = (a[bytes] >> (8 - bits)) - (b[bytes] >> (8 - bits));

return res;
}

The above function is used to compare bit streams that are not a multiple of 32 bits.
The purpose is to compare a memory block and a part of a memory block.
For example:
a - memory block to be compared
b - a part of memory




NEXT




<s> static void rtl8214fc_sfp_remove(void *upstream)
{
struct phy_device *phydev = upstream;

rtl8214fc_media_set(phydev, false);
}

The above function is used to power down SFP+ link, as shown below in Fig. 4.

Figure 4: SFP power management

A link down event can be indicated in two ways:
link down event (e.g., loss of




NEXT




<s> rtk_api_ret_t rtk_ptp_intControl_set(rtk_ptp_intType_t type, rtk_enable_t enable)
{
rtk_api_ret_t retVal;
rtk_uint32 mask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type>=PTP_INT_TYPE_END)
return RT_ERR_INPUT;

if (PTP_INT_TYPE_ALL!=type)
{
if ((retVal = rtl8367c_getAsicEavInterruptMask(&mask)) != RT_ERR_OK)
return retVal;

if (ENABLED == enable)
mask = mask | (1<<type);
else if (DISABLED == enable)
mask = mask & ~(1<<type);
else
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicEavInterruptMask(mask)) != RT_ERR_OK)
return retVal;
}
else
{
if (ENABLED == enable)
mask = RTK_PTP_INTR_MASK;
else if (DISABLED == enable)
mask = 0;
else
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicEavInterruptMask(mask)) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to enable or disable the selected PTP interrupt


rtk_api_ret_t rtk_ptp_intType_get(rtk_ptp_intType_t *type)
{
rtk_api




NEXT




<s> int AT91F_MCI_MMC_SelectCard(AT91PS_MciDevice pMCI_Device, unsigned int relative_card_address)
{
int status;

//* Check if the MMC card chosen is already the selected one
status = AT91F_MCI_GetStatus(pMCI_Device,relative_card_address);

if (status < 0)
return AT91C_CARD_SELECTED_ERROR;

if ((status & AT91C_SR_CARD_SELECTED) == AT91C_SR_CARD_SELECTED)
return AT91C_CARD_SELECTED_OK;

//* Search for the MMC Card to be selected, status = the Corresponding Device Number
status = 0;
while( (pMCI_Device->pMCI_DeviceFeatures[status].Relative_Card_Address != relative_card_address)
&& (status < AT91C_MAX_MCI_CARDS) )
status++;

if (status > AT91C_MAX_MCI_CARDS)
return AT91C_CARD_SELECTED_ERROR;

if (AT91F_MCI_SendCommand( pMCI_Device,
AT91C_SEL_DESEL_CARD_CMD,
pMCI_Device->pMCI_DeviceFeatures[status].Relative_Card_Address << 16) == AT91C_CMD_SEND_OK)
return AT91C_CARD_SELECTED_OK;
return AT91C_CARD_SELECTED_ERROR;
}

The above function is used to select a (SD, MMC) card on our SDHC/MCV host controller.</s>




NEXT




<s> static rtk_api_ret_t _rtk_port_FiberModeAbility_get(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
{
rtk_api_ret_t   retVal;
rtk_uint32      data, regData;

/* Check Combo port or not */
RTK_CHK_PORT_IS_COMBO(port);

memset(pAbility, 0x00, sizeof(rtk_port_phy_ability_t));

/* Flow Control */
if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_FRC_REG4_OFFSET, 1)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_FRC_REG4_FIB100_OFFSET, 0)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, 0x0044)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x0080)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_SDS_INDACS_DATA, &regData)) != RT_ERR_OK)
return retVal;

if(regData & (0x0001 << 8))
pAbility->AsyFC = 1;

if(regData & (0x0001 << 7))
pAbility->FC = 1;

/* Speed ability */
if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_FRC_MODE_OFFSET, &data)) != RT_ERR_OK)
return retVal;

if(data == 0)
{
pAbility->AutoNegotiation = 1;
pAbility->Full_1000 = 1;
pAbility->Full_100 = 1;
}
else
{
if ((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_MODE_MASK, &data)) != RT_ERR_OK)
return retVal;

if(data == 4)
{
pAbility->Full_1000 = 1;

if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_FIB0_CFG00, &data)) != RT_ERR_OK)
return retVal;

if(data & 0x1000)
pAbility->AutoNegotiation = 1;
else
pAbility->AutoNegotiation = 0;
}
else if(data == 5)
pAbility->Full_100 = 1;
else
return RT_ERR_FAILED;
}

return RT_ERR_OK;
}

The above function is used to read the value of port’s fiber mode ability.
By using this function, the application can check if the current port can enter the certain fiber mode or not</s>




NEXT




<s> static void rtl8366_smi_read_bits(struct rtl8366_smi *smi, u32 len, u32 *data)
{
unsigned int sda = smi->gpio_sda;
unsigned int sck = smi->gpio_sck;

gpio_direction_input(sda);

for (*data = 0; len > 0; len--) {
u32 u;

rtl8366_smi_clk_delay(smi);

/* clocking */
gpio_set_value(sck, 1);
rtl8366_smi_clk_delay(smi);
u = !!gpio_get_value(sda);
gpio_set_value(sck, 0);

*data |= (u << (len - 1));
}

gpio_direction_output(sda, 0);
}

The above function is used to read the clock bits out of a GPIO. For example, in order to read a 4 bit command:

u8 command = 0;

rtl8366_smi_read_bits(smi,




NEXT




<s> static void rtl931x_pie_lookup_enable(struct rtl838x_switch_priv *priv, int index)
{
int block = index / PIE_BLOCK_SIZE;

sw_w32_mask(0, BIT(block), RTL931X_PIE_BLK_LOOKUP_CTRL);
}

The above function is used to select the block of the PIE table that needs to be updated and the following function is used to update the PIE tables

static void rtl931x_pie_set(struct rtl838x_switch_




NEXT




<s> ret_t rtl8367c_setAsicSdsReg(rtk_uint32 sdsId, rtk_uint32 sdsReg, rtk_uint32 sdsPage,  rtk_uint32 value)
{
rtk_uint32 retVal;

if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, value)) != RT_ERR_OK)
return retVal;

if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (sdsPage<<5) | sdsReg)) != RT_ERR_OK)
return retVal;

if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0|sdsId)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;

}

The above function is used to writting data  into SDS RAM.

The below figure shows the detailed of SDS register field

The 2nd field is used to select address or data of SDS RAM by which the write data into SDS RAM is




NEXT




<s> static int esw_get_port_recv_badgood(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
int idx = val->port_vlan;
int shift = attr->id == RT305X_ESW_ATTR_PORT_RECV_GOOD ? 0 : 16;
u32 reg;

if (idx < 0 || idx >= RT305X_ESW_NUM_LANWAN)
return -EINVAL;
reg = esw_r32(esw, RT305X_ESW_REG_PXPC(idx));
val->value.i = (reg >> shift) & 0xffff;

return 0;
}

The above function is used to get the port status, such as, the port receive good and bad traffic count.</s>




NEXT




<s> static int clk_mt7988_apmixed_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;

clk_data = mtk_alloc_clk_data(ARRAY_SIZE(plls));
if (!clk_data)
return -ENOMEM;

mtk_clk_register_plls(node, plls, ARRAY_SIZE(plls), clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_apmixed_data;
}
return r;

free_apmixed_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to allocate and register the PLL in the power-domain structure. However, the registering fails since there is no corresponding driver defined for it. This issue can be verified by following the log from the log-file.

# dmesg




NEXT




<s> extern u64 uevent_next_seqnum(void);

#define BH_MAP(_code, _name)		\
{				\
.code = (_code),	\
.name = (_name),	\
}

The above function is used to return the next sequence
number.

The bhmap array is an array of elements that define the
sequence of events needed to initialize a block of
hierarchical block devices (i.e. raid devices with
hier




NEXT




<s> rtk_api_ret_t rtk_rate_egrQueueBwCtrlRate_set(rtk_port_t port, rtk_qid_t queue, rtk_meter_id_t index)
{
rtk_api_ret_t retVal;
rtk_uint32 offset_idx;
rtk_uint32 phy_port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (queue >= RTK_MAX_NUM_OF_QUEUE)
return RT_ERR_QUEUE_ID;

if (index > RTK_MAX_METER_ID)
return RT_ERR_FILTER_METER_ID;

phy_port = rtk_switch_port_L2P_get(port);
if (index < ((phy_port%4)*8) ||  index > (7 + (phy_port%4)*8))
return RT_ERR_FILTER_METER_ID;

offset_idx = index - ((phy_port%4)*8);

if ((retVal=rtl8367c_setAsicAprMeter(phy_port,queue,offset_idx))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the weight of the packet rate controlling module when the packet enters the egress queue. The value range is from 0 to 7.

rtk_api_ret_t rtk_rate_egrQueueBwCtrlRate




NEXT




<s> const char *sym_get_string_default(struct symbol *sym)
{
struct property *prop;
struct symbol *ds;
const char *str;
tristate val;

sym_calc_visibility(sym);
sym_calc_value(modules_sym);
val = symbol_no.curr.tri;
str = symbol_empty.curr.val;

/* If symbol has a default value look it up */
prop = sym_get_default_prop(sym);
if (prop != NULL) {
switch (sym->type) {
case S_BOOLEAN:
case S_TRISTATE:
/* The visibility may limit the value from yes => mod */
val = EXPR_AND(expr_calc_value(prop->expr), prop->visible.tri);
break;
default:
/*
* The following fails to handle the situation
* where a default value is further limited by
* the valid range.
*/
ds = prop_get_symbol(prop);
if (ds != NULL) {
sym_calc_value(ds);
str = (const char *)ds->curr.val;
}
}
}

/* Handle select statements */
val = EXPR_OR(val, sym->rev_dep.tri);

/* transpose mod to yes if modules are not enabled */
if (val == mod)
if (!sym_is_choice_value(sym) && modules_sym->curr.tri == no)
val = yes;

/* transpose mod to yes if type is bool */
if (sym->type == S_BOOLEAN && val == mod)
val = yes;

/* adjust the default value if this symbol is implied by another */
if (val < sym->implied.tri)
val = sym->implied.tri;

switch (sym->type) {
case S_BOOLEAN:
case S_TRISTATE:
switch (val) {
case no: return "n";
case mod: return "m";
case yes: return "y";
}
case S_INT:
case S_HEX:
return str;
case S_STRING:
return str;
case S_UNKNOWN:
break;
}
return "";
}

The above function is used to return the default value for a symbol for display in a source file. However, this does not take into account of a symfile that could be linked into this source file. The default value for the variable x for example could be 2 which would




NEXT




<s> void rtl_table_release(struct table_reg *r)
{
if (!r)
return;

/*	pr_info("Unlocking %08x\n", (u32)r); */
mutex_unlock(&r->lock);
/*	pr_info("Unlock done\n"); */
}

The above function is used to remove the lock on a regulator table entry.

The mutex lock operation in the rtl8197 driver is called
rtl_table_acquire() and it looks like this:

struct table_reg *




NEXT




<s> ar8xxx_sw_get_mirror_rx_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
val->value.i = priv->mirror_rx;
return 0;
}

The above function is used to query the mirror receive status.
But in current kernel, there is no switch_val structure in
linux/switch.h. Then, how can I update the new header file without
hiding too many kernel files？

I used




NEXT




<s> static void wpas_ubus_ref_dec(void)
{
ctx_ref--;
if (!ctx)
return;

if (ctx_ref)
return;

uloop_fd_delete(&ctx->sock);
ubus_free(ctx);
ctx = NULL;
}

The above function is used to decrement the reference counter in the context struct and perform cleanup in case of the reference counter reaching zero. The UBUS driver implementation provides a reference counter as part of passing context struct which is incremented while establishing the control socket and decremented when




NEXT




<s> ret_t rtl8367c_setAsicI2C_checkBusIdle(void)
{
rtk_uint32 regData;
ret_t retVal;

if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_M_I2C_BUS_IDLE_OFFSET, &regData)) != RT_ERR_OK)
return retVal;

if(regData == 0x0001)
return RT_ERR_OK; /*i2c is idle*/
else
return RT_ERR_BUSYWAIT_TIMEOUT; /*i2c is busy*/
}

The above function is used to check whether the i2c has been fully bus idle or not, and there is some looping mechanism in that check.

I got two questions:

1. What’s the meaning of Bus-IDLE and I get it




NEXT




<s> void gsw_debug_proc_exit(void)
{
if (proc_esw_cnt)
remove_proc_entry(PROCREG_ESW_CNT, proc_reg_dir);
}

The above function is used to stop register the e-sw counter in proc_reg_dir,
which is created by create_proc_reg_dir().
But it may cause a bug when the system is rebooting.
Since the debug switch is always kept




NEXT




<s> static void aes_cbcmac_exit_tfm(struct crypto_tfm *tfm)
{
struct aes_ctx *mctx = crypto_tfm_ctx(tfm);
kfree(mctx->temp);
}

The above function is used to destroy the AES-CCM context which is dynamically allocated on the heap. This function is currently called even if the device is in device suspend.

On devices with a limited amount of RAM, this could lead to a “dead”




NEXT




<s> void str_printf(struct gstr *gs, const char *fmt, ...)
{
va_list ap;
char s[10000]; /* big enough... */
va_start(ap, fmt);
vsnprintf(s, sizeof(s), fmt, ap);
str_append(gs, s);
va_end(ap);
}

The above function is used to perform printf formatting on a string in
pstore. The problem is that in some cases of long strings, the string
won't fit in s (10,000 is a rather arbitrary number). The current
implementation




NEXT




<s> static int ip17xx_get_enable_vlan(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);

val->value.i = state->vlan_enabled;
return 0;
}

The above function is used to get the value of a switch attribute named enable_vlan. The state parameter is used to represent the state of the switch device. val is a pointer to a union called switch_val, which is used to store the value of the attribute.




NEXT




<s> void __init red_15w_rev1_pic_init(void)
{
struct mpic *mpic;

mpic = mpic_alloc(NULL, 0,
MPIC_BIG_ENDIAN | MPIC_SINGLE_DEST_CPU,
0, 256, " OpenPIC  ");

BUG_ON(mpic == NULL);
mpic_init(mpic);
}

The above function is used to allocate the pic hardware and
registers it as an interupt source with the processor.

The function returns the pointer to mpic structure, and sets up a
data structure pointed by 'struct mpic *mpic' with the following




NEXT




<s> static int ubnt_ledbar_remove(struct i2c_client *client)
#else
static void ubnt_ledbar_remove(struct i2c_client *client)
#endif
{
struct ubnt_ledbar *ledbar = i2c_get_clientdata(client);

mutex_destroy(&ledbar->lock);

#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
return 0;
#endif
}

The above function is used to deregister the driver when the device is removed. Note that there is a conditional check for if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0), this version check is required to make the code




NEXT




<s> static int bcm6348_pci_write(struct pci_bus *bus, unsigned int devfn,
int where, int size, u32 val)
{
int type;

type = bus->parent ? 1 : 0;

if (type == 0 && PCI_SLOT(devfn) == CARDBUS_PCI_IDSEL)
return PCIBIOS_DEVICE_NOT_FOUND;

return bcm6348_do_cfg_write(type, bus->number, devfn,
where, size, val);
}

The above function is used to write value to specific I/O address
register.

However, when I debug the code, I notice that the ‘‘type‘‘ parameter
always returns 1 (= PCI_TYPE_BRIDGE). Why is that so




NEXT




<s> void dc_ep_icu_en_intr(struct dc_ep_priv *priv, u32 bits)
{
wr32_mask(0, bits, ICU_IMER);
}

The above function is used to enable interrupts on interrupts and event registers. If the interrupt is enabled a bit in ICU_IMER is set to 1. DC code uses the same interrupt number(ICU) to handle multiple interrupts.

I would




NEXT




<s> static int rtl8367_led_op_select_parallel(struct rtl8366_smi *smi)
{
int err;

REG_WR(smi, RTL8367_LED_SYS_CONFIG_REG, 0x1472);
return 0;
}

The above function is used to configure the LT8367 to use the parallel
LED driver by selecting bit 02 of the LED_SYS_CONFIG register.

In the rtl8366_led_op_set_status function,




NEXT




<s> int rtl9300_sds_check_calibration(int sds_num, phy_interface_t phy_mode)
{
u32 errors1, errors2;

rtl9300_sds_sym_err_reset(sds_num, phy_mode);
rtl9300_sds_sym_err_reset(sds_num, phy_mode);

/* Count errors during 1ms */
errors1 = rtl9300_sds_sym_err_get(sds_num, phy_mode);
mdelay(1);
errors2 = rtl9300_sds_sym_err_get(sds_num, phy_mode);

switch (phy_mode) {
case PHY_INTERFACE_MODE_XGMII:

if ((errors2 - errors1 > 100) ||
(errors1 >= 0xffff00) || (errors2 >= 0xffff00)) {
pr_info("%s XSGMII error rate too high\n", __func__);
return 1;
}
break;
case PHY_INTERFACE_MODE_10GBASER:
if (errors2 > 0) {
pr_info("%s 10GBASER error rate too high\n", __func__);
return 1;
}
break;
default:
return 1;
}

return 0;
}

The above function is used to test the symmetry of TX and RX errors.
(1) If error transmission does not exist during operation, it can be inferred that the SDS mode may be abnormal.
(2) If the number of errors received during operation




NEXT




<s> static void g977_get_snr(int fd, DSL_AccessDir_t direction) {
IOCTL_DIR_DELT(DSL_G997_DeltSnr_t, DSL_FIO_G997_DELT_SNR_GET, direction, DSL_DELT_DATA_SHOWTIME);

m_u32("groupsize", out.data.nGroupSize);
m_u32("groups", out.data.deltSnr.nNumData);

void *c = blobmsg_open_array(&b, "data");

// SNR -32 ... 95 dB
for (uint16_t i  = 0  ; i < out.data.deltSnr.nNumData ; i++)
if (out.data.deltSnr.nNSCData[i] != 255 && out.data.deltSnr.nNSCData[i] != 0)
m_double("", -32 + (double)out.data.deltSnr.nNSCData[i] / 2);
else
m_null();

blobmsg_close_array(&b, c);
}

The above function is used to get downstream SNR.

You can check if NSC is implemented (noise suppression code) in your
hardware by looking at the following line. If it is present, then you can assume
noise suppression is




NEXT




<s> rtk_api_ret_t rtk_mirror_vlanLeaky_get(rtk_enable_t *pTxenable, rtk_enable_t *pRxenable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if( (NULL == pTxenable) || (NULL == pRxenable) )
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortMirrorVlanTxLeaky(pTxenable)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicPortMirrorVlanRxLeaky(pRxenable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the value of mirror vlan tx/rx leaky flag

To enable the interface with the specific VLAN, you call the function as :

rtk_enable_t enable;
rtk_enable_t *p




NEXT




<s> ret_t rtl8367c_getAsicAcl(rtk_uint32 port, rtk_uint32* pEnabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_ACL_ENABLE_REG, port, pEnabled);
}

The above function is used to check whether a given physical port is assigned as ACL port.

ret_t rtl8367c_setAsicAclMask(rtk_uint32 port, rtk_uint32 enable)





NEXT




<s> ret_t rtl8367c_getAsicPortDos(rtk_uint32 type, rtk_uint32* pDrop)
{
if(type >= DOS_END)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_getAsicRegBit(RTL8367C_REG_DOS_CFG, RTL8367C_DROP_DAEQSA_OFFSET + type,pDrop);
}

The above function is used to get the value of the DOS register according to the DOType value specified.

The following 4 tables list the corresponding DOS register bit number and the corresponding DOType value of each table register bit number.

Table 4.




NEXT




<s> static int rtl8366rb_sw_set_blinkrate(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

if (val->value.i >= 6)
return -EINVAL;

return rtl8366_smi_rmwr(smi, RTL8366RB_LED_BLINKRATE_REG,
RTL8366RB_LED_BLINKRATE_MASK,
val->value.i);
}

The above function is used to set the blinkrate of the LED by the user space application. The user can call ioctl command (see sw008.txt) to set 1, 2, or 3 times blink rate. The following is a screenshot




NEXT




<s> static void print_buttons(WINDOW * dialog, int height, int width, int selected)
{
int x = width / 2 - 11;
int y = height - 2;

print_button(dialog, "  Ok  ", y, x, selected == 0);
print_button(dialog, " Help ", y, x + 14, selected == 1);

wmove(dialog, y, x + 1 + 14 * selected);
wrefresh(dialog);
}

The above function is used to draw a "buttons" at the bottom of this dialog.
The 1st argument is the window object of the dialog, the 2nd the height and
the 3rd the width of the dialog. The 4th argument is




NEXT




<s> inline void rtl931x_exec_tbl0_cmd(u32 cmd)
{
sw_w32(cmd, RTL931X_TBL_ACCESS_CTRL_0);
do { } while (sw_r32(RTL931X_TBL_ACCESS_CTRL_0) & (1 << 20));
}

The above function is used to write an access control to table control register with value 0.

For the first time, I saw this kind of register usage as well. I guess that it’s very likely to see some kind of side channel attack or fault injection as




NEXT




<s> static void handle_f4(int *key, struct menu *current_item);
static void handle_f5(int *key, struct menu *current_item);
static void handle_f6(int *key, struct menu *current_item);
static void handle_f7(int *key, struct menu *current_item);
static void handle_f8(int *key, struct menu *current_item);
static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to set which key is which.  When the menu
screen is active, we check which key pressed.  If we haven't handled the
key press yet, we use the below table to determine what should be done.

static int




NEXT




<s> static void write_cr(void __iomem *phy_base, u16 data, u16 address)
{
iowrite32((u32)address, phy_base + PHY_STAT);
wait_cr_ack(phy_base);
iowrite32((data | CR_CAP_DATA), phy_base + PHY_DATA);
wait_cr_ack(phy_base);
iowrite32(CR_WRITE_ENABLE, phy_base + PHY_DATA);
wait_cr_ack(phy_base);
}

The above function is used to write data to a given address and then enable the write as per the documentation: http://forum.xilinx.com/t5/A/bd-p/401/pg/3#140375




NEXT




<s> static void ag71xx_ethtool_get_stats(struct net_device *ndev,
struct ethtool_stats *stats, u64 *data)
{
struct ag71xx *ag = netdev_priv(ndev);
int i;

for (i = 0; i < ARRAY_SIZE(ag71xx_statistics); i++)
*data++ = ag71xx_rr(ag, ag71xx_statistics[i].offset)
& ag71xx_statistics[i].mask;
}

The above function is used to read all the statistics registers
in the ethtool get_stats operation. The code reads 8 bytes
(64bits) from the ag71xx device and populates them into an array
with the same names as in the




NEXT




<s> int rtl8366_smi_probe_plat(struct platform_device *pdev, struct rtl8366_smi *smi)
{
struct rtl8366_platform_data *pdata = pdev->dev.platform_data;

if (!pdev->dev.platform_data) {
dev_err(&pdev->dev, "no platform data specified\n");
return -EINVAL;
}

smi->gpio_sda = pdata->gpio_sda;
smi->gpio_sck = pdata->gpio_sck;
smi->hw_reset = pdata->hw_reset;

return 0;
}

The above function is used to probe the GPIO on the platform. This allows the driver to determine the correct GPIO for RX24421. You can choose to connect RX24421 to any GPIO that you want.</s>




NEXT




<s> void MD5_Update (mdContext, inBuf, inLen)
MD5_CTX *mdContext;
unsigned char *inBuf;
unsigned int inLen;
{
UINT4 in[16];
int mdi;
unsigned int i, ii;

/* compute number of bytes mod 64 */
mdi = (int)((mdContext->i[0] >> 3) & 0x3F);

/* update number of bits */
if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
mdContext->i[1]++;
mdContext->i[0] += ((UINT4)inLen << 3);
mdContext->i[1] += ((UINT4)inLen >> 29);

while (inLen--) {
/* add new character to buffer, increment mdi */
mdContext->in[mdi++] = *inBuf++;

/* transform if necessary */
if (mdi == 0x40) {
for (i = 0, ii = 0; i < 16; i++, ii += 4)
in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
(((UINT4)mdContext->in[ii+2]) << 16) |
(((UINT4)mdContext->in[ii+1]) << 8) |
((UINT4)mdContext->in[ii]);
Transform (mdContext->buf, in);
mdi = 0;
}
}
}

The above function is used to update with new data (and data that has not been used yet) to the buffer. It is used when calling the MD5_Transform() function at the end of the function (and only the buffer that has been updated). This will be covered




NEXT




<s> static int md5_update(struct shash_desc *desc, const u8 *data, unsigned int len)
{
struct md5_ctx *mctx = shash_desc_ctx(desc);
const u32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);

mctx->byte_count += len;

if (avail > len) {
memcpy((char *)mctx->block + (sizeof(mctx->block) - avail),
data, len);
return 0;
}

memcpy((char *)mctx->block + (sizeof(mctx->block) - avail),
data, avail);

md5_transform_helper(mctx);
data += avail;
len -= avail;

while (len >= sizeof(mctx->block)) {
memcpy(mctx->block, data, sizeof(mctx->block));
md5_transform_helper(mctx);
data += sizeof(mctx->block);
len -= sizeof(mctx->block);
}

memcpy(mctx->block, data, len);
return 0;
}

The above function is used to update the MD5 hash. It takes a desc argument which has the context of the hash function stored inside it. It calls the md5_transform_helper function to help out in updating the MD5 hash.</s>




NEXT




<s> static void print_page(WINDOW *win, int height, int width, update_text_fn
update_text, void *data);
static void print_line(WINDOW *win, int row, int width);
static char *get_line(void);
static void print_position(WINDOW * win);

static int hscroll;
static int begin_reached, end_reached, page_length;
static char *buf;
static char *page;

/*
* refresh window content
*/
static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
int cur_y, int cur_x, update_text_fn update_text,
void *data)
{
print_page(box, boxh, boxw, update_text, data);
print_position(dialog);
wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
wrefresh(dialog);
}

The above function is used to set the text area of the window. The main
functionality is the print_page(). It handles the screen buffer for printing
the page in the dialog. It takes the height of the screen and the width
and a function pointer with data




NEXT




<s> bool mapping_block_in_range(int block, int *start, int *end)
{
const __be32 *cur = bmtd.remap_range;
u32 addr = block << bmtd.blk_shift;
int i;

if (!cur || !bmtd.remap_range_len) {
*start = 0;
*end = bmtd.total_blks;
return true;
}

for (i = 0; i < bmtd.remap_range_len; i++, cur += 2) {
if (addr < be32_to_cpu(cur[0]) || addr >= be32_to_cpu(cur[1]))
continue;

*start = be32_to_cpu(cur[0]);
*end = be32_to_cpu(cur[1]);
return true;
}

return false;
}

The above function is used to determine if the L-physical block number belongs to a remapping range. You can view all remapping ranges as follows. The default file is `/mnt/d2`, so I won't show it here again (see [




NEXT




<s> rtk_api_ret_t rtk_trunk_port_get(rtk_trunk_group_t trk_gid, rtk_portmask_t *pTrunk_member_portmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Trunk Group Valid */
RTK_CHK_TRUNK_GROUP_VALID(trk_gid);

if ((retVal = rtl8367c_getAsicTrunkingGroup(trk_gid, &pmsk)) != RT_ERR_OK)
return retVal;

pmsk = pmsk << RTL8367C_PORT_TRUNK_GROUP_MASK_OFFSET(trk_gid);

if((retVal = rtk_switch_portmask_P2L_get(pmsk, pTrunk_member_portmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve TRUNK member ports of a specified Group.

Example:

rtk_portmask_t TrunkMemPortmask;

int main(t)
{
int i;

for(i = 1




NEXT




<s> static void ag71xx_setup_gmac_956x(struct device_node *np, void __iomem *base)
{
u32 val = __raw_readl(base + QCA956X_GMAC_REG_ETH_CFG);

ag71xx_of_bit(np, "switch-phy-swap", &val, QCA956X_ETH_CFG_SW_PHY_SWAP);
ag71xx_of_bit(np, "switch-phy-addr-swap", &val,
QCA956X_ETH_CFG_SW_PHY_ADDR_SWAP);

__raw_writel(val, base + QCA956X_GMAC_REG_ETH_CFG);
}

The above function is used to setup MII-PHY interface based on
QCA9563/9565 SoC. This function should not be used by any other SoC.

This patch fixes this issue by calling the above function in





NEXT




<s> chksum(u16_t sum, const u8_t *data, u16_t len)
{
u16_t t;
const u8_t *dataptr;
const u8_t *last_byte;

dataptr = data;
last_byte = data + len - 1;

while(dataptr < last_byte) {	/* At least two more bytes */
t = (dataptr[0] << 8) + dataptr[1];
sum += t;
if(sum < t) {
sum++;		/* carry */
}
dataptr += 2;
}

if(dataptr == last_byte) {
t = (dataptr[0] << 8) + 0;
sum += t;
if(sum < t) {
sum++;		/* carry */
}
}

/* Return sum in host byte order. */
return sum;
}

The above function is used to compute the CRC of the input. Also you don't need
to add the length of byte that you got in CRC since the length in big endian.</s>




NEXT




<s> static int item_is_tag(char tag)
{
return item_tag() == tag;
}

The above function is used to determine whether an item's tag is
exactly what we expect it to be. The above function is used to
access the item's tag. This is what the function is used for.
The string tag is what we are testing




NEXT




<s> rtk_api_ret_t rtk_int_polarity_set(rtk_int_polarity_t type)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(type >= INT_POLAR_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicInterruptPolarity(type)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set INT polarity.

#if 0 #endif // end of [if] #if 0 #endif // end of [if] #if 0 #endif // end of [if] // end of [if] //




NEXT




<s> rtk_api_ret_t rtk_trunk_port_set(rtk_trunk_group_t trk_gid, rtk_portmask_t *pTrunk_member_portmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk;
rtk_uint32 regValue, type, tmp;


if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicReg(0x1300, &regValue)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
return retVal;

switch (regValue)
{
case 0x0276:
case 0x0597:
case 0x6367:
type = 0;
break;
case 0x0652:
case 0x6368:
type = 1;
break;
case 0x0801:
case 0x6511:
type = 2;
break;
default:
return RT_ERR_FAILED;
}

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Trunk Group Valid */
RTK_CHK_TRUNK_GROUP_VALID(trk_gid);

if(NULL == pTrunk_member_portmask)
return RT_ERR_NULL_POINTER;

RTK_CHK_PORTMASK_VALID(pTrunk_member_portmask);

if((retVal = rtk_switch_portmask_L2P_get(pTrunk_member_portmask, &pmsk)) != RT_ERR_OK)
return retVal;

if((type == 0) || (type == 1))
{
if ((pmsk | RTL8367C_PORT_TRUNK_GROUP_MASK_MASK(trk_gid)) != (rtk_uint32)RTL8367C_PORT_TRUNK_GROUP_MASK_MASK(trk_gid))
return RT_ERR_PORT_MASK;

pmsk = (pmsk & RTL8367C_PORT_TRUNK_GROUP_MASK_MASK(trk_gid)) >> RTL8367C_PORT_TRUNK_GROUP_MASK_OFFSET(trk_gid);
}
else if(type == 2)
{
tmp = 0;

if(pmsk & 0x2)
tmp |= 1;
if(pmsk & 0x8)
tmp |=2;
if(pmsk & 0x80)
tmp |=8;

pmsk = tmp;
}

if ((retVal = rtl8367c_setAsicTrunkingGroup(trk_gid, pmsk)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set a group as a trunk group

rtk_api_ret_t rtk_trunk_group_set_mode(rtk_trunk_group_t trk_gid, rtk_trunk_




NEXT




<s> swlib_priv_init(void)
{
int ret;

handle = nl_socket_alloc();
if (!handle) {
DPRINTF("Failed to create handle\n");
goto err;
}

if (genl_connect(handle)) {
DPRINTF("Failed to connect to generic netlink\n");
goto err;
}

ret = genl_ctrl_alloc_cache(handle, &cache);
if (ret < 0) {
DPRINTF("Failed to allocate netlink cache\n");
goto err;
}

family = genl_ctrl_search_by_name(cache, "switch");
if (!family) {
DPRINTF("Switch API not present\n");
goto err;
}
return 0;

err:
swlib_priv_free();
return -EINVAL;
}

The above function is used to initialize the private instance of swlib_priv. It calls the nl_socket_alloc function to create a handle which can be used
to communicate with other processes through sockets. Then, it calls the genl_connect function to connect to




NEXT




<s> static bool nmbm_write_phys_page(struct nmbm_instance *ni, uint64_t addr,
const void *data, const void *oob)
{
int tries, ret;

for (tries = 0; tries < NMBM_TRY_COUNT; tries++) {
struct mtd_oob_ops ops = {
.mode = MTD_OPS_PLACE_OOB,
.oobbuf = (void *)oob,
.datbuf = (void *)data,
};

if (data)
ops.len = bmtd.pg_size;
if (oob)
ops.ooblen = mtd_oobavail(bmtd.mtd, &ops);

ret = bmtd._write_oob(bmtd.mtd, addr, &ops);
if (!ret)
return true;
}

nlog_err(ni, "Page write failed at address 0x%08llx\n", addr);

return false;
}

The above function is used to write the current NAND page to the storage, and will be called at intervals of every 20 KB.

The following is the call to the above function in the write_work function in nmudc_file_write




NEXT




<s> int ifxdeu_init_des (void)
{
int ret = -ENOSYS;

des_chip_init();

ret = crypto_register_alg(&ifxdeu_des_alg);
if (ret < 0)
goto des_err;

ret = crypto_register_skcipher(&ifxdeu_ecb_des_alg);
if (ret < 0)
goto ecb_des_err;

ret = crypto_register_skcipher(&ifxdeu_cbc_des_alg);
if (ret < 0)
goto cbc_des_err;

ret = crypto_register_alg(&ifxdeu_des3_ede_alg);
if (ret < 0)
goto des3_ede_err;

ret = crypto_register_skcipher(&ifxdeu_ecb_des3_ede_alg);
if (ret < 0)
goto ecb_des3_ede_err;

ret = crypto_register_skcipher(&ifxdeu_cbc_des3_ede_alg);
if (ret < 0)
goto cbc_des3_ede_err;

CRTCL_SECT_INIT;



printk (KERN_NOTICE "IFX DEU DES initialized%s%s.\n", disable_multiblock ? "" : " (multiblock)", disable_deudma ? "" : " (DMA)");
return ret;

des_err:
crypto_unregister_alg(&ifxdeu_des_alg);
printk(KERN_ERR "IFX des initialization failed!\n");
return ret;
ecb_des_err:
crypto_unregister_skcipher(&ifxdeu_ecb_des_alg);
printk (KERN_ERR "IFX ecb_des initialization failed!\n");
return ret;
cbc_des_err:
crypto_unregister_skcipher(&ifxdeu_cbc_des_alg);
printk (KERN_ERR "IFX cbc_des initialization failed!\n");
return ret;
des3_ede_err:
crypto_unregister_alg(&ifxdeu_des3_ede_alg);
printk(KERN_ERR "IFX des3_ede initialization failed!\n");
return ret;
ecb_des3_ede_err:
crypto_unregister_skcipher(&ifxdeu_ecb_des3_ede_alg);
printk (KERN_ERR "IFX ecb_des3_ede initialization failed!\n");
return ret;
cbc_des3_ede_err:
crypto_unregister_skcipher(&ifxdeu_cbc_des3_ede_alg);
printk (KERN_ERR "IFX cbc_des3_ede initialization failed!\n");
return ret;

}

The above function is used to initialize the software layer of the IFXDEU DES module. The initialization procedure includes hardware initialization of the DES chip and driver registration of the crypto algorithms and ciphers. It registers crypto algorithms and ciphers that are used with 64




NEXT




<s> static void ag71xx_hw_stop(struct ag71xx *ag)
{
/* disable all interrupts and stop the rx/tx engine */
ag71xx_wr(ag, AG71XX_REG_INT_ENABLE, 0);
ag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);
ag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);
}

The above function is used to stop the transmission as well as the reception. If you are developing your code to develop hardware, you need to make sure that the above operations are successfully performed. When interrupt enabled operation is used by the kernel to stop transmission or reception from a network,




NEXT




<s> static int rb4xx_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
{
return 0; /* All 9 GPIOs are out */
}

The above function is used to determine the device’s pin direction at runtime after it is attached to the bus. The default function of an GPIO_GET_DIRECTION handler is to return INPUT_TYPE if the device cannot dynamically change the direction of a pin or




NEXT




<s> rtk_api_ret_t rtk_igmp_static_router_port_set(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Valid port mask */
if(pPortmask == NULL)
return RT_ERR_NULL_POINTER;

RTK_CHK_PORTMASK_VALID(pPortmask);

if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIGMPStaticRouterPort(pmask))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set IGMP v3 router port.</s>




NEXT




<s> ret_t rtl8367c_getAsicIGMPFastLeaveEn(rtk_uint32 *penabled)
{
ret_t   retVal;
rtk_uint32  value;

/* Fast Leave */
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_FAST_LEAVE_EN_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;

*penabled = value;

return RT_ERR_OK;
}

The above function is used to enable a switch to perform fast leave. The function has the following signature:

ret_t rtl8367c_getAsicIGMPFastLeaveEn(rtk_uint32 *penabled);

The




NEXT




<s> static int rtl8367b_setup(struct rtl8366_smi *smi)
{
struct rtl8367_platform_data *pdata;
int err;
int i;

pdata = smi->parent->platform_data;

err = rtl8367b_init_regs(smi);
if (err)
return err;

/* initialize external interfaces */
if (smi->parent->of_node) {
err = rtl8367b_extif_init_of(smi, 0, "realtek,extif0");
if (err)
return err;

err = rtl8367b_extif_init_of(smi, 1, "realtek,extif1");
if (err)
return err;

err = rtl8367b_extif_init_of(smi, 2, "realtek,extif2");
if (err)
return err;
} else {
err = rtl8367b_extif_init(smi, 0, pdata->extif0_cfg);
if (err)
return err;

err = rtl8367b_extif_init(smi, 1, pdata->extif1_cfg);
if (err)
return err;
}

/* set maximum packet length to 1536 bytes */
REG_RMW(smi, RTL8367B_SWC0_REG, RTL8367B_SWC0_MAX_LENGTH_MASK,
RTL8367B_SWC0_MAX_LENGTH_1536);

/*
* discard VLAN tagged packets if the port is not a member of
* the VLAN with which the packets is associated.
*/
REG_WR(smi, RTL8367B_VLAN_INGRESS_REG, RTL8367B_PORTS_ALL);

/*
* Setup egress tag mode for each port.
*/
for (i = 0; i < RTL8367B_NUM_PORTS; i++)
REG_RMW(smi,
RTL8367B_PORT_MISC_CFG_REG(i),
RTL8367B_PORT_MISC_CFG_EGRESS_MODE_MASK <<
RTL8367B_PORT_MISC_CFG_EGRESS_MODE_SHIFT,
RTL8367B_PORT_MISC_CFG_EGRESS_MODE_ORIGINAL <<
RTL8367B_PORT_MISC_CFG_EGRESS_MODE_SHIFT);

return 0;
}

The above function is used to set up the chip before the actual PHY is initialized. The function calls the following functions in its proper sequence:

*  rtl8367b_init_regs: initializes register offsets and settings for internal functions of




NEXT




<s> rtk_api_ret_t rtk_ptp_refTimeAdjust_set(rtk_ptp_sys_adjust_t sign, rtk_ptp_timeStamp_t timeStamp)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (timeStamp.nsec > RTK_MAX_NUM_OF_NANO_SECOND)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicEavSysTimeAdjust(sign, timeStamp.sec, timeStamp.nsec))!=RT_ERR_OK)
return retVal;


return RT_ERR_OK;
}

The above function is used to set the PTP time of reference clock. And it is not a public function. Therefore we defined our own “RTL_API_RTK_PTP_REFTIMEADJUST_SET” in rtl8367c




NEXT




<s> static int bcm6348_emac_mdio_op(struct bcm6348_emac *emac, uint32_t data)
{
int limit;

/* Make sure mii interrupt status is cleared */
emac_writel(emac, ENET_IR_MII, ENET_IR_REG);

/* Issue mii op */
emac_writel(emac, data, ENET_MIID_REG);
wmb();

/* busy wait on mii interrupt bit, with timeout */
limit = 1000;
do {
if (emac_readl(emac, ENET_IR_REG) & ENET_IR_MII)
break;
udelay(1);
} while (limit-- > 0);

return (limit < 0) ? 1 : 0;
}

The above function is used to perform MII operations, and it expects a read/write operation based on data. On a successful operation, this function returns zero. This function is used to read the MII register at address 10 and write a register at address 1




NEXT




<s> static void rtl930x_create_tx_header(struct p_hdr *h, unsigned int dest_port, int prio)
{
h->cpu_tag[0] = 0x8000;  /* CPU tag marker */
h->cpu_tag[1] = h->cpu_tag[2] = 0;
h->cpu_tag[3] = 0;
h->cpu_tag[4] = 0;
h->cpu_tag[5] = 0;
h->cpu_tag[6] = BIT(dest_port) >> 16;
h->cpu_tag[7] = BIT(dest_port) & 0xffff;

/* Enable (AS_QID) and set priority queue (QID) */
if (prio >= 0)
h->cpu_tag[2] = (BIT(5) | (prio & 0x1f)) << 8;
}

The above function is used to create tx header of rtl930x in the kernel space before enqueueing to send. Then, on receiving the frame by the driver,

struct p_hdr *txHdr = (struct p_hdr *)skb->




NEXT




<s> void menu_warn(struct menu *menu, const char *fmt, ...)
{
va_list ap;
va_start(ap, fmt);
fprintf(stderr, "%s:%d:warning: ", menu->file->name, menu->lineno);
vfprintf(stderr, fmt, ap);
fprintf(stderr, "\n");
va_end(ap);
}

The above function is used to print warnings to the user when parsing
a menu script (or possibly other configuration file format), similar to
the way that the kernel can print warnings while compiling using the
#warning directive.

This function is already used by




NEXT




<s> hostapd_add_b64_data(const char *name, const struct wpabuf *buf)
{
char *str;

if (!buf)
return false;

str = blobmsg_alloc_string_buffer(&b, name, B64_ENCODE_LEN(wpabuf_len(buf)));
b64_encode(wpabuf_head(buf), wpabuf_len(buf), str, B64_ENCODE_LEN(wpabuf_len(buf)));
blobmsg_add_string_buffer(&b);

return true;
}

The above function is used to add a B64 hex string encoded data to blob in the wpa_supplicant.


wpabuf_head(buf) points to the actual data stored in the heap. (allocated using malloc)</s>




NEXT




<s> BigIntegerMulInt(result, m1, m2)
BigInteger result, m1;
unsigned int m2;
{
BN_CTX * ctx = BN_CTX_new();
BIGNUM * m = BN_new();
BN_set_word(m, m2);
BN_mul(result, m1, m, ctx);
BN_CTX_free(ctx);
}

The above function is used to multiply a big integer result with a small/tiny integer m2

When 0 is used as m2, BN_set_word(m, m2); sets m1 to 1, whereas BN_mul(




NEXT




<s> static int rtl930x_mdio_write_paged(struct mii_bus *bus, int mii_id, u16 page,
int regnum, u16 value)
{
struct rtl838x_eth_priv *priv = bus->priv;
int err;

if (priv->phy_is_internal[mii_id])
return rtl930x_write_sds_phy(priv->sds_id[mii_id], page, regnum, value);

if (regnum & (MII_ADDR_C45 | MII_ADDR_C22_MMD))
return rtl930x_write_mmd_phy(mii_id, mdiobus_c45_devad(regnum),
regnum, value);

err = rtl930x_write_phy(mii_id, page, regnum, value);
pr_debug("PHY: %d register %x write %x, err %d\n", mii_id, regnum, value, err);

return err;
}

The above function is used to write a 16-bit register of the device over MDIO. This includes 45-mmd registers, 22-mmd registers, and CSR registers. rtl930x_write_phy() implements




NEXT




<s> void menu_set_type(int type)
{
struct symbol *sym = current_entry->sym;

if (sym->type == type)
return;
if (sym->type == S_UNKNOWN) {
sym->type = type;
return;
}
menu_warn(current_entry,
"ignoring type redefinition of '%s' from '%s' to '%s'",
sym->name ? sym->name : "<choice>",
sym_type_name(sym->type), sym_type_name(type));
}

The above function is used to change the type of a symbol. But how?
Either from the command line with $ menu set type... or from inside of
the menu system during menu_edit. This isn't ideal.

I think that we should add




NEXT




<s> static int rtl8366rb_enable_vlan(struct rtl8366_smi *smi, int enable)
{
return rtl8366_smi_rmwr(smi, RTL8366RB_SGCR, RTL8366RB_SGCR_EN_VLAN,
(enable) ? RTL8366RB_SGCR_EN_VLAN : 0);
}

The above function is used to disable/enable vlan tagging in rtl8366.
If I set vlan to be not enabled by using the function
rtl8366rb_enable_vlan(0), can one capture a packet




NEXT




<s> rtk_api_ret_t rtk_svlan_tpidEntry_set(rtk_svlan_tpid_t svlan_tag_id)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (svlan_tag_id>RTK_MAX_NUM_OF_PROTO_TYPE)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicSvlanTpid(svlan_tag_id)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set a SVLAN TPID entry index

void rtk_svlan_tpidEntry_get(rtk_svlan_tpid_t svlan_tag_id, rtk_svlan_tpid_




NEXT




<s> ar8327_phy_rgmii_set(struct ar8xxx_priv *priv, struct phy_device *phydev)
{
u16 phy_val = 0;
int phyaddr = phydev->mdio.addr;
struct device_node *np = phydev->mdio.dev.of_node;

if (!np)
return;

if (!of_property_read_bool(np, "qca,phy-rgmii-en")) {
pr_err("ar8327: qca,phy-rgmii-en is not specified\n");
return;
}
ar8xxx_phy_dbg_read(priv, phyaddr,
AR8327_PHY_MODE_SEL, &phy_val);
phy_val |= AR8327_PHY_MODE_SEL_RGMII;
ar8xxx_phy_dbg_write(priv, phyaddr,
AR8327_PHY_MODE_SEL, phy_val);

/* set rgmii tx clock delay if needed */
if (!of_property_read_bool(np, "qca,txclk-delay-en")) {
pr_err("ar8327: qca,txclk-delay-en is not specified\n");
return;
}
ar8xxx_phy_dbg_read(priv, phyaddr,
AR8327_PHY_SYS_CTRL, &phy_val);
phy_val |= AR8327_PHY_SYS_CTRL_RGMII_TX_DELAY;
ar8xxx_phy_dbg_write(priv, phyaddr,
AR8327_PHY_SYS_CTRL, phy_val);

/* set rgmii rx clock delay if needed */
if (!of_property_read_bool(np, "qca,rxclk-delay-en")) {
pr_err("ar8327: qca,rxclk-delay-en is not specified\n");
return;
}
ar8xxx_phy_dbg_read(priv, phyaddr,
AR8327_PHY_TEST_CTRL, &phy_val);
phy_val |= AR8327_PHY_TEST_CTRL_RGMII_RX_DELAY;
ar8xxx_phy_dbg_write(priv, phyaddr,
AR8327_PHY_TEST_CTRL, phy_val);
}

The above function is used to configure RGMII interface via 32 bit registers
inside PHY for Ar7010 series. While configuring the interface, if above function
is missing then MAC is configured for MII mode automatically.

The below




NEXT




<s> static inline u32 ecc_read32(struct mt7621_nfc *nfc, u32 reg)
{
return readl(nfc->ecc_regs + reg);
}

The above function is used to access the contents of the
ECC registers by taking a read-access to it.

static inline void ecc_write32(struct mt7621_nfc *nfc, u32 reg, u32




NEXT




<s> ret_t rtl8367c_getAsicRldpEnterLoopedPortmask(rtk_uint32 *pPortmask)
{
return rtl8367c_getAsicReg(RTL8367C_REG_RLDP_LOOPED_INDICATOR, pPortmask);
}

The above function is used to get the looped port information for the LAG interface.
Below is a trace of the result using the above function:

0x0010, 0x0030, 0x0080




NEXT




<s> static void ag71xx_bit_set(void __iomem *reg, u32 bit)
{
u32 val;

val = __raw_readl(reg) | bit;
__raw_writel(val, reg);
__raw_readl(reg);
}

The above function is used to set a particular bit position to 1, given by bit. The code for ag71xx_bit_clear() is similar with bit set to 0.

The above code seems to indicate that setting a particular bit position will only




NEXT




<s> static void item_add_str(const char *fmt, ...)
{
va_list ap;
int index = items_num-1;
char new_str[256];
char tmp_str[256];

if (index < 0)
return;

va_start(ap, fmt);
vsnprintf(new_str, sizeof(new_str), fmt, ap);
va_end(ap);
snprintf(tmp_str, sizeof(tmp_str), "%s%s",
k_menu_items[index].str, new_str);
strncpy(k_menu_items[index].str,
tmp_str,
sizeof(k_menu_items[index].str));

free_item(curses_menu_items[index]);
curses_menu_items[index] = new_item(
k_menu_items[index].str,
k_menu_items[index].str);
set_item_userptr(curses_menu_items[index],
&k_menu_items[index]);
}

The above function is used to dynamically change the text displayed in a menu in the program I am working on. Since dynamic C string manipulation is not exactly a piece of cake, there are a lot of things that can go wrong when you use a function like the one above




NEXT




<s> int dc_ep_gpio_get(struct dc_ep_priv *priv, u32 gpio, int *val)
{
u32 dir;
struct dc_aca *aca = to_aca(priv);

if (gpio > aca->max_gpio)
return -EINVAL;

dir = rd32(GPIO_DIR);
if ((dir >> gpio) & 0x1)
*val = (rd32(GPIO_OUT) >> gpio) & 0x1;
else
*val = (rd32(GPIO_IN) >> gpio) & 0x1;
return 0;
}

The above function is used to get the value of a gpio pin. It first calls GDK’s `rd32` function to read the value of the GPIO port or its input port. The result is then masked with the appropriate bits and stored in a pointer




NEXT




<s> static ssize_t hc_wlan_data_bin_read(struct file *filp, struct kobject *kobj,
struct bin_attribute *attr, char *buf,
loff_t off, size_t count);

static struct hc_wlan_attr {
const u16 erd_tag_id;
struct bin_attribute battr;
u16 pld_ofs;
u16 pld_len;
} hc_wd_multi_battrs[] = {
{
.erd_tag_id = RB_WLAN_ERD_ID_MULTI_8001,
.battr = __BIN_ATTR(data_0, S_IRUSR, hc_wlan_data_bin_read, NULL, 0),
}, {
.erd_tag_id = RB_WLAN_ERD_ID_MULTI_8201,
.battr = __BIN_ATTR(data_2, S_IRUSR, hc_wlan_data_bin_read, NULL, 0),
}
};

The above function is used to read the data. We need to make sure that we can use this function, but we can also make sure that we can use the data function. In order to do that, we can use the following code:

static struct hc_




NEXT




<s> static int qca807x_set_downshift(struct phy_device *phydev, u8 cnt)
{
int ret, val;

if (cnt > QCA807X_SMARTSPEED_RETRY_LIMIT_MAX ||
(cnt < QCA807X_SMARTSPEED_RETRY_LIMIT_MIN && cnt != DOWNSHIFT_DEV_DISABLE))
return -EINVAL;

if (!cnt) {
ret = phy_clear_bits(phydev, MII_NWAYTEST, QCA807X_SMARTSPEED_EN);
} else {
val = QCA807X_SMARTSPEED_EN;
val |= FIELD_PREP(QCA807X_SMARTSPEED_RETRY_LIMIT_MASK, cnt - 2);

phy_modify(phydev, MII_NWAYTEST,
QCA807X_SMARTSPEED_EN |
QCA807X_SMARTSPEED_RETRY_LIMIT_MASK,
val);
}

ret = genphy_soft_reset(phydev);

return ret;
}

The above function is used to configure the downshift and the following snippet is used to invoke this function. This will then set the NWAY TEST register, as shown here for the QCA SmartSpeeds enabled Ethernet PHY. Once the downshift has been configured




NEXT




<s> static inline int rtl838x_tbl_access_data_0(int i)
{
return RTL838X_TBL_ACCESS_DATA_0(i);
}

The above function is used to print the table access data.

The first few times I looked at this function, I was convinced that the reason the function was returning table data values was because the compiler didn’t know where the table values were located, and thus couldn’




NEXT




<s> static void aca_mdm_init(struct dc_ep_priv *priv, struct aca_modem_param *mdm)
{
struct aca_proj_param *param;

if (!mdm)
return;

param = &mdm->mdm_txout;
wr32(param->stat | priv->phymem, GNRC_TXOUT_TGT_STAT);
wr32(param->pd | priv->phymem, GNRC_TXOUT_TGT_PD_OFF);
wr32(param->acc_cnt | priv->phymem, GNRC_TXOUT_TGT_ACCM_CNT);

param = &mdm->mdm_rxin;
wr32(param->stat | priv->phymem, GNRC_RXIN_TGT_STAT);
wr32(param->pd | priv->phymem, GNRC_RXIN_TGT_PD_OFF);
wr32(param->acc_cnt | priv->phymem, GNRC_RXIN_TGT_ACCM_CNT);

param = &mdm->mdm_rxout;
wr32(param->stat | priv->phymem, GNRC_RXOUT_TGT_STAT);
wr32(param->pd | priv->phymem, GNRC_RXOUT_TGT_PD_OFF);
wr32(param->acc_cnt | priv->phymem, GNRC_RXOUT_TGT_ACCM_CNT);
dev_dbg(priv->dev, "aca mdm init done\n");
}

The above function is used to setup initial value when the system needs the modem function. The main function include enabling the target clock, PD module, enabling the modem ACCM mode for the target pads.</s>




NEXT




<s> int ifxdeu_init_sha1 (void)
{
int ret = -ENOSYS;


if ((ret = crypto_register_shash(&ifxdeu_sha1_alg)))
goto sha1_err;

printk (KERN_NOTICE "IFX DEU SHA1 initialized%s.\n", disable_deudma ? "" : " (DMA)");
return ret;

sha1_err:
printk(KERN_ERR "IFX DEU SHA1 initialization failed!\n");
return ret;
}

The above function is used to register sha1 with the kernel, this
is done in the file called ifxdeu_core.c that is included in the
kernel.

During the sha1 initialization, the kernel searches for
ifxdeu




NEXT




<s> static void sata_oxnas_freeze(struct ata_port *ap)
{
struct sata_oxnas_host_priv *hd = ap->host->private_data;

DPRINTK("\n");
hd->port_frozen |= BIT(ap->port_no);
smp_wmb();
}

The above function is used to freeze a port. However while taking out a port on the bus the driver calls:

int sata_oxnas_remove_port(struct ata_port *ap)
{
struct sata_oxnas_host_




NEXT




<s> u32 dc_aca_txin_hd_cnt(struct dc_ep_priv *priv)
{
return rd32(TXIN_ACA_HD_ACC_CNT);
}

The above function is used to obtain the value of the 32-bit ACATXIN_HDCNT register in the hardware.

u32 dc_aca_txin_wd_cnt(struct dc_ep_priv *priv)
{




NEXT




<s> static int mr18_extract_sgmii_res_cal(void)
{
unsigned int base;
unsigned int reversed_sgmii_value;

unsigned int otp_value, otp_per_val, rbias_per, read_data;
unsigned int rbias_pos_or_neg;
unsigned int sgmii_res_cal_value;
int res_cal_val;

base = KSEG1ADDR(QCA955X_OTP_BASE);

WRITEREG(base + QCA955X_OTP_REG_INTF2, 0x7d);
WRITEREG(base + QCA955X_OTP_REG_LDO_CTRL, 0x00);

while (READREG(base + QCA955X_OTP_REG_LDO_STATUS) &
QCA955X_OTP_LDO_STATUS_POWER_ON)
;

READREG(base + QCA955X_OTP_REG_MEM_0 + 4);

while (!(READREG(base + QCA955X_OTP_REG_STATUS0) &
QCA955X_OTP_STATUS0_EFUSE_VALID))
;

read_data = READREG(base + QCA955X_OTP_REG_STATUS1);

if (!(read_data & 0x1fff))
return 0;

if (read_data & 0x00001000)
otp_value = (read_data & 0xfc0) >> 6;
else
otp_value = read_data & 0x3f;

if (otp_value > 31) {
otp_per_val = 63 - otp_value;
rbias_pos_or_neg = 1;
} else {
otp_per_val = otp_value;
rbias_pos_or_neg = 0;
}

rbias_per = otp_per_val * 15;

if (rbias_pos_or_neg == 1)
res_cal_val = (rbias_per + 34) / 21;
else if (rbias_per > 34)
res_cal_val = -((rbias_per - 34) / 21);
else
res_cal_val = (34 - rbias_per) / 21;

sgmii_res_cal_value = (8 + res_cal_val) & 0xf;

reversed_sgmii_value  = (sgmii_res_cal_value & 8) >> 3;
reversed_sgmii_value |= (sgmii_res_cal_value & 4) >> 1;
reversed_sgmii_value |= (sgmii_res_cal_value & 2) << 1;
reversed_sgmii_value |= (sgmii_res_cal_value & 1) << 3;
printf("SGMII cal value = 0x%x\n", reversed_sgmii_value);
return reversed_sgmii_value;
}

The above function is used to extract the res_cal value from the OTP as well, however, we want to do that at runtime.


```</s>




NEXT




<s> uc_bpf_map_iterator(uc_vm_t *vm, size_t nargs)
{
struct uc_bpf_map *map = uc_fn_thisval("bpf.map");
struct uc_bpf_map_iter *iter;

if (!map)
err_return(EINVAL, NULL);

iter = xalloc(sizeof(*iter) + map->key_size);
iter->fd = map->fd.fd;
iter->key_size = map->key_size;
iter->has_next = !bpf_map_get_next_key(iter->fd, NULL, &iter->key);

return uc_resource_new(map_iter_type, iter);
}

The above function is used to iterate over an eBPF map and it can be used in two ways:
1. To iterate over all keys and values in the map
2. To iterate over keys in the map, but not populate the values





NEXT




<s> static void button_hotplug_event(struct input_handle *handle,
unsigned int type, unsigned int code, int value)
{
struct bh_priv *priv = handle->private;
unsigned long seen = jiffies;
int btn;

BH_DBG("event type=%u, code=%u, value=%d\n", type, code, value);

if (type != EV_KEY)
return;

btn = button_get_index(code);
if (btn < 0)
return;

button_hotplug_create_event(button_map[btn].name,
(seen - priv->seen[btn]) / HZ, value);
priv->seen[btn] = seen;
}

The above function is used to check the button state using a timer tick.</s>




NEXT




<s> int rtl931x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val)
{
int err = 0;
u32 v;
/* Select PHY register type
* If select 1G/10G MMD register type, registers EXT_PAGE, MAIN_PAGE and REG settings are don’t care.
* 0x0  Normal register (Clause 22)
* 0x1: 1G MMD register (MMD via Clause 22 registers 13 and 14)
* 0x2: 10G MMD register (MMD via Clause 45)
*/
int type = (regnum & MII_ADDR_C45)?2:1;

mutex_lock(&smi_lock);

/* Set PHY to access via port-number */
sw_w32(port << 5, RTL931X_SMI_INDRT_ACCESS_BC_PHYID_CTRL);

/* Set MMD device number and register to write to */
sw_w32(devnum << 16 | mdiobus_c45_regad(regnum), RTL931X_SMI_INDRT_ACCESS_MMD_CTRL);

v = type << 2 | BIT(0); /* MMD-access-type | EXEC */
sw_w32(v, RTL931X_SMI_INDRT_ACCESS_CTRL_0);

do {
v = sw_r32(RTL931X_SMI_INDRT_ACCESS_CTRL_0);
} while (v & BIT(0));

/* Check for error condition */
if (v & BIT(1))
err = -EIO;

*val = sw_r32(RTL931X_SMI_INDRT_ACCESS_CTRL_3) >> 16;

pr_debug("%s: port %d, dev: %x, regnum: %x, val: %x (err %d)\n", __func__,
port, devnum, mdiobus_c45_regad(regnum), *val, err);

mutex_unlock(&smi_lock);

return err;
}

The above function is used to access the PHY. To access any PHY device (eg. 3com) via the SMI, following functions are used.

// 1. Register the bus.

rtl931x_smi_




NEXT




<s> int bcm6348_iudma_drivers_register(struct platform_device *pdev);

static inline u32 dma_readl(struct bcm6348_iudma *iudma, u32 off)
{
u32 val;

spin_lock(&iudma->dma_base_lock);
val = __raw_readl(iudma->dma_base + off);
spin_unlock(&iudma->dma_base_lock);

return val;
}

The above function is used to read data from DMA base address using dma_readl function as in the below code. Please find my code

u32 dma_test_read(struct bcm6348_iudma *iudma




NEXT




<s> mt7530_set_mirror_monitor_port(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

priv->mirror_dest_port = val->value.i;

return 0;
}

The above function is used to change the MT7530 port which will be used to send
mirrored packets, based on the port attribute which was passed in.

int mt7530_vlan_port_alloc(struct switch_dev




NEXT




<s> swconfig_trig_port_mask_show(struct device *dev, struct device_attribute *attr,
char *buf)
{
struct led_classdev *led_cdev = dev_get_drvdata(dev);
struct swconfig_trig_data *trig_data = led_cdev->trigger_data;
u32 port_mask;

read_lock(&trig_data->lock);
port_mask = trig_data->port_mask;
read_unlock(&trig_data->lock);

sprintf(buf, "%#x\n", port_mask);

return strlen(buf) + 1;
}

The above function is used to report the port mask which we have applied previously. The port mask is a combination of flags which can be defined in the source code of the swconfig.c file, in which we have defined as the SWCONFIG_EVENT_TYPE definition. The




NEXT




<s> void ifx_deu_aes_cfb (void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
ifx_deu_aes (ctx, dst, src, iv, nbytes, encdec, 3);
}

The above function is used to implement CFB encrypt and CFB decrypt. This differs from the default behaviour of OpenSSL CFB where if nbytes is large and less than or equal to the AES block size then OpenSSL will break the stream into chunks,




NEXT




<s> static ssize_t rtl8366_read_debugfs_mibs(struct file *file,
char __user *user_buf,
size_t count, loff_t *ppos)
{
struct rtl8366_smi *smi = file->private_data;
int i, j, len = 0;
char *buf = smi->buf;

len += snprintf(buf + len, sizeof(smi->buf) - len, "%-36s",
"Counter");

for (i = 0; i < smi->num_ports; i++) {
char port_buf[10];

snprintf(port_buf, sizeof(port_buf), "Port %d", i);
len += snprintf(buf + len, sizeof(smi->buf) - len, " %12s",
port_buf);
}
len += snprintf(buf + len, sizeof(smi->buf) - len, "\n");

for (i = 0; i < smi->num_mib_counters; i++) {
len += snprintf(buf + len, sizeof(smi->buf) - len, "%-36s ",
smi->mib_counters[i].name);
for (j = 0; j < smi->num_ports; j++) {
unsigned long long counter = 0;

if (!smi->ops->get_mib_counter(smi, i, j, &counter))
len += snprintf(buf + len,
sizeof(smi->buf) - len,
"%12llu ", counter);
else
len += snprintf(buf + len,
sizeof(smi->buf) - len,
"%12s ", "error");
}
len += snprintf(buf + len, sizeof(smi->buf) - len, "\n");
}

return simple_read_from_buffer(user_buf, count, ppos, buf, len);
}

The above function is used to obtain and print the contents of the
MIB counters.

3.1.10.2. Print Statistics

There are two different debugfs files to print the MIB counters of the NIC.

The




NEXT




<s> rtk_api_ret_t rtk_cpu_acceptLength_set(rtk_cpu_rx_length_t length)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (length >= CPU_RX_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicCputagRxMinLength(length)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to modify the RX packet length, which will be considered as the incoming packet length on the CPU side.

The default value is 1514. For a packet greater than or equal to 1514 bytes, it will




NEXT




<s> mtk_bmt_read_bbt(void)
{
u8 oob_buf[8];
int i;

for (i = bmtd.total_blks - 1; i >= bmtd.total_blks - 5; i--) {
u32 page = i << (bmtd.blk_shift - bmtd.pg_shift);

if (bbt_nand_read(page, bmtd.bbt_buf, bmtd.pg_size,
oob_buf, sizeof(oob_buf))) {
pr_info("read_bbt: could not read block %d\n", i);
continue;
}

if (oob_buf[0] != 0xff) {
pr_info("read_bbt: bad block at %d\n", i);
continue;
}

if (memcmp(&oob_buf[1], "mtknand", 7) != 0) {
pr_info("read_bbt: signature mismatch in block %d\n", i);
print_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 1, oob_buf, 8, 1);
continue;
}

pr_info("read_bbt: found bbt at block %d\n", i);
bmtd.bmt_blk_idx = i;
return 0;
}

return -EIO;
}

The above function is used to find the last block that contains the BBT entries, that’s how it knows which block to read/write. We will use this info to locate the BBT within the EEPROM.
The location is calculated by offsetting the




NEXT




<s> static int rtl8366s_enable_port(struct rtl8366_smi *smi, int port, int enable)
{
return rtl8366_smi_rmwr(smi, RTL8366S_PECR, (1 << port),
(enable) ? 0 : (1 << port));
}

The above function is used to enable or disable the port of the switching machine. It uses the same hardware abstraction layer function rtl8366_smi_rmwr to do bit operation. The value which will be stored into the register is 1 <<




NEXT




<s> static int block_load_image_fat(const char *filename)
{
int err;
struct image_header *header;

header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
sizeof(struct image_header));

err = file_fat_read(filename, header, sizeof(struct image_header));
if (err <= 0)
goto end;

spl_parse_image_header(header);

err = file_fat_read(filename, (u8 *)spl_image.load_addr, 0);

end:
if (err <= 0)
printf("spl: error reading image %s, err - %d\n",
filename, err);

return (err <= 0);
}

The above function is used to load images from the SD card in FAT32 format. It can easily be converted to load images from a SDHC card.</s>




NEXT




<s> ret_t rtl8367c_getAsicI2CGpioPinGroup(rtk_uint32 * pPinGroup_ID)
{

rtk_uint32 regData;
ret_t retVal;
if( (retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, &regData)) != RT_ERR_OK)
return retVal;
regData &= 0xF000 ;
regData = (regData >> 12);

if( regData == 0x5 )
*pPinGroup_ID = 0;
else if(regData == 0xA)
*pPinGroup_ID = 1;
else if(regData == 0xF)
*pPinGroup_ID = 2;
else
return RT_ERR_FAILED;
return RT_ERR_OK ;
}

The above function is used to get Asic I2C peripheral pin for gpio use. This code returns the pin mapped value corresponding to the I2C register address.

Now how do we use this function while we are trying to read any data from Asic




NEXT




<s> static void fe_clean_rx(struct fe_priv *priv)
{
struct fe_rx_ring *ring = &priv->rx_ring;
struct page *page;
int i;

if (ring->rx_data) {
for (i = 0; i < ring->rx_ring_size; i++)
if (ring->rx_data[i]) {
if (ring->rx_dma && ring->rx_dma[i].rxd1)
dma_unmap_single(priv->dev,
ring->rx_dma[i].rxd1,
ring->rx_buf_size,
DMA_FROM_DEVICE);
skb_free_frag(ring->rx_data[i]);
}

kfree(ring->rx_data);
ring->rx_data = NULL;
}

if (ring->rx_dma) {
dma_free_coherent(priv->dev,
ring->rx_ring_size * sizeof(*ring->rx_dma),
ring->rx_dma,
ring->rx_phys);
ring->rx_dma = NULL;
}

if (!ring->frag_cache.va)
return;

page = virt_to_page(ring->frag_cache.va);
__page_frag_cache_drain(page, ring->frag_cache.pagecnt_bias);
memset(&ring->frag_cache, 0, sizeof(ring->frag_cache));
}

The above function is used to dispose the DMA memory.

# fe_init_rx()
static int fe_init_rx(struct fe_priv *priv)
{
struct page *page;
struct fe_rx_ring *ring = &




NEXT




<s> static inline struct aca_fw_param *to_aca_fw_param(struct dc_ep_priv *priv)
{
return &priv->aca.fw_info.fw_param;
}

The above function is used to acquire an instance of struct aca_fw_param from a structure representing the private data associated with an AC-LVDS Display Controller Engine Protocol Event (DC_EP)

```
#include <linux/drm_ioctl




NEXT




<s> static int rtl8366rb_sw_set_mirror_tx_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

if (val->value.i)
data = RTL8366RB_PMCR_MIRROR_TX;
else
data = 0;

return rtl8366_smi_rmwr(smi, RTL8366RB_PMCR, RTL8366RB_PMCR_MIRROR_TX, data);
}

The above function is used to set the transmit-mirror capability
of the switch chip.
This function is normally used to decide whether the mirrored
packets are forwarded by the switch or not.
If the mirror-enable bit (bit5) is




NEXT




<s> int des3_ede_setkey_skcipher(struct crypto_skcipher *tfm, const u8 *key,
unsigned int keylen)
{
return des3_ede_setkey(crypto_skcipher_tfm(tfm), key, keylen);
}

The above function is used to set and change the key
string in the struct crypto_skcipher. The struct
crypto_skcipher is a common structure for block
ciphers. des3_ede_setkey and des3_ede_setkey




NEXT




<s> static int bcm6348_emac_mdio_write(struct mii_bus *bus, int phy_id,
int loc, uint16_t val)
{
struct bcm6348_emac *emac = bus->priv;
struct platform_device *pdev = emac->pdev;
struct device *dev = &pdev->dev;
uint32_t reg;

reg = (val << ENET_MIID_DATA_SHIFT) & ENET_MIID_DATA_MASK;
reg |= 0x2 << ENET_MIID_TA_SHIFT;
reg |= loc << ENET_MIID_REG_SHIFT;
reg |= phy_id << ENET_MIID_PHY_SHIFT;
reg |= ENET_MIID_OP_WRITE;

if (bcm6348_emac_mdio_op(emac, reg)) {
dev_err(dev, "mdio_write: phy=%d loc=%x timeout!\n",
phy_id, loc);
return -EINVAL;
}

bcm6348_emac_mdio_op(emac, reg);

return 0;
}

The above function is used to write data to the specified PHY register.




```
static int bcm6348_emac_mdio_write(struct mii_bus *bus, int phy_id, int loc




NEXT




<s> static int adm6996_soft_reset(struct phy_device *phydev)
{
/* we don't need an extra reset */
return 0;
}

The above function is used to indicate that no reset pin is
used.
The actual reset of the device occurs during bootup.

static inline bool is_phy_adm6996(struct phy_device *_phydev)
{





NEXT




<s> void ifx_deu_des_cbc (void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
ifx_deu_des (ctx, dst, src, iv, nbytes, encdec, 1);
}

The above function is used to encrypt or decrypt blocks of data and was not used during our testing.

There are a few more functions that are used elsewhere by the main programs.
These include ifx_deu_aes3_encrypt_ec




NEXT




<s> static void mt7620_mac_init(struct mt7620_gsw *gsw)
{
/* Internal ethernet requires PCIe RC mode */
rt_sysc_w32(rt_sysc_r32(SYSC_REG_CFG1) | PCIE_RC_MODE, SYSC_REG_CFG1);

/* Keep Global Clocks on Idle traffic */
mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_CKGCR) & ~(0x3 << 4), GSW_REG_CKGCR);

/* Set Port 6 to Force Link 1G, Flow Control ON */
mtk_switch_w32(gsw, 0x5e33b, GSW_REG_PORT_PMCR(6));

/* Set Port 6 as CPU Port */
mtk_switch_w32(gsw, 0x7f7f7fe0, 0x0010);

/* Enable MIB stats */
mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_MIB_CNT_EN) | (1 << 1), GSW_REG_MIB_CNT_EN);
}

The above function is used to setup port 6 as ethernet port, and the rest of ports are set as CPU ports. In order to setup CPU ports, the function _rt_syscon_set_cpu_ports() is used, and the default number of




NEXT




<s> ret_t rtl8367c_getAsicPortBlockSpa(rtk_uint32 port, rtk_uint32* pPermit)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_SOURCE_PORT_BLOCK_REG, port, pPermit);
}

The above function is used to get the status. But in rtl8367c_getAsicRegBit function, the return value is

return (rtk_uint32)(value&(1<<port)).

I just am not sure




NEXT




<s> int rtl839x_set_egress_rate(struct rtl838x_switch_priv *priv, int port, u32 rate)
{
u32 old_rate;

pr_debug("%s: Setting egress rate on port %d to %d\n", __func__, port, rate);
if (port >= priv->cpu_port)
return -1;

mutex_lock(&priv->reg_mutex);

rtl839x_read_scheduling_table(port);

old_rate = sw_r32(RTL839X_TBL_ACCESS_DATA_2(7)) & 0xff;
old_rate <<= 12;
old_rate |= sw_r32(RTL839X_TBL_ACCESS_DATA_2(8)) >> 20;
sw_w32_mask(0xff, (rate >> 12) & 0xff, RTL839X_TBL_ACCESS_DATA_2(7));
sw_w32_mask(0xfff << 20, rate << 20, RTL839X_TBL_ACCESS_DATA_2(8));

rtl839x_write_scheduling_table(port);

mutex_unlock(&priv->reg_mutex);

return old_rate;
}

The above function is used to set the egress rate using the rtl838x/rtl830x firmware. This function takes in a switch_port_t port and a u32 value. The function then writes the new value to the




NEXT




<s> IFX_MEI_FuseInit (DSL_DEV_Device_t * pDev)
{
u32 data = 0;
IFX_MEI_DMAWrite (pDev, IRAM0_BASE, &data, 1);
IFX_MEI_DMAWrite (pDev, IRAM0_BASE + 4, &data, 1);
IFX_MEI_DMAWrite (pDev, IRAM1_BASE, &data, 1);
IFX_MEI_DMAWrite (pDev, IRAM1_BASE + 4, &data, 1);
IFX_MEI_DMAWrite (pDev, BRAM_BASE, &data, 1);
IFX_MEI_DMAWrite (pDev, BRAM_BASE + 4, &data, 1);
IFX_MEI_DMAWrite (pDev, ADSL_DILV_BASE, &data, 1);
IFX_MEI_DMAWrite (pDev, ADSL_DILV_BASE + 4, &data, 1);
}

The above function is used to write zeros to the memory and flash of the
ADSL chip. But it also causes strange errors. Can you see why?

#define IRAM0_BASE 0x5000000
#define IR




NEXT




<s> static void pm_retx_counters_showtime(int fd, DSL_XTUDir_t direction) {
#ifdef INCLUDE_DSL_CPE_PM_RETX_COUNTERS
IOCTL_DIR(DSL_PM_ReTxCounters_t, DSL_FIO_PM_RETX_COUNTERS_SHOWTIME_GET, direction);

m_u32("mineftr", out.data.nEftrMin);
#endif
}

The above function is used to print the PM Eftr (Electrify Frames per time) to the console during the MIB (MIB-II) and RMON (RMON-II) collection in CPE using DSL4ALL. The same




NEXT




<s> static void rtl9310_writel(struct rtl9300_i2c *i2c, u32 data)
{
writel(data, REG(i2c, RTL9310_I2C_DATA));
}

The above function is used to write 32-bit data to the rtl*i2c.data
register. However, from the header file <linux/rtl922/9300.h>, this data
must be 16




NEXT




<s> static int rtl931x_mdio_write_paged(struct mii_bus *bus, int mii_id, u16 page,
int regnum, u16 value)
{
struct rtl838x_eth_priv *priv = bus->priv;
int err;

if (priv->phy_is_internal[mii_id])
return rtl931x_write_sds_phy(priv->sds_id[mii_id], page, regnum, value);

if (regnum & (MII_ADDR_C45 | MII_ADDR_C22_MMD)) {
err = rtl931x_write_mmd_phy(mii_id, mdiobus_c45_devad(regnum),
regnum, value);
pr_debug("MMD: %d dev %x register %x write %x, err %d\n", mii_id,
mdiobus_c45_devad(regnum), mdiobus_c45_regad(regnum),
value, err);

return err;
}

err = rtl931x_write_phy(mii_id, page, regnum, value);
pr_debug("PHY: %d register %x write %x, err %d\n", mii_id, regnum, value, err);

return err;
}

The above function is used to write to MD0 or other registers on a page-
addressable phy, so to write to MD0 (say,) we use it like this in driver:

if (mii_bus)
{
result = m




NEXT




<s> static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to push a valid oam message to the oam-related
interface functions.
#endif

int ifx_atm_set_lid(void);
int ifx_atm_get_lid(void);




NEXT




<s> static void __exit wl_glue_exit(void)
{
if (wl_glue_attached)
{
if (wl_glue_unregister())
pr_err("Failed to unregister glue driver\n");

wl_glue_attached = 0;
}

return;
}

The above function is used to uninitialize the module at the time of exit and is called once we hit the 'modinfo' command.

In addition to this, at the time of exit we call wl_glue_unregister() that is used to inform to




NEXT




<s> ret_t rtl8367c_getAsicLutLearnLimitNo(rtk_uint32 port, rtk_uint32* pNumber)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
return rtl8367c_getAsicReg(RTL8367C_LUT_PORT_LEARN_LIMITNO_REG(port), pNumber);
else
return rtl8367c_getAsicReg(RTL8367C_REG_LUT_PORT8_LEARN_LIMITNO+port-8, pNumber);
}

The above function is used to get the 8-24 MAC address learning limit.</s>




NEXT




<s> static int rtl839x_mdio_read_paged(struct mii_bus *bus, int mii_id, u16 page, int regnum)
{
u32 val;
int err;
struct rtl838x_eth_priv *priv = bus->priv;

if (mii_id >= 48 && mii_id <= 49 && priv->id == 0x8393)
return rtl839x_read_sds_phy(mii_id, regnum);

if (regnum & (MII_ADDR_C45 | MII_ADDR_C22_MMD)) {
err = rtl839x_read_mmd_phy(mii_id,
mdiobus_c45_devad(regnum),
regnum, &val);
pr_debug("MMD: %d dev %x register %x read %x, err %d\n", mii_id,
mdiobus_c45_devad(regnum), mdiobus_c45_regad(regnum),
val, err);
} else {
err = rtl839x_read_phy(mii_id, page, regnum, &val);
pr_debug("PHY: %d register %x read %x, err %d\n", mii_id, regnum, val, err);
}

if (err)
return err;

return val;
}

The above function is used to read values from specific MDIO PHY. It gets called from driver/net/mdio/rtl839x_mdio.c file. If you have a look at function rtl839x_mdio_




NEXT




<s> void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to dump the contents of yy_hold_char to the standard output.
#endif

#line 297 "lib/yaccpar.c"


#ifndef YY_NO_UNPUT
static void yy




NEXT




<s> rtk_api_ret_t rtk_igmp_maxGroup_set(rtk_port_t port, rtk_uint32 group)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if(group > RTL8367C_IGMP_MAX_GOUP)
return RT_ERR_OUT_OF_RANGE;

if ((retVal = rtl8367c_setAsicIGMPPortMAXGroup(rtk_switch_port_L2P_get(port), group))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the maximum number of groups(per port) on L2 switch.
if you want to set the maximum number of groups(per port) on L3 switch, you have to use the API as below.
uint32 igmp




NEXT




<s> void AT91F_MCI_Device_Handler(
AT91PS_MciDevice pMCI_Device,
unsigned int status)
{
// If End of Tx Buffer Empty interrupt occurred
if ( status & AT91C_MCI_TXBUFE )
{
AT91C_BASE_MCI->MCI_IDR = AT91C_MCI_TXBUFE;
AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_TXTDIS;

pMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_IDLE;
}	// End of if AT91C_MCI_TXBUFF

// If End of Rx Buffer Full interrupt occurred
if ( status & AT91C_MCI_RXBUFF )
{
AT91C_BASE_MCI->MCI_IDR = AT91C_MCI_RXBUFF;
AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_RXTDIS;

pMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_IDLE;
}	// End of if AT91C_MCI_RXBUFF

}

The above function is used to handle the AT91F_MCI module interrupt. Note that this function is not part of the MCIMCDriver implementation. The functions in the driver deal with the interrupts. AT91F_MCI calls the callback functions in




NEXT




<s> static void i2c_start(void)
{
sdalo();
scllo();
}

The above function is used to start a I2C transaction. It should only be used with a
valid i2c_addr on the I2C bus. The above function should be done with
the following:

static void i2c_stop(void




NEXT




<s> static int l2_table_open(struct inode *inode, struct file *filp)
{
return single_open(filp, l2_table_show, inode->i_private);
}

The above function is used to map the FAT entry to block number and is called inside l2_table_show. So the inode is not just any inode of the process directory but the one belonging to “l2_cache”.

The inode is used to open




NEXT




<s> static inline void m_db(const char *id, int value, int invalid) {
if (value != invalid)
m_double(id, (double)value / 10);
}

The above function is used to save the position of a ball, the coordinates of the centre of a ball, and the coordinates of a point.

So how do we know that this function has any real meaning?

If we look at the code for the function m




NEXT




<s> t_fromb64(dst, src)
register char *dst, *src;
{
unsigned char *a;
char *loc;
int i, j;
unsigned int size;

while(*src && (*src == ' ' || *src == '\t' || *src == '\n'))
++src;
size = strlen(src);

a = malloc((size + 1) * sizeof(unsigned char));
if(a == (unsigned char *) 0)
return -1;

i = 0;
while(i < size) {
loc = strchr(b64table, src[i]);
if(loc == (char *) 0)
break;
else
a[i] = loc - b64table;
++i;
}
size = i;

i = size - 1;
j = size;
while(1) {
a[j] = a[i];
if(--i < 0)
break;
a[j] |= (a[i] & 3) << 6;
--j;
a[j] = (unsigned char) ((a[i] & 0x3c) >> 2);
if(--i < 0)
break;
a[j] |= (a[i] & 0xf) << 4;
--j;
a[j] = (unsigned char) ((a[i] & 0x30) >> 4);
if(--i < 0)
break;
a[j] |= (a[i] << 2);

a[--j] = 0;
if(--i < 0)
break;
}

while(j <= size && a[j] == 0)
++j;

memcpy(dst, a + j, size - j + 1);
free(a);
return size - j + 1;
}

The above function is used to decode a BASE64 encoded string (represented by the character src) and store it in the buffer dst.

I will now demonstrate the usage of the function with a program that prints a simple message, to show how the function




NEXT




<s> static rtk_api_ret_t _rtk_switch_init_8364b(void)
{
ret_t retVal;
rtk_uint32 regData;

/*enable EEE, include mac & phy*/

if ((retVal = rtl8367c_setAsicRegBits(0x38, 0x300, 3)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0x78, 0x300, 3)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0xd8, 0x300, 0)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0xf8, 0x300, 0)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicPHYOCPReg(1, 0xa5d0, 6)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicPHYOCPReg(3, 0xa5d0, 6)) != RT_ERR_OK)
return retVal;

/*PAD para*/

/*EXT1 PAD Para*/
if ((retVal = rtl8367c_getAsicReg(0x1303, &regData)) != RT_ERR_OK)
return retVal;
regData &= 0xFFFFFFFE;
regData |= 0x250;
if((retVal = rtl8367c_setAsicReg(0x1303, regData)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRegBits(0x1304, 0x7000, 0)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0x1304, 0x700, 7)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x38, 0)) != RT_ERR_OK)
return retVal;

/*EXT2 PAD Para*/
if ((retVal = rtl8367c_setAsicRegBit(0x1303, 10, 1)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0x13E2, 0x1ff, 0x26)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x1c0, 0)) != RT_ERR_OK)
return retVal;


/*SDS PATCH*/
/*SP_CFG_EN_LINK_FIB1G*/
if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &regData)) != RT_ERR_OK)
return retVal;
regData |= 0x4;
if((retVal = rtl8367c_setAsicSdsReg(0,4,0, regData)) != RT_ERR_OK)
return retVal;

/*FIB100 Down-speed*/
if((retVal = rtl8367c_getAsicSdsReg(0, 1, 0, &regData)) != RT_ERR_OK)
return retVal;
regData |= 0x20;
if((retVal = rtl8367c_setAsicSdsReg(0,1,0, regData)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to initialize the system on board 8364B.
This function does not exist on HUB because it is empty.</s>




NEXT




<s> ret_t rtl8367c_setAsicFlowControlJumboModeSize(rtk_uint32 size)
{
if(size >= FC_JUMBO_SIZE_END)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SIZE, RTL8367C_JUMBO_SIZE_MASK, size);
}

The above function is used to indicate jumbo-frames maximum size supported by MAC. For reference, this function set the field from (12:0) bit of register RTL8367C_REG_FLOWCTRL_JUMBO_SIZE.




NEXT




<s> static void ptm_tx_timeout(struct net_device *, unsigned int txqueue);
#endif

static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to
initialize the private data and
allocate buffer pages.
return
0  OK

static int init_priv_data(void)
{
int ret;

struct ptm_buffer *buffer_page;
struct




NEXT




<s> static ssize_t sc_tag_show_cpufreq_indexes(const u8 *pld, u16 pld_len, char *buf)
{
const struct sc_u32tvs *tvs;

if (soc_is_ar71xx() || soc_is_ar724x())
tvs = sc_cpufreq_indexes_ath79_7x;
else
tvs = sc_cpufreq_indexes_ath79_9x;

return sc_tag_show_u32tvs(pld, pld_len, buf, tvs, sc_tag_cpufreq_ath79_arraysize());
}

The above function is used to find and show the indexes of the cpu frequency
for any platform specific configuration.</s>




NEXT




<s> static int rtl8366s_mii_write(struct mii_bus *bus, int addr, int reg, u16 val)
{
struct rtl8366_smi *smi = bus->priv;
u32 t;
int err;

err = rtl8366s_write_phy_reg(smi, addr, 0, reg, val);
/* flush write */
(void) rtl8366s_read_phy_reg(smi, addr, 0, reg, &t);

return err;
}

The above function is used to force the hardware to flush out any writes in progress before the read is
performed. We need to use this method for PHYs that support auto-negotiation

static int rt2860_mac_get_s




NEXT




<s> static int rtl8214fc_set_port(struct phy_device *phydev, int port)
{
bool is_fibre = (port == PORT_FIBRE ? true : false);
int addr = phydev->mdio.addr;

pr_debug("%s port %d to %d\n", __func__, addr, port);

rtl8214fc_media_set(phydev, is_fibre);

return 0;
}

The above function is used to set some configuration into rtl8214fc.

In my mind, the rtl8214fc works something similar to rtl8201, it is a media independent interface, and it would get related information




NEXT




<s> static inline u32 nmbm_crc32(u32 crcval, const void *buf, size_t size)
{
unsigned int chksz;
const unsigned char *p = buf;

while (size) {
if (size > UINT_MAX)
chksz = UINT_MAX;
else
chksz = (uint)size;

crcval = crc32_le(crcval, p, chksz);
size -= chksz;
p += chksz;
}

return crcval;
}

The above function is used to calculate a simple checksum on the data in a single buffer.</s>




NEXT




<s> const char *sym_type_name(enum symbol_type type)
{
switch (type) {
case S_BOOLEAN:
return "bool";
case S_TRISTATE:
return "tristate";
case S_INT:
return "integer";
case S_HEX:
return "hex";
case S_STRING:
return "string";
case S_UNKNOWN:
return "unknown";
}
return "???";
}

The above function is used to display text corresponding to a numerical
symbol_type, as in the following statement from the expression-printing
routine in the syntax tree dump program: *sym->name ?
sym_type_name(sym->type) : "<




NEXT




<s> int quality(const struct iwinfo_ops *iw, const char *ifname)
{
int qual;

if ( ! iw ) return -1;

if (qual_max < 1)
if (iw->quality_max(ifname, &qual_max))
return -1;

if (iw->quality(ifname, &qual))
return -1;

return ( qual * 100 ) / qual_max ;
}

The above function is used to determine the data rate of the 802.11 connection on an access point. Its first argument is a pointer to the structure obtained from a call to the iwinfo_ops_alloc() function. Its second argument is the name




NEXT




<s> static int ltq_mei_remove(struct platform_device *pdev)
{
int i = 0;
int num;

for (num = 0; num < BSP_MAX_DEVICES; num++) {
IFX_MEI_CleanUpDevNode (num);
}

for (i = 0; i < BSP_MAX_DEVICES; i++) {
for (i = 0; i < BSP_MAX_DEVICES; i++) {
IFX_MEI_ExitDevice (i);
}
}
return 0;
}

The above function is used to free memory dynamically allocated when probe function was executed.

Static int ltq_mei_add(struct platform_device *pdev) {
/* For every device there is one slot allocated */

int dev_num =




NEXT




<s> static ssize_t age_out_read(struct file *filp, char __user *buffer, size_t count,
loff_t *ppos)
{
struct rtl838x_port *p = filp->private_data;
struct dsa_switch *ds = p->dp->ds;
struct rtl838x_switch_priv *priv = ds->priv;
int value = sw_r32(priv->r->l2_port_aging_out);

if (value < 0)
return -EINVAL;

return rtl838x_common_read(buffer, count, ppos, (u32)value);
}

The above function is used to display the value in 32 bit register.

static ssize_t age_out_write(struct file *filp, const char __user *buffer,
size_t count, loff_t *ppos)




NEXT




<s> DSL_BSP_DriverHandleGet (int maj, int num)
{
DSL_DEV_Device_t *pDev;

if (num > BSP_MAX_DEVICES)
return NULL;

pDev = &dsl_devices[num];
if (!try_module_get(pDev->owner))
return NULL;

pDev->nInUse++;
return pDev;
}

The above function is used to create a handle to a device. It basically initializes the structure for it and gets the ownership module for each time a device is used. However, the dsl_devices[] array contains one or more DSL_DEV_Device_t structure




NEXT




<s> static void set_rtl8367s_sgmii(void)
{
rtk_port_mac_ability_t mac_cfg;
rtk_mode_ext_t mode;

mode = MODE_EXT_HSGMII;
mac_cfg.forcemode = MAC_FORCE;
mac_cfg.speed = PORT_SPEED_2500M;
mac_cfg.duplex = PORT_FULL_DUPLEX;
mac_cfg.link = PORT_LINKUP;
mac_cfg.nway = DISABLED;
mac_cfg.txpause = ENABLED;
mac_cfg.rxpause = ENABLED;
rtk_port_macForceLinkExt_set(EXT_PORT0, mode, &mac_cfg);
rtk_port_sgmiiNway_set(EXT_PORT0, DISABLED);
rtk_port_phyEnableAll_set(ENABLED);

}

The above function is used to set the Port0 to operate as a downstream port in 2.5G mode. Note that there is a known issue when using the rtl8367s SoC in 2.5G mode.

rtk




NEXT




<s> BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)
{
unsigned int i,m;
unsigned int n;
BN_ULONG l;

if (ret == NULL) ret=BN_new();
if (ret == NULL) return(NULL);
l=0;
n=len;
if (n == 0)
{
ret->top=0;
return(ret);
}
if (bn_expand(ret,(int)(n+2)*8) == NULL)
return(NULL);
i=((n-1)/BN_BYTES)+1;
m=((n-1)%(BN_BYTES));
ret->top=i;
while (n-- > 0)
{
l=(l<<8L)| *(s++);
if (m-- == 0)
{
ret->d[--i]=l;
l=0;
m=BN_BYTES-1;
}
}
/* need to call this due to clear byte at top if avoiding
* having the top bit set (-ve number) */
bn_fix_top(ret);
return(ret);
}

The above function is used to take a string of characters (as in ASCII representation of 0–9,A–F) and convert it to a BIGNUM. So, if we have `542F73` in the string variable `s




NEXT




<s> static int rtl8367s_vlan_config(int want_at_p0)
{
rtk_vlan_cfg_t vlan1, vlan2;

/* Set LAN/WAN VLAN partition */
memset(&vlan1, 0x00, sizeof(rtk_vlan_cfg_t));

RTK_PORTMASK_PORT_SET(vlan1.mbr, EXT_PORT0);
RTK_PORTMASK_PORT_SET(vlan1.mbr, UTP_PORT1);
RTK_PORTMASK_PORT_SET(vlan1.mbr, UTP_PORT2);
RTK_PORTMASK_PORT_SET(vlan1.mbr, UTP_PORT3);
RTK_PORTMASK_PORT_SET(vlan1.untag, EXT_PORT0);
RTK_PORTMASK_PORT_SET(vlan1.untag, UTP_PORT1);
RTK_PORTMASK_PORT_SET(vlan1.untag, UTP_PORT2);
RTK_PORTMASK_PORT_SET(vlan1.untag, UTP_PORT3);

if (want_at_p0) {
RTK_PORTMASK_PORT_SET(vlan1.mbr, UTP_PORT4);
RTK_PORTMASK_PORT_SET(vlan1.untag, UTP_PORT4);
} else {
RTK_PORTMASK_PORT_SET(vlan1.mbr, UTP_PORT0);
RTK_PORTMASK_PORT_SET(vlan1.untag, UTP_PORT0);
}

vlan1.ivl_en = 1;

rtk_vlan_set(1, &vlan1);

memset(&vlan2, 0x00, sizeof(rtk_vlan_cfg_t));

RTK_PORTMASK_PORT_SET(vlan2.mbr, EXT_PORT1);
RTK_PORTMASK_PORT_SET(vlan2.untag, EXT_PORT1);

if (want_at_p0) {
RTK_PORTMASK_PORT_SET(vlan2.mbr, UTP_PORT0);
RTK_PORTMASK_PORT_SET(vlan2.untag, UTP_PORT0);
} else {
RTK_PORTMASK_PORT_SET(vlan2.mbr, UTP_PORT4);
RTK_PORTMASK_PORT_SET(vlan2.untag, UTP_PORT4);
}

vlan2.ivl_en = 1;
rtk_vlan_set(2, &vlan2);

rtk_vlan_portPvid_set(EXT_PORT0, 1, 0);
rtk_vlan_portPvid_set(UTP_PORT1, 1, 0);
rtk_vlan_portPvid_set(UTP_PORT2, 1, 0);
rtk_vlan_portPvid_set(UTP_PORT3, 1, 0);
rtk_vlan_portPvid_set(EXT_PORT1, 2, 0);

if (want_at_p0) {
rtk_vlan_portPvid_set(UTP_PORT0, 2, 0);
rtk_vlan_portPvid_set(UTP_PORT4, 1, 0);
} else {
rtk_vlan_portPvid_set(UTP_PORT0, 1, 0);
rtk_vlan_portPvid_set(UTP_PORT4, 2, 0);
}

return 0;
}

The above function is used to configure the VLAN on rtl8367s (8367s) chip. The LAN and WAN partition may be defined as in the following picture:

Figure: VLAN configuration for 8367




NEXT




<s> static void rtl838x_read_pie_action(u32 r[],  struct pie_rule *pr)
{
u16 *aif = (u16 *)&r[17];

aif--;

pr_debug("%s, at %08x\n", __func__, (u32)aif);
if (pr->drop)
pr_debug("%s: Action Drop: %d", __func__, pr->drop);

if (pr->fwd_sel){ /* Forwarding action */
pr->fwd_act = *aif >> 13;
pr->fwd_data = *aif--;
pr->bypass_all = pr->fwd_data & BIT(12);
pr->bypass_ibc_sc = pr->fwd_data & BIT(11);
pr->bypass_igr_stp = pr->fwd_data & BIT(10);
if (pr->bypass_all || pr->bypass_ibc_sc || pr->bypass_igr_stp)
pr->bypass_sel = true;
}
if (pr->ovid_sel) /* Outer VID action */
pr->ovid_data = *aif--;
if (pr->ivid_sel) /* Inner VID action */
pr->ivid_data = *aif--;
if (pr->flt_sel) /* Filter action */
pr->flt_data = *aif--;
if (pr->log_sel) /* Log action */
pr->log_data = *aif--;
if (pr->rmk_sel) /* Remark action */
pr->rmk_data = *aif--;
if (pr->meter_sel) /* Meter action */
pr->meter_data = *aif--;
if (pr->tagst_sel) /* Egress Tag Status action */
pr->tagst_data = *aif--;
if (pr->mir_sel) /* Mirror action */
pr->mir_data = *aif--;
if (pr->nopri_sel) /* Normal Priority action */
pr->nopri_data = *aif--;
if (pr->cpupri_sel) /* CPU Priority action */
pr->nopri_data = *aif--;
if (pr->otpid_sel) /* OTPID action */
pr->otpid_data = *aif--;
if (pr->itpid_sel) /* ITPID action */
pr->itpid_data = *aif--;
if (pr->shaper_sel) /* Traffic shaper action */
pr->shaper_data = *aif--;
}

The above function is used to interpret the ruleset in the rule_data.

int rtl838x_get_rule_data(struct rtl838x *rtl, u32 rule_id, u32 *r,




NEXT




<s> swconfig_parse_ports(struct sk_buff *msg, struct nlattr *head,
struct switch_val *val, int max)
{
struct nlattr *nla;
int rem;

val->len = 0;
nla_for_each_nested(nla, head, rem) {
struct nlattr *tb[SWITCH_PORT_ATTR_MAX+1];
struct switch_port *port;

if (val->len >= max)
return -EINVAL;

port = &val->value.ports[val->len];

if (nla_parse_nested_deprecated(tb, SWITCH_PORT_ATTR_MAX, nla,
port_policy, NULL))
return -EINVAL;

if (!tb[SWITCH_PORT_ID])
return -EINVAL;

port->id = nla_get_u32(tb[SWITCH_PORT_ID]);
if (tb[SWITCH_PORT_FLAG_TAGGED])
port->flags |= (1 << SWITCH_PORT_FLAG_TAGGED);
val->len++;
}

return 0;
}

The above function is used to parse the port fields and fills the “switch_port” structure.</s>




NEXT




<s> void ase_shutdown(void)
{
uninit_pmu();
}

The above function is used to clean up whatever was initialized during _init. There are a number of functions which perform clean up tasks, one of which is "uninit_pmu()". It is called via an asm() to save what the initial stack pointer was then




NEXT




<s> ret_t rtl8367c_getAsicFlowControlPortPrivateDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF_MASK, pOffThreshold);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to get the private flow control port's off-state drop threshold and on-state drop threshold. These thresholds are derived from corresponding physical port's flow control off-state drop threshold(PHY_FC_DROP_THRESH




NEXT




<s> static int ubnt_ledbar_init_led(struct device_node *np, struct ubnt_ledbar *ledbar,
struct led_classdev *led_cdev)
{
struct led_init_data init_data = {};
int ret;

if (!np)
return 0;

init_data.fwnode = of_fwnode_handle(np);

led_cdev->max_brightness = UBNT_LEDBAR_MAX_BRIGHTNESS;

ret = devm_led_classdev_register_ext(&ledbar->client->dev, led_cdev,
&init_data);
if (ret)
dev_err(&ledbar->client->dev, "led register err: %d\n", ret);

return ret;
}

The above function is used to initialize the LED device. It receives a pointer to a device node, which is used to obtain the LED data. The function also receives a pointer to the ubnt_ledbar structure, which represents the device. Finally, the function receives a pointer




NEXT




<s> static int esw_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
int ports;
int vlan_idx = -1;
int i;

if (val->port_vlan < 0 || val->port_vlan >= RT305X_ESW_NUM_VIDS ||
val->len > RT305X_ESW_NUM_PORTS)
return -EINVAL;

/* one of the already defined vlans? */
for (i = 0; i < RT305X_ESW_NUM_VLANS; i++) {
if (esw->vlans[i].vid == val->port_vlan &&
esw->vlans[i].ports != RT305X_ESW_PORTS_NONE) {
vlan_idx = i;
break;
}
}

/* select a free slot */
for (i = 0; vlan_idx == -1 && i < RT305X_ESW_NUM_VLANS; i++) {
if (esw->vlans[i].ports == RT305X_ESW_PORTS_NONE)
vlan_idx = i;
}

/* bail if all slots are in use */
if (vlan_idx == -1)
return -EINVAL;

ports = RT305X_ESW_PORTS_NONE;
for (i = 0; i < val->len; i++) {
struct switch_port *p = &val->value.ports[i];
int port_mask = 1 << p->id;
bool untagged = !(p->flags & (1 << SWITCH_PORT_FLAG_TAGGED));

if (p->id >= RT305X_ESW_NUM_PORTS)
return -EINVAL;

ports |= port_mask;
esw->ports[p->id].untag = untagged;
}
esw->vlans[vlan_idx].ports = ports;
if (ports == RT305X_ESW_PORTS_NONE)
esw->vlans[vlan_idx].vid = RT305X_ESW_VLAN_NONE;
else
esw->vlans[vlan_idx].vid = val->port_vlan;

return 0;
}

The above function is used to select VLAN ID for a port, this is an example
how to change VLAN for 802.1q-capable ports (with the default VLAN number
set to untagged port, which is different from that




NEXT




<s> static void rt2880_init_data(struct fe_soc_data *data,
struct net_device *netdev)
{
struct fe_priv *priv = netdev_priv(netdev);

priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_PADDING_BUG |
FE_FLAG_JUMBO_FRAME | FE_FLAG_CALIBRATE_CLK;
netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_TX;
/* this should work according to the datasheet but actually does not*/
/* netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM; */
}

The above function is used to initialize a fe_soc_data struct on module load.
My question is this. I want to know if the fe_soc_data struct that stores the values defined in the above function is copied and assigned to another variable, can I achieve




NEXT




<s> static inline void rttm_enable_irq(void __iomem *base)
{
iowrite32(RTTM_INT_ENABLE, base + RTTM_INT);
}

The above function is used to enable interrupts in a simple case.

The following function is more flexible as all options are defined through
bit fields.

static inline void rttm_int_modify(void __iomem *base, u32




NEXT




<s> void rtl931x_pie_rule_dump_raw(u32 r[])
{
pr_info("Raw IACL table entry:\n");
pr_info("r 0 - 7: %08x %08x %08x %08x %08x %08x %08x %08x\n",
r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7]);
pr_info("r 8 - 15: %08x %08x %08x %08x %08x %08x %08x %08x\n",
r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15]);
pr_info("r 16 - 18: %08x %08x %08x\n", r[16], r[17], r[18]);
pr_info("Match  : %08x %08x %08x %08x %08x %08x\n", r[0], r[1], r[2], r[3], r[4], r[5]);
pr_info("Fixed  : %06x\n", r[6] >> 8);
pr_info("Match M: %08x %08x %08x %08x %08x %08x\n",
(r[6] << 24) | (r[7] >> 8), (r[7] << 24) | (r[8] >> 8), (r[8] << 24) | (r[9] >> 8),
(r[9] << 24) | (r[10] >> 8), (r[10] << 24) | (r[11] >> 8),
(r[11] << 24) | (r[12] >> 8));
pr_info("R[13]:   %08x\n", r[13]);
pr_info("Fixed M: %06x\n", ((r[12] << 16) | (r[13] >> 16)) & 0xffffff);
pr_info("Valid / not / and1 / and2 : %1x\n", (r[13] >> 12) & 0xf);
pr_info("r 13-16: %08x %08x %08x %08x\n", r[13], r[14], r[15], r[16]);
}

The above function is used to dump the IACL raw rules. This function prints out the raw rule in a hexadecimal format. The above function’s input parameter is r, which is a pointer to an array of 8 words. Each word in this array




NEXT




<s> zconf_endfile();
return T_EOL;
}
fclose(yyin);
yyterminate();
}
YY_BREAK
case 64:
YY_RULE_SETUP
YY_FATAL_ERROR( "flex scanner jammed" );
YY_BREAK

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = (yy_hold_char);
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{

The above function is used to
read in the lexeme from the input file. This function also takes care of the
eol marks in the files. The main logic in this function is shown below
<p class="codename1"></s>




NEXT




<s> static void mt7621_nfc_write_data(struct mt7621_nfc *nfc, const u8 *buf,
u32 len)
{
while (((uintptr_t)buf & 3) && len) {
mt7621_nfc_pio_write(nfc, *buf, true);
buf++;
len--;
}

while (len >= 4) {
mt7621_nfc_pio_write(nfc, *(const u32 *)buf, false);
buf += 4;
len -= 4;
}

while (len) {
mt7621_nfc_pio_write(nfc, *buf, true);
buf++;
len--;
}
}

The above function is used to write the data and its use will help in getting the correct input in the first pass.
The first few bytes can be written using the PIO writes and the remaining bytes can be passed using the PIO writes.
Similarly, the function




NEXT




<s> static int b53_port_get_mib(struct switch_dev *sw_dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct b53_device *dev = sw_to_b53(sw_dev);
const struct b53_mib_desc *mibs;
int port = val->port_vlan;
int len = 0;

if (!(BIT(port) & dev->enabled_ports))
return -1;

if (is5365(dev)) {
if (port == 5)
port = 8;

mibs = b53_mibs_65;
} else if (is63xx(dev)) {
mibs = b53_mibs_63xx;
} else {
mibs = b53_mibs;
}

dev->buf[0] = 0;

for (; mibs->size > 0; mibs++) {
u64 val;

if (mibs->size == 8) {
b53_read64(dev, B53_MIB_PAGE(port), mibs->offset, &val);
} else {
u32 val32;

b53_read32(dev, B53_MIB_PAGE(port), mibs->offset,
&val32);
val = val32;
}

len += snprintf(dev->buf + len, B53_BUF_SIZE - len,
"%-20s: %llu\n", mibs->name, val);
}

val->len = len;
val->value.s = dev->buf;

return 0;
}

The above function is used to retrieve b53 mibs on port basis.</s>




NEXT




<s> void msdc_debug_proc_init(void)
{
proc_create("msdc_debug", 0660, NULL, &msdc_debug_fops);
}

The above function is used to create a proc file called "msdc_debug". By reading the kernel source codes, this proc file is created by the driver MSDC, so the driver MSDC is related to the function. Through the process to understand the relationship with




NEXT




<s> ret_t rtl8367c_getAsicLutAgeTimerSpeed(rtk_uint32* pTimer, rtk_uint32* pSpeed)
{
rtk_uint32 regData;
ret_t retVal;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_LUT_CFG, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pTimer =  (regData & RTL8367C_AGE_TIMER_MASK) >> RTL8367C_AGE_TIMER_OFFSET;

*pSpeed =  (regData & RTL8367C_AGE_SPEED_MASK) >> RTL8367C_AGE_SPEED_OFFSET;

return RT_ERR_OK;

}

The above function is used to find the age limit and age speed of the LUT. The input parameters are two pointers to where the results are to be stored and the return value is RT_OK.

Retrun Value:
RT_OK
Error






NEXT




<s> static int sclhi(void)
{
gpio_direction_input(scl_index);
udelay(ADAP_DELAY);
if (!getscl()) {
printk(KERN_ERR "SCL pin should be low\n");
return -ETIMEDOUT;
}
return 0;
}

The above function is used to raise scl hi. Now lets see the sequence of actions involved in it.

gpio_direction_input(scl_index);
This configures the gpio as input to be read.

udelay(ADAP




NEXT




<s> static DSL_DEV_MeiError_t IFX_MEI_DownloadBootCode (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_ArcJtagEnable (DSL_DEV_Device_t *, int);
static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to print out the showtime values before and after
ATM transmitter test

The above function is the dummy ledcallback used after ifx_reg_atm_ledcallback
is used. It prints out all the led values.





NEXT




<s> static bool rtl83xx_lag_can_offload(struct dsa_switch *ds,
struct net_device *lag,
struct netdev_lag_upper_info *info)
{
int id;

id = dsa_lag_id(ds->dst, lag);
if (id < 0 || id >= ds->num_lag_ids)
return false;

if (info->tx_type != NETDEV_LAG_TX_TYPE_HASH) {
return false;
}
if (info->hash_type != NETDEV_LAG_HASH_L2 && info->hash_type != NETDEV_LAG_HASH_L23)
return false;

return true;
}

The above function is used to check if the TX offload of the
LAG/BRIDGE interface can be done. In the above code, NETDEV_LAG_TX_TYPE_HASH
is the flag of TX type. This flag is used to




NEXT




<s> uc_bpf_module_get_map(uc_vm_t *vm, size_t nargs)
{
struct bpf_object *obj = uc_fn_thisval("bpf.module");
struct bpf_map *map;
uc_value_t *name = uc_fn_arg(0);
int fd;

if (!obj || ucv_type(name) != UC_STRING)
err_return(EINVAL, NULL);

map = bpf_object__find_map_by_name(obj, ucv_string_get(name));
if (!map)
err_return(errno, NULL);

fd = bpf_map__fd(map);
if (fd < 0)
err_return(EINVAL, NULL);

return uc_bpf_map_create(fd, bpf_map__key_size(map), bpf_map__value_size(map), false);
}

The above function is used to retrieve the map by name. I didn't realize it could create new maps so the value is unused, but the program just calls it on a map so it has the right map name and does return success. Also bpf_map_create




NEXT




<s> static int fe_vlan_rx_kill_vid(struct net_device *dev,
__be16 proto, u16 vid)
{
struct fe_priv *priv = netdev_priv(dev);
u32 idx = (vid & 0xf);

if (!((fe_reg_table[FE_REG_FE_DMA_VID_BASE]) &&
(dev->features & NETIF_F_HW_VLAN_CTAG_TX)))
return 0;

clear_bit(idx, &priv->vlan_map);

return 0;
}

The above function is used to remove VID from FDCAN from the hardware
mapping table maintained in the driver. The FDCAN_FE driver uses this
function and calls the fe_vlan_rx_kill_vid() function with the vid as
1




NEXT




<s> int BN_is_prime_fasttest(const BIGNUM *a, int checks,
void (*callback)(int,int,void *),
BN_CTX *ctx_passed, void *cb_arg,
int do_trial_division)
{
int i, j, ret = -1;
int k;
BN_CTX *ctx = NULL;
BIGNUM *A1, *A1_odd, *check; /* taken from ctx */
BN_MONT_CTX *mont = NULL;
const BIGNUM *A = NULL;

if (checks == BN_prime_checks)
checks = BN_prime_checks_for_size(BN_num_bits(a));

/* first look for small factors */
if (!BN_is_odd(a))
return(0);
if (do_trial_division)
{
for (i = 1; i < NUMPRIMES; i++)
if (BN_mod_word(a, primes[i]) == 0)
return 0;
if (callback != NULL) callback(1, -1, cb_arg);
}

if (ctx_passed != NULL)
ctx = ctx_passed;
else
if ((ctx=BN_CTX_new()) == NULL)
goto err;
BN_CTX_start(ctx);

/* A := abs(a) */
if (a->neg)
{
BIGNUM *t;
if ((t = BN_CTX_get(ctx)) == NULL) goto err;
BN_copy(t, a);
t->neg = 0;
A = t;
}
else
A = a;
A1 = BN_CTX_get(ctx);
A1_odd = BN_CTX_get(ctx);
check = BN_CTX_get(ctx);
if (check == NULL) goto err;

/* compute A1 := A - 1 */
if (!BN_copy(A1, A))
goto err;
if (!BN_sub_word(A1, 1))
goto err;
if (BN_is_zero(A1))
{
ret = 0;
goto err;
}

/* write  A1  as  A1_odd * 2^k */
k = 1;
while (!BN_is_bit_set(A1, k))
k++;
if (!BN_rshift(A1_odd, A1, k))
goto err;

/* Montgomery setup for computations mod A */
mont = BN_MONT_CTX_new();
if (mont == NULL)
goto err;
if (!BN_MONT_CTX_set(mont, A, ctx))
goto err;

for (i = 0; i < checks; i++)
{
if (!BN_pseudo_rand(check, BN_num_bits(A1), 0, 0))
goto err;
if (BN_cmp(check, A1) >= 0)
if (!BN_sub(check, check, A1))
goto err;
if (!BN_add_word(check, 1))
goto err;
/* now 1 <= check < A */

j = witness(check, A, A1, A1_odd, k, ctx, mont);
if (j == -1) goto err;
if (j)
{
ret=0;
goto err;
}
if (callback != NULL) callback(1,i,cb_arg);
}
ret=1;
err:
if (ctx != NULL)
{
BN_CTX_end(ctx);
if (ctx_passed == NULL)
BN_CTX_free(ctx);
}
if (mont != NULL)
BN_MONT_CTX_free(mont);

return(ret);
}

The above function is used to test whether a number is prime or not by using a fast testing method.  If you go through the code, you can see that initially it checks for the small factors less than or equal to 26 prime numbers.</s>




NEXT




<s> static int add_dirent(const char *name, const char type, int parent)
{
struct jffs2_raw_dirent *de;

if (ofs - erasesize < sizeof(struct jffs2_raw_dirent) + strlen(name))
pad(erasesize);

prep_eraseblock();
last_ino++;
memset(buf + ofs, 0, sizeof(struct jffs2_raw_dirent));
de = (struct jffs2_raw_dirent *) (buf + ofs);

de->magic = JFFS2_MAGIC_BITMASK;
de->nodetype = JFFS2_NODETYPE_DIRENT;
de->type = type;
de->name_crc = crc32(0, name, strlen(name));
de->ino = last_ino++;
de->pino = parent;
de->totlen = sizeof(*de) + strlen(name);
de->hdr_crc = crc32(0, (void *) de, sizeof(struct jffs2_unknown_node) - 4);
de->version = last_version++;
de->mctime = 0;
de->nsize = strlen(name);
de->node_crc = crc32(0, (void *) de, sizeof(*de) - 8);
memcpy(de->name, name, strlen(name));

ofs += sizeof(struct jffs2_raw_dirent) + de->nsize;
pad(4);

return de->ino;
}

The above function is used to add a directory. It seems there is a bug here -- the call to prep_eraseblock() causes its argument erasecount to be set to 0.

If this function were properly written, then all those alloc_eraseblocks()




NEXT




<s> ret_t rtl8367c_getAsicAclIpRange(rtk_uint32 index, rtk_uint32* pType, ipaddr_t* pUpperIp, ipaddr_t* pLowerIp)
{
ret_t retVal;
rtk_uint32 regData;
ipaddr_t ipData;

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL4 + index*5, RTL8367C_ACL_IP_RANGE_ENTRY0_CTRL4_MASK, pType);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL2 + index*5, &regData);
if(retVal != RT_ERR_OK)
return retVal;
ipData = regData;


retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL3 + index*5, &regData);
if(retVal != RT_ERR_OK)
return retVal;

ipData = (regData <<16) | ipData;
*pUpperIp = ipData;


retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL0 + index*5, &regData);
if(retVal != RT_ERR_OK)
return retVal;
ipData = regData;


retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL1 + index*5, &regData);
if(retVal != RT_ERR_OK)
return retVal;

ipData = (regData << 16) | ipData;
*pLowerIp = ipData;

return RT_ERR_OK;
}

The above function is used to update the ACL ip range entry in VOIP module .The ACL range entry is stored in a 8-word register array to define 8 ip ranges. The first 4 words define 4 ip address ranges which can be either




NEXT




<s> static bool remap_block_nmbm(u16 block, u16 mapped_block, int copy_len)
{
struct nmbm_instance *ni = bmtd.ni;
int new_block;

if (block >= ni->data_block_count)
return false;

nmbm_set_block_state(ni, mapped_block, BLOCK_ST_BAD);
if (!nmbm_map_block(ni, block))
return false;

new_block = ni->block_mapping[block];
bbt_nand_erase(new_block);
if (copy_len > 0)
bbt_nand_copy(new_block, mapped_block, copy_len);
nmbm_update_info_table(ni);

return true;
}

The above function is used to map a block with bad address to a new flash block. Now the problem is why remap_block_nmbm may be called with negative value as input for the varible "copy_len" ?

The condition which will check




NEXT




<s> void print_in_middle(WINDOW *win, int y, int width, const char *str, int attrs)
{
wattrset(win, attrs);
mvwprintw(win, y, (width - strlen(str)) / 2, "%s", str);
}

The above function is used to print messages in the middle of screen.

What is the drawback of it as i have written this code only for the menu
section and now my code has become very ugly. Is there any better
solution available?
I guess




NEXT




<s> int des_setkey_skcipher (struct crypto_skcipher *tfm, const u8 *in_key, unsigned int key_len)
{
return des_setkey(crypto_skcipher_tfm(tfm), in_key, key_len);
}

The above function is used to set the DES-SET-KEY algorithm for
ciphering/deciphering. The corresponding function used to initiate a
cipher/ decipher operation is the following.

int crypto_ecb_encrypt (const u




NEXT




<s> static int ptm_napi_poll(struct napi_struct *, int);
static int ptm_hard_start_xmit(struct sk_buff *, struct net_device *);
static int ptm_ioctl(struct net_device *, struct ifreq *, int);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
static void ptm_tx_timeout(struct net_device *);
#else
static void ptm_tx_timeout(struct net_device *, unsigned int txqueue);
#endif

static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to swap descriptors from the ring.
static inline void
do_swap_desc_tasklet(unsigned long param)
{
int tx_idx;

for (tx_idx = 0; tx_idx < PTM




NEXT




<s> static int b53_mmap_probe(struct platform_device *pdev)
{
struct b53_platform_data *pdata = pdev->dev.platform_data;
struct b53_device *dev;

if (!pdata)
return -EINVAL;

dev = b53_swconfig_switch_alloc(&pdev->dev, &b53_mmap_ops, pdata->regs);
if (!dev)
return -ENOMEM;

if (pdata)
dev->pdata = pdata;

platform_set_drvdata(pdev, dev);

return b53_swconfig_switch_register(dev);
}

The above function is used to initialize b53_driver.

The below function is used to initialize b53_mmap driver.

static int b53_mmap_probe(struct platform_device *pdev)
{
struct b5




NEXT




<s> ret_t rtl8367c_getAsicVlanMemberConfig(rtk_uint32 index, rtl8367c_vlanconfiguser *pVlanCg)
{
ret_t  retVal;
rtk_uint32 page_idx;
rtk_uint32 regAddr;
rtk_uint32 regData;
rtk_uint16 *tableAddr;
rtk_uint16 smi_vlancfg[RTL8367C_VLAN_MBRCFG_LEN];

if(index > RTL8367C_CVIDXMAX)
return RT_ERR_VLAN_ENTRY_NOT_FOUND;

memset(smi_vlancfg, 0x00, sizeof(rtk_uint16) * RTL8367C_VLAN_MBRCFG_LEN);
tableAddr  = smi_vlancfg;

for(page_idx = 0; page_idx < 4; page_idx++)  /* 4 pages per VLAN Member Config */
{
regAddr = RTL8367C_VLAN_MEMBER_CONFIGURATION_BASE + (index * 4) + page_idx;

retVal = rtl8367c_getAsicReg(regAddr, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*tableAddr = (rtk_uint16)regData;
tableAddr++;
}

_rtl8367c_VlanMCStSmi2User(smi_vlancfg, pVlanCg);
return RT_ERR_OK;
}

The above function is used to copy the user entered information, such as VLAN ID, Port Status, Port Priority and Port Action from the user space into the VLAN Member configuration structure in the user memory space. Before the VLAN Member configuration structure is copied from the user




NEXT




<s> register_switch(struct switch_dev *dev, struct net_device *netdev)
{
struct switch_dev *sdev;
const int max_switches = 8 * sizeof(unsigned long);
unsigned long in_use = 0;
int err;
int i;

INIT_LIST_HEAD(&dev->dev_list);
if (netdev) {
dev->netdev = netdev;
if (!dev->alias)
dev->alias = netdev->name;
}
BUG_ON(!dev->alias);

/* Make sure swdev_id doesn't overflow */
if (swdev_id == INT_MAX) {
return -ENOMEM;
}

if (dev->ports > 0) {
dev->portbuf = kzalloc(sizeof(struct switch_port) *
dev->ports, GFP_KERNEL);
if (!dev->portbuf)
return -ENOMEM;
dev->portmap = kzalloc(sizeof(struct switch_portmap) *
dev->ports, GFP_KERNEL);
if (!dev->portmap) {
kfree(dev->portbuf);
return -ENOMEM;
}
}
swconfig_defaults_init(dev);
mutex_init(&dev->sw_mutex);
swconfig_lock();
dev->id = ++swdev_id;

list_for_each_entry(sdev, &swdevs, dev_list) {
if (!sscanf(sdev->devname, SWCONFIG_DEVNAME, &i))
continue;
if (i < 0 || i > max_switches)
continue;

set_bit(i, &in_use);
}
i = find_first_zero_bit(&in_use, max_switches);

if (i == max_switches) {
swconfig_unlock();
return -ENFILE;
}

#ifdef CONFIG_OF
if (dev->ports)
of_switch_load_portmap(dev);
#endif

/* fill device name */
snprintf(dev->devname, IFNAMSIZ, SWCONFIG_DEVNAME, i);

list_add_tail(&dev->dev_list, &swdevs);
swconfig_unlock();

err = swconfig_create_led_trigger(dev);
if (err)
return err;

return 0;
}

The above function is used to register the switch device in the switch fabric.</s>




NEXT




<s> static int elf32_determine_size(struct mtd_info *mtd, struct elf_header *hdr,
size_t *size)
{
struct elf_header_32 *hdr32 = &(hdr->elf32);
int err;
size_t section_end, ph_table_end, ph_entry;
struct elf_program_header_32 ph;

*size = 0;

if (hdr32->shoff > 0) {
*size = hdr32->shoff + hdr32->shentsize * hdr32->shnum;
return 0;
}

ph_entry = hdr32->phoff;
ph_table_end = hdr32->phoff + hdr32->phentsize * hdr32->phnum;

while (ph_entry < ph_table_end) {
err = mtdsplit_elf_read_mtd(mtd, ph_entry, (uint8_t *)(&ph),
sizeof(ph));
if (err)
return err;

section_end = ph.offset + ph.filesize;
if (section_end > *size)
*size = section_end;

ph_entry += hdr32->phentsize;
}

return 0;
}

The above function is used to read the ELF header, get the program header table, and determine the size of the data. When the ELF header is in the first position of the memory, it will calculate the size of the whole file using ELF_S_NUM




NEXT




<s> ret_t rtl8367c_getAsicRldp(rtk_uint32 *pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_ENABLE_OFFSET, pEnabled);
}

The above function is used to get the current status of the rldp function. If you want to enable it, a call to this function will be very helpful. This function takes a pointer to `rldp` to store whether it is on or not and returns true




NEXT




<s> rtk_api_ret_t rtk_ptp_refTimeEnable_set(rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicEavSysTimeCtrl(enable))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable EAV sys time control, if any system time control is required.

rtk_api_ret_t rtk_ptp_refTimeForceDelayTime_get(rtk_ptp_refTimeForceDelayTime




NEXT




<s> static int fit_image_get_data_and_size(const void *fit, int noffset,
const void **data, size_t *size)
{
bool external_data = false;
int offset;
int len;
int ret;

if (!fit_image_get_data_position(fit, noffset, &offset)) {
external_data = true;
} else if (!fit_image_get_data_offset(fit, noffset, &offset)) {
external_data = true;
/*
* For FIT with external data, figure out where
* the external images start. This is the base
* for the data-offset properties in each image.
*/
offset += ((fdt_totalsize(fit) + 3) & ~3);
}

if (external_data) {
ret = fit_image_get_data_size(fit, noffset, &len);
if (!ret) {
*data = fit + offset;
*size = len;
}
} else {
ret = fit_image_get_data(fit, noffset, data, size);
}

return ret;
}

The above function is used to obtain the address of the data part of the FIT file. The input noffset variable is the index of the image from which the data is to be fetched. The FIT data is kept in the internal memory in the below address:






NEXT




<s> swconfig_apply_config(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
/* don't complain if not supported by the switch driver */
if (!dev->ops->apply_config)
return 0;

return dev->ops->apply_config(dev);
}

The above function is used to apply a specified attribute's value for a given switch device. So in each switch port configuration function, we just check if the switch hardware supports the configuration, then call swconfig_apply_config function.</s>




NEXT




<s> void	green_LED_off(void)
{
AT91PS_PIO	PIOB	= AT91C_BASE_PIOB;
//	PIOB->PIO_SODR		= GREEN_LED;
PIOB->PIO_SODR		= (1 << 0);
}

The above function is used to control a Green LED which is connected
to port IO line 0 (0th bit) of port IO port B. This function is located
in the file gpio.c . When this function is called, the bit of 0th




NEXT




<s> rtk_api_ret_t rtk_vlan_realKeepRemarkEnable_get(rtk_enable_t *pEnabled)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnabled)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getRealKeepRemarkEn((rtk_uint32 *)pEnabled)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the VLAN keep Remark flag status.If it returns RT_ERR_OK, the VLAN keep Remark flag status will be retrieved successfully.


rtk_enable_t rtk_vlan_realKeep




NEXT




<s> rtl_attr_set_vlan_int(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
if (val->port_vlan >= dev->vlans)
return -EINVAL;

return rtl_attr_set_int(dev, attr, val);
}

The above function is used to set new VLAN ID on the port. The following code shows the caller of the above function while setting a VLAN tag. The port_vlan and port_id parameters are initialized from the function argument:

struct switch_val val




NEXT




<s> int __init lqdeu_async_aes_init (void)
{
int i, j, ret = -EINVAL;

#define IFX_DEU_DRV_VERSION  "2.0.0"
printk(KERN_INFO "Lantiq Technologies DEU Driver version %s\n", IFX_DEU_DRV_VERSION);

for (i = 0; i < ARRAY_SIZE(aes_drivers_alg); i++) {
ret = crypto_register_alg(&aes_drivers_alg[i].alg);
printk("driver: %s\n", aes_drivers_alg[i].alg.cra_name);
if (ret)
goto aes_err;
}

aes_chip_init();

CRTCL_SECT_INIT;


printk (KERN_NOTICE "Lantiq DEU AES initialized %s %s.\n",
disable_multiblock ? "" : " (multiblock)", disable_deudma ? "" : " (DMA)");

return ret;

aes_err:

for (j = 0; j < i; j++)
crypto_unregister_alg(&aes_drivers_alg[j].alg);

printk(KERN_ERR "Lantiq %s driver initialization failed!\n", (char *)&aes_drivers_alg[i].alg.cra_driver_name);
return ret;

ctr_rfc3686_aes_err:
for (i = 0; i < ARRAY_SIZE(aes_drivers_alg); i++) {
if (!strcmp((char *)&aes_drivers_alg[i].alg.cra_name, "rfc3686(ctr(aes))"))
crypto_unregister_alg(&aes_drivers_alg[j].alg);
}
printk (KERN_ERR "Lantiq ctr_rfc3686_aes initialization failed!\n");
return ret;
}

The above function is used to create a crypto device from kernel
module. Here, in this chapter, we have focused on the initialising
of the AES module. This module is used to encrypt and decrypt the
data using the Advanced Encryption Standard (A




NEXT




<s> print_attr_val(const struct switch_attr *attr, const struct switch_val *val)
{
struct switch_port_link *link;
int i;

switch (attr->type) {
case SWITCH_TYPE_INT:
printf("%d", val->value.i);
break;
case SWITCH_TYPE_STRING:
printf("%s", val->value.s);
break;
case SWITCH_TYPE_PORTS:
for(i = 0; i < val->len; i++) {
printf("%d%s ",
val->value.ports[i].id,
(val->value.ports[i].flags &
SWLIB_PORT_FLAG_TAGGED) ? "t" : "");
}
break;
case SWITCH_TYPE_LINK:
link = val->value.link;
if (link->link)
printf("port:%d link:up speed:%s %s-duplex %s%s%s%s%s",
val->port_vlan,
speed_str(link->speed),
link->duplex ? "full" : "half",
link->tx_flow ? "txflow " : "",
link->rx_flow ? "rxflow " : "",
link->eee & SWLIB_LINK_FLAG_EEE_100BASET ? "eee100 " : "",
link->eee & SWLIB_LINK_FLAG_EEE_1000BASET ? "eee1000 " : "",
link->aneg ? "auto" : "");
else
printf("port:%d link:down", val->port_vlan);
break;
default:
printf("?unknown-type?");
}
}

The above function is used to display the value of an attribute of the port. How can I get the value of the object’s attribute?</s>




NEXT




<s> ar8xxx_age_time_val(int age_time)
{
return (age_time + AR8XXX_REG_ARL_CTRL_AGE_TIME_SECS / 2) /
AR8XXX_REG_ARL_CTRL_AGE_TIME_SECS;
}

The above function is used to calculate the value according to which this bit field
AR8XXX_REG_ARL_CTRL_ENBL_MSEC_TIMER: age time of 100 ms is used to update the AAR
fields. This




NEXT




<s> ret_t rtl8367c_getAsicPortUnknownMulticastFloodingPortmask(rtk_uint32 *pPortmask)
{
return rtl8367c_getAsicReg(RTL8367C_UNMCAST_FLOADING_PMSK_REG, pPortmask);
}

The above function is used to query the asic whether the port can flood the undetectable multicast frame.

It returns RT_SUCCESS if any port can flood.  If the port is configured, it may return RTL8367C_




NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_cfg_del(rtk_filter_id_t filter_id)
{
rtl8367c_aclrule initRule;
rtl8367c_acl_act_t  initAct;
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(filter_id > RTL8367C_ACLRULEMAX )
return RT_ERR_FILTER_ENTRYIDX;

memset(&initRule, 0, sizeof(rtl8367c_aclrule));
memset(&initAct, 0, sizeof(rtl8367c_acl_act_t));

if((ret = rtl8367c_setAsicAclRule(filter_id, &initRule)) != RT_ERR_OK)
return ret;
if((ret = rtl8367c_setAsicAclActCtrl(filter_id, FILTER_ENACT_INIT_MASK))!= RT_ERR_OK)
return ret;
if((ret = rtl8367c_setAsicAclAct(filter_id, &initAct)) != RT_ERR_OK)
return ret;
if((ret = rtl8367c_setAsicAclNot(filter_id, DISABLED)) != RT_ERR_OK )
return ret;

return RT_ERR_OK;
}

The above function is used to delete one specified ACL RULE from the ACL database.

Example
/* Delete ACL RULE 10 */
if((ret = rtk_filter_igrAcl_cfg_del(10))!= RT




NEXT




<s> IFX_MEI_IRQDisable (DSL_DEV_Device_t * pDev)
{
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_ARC2ME_MASK,  0x0);
}

The above function is used to disable the irq generated from ME to ARC interface. But the device still generates irq in some cases due to some hw erroneous state. That irq has an erroneous source. To resolve this issue, I'm trying to clear this




NEXT




<s> ret_t rtl8367c_setAsicLutLearnOverAct(rtk_uint32 action)
{
if(action >= LRNOVERACT_END)
return RT_ERR_NOT_ALLOWED;

return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_SECURITY_CTRL, RTL8367C_LUT_LEARN_OVER_ACT_MASK, action);
}

The above function is used to configure the LUT learning control action over the actions of each port.
For example: set to 0 and write to the port 1 to 7, the port will learn an entry in the LUT.

The source code of




NEXT




<s> ret_t rtl8367c_setAsicFlowControlSharedThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_SHARE_OFF, RTL8367C_FLOWCTRL_SHARE_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_SHARE_ON, RTL8367C_FLOWCTRL_SHARE_ON_MASK, onThreshold);

return retVal;
}

The above function is used to set or get the threshold values for the shared flow-control unit.

For instance, if I wanted to set the threshold values for the shared flow-control to 26 pages and 27 pages, I would do:






NEXT




<s> ret_t rtl8367c_getAsicRldpLoopedPortmask(rtk_uint32 *pPortmask)
{
return rtl8367c_getAsicReg(RTL8367C_RLDP_LOOP_PMSK_REG, pPortmask);
}

The above function is used to obtain the loop port bitmap in register RTL8367C_RLDP_LOOP_PMSK_REG

If we go through the code, we find that register RTL8367C_RLDP_




NEXT




<s> static int rtl8390_configure_serdes(struct phy_device *phydev)
{
phydev_info(phydev, "Detected internal RTL8390 SERDES\n");

/* In autoneg state, force link, set SR4_CFG_EN_LINK_FIB1G */
sw_w32_mask(0, 1 << 18, RTL839X_SDS12_13_XSG0 + 0x0a);

/* Disable EEE: Clear FRE16_EEE_RSG_FIB1G, FRE16_EEE_STD_FIB1G,
* FRE16_C1_PWRSAV_EN_FIB1G, FRE16_C2_PWRSAV_EN_FIB1G
* and FRE16_EEE_QUIET_FIB1G
*/
sw_w32_mask(0x1f << 10, 0, RTL839X_SDS12_13_XSG0 + 0xe0);

return 0;
}

The above function is used to configure the RTL8390 SERDES, and it is part of the PHY driver for an RTL chip. The key line is:
sw_w32_mask(0, 1 << 18,




NEXT




<s> static int fe_poll_tx(struct fe_priv *priv, int budget, u32 tx_intr,
int *tx_again)
{
struct net_device *netdev = priv->netdev;
unsigned int bytes_compl = 0;
struct sk_buff *skb;
struct fe_tx_buf *tx_buf;
int done = 0;
u32 idx, hwidx;
struct fe_tx_ring *ring = &priv->tx_ring;

idx = ring->tx_free_idx;
hwidx = fe_reg_r32(FE_REG_TX_DTX_IDX0);

while ((idx != hwidx) && budget) {
tx_buf = &ring->tx_buf[idx];
skb = tx_buf->skb;

if (!skb)
break;

if (skb != (struct sk_buff *)DMA_DUMMY_DESC) {
bytes_compl += skb->len;
done++;
budget--;
}
fe_txd_unmap(priv->dev, tx_buf);
idx = NEXT_TX_DESP_IDX(idx);
}
ring->tx_free_idx = idx;

if (idx == hwidx) {
/* read hw index again make sure no new tx packet */
hwidx = fe_reg_r32(FE_REG_TX_DTX_IDX0);
if (idx == hwidx)
fe_reg_w32(tx_intr, FE_REG_FE_INT_STATUS);
else
*tx_again = 1;
} else {
*tx_again = 1;
}

if (done) {
netdev_completed_queue(netdev, done, bytes_compl);
smp_mb();
if (unlikely(netif_queue_stopped(netdev) &&
(fe_empty_txd(ring) > ring->tx_thresh)))
netif_wake_queue(netdev);
}

return done;
}

The above function is used to transfer 802.11 packets from the higher
layer to driver. The implementation follows the standard ring
buffers and is used to transfer the packets.

static void fe_poll_rx_workfn(struct work_




NEXT




<s> void rtl839x_set_port_reg_le(u64 set, int reg)
{
sw_w32(set, reg);
sw_w32(set >> 32, reg + 4);
}

The above function is used to write 64 bits directly to a PORT_CTL register of the ralink RT3300, used in the Linksys WRT40X or Asus WL-520-P2.

The problem




NEXT




<s> IFX_MEI_MailboxRead (DSL_DEV_Device_t * pDev, u16 * msgdestbuffer,
u16 msgsize)
{
DSL_DEV_MeiError_t meiMailboxError = DSL_DEV_MEI_ERR_SUCCESS;
//      Read from mailbox
meiMailboxError =
IFX_MEI_DMARead (pDev, ARC_TO_MEI_MAILBOX, (u32 *) msgdestbuffer, msgsize / 2);

//      Notify arc that mailbox read completed
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_ARC2ME_STAT, ARC_TO_MEI_MSGAV);

return meiMailboxError;
}

The above function is used to access from Mei mailbox. Mailbox is a 512 byte block of memory. Mailbox is used to transfer data between Mei and Arc.</s>




NEXT




<s> rtk_api_ret_t rtk_port_macForceLink_get(rtk_port_t port, rtk_port_mac_ability_t *pPortability)
{
rtk_api_ret_t retVal;
rtl8367c_port_ability_t ability;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

if(NULL == pPortability)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortForceLink(rtk_switch_port_L2P_get(port), &ability)) != RT_ERR_OK)
return retVal;

pPortability->forcemode = ability.forcemode;
pPortability->speed     = ability.speed;
pPortability->duplex    = ability.duplex;
pPortability->link      = ability.link;
pPortability->nway      = ability.nway;
pPortability->txpause   = ability.txpause;
pPortability->rxpause   = ability.rxpause;

return RT_ERR_OK;
}

The above function is used to get the forced MAC link ability of a 1000Base-T port. This function will query the macForceLink of an port to get the force mode, speed and duplex of an port. The return value indicates if the function




NEXT




<s> void __init br200_wp_pic_init(void)
{
struct mpic *mpic;

mpic = mpic_alloc(NULL, 0,
MPIC_BIG_ENDIAN |
MPIC_SINGLE_DEST_CPU,
0, 256, " OpenPIC  ");

BUG_ON(mpic == NULL);
mpic_init(mpic);
}

The above function is used to set interrupt vectors:

void __cold boot_init_interrupts(void)
{
/* Use our interrupt controller */
{
u32 i;

struct mpic_regs *mpicreg;






NEXT




<s> int b53_swconfig_switch_detect(struct b53_device *dev)
{
u32 id32;
u16 tmp;
u8 id8;
int ret;

ret = b53_read8(dev, B53_MGMT_PAGE, B53_DEVICE_ID, &id8);
if (ret)
return ret;

switch (id8) {
case 0:
/*
* BCM5325 and BCM5365 do not have this register so reads
* return 0. But the read operation did succeed, so assume
* this is one of them.
*
* Next check if we can write to the 5325's VTA register; for
* 5365 it is read only.
*/

b53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, 0xf);
b53_read16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, &tmp);

if (tmp == 0xf)
dev->chip_id = BCM5325_DEVICE_ID;
else
dev->chip_id = BCM5365_DEVICE_ID;
break;
case BCM5395_DEVICE_ID:
case BCM5397_DEVICE_ID:
case BCM5398_DEVICE_ID:
dev->chip_id = id8;
break;
default:
ret = b53_read32(dev, B53_MGMT_PAGE, B53_DEVICE_ID, &id32);
if (ret)
return ret;

switch (id32) {
case BCM53115_DEVICE_ID:
case BCM53125_DEVICE_ID:
case BCM53128_DEVICE_ID:
case BCM53010_DEVICE_ID:
case BCM53011_DEVICE_ID:
case BCM53012_DEVICE_ID:
case BCM53018_DEVICE_ID:
case BCM53019_DEVICE_ID:
dev->chip_id = id32;
break;
default:
pr_err("unsupported switch detected (BCM53%02x/BCM%x)\n",
id8, id32);
return -ENODEV;
}
}

if (dev->chip_id == BCM5325_DEVICE_ID)
return b53_read8(dev, B53_STAT_PAGE, B53_REV_ID_25,
&dev->core_rev);
else
return b53_read8(dev, B53_MGMT_PAGE, B53_REV_ID,
&dev->core_rev);
}

The above function is used to identify which chipset we're using.</s>




NEXT




<s> int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)
{
BIGNUM Ri,*R;

BN_init(&Ri);
R= &(mont->RR);                                 /* grab RR as a temp */
BN_copy(&(mont->N),mod);                        /* Set N */

#ifdef MONT_WORD
{
BIGNUM tmod;
BN_ULONG buf[2];

mont->ri=(BN_num_bits(mod)+(BN_BITS2-1))/BN_BITS2*BN_BITS2;
BN_zero(R);
BN_set_bit(R,BN_BITS2);                 /* R */

buf[0]=mod->d[0]; /* tmod = N mod word size */
buf[1]=0;
tmod.d=buf;
tmod.top=1;
tmod.dmax=2;
tmod.neg=mod->neg;
/* Ri = R^-1 mod N*/
if ((BN_mod_inverse(&Ri,R,&tmod,ctx)) == NULL)
goto err;
BN_lshift(&Ri,&Ri,BN_BITS2);            /* R*Ri */
if (!BN_is_zero(&Ri))
BN_sub_word(&Ri,1);
else /* if N mod word size == 1 */
BN_set_word(&Ri,BN_MASK2);  /* Ri-- (mod word size) */
BN_div(&Ri,NULL,&Ri,&tmod,ctx); /* Ni = (R*Ri-1)/N,
* keep only least significant word: */
mont->n0=Ri.d[0];
BN_free(&Ri);
}
#else /* !MONT_WORD */
{ /* bignum version */
mont->ri=BN_num_bits(mod);
BN_zero(R);
BN_set_bit(R,mont->ri);                 /* R = 2^ri */
/* Ri = R^-1 mod N*/
if ((BN_mod_inverse(&Ri,R,mod,ctx)) == NULL)
goto err;
BN_lshift(&Ri,&Ri,mont->ri);            /* R*Ri */
BN_sub_word(&Ri,1);
/* Ni = (R*Ri-1) / N */
BN_div(&(mont->Ni),NULL,&Ri,mod,ctx);
BN_free(&Ri);
}
#endif

/* setup RR for conversions */
BN_zero(&(mont->RR));
BN_set_bit(&(mont->RR),mont->ri*2);
BN_mod(&(mont->RR),&(mont->RR),&(mont->N),ctx);

return(1);
err:
return(0);
}

The above function is used to initialize a BN_MONT_CTX structure. This is done in BN_mod_mult() if mont is set to 2 by the caller (the default as provided by the interface for most back-end methods in the SAF




NEXT




<s> static void __exit button_hotplug_exit(void)
{
input_unregister_handler(&button_hotplug_handler);
}

The above function is used to register hotplug events. This will let us know when a new device is plugged in and when it is removed. We start this by creating a new device entry:

module_param(name, charp, 0);






NEXT




<s> ret_t rtl8367c_setAsicIGMPIsoLeaky(rtk_uint32 leaky)
{
ret_t   retVal;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_PORTISO_LEAKY_OFFSET, leaky);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure whether or not the switch should use the port Isolation mode for the G-MLD (leaky mode or non-leaky mode). However we are not sure how this setting will affect the switch performance in terms of the control packets transmission




NEXT




<s> static void msdc_dma_config(struct msdc_host *host, struct msdc_dma *dma)
{
void __iomem *base = host->base;
//u32 i, j, num, bdlen, arg, xfersz;
u32 j, num;
struct scatterlist *sg;
struct gpd *gpd;
struct bd *bd;

switch (dma->mode) {
case MSDC_MODE_DMA_BASIC:
BUG_ON(host->xfer_size > 65535);
BUG_ON(dma->sglen != 1);
sdr_write32(MSDC_DMA_SA, PHYSADDR(sg_dma_address(sg)));
sdr_set_field(MSDC_DMA_CTRL, MSDC_DMA_CTRL_LASTBUF, 1);
//#if defined (CONFIG_RALINK_MT7620)
if (ralink_soc == MT762X_SOC_MT7620A)
sdr_set_field(MSDC_DMA_CTRL, MSDC_DMA_CTRL_XFERSZ, sg_dma_len(sg));
//#elif defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628)
else
sdr_write32((void __iomem *)(RALINK_MSDC_BASE + 0xa8), sg_dma_len(sg));
//#endif
sdr_set_field(MSDC_DMA_CTRL, MSDC_DMA_CTRL_BRUSTSZ,
MSDC_BRUST_64B);
sdr_set_field(MSDC_DMA_CTRL, MSDC_DMA_CTRL_MODE, 0);
break;
case MSDC_MODE_DMA_DESC:

/* calculate the required number of gpd */
num = (dma->sglen + MAX_BD_PER_GPD - 1) / MAX_BD_PER_GPD;
BUG_ON(num != 1);

gpd = dma->gpd;
bd  = dma->bd;

/* modify gpd*/
//gpd->intr = 0;
gpd->hwo = 1;  /* hw will clear it */
gpd->bdp = 1;
gpd->chksum = 0;  /* need to clear first. */
gpd->chksum = msdc_dma_calcs((u8 *)gpd, 16);

/* modify bd*/
for_each_sg(dma->sg, sg, dma->sglen, j) {
bd[j].blkpad = 0;
bd[j].dwpad = 0;
bd[j].ptr = (void *)sg_dma_address(sg);
bd[j].buflen = sg_dma_len(sg);

if (j == dma->sglen - 1)
bd[j].eol = 1;	/* the last bd */
else
bd[j].eol = 0;

bd[j].chksum = 0; /* checksume need to clear first */
bd[j].chksum = msdc_dma_calcs((u8 *)(&bd[j]), 16);
}

sdr_set_field(MSDC_DMA_CFG, MSDC_DMA_CFG_DECSEN, 1);
sdr_set_field(MSDC_DMA_CTRL, MSDC_DMA_CTRL_BRUSTSZ,
MSDC_BRUST_64B);
sdr_set_field(MSDC_DMA_CTRL, MSDC_DMA_CTRL_MODE, 1);

sdr_write32(MSDC_DMA_SA, PHYSADDR((u32)dma->gpd_addr));
break;

default:
break;
}

N_MSG(DMA, "DMA_CTRL = 0x%x", sdr_read32(MSDC_DMA_CTRL));
N_MSG(DMA, "DMA_CFG  = 0x%x", sdr_read32(MSDC_DMA_CFG));
N_MSG(DMA, "DMA_SA   = 0x%x", sdr_read32(MSDC_DMA_SA));

}

The above function is used to configur MSDC DMA. Let's take the basic DMA as an example to understand how this function works.

The basic_dma function in RALINK MSDC driver looks like this:
msdc_dma_start




NEXT




<s> static void rtl930x_vlan_set_tagged(u32 vlan, struct rtl838x_vlan_info *info)
{
u32 v, w;
/* Access VLAN table (1) via register 0 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_0, 1);

v = info->tagged_ports << 3;
v |= ((u32)info->fid) >> 3;

w = ((u32)info->fid) << 29;
w |= info->hash_mc_fid ? BIT(27) : 0;
w |= info->hash_uc_fid ? BIT(28) : 0;
w |= info->profile_id << 24;

sw_w32(v, rtl_table_data(r, 0));
sw_w32(w, rtl_table_data(r, 1));

rtl_table_write(r, vlan);
rtl_table_release(r);
}

The above function is used to set the tagged ports for the port mapped vlan
id during port up process. The vlan_id and tagged_ports information passed
to this function. The function will calculate the 32-bit table offset
based on




NEXT




<s> static int rtk_hal_dump_vlan(void)
{
rtk_vlan_cfg_t vlan;
int i;

printk("vid    portmap\n");
for (i = 0; i < RTK_SW_VID_RANGE; i++) {
rtk_vlan_get(i, &vlan);
printk("%3d    ", i);
printk("%c",
RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
UTP_PORT0) ? '1' : '-');
printk("%c",
RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
UTP_PORT1) ? '1' : '-');
printk("%c",
RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
UTP_PORT2) ? '1' : '-');
printk("%c",
RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
UTP_PORT3) ? '1' : '-');
printk("%c",
RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
UTP_PORT4) ? '1' : '-');
printk("%c",
RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
EXT_PORT0) ? '1' : '-');
printk("%c",
RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
EXT_PORT1) ? '1' : '-');
printk("\n");
}

return 0;
}

The above function is used to dump the VLAN table. Please note that the
number '4' in function return should correspond to the number of ports on
your device. Modify the code according to the number of ports on your
device.</s>




NEXT




<s> static int __init rtcl_init_subsys(void)
{
return platform_driver_register(&rtcl_platform_driver);
}

The above function is used to install the kernel module and the driver can then be used to control the real-time clock.
This is the code that is used to set the frequency for the real-time clock:
#include</s>




NEXT




<s> rtk_api_ret_t rtk_vlan_tagMode_set(rtk_port_t port, rtk_vlan_tagMode_t tag_mode)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (tag_mode >= VLAN_TAG_MODE_END)
return RT_ERR_PORT_ID;

if ((retVal = rtl8367c_setAsicVlanEgressTagMode(rtk_switch_port_L2P_get(port), tag_mode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to program VLAN_TAG_MODE in ASIC.
This function is executed when user invoke the rtk_vlan_tagMode_set function. If input argument is incorrect, function will return RT_ERR_PORT_ID.





NEXT




<s> rtk_api_ret_t rtk_int_status_set(rtk_int_status_t *pStatusMask)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pStatusMask)
return RT_ERR_NULL_POINTER;

if(pStatusMask->value[0] & (0x0001 << INT_TYPE_RESERVED))
return RT_ERR_INPUT;

if(pStatusMask->value[0] >= (0x0001 << INT_TYPE_END))
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicInterruptStatus((rtk_uint32)pStatusMask->value[0]))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set interrupt status.
In rtl8367c the available interrupt mask as below

<center>

</center>
<pre>

  typedef enum interrupt_status {/* The interrupt status register */
  




NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_state_get(rtk_port_t port, rtk_filter_state_t* pState)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pState)
return RT_ERR_NULL_POINTER;

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if((ret = rtl8367c_getAsicAcl(rtk_switch_port_L2P_get(port), pState)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to get ACL state(igraph_acl_state) of the specified port.

Example:
/* Get ACL state(igraph_acl_state) */
rtk_filter_state_t pState;
rt




NEXT




<s> ret_t rtl8367c_setAsicRldpEnterLoopedPortmask(rtk_uint32 portmask)
{
return rtl8367c_setAsicReg(RTL8367C_REG_RLDP_LOOPED_INDICATOR, portmask);
}

The above function is used to inform the MAC layer that the corresponding port is used in the looped network topology. It is not used in the normal topology and may be used in Loopback test or RLDP test
.
To enable the loopback port




NEXT




<s> int br_foreach_port(const char *brname,
int (*iterator)(const char *br, const char *port, void *arg),
void *arg)
{
int i, count;
struct dirent **namelist;
char path[SYSFS_PATH_MAX];

snprintf(path, SYSFS_PATH_MAX, SYSFS_CLASS_NET "%s/brif", brname);
count = scandir(path, &namelist, 0, alphasort);

for (i = 0; i < count; i++) {
if (namelist[i]->d_name[0] == '.'
&& (namelist[i]->d_name[1] == '\0'
|| (namelist[i]->d_name[1] == '.'
&& namelist[i]->d_name[2] == '\0')))
continue;

if (iterator(brname, namelist[i]->d_name, arg))
break;
}
for (i = 0; i < count; i++)
free(namelist[i]);
free(namelist);

return count;
}

The above function is used to iterate over all ports (and port-groups) of a virtual bridge:

static int _br_foreach_port_iterator(
 const char *br, const char *port, void *args)
{
struct netdev




NEXT




<s> static int esw_cnt_read(struct seq_file *seq, void *v)
{
rtk_hal_dump_mib();
return 0;
}

The above function is used to dump MIB information to the seq_file (log file).

How to get MIB information?

First, to read one MIB entry, just print MIBID and corresponding information in a sequence.

1. Get




NEXT




<s> static unsigned char *rt2880_speed_str(struct fe_priv *priv)
{
switch (priv->phy->speed[0]) {
case SPEED_1000:
return "1000";
case SPEED_100:
return "100";
case SPEED_10:
return "10";
}

return "?";
}

The above function is used to determine the link speed (the speed which has been negotiated between the two Ethernet devices) when checking it with 'ethtool -S'.
Is it safe to assume that by default SPEED_100 would be the default




NEXT




<s> static inline void rtl839x_exec_tbl1_cmd(u32 cmd)
{
sw_w32(cmd, RTL839X_TBL_ACCESS_CTRL_1);
do { } while (sw_r32(RTL839X_TBL_ACCESS_CTRL_1) & BIT(16));
}

The above function is used to trigger TBL1 in RTL8390. However due to
the bug in 8390 RTL8390 and 8366A chipset, the function do not really
triggers TBL




NEXT




<s> static int ip17xx_get_val(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int retval = -EINVAL;
if (REG_SUPP(state->proc_mii))
retval = getPhy(state, state->proc_mii);

if (retval < 0) {
return retval;
} else {
val->value.i = retval;
return 0;
}
}

The above function is used to query specific MII registers, so the user is able to get the MII status info of every port, for example, `echo 117 | sudo tee
/sys/class/net/eth1/phy/ip




NEXT




<s> void rtl838x_set_port_reg(u64 set, int reg)
{
sw_w32((u32)set, reg);
}

The above function is used to set the value of a particular register by first writing the lower 32 bits of the set variable to the register and then writing the upper 32 bits of the set variable to the register. The following are some questions to be answered:





NEXT




<s> static void nlog_table_update(struct nmbm_instance *ni, bool main_table,
uint32_t start_ba, uint32_t end_ba)
{
if (start_ba == end_ba - 1)
nlog_debug(ni, "%s info table has been updated in block %u\n",
main_table ? "Main" : "Backup", start_ba);
else
nlog_debug(ni, "%s info table has been updated in block %u-%u\n",
main_table ? "Main" : "Backup", start_ba, end_ba - 1);
}

The above function is used to report on when the table's structure is
updated, but does not actually update the table. It was thought that that
would be a part of one or more nlog_put_record implementations. To my
knowledge,




NEXT




<s> static void ag71xx_setup_gmac_934x(struct device_node *np, void __iomem *base)
{
u32 val = __raw_readl(base + AR934X_GMAC_REG_ETH_CFG);

ag71xx_of_bit(np, "rgmii-gmac0", &val, AR934X_ETH_CFG_RGMII_GMAC0);
ag71xx_of_bit(np, "mii-gmac0", &val, AR934X_ETH_CFG_MII_GMAC0);
ag71xx_of_bit(np, "mii-gmac0-slave", &val, AR934X_ETH_CFG_MII_GMAC0_SLAVE);
ag71xx_of_bit(np, "gmii-gmac0", &val, AR934X_ETH_CFG_GMII_GMAC0);
ag71xx_of_bit(np, "switch-phy-swap", &val, AR934X_ETH_CFG_SW_PHY_SWAP);
ag71xx_of_bit(np, "switch-only-mode", &val,
AR934X_ETH_CFG_SW_ONLY_MODE);
ag71xx_of_set(np, "rxdv-delay", &val,
AR934X_ETH_CFG_RDV_DELAY_SHIFT, 0x3);
ag71xx_of_set(np, "rxd-delay", &val,
AR934X_ETH_CFG_RXD_DELAY_SHIFT, 0x3);
ag71xx_of_set(np, "txd-delay", &val,
AR934X_ETH_CFG_TXD_DELAY_SHIFT, 0x3);
ag71xx_of_set(np, "txen-delay", &val,
AR934X_ETH_CFG_TXE_DELAY_SHIFT, 0x3);

__raw_writel(val, base + AR934X_GMAC_REG_ETH_CFG);
}

The above function is used to configure GMAC in 934X platform which can
have up to two RGMII GMAC controllers. And the value of the
val in for while loop is stored in val.</s>




NEXT




<s> static int rtl8218d_set_eee(struct phy_device *phydev, struct ethtool_eee *e)
{
int addr = phydev->mdio.addr;
u64 poll_state;

pr_info("In %s, port %d, enabled %d\n", __func__, addr, e->eee_enabled);

poll_state = disable_polling(addr);

rtl8218d_eee_set(phydev, (bool) e->eee_enabled);

resume_polling(poll_state);

return 0;
}

The above function is used to set EEE(Energy Efficiency) feature of the realtek PCI ethernet device (Realtek RTL8218DC 10/100/1000 Ethernet Pcie Controller).






NEXT




<s> static void rtl838x_vlan_tables_read(u32 vlan, struct rtl838x_vlan_info *info)
{
u32 v;
/* Read VLAN table (0) via register 0 */
struct table_reg *r = rtl_table_get(RTL8380_TBL_0, 0);

rtl_table_read(r, vlan);
info->tagged_ports = sw_r32(rtl_table_data(r, 0));
v = sw_r32(rtl_table_data(r, 1));
pr_debug("VLAN_READ %d: %016llx %08x\n", vlan, info->tagged_ports, v);
rtl_table_release(r);

info->profile_id = v & 0x7;
info->hash_mc_fid = !!(v & 0x8);
info->hash_uc_fid = !!(v & 0x10);
info->fid = (v >> 5) & 0x3f;

/* Read UNTAG table (0) via table register 1 */
r = rtl_table_get(RTL8380_TBL_1, 0);
rtl_table_read(r, vlan);
info->untagged_ports = sw_r32(rtl_table_data(r, 0));
rtl_table_release(r);
}

The above function is used to read VLAN tables from registers.</s>




NEXT




<s> static u8 rb91x_nand_read_byte(struct nand_chip *chip)
{
u8 data = 0xff;

rb91x_nand_read(chip->priv, &data, 1);

return data;
}

The above function is used to get the content of RB91x NAND chip
if we want to create a image file which will written to NAND chip.
The problem is , the image size of Linux kernel is very large to put in
the buffer of




NEXT




<s> void rtl839x_set_scheduling_algorithm(struct rtl838x_switch_priv *priv, int port,
enum scheduler_type sched)
{
enum scheduler_type t = rtl839x_get_scheduling_algorithm(priv, port);
u32 v, oam_state, oam_port_state;
u32 count;
int i, egress_rate;

mutex_lock(&priv->reg_mutex);
/* Check whether we need to empty the egress queue of that port due to Errata E0014503 */
if (sched == WEIGHTED_FAIR_QUEUE && t == WEIGHTED_ROUND_ROBIN && port != priv->cpu_port) {
/* Read Operations, Adminstatrion and Management control register */
oam_state = sw_r32(RTL839X_OAM_CTRL);

/* Get current OAM state */
oam_port_state = sw_r32(RTL839X_OAM_PORT_ACT_CTRL(port));

/* Disable OAM to block traffice */
v = sw_r32(RTL839X_OAM_CTRL);
sw_w32_mask(0, 1, RTL839X_OAM_CTRL);
v = sw_r32(RTL839X_OAM_CTRL);

/* Set to trap action OAM forward (bits 1, 2) and OAM Mux Action Drop (bit 0) */
sw_w32(0x2, RTL839X_OAM_PORT_ACT_CTRL(port));

/* Set port egress rate to unlimited */
egress_rate = rtl839x_set_egress_rate(priv, port, 0xFFFFF);

/* Wait until the egress used page count of that port is 0 */
i = 0;
do {
usleep_range(100, 200);
rtl839x_read_out_q_table(port);
count = sw_r32(RTL839X_TBL_ACCESS_DATA_2(6));
count >>= 20;
i++;
} while (i < 3500 && count > 0);
}

/* Actually set the scheduling algorithm */
rtl839x_read_scheduling_table(port);
sw_w32_mask(BIT(19), sched ? BIT(19) : 0, RTL839X_TBL_ACCESS_DATA_2(8));
rtl839x_write_scheduling_table(port);

if (sched == WEIGHTED_FAIR_QUEUE && t == WEIGHTED_ROUND_ROBIN && port != priv->cpu_port) {
/* Restore OAM state to control register */
sw_w32(oam_state, RTL839X_OAM_CTRL);

/* Restore trap action state */
sw_w32(oam_port_state, RTL839X_OAM_PORT_ACT_CTRL(port));

/* Restore port egress rate */
rtl839x_set_egress_rate(priv, port, egress_rate);
}

mutex_unlock(&priv->reg_mutex);
}

The above function is used to set/get scheduling algorithm for ports on the switch. For setting the scheduling algorithm, we first disable OAM for a port, wait until the egress queue is empty for that port. Then we write the scheduling algorithm to each schedul




NEXT




<s> static int aw9523_hw_reset(struct aw9523 *awi)
{
int ret, max_retries = 2;

/* Sometimes the chip needs more than one reset cycle */
do {
ret = aw9523_drive_reset_gpio(awi);
if (ret == 0)
break;
max_retries--;
} while (max_retries);

return ret;
}

The above function is used to reset the power amplifier and is part of the
hardware init code. As is, it works fine on the development board. The problem is with the
production board. The production boards come with a different DSP chip, so the





NEXT




<s> int mtd_write_jffs2(const char *mtd, const char *filename, const char *dir)
{
int err = -1, fdeof = 0;

outfd = mtd_check_open(mtd);
if (outfd < 0)
return -1;

if (quiet < 2)
fprintf(stderr, "Appending %s to jffs2 partition %s\n", filename, mtd);

buf = malloc(erasesize);
if (!buf) {
fprintf(stderr, "Out of memory!\n");
goto done;
}

if (!*dir)
target_ino = 1;

/* parse the structure of the jffs2 first
* locate the directory that the file is going to be placed in */
for(;;) {
struct jffs2_unknown_node *node = (struct jffs2_unknown_node *) buf;

if (read(outfd, buf, erasesize) != erasesize) {
fdeof = 1;
break;
}
mtdofs += erasesize;

if (node->magic == 0x8519) {
fprintf(stderr, "Error: wrong endianness filesystem\n");
goto done;
}

/* assume  no magic == end of filesystem
* the filesystem will probably end with be32(0xdeadc0de) */
if (node->magic != 0x1985)
break;

mtd_parse_jffs2data(buf, dir);
}

if (fdeof) {
fprintf(stderr, "Error: No room for additional data\n");
goto done;
}

/* jump back one eraseblock */
mtdofs -= erasesize;
lseek(outfd, mtdofs, SEEK_SET);

ofs = 0;

if (!last_ino)
last_ino = 1;

if (!target_ino)
target_ino = add_dir(dir, 1);

add_file(filename, target_ino);
pad(erasesize);

/* add eof marker, pad to eraseblock size and write the data */
add_data(JFFS2_EOF, sizeof(JFFS2_EOF) - 1);
pad(erasesize);

err = 0;

if (trx_fixup) {
trx_fixup(outfd, mtd);
}

done:
close(outfd);
if (buf)
free(buf);

return err;
}

The above function is used to check whether a specified image filename is already exist in the specified mtd partition. If it exist, update the existing image data. else, create a new image.

In JFFs2, each image is consist of several blocks, blocks




NEXT




<s> int ctr_rfc3686_aes_set_key_skcipher (struct crypto_skcipher *tfm, const uint8_t *in_key, unsigned int key_len)
{
return ctr_rfc3686_aes_set_key(crypto_skcipher_tfm(tfm), in_key, key_len);
}

The above function is used to prepare the AES cipher for use, both when
initializing the cipher by passing into crypto_skcipher_set_tfm, and upon
subsequent calls to crypto_skcipher_encrypt and crypto_




NEXT




<s> rtk_api_ret_t rtk_trunk_trafficPause_get(rtk_trunk_group_t trk_gid, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Trunk Group Valid */
RTK_CHK_TRUNK_GROUP_VALID(trk_gid);

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicTrunkingFc((rtk_uint32)trk_gid, (rtk_uint32 *)pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read out the trunk traffic pause for member ports of a group.

The data structure for the above API is as follows,

| |
| --- | -----
|Type|Description |
|rtk_trunk_group




NEXT




<s> ar8xxx_mib_start(struct ar8xxx_priv *priv);
static void
ar8xxx_mib_stop(struct ar8xxx_priv *priv);

/* inspired by phy_poll_reset in drivers/net/phy/phy_device.c */
static int
ar8xxx_phy_poll_reset(struct mii_bus *bus)
{
unsigned int sleep_msecs = 20;
int ret, elapsed, i;

for (elapsed = sleep_msecs; elapsed <= 600;
elapsed += sleep_msecs) {
msleep(sleep_msecs);
for (i = 0; i < AR8XXX_NUM_PHYS; i++) {
ret = mdiobus_read(bus, i, MII_BMCR);
if (ret < 0)
return ret;
if (ret & BMCR_RESET)
break;
if (i == AR8XXX_NUM_PHYS - 1) {
usleep_range(1000, 2000);
return 0;
}
}
}
return -ETIMEDOUT;
}

The above function is used to determine when the PHY is in ready state with the PHY_IS_READY(). In the old 2.4.x kernel, phy_probe() has the responsibility to probe and configure the PHY devices. Starting from 




NEXT




<s> static void handle_f6(int *key, struct menu *current_item);
static void handle_f7(int *key, struct menu *current_item);
static void handle_f8(int *key, struct menu *current_item);
static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to determine the proper handler for the hotkey. When the user presses F1, it would pass along (F1, NULL) to the static handlers. It determines which handler is appropriate for that key code based on the string stored in the




NEXT




<s> static void ag71xx_ring_tx_init(struct ag71xx *ag)
{
struct ag71xx_ring *ring = &ag->tx_ring;
int ring_size = BIT(ring->order);
int ring_mask = BIT(ring->order) - 1;
int i;

for (i = 0; i < ring_size; i++) {
struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);

desc->next = (u32) (ring->descs_dma +
AG71XX_DESC_SIZE * ((i + 1) & ring_mask));

desc->ctrl = DESC_EMPTY;
ring->buf[i].skb = NULL;
}

/* flush descriptors */
wmb();

ring->curr = 0;
ring->dirty = 0;
netdev_reset_queue(ag->dev);
}

The above function is used to initialize the TX-Ring for the Atheros device driver . The for loop used in the function is to initialize each of the descriptor in a circular fashion (as in a list circular linked-list). For some reason this doesn't work




NEXT




<s> ret_t rtl8367c_setAsicLutIPMCGroup(rtk_uint32 index, ipaddr_t group_addr, rtk_uint32 vid, rtk_uint32 pmask, rtk_uint32 valid)
{
rtk_uint32  regAddr, regData, bitoffset;
ipaddr_t    ipData;
ret_t       retVal;

if(index > RTL8367C_LUT_IPMCGRP_TABLE_MAX)
return RT_ERR_INPUT;

if (vid > RTL8367C_VIDMAX)
return RT_ERR_VLAN_VID;

ipData = group_addr;

if( (ipData & 0xF0000000) != 0xE0000000)    /* not in 224.0.0.0 ~ 239.255.255.255 */
return RT_ERR_INPUT;

/* Group Address */
regAddr = RTL8367C_REG_IPMC_GROUP_ENTRY0_H + (index * 2);
regData = ((ipData & 0x0FFFFFFF) >> 16);

if( (retVal = rtl8367c_setAsicReg(regAddr, regData)) != RT_ERR_OK)
return retVal;

regAddr++;
regData = (ipData & 0x0000FFFF);

if( (retVal = rtl8367c_setAsicReg(regAddr, regData)) != RT_ERR_OK)
return retVal;

/* VID */
regAddr = RTL8367C_REG_IPMC_GROUP_VID_00 + index;
regData = vid;

if( (retVal = rtl8367c_setAsicReg(regAddr, regData)) != RT_ERR_OK)
return retVal;

/* portmask */
regAddr = RTL8367C_REG_IPMC_GROUP_PMSK_00 + index;
regData = pmask;

if( (retVal = rtl8367c_setAsicReg(regAddr, regData)) != RT_ERR_OK)
return retVal;

/* valid */
regAddr = RTL8367C_REG_IPMC_GROUP_VALID_15_0 + (index / 16);
bitoffset = index % 16;
if( (retVal = rtl8367c_setAsicRegBit(regAddr, bitoffset, valid)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set certain vlan and portmask for an already existing Ip MC Groups.

The below function is used to add new IP MC Group.

The following function is used to add Ip MC Groups. When MAC address of




NEXT




<s> ret_t rtl8367c_getAsicIGMPBypassStormCTRL(rtk_uint32 *pBypass)
{
ret_t   retVal;
rtk_uint32  regData;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_DISCARD_STORM_FILTER_OFFSET, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pBypass = regData;
return RT_ERR_OK;
}

The above function is used to obtain IGMP/MLD bypass storm control status in ASIC.

```
{
#include <stdio.h>
#include <stdlib.h>
#include "sdk_rtl83




NEXT




<s> rtk_api_ret_t rtk_svlan_unassign_action_get(rtk_svlan_unassign_action_t *pAction)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pAction)
return RT_ERR_NULL_POINTER;

retVal = rtl8367c_getAsicSvlanEgressUnassign(pAction);

return retVal;
}

The above function is used to get the SVLAN unassign action from ASIC. It is useful for getting value of SVLAN unassign action which is defined in svlan_action.h. The function rtl8367c_getAsicSvlanE




NEXT




<s> ret_t rtl8367c_getAsicMaxLength(rtk_uint32 port, rtk_uint32 type, rtk_uint32 *pCfgId)
{
ret_t retVal;

if(port < 8)
{
retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MAX_LENGTH_CFG, (type * 8) + port, pCfgId);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MAX_LENGTH_CFG_EXT, (type * 3) + port - 8, pCfgId);
if(retVal != RT_ERR_OK)
return retVal;
}
return RT_ERR_OK;
}

The above function is used to retreive ASIC maximum length of a specific port. A little search tells me that this function is used by 12 ports switch to set mac address to the ASIC for that port. The ASIC maintains maximum 64 entries




NEXT




<s> send_attr_ports(struct nl_msg *msg, struct switch_val *val)
{
struct nlattr *n;
int i;

/* TODO implement multipart? */
if (val->len == 0)
goto done;
n = nla_nest_start(msg, SWITCH_ATTR_OP_VALUE_PORTS);
if (!n)
goto nla_put_failure;
for (i = 0; i < val->len; i++) {
struct switch_port *port = &val->value.ports[i];
struct nlattr *np;

np = nla_nest_start(msg, SWITCH_ATTR_PORT);
if (!np)
goto nla_put_failure;

NLA_PUT_U32(msg, SWITCH_PORT_ID, port->id);
if (port->flags & SWLIB_PORT_FLAG_TAGGED)
NLA_PUT_FLAG(msg, SWITCH_PORT_FLAG_TAGGED);

nla_nest_end(msg, np);
}
nla_nest_end(msg, n);
done:
return 0;

nla_put_failure:
return -1;
}

The above function is used to push the port attribute list of switch_val object. The code snippet is taken from switcchd source code.

However, if we simply print the buffer of the switch_attr_msg msg, we’ll find that




NEXT




<s> uc_hostapd_iface_add_bss(uc_vm_t *vm, size_t nargs)
{
struct hostapd_iface *iface = uc_fn_thisval("hostapd.iface");
struct hostapd_bss_config *bss;
struct hostapd_config *conf;
struct hostapd_data *hapd;
uc_value_t *file = uc_fn_arg(0);
uc_value_t *index = uc_fn_arg(1);
unsigned int idx = 0;
uc_value_t *ret = NULL;

if (!iface || ucv_type(file) != UC_STRING)
goto out;

if (ucv_type(index) == UC_INTEGER)
idx = ucv_int64_get(index);

conf = interfaces->config_read_cb(ucv_string_get(file));
if (!conf || idx > conf->num_bss || !conf->bss[idx])
goto out;

bss = conf->bss[idx];
hapd = hostapd_alloc_bss_data(iface, iface->conf, bss);
if (!hapd)
goto out;

hapd->driver = iface->bss[0]->driver;
hapd->drv_priv = iface->bss[0]->drv_priv;
if (interfaces->ctrl_iface_init &&
interfaces->ctrl_iface_init(hapd) < 0)
goto free_hapd;

if (iface->state == HAPD_IFACE_ENABLED &&
hostapd_setup_bss(hapd, -1, true))
goto deinit_ctrl;

iface->bss = os_realloc_array(iface->bss, iface->num_bss + 1,
sizeof(*iface->bss));
iface->bss[iface->num_bss++] = hapd;

iface->conf->bss = os_realloc_array(iface->conf->bss,
iface->conf->num_bss + 1,
sizeof(*iface->conf->bss));
iface->conf->bss[iface->conf->num_bss] = bss;
conf->bss[idx] = NULL;
ret = hostapd_ucode_bss_get_uval(hapd);
hostapd_ucode_update_interfaces();
goto out;

deinit_ctrl:
if (interfaces->ctrl_iface_deinit)
interfaces->ctrl_iface_deinit(hapd);
free_hapd:
hostapd_free_hapd_data(hapd);
os_free(hapd);
out:
hostapd_config_free(conf);
return ret;
}

The above function is used to add a BSS to the HostAPD. As you see from above, as long as there is an integer `idx` or an index `[ idx ]`, the above function will not enter the `goto out` exit statement.






NEXT




<s> ret_t rtl8367c_getAsicUnknownIPv4MulticastBehavior(rtk_uint32 port, rtk_uint32 *pBehave)
{
if(port >  RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_UNKNOWN_IPV4_MULTICAST_REG(port), RTL8367C_UNKNOWN_IPV4_MULTICAST_MASK(port), pBehave);
}

The above function is used to read the unknown ipv4 multicast behavior (bit 20) of specified port.

The above function is used to set unknown ipv4 multicast behavior of specified port. If behavior is 0 (no behavior settings




NEXT




<s> void variable_add(const char *name, const char *value,
enum variable_flavor flavor)
{
struct variable *v;
char *new_value;
bool append = false;

v = variable_lookup(name);
if (v) {
/* For defined variables, += inherits the existing flavor */
if (flavor == VAR_APPEND) {
flavor = v->flavor;
append = true;
} else {
free(v->value);
}
} else {
/* For undefined variables, += assumes the recursive flavor */
if (flavor == VAR_APPEND)
flavor = VAR_RECURSIVE;

v = xmalloc(sizeof(*v));
v->name = xstrdup(name);
v->exp_count = 0;
list_add_tail(&v->node, &variable_list);
}

v->flavor = flavor;

if (flavor == VAR_SIMPLE)
new_value = expand_string(value);
else
new_value = xstrdup(value);

if (append) {
v->value = xrealloc(v->value,
strlen(v->value) + strlen(new_value) + 2);
strcat(v->value, " ");
strcat(v->value, new_value);
free(new_value);
} else {
v->value = new_value;
}
}

The above function is used to create a new variable or append to the end
of an existing variable value string. It takes as inputs the name
of the variable to manipulate, as well as the value of the variable.
It will also accept a flavor argument, which




NEXT




<s> static int rtl9300_execute_xfer(struct rtl9300_i2c *i2c, char read_write,
int size, union i2c_smbus_data * data, int len)
{
u32 v;

if (read_write == I2C_SMBUS_READ)
REG_MASK(i2c, BIT(RTL9300_I2C_CTRL1_RWOP), 0, RTL9300_I2C_CTRL1);
else
REG_MASK(i2c, 0, BIT(RTL9300_I2C_CTRL1_RWOP), RTL9300_I2C_CTRL1);

REG_MASK(i2c, 0, BIT(RTL9300_I2C_CTRL1_I2C_TRIG), RTL9300_I2C_CTRL1);
do {
v = readl(REG(i2c, RTL9300_I2C_CTRL1));
} while (v & BIT(RTL9300_I2C_CTRL1_I2C_TRIG));

if (v & BIT(RTL9300_I2C_CTRL1_I2C_FAIL))
return -EIO;

if (read_write == I2C_SMBUS_READ) {
if (size == I2C_SMBUS_BYTE || size == I2C_SMBUS_BYTE_DATA){
data->byte = readl(REG(i2c, RTL9300_I2C_DATA_WORD0));
} else if (size == I2C_SMBUS_WORD_DATA) {
data->word = readl(REG(i2c, RTL9300_I2C_DATA_WORD0));
} else if (len > 0) {
rtl9300_i2c_read(i2c, &data->block[0], len);
}
}

return 0;
}

The above function is used to call a read/write operation of the i2c bus. There is only one buffer for storing data.

As I said before, I tried to write the byte, not word, then the byte was read from the word buffer.




NEXT




<s> int rtl9300_sds_sym_err_reset(int sds_num, phy_interface_t phy_mode)
{
switch (phy_mode) {
case PHY_INTERFACE_MODE_XGMII:
break;

case PHY_INTERFACE_MODE_10GBASER:
/* Read twice to clear */
rtl930x_read_sds_phy(sds_num, 5, 1);
rtl930x_read_sds_phy(sds_num, 5, 1);
break;

case PHY_INTERFACE_MODE_1000BASEX:
rtl9300_sds_field_w(sds_num, 0x1, 24, 2, 0, 0);
rtl9300_sds_field_w(sds_num, 0x1, 3, 15, 8, 0);
rtl9300_sds_field_w(sds_num, 0x1, 2, 15, 0, 0);
break;

default:
pr_info("%s unsupported phy mode\n", __func__);
return -1;
}

return 0;
}

The above function is used to reset SDS error counters in order to avoid
counter resets (as described here
[https://dev-cisco-com.atlassian.net/wiki/spaces/DEVSEC/pages/31681




NEXT




<s> void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to set up an interactive buffer. Note that this buffer's contents will not be stored. This enables us to work with one buffer only, and to store whatever we've parsed as a program in `yyparse`, which uses yyin. This




NEXT




<s> static void get_symbol_props_str(struct gstr *r, struct symbol *sym,
enum prop_type tok, const char *prefix)
{
bool hit = false;
struct property *prop;

for_all_properties(sym, prop, tok) {
if (!hit) {
str_append(r, prefix);
hit = true;
} else
str_printf(r, " && ");
expr_gstr_print(prop->expr, r);
}
if (hit)
str_append(r, "\n");
}

The above function is used to find a property's values. Since it is
generating the property values as a comma-seperated list it's important
to note that it will only show values from the main type.

When you have 2




NEXT




<s> static void gpio_rb91x_key_set(struct gpio_chip *gc, unsigned offset, int value)
{
struct gpio_rb91x_key *drvdata = to_gpio_rb91x_key(gc);
struct gpio_desc *gpio = drvdata->gpio;

mutex_lock(&drvdata->mutex);

switch (offset) {
case GPIO_RB91X_KEY_NAND:
gpiod_set_raw_value_cansleep(gpio, value);
break;
case GPIO_RB91X_KEY_PDIS:
if (value) {
if (!drvdata->polling_disabled) {
mutex_lock(&drvdata->poll_mutex);
drvdata->polling_disabled = 1;
}
} else {
if (drvdata->polling_disabled) {
mutex_unlock(&drvdata->poll_mutex);
drvdata->polling_disabled = 0;
}
}
break;
default:
break;
}

mutex_unlock(&drvdata->mutex);
}

The above function is used to set the value of a GPIO pin under
gpio_chip object. If the value of GPIO_RB91X_KEY_PDIS is 1, the
function will set the polling value to 0 which means do not enable




NEXT




<s> mt7530_get_mirror_monitor_port(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

val->value.i = priv->mirror_dest_port;

return 0;
}

The above function is used to get the destination port for port mirroring.
But we can use port mirroring on any two ports in the switch. And the
value depends on what we are monitoring in the switch, so it needs to be
determined




NEXT




<s> static int fe_poll(struct napi_struct *napi, int budget)
{
struct fe_priv *priv = container_of(napi, struct fe_priv, rx_napi);
struct fe_hw_stats *hwstat = priv->hw_stats;
int tx_done, rx_done, tx_again;
u32 status, fe_status, status_reg, mask;
u32 tx_intr, rx_intr, status_intr;

status = fe_reg_r32(FE_REG_FE_INT_STATUS);
fe_status = status;
tx_intr = priv->soc->tx_int;
rx_intr = priv->soc->rx_int;
status_intr = priv->soc->status_int;
tx_done = 0;
rx_done = 0;
tx_again = 0;

if (fe_reg_table[FE_REG_FE_INT_STATUS2]) {
fe_status = fe_reg_r32(FE_REG_FE_INT_STATUS2);
status_reg = FE_REG_FE_INT_STATUS2;
} else {
status_reg = FE_REG_FE_INT_STATUS;
}

if (status & tx_intr)
tx_done = fe_poll_tx(priv, budget, tx_intr, &tx_again);

if (status & rx_intr)
rx_done = fe_poll_rx(napi, budget, priv, rx_intr);

if (unlikely(fe_status & status_intr)) {
if (hwstat && spin_trylock(&hwstat->stats_lock)) {
fe_stats_update(priv);
spin_unlock(&hwstat->stats_lock);
}
fe_reg_w32(status_intr, status_reg);
}

if (unlikely(netif_msg_intr(priv))) {
mask = fe_reg_r32(FE_REG_FE_INT_ENABLE);
netdev_info(priv->netdev,
"done tx %d, rx %d, intr 0x%08x/0x%x\n",
tx_done, rx_done, status, mask);
}

if (!tx_again && (rx_done < budget)) {
status = fe_reg_r32(FE_REG_FE_INT_STATUS);
if (status & (tx_intr | rx_intr)) {
/* let napi poll again */
rx_done = budget;
goto poll_again;
}

napi_complete_done(napi, rx_done);
fe_int_enable(tx_intr | rx_intr);
} else {
rx_done = budget;
}

poll_again:
return rx_done;
}

The above function is used to do the interrupt operations of packet transmission and reception. During the packet transmission, the Ethernet adapter driver will send the data to the MAC layer through the DMA (Direct Memory Access) and then the MAC will send the packets to the PHY layer




NEXT




<s> static ssize_t sc_tag_store_cpufreq_indexes(const u8 *pld, u16 pld_len, const char *buf, size_t count)
{
const struct sc_u32tvs *tvs;

if (soc_is_ar71xx() || soc_is_ar724x())
tvs = sc_cpufreq_indexes_ath79_7x;
else
tvs = sc_cpufreq_indexes_ath79_9x;

return sc_tag_store_u32tvs(pld, pld_len, buf, count, tvs, sc_tag_cpufreq_ath79_arraysize());
}

The above function is used to set clock frequencies as per application needs.

Now let’s take a look at the implementation of the function in the file
cfe_lite_config.h, in particular we want to focus on the “AR7XXX




NEXT




<s> static int rtl8366s_sw_get_port_link(struct switch_dev *dev,
int port,
struct switch_port_link *link)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data = 0;
u32 speed;

if (port >= RTL8366S_NUM_PORTS)
return -EINVAL;

rtl8366_smi_read_reg(smi, RTL8366S_PORT_LINK_STATUS_BASE + (port / 2),
&data);

if (port % 2)
data = data >> 8;

link->link = !!(data & RTL8366S_PORT_STATUS_LINK_MASK);
if (!link->link)
return 0;

link->duplex = !!(data & RTL8366S_PORT_STATUS_DUPLEX_MASK);
link->rx_flow = !!(data & RTL8366S_PORT_STATUS_RXPAUSE_MASK);
link->tx_flow = !!(data & RTL8366S_PORT_STATUS_TXPAUSE_MASK);
link->aneg = !!(data & RTL8366S_PORT_STATUS_AN_MASK);

speed = (data & RTL8366S_PORT_STATUS_SPEED_MASK);
switch (speed) {
case 0:
link->speed = SWITCH_PORT_SPEED_10;
break;
case 1:
link->speed = SWITCH_PORT_SPEED_100;
break;
case 2:
link->speed = SWITCH_PORT_SPEED_1000;
break;
default:
link->speed = SWITCH_PORT_SPEED_UNKNOWN;
break;
}

return 0;
}

The above function is used to get port link status, it reads LINK_STATUS_BASE, the bits of which control all the link status,
such as link, duplex, speed, rate, etc.
And if the port is in dual-channel port mode




NEXT




<s> static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to print the ATM showtime counters. There are certain requirements for the
application to call this function.

Usage:
    ifx_mei_atm_showtime_enter(PC, userdata);
    if




NEXT




<s> rtk_api_ret_t rtk_dot1x_guestVlan2Auth_set(rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsic1xGVOpdir(enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable/disable 1x guest VLAN for 802.1x.
There is a related switch configuration item in GUI which controls this
behavior.</s>




NEXT




<s> ret_t rtl8367c_getAsicEgressFlowControlQueueDropGap(rtk_uint32 *pGap)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_QUEUE_GAP, RTL8367C_FLOWCTRL_QUEUE_GAP_MASK, pGap);
}

The above function is used to retrieve the asic queue drop gap value. If the queue drop gap value has been
changed by a flowControl entry, a queue may not drop a new packet if the priority of this new packet is
greater than that of all the packets




NEXT




<s> static int sata_oxnas_resume(struct platform_device *op)
{
struct ata_host *host = dev_get_drvdata(&op->dev);
int ret;

ret = sata_oxnas_init_controller(host);
if (ret) {
dev_err(&op->dev, "Error initializing hardware\n");
return ret;
}
ata_host_resume(host);
return 0;
}

The above function is used to resume the ata host, it is called by the platform_device in a_device_resume function:

static int a_device_resume(struct platform_device *op)
{
struct ata_host *host =




NEXT




<s> static int rtl8367b_write_initvals(struct rtl8366_smi *smi,
const struct rtl8367b_initval *initvals,
int count)
{
int err;
int i;

for (i = 0; i < count; i++)
REG_WR(smi, initvals[i].reg, initvals[i].val);

return 0;
}

The above function is used to write the switch chip’s initialization
values, stored in `struct rtl8367b_initval` defined as follows:

struct rtl8367b_initval {
int reg;
int val




NEXT




<s> ret_t rtl8367c_getAsicRldpIndicatorSource(rtk_uint32 *pSrc)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_INDICATOR_SOURCE_OFFSET, pSrc);
}

The above function is used to retrieve the MAC and IP address that is used for RLDP source address. The function accepts uint32_t pointer address, which is later assigned with the value being queried.

ret_t rtl8367c




NEXT




<s> static int psb6970_hw_apply(struct switch_dev *dev)
{
struct psb6970_priv *priv = to_psb6970(dev);
int i, j;

mutex_lock(&priv->reg_mutex);

if (priv->vlan) {
/* into the vlan translation unit */
for (j = 0; j < PSB6970_MAX_VLANS; j++) {
u8 vp = priv->vlan_table[j];

if (vp) {
priv->write(priv->phy, PSB6970_VFxL(j),
PSB6970_VFxL_VV | priv->vlan_id[j]);
priv->write(priv->phy, PSB6970_VFxH(j),
((vp & priv->
vlan_tagged) <<
PSB6970_VFxH_TM_SHIFT) | vp);
} else	/* clear VLAN Valid flag for unused vlans */
priv->write(priv->phy, PSB6970_VFxL(j), 0);

}
}

/* update the port destination mask registers and tag settings */
for (i = 0; i < PSB6970_NUM_PORTS; i++) {
int dvid = 1, pbvm = 0x7f | PSB6970_PBVM_VSD, ec = 0;

if (priv->vlan) {
ec = PSB6970_EC_IFNTE;
dvid = priv->vlan_id[priv->pvid[i]];
pbvm |= PSB6970_PBVM_TBVE | PSB6970_PBVM_VMCE;

if ((i << 1) & priv->vlan_tagged)
pbvm |= PSB6970_PBVM_AOVTP | PSB6970_PBVM_VC;
}

priv->write(priv->phy, PSB6970_PBVM(i), pbvm);

if (!PSB6970_IS_CPU_PORT(i)) {
priv->write(priv->phy, PSB6970_EC(i), ec);
priv->write(priv->phy, PSB6970_DVID(i), dvid);
}
}

mutex_unlock(&priv->reg_mutex);
return 0;
}

The above function is used to configure different port vlan mapping. There are some things we must notice in above code as below:

1.    It must unlock mutex first before perform any switch register operations, and the other way around must be applied. The reason is




NEXT




<s> static void _smi_stop(void)
{

CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SDA, 0);
GPIO_DATA_SET(smi_SCK, 1);
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SDA, 1);
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SCK, 1);
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SCK, 0);
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SCK, 1);

/* add a click */
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SCK, 0);
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SCK, 1);


/* change GPIO pin to Input only */
GPIO_DIRECTION_SET(smi_SDA, GPIO_DIR_IN);
GPIO_DIRECTION_SET(smi_SCK, GPIO_DIR_IN);
}

The above function is used to put the SMU in read mode.

/* get data from SMU */
CLK_DURATION(DELAY);
GPIO_WRITE_DATA(smi_SCK, 0);


CLK_DUR




NEXT




<s> handle_send_a(struct ead_packet *pkt, int len, int *nstate)
{
struct ead_msg *msg = &pkt->msg;
struct ead_msg_number *number = EAD_DATA(msg, number);
len = ntohl(msg->len) - sizeof(struct ead_msg_number);

if (len > MAXPARAMLEN + 1)
return false;

A.len = len;
A.data = abuf;
memcpy(A.data, number->data, len);

msg = &pktbuf->msg;
number = EAD_DATA(msg, number);
msg->len = htonl(sizeof(struct ead_msg_number) + B->len);
memcpy(number->data, B->data, B->len);

*nstate = EAD_TYPE_SEND_AUTH;
return true;
}

The above function is used to write the initial "auth key" to the eAD packet buffer. To write in order to the correct packet, it is required to have the packet buffer state and the corresponding decrypted message for the packet. The latter is achieved by using a packet




NEXT




<s> static struct variable *variable_lookup(const char *name)
{
struct variable *v;

list_for_each_entry(v, &variable_list, node) {
if (!strcmp(name, v->name))
return v;
}

return NULL;
}

The above function is used to lookup a variable entry from a list of
variables. This isn't thread safe, and is unsuitable for use on the
list of global variables. The variable table is just a list with one
entry for each global variable.





NEXT




<s> struct property *menu_add_prop(enum prop_type type, struct expr *expr,
struct expr *dep)
{
struct property *prop;

prop = xmalloc(sizeof(*prop));
memset(prop, 0, sizeof(*prop));
prop->type = type;
prop->file = current_file;
prop->lineno = zconf_lineno();
prop->menu = current_entry;
prop->expr = expr;
prop->visible.expr = dep;

/* append property to the prop list of symbol */
if (current_entry->sym) {
struct property **propp;

for (propp = &current_entry->sym->prop;
*propp;
propp = &(*propp)->next)
;
*propp = prop;
}

return prop;
}

The above function is used to check if a label of a property
in the "visible.expr" has been found.

To use above code, for example,

1. add property to menu structure
2. add entry to menu structure
3. set




NEXT




<s> static int aw9523_direction_input(struct gpio_chip *chip, unsigned int offset)
{
struct aw9523 *awi = gpiochip_get_data(chip);
u8 regbit = offset % AW9523_PINS_PER_PORT;
int ret;

mutex_lock(&awi->i2c_lock);
ret = regmap_update_bits(awi->regmap, AW9523_REG_CONF_STATE(offset),
BIT(regbit), BIT(regbit));
mutex_unlock(&awi->i2c_lock);

return ret;
}

The above function is used to set the input pins direction of the chip. It is clear that this is a

privilege function. In fact, only the software can call this function to set the direction. It

is impossible for users to operate in this




NEXT




<s> ret_t rtl8367c_setAsicFlowControlSystemThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_SYS_OFF, RTL8367C_FLOWCTRL_SYS_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_SYS_ON, RTL8367C_FLOWCTRL_SYS_ON_MASK, onThreshold);

return retVal;
}

The above function is used to set the ASIC threshold values for link down/link up flow control system.

rtl8367c_setAsicFlowControlSystemThreshold(RTL8367C_PAGE_NUMBER, RTL83




NEXT




<s> ret_t rtl8367c_getAsicFlowControlPauseAllThreshold(rtk_uint32 *pThreshold)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_ALL_ON, RTL8367C_FLOWCTRL_ALL_ON_THRESHOLD_MASK, pThreshold);
}

The above function is used to read the "All On Pause Threshold" from ASIC

//
// Set all on Pause threshold
//
rt_err_t l8367cbp_setAsicFlowControlPauseAllThreshold(




NEXT




<s> static void rtl839x_fill_l2_row(u32 r[], struct rtl838x_l2_entry *e)
{
if (!e->valid) {
r[0] = r[1] = r[2] = 0;
return;
}

r[2] = e->is_ip_mc ? BIT(31) : 0;
r[2] |= e->is_ipv6_mc ? BIT(30) : 0;

if (!e->is_ip_mc  && !e->is_ipv6_mc) {
r[0] = ((u32)e->mac[0]) << 12;
r[0] |= ((u32)e->mac[1]) << 4;
r[0] |= ((u32)e->mac[2]) >> 4;
r[1] = ((u32)e->mac[2]) << 28;
r[1] |= ((u32)e->mac[3]) << 20;
r[1] |= ((u32)e->mac[4]) << 12;
r[1] |= ((u32)e->mac[5]) << 4;

if (!(e->mac[0] & 1)) { /* Not multicast */
r[2] |= e->is_static ? BIT(18) : 0;
r[0] |= ((u32)e->rvid) << 20;
r[2] |= e->port << 24;
r[2] |= e->block_da ? BIT(19) : 0;
r[2] |= e->block_sa ? BIT(20) : 0;
r[2] |= e->suspended ? BIT(17) : 0;
r[2] |= ((u32)e->age) << 21;
if (e->next_hop) {
r[2] |= BIT(16);
r[2] |= e->nh_vlan_target ? BIT(15) : 0;
r[2] |= (e->nh_route_id & 0x7ff) << 4;
} else {
r[2] |= e->vid << 4;
}
pr_debug("Write L2 NH: %08x %08x %08x\n", r[0], r[1], r[2]);
} else {  /* L2 Multicast */
r[0] |= ((u32)e->rvid) << 20;
r[2] |= ((u32)e->mc_portmask_index) << 6;
}
} else { /* IPv4 or IPv6 MC entry */
r[0] = ((u32)e->rvid) << 20;
r[1] = e->mc_gip;
r[2] |= ((u32)e->mc_portmask_index) << 6;
}
}

The above function is used to generate code from structure which is defined in linux/driver/net/wireless/ieee80211/rtl839x.c:

/* structure for each entry */
struct rtl838




NEXT




<s> int dialog_yesno(const char *title, const char *prompt, int height, int width)
{
int i, x, y, key = 0, button = 0;
WINDOW *dialog;

do_resize:
if (getmaxy(stdscr) < (height + YESNO_HEIGTH_MIN))
return -ERRDISPLAYTOOSMALL;
if (getmaxx(stdscr) < (width + YESNO_WIDTH_MIN))
return -ERRDISPLAYTOOSMALL;

/* center dialog box on screen */
x = (getmaxx(stdscr) - width) / 2;
y = (getmaxy(stdscr) - height) / 2;

draw_shadow(stdscr, y, x, height, width);

dialog = newwin(height, width, y, x);
keypad(dialog, TRUE);

draw_box(dialog, 0, 0, height, width,
dlg.dialog.atr, dlg.border.atr);
wattrset(dialog, dlg.border.atr);
mvwaddch(dialog, height - 3, 0, ACS_LTEE);
for (i = 0; i < width - 2; i++)
waddch(dialog, ACS_HLINE);
wattrset(dialog, dlg.dialog.atr);
waddch(dialog, ACS_RTEE);

print_title(dialog, title, width);

wattrset(dialog, dlg.dialog.atr);
print_autowrap(dialog, prompt, width - 2, 1, 3);

print_buttons(dialog, height, width, 0);

while (key != KEY_ESC) {
key = wgetch(dialog);
switch (key) {
case 'Y':
case 'y':
delwin(dialog);
return 0;
case 'N':
case 'n':
delwin(dialog);
return 1;

case TAB:
case KEY_LEFT:
case KEY_RIGHT:
button = ((key == KEY_LEFT ? --button : ++button) < 0) ? 1 : (button > 1 ? 0 : button);

print_buttons(dialog, height, width, button);
wrefresh(dialog);
break;
case ' ':
case '\n':
delwin(dialog);
return button;
case KEY_ESC:
key = on_key_esc(dialog);
break;
case KEY_RESIZE:
delwin(dialog);
on_key_resize();
goto do_resize;
}
}

delwin(dialog);
return key;		/* ESC pressed */
}

The above function is used to create a simple dialog box for the yes/no decisions.
It is used to prompt the user if it's ok to run an autoconf/automake run to
create/update/rewrite the Makefile and so forth.




NEXT




<s> void attr_clear(WINDOW * win, int height, int width, chtype attr)
{
int i, j;

wattrset(win, attr);
for (i = 0; i < height; i++) {
wmove(win, i, 0);
for (j = 0; j < width; j++)
waddch(win, ' ');
}
touchwin(win);
}

The above function is used to set the attribute in the buffer of windows to empty after deleting an existing windows, the main function of the program looks similar to below.

```
/*
```

#include “curses.h”

``




NEXT




<s> add_id(struct nl_msg *msg, void *arg)
{
struct attrlist_arg *l = arg;

NLA_PUT_U32(msg, SWITCH_ATTR_ID, l->id);

return 0;
nla_put_failure:
return -1;
}

The above function is used to put the attribute id (SWITCH_ATTR_ID) in a message (struct nl_msg). It was using the function NLA_PUT_U32() to directly put the id into the struct nl_msg. If the




NEXT




<s> static int elf64_determine_size(struct mtd_info *mtd, struct elf_header *hdr,
size_t *size)
{
struct elf_header_64 *hdr64 = &(hdr->elf64);
int err;
size_t section_end, ph_table_end, ph_entry;
struct elf_program_header_64 ph;

*size = 0;

if (hdr64->shoff > 0) {
*size = hdr64->shoff + hdr64->shentsize * hdr64->shnum;
return 0;
}

ph_entry = hdr64->phoff;
ph_table_end = hdr64->phoff + hdr64->phentsize * hdr64->phnum;

while (ph_entry < ph_table_end) {
err = mtdsplit_elf_read_mtd(mtd, ph_entry, (uint8_t *)(&ph),
sizeof(ph));
if (err)
return err;

section_end = ph.offset + ph.filesize;
if (section_end > *size)
*size = section_end;

ph_entry += hdr64->phentsize;
}

return 0;
}

The above function is used to read the .data section and then mtdpart is able to get the size correctly:

struct mtd_device *cfi_devices = NULL;
cfi_devices = mtd_get_common_flash_device(




NEXT




<s> rtk_api_ret_t rtk_trunk_distributionAlgorithm_get(rtk_trunk_group_t trk_gid, rtk_uint32 *pAlgo_bitmask)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (trk_gid != RTK_WHOLE_SYSTEM)
return RT_ERR_LA_TRUNK_ID;

if(NULL == pAlgo_bitmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicTrunkingHashSelect((rtk_uint32 *)pAlgo_bitmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get hash select algorithm configuration by the given trunk group ID and has the following restrictions:

• The input argument pAlgo_bitmask is a pointer to an integer variable that stores the trunk distribution algorithm bit mask. Each bit corresponds to a




NEXT




<s> int rtl9300_serdes_setup(int sds_num, phy_interface_t phy_mode)
{
int sds_mode;
int calib_tries = 0;

switch (phy_mode) {
case PHY_INTERFACE_MODE_HSGMII:
sds_mode = 0x12;
break;
case PHY_INTERFACE_MODE_1000BASEX:
sds_mode = 0x04;
break;
case PHY_INTERFACE_MODE_XGMII:
sds_mode = 0x10;
break;
case PHY_INTERFACE_MODE_10GBASER:
sds_mode = 0x1a;
break;
case PHY_INTERFACE_MODE_USXGMII:
sds_mode = 0x0d;
break;
default:
pr_err("%s: unknown serdes mode: %s\n", __func__, phy_modes(phy_mode));
return -EINVAL;
}

/* Maybe use dal_longan_sds_init */

/* dal_longan_construct_serdesConfig_init */ /* Serdes Construct */
rtl9300_phy_enable_10g_1g(sds_num);

/* Set Serdes Mode */
rtl9300_sds_set(sds_num, 0x1a); /* 0x1b: RTK_MII_10GR1000BX_AUTO */

/* Do RX calibration */
do {
rtl9300_do_rx_calibration(sds_num, phy_mode);
calib_tries++;
mdelay(50);
} while (rtl9300_sds_check_calibration(sds_num, phy_mode) && calib_tries < 3);


return 0;
}

The above function is used to set the sds mode, for example 10G serdes mode 0x1a 1G serdes mode 0x04, but the actual sds_setup() of the hardware is shown below,

/*




NEXT




<s> void rtl930x_print_matrix(void)
{
struct table_reg *r = rtl_table_get(RTL9300_TBL_0, 6);

for (int i = 0; i < 29; i++) {
rtl_table_read(r, i);
pr_debug("> %08x\n", sw_r32(rtl_table_data(r, 0)));
}
rtl_table_release(r);
}

The above function is used to print out the debug messages
by the RTL930x driver during run time.
This allows a user to examine its internals to track
down bugs that may have to do with misconfigured
resources and or data structures.




NEXT




<s> int BN_is_prime(const BIGNUM *a, int checks, void (*callback)(int,int,void *),
BN_CTX *ctx_passed, void *cb_arg)
{
return BN_is_prime_fasttest(a, checks, callback, ctx_passed, cb_arg, 0);
}

The above function is used to check if a number is prime or not.

The following function checks the number with different algorithms.

void BN_is_prime_fasttest(const BIGNUM *a,
int checks,
void (*callback)(




NEXT




<s> ret_t rtl8367c_setAsicI2CTxAckCmd(void)
{
rtk_uint32 regData;
ret_t retVal;

/* Bits [4-1] = 0b0100, tx ACK Command; Bit [0] = 1, Trigger the Command */
if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
return retVal;
regData &= 0xFFE0;
regData |= 0x0009;
if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
return retVal;

/* wait for command finished */
do{
if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
return retVal;
}while( regData != 0x0);

return RT_ERR_OK ;

}

The above function is used to send I2C TX ACK command to ASIC
and then let it execute all commands in the register.

The M_I2C_CTL_STA register of ASIC is used (see Figure 3).






NEXT




<s> rtk_api_ret_t rtk_port_macForceLinkExt_get(rtk_port_t port, rtk_mode_ext_t *pMode, rtk_port_mac_ability_t *pPortability)
{
rtk_api_ret_t retVal;
rtl8367c_port_ability_t ability;
rtk_uint32 ext_id;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_EXT(port);

if(NULL == pMode)
return RT_ERR_NULL_POINTER;

if(NULL == pPortability)
return RT_ERR_NULL_POINTER;

ext_id = port - 15;

if ((retVal = rtl8367c_getAsicPortExtMode(ext_id, (rtk_uint32 *)pMode)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicPortForceLinkExt(ext_id, &ability)) != RT_ERR_OK)
return retVal;

pPortability->forcemode = ability.forcemode;
pPortability->speed     = (*pMode == MODE_EXT_HSGMII) ? PORT_SPEED_2500M : ability.speed;
pPortability->duplex    = ability.duplex;
pPortability->link      = ability.link;
pPortability->nway      = ability.nway;
pPortability->txpause   = ability.txpause;
pPortability->rxpause   = ability.rxpause;

return RT_ERR_OK;

}

The above function is used to get MAC Forcelink extension for a given port and the portability of this forcelink.  It first check if port is valid using rtk_check_port_id, and then it will get ability data from asic registers.




NEXT




<s> void print_header(void)
{
int i;

printf("vectors in header\n");
for (i = 0; i < NUMBER_VECTORS; i++) {
printf("%d:0x%08x\n", i, img_header.start_vector[i]);
}
printf("length:%8x\nimg_CRC:0x%08x\nHeader CRC:0x%08x\n",
img_header.length, img_header.img_CRC, img_header.CRC);
}

The above function is used to print the values in the header. However as we can see that the printf statement is printing out all of the hex values in that particular segment. I need to print out only the 3rd number in that segment. How do I go about that




NEXT




<s> static int rtl8367_sw_get_vlan_info(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
int i;
u32 len = 0;
struct rtl8367_vlan_info vlan;
static char vlan_buf[256];
int err;

if (!rtl8367c_is_vlan_valid(val->port_vlan))
return -EINVAL;

memset(vlan_buf, '\0', sizeof(vlan_buf));

err = rtl8367c_get_vlan(val->port_vlan, &vlan);
if (err)
return err;

len += snprintf(vlan_buf + len, sizeof(vlan_buf) - len,
"VLAN %d: Ports: '", vlan.vid);

for (i = 0; i <RTL8367C_NUM_PORTS; i++) {
if (!(vlan.member & (1 << i)))
continue;

len += snprintf(vlan_buf + len, sizeof(vlan_buf) - len, "%d%s", i,
(vlan.untag & (1 << i)) ? "" : "t");
}

len += snprintf(vlan_buf + len, sizeof(vlan_buf) - len,
"', members=%04x, untag=%04x, fid=%u",
vlan.member, vlan.untag, vlan.fid);

val->value.s = vlan_buf;
val->len = len;

return 0;
}

The above function is used to retrieve some value for the specified port. The value is stored in the vlan_buf variable.
static int rtl8367_sw_set_vlan_info(struct switch_dev *dev,
const struct switch




NEXT




<s> void rtl9300_do_rx_calibration_2(int sds)
{
rtl930x_sds_rx_rst(sds, PHY_INTERFACE_MODE_10GBASER);
rtl9300_do_rx_calibration_2_1(sds);
rtl9300_do_rx_calibration_2_2(sds);
rtl9300_do_rx_calibration_2_3(sds);
}

The above function is used to do TX and RX calibration of the phy chips to ensure that both transmit and receive gain settings properly match between both halves of a dual phy chip.

When using the phy chips in dual phy mode the chip is




NEXT




<s> static void *hash_buf(FILE *f, int *len)
{
static char buf[1024];

*len = fread(buf, 1, sizeof(buf), f);

return *len > 0 ? buf : NULL;
}

The above function is used to read file into a hash table in C. However the problem with this method is that if the buffer is small enough when read as a whole file can result in loss of data, and also it is not efficient because file read and buffer creation is repeated




NEXT




<s> ret_t rtl8367c_getAsicIGMPVLANLeaky(rtk_uint32 *pLeaky)
{
ret_t   retVal;
rtk_uint32  regData;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_VLAN_LEAKY_OFFSET, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pLeaky = regData;
return RT_ERR_OK;
}

The above function is used to get the leaky VLAN for IGMP snooping. By default this will be set to 1 when igmp is ON (by this code). So all the VLANs present on any port/vlan-vifs will




NEXT




<s> static int osafeloader_info(int argc, char **argv) {
FILE *safeloader;
struct safeloader_header hdr;
MD5_CTX ctx;
size_t bytes, imagesize;
uint8_t buf[1024];
uint8_t md5[16];
char name[32];
int base, size, i;
int err = 0;

if (argc < 3) {
fprintf(stderr, "No SafeLoader file passed\n");
err = -EINVAL;
goto out;
}
safeloader_path = argv[2];

safeloader = fopen(safeloader_path, "r");
if (!safeloader) {
fprintf(stderr, "Couldn't open %s\n", safeloader_path);
err = -EACCES;
goto out;
}

bytes = fread(&hdr, 1, sizeof(hdr), safeloader);
if (bytes != sizeof(hdr)) {
fprintf(stderr, "Couldn't read %s header\n", safeloader_path);
err =  -EIO;
goto err_close;
}
imagesize = be32_to_cpu(hdr.imagesize);

MD5_Init(&ctx);
MD5_Update(&ctx, md5_salt, sizeof(md5_salt));
while ((bytes = fread(buf, 1, osafeloader_min(sizeof(buf), imagesize), safeloader)) > 0) {
MD5_Update(&ctx, buf, bytes);
imagesize -= bytes;
}
MD5_Final(md5, &ctx);

if (memcmp(md5, hdr.md5, 16)) {
fprintf(stderr, "Broken SafeLoader file with invalid MD5\n");
err =  -EIO;
goto err_close;
}

printf("%10s: %d\n", "Image size", be32_to_cpu(hdr.imagesize));
printf("%10s: ", "MD5");
for (i = 0; i < 16; i++)
printf("%02x", md5[i]);
printf("\n");

/* Skip header & vendor info */
fseek(safeloader, 0x1014, SEEK_SET);

while (fscanf(safeloader, "fwup-ptn %s base 0x%x size 0x%x\t\r\n", name, &base, &size) == 3) {
printf("%10s: %s (0x%x - 0x%x)\n", "Partition", name, base, base + size);
}

err_close:
fclose(safeloader);
out:
return err;
}

The above function is used to display the output of a file from the bootloader that is passed by the user as a parameter on the command line. In this case, the filename is safeloader. The code is very simple and readable; however, the code can




NEXT




<s> static int clk_mt7988_topckgen_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;
int nr = ARRAY_SIZE(top_fixed_clks) + ARRAY_SIZE(top_divs) +
ARRAY_SIZE(top_muxes) + ARRAY_SIZE(top_aud_divs);

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(nr);
if (!clk_data)
return -ENOMEM;

mtk_clk_register_fixed_clks(top_fixed_clks, ARRAY_SIZE(top_fixed_clks),
clk_data);

mtk_clk_register_factors(top_divs, ARRAY_SIZE(top_divs), clk_data);

mtk_clk_register_muxes(top_muxes, ARRAY_SIZE(top_muxes), node,
&mt7988_clk_lock, clk_data);

mtk_clk_register_composites(top_aud_divs, ARRAY_SIZE(top_aud_divs),
base, &mt7988_clk_lock, clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);

if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_topckgen_data;
}
return r;

free_topckgen_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to register all top-level clock related node. The usage is almost the same as the mtk_clk_register_fixed_clks() function except
the following
clk_data = mtk_alloc_clk_data(nr);




NEXT




<s> static ssize_t swconfig_trig_mode_show(struct device *dev,
struct device_attribute *attr, char *buf)
{
struct led_classdev *led_cdev = dev_get_drvdata(dev);
struct swconfig_trig_data *trig_data = led_cdev->trigger_data;
u8 mode;

read_lock(&trig_data->lock);
mode = trig_data->mode;
read_unlock(&trig_data->lock);

if (mode == 0) {
strcpy(buf, "none\n");
} else {
if (mode & SWCONFIG_LED_MODE_LINK)
strcat(buf, "link ");
if (mode & SWCONFIG_LED_MODE_TX)
strcat(buf, "tx ");
if (mode & SWCONFIG_LED_MODE_RX)
strcat(buf, "rx ");
strcat(buf, "\n");
}

return strlen(buf)+1;
}

The above function is used to read the status of the RTL8139’s LED.The function prototype is as follows:static ssize_t swconfig_trig_mode_show (struct device *dev, struct device_attribute *attr,char




NEXT




<s> static int bcm6368_enetsw_stop(struct net_device *ndev)
{
struct bcm6368_enetsw *priv = netdev_priv(ndev);
struct platform_device *pdev = priv->pdev;
struct device *dev = &pdev->dev;
int i;

netif_stop_queue(ndev);
napi_disable(&priv->napi);
del_timer_sync(&priv->rx_timeout);

/* mask all interrupts */
dmac_writel(priv, 0, DMAC_IRMASK_REG, priv->rx_chan);
dmac_writel(priv, 0, DMAC_IRMASK_REG, priv->tx_chan);

/* disable dma & mac */
bcm6368_enetsw_disable_dma(priv, priv->tx_chan);
bcm6368_enetsw_disable_dma(priv, priv->rx_chan);

/* force reclaim of all tx buffers */
bcm6368_enetsw_tx_reclaim(ndev, 1, 0);

/* free the rx buffer ring */
for (i = 0; i < priv->rx_ring_size; i++) {
struct bcm6368_enetsw_desc *desc;

if (!priv->rx_buf[i])
continue;

desc = &priv->rx_desc_cpu[i];
dma_unmap_single_attrs(dev, desc->address, priv->rx_buf_size,
DMA_FROM_DEVICE,
DMA_ATTR_SKIP_CPU_SYNC);
skb_free_frag(priv->rx_buf[i]);
}

/* free remaining allocated memory */
kfree(priv->rx_buf);
kfree(priv->tx_skb);
dma_free_coherent(dev, priv->rx_desc_alloc_size,
priv->rx_desc_cpu, priv->rx_desc_dma);
dma_free_coherent(dev, priv->tx_desc_alloc_size,
priv->tx_desc_cpu, priv->tx_desc_dma);
if (priv->irq_tx != -1)
free_irq(priv->irq_tx, ndev);
free_irq(priv->irq_rx, ndev);

netdev_reset_queue(ndev);

return 0;
}

The above function is used to stop the net dev and enable interrupt mask.
Please refer to the source code for more details.

#define DMAC_CH_EN_REG		(0xe0 + 0)
#define DMAC_CH_




NEXT




<s> adm6996_get_pvid(struct switch_dev *dev, int port, int *vlan)
{
struct adm6996_priv *priv = to_adm(dev);

pr_devel("get_pvid port %d\n", port);
*vlan = priv->pvid[port];

return 0;
}

The above function is used to get the native PVID in a given port on the switch. This code will be called from the switch_config.c file if the PVID is set by the user to any other value than 1005. Since the default P




NEXT




<s> static inline struct wpa_global *get_wpa_global_from_object(struct ubus_object *obj)
{
return container_of(obj, struct wpa_global, ubus_global);
}

The above function is used to get the WPA global info from the Ubus
global object. In this example, the wpa_global object's field ubus_global
is cast to a pointer to the struct wpa_global. We will now look at




NEXT




<s> hostapd_bss_ban_client(struct hostapd_data *hapd, u8 *addr, int time)
{
struct ubus_banned_client *ban;

if (time < 0)
time = 0;

ban = avl_find_element(&hapd->ubus.banned, addr, ban, avl);
if (!ban) {
if (!time)
return;

ban = os_zalloc(sizeof(*ban));
memcpy(ban->addr, addr, sizeof(ban->addr));
ban->avl.key = ban->addr;
avl_insert(&hapd->ubus.banned, &ban->avl);
} else {
eloop_cancel_timeout(hostapd_bss_del_ban, ban, hapd);
if (!time) {
hostapd_bss_del_ban(ban, hapd);
return;
}
}

eloop_register_timeout(0, time * 1000, hostapd_bss_del_ban, ban, hapd);
}

The above function is used to add a client to the hotspot blacklist. The variable avl.key points to the mac address of the device or client.

The avl.data variable contains other information about the client that is used by the function when removing the




NEXT




<s> int first_alpha(const char *string, const char *exempt)
{
int i, in_paren = 0, c;

for (i = 0; i < strlen(string); i++) {
c = tolower(string[i]);

if (strchr("<[(", c))
++in_paren;
if (strchr(">])", c) && in_paren > 0)
--in_paren;

if ((!in_paren) && isalpha(c) && strchr(exempt, c) == 0)
return i;
}

return 0;
}

The above function is used to find the first letter of a non-exempt string. What a string can be is described by the `exempt` variable. The exempt string is passed as a parameter so that an application can pass in something else.

What I




NEXT




<s> static char *function_expand(const char *name, int argc, char *argv[])
{
const struct function *f;
int i;

for (i = 0; i < ARRAY_SIZE(function_table); i++) {
f = &function_table[i];
if (strcmp(f->name, name))
continue;

if (argc < f->min_args)
pperror("too few function arguments passed to '%s'",
name);

if (argc > f->max_args)
pperror("too many function arguments passed to '%s'",
name);

return f->func(argc, argv);
}

return NULL;
}

The above function is used to dynamically lookup and call functions
from the `function_table`, in the above example `pperror` is called by
the `function_expand` function.

The `function_table` stores the name of the function `




NEXT




<s> void fe_csum_config(struct fe_priv *priv)
{
struct net_device *dev = priv_netdev(priv);

fe_txcsum_config((dev->features & NETIF_F_IP_CSUM));
fe_rxcsum_config((dev->features & NETIF_F_RXCSUM));
}

The above function is used to set-up the device so that it either handles
CSUM in hardware or in software or not at all. This should be called when
the device state changes or is modified by user. At each time, the
function should be called so




NEXT




<s> static int AT91F_MemoryDisplay(unsigned int addr, unsigned int length)
{
unsigned long	i, nbytes, linebytes;
char	*cp;
//	unsigned int 	*uip;
//	unsigned short 	*usp;
unsigned char 	*ucp;
char linebuf[DISP_LINE_LEN];

//	nbytes = length * size;
nbytes = length;
do
{
//   		uip = (unsigned int *)linebuf;
//   		usp = (unsigned short *)linebuf;
ucp = (unsigned char *)linebuf;

printf("%08x:", addr);
linebytes = (nbytes > DISP_LINE_LEN)?DISP_LINE_LEN:nbytes;
if((addr & 0xF0000000) == 0x20000000) {
for(i = 0; i < linebytes; i ++) {
linebuf[i] =  *(char *)(addr+i);
}
} else {
read_dataflash(addr, linebytes, linebuf);
}
for (i=0; i<linebytes; i++)
{
/*			if (size == 4)
printf(" %08x", *uip++);
else if (size == 2)
printf(" %04x", *usp++);
else
*/
printf(" %02x", *ucp++);
//			addr += size;
addr++;
}
printf("    ");
cp = linebuf;
for (i=0; i<linebytes; i++) {
if ((*cp < 0x20) || (*cp > 0x7e))
printf(".");
else
printf("%c", *cp);
cp++;
}
printf("\n");
nbytes -= linebytes;
} while (nbytes > 0);
return 0;
}

The above function is used to debug the UBOOT environment by displaying memory contents. This function is not part of the code included in this project. If you wish to include it, please find the code at http://www.atmel.com/dyn/resources/




NEXT




<s> static int rtl8367_sw_reset_port_mibs(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
int port;

port = val->port_vlan;
if (port >= RTL8367_NUM_PORTS)
return -EINVAL;

return rtl8366_smi_rmwr(smi, RTL8367_MIB_CTRL_REG(port / 8), 0,
RTL8367_MIB_CTRL_PORT_RESET_MASK(port % 8));
}

The above function is used to reset port mib counters in
rtl8366_set_port_mibs().

Please note the following in the above discussion:
1. When switch_write() is called for resetting PFC m




NEXT




<s> static int rb4xx_cpld_gpio_set_8(struct rb4xx_cpld *cpld, u8 value)
{
/* GPIO 8 uses dedicated high/low commands */
u8 cmd = CPLD_CMD_GPIO8_HIGH | !!(value);
return rb4xx_cpld_cmd(cpld, &cmd, 1);
}

The above function is used to set the GPIO8 on/off condition
You’ll notice that I’m not using the new gpio_direction_input and gpio_direction_output macros.
The reason is that I had problems compiling with them (




NEXT




<s> static int rtl8366rb_sw_get_mirror_pause_frames_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366RB_PMCR, &data);
if (data & RTL8366RB_PMCR_MIRROR_SPC)
val->value.i = 1;
else
val->value.i = 0;

return 0;
}

The above function is used to get value of the mirror_pause_frames_enable register from silicon. I also added RTL8366RB_PMCR_MIRROR_SPC mask to the definition of the mirror_pause_frames_enable




NEXT




<s> static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to report errors. If it's called, it calls the
function yerror().

YYTEXT_PTR is the currently active input, used by this file and by output
functions. In contrast to the static declaration of yytext, the




NEXT




<s> static int proc_write_dbg(struct file *, const char *, unsigned long, void *);
#endif

/*
*  Proc Help Functions
*/
static INLINE int stricmp(const char *, const char *);
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static INLINE int strincmp(const char *, const char *, int);
#endif
static INLINE int ifx_ptm_version(char *);

/*
*  Init & clean-up functions
*/
static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to check whether the showtime request for an
port-cell needs to perform the corresponding showtime checking.
At the moment, there is no implementation of MEI based showtime
checking.

Explained in detail below:





NEXT




<s> static void rb91x_nand_release(struct rb91x_nand_drvdata *drvdata)
{
mtd_device_unregister(nand_to_mtd(&drvdata->chip));
nand_cleanup(&drvdata->chip);
}

The above function is used to release the non-volatile memory. It registers the mtd to be unregistered and cleans up anything that was used.

int rb91x_nand_init(struct device *dev)

static int rb




NEXT




<s> rtk_api_ret_t rtk_l2_ipMcastAddrLookup_set(rtk_l2_ipmc_lookup_type_t type)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(type == LOOKUP_MAC)
{
if((retVal = rtl8367c_setAsicLutIpMulticastLookup(DISABLED)) != RT_ERR_OK)
return retVal;
}
else if(type == LOOKUP_IP)
{
if((retVal = rtl8367c_setAsicLutIpMulticastLookup(ENABLED)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicLutIpMulticastVidLookup(DISABLED))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicLutIpLookupMethod(1))!=RT_ERR_OK)
return retVal;
}
else if(type == LOOKUP_IP_VID)
{
if((retVal = rtl8367c_setAsicLutIpMulticastLookup(ENABLED)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicLutIpMulticastVidLookup(ENABLED))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicLutIpLookupMethod(1))!=RT_ERR_OK)
return retVal;
}
else
return RT_ERR_INPUT;

return RT_ERR_OK;
}

The above function is used to configure lookup type for L2 IpMC lookup.

The lookup type has 3 choices:

- look up based on MAC address.
- look up based on IP VFID table for VLAN mode, and E1




NEXT




<s> static void __exit ifx_ptm_test_exit(void)
{
proc_file_delete();
}

The above function is used to remove the character device at kernel exit. But in this case we do not get a system interrupt because the user process exits, hence the module is never unloaded and the kernel is hanged.

Now, let’s look at the




NEXT




<s> static int __init mt7986b_pinctrl_init(void)
{
return platform_driver_register(&mt7986b_pinctrl_driver);
}

The above function is used to register MT7986B pinctrl driver.

int __init pm8xxx_pinctrl_init(void)
{
return 0;
}

This function is used to initialized pinctrl operations




NEXT




<s> static void rtl931x_vlan_profile_setup(int profile)
{
u32 p[7];

pr_info("In %s\n", __func__);

if (profile > 15)
return;

p[0] = sw_r32(RTL931X_VLAN_PROFILE_SET(profile));

/* Enable routing of Ipv4/6 Unicast and IPv4/6 Multicast traffic */
/* p[0] |= BIT(17) | BIT(16) | BIT(13) | BIT(12); */
p[0] |= 0x3 << 11; /* COPY2CPU */

p[1] = 0x1FFFFFF; /* L2 unknwon MC flooding portmask all ports, including the CPU-port */
p[2] = 0xFFFFFFFF;
p[3] = 0x1FFFFFF; /* IPv4 unknwon MC flooding portmask */
p[4] = 0xFFFFFFFF;
p[5] = 0x1FFFFFF; /* IPv6 unknwon MC flooding portmask */
p[6] = 0xFFFFFFFF;

for (int i = 0; i < 7; i++)
sw_w32(p[i], RTL931X_VLAN_PROFILE_SET(profile) + i * 4);
pr_info("Leaving %s\n", __func__);
}

The above function is used to set the CPU COPY2CPU bit. We see that p[0] or sw_r32(RTL931X_VLAN_PROFILE_SET(profile)) contains this line.

p[0] |=




NEXT




<s> rtk_api_ret_t rtk_switch_isHsgPort(rtk_port_t logicalPort)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(logicalPort >= RTK_SWITCH_PORT_NUM)
return RT_ERR_FAILED;

if(logicalPort == halCtrl->hsg_logical_port)
return RT_ERR_OK;
else
return RT_ERR_FAILED;
}

The above function is used to determine whether a port is a HSG port.

To configure HSG ports, the following API functions are used.
Note that you should use these API functions to change ports to/from HSG port, but NOT HSG1/




NEXT




<s> static int b53_phy_probe(struct phy_device *phydev)
{
struct b53_device *dev;
int ret;

/* allow the generic phy driver to take over */
if (phydev->mdio.addr != B53_PSEUDO_PHY && phydev->mdio.addr != 0)
return -ENODEV;

dev = b53_swconfig_switch_alloc(&phydev->mdio.dev, &b53_mdio_ops, phydev->mdio.bus);
if (!dev)
return -ENOMEM;

dev->current_page = 0xff;
dev->priv = phydev->mdio.bus;
dev->ops = &b53_mdio_ops;
dev->pdata = NULL;
mutex_init(&dev->reg_mutex);

ret = b53_swconfig_switch_detect(dev);
if (ret)
return ret;

linkmode_zero(phydev->supported);
if (is5325(dev) || is5365(dev))
linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, phydev->supported);
else
linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, phydev->supported);

linkmode_copy(phydev->advertising, phydev->supported);

ret = b53_swconfig_switch_register(dev);
if (ret) {
dev_err(dev->dev, "failed to register switch: %i\n", ret);
return ret;
}

phydev->priv = dev;

return 0;
}

The above function is used to initialize the B53 phy device and register
it with the system. The function starts by checking if the phy device is
compatible with B53 (i.e. the MDCA address is B53_PSEU




NEXT




<s> static int b53_spi_probe(struct spi_device *spi)
{
struct b53_device *dev;
int ret;

dev = b53_swconfig_switch_alloc(&spi->dev, &b53_spi_ops, spi);
if (!dev)
return -ENOMEM;

if (spi->dev.platform_data)
dev->pdata = spi->dev.platform_data;

ret = b53_swconfig_switch_register(dev);
if (ret)
return ret;

spi_set_drvdata(spi, dev);

return 0;
}

The above function is used to probe and register our b53_device. All our b53_device functions are provided in b53_spi_ops(which is passed as a parameter in b53_swconfig_switch_alloc in b53




NEXT




<s> void rtk_hal_switch_init(void)
{
if(rtk_switch_init() != 0)
printk("rtk_switch_init failed\n");
mdelay(500);
/*vlan init */
if (rtk_vlan_init() != 0)
printk("rtk_vlan_init failed\n");
}

The above function is used to initialize the switch module, the rtk_switch_init function is defined in the driver/mcast_switch_drv.c and will be initialized as follows.
rtk_switch_init(void)
{
int ret =




NEXT




<s> ar8327_leds_init(struct ar8xxx_priv *priv)
{
struct ar8327_data *data = priv->chip_data;
unsigned i;

if (!IS_ENABLED(CONFIG_AR8216_PHY_LEDS))
return;

for (i = 0; i < data->num_leds; i++) {
struct ar8327_led *aled;

aled = data->leds[i];

if (aled->enable_hw_mode)
aled->pattern = AR8327_LED_PATTERN_RULE;
else
aled->pattern = AR8327_LED_PATTERN_OFF;

ar8327_set_led_pattern(priv, aled->led_num, aled->pattern);
}
}

The above function is used to initialze the LEDs at init time and when
the link status (connected/disconnected) occurs.

The problem with is that some LEDs have a fixed pattern:

leds: ar8xxx:ar832




NEXT




<s> ar8xxx_sw_reset_switch(struct switch_dev *dev)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
const struct ar8xxx_chip *chip = priv->chip;
int i;

mutex_lock(&priv->reg_mutex);
memset(&priv->ar8xxx_priv_volatile, 0, sizeof(priv->ar8xxx_priv_volatile));

for (i = 0; i < dev->vlans; i++)
priv->vlan_id[i] = i;

/* Configure all ports */
for (i = 0; i < dev->ports; i++)
chip->init_port(priv, i);

priv->mirror_rx = false;
priv->mirror_tx = false;
priv->source_port = 0;
priv->monitor_port = 0;
priv->arl_age_time = AR8XXX_DEFAULT_ARL_AGE_TIME;

chip->init_globals(priv);
chip->atu_flush(priv);

mutex_unlock(&priv->reg_mutex);

return chip->sw_hw_apply(dev);
}

The above function is used to perform a switch reset (or reboot).</s>




NEXT




<s> static void _rtl8367c_aclActStSmi2User(rtl8367c_acl_act_t *pAclUser, rtk_uint16 *pAclSmi)
{
pAclUser->cact = (pAclSmi[0] & 0x00C0) >> 6;
pAclUser->cvidx_cact = (pAclSmi[0] & 0x003F) | (((pAclSmi[3] & 0x0008) >> 3) << 6);

pAclUser->sact = (pAclSmi[0] & 0xC000) >> 14;
pAclUser->svidx_sact = ((pAclSmi[0] & 0x3F00) >> 8) | (((pAclSmi[3] & 0x0010) >> 4) << 6);

pAclUser->aclmeteridx = (pAclSmi[1] & 0x003F) | (((pAclSmi[3] & 0x0020) >> 5) << 6);

pAclUser->fwdact = (pAclSmi[1] & 0xC000) >> 14;
pAclUser->fwdpmask = ((pAclSmi[1] & 0x3FC0) >> 6) | (((pAclSmi[3] & 0x01C0) >> 6) << 8);

pAclUser->priact = (pAclSmi[2] & 0x00C0) >> 6;
pAclUser->pridx = (pAclSmi[2] & 0x003F) | (((pAclSmi[3] & 0x0200) >> 9) << 6);

pAclUser->aclint = (pAclSmi[2] & 0x2000) >> 13;
pAclUser->gpio_en = (pAclSmi[2] & 0x1000) >> 12;
pAclUser->gpio_pin = (pAclSmi[2] & 0x0F00) >> 8;

pAclUser->cact_ext = (pAclSmi[2] & 0xC000) >> 14;
pAclUser->tag_fmt = (pAclSmi[3] & 0x0003);
pAclUser->fwdact_ext = (pAclSmi[3] & 0x0004) >> 2;
}

The above function is used to translate user parameter into HW config of SMI AC block which includes the following elements :

cact : channel ACL counter enable.
pv/index : cact/sact channel ACL counter value.
meteridx :




NEXT




<s> void ifxdeu_fini_aes (void)
{
crypto_unregister_alg (&ifxdeu_aes_alg);
crypto_unregister_skcipher (&ifxdeu_ecb_aes_alg);
crypto_unregister_skcipher (&ifxdeu_cbc_aes_alg);
crypto_unregister_skcipher (&ifxdeu_xts_aes_alg);
crypto_unregister_skcipher (&ifxdeu_ofb_aes_alg);
crypto_unregister_skcipher (&ifxdeu_cfb_aes_alg);
crypto_unregister_skcipher (&ifxdeu_ctr_basic_aes_alg);
crypto_unregister_skcipher (&ifxdeu_ctr_rfc3686_aes_alg);
crypto_unregister_shash (&ifxdeu_cbcmac_aes_alg);
crypto_unregister_aead (&ifxdeu_gcm_aes_alg);
}

The above function is used to unregister driver from the Linux kernel,
after successful registration of drivers to the kernel.
On unregistering the module, the following
functions are called in the reverse order in
which they are called while registering the code to
the




NEXT




<s> static int __init mtdsplit_lzma_init(void)
{
register_mtd_parser(&mtdsplit_lzma_parser);

return 0;
}

The above function is used to register the LZMA-based UBI parsing function in the ubi_init() function. We shall now take a look at the parser function.

static mtd_parser_status mtdsplit_lzma_parser




NEXT




<s> ret_t rtl8367c_getAsicVlanUntagDscpPriorityEn(rtk_uint32* enabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_UNTAG_DSCP_PRI_CFG, RTL8367C_UNTAG_DSCP_PRI_CFG_OFFSET, enabled);
}

The above function is used to get VLAN Untag DSCP Setting configuration.

rtk_uint32 rtl8367c_getAsicVlanUnTagPcpEn(rtk_uint32* enabled)
{




NEXT




<s> static inline void m_bool(const char *id, bool value) {
blobmsg_add_u8(&b, id, value);
}

The above function is used to set a blob to a boolean value.

If we take a look at the blobmsg_builder code, we can see that if we get up a few functions, the call to blobmsg_add_u8() uses the function blob




NEXT




<s> void BN_MONT_CTX_free(BN_MONT_CTX *mont)
{
if(mont == NULL)
return;

BN_free(&(mont->RR));
BN_free(&(mont->N));
BN_free(&(mont->Ni));
if (mont->flags & BN_FLG_MALLOCED)
free(mont);
}

The above function is used to cleanup (free) memory of the BN_MONT_CTX struct when the BN_MONT_CTX is no longer needed.

void BN_MONT_CTX_clear(BN_MONT_CTX *mont




NEXT




<s> int rtl83xx_port_get_stp_state(struct rtl838x_switch_priv *priv, int port);
void rtl83xx_port_stp_state_set(struct dsa_switch *ds, int port, u8 state);
void rtl83xx_fast_age(struct dsa_switch *ds, int port);
u32 rtl838x_get_egress_rate(struct rtl838x_switch_priv *priv, int port);
u32 rtl839x_get_egress_rate(struct rtl838x_switch_priv *priv, int port);
int rtl838x_set_egress_rate(struct rtl838x_switch_priv *priv, int port, u32 rate);
int rtl839x_set_egress_rate(struct rtl838x_switch_priv *priv, int port, u32 rate);


const char *rtl838x_drop_cntr[] = {
"ALE_TX_GOOD_PKTS", "MAC_RX_DROP", "ACL_FWD_DROP", "HW_ATTACK_PREVENTION_DROP",
"RMA_DROP", "VLAN_IGR_FLTR_DROP", "INNER_OUTER_CFI_EQUAL_1_DROP", "PORT_MOVE_DROP",
"NEW_SA_DROP", "MAC_LIMIT_SYS_DROP", "MAC_LIMIT_VLAN_DROP", "MAC_LIMIT_PORT_DROP",
"SWITCH_MAC_DROP", "ROUTING_EXCEPTION_DROP", "DA_LKMISS_DROP", "RSPAN_DROP",
"ACL_LKMISS_DROP", "ACL_DROP", "INBW_DROP", "IGR_METER_DROP",
"ACCEPT_FRAME_TYPE_DROP", "STP_IGR_DROP", "INVALID_SA_DROP", "SA_BLOCKING_DROP",
"DA_BLOCKING_DROP", "L2_INVALID_DPM_DROP", "MCST_INVALID_DPM_DROP", "RX_FLOW_CONTROL_DROP",
"STORM_SPPRS_DROP", "LALS_DROP", "VLAN_EGR_FILTER_DROP", "STP_EGR_DROP",
"SRC_PORT_FILTER_DROP", "PORT_ISOLATION_DROP", "ACL_FLTR_DROP", "MIRROR_FLTR_DROP",
"TX_MAX_DROP", "LINK_DOWN_DROP", "FLOW_CONTROL_DROP", "BRIDGE .1d discards"
};

The above function is used to get the egress rate.
If the egress rate is not supported, the function returns 0.

The above function sets the egress rate. If the egress rate is not supported, the egress rate is set to 




NEXT




<s> struct ringbuf_entry * ringbuf_get(struct ringbuf *r, int i)
{
struct ringbuf_entry *e = r->buf + (((r->fill + i) % r->len) * r->slen);

if (e->len > 0)
return e;

return NULL;
}

The above function is used to read data into a buffer (of any number of bytes including zero), and I'm trying to figure out how fast it should be. I can't really figure out how to solve for that.

I'm a bit confused as




NEXT




<s> int __init bcma_fbs_register(void)
{
return platform_driver_register(&bcma_fbs_driver);
}

The above function is used to register the FBS platform driver

device_t *platform_device_register

The platform_device_register initializes the platform device driver, which
is responsible for registering the driver to the kernel, initializing it,





NEXT




<s> static int mt798x_2p5ge_phy_read_status(struct phy_device *phydev)
{
int ret;

ret = genphy_update_link(phydev);
if (ret)
return ret;

phydev->speed = SPEED_UNKNOWN;
phydev->duplex = DUPLEX_UNKNOWN;
phydev->pause = 0;
phydev->asym_pause = 0;

if (!phydev->link)
return 0;

if (phydev->autoneg == AUTONEG_ENABLE && phydev->autoneg_complete) {
ret = genphy_c45_read_lpa(phydev);
if (ret < 0)
return ret;

/* Read the link partner's 1G advertisement */
ret = phy_read(phydev, MII_STAT1000);
if (ret < 0)
return ret;
mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising, ret);
} else if (phydev->autoneg == AUTONEG_DISABLE) {
linkmode_zero(phydev->lp_advertising);
}

ret = phy_read(phydev, PHY_AUX_CTRL_STATUS);
if (ret < 0)
return ret;

switch (FIELD_GET(PHY_AUX_SPEED_MASK, ret)) {
case PHY_AUX_SPD_10:
phydev->speed = SPEED_10;
break;
case PHY_AUX_SPD_100:
phydev->speed = SPEED_100;
break;
case PHY_AUX_SPD_1000:
phydev->speed = SPEED_1000;
break;
case PHY_AUX_SPD_2500:
phydev->speed = SPEED_2500;
phydev->duplex = DUPLEX_FULL; /* 2.5G must be FDX */
break;
}

ret = phy_read_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_LINK_STATUS_MISC);
if (ret < 0)
return ret;

phydev->duplex = (ret & MTK_PHY_FDX_ENABLE) ? DUPLEX_FULL : DUPLEX_HALF;

return 0;
}

The above function is used to read the current status of a 10/100/1000/2500M bit bus on MT7985,MT7981,MT7982,MT7983




NEXT




<s> static int proc_read_dbg(char *, char **, off_t, int, int *, void *);
static int proc_write_dbg(struct file *, const char *, unsigned long, void *);
#endif

/*
*  Proc Help Functions
*/
static INLINE int stricmp(const char *, const char *);
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static INLINE int strincmp(const char *, const char *, int);
#endif
static INLINE int ifx_ptm_version(char *);

/*
*  Init & clean-up functions
*/
static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to check if ATM port has SHOWTIME (e.g. when ifxmips CPE board does not support showtime, we may force it's xdata value to NULL).
#endif
static int ifx_v




NEXT




<s> rtk_api_ret_t rtk_port_backpressureEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (port != RTK_WHOLE_SYSTEM)
return RT_ERR_PORT_ID;

if (enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicPortJamMode(!enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable the back pressure mechanism for the given port. Setting to 1 enables and 0 disables the mechanism.

/* Set Back Pressing Enable */
if (rtk_portBackpressureEnableSet(port, RT_ENABLE




NEXT




<s> void *xrealloc(void *p, size_t size)
{
p = realloc(p, size);
if (p)
return p;
fprintf(stderr, "Out of memory.\n");
exit(1);
}

The above function is used to "allocate" memory in the `xmalloc.c` and `xfree.c` files.
The line `size_t size = MAX_BLOBS/20;` allocates memory sufficient for 20 bl




NEXT




<s> ret_t rtl8367c_setAsicMLDv1Opeartion(rtk_uint32 port, rtk_uint32 mldv1_op)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(mldv1_op >= PROTOCOL_OP_END)
return RT_ERR_INPUT;

/* MLDv1 operation */
if(port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_MLDv1_OP_MASK, mldv1_op);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_MLDv1_OP_MASK, mldv1_op);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set the MLDv1 operation on a certain port. We need modify this function according to our requirements.

1. To allow MLDv1 operation on ports from 8 to RTL8367C_PORTIDMAX




NEXT




<s> ret_t rtl8367c_setAsicStormFilterExtUnknownMulticastMeter(rtk_uint32 meter)
{
if(meter > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

return rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG1, RTL8367C_UNMC_STORM_EXT_METERIDX_MASK, meter);
}

The above function is used to set the external storm meter
index for the storm filter.

Note that this can only be set when the type of storm filter is
set to EXT_STORM_FILTER_TYPE.

The external storm meter can be set




NEXT




<s> static inline u32 esw_r32(struct rt305x_esw *esw, unsigned reg)
{
return __raw_readl(esw->base + reg);
}

The above function is used to read the register value from the 32  bits
register.The result of this function is stored in a 32-bit variable, not in a
8-bit variable (which is not possible for a 32  bits




NEXT




<s> ret_t rtl8367c_getAsicLedSerialModeConfig(rtk_uint32 *active, rtk_uint32 *serimode)
{
ret_t retVal;

if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_SERI_LED_ACT_LOW_OFFSET, active))!=  RT_ERR_OK)
return retVal;

/*get to 8G mode (not 16G mode)*/
if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LED_MODE, RTL8367C_DLINK_TIME_OFFSET, serimode))!=  RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the following information:

The ASIC LED serial port mode and whether it’s 8G mode (not 16G mode). The LED serial port and LED 16G modes cannot be set at the same time,




NEXT




<s> server_handle_sigchld(int sig)
{
struct ead_instance *in;
struct list_head *p;
int pid = 0;
wait(&pid);

list_for_each(p, &instances) {
in = list_entry(p, struct ead_instance, list);
if (pid != in->pid)
continue;

in->pid = 0;
break;
}
}

The above function is used to handle signals 16 (SIGHUP) and 6
(SIGWINCH) and also checks whether the process is still running.
Please note that the signal 16 has been taken care by the signal
handler (ead_




NEXT




<s> static int ip175c_set_vlan_mode(struct ip17xx_state *state);
static int ip175c_reset(struct ip17xx_state *state);

static const struct register_mappings IP178C = {
.NAME = "IP178C",
.MODEL_NO = 0x18,
.VLAN_DEFAULT_TAG_REG = {
{30,3},{30,4},{30,5},{30,6},{30,7},{30,8},
{30,9},{30,10},{30,11},
},

.ADD_TAG_REG = {30,12},
.ADD_TAG_BIT = {0,1,2,3,4,5,6,7,8},
.REMOVE_TAG_REG = {30,13},
.REMOVE_TAG_BIT = {4,5,6,7,8,9,10,11,12},

.SIMPLE_VLAN_REGISTERS = 1,

.VLAN_LOOKUP_REG = {31,0},// +N
.VLAN_LOOKUP_REG_5 = NOTSUPPORTED, // not used with SIMPLE_VLAN_REGISTERS
.VLAN_LOOKUP_EVEN_BIT = {0,1,2,3,4,5,6,7,8},
.VLAN_LOOKUP_ODD_BIT = {0,1,2,3,4,5,6,7,8},

.TAG_VLAN_MASK_REG = {30,14}, // +N
.TAG_VLAN_MASK_EVEN_BIT = {0,1,2,3,4,5,6,7,8},
.TAG_VLAN_MASK_ODD_BIT = {0,1,2,3,4,5,6,7,8},

.RESET_VAL = 0x55AA,
.RESET_REG = {30,0},
.MODE_VAL = 0,
.MODE_REG = NOTSUPPORTED,

.ROUTER_CONTROL_REG = {30,30},
.ROUTER_EN_BIT = 11,
.NUMLAN_GROUPS_MAX = 8,
.NUMLAN_GROUPS_BIT = 8, // {0-2}

.VLAN_CONTROL_REG = {30,13},
.TAG_VLAN_BIT = 3,

.CPU_PORT = 8,
.NUM_PORTS = 9,

.MII_REGISTER_EN = NOTSUPPORTED,

.update_state = ip175c_update_state,
.set_vlan_mode = ip175c_set_vlan_mode,
.reset = ip175c_reset,
};

The above function is used to configure the IP17xx state with the appropriate values for this device.
NOTE: This function does not configure any state members, it does not write to the bus. It just initializes what the state members should contain when the bus state




NEXT




<s> rtk_api_ret_t rtk_trap_rmaAction_get(rtk_trap_type_t type, rtk_trap_rma_action_t *pRma_action)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;
rtk_uint32 tmp;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= TRAP_END)
return RT_ERR_INPUT;

if(NULL == pRma_action)
return RT_ERR_NULL_POINTER;

if (type >= 0 && type <= TRAP_UNDEF_GARP_2F)
{
if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;

*pRma_action = rmacfg.operation;
}
else if (type == TRAP_CDP)
{
if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;

*pRma_action = rmacfg.operation;
}
else if (type == TRAP_CSSTP)
{
if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;

*pRma_action = rmacfg.operation;
}
else if (type == TRAP_LLDP)
{
if ((retVal = rtl8367c_getAsicRmaLldp(&tmp,&rmacfg)) != RT_ERR_OK)
return retVal;

*pRma_action = rmacfg.operation;
}
else
return RT_ERR_INPUT;

return RT_ERR_OK;
}

The above function is used to retrieve the RMA action information. The function is used to retrieve the RMA action information and the trigger type to the rma_action_t structure.

The RMA configuration operation mode of the trap can be configured, which provides three




NEXT




<s> static int b53_srab_request_grant(struct b53_device *dev)
{
u8 __iomem *regs = dev->priv;
u32 ctrls;
int i;

ctrls = readl(regs + B53_SRAB_CTRLS);
ctrls |= B53_SRAB_CTRLS_RCAREQ;
writel(ctrls, regs + B53_SRAB_CTRLS);

for (i = 0; i < 20; i++) {
ctrls = readl(regs + B53_SRAB_CTRLS);
if (ctrls & B53_SRAB_CTRLS_RCAGNT)
break;
usleep_range(10, 100);
}
if (WARN_ON(i == 5))
return -EIO;

return 0;
}

The above function is used to request a channel allocation grant which
is used by b53_srab_allocate_channel as it looks for a valid channel.
If the driver fails to get a grant, then the allocation will fail which
in turn means that




NEXT




<s> ret_t rtl8367c_getAsicEavInterruptMask(rtk_uint32* pImr)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_PTP_TIME_CFG2, RTL8367C_PTP_INTR_MASK, pImr);
}

The above function is used to fetch internal asic event interrupt mask register, and it will fail if called when interrupt is occurred. As we can see in the definition of RTL8367C_PTP_INTR_MASK:

#define RTL




NEXT




<s> int conf_write_autoconf(int overwrite)
{
struct symbol *sym;
const char *name;
const char *autoconf_name = conf_get_autoconfig_name();
FILE *out, *out_h;
int i;

#ifndef OPENWRT_DOES_NOT_WANT_THIS
return 0;
#endif
if (!overwrite && is_present(autoconf_name))
return 0;

conf_write_dep("include/config/auto.conf.cmd");

if (conf_touch_deps())
return 1;

out = fopen(".tmpconfig", "w");
if (!out)
return 1;

out_h = fopen(".tmpconfig.h", "w");
if (!out_h) {
fclose(out);
return 1;
}

conf_write_heading(out, &kconfig_printer_cb, NULL);
conf_write_heading(out_h, &header_printer_cb, NULL);

for_all_symbols(i, sym) {
sym_calc_value(sym);
if (!(sym->flags & SYMBOL_WRITE) || !sym->name)
continue;

/* write symbols to auto.conf and autoconf.h */
conf_write_symbol(out, sym, &kconfig_printer_cb, (void *)1);
conf_write_symbol(out_h, sym, &header_printer_cb, NULL);
}
fclose(out);
fclose(out_h);

name = getenv("KCONFIG_AUTOHEADER");
if (!name)
name = "include/generated/autoconf.h";
if (make_parent_dir(name))
return 1;
if (rename(".tmpconfig.h", name))
return 1;

if (make_parent_dir(autoconf_name))
return 1;
/*
* This must be the last step, kbuild has a dependency on auto.conf
* and this marks the successful completion of the previous steps.
*/
if (rename(".tmpconfig", autoconf_name))
return 1;

return 0;
}

The above function is used to generate .tmpconfig and .tmpconfig.h based on the
contents of the autoconfig directory. The kconfig_printer_cb and header_printer_cb
are used to process the output in the .tmpconfig and




NEXT




<s> rtk_api_ret_t rtk_switch_logPortMask_get(rtk_portmask_t *pPortmask)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_FAILED;

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

pPortmask->bits[0] = halCtrl->valid_portmask;
return RT_ERR_OK;
}

The above function is used to read out the portmask configured on current port. The portmask is set by the following functions: rtk_switch_portmask_set , rtk_switch_portmask_enable and rtk_switch_portmask_disable.




NEXT




<s> static int clk_mt7988_mcusys_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;
int nr = ARRAY_SIZE(mcu_muxes);

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(nr);
if (!clk_data)
return -ENOMEM;

mtk_clk_register_composites(mcu_muxes, ARRAY_SIZE(mcu_muxes), base,
&mt7988_clk_lock, clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);

if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_mcusys_data;
}
return r;

free_mcusys_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to register MT7988 mcusys.</s>




NEXT




<s> static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to check whether the VPI/VCI match the current showtime VPI/VCI or not. VPI/VCI in showtime is configurable. Default value is 2041/2031.
#endif




NEXT




<s> static void bcm6348_emac_set_flow(struct bcm6348_emac *emac, bool rx_en, bool tx_en)
{
struct bcm6348_iudma *iudma = emac->iudma;
u32 val;

val = emac_readl(emac, ENET_RXCFG_REG);
if (rx_en)
val |= ENET_RXCFG_ENFLOW_MASK;
else
val &= ~ENET_RXCFG_ENFLOW_MASK;
emac_writel(emac, val, ENET_RXCFG_REG);

dmas_writel(iudma, emac->rx_desc_dma, DMAS_RSTART_REG, emac->rx_chan);
dmas_writel(iudma, emac->tx_desc_dma, DMAS_RSTART_REG, emac->tx_chan);

val = dma_readl(iudma, DMA_CFG_REG);
if (tx_en)
val |= DMA_CFG_FLOWCH_MASK(emac->rx_chan);
else
val &= ~DMA_CFG_FLOWCH_MASK(emac->rx_chan);
dma_writel(iudma, val, DMA_CFG_REG);
}

The above function is used to start/stop a flow based on rx_en/tx_en values. This function is used by emac_init to enable flow, ie. in emac_init()

> bcm6348_emac_




NEXT




<s> int gsw_debug_proc_init(void)
{

if (!proc_reg_dir)
proc_reg_dir = proc_mkdir(PROCREG_DIR, NULL);

proc_esw_cnt =
proc_create(PROCREG_ESW_CNT, 0, proc_reg_dir, &switch_count_fops);

if (!proc_esw_cnt)
pr_err("!! FAIL to create %s PROC !!\n", PROCREG_ESW_CNT);

proc_vlan_cnt =
proc_create(PROCREG_VLAN, 0, proc_reg_dir, &switch_vlan_fops);

if (!proc_vlan_cnt)
pr_err("!! FAIL to create %s PROC !!\n", PROCREG_VLAN);

proc_mac_tbl =
proc_create(PROCREG_MAC_TBL, 0, proc_reg_dir, &mac_tbl_fops);

if (!proc_mac_tbl)
pr_err("!! FAIL to create %s PROC !!\n", PROCREG_MAC_TBL);

proc_reg =
proc_create(PROCREG_REG, 0, proc_reg_dir, &reg_fops);

if (!proc_reg)
pr_err("!! FAIL to create %s PROC !!\n", PROCREG_REG);

proc_phyreg =
proc_create(PROCREG_PHYREG, 0, proc_reg_dir, &phyreg_fops);

if (!proc_phyreg)
pr_err("!! FAIL to create %s PROC !!\n", PROCREG_PHYREG);

proc_mirror =
proc_create(PROCREG_MIRROR, 0, proc_reg_dir, &mirror_fops);

if (!proc_mirror)
pr_err("!! FAIL to create %s PROC !!\n", PROCREG_MIRROR);

proc_igmp =
proc_create(PROCREG_IGMP, 0, proc_reg_dir, &igmp_fops);

if (!proc_igmp)
pr_err("!! FAIL to create %s PROC !!\n", PROCREG_IGMP);

return 0;
}

The above function is used to initialize the /proc interface of gsw. It will
register the proc file for each subcomponent of GSW.

To view the port map and its corresponding MAC address in gsw, we can use the command below:

#




NEXT




<s> static void rtl931x_pie_init(struct rtl838x_switch_priv *priv)
{
u32 template_selectors;

mutex_init(&priv->pie_mutex);

pr_info("%s\n", __func__);
/* Enable ACL lookup on all ports, including CPU_PORT */
for (int i = 0; i <= priv->cpu_port; i++)
sw_w32(1, RTL931X_ACL_PORT_LOOKUP_CTRL(i));

/* Include IPG in metering */
sw_w32_mask(0, 1, RTL931X_METER_GLB_CTRL);

/* Delete all present rules, block size is 128 on all SoC families */
rtl931x_pie_rule_del(priv, 0, priv->n_pie_blocks * 128 - 1);

/* Assign first half blocks 0-7 to VACL phase, second half to IACL */
/* 3 bits are used for each block, values for PIE blocks are */
/* 6: Disabled, 0: VACL, 1: IACL, 2: EACL */
/* And for OpenFlow Flow blocks: 3: Ingress Flow table 0, */
/* 4: Ingress Flow Table 3, 5: Egress flow table 0 */
for (int i = 0; i < priv->n_pie_blocks; i++) {
int pos = (i % 10) * 3;
u32 r = RTL931X_PIE_BLK_PHASE_CTRL + 4 * (i / 10);

if (i < priv->n_pie_blocks / 2)
sw_w32_mask(0x7 << pos, 0, r);
else
sw_w32_mask(0x7 << pos, 1 << pos, r);
}

/* Enable predefined templates 0, 1 for first quarter of all blocks */
template_selectors = 0 | (1 << 4);
for (int i = 0; i < priv->n_pie_blocks / 4; i++)
sw_w32(template_selectors, RTL931X_PIE_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 2, 3 for second quarter of all blocks */
template_selectors = 2 | (3 << 4);
for (int i = priv->n_pie_blocks / 4; i < priv->n_pie_blocks / 2; i++)
sw_w32(template_selectors, RTL931X_PIE_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 0, 1 for third quater of all blocks */
template_selectors = 0 | (1 << 4);
for (int i = priv->n_pie_blocks / 2; i < priv->n_pie_blocks * 3 / 4; i++)
sw_w32(template_selectors, RTL931X_PIE_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 2, 3 for fourth quater of all blocks */
template_selectors = 2 | (3 << 4);
for (int i = priv->n_pie_blocks * 3 / 4; i < priv->n_pie_blocks; i++)
sw_w32(template_selectors, RTL931X_PIE_BLK_TMPLTE_CTRL(i));

}

The above function is used to init the PIE block
to assign blocks for various purposes like
VACL,IACL,EACL,Flow etc.

For rtl9312, we need to add one more step
to configure the




NEXT




<s> rtk_api_ret_t rtk_svlan_sp2c_del(rtk_vlan_t svid, rtk_port_t dst_port)
{
rtk_api_ret_t retVal;
rtk_uint32 i, svidx;
rtl8367c_svlan_memconf_t svlanMemConf;
rtl8367c_svlan_s2c_t svlanSP2CConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (svid > RTL8367C_VIDMAX)
return RT_ERR_SVLAN_VID;

/* Check port Valid */
RTK_CHK_PORT_VALID(dst_port);
dst_port = rtk_switch_port_L2P_get(dst_port);

svidx = 0xFFFF;

for (i = 0; i < RTL8367C_SVIDXNO; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;

if (svid == svlanMemConf.vs_svid)
{
svidx = i;
break;
}
}

if (0xFFFF == svidx)
return RT_ERR_SVLAN_ENTRY_NOT_FOUND;

for (i = 0; i <= RTL8367C_SP2CMAX; i++)
{
if ((retVal = rtl8367c_getAsicSvlanSP2CConf(i, &svlanSP2CConf)) != RT_ERR_OK)
return retVal;

if ( (svlanSP2CConf.svidx == svidx) && (svlanSP2CConf.dstport == dst_port) && (svlanSP2CConf.valid == 1) )
{
svlanSP2CConf.valid     = 0;
svlanSP2CConf.vid       = 0;
svlanSP2CConf.svidx     = 0;
svlanSP2CConf.dstport   = 0;

if ((retVal = rtl8367c_setAsicSvlanSP2CConf(i, &svlanSP2CConf)) != RT_ERR_OK)
return retVal;
return RT_ERR_OK;
}

}

return RT_ERR_OUT_OF_RANGE;
}

The above function is used to delete SVID -> CVID to destination Port
mapping.</s>




NEXT




<s> ret_t rtl8367c_setAsicIGMPReportLeaveFlood(rtk_uint32 flood)
{
ret_t   retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG3, RTL8367C_REPORT_LEAVE_FORWARD_MASK, flood);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the "Report LEAVE forward enable bits" within register RTL8367C_REG_IGMP_MLD_CFG3, which is 0x1912 when using RTL8367C




NEXT




<s> static void ag71xx_setup_gmac_955x(struct device_node *np, void __iomem *base)
{
u32 val = __raw_readl(base + QCA955X_GMAC_REG_ETH_CFG);

ag71xx_of_bit(np, "rgmii-enabled", &val, QCA955X_ETH_CFG_RGMII_EN);
ag71xx_of_bit(np, "ge0-sgmii", &val, QCA955X_ETH_CFG_GE0_SGMII);
ag71xx_of_set(np, "txen-delay", &val, QCA955X_ETH_CFG_TXE_DELAY_SHIFT, 0x3);
ag71xx_of_set(np, "txd-delay", &val, QCA955X_ETH_CFG_TXD_DELAY_SHIFT, 0x3);
ag71xx_of_set(np, "rxdv-delay", &val, QCA955X_ETH_CFG_RDV_DELAY_SHIFT, 0x3);
ag71xx_of_set(np, "rxd-delay", &val, QCA955X_ETH_CFG_RXD_DELAY_SHIFT, 0x3);

__raw_writel(val, base + QCA955X_GMAC_REG_ETH_CFG);
}

The above function is used to set certain registers specific for an SoC to do something like enable RGMII mode. In order to be able to use this function we would need access to the device nodes.</s>




NEXT




<s> static void __exit trelay_exit(void)
{
struct trelay *tr, *tmp;

unregister_netdevice_notifier(&tr_dev_notifier);

rtnl_lock();
list_for_each_entry_safe(tr, tmp, &trelay_devs, list)
trelay_do_remove(tr);
rtnl_unlock();

debugfs_remove_recursive(debugfs_dir);
}

The above function is used to remove a TRELAY device when the module
gets unloaded.

We first unregister the net device_notifier callback which we used to
detect new TRELAY devices. At this point there is no need for the
not




NEXT




<s> static INLINE int mailbox_rx_irq_handler(unsigned int);
static irqreturn_t mailbox_irq_handler(int, void *);
static INLINE void mailbox_signal(unsigned int, int);
#ifdef CONFIG_IFX_PTM_RX_TASKLET
static void do_ptm_tasklet(unsigned long);
#endif

/*
*  Debug Functions
*/
#if defined(DEBUG_DUMP_SKB) && DEBUG_DUMP_SKB
static void dump_skb(struct sk_buff *, u32, char *, int, int, int);
#else
#define dump_skb(skb, len, title, port, ch, is_tx)    do {} while (0)

The above function is used to dump the sk_buff in certain condition
like when the length is more than 128, when port and channel is not
known and when the sk_buff is received when it should have been transmitted.
#endif</s>




NEXT




<s> static inline int gpio_dir(struct dc_ep_dev *dev, u32 gpio, int dir)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_gpio_dir(dev->priv, gpio, dir);
}

The above function is used to configure an output direction on a GPIO pin. If you want to change the direction to an output, just change the `dir` parameter to 0:

for dev in dc_ep_devs:
gpio_dir(dev,




NEXT




<s> static int rtl8367b_extif_init(struct rtl8366_smi *smi, int id,
struct rtl8367_extif_config *cfg)
{
enum rtl8367_extif_mode mode;
int err;

mode = (cfg) ? cfg->mode : RTL8367_EXTIF_MODE_DISABLED;

err = rtl8367b_extif_set_mode(smi, id, mode);
if (err)
return err;

if (mode != RTL8367_EXTIF_MODE_DISABLED) {
err = rtl8367b_extif_set_force(smi, id, &cfg->ability);
if (err)
return err;

err = rtl8367b_extif_set_rgmii_delay(smi, id, cfg->txdelay,
cfg->rxdelay);
if (err)
return err;
}

return 0;
}

The above function is used to set an MDIO interface in the extended interface of one RGMII port to work as a phy or as regular extif (with a special configuration).

In this function, there are three things done:

1. set the




NEXT




<s> static void show_helptext(const char *title, const char *text);
static void show_help(struct menu *menu);

static char filename[PATH_MAX+1];
static void set_config_filename(const char *config_filename)
{
static char menu_backtitle[PATH_MAX+128];

snprintf(menu_backtitle, sizeof(menu_backtitle), "%s - %s",
config_filename, rootmenu.prompt->text);
set_dialog_backtitle(menu_backtitle);

snprintf(filename, sizeof(filename), "%s", config_filename);
}

The above function is used to set menu titles in the rootmenu:
Code:
if ((ret < 0) ||
(!strcmp(filename, "/usr/share/vdr/config/vdr.cfg")))
{
   set_config_




NEXT




<s> static int b53_mmap_write32(struct b53_device *dev, u8 page, u8 reg,
u32 value)
{
u8 __iomem *regs = dev->priv;

if (WARN_ON(reg % 4))
return -EINVAL;

if (dev->pdata && dev->pdata->big_endian)
writel_be(value, regs + (page << 8) + reg);
else
writel(value, regs + (page << 8) + reg);

return 0;
}

The above function is used to write u32 values into the address register (regs). But this will lead to a compiler warning because it will pass the u8 page to the write32 function and it should be of type u8 reg.

I suggest simply remove




NEXT




<s> void LED_init (void)
{
AT91PS_PIO	PIOB	= AT91C_BASE_PIOB;
AT91PS_PMC	PMC	= AT91C_BASE_PMC;
PMC->PMC_PCER		= (1 << AT91C_ID_PIOB);	// Enable PIOB clock
// Disable peripherals on LEDs
PIOB->PIO_PER		= AT91C_PIO_PB2 | AT91C_PIO_PB1 | AT91C_PIO_PB0;
// Enable pins as outputs
PIOB->PIO_OER		= AT91C_PIO_PB2 | AT91C_PIO_PB1 | AT91C_PIO_PB0;
// Turn all LEDs OFF
PIOB->PIO_SODR		= AT91C_PIO_PB2 | AT91C_PIO_PB1 | AT91C_PIO_PB0;
}

The above function is used to set LEDs (LED2,led1 and led0).

```
#define LED1_PORT	PIOB
#define LED1_PIN		AT91C_PIO_PB1
#define LED0




NEXT




<s> u32 rtl9310_sds_field_r(int sds, u32 page, u32 reg, int end_bit, int start_bit)
{
int l = end_bit - start_bit + 1;
u32 v = rtl931x_read_sds_phy(sds, page, reg);

if (l >= 32)
return v;

return (v >> start_bit) & (BIT(l) - 1);
}

The above function is used to get the content of a one or more bits in a register. To get the content of one bit, we may call the above function as below:

u32 v = rtl9310_sds_field_r




NEXT




<s> static int vr9_start(int pp32)
{
unsigned int mask = 1 << (pp32 << 4);
int ret;

/*  download firmware   */
ret = vr9_pp32_download_code(pp32,
vr9_fw_bin, sizeof(vr9_fw_bin) / sizeof(*vr9_fw_bin),
vr9_fw_data, sizeof(vr9_fw_data) / sizeof(*vr9_fw_data));
if ( ret != 0 )
return ret;

/*  run PP32    */
IFX_REG_W32_MASK(mask, 0, PP32_FREEZE);

/*  idle for a while to let PP32 init itself    */
udelay(10);

return 0;
}

The above function is used to start the PP32. You have to call it from the device's open entry point. If you are running an application you can call this function from the system startup code.

We will now create a new device entry point that inv




NEXT




<s> struct symbol **sym_re_search(const char *pattern)
{
struct symbol *sym, **sym_arr = NULL;
struct sym_match *sym_match_arr = NULL;
int i, cnt, size;
regex_t re;
regmatch_t match[1];

cnt = size = 0;
/* Skip if empty */
if (strlen(pattern) == 0)
return NULL;
if (regcomp(&re, pattern, REG_EXTENDED|REG_ICASE))
return NULL;

for_all_symbols(i, sym) {
if (sym->flags & SYMBOL_CONST || !sym->name)
continue;
if (regexec(&re, sym->name, 1, match, 0))
continue;
if (cnt >= size) {
void *tmp;
size += 16;
tmp = realloc(sym_match_arr, size * sizeof(struct sym_match));
if (!tmp)
goto sym_re_search_free;
sym_match_arr = tmp;
}
sym_calc_value(sym);
/* As regexec returned 0, we know we have a match, so
* we can use match[0].rm_[se]o without further checks
*/
sym_match_arr[cnt].so = match[0].rm_so;
sym_match_arr[cnt].eo = match[0].rm_eo;
sym_match_arr[cnt++].sym = sym;
}
if (sym_match_arr) {
qsort(sym_match_arr, cnt, sizeof(struct sym_match), sym_rel_comp);
sym_arr = malloc((cnt+1) * sizeof(struct symbol *));
if (!sym_arr)
goto sym_re_search_free;
for (i = 0; i < cnt; i++)
sym_arr[i] = sym_match_arr[i].sym;
sym_arr[cnt] = NULL;
}
sym_re_search_free:
/* sym_match_arr can be NULL if no match, but free(NULL) is OK */
free(sym_match_arr);
regfree(&re);

return sym_arr;
}

The above function is used to find all symbols matched by a regex such as 42.

To make searching by pattern more pleasant to use, a shell pattern syntax can be added. It is similar to the regexp that is being used as a backend for this.




NEXT




<s> static int rtl8380_configure_rtl8214c(struct phy_device *phydev)
{
u32 phy_id, val;
int mac = phydev->mdio.addr;

val = phy_read(phydev, 2);
phy_id = val << 16;
val = phy_read(phydev, 3);
phy_id |= val;
pr_debug("Phy on MAC %d: %x\n", mac, phy_id);

phydev_info(phydev, "Detected external RTL8214C\n");

/* GPHY auto conf */
phy_write_paged(phydev, RTL821X_PAGE_GPHY, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_AUTO);

return 0;
}

The above function is used to configure the RTL8214C on an 8380.

A more generic approach would be to use mac-index=23 which would cover all other devices. So the problem with our driver lies only with the




NEXT




<s> static int tr_device_event(struct notifier_block *unused, unsigned long event,
void *ptr)
{
struct net_device *dev = netdev_notifier_info_to_dev(ptr);
struct trelay *tr;

if (event != NETDEV_UNREGISTER)
goto out;

tr = trelay_find(dev);
if (!tr)
goto out;

trelay_do_remove(tr);

out:
return NOTIFY_DONE;
}

The above function is used to manage the link layer events
received for the device for which the driver has registered.
The following events are supported:
1.NETDEV_REGISTER
2.NETDEV_UNREGISTER
NETDEV_REGISTER is used




NEXT




<s> static int mt7530_get_arl_table(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
char *buf = priv->arl_buf;
size_t size = sizeof(priv->arl_buf);
size_t count = 0;
size_t retry_times = 100;
int ret;
u32 atc;

ret = snprintf(buf, size, "address resolution table\n");
if (ret >= size || ret <= 0) {
priv->arl_buf[0] = 0;
goto out;
}
buf += ret;
size = size - ret;

mt7530_w32(priv, REG_ESW_WT_MAC_ATC, REG_MAC_ATC_START);

do {
atc = mt7530_r32(priv, REG_ESW_WT_MAC_ATC);
if (atc & REG_MAC_ATC_SRCH_HIT && !(atc & REG_MAC_ATC_BUSY)) {
u32 atrd;

++count;
atrd = mt7530_r32(priv, REG_ESW_TABLE_ATRD);
if (atrd & REG_ATRD_VALID) {
u32 mac1;
u32 mac2;

mac1 = mt7530_r32(priv, REG_ESW_TABLE_TSRA1);
mac2 = mt7530_r32(priv, REG_ESW_TABLE_TSRA2);

if (!(atc & REG_MAC_ATC_SRCH_END))
mt7530_w32(priv, REG_ESW_WT_MAC_ATC, REG_MAC_ATC_NEXT);

buf = mt7530_print_arl_table_row(atrd, mac1, mac2, buf, &size);
if (!buf) {
pr_warn("%s: too many addresses\n", __func__);
goto out;
}
} else if (!(atc & REG_MAC_ATC_SRCH_END)) {
mt7530_w32(priv, REG_ESW_WT_MAC_ATC, REG_MAC_ATC_NEXT);
}
} else {
--retry_times;
usleep_range(1000, 5000);
}
} while (!(atc & REG_MAC_ATC_SRCH_END) &&
count < MT7530_NUM_ARL_RECORDS &&
retry_times > 0);
out:
val->value.s = priv->arl_buf;
val->len = strlen(priv->arl_buf);

return 0;
}

The above function is used to get address resolution table. It can be invoked by issuing the following command:

$ eswctl show --attr arl # show Ethernet switch address resolution table

This snippet shows all 256 MAC addresses in




NEXT




<s> static int rtl838x_eth_stop(struct net_device *ndev)
{
struct rtl838x_eth_priv *priv = netdev_priv(ndev);

pr_info("in %s\n", __func__);

phylink_stop(priv->phylink);
rtl838x_hw_stop(priv);

for (int i = 0; i < priv->rxrings; i++)
napi_disable(&priv->rx_qs[i].napi);

netif_tx_stop_all_queues(ndev);

return 0;
}

The above function is used to stop NIC. To stop NIC we will:1. Stop PHY: This will reset PHY with PHY controller (PHYC) for power down. We may also disable PHY controller(PCH enable) before this step.




NEXT




<s> t_getpreparam(idx)
int idx;
{
if(pre_params[idx].state == 0) {
/* Wire up storage */
pre_params[idx].preconf.modulus.data = pre_params[idx].modbuf;
pre_params[idx].preconf.generator.data = pre_params[idx].genbuf;

/* Convert from b64 to t_num */
pre_params[idx].preconf.modulus.len = t_fromb64(pre_params[idx].preconf.modulus.data, pre_params[idx].preconf.mod_b64);
pre_params[idx].preconf.generator.len = t_fromb64(pre_params[idx].preconf.generator.data, pre_params[idx].preconf.gen_b64);

pre_params[idx].state = 1;
}
return &(pre_params[idx].preconf);
}

The above function is used to fetch the data of the first group of paramaters. This function was extracted from the crypto_kem_get_public_key function, with a few changes. The changes consist of moving the declaration for the function from line 17 to line




NEXT




<s> static int proc_write_wanmib(struct file *, const char *, unsigned long, void *);
#if defined(ENABLE_FW_PROC) && ENABLE_FW_PROC
static int proc_read_genconf(char *, char **, off_t, int, int *, void *);
#endif
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static int proc_read_dbg(char *, char **, off_t, int, int *, void *);
static int proc_write_dbg(struct file *, const char *, unsigned long, void *);
#endif

/*
*  Proc Help Functions
*/
static INLINE int stricmp(const char *, const char *);
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static INLINE int strincmp(const char *, const char *, int);
#endif
static INLINE int ifx_ptm_version(char *);

/*
*  Init & clean-up functions
*/
static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to check if some showtime packets were created.
The function receives the port cell number, it needs to compare from which port the packet was created.
It also receives the xdata address which is part of the xheader of the showtime packet




NEXT




<s> static u32 en7523_get_div(void __iomem *base, int i)
{
const struct en_clk_desc *desc = &en7523_base_clks[i];
u32 reg, val;

if (!desc->div_bits)
return 1;

reg = desc->div_reg ? desc->div_reg : desc->base_reg;
val = readl(base + reg);
val >>= desc->div_shift;
val &= (1 << desc->div_bits) - 1;

if (!val && desc->div_val0)
return desc->div_val0;

return (val + 1) * desc->div_step;
}

The above function is used to get the divider value for the clocks in the en7523 register, but it needs the shift register and number of bits for that register to calculate the divider value.

The shifts used for the register can be hardc




NEXT




<s> void dc_ep_clkod_disable(struct dc_ep_priv *priv)
{
wr32_mask(0, IF_CLKOD_ALL, IF_CLK);
}

The above function is used to disable the DC_EP clock gating register.

But there is another function which uses a different address space.

void dc_ep_clkod_disable(struct dc_ep_priv *priv)
{
wr3




NEXT




<s> u32 fe_r32(unsigned reg)
{
return __raw_readl(fe_base + reg);
}

The above function is used to read the first 32 bits of a register. The second argument does not make a lot of sense as an argument to the above function, since the function is expecting the value passed should be the base address of the module. So, I guess




NEXT




<s> static void get_vector_status(int fd, vector_t *status) {
*status = VECTOR_UNKNOWN;

#ifdef INCLUDE_DSL_CPE_API_VRX
if (fd < 0)
return;

IOCTL(IOCTL_MEI_dsmStatus_t, FIO_MEI_DSM_STATUS_GET);

switch (out.eVectorStatus) {
case e_MEI_VECTOR_STAT_OFF:
*status = VECTOR_OFF;
break;
case e_MEI_VECTOR_STAT_ON_DS:
*status = VECTOR_ON_DS;
break;
case e_MEI_VECTOR_STAT_ON_DS_US:
*status = VECTOR_ON_DS_US;
break;
default:
break;
};
#endif
}

The above function is used to read the interrupt status as returned by the driver on an interrupt. The value used here is the DSM status.

static void get_ddc2_status(int fd, vector_t *status) {
*status = V




NEXT




<s> ret_t rtl8367c_getAsicCputagEnable(rtk_uint32 *pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_EN_OFFSET, pEnabled);
}

The above function is used to get the CPUTagEnable setting when the ASIC is at running status and it is not stable because RTK8367C_MAX_PACKETS = 128 so when we use 8 packets in this function we




NEXT




<s> ar8327_set_led_pattern(struct ar8xxx_priv *priv, unsigned int led_num,
enum ar8327_led_pattern pattern)
{
const struct ar8327_led_entry *entry;

entry = &ar8327_led_map[led_num];
ar8xxx_rmw(priv, AR8327_REG_LED_CTRL(entry->reg),
(3 << entry->shift), pattern << entry->shift);
}

The above function is used to set led pattern for one led.
The input parameters are:
– priv: This is the controller private data structure.
– led_num: The led is identified by the led_num parameter. There are 32 leds in




NEXT




<s> rtk_api_ret_t rtk_l2_limitLearningCntAction_get(rtk_port_t port, rtk_l2_limitLearnCntAction_t *pAction)
{
rtk_api_ret_t retVal;
rtk_uint32 action;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (port != RTK_WHOLE_SYSTEM)
return RT_ERR_PORT_ID;

if(NULL == pAction)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLutLearnOverAct(&action)) != RT_ERR_OK)
return retVal;

if ( 1 == action )
*pAction = LIMIT_LEARN_CNT_ACTION_DROP;
else if ( 0 == action )
*pAction = LIMIT_LEARN_CNT_ACTION_FORWARD;
else if ( 2 == action )
*pAction = LIMIT_LEARN_CNT_ACTION_TO_CPU;
else
*pAction = action;

return RT_ERR_OK;
}

The above function is used to gets the setting of limitLearningCntAction field in L2 forwarding information.

```
if(NULL == pAction)
return RT_ERR_NULL_POINTER;
```

To avoid un




NEXT




<s> static void g977_get_qln(int fd, DSL_AccessDir_t direction) {
IOCTL_DIR_DELT(DSL_G997_DeltQln_t, DSL_FIO_G997_DELT_QLN_GET, direction, DSL_DELT_DATA_SHOWTIME);

m_u32("groupsize", out.data.nGroupSize);
m_u32("groups", out.data.deltQln.nNumData);

void *c = blobmsg_open_array(&b, "data");

// QLN -150 ... -23 dBm/Hz
for (uint16_t i  = 0  ; i < out.data.deltQln.nNumData ; i++)
if (out.data.deltQln.nNSCData[i] != 255 && out.data.deltQln.nNSCData[i] != 0)
m_double("", -23 - (double)out.data.deltQln.nNSCData[i] / 2);
else
m_null();

blobmsg_close_array(&b, c);
}

The above function is used to send QLN data to the control system. QLN (Quality Loss Number) is a measure of signal distortion in the last nano-second or so (a very small time frame). The more signal distortion, the greater




NEXT




<s> int get_line_length(const char *line)
{
int res = 0;
while (*line != '\0' && *line != '\n') {
line++;
res++;
}
return res;
}

The above function is used to determine the length of a string that can be read from stdin
so that it doesn't overflow the dynamic string buffer it gets passed and null terminated
by adding the newline character.
While it is a good candidate of the C




NEXT




<s> int env_init(void)
{
/* use default */
gd->env_addr = (ulong)&default_environment[0];
gd->env_valid = 1;

return 0;
}

The above function is used to initialize the environment, where the
environment information of the program is stored.

## The use of environment variables and how to process environment variables

From the program’s own perspective, although the environment information is stored in environment variables, from




NEXT




<s> void board_init_f(ulong dummy)
{
/* Set the stack pointer. */
asm volatile("mov sp, %0\n" : : "r"(CONFIG_SPL_STACK));

/* Clear the BSS. */
memset(__bss_start, 0, __bss_end - __bss_start);

/* Set global data pointer. */
gd = &gdata;

board_inithw();

board_init_r(NULL, 0);
}

The above function is used to initialize the hardware for the current machine,
before booting the actual kernel. This function can be used in customized
distributions to add additional hardware setup code.

The board_inithw() function is called early during the machine




NEXT




<s> static u16 find_valid_block_in_pool(struct bbbt *bbt)
{
int i;

if (bmtd.bmt_blk_idx == 0)
goto error;

for (i = 0; i < bmtd.bmt_blk_idx; i++) {
if (bmt_tbl(bbt)[i].block != 0 && bmt_tbl(bbt)[i].mapped == NO_MAPPED) {
bmt_tbl(bbt)[i].mapped = NORMAL_MAPPED;
return bmt_tbl(bbt)[i].block;
}
}

error:
pr_info("nand: FATAL ERR: BMT pool is run out!\n");
return 0;
}

The above function is used to find a free block in the blockmap table pool(BMT). The BMT is a structure that stores all the available blocks on the NAND Flash, which I will explain later. If there is no free block, you will hear `F




NEXT




<s> void nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
{
struct nand_chip *this = mtd->priv;
unsigned long nandaddr = (unsigned long) this->IO_ADDR_W;

if (ctrl & NAND_CTRL_CHANGE) {
nandaddr &= ~(BIT(NAND_ALE_ADDR_PIN) | BIT(NAND_CLE_ADDR_PIN));
if (ctrl & NAND_CLE)
nandaddr |= BIT(NAND_CLE_ADDR_PIN);
else if (ctrl & NAND_ALE)
nandaddr |= BIT(NAND_ALE_ADDR_PIN);
this->IO_ADDR_W = (void __iomem *) nandaddr;
}

if (cmd != NAND_CMD_NONE)
writeb(cmd, (void __iomem *) nandaddr);
}

The above function is used to provide the NAND specific hw control
functions (similar to nand_hwcontrol() in linux).  However, the main
differences
are that it is not intended to be called directly by C code; and it





NEXT




<s> Byte RangeDecoderReadByte(CRangeDecoder *rd)
{
if (rd->Buffer == rd->BufferLim)
{
#ifdef _LZMA_IN_CB
UInt32 size;
rd->Result = rd->InCallback->Read(rd->InCallback, &rd->Buffer, &size);
rd->BufferLim = rd->Buffer + size;
if (size == 0)
#endif
{
rd->ExtraBytes = 1;
return 0xFF;
}
}
return (*rd->Buffer++);
}

The above function is used to read and emit raw data. As you can see the code is very simple: If the current buffer is not empty then return the next byte from the buffer. The returned value is used to control the behavior of the compressor so, for example,




NEXT




<s> static inline struct oxnas_pcie *sys_to_pcie(struct pci_sys_data *sys)
{
return sys->private_data;
}

The above function is used to extract the correct private data from the system
data passed in as parameter and it returns an instance of the oxnas_pcie
structure.

static inline void *
oxnas_to_sysdata(struct oxnas_pcie




NEXT




<s> rtk_api_ret_t rtk_dot1x_portBasedAuthStatus_set(rtk_port_t port, rtk_dot1x_auth_status_t port_auth)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if (port_auth >= AUTH_STATUS_END)
return RT_ERR_DOT1X_PORTBASEDAUTH;

if ((retVal = rtl8367c_setAsic1xPBAuthConfig(rtk_switch_port_L2P_get(port), port_auth)) != RT_ERR_OK)
return retVal;


return RT_ERR_OK;
}

The above function is used to set the port based dot1x auth status.
In case of the port, you can choose the auth status.
Possible values are :
#define AUTH_STATUS_ENABLE   0   /* Forged MAC is not allowed.




NEXT




<s> static int rb4xx_ooblayout_ecc(struct mtd_info *mtd, int section,
struct mtd_oob_region *oobregion)
{
switch (section) {
case 0:
oobregion->offset = 8;
oobregion->length = 3;
return 0;
case 1:
oobregion->offset = 13;
oobregion->length = 3;
return 0;
default:
return -ERANGE;
}
}

The above function is used to select the ecc size and offset for readback.

The ecc_correct function is:

static void __mtd_ooblayout_ecc_correct(struct mtd_info *mtd, int section,
char




NEXT




<s> static int ecb_arc4_encrypt(struct skcipher_request *req)
{
struct arc4_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
unsigned int nbytes;
int err;

DPRINTF(1, "\n");
err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = walk.nbytes)) {
_deu_arc4_ecb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
NULL, nbytes, CRYPTO_DIR_ENCRYPT, 0);
nbytes &= ARC4_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

return err;
}

The above function is used to encrypt ARC4 with the ECB block mode.</s>




NEXT




<s> rtl_get_vlan(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
val->value.i = rtl_get(dev, RTL_REG_VLAN_ENABLE);
return 0;
}

The above function is used to set and retrieve the value of the register that enables/disables VLANs.

The rtl_set_vlan(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)




NEXT




<s> static int sata_oxnas_scr_write(struct ata_link *link, unsigned int sc_reg,
u32 val)
{
return sata_oxnas_scr_write_port(link->ap, sc_reg, val);
}

The above function is used to set SATA_SCR. Somewhere in the code of the driver
is present the sata_oxnas_scr_write_port function.

I am trying to see if I can set the SATA_SCR using




NEXT




<s> int rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
{
if (smi->ext_mbus)
return __rtl8366_mdio_read_reg(smi, addr, data);
else
return __rtl8366_smi_read_reg(smi, addr, data);
}

The above function is used to read the data from the register of the PHY through the 0xA4 MDIO register write.
The driver then uses the get_data function to copy the data to the MII data structure.
This is because MDI/M




NEXT




<s> ret_t rtl8367c_setAsicPortMirrorIsolationTxLeaky(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_TX_ISOLATION_LEAKY_OFFSET, enabled);
}

The above function is used to enable transmit leaky/permeable function in port mirror.

It’s not enabled by default. If enabled, all the traffic from the selected port will go through the mirror port. And the mirror port will receive all the traffic from




NEXT




<s> static u64 rtl838x_l2_hash_seed(u64 mac, u32 vid)
{
return mac << 12 | vid;
}

The above function is used to calculate the seed of the hash table. The mac address (6 bytes) and the vlan id (2 bytes) are concatenated to form L2 hash table seed.

First of all, why does a hash algorithm need seed?




NEXT




<s> static void b53_set_vlan_entry(struct b53_device *dev, u16 vid, u16 members,
u16 untag)
{
if (is5325(dev)) {
u32 entry = 0;

if (members) {
entry = ((untag & VA_UNTAG_MASK_25) << VA_UNTAG_S_25) |
members;
if (dev->core_rev >= 3)
entry |= VA_VALID_25_R4 | vid << VA_VID_HIGH_S;
else
entry |= VA_VALID_25;
}

b53_write32(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_25, entry);
b53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, vid |
VTA_RW_STATE_WR | VTA_RW_OP_EN);
} else if (is5365(dev)) {
u16 entry = 0;

if (members)
entry = ((untag & VA_UNTAG_MASK_65) << VA_UNTAG_S_65) |
members | VA_VALID_65;

b53_write16(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_65, entry);
b53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_65, vid |
VTA_RW_STATE_WR | VTA_RW_OP_EN);
} else {
b53_write16(dev, B53_ARLIO_PAGE, dev->vta_regs[1], vid);
b53_write32(dev, B53_ARLIO_PAGE, dev->vta_regs[2],
(untag << VTE_UNTAG_S) | members);

b53_do_vlan_op(dev, VTA_CMD_WRITE);
}
}

The above function is used to program the VLAN tagging entry with the VLAN
ID and untagged port/VLAN-ID pair in CSRs.

The function is first called from drivers/staging/bcm/b53_core




NEXT




<s> int AT91F_MCI_SetBlocklength(AT91PS_MciDevice pMCI_Device,unsigned int length)
{
return( AT91F_MCI_SendCommand(pMCI_Device, AT91C_SET_BLOCKLEN_CMD, length) );
}

The above function is used to set the blocklength to be used by the memory chip.

Question: In the AT91F256C_MCI_Init function in File: AT91/AT91_MCI_Flash.c




NEXT




<s> static void hostapd_ubus_notify_bss_transition_add_candidate_list(
const u8 *candidate_list, u16 candidate_list_len)
{
char *cl_str;
int i;

if (candidate_list_len == 0)
return;

cl_str = blobmsg_alloc_string_buffer(&b, "candidate-list", candidate_list_len * 2 + 1);
for (i = 0; i < candidate_list_len; i++)
snprintf(&cl_str[i*2], 3, "%02X", candidate_list[i]);
blobmsg_add_string_buffer(&b);

}

The above function is used to construct a blob message from a BSS transition candidate list. It can be used to construct the following blob message:

{
"id": 6,
"type": "hostapd",
"method": "get",





NEXT




<s> int item_activate_selected(void)
{
item_foreach()
if (item_is_selected())
return 1;
return 0;
}

The above function is used to determine if any one of the items is selected or not.

But what you are asking is how to change an item's state from one state to another directly (i.e. from the "not selected" state to the "selected




NEXT




<s> static int sha1_init1(struct shash_desc *desc)
{
struct sha1_ctx *sctx = shash_desc_ctx(desc);

sctx->started = 0;
sctx->count = 0;
return 0;
}

The above function is used to initialize the 1st iteration of SHA-1.

The function first sets the value of sctx->started to 0. This marks that the 1st iteration has not yet started. Next, it sets the value of s




NEXT




<s> static int rtl83xx_fib6_add(struct rtl838x_switch_priv *priv,
struct fib6_entry_notifier_info *info)
{
pr_debug("In %s\n", __func__);
/*	nh->fib_nh_flags |= RTNH_F_OFFLOAD; */

return 0;
}

The above function is used to install fib6 route which we did not do in
earlier versions but now we install the fib6 route through this function.

The error message is still happening because of this function.

We have to remove the RTNH




NEXT




<s> void rtk_hal_vlan_portpvid_set(rtk_port_t port, rtk_vlan_t pvid, rtk_pri_t priority)
{
rtk_vlan_portPvid_set(port, pvid, priority);
}

The above function is used to set pvid and pvid set by rtk_port_t.

For example, to assign vlan 101 with a priority of 8 on port 7(RTK_PORT_7), use the following command




NEXT




<s> static void rtl930x_stp_get(struct rtl838x_switch_priv *priv, u16 msti, u32 port_state[])
{
u32 cmd = 1 << 17 | /* Execute cmd */
0 << 16 | /* Read */
4 << 12 | /* Table type 0b10 */
(msti & 0xfff);
priv->r->exec_tbl0_cmd(cmd);

for (int i = 0; i < 2; i++)
port_state[i] = sw_r32(RTL930X_TBL_ACCESS_DATA_0(i));
pr_debug("MSTI: %d STATE: %08x, %08x\n", msti, port_state[0], port_state[1]);
}

The above function is used to read STATE register in table 0 which is a control register for spanning tree port state. But, this function does not use any wait time for checking. I am getting STATE=3,3 and I don't know whether is




NEXT




<s> static int b53_vlan_get_ports(struct switch_dev *dev, struct switch_val *val)
{
struct b53_device *priv = sw_to_b53(dev);
struct switch_port *port = &val->value.ports[0];
struct b53_vlan *vlan = &priv->vlans[val->port_vlan];
int i;

val->len = 0;

if (!vlan->members)
return 0;

for (i = 0; i < dev->ports; i++) {
if (!(vlan->members & BIT(i)))
continue;


if (!(vlan->untag & BIT(i)))
port->flags = BIT(SWITCH_PORT_FLAG_TAGGED);
else
port->flags = 0;

port->id = i;
val->len++;
port++;
}

return 0;
}

The above function is used to retrieve a list of ports associated
with that VLAN on the switch.</s>




NEXT




<s> static void get_prompt_str(struct gstr *r, struct property *prop,
struct list_head *head)
{
int i, j;
struct menu *submenu[8], *menu, *location = NULL;
struct jump_key *jump = NULL;

str_printf(r, "  Prompt: %s\n", prop->text);

get_dep_str(r, prop->menu->dep, "  Depends on: ");
/*
* Most prompts in Linux have visibility that exactly matches their
* dependencies. For these, we print only the dependencies to improve
* readability. However, prompts with inline "if" expressions and
* prompts with a parent that has a "visible if" expression have
* differing dependencies and visibility. In these rare cases, we
* print both.
*/
if (!expr_eq(prop->menu->dep, prop->visible.expr))
get_dep_str(r, prop->visible.expr, "  Visible if: ");

menu = prop->menu->parent;
for (i = 0; menu != &rootmenu && i < 8; menu = menu->parent) {
bool accessible = menu_is_visible(menu);

submenu[i++] = menu;
if (location == NULL && accessible)
location = menu;
}
if (head && location) {
jump = xmalloc(sizeof(struct jump_key));

if (menu_is_visible(prop->menu)) {
/*
* There is not enough room to put the hint at the
* beginning of the "Prompt" line. Put the hint on the
* last "Location" line even when it would belong on
* the former.
*/
jump->target = prop->menu;
} else
jump->target = location;

if (list_empty(head))
jump->index = 0;
else
jump->index = list_entry(head->prev, struct jump_key,
entries)->index + 1;

list_add_tail(&jump->entries, head);
}

if (i > 0) {
str_printf(r, "  Location:\n");
for (j = 4; --i >= 0; j += 2) {
menu = submenu[i];
if (jump && menu == location)
jump->offset = strlen(r->s);
str_printf(r, "%*c-> %s", j, ' ',
menu_get_prompt(menu));
if (menu->sym) {
str_printf(r, " (%s [=%s])", menu->sym->name ?
menu->sym->name : "<choice>",
sym_get_string_value(menu->sym));
}
str_append(r, "\n");
}
}
}

The above function is used to print some details about a property on the
console. This info is primarily meant to be read by developers.
It includes:

* the name of the property
* dependencies
* its visibility
* location
* the list of menu




NEXT




<s> static int rtl8367_extif_set_rgmii_delay(struct rtl8366_smi *smi, int id,
unsigned txdelay, unsigned rxdelay)
{
u32 mask;
u32 val;
int err;

mask = (RTL8367_EXT_RGMXF_RXDELAY_MASK |
(RTL8367_EXT_RGMXF_TXDELAY_MASK <<
RTL8367_EXT_RGMXF_TXDELAY_SHIFT));

val = rxdelay;
val |= txdelay << RTL8367_EXT_RGMXF_TXDELAY_SHIFT;

REG_RMW(smi, RTL8367_EXT_RGMXF_REG(id), mask, val);

return 0;
}

The above function is used to configure the TX & RX delays for a given GPHY.
The function assumes that the rtl8366_smi struct points to a valid rtl8366
device and that the id is a valid G




NEXT




<s> static int usage(void)
{
fprintf(stderr,
"Usage: %s file [<options>] [pad0] [pad1] [padN]\n"
"Options:\n"
"  -x <offset>:          Add an extra offset for padding data\n"
"  -J:                   Use a fake big-endian jffs2 padding element instead of EOF\n"
"                        This is used to work around broken boot loaders that\n"
"                        try to parse the entire firmware area as one big jffs2\n"
"  -j:                   (like -J, but little-endian instead of big-endian)\n"
"  -c:                   write padding to stdout\n"
"\n",
progname);
return EXIT_FAILURE;
}

The above function is used to check the correctness of the command line arguments. However, in this case, we've made a small (but important) mistake. The correct function is as follows.

static int usage(void)
{
fprintf(stderr,




NEXT




<s> handle_none(void)
{
return true;
}

The above function is used to get the error for the 'none' parameter in the
function `handle_err' (located in `tput.c'). Currently that error is printed and
the error is returned to the executable (or the calling script); in




NEXT




<s> void RangeDecoderInit(CRangeDecoder *rd,
#ifdef _LZMA_IN_CB
ILzmaInCallback *inCallback
#else
Byte *stream, UInt32 bufferSize
#endif
)
{
int i;
#ifdef _LZMA_IN_CB
rd->InCallback = inCallback;
rd->Buffer = rd->BufferLim = 0;
#else
rd->Buffer = stream;
rd->BufferLim = stream + bufferSize;
#endif
rd->ExtraBytes = 0;
rd->Code = 0;
rd->Range = (0xFFFFFFFF);
for(i = 0; i < 5; i++)
rd->Code = (rd->Code << 8) | ReadByte;
}

The above function is used to initilize CRangeDecoder and it has a local function 'ReadByte' which reads the byte, in my case the program is not getting the input bytes. so while coding i changed it to 'GetByte' , it's a custom




NEXT




<s> void fe_reg_w32(u32 val, enum fe_reg reg)
{
fe_w32(val, fe_reg_table[reg]);
}

The above function is used to write from the FPGA onto any of the 5 available registers using the function pointers that have been generated in stage 2. Stage 2 is discussed later in the report and the registers are listed below.

REGISTERS:




NEXT




<s> static void esw_set_vlan_id(struct rt305x_esw *esw, unsigned vlan, unsigned vid)
{
unsigned s;

s = RT305X_ESW_VLANI_VID_S * (vlan % 2);
esw_rmw(esw,
RT305X_ESW_REG_VLANI(vlan / 2),
RT305X_ESW_VLANI_VID_M << s,
(vid & RT305X_ESW_VLANI_VID_M) << s);
}

The above function is used to set vlan id from 0 to 39. In fact, it is not used since in rt305x_init_esw we directly set the VLAN_STP reg by:

esw_wr(




NEXT




<s> static void sata_oxnas_error_handler(struct ata_port *ap)
{
DPRINTK("Enter port_no %d\n", ap->port_no);
sata_oxnas_freeze_host(ap);

/* If the core is busy here, make it idle */
sata_oxnas_cleanup(ap->host);

ata_std_error_handler(ap);

sata_oxnas_thaw_host(ap);
}

The above function is used to signal an error to the hostcontroller. At the moment it only stops the core (in case it’s running) by the function sata_oxnas_freeze_host

sata_oxnas_thaw_host is




NEXT




<s> ar8216_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
{
return __ar8216_setup_port(priv, port, members,
chip_is_ar8216(priv) && priv->vlan &&
port == AR8216_PORT_CPU);
}

The above function is used to setup the hardware in ar8216. It is defined in _ar8216_setup_port() as we have seen below.

void ar8_write_ar8216_port(struct ar8




NEXT




<s> extern int rtl930x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl930x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl931x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl931x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl930x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl930x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);
extern int rtl931x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl931x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);

/* On the RTL93XX, the RTL93XX_DMA_IF_RX_RING_CNTR track the fill level of
* the rings. Writing x into these registers substracts x from its content.
* When the content reaches the ring size, the ASIC no longer adds
* packets to this receive queue.
*/
void rtl838x_update_cntr(int r, int released)
{
/* This feature is not available on RTL838x SoCs */
}

The above function is used to update the receive ring descriptors in the ASIC.

void RTL930X_SetBitrate(int dev_id, int phy_id, u32 data);

The function to set the speed mode




NEXT




<s> static int ar934x_nfc_hw_reset_assert(struct ar934x_nfc *nfc)
{
int err;

err = reset_control_assert(nfc->rst);
udelay(250);
return err;
}

The above function is used to assert a hardware reset for Ar934x
chipset.

The function, reset_control_assert takes one input parameter reset
device.
The function uses reset_control_assert to assert a reset for Ar934




NEXT




<s> static ssize_t rtl838x_common_read(char __user *buffer, size_t count,
loff_t *ppos, unsigned int value)
{
char *buf;
ssize_t len;

if (*ppos != 0)
return 0;

buf = kasprintf(GFP_KERNEL, "0x%08x\n", value);
if (!buf)
return -ENOMEM;

if (count < strlen(buf)) {
kfree(buf);
return -ENOSPC;
}

len = simple_read_from_buffer(buffer, count, ppos, buf, strlen(buf));
kfree(buf);

return len;
}

The above function is used to read the value of a particular register in
the RTL838x series of NICs. It takes as input a user buffer to store the
data and the current position (in bytes) of the buffer.

This function




NEXT




<s> struct expr *expr_eliminate_dups(struct expr *e)
{
int oldcount;
if (!e)
return e;

oldcount = trans_count;
while (1) {
trans_count = 0;
switch (e->type) {
case E_OR: case E_AND:
expr_eliminate_dups1(e->type, &e, &e);
default:
;
}
if (!trans_count)
/* No simplifications done in this pass. We're done */
break;
e = expr_eliminate_yn(e);
}
trans_count = oldcount;
return e;
}

The above function is used to eliminate duplicates in the
expression tree by traversing it.</s>




NEXT




<s> void rtk_hal_del_table(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;
rtk_l2_ucastAddr_t l2_entry;
rtk_mac_t mac;

mac.octet[0] =data->mac[0];
mac.octet[1] =data->mac[1];
mac.octet[2] =data->mac[2];
mac.octet[3] =data->mac[3];
mac.octet[4] =data->mac[4];
mac.octet[5] =data->mac[5];

memset(&l2_entry, 0x00, sizeof(rtk_l2_ucastAddr_t));
l2_entry.port = data->port;
l2_entry.ivl = 1;
l2_entry.cvid = data->vid;
l2_entry.fid = 0;
l2_entry.efid = 0;
ret = rtk_l2_addr_del(&mac, &l2_entry);
if (ret != RT_ERR_OK)
printk("rtk_hal_add_table failed\n");
}

The above function is used to delet an L2 Entry from the Routing table based on the arguments the user sends to the module.  The function takes in the address of the ioctl struct which contains the user's arguments. It contains the MAC address to match based on




NEXT




<s> static int menu_validate_number(struct symbol *sym, struct symbol *sym2)
{
return sym2->type == S_INT || sym2->type == S_HEX ||
(sym2->type == S_UNKNOWN && sym_string_valid(sym, sym2->name));
}

The above function is used to validate the "n" field when reading
the SUMMER_START block. This checks whether the name field (and if the type
of SUMMER_START is S_UNKNOWN (a string name will be used)) and




NEXT




<s> rtk_api_ret_t rtk_port_phyComboPortMedia_get(rtk_port_t port, rtk_port_media_t *pMedia)
{
rtk_api_ret_t   retVal;
rtk_uint32      regData;
rtk_uint32      data;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

/* Check Combo Port ID */
RTK_CHK_PORT_IS_COMBO(port);

if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
return retVal;

if(regData != 0x6367)
{
*pMedia = PORT_MEDIA_COPPER;
}
else
{
if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_UTP_FIB_DET, RTL8367C_UTP_FIRST_OFFSET, &data))!=RT_ERR_OK)
return retVal;

if(data == 1)
*pMedia = PORT_MEDIA_COPPER;
else
*pMedia = PORT_MEDIA_FIBER;
}

return RT_ERR_OK;
}

The above function is used to get the copper/fiber selection on combo port.

The data bit 1 of RTL8367C_REG_UTP_FIB_DET is used to indicate that the fiber detect of this port is




NEXT




<s> static void fe_clean_tx(struct fe_priv *priv)
{
int i;
struct device *dev = priv->dev;
struct fe_tx_ring *ring = &priv->tx_ring;

if (ring->tx_buf) {
for (i = 0; i < ring->tx_ring_size; i++)
fe_txd_unmap(dev, &ring->tx_buf[i]);
kfree(ring->tx_buf);
ring->tx_buf = NULL;
}

if (ring->tx_dma) {
dma_free_coherent(dev,
ring->tx_ring_size * sizeof(*ring->tx_dma),
ring->tx_dma,
ring->tx_phys);
ring->tx_dma = NULL;
}

netdev_reset_queue(priv->netdev);
}

The above function is used to initialize the transmit ring before transferring frames to the PCIe device. At the end of transfer the corresponding ring is unregistered and freed.</s>




NEXT




<s> void expr_eliminate_eq(struct expr **ep1, struct expr **ep2)
{
if (!e1 || !e2)
return;
switch (e1->type) {
case E_OR:
case E_AND:
__expr_eliminate_eq(e1->type, ep1, ep2);
default:
;
}
if (e1->type != e2->type) switch (e2->type) {
case E_OR:
case E_AND:
__expr_eliminate_eq(e2->type, ep1, ep2);
default:
;
}
e1 = expr_eliminate_yn(e1);
e2 = expr_eliminate_yn(e2);
}

The above function is used to eliminate equs from either or both operands. This is used by
a similar function (expr_eliminate_eq) that is called once the parse expression tree is almost
ready. This is needed when there are operands (on




NEXT




<s> static inline int aca_start(struct dc_ep_dev *dev, u32 func, int start)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_aca_start(dev->priv, func, start);
}

The above function is used to start and stop ACA, but the DC ACA IP does not define the ACA_ENABLE register which is the normal place to put these registers. Instead, the ACA IP defines two registers that start and stop ACA:

The




NEXT




<s> static int msdc_ops_get_ro(struct mmc_host *mmc)
{
struct msdc_host *host = mmc_priv(mmc);
void __iomem *base = host->base;
unsigned long flags;
int ro = 0;

if (host->hw->flags & MSDC_WP_PIN_EN) { /* set for card */
spin_lock_irqsave(&host->lock, flags);
ro = (sdr_read32(MSDC_PS) >> 31);
spin_unlock_irqrestore(&host->lock, flags);
}
return ro;
}

The above function is used to read the read only bit from the host processor
register. It should return the value of read only bit as the read only bit
is set when SD card is inserted in the cardholder in the mobile
device.

The above function is




NEXT




<s> static int rtl9310_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)
{
struct rtl9300_mux *mux = i2c_mux_priv(muxc);

/* Set SCL pin */
REG_MASK(0, 0, BIT(RTL9310_I2C_MST_IF_SEL_GPIO_SCL_SEL + channels[chan].scl_num),
RTL9310_I2C_MST_IF_SEL);

/* Set SDA pin */
REG_MASK(channels[chan].scl_num, 0xf << RTL9310_I2C_CTRL_SDA_OUT_SEL,
channels[chan].sda_num << RTL9310_I2C_CTRL_SDA_OUT_SEL, RTL9310_I2C_CTRL);

mux->i2c->sda_num = channels[chan].sda_num;
mux->i2c->scl_num = channels[chan].scl_num;

return 0;
}

The above function is used to select the pins connected to the SD and SCL channels.</s>




NEXT




<s> static inline void ar934x_nfc_wr(struct ar934x_nfc *nfc, unsigned reg, u32 val)
{
__raw_writel(val, nfc->base + reg);
}

The above function is used to set the value of a particular register. In this particular case the __raw_writel function is not part of any header file but the _writel() family of functions. The __raw_writel() macro is defined in the asm




NEXT




<s> static int b53_spi_read8(struct b53_device *dev, u8 page, u8 reg, u8 *val)
{
return b53_spi_read(dev, page, reg, val, 1);
}

The above function is used to get the reg_val of a register
The function signature is:

static int b53_spi_read8(struct b53_device *, u8, u8, u8 *);
The first parameter is the




NEXT




<s> rtk_api_ret_t rtk_dot1x_eapolFrame2CpuEnable_get(rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicRma(3, &rmacfg)) != RT_ERR_OK)
return retVal;

if (RMAOP_TRAP_TO_CPU == rmacfg.operation)
*pEnable = ENABLED;
else
*pEnable = DISABLED;

return RT_ERR_OK;
}

The above function is used to set EAPOL frame to CPU.

The function is to set the type of the interface on which it sends the EAPOL frames to be CPU.

If RMA is enabled on this field, then the value is taken from




NEXT




<s> static int rtl8366s_sw_set_blinkrate(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

if (val->value.i >= 6)
return -EINVAL;

return rtl8366_smi_rmwr(smi, RTL8366S_LED_BLINKRATE_REG,
RTL8366S_LED_BLINKRATE_MASK,
val->value.i);
}

The above function is used to set blink rate of LED of specific port.
Here we are trying to change this value to 1 i.e 500ms.</s>




NEXT




<s> rtk_api_ret_t rtk_qos_1pPriRemap_set(rtk_pri_t dot1p_pri, rtk_pri_t int_pri)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (dot1p_pri > RTL8367C_PRIMAX || int_pri > RTL8367C_PRIMAX)
return  RT_ERR_VLAN_PRIORITY;

if ((retVal = rtl8367c_setAsicPriorityDot1qRemapping(dot1p_pri, int_pri)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the dot1P priority and internal priority.</s>




NEXT




<s> int mtd_get_squashfs_len(struct mtd_info *master,
size_t offset,
size_t *squashfs_len)
{
struct squashfs_super_block sb;
size_t retlen;
int err;

err = mtd_read(master, offset, sizeof(sb), &retlen, (void *)&sb);
if (err || (retlen != sizeof(sb))) {
pr_alert("error occured while reading from \"%s\"\n",
master->name);
return -EIO;
}

if (le32_to_cpu(sb.s_magic) != SQUASHFS_MAGIC) {
pr_alert("no squashfs found in \"%s\"\n", master->name);
return -EINVAL;
}

retlen = le64_to_cpu(sb.bytes_used);
if (retlen <= 0) {
pr_alert("squashfs is empty in \"%s\"\n", master->name);
return -ENODEV;
}

if (offset + retlen > master->size) {
pr_alert("squashfs has invalid size in \"%s\"\n",
master->name);
return -EINVAL;
}

*squashfs_len = retlen;
return 0;
}

The above function is used to determine the compressed raw size of SquashFS.</s>




NEXT




<s> static int rtl8393_read_status(struct phy_device *phydev)
{
int offset = 0;
int err;
int phy_addr = phydev->mdio.addr;
u32 v;

err = genphy_read_status(phydev);
if (phy_addr == 49)
offset = 0x100;

if (phydev->link) {
phydev->speed = SPEED_100;
/* Read SPD_RD_00 (bit 13) and SPD_RD_01 (bit 6) out of the internal
* PHY registers
*/
v = sw_r32(RTL839X_SDS12_13_XSG0 + offset + 0x80);
if (!(v & (1 << 13)) && (v & (1 << 6)))
phydev->speed = SPEED_1000;
phydev->duplex = DUPLEX_FULL;
}

return err;
}

The above function is used to read the speed & duplex settings when the phy is being probed.

Problem:
When the phy isn't being probed by a management phy, this function reads a speed of half duplex 10




NEXT




<s> struct table_reg *rtl_table_get(rtl838x_tbl_reg_t r, int t)
{
if (r >= RTL_TBL_END)
return NULL;

if (t >= BIT(rtl838x_tbl_regs[r].c_bit-rtl838x_tbl_regs[r].t_bit))
return NULL;

mutex_lock(&rtl838x_tbl_regs[r].lock);
rtl838x_tbl_regs[r].tbl = t;

return &rtl838x_tbl_regs[r];
}

The above function is used to set the table of RTL8380. If you want to write
anything into this table, you should call this function to set the table you want
this time. There are several different tables in the driver with corresponding
values




NEXT




<s> static long long sym_get_range_val(struct symbol *sym, int base)
{
sym_calc_value(sym);
switch (sym->type) {
case S_INT:
base = 10;
break;
case S_HEX:
base = 16;
break;
default:
break;
}
return strtoll(sym->curr.val, NULL, base);
}

The above function is used to get the value of a symbol

The actual code for the loop is located at

https://github.com/tjko/binutils/blob/8a31f94/ld/output.c#L4




NEXT




<s> int open_backend(const struct iwinfo_ops **iw, const char *ifname)
{
*iw = iwinfo_backend(ifname);

if (!(*iw))
return 1;

return 0;
}

The above function is used to initialise and open the backend information
system. The iwinfo_backend returns a handle to a backend information
system.

The backend information system has a limited number of information
types and the application is required to select a set of




NEXT




<s> rtk_api_ret_t rtk_leaky_vlan_set(rtk_leaky_type_t type, rtk_enable_t enable)
{
rtk_api_ret_t retVal;
rtk_uint32 port;
rtl8367c_rma_t rmacfg;
rtk_uint32 tmp;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= LEAKY_END)
return RT_ERR_INPUT;

if (enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if (type >= 0 && type <= LEAKY_UNDEF_GARP_2F)
{
if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.vlan_leaky = enable;

if ((retVal = rtl8367c_setAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (LEAKY_IPMULTICAST == type)
{
for (port = 0; port <= RTK_PORT_ID_MAX; port++)
{
if ((retVal = rtl8367c_setAsicIpMulticastVlanLeaky(port,enable)) != RT_ERR_OK)
return retVal;
}
}
else if (LEAKY_IGMP == type)
{
if ((retVal = rtl8367c_setAsicIGMPVLANLeaky(enable)) != RT_ERR_OK)
return retVal;
}
else if (LEAKY_CDP == type)
{
if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.vlan_leaky = enable;

if ((retVal = rtl8367c_setAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (LEAKY_CSSTP == type)
{
if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.vlan_leaky = enable;

if ((retVal = rtl8367c_setAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (LEAKY_LLDP == type)
{
if ((retVal = rtl8367c_getAsicRmaLldp(&tmp,&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.vlan_leaky = enable;

if ((retVal = rtl8367c_setAsicRmaLldp(tmp, &rmacfg)) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set the leak VLAN of switch.

rtk_api_ret_t rtk_leaky_vlan_get(rtk_leaky_type_t type, rtk_enable_t *enable)





NEXT




<s> static int rtl8366rb_sw_get_blinkrate(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366RB_LED_BLINKRATE_REG, &data);

val->value.i = (data & (RTL8366RB_LED_BLINKRATE_MASK));

return 0;
}

The above function is used to retrieve the current blink rate.
Now the following code is where I'm getting an error. It seems I should be sending the output of rtl8366rb_sw_get_blinkrate to
rtl83




NEXT




<s> static int wlc_radio(wlc_param param, void *data, void *value)
{
int *val = (int *) value;
int ret;

if ((param & PARAM_MODE) == GET) {
ret = wl_ioctl(interface, WLC_GET_RADIO, val, sizeof(int));
*val = ((*val & 1) ? 0 : 1);
} else {
*val = (1 << 16) | (*val ? 0 : 1);
ret = wl_ioctl(interface, WLC_SET_RADIO, val, sizeof(int));
}

return ret;
}

The above function is used to get or set the WLAN's device radio.

When the radio option is set, the driver will send the WLAN radio channel and set up the channel.

The driver should not send any request to set network mode to host




NEXT




<s> void rtl838x_setup_prio2queue_matrix(int *min_queues)
{
u32 v = 0;

pr_info("Current Intprio2queue setting: %08x\n", sw_r32(RTL838X_QM_INTPRI2QID_CTRL));
for (int i = 0; i < MAX_PRIOS; i++)
v |= i << (min_queues[i] * 3);
sw_w32(v, RTL838X_QM_INTPRI2QID_CTRL);
}

The above function is used to write to the RTL838X_QM_INTPRI2QID_CTRL register and the
function is called within the rtl838x_init_qos function. For the most part, as indicated above




NEXT




<s> static int zyxel_bootconfig_write(struct zyxel_bootconfig *config, struct zyxel_bootconfig_mtd *mtd)
{
struct erase_info_user erase_info;
char img_status, img_active;
char *args = NULL;
int ret = 0;

/* Allocate memory for reading boot-config partition */
args = calloc(1, mtd->mtd_info.erasesize);
if (!args) {
fprintf(stderr, "Could not allocate memory!\n");
ret = -1;
goto out;
}

/* Read bootconfig partition */
pread(mtd->fd, args, mtd->mtd_info.erasesize, 0);

img_status = IMAGE_STATUS(config->image0_status, config->image1_status);
img_active = ACTIVE_IMAGE(config->active_image);

/* Check if bootconfig has to be written */
if (args[BOOTCONFIG_IMAGE_STATUS] == img_status && args[BOOTCONFIG_ACTIVE_IMAGE] == img_active) {
ret = 0;
goto out;
}

/* Erase first block (containing the magic) */
erase_info.start = 0;
erase_info.length = mtd->mtd_info.erasesize;
ret = ioctl(mtd->fd, MEMERASE, &erase_info);
if (ret < 0) {
fprintf(stderr, "Failed to erase block: %i\n", ret);
goto out;
}


/* Write bootconfig */
args[BOOTCONFIG_IMAGE_STATUS] = img_status;
args[BOOTCONFIG_ACTIVE_IMAGE] = img_active;

if (pwrite(mtd->fd, args, mtd->mtd_info.erasesize, 0) != mtd->mtd_info.erasesize) {
fprintf(stderr, "Error writing bootconfig!\n");
ret = -1;
goto out;
}

out:
if (args)
free(args);
return ret;
}

The above function is used to write a value into the first block of the bootconfig partition of the device specified in zyxel_bootconfig_mtd structure. This structure describes the device used to program bootloader into NVRAM on Zyxel devices.




NEXT




<s> rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_delAll(rtk_port_t port)
{
rtk_api_ret_t retVal;
rtk_uint32 i, j, bUsed[4];
rtl8367c_protocolgdatacfg ppb_data_cfg;
rtl8367c_protocolvlancfg ppb_vlan_cfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

for (i = 0; i<= RTL8367C_PROTOVLAN_GIDX_MAX; i++)
{
ppb_vlan_cfg.valid = FALSE;
ppb_vlan_cfg.vlan_idx = 0;
ppb_vlan_cfg.priority = 0;
if ((retVal = rtl8367c_setAsicVlanPortAndProtocolBased(rtk_switch_port_L2P_get(port), i, &ppb_vlan_cfg)) != RT_ERR_OK)
return retVal;
}

bUsed[0] = FALSE;
bUsed[1] = FALSE;
bUsed[2] = FALSE;
bUsed[3] = FALSE;
RTK_SCAN_ALL_PHY_PORTMASK(i)
{
for (j = 0; j <= RTL8367C_PROTOVLAN_GIDX_MAX; j++)
{
if ((retVal = rtl8367c_getAsicVlanPortAndProtocolBased(i,j, &ppb_vlan_cfg)) != RT_ERR_OK)
return retVal;

if (TRUE == ppb_vlan_cfg.valid)
{
bUsed[j] = TRUE;
}
}
}

for (i = 0; i<= RTL8367C_PROTOVLAN_GIDX_MAX; i++)
{
if (FALSE == bUsed[i]) /*No Port use this PPB Index, Delete it*/
{
ppb_data_cfg.etherType=0;
ppb_data_cfg.frameType=0;
if ((retVal = rtl8367c_setAsicVlanProtocolBasedGroupData(i, &ppb_data_cfg)) != RT_ERR_OK)
return retVal;
}
}



return RT_ERR_OK;
}

The above function is used to delete All protocol vlan based on port.It is not used frequently.</s>




NEXT




<s> void rtcl_ccu_log_early(void)
{
char meminfo[80], clkinfo[255], msg[255] = "rtl83xx-clk: initialized";

sprintf(meminfo, " (%d Bit DDR%d)", rtcl_ccu->dram.buswidth, rtcl_ccu->dram.type);
for (int clk_idx = 0; clk_idx < CLK_COUNT; clk_idx++) {
sprintf(clkinfo, ", %s %lu MHz", rtcl_clk_info[clk_idx].display_name,
rtcl_ccu->clks[clk_idx].startup / 1000000);
if (clk_idx == CLK_MEM)
strcat(clkinfo, meminfo);
strcat(msg, clkinfo);
}
pr_info("%s\n", msg);
}

The above function is used to print the status of CCU_CLKS register after CCU has been initialized. It gets invoked only once.
In case of the SIPI board, the DDR3 chip is not being seen by BIOS and hence CCU




NEXT




<s> t_initrand();

if(size <= 0)         /* t_random(NULL, 0) forces seed initialization */
return;

while(size > outpos) {
if(outpos > 0) {
memcpy(data, randout + (sizeof(randout) - outpos), outpos);
data += outpos;
size -= outpos;
}

/* Recycle */
SHA1Init(&randctxt);
SHA1Update(&randctxt, randpool, sizeof(randpool));
SHA1Final(randout, &randctxt);
SHA1Init(&randctxt);
SHA1Update(&randctxt, (unsigned char *) &randcnt, sizeof(randcnt));
SHA1Update(&randctxt, randpool, sizeof(randpool));
SHA1Final(randpool, &randctxt);
++randcnt;
outpos = sizeof(randout);
}

The above function is used to fill a user buffer using SHA-1 cryptography. The size of the user buffer is limited by the size of the out buffer and out can be NULL. The size of the SHA-1 cryptographic process is fixed. It is not possible to




NEXT




<s> static void rttm_start_timer(struct timer_of *to, u32 mode)
{
rttm_set_counter(to->of_base.base, 0);
rttm_enable_timer(to->of_base.base, mode, to->of_clk.rate / RTTM_TICKS_PER_SEC);
}

The above function is used to start the one shot timer. The actual implementation of it starts the timer when the user has called rttm_start() to start it. The same function is used for periodic timer. We have seen the implementation of this routine in detail in the




NEXT




<s> static bool qca807x_distance_valid(int result)
{
switch (result) {
case QCA807X_CDT_RESULTS_OPEN:
case QCA807X_CDT_RESULTS_SAME_SHORT:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI1_SAME_OK:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI2_SAME_OK:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI3_SAME_OK:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI1_SAME_OPEN:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI2_SAME_OPEN:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI3_SAME_OPEN:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI1_SAME_SHORT:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI2_SAME_SHORT:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI3_SAME_SHORT:
return true;
}
return false;
}

The above function is used to check the validity of the results of a certain test.

The QCA807x chip that is used in the HP Stream x360 is capable of detecting the 6 different states of the DIMM slots.




NEXT




<s> ret_t rtl8367c_setAsicLedForceBlinkRate(rtk_uint32 blinkRate)
{
if(blinkRate >= LEDFORCERATE_END)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBits(RTL8367C_REG_LED_MODE, RTL8367C_FORCE_RATE_MASK, blinkRate);
}

The above function is used to set blinking rate of led force blink.
In this case, it will set the corresponding register bit:
LEDMODE [LED_FORCE_RATE]

Its bit pattern defined as RT_LED_FORCE_BLINK




NEXT




<s> mt7530_write_vlan_entry(struct mt7530_priv *priv, int vlan, u16 vid,
u8 ports, u8 etags)
{
int port;
u32 val;

/* vid of vlan */
val = mt7530_r32(priv, REG_ESW_VLAN_VTIM(vlan));
if (vlan % 2 == 0) {
val &= 0xfff000;
val |= vid;
} else {
val &= 0xfff;
val |= (vid << 12);
}
mt7530_w32(priv, REG_ESW_VLAN_VTIM(vlan), val);

/* vlan port membership */
if (ports)
mt7530_w32(priv, REG_ESW_VLAN_VAWD1, REG_ESW_VLAN_VAWD1_IVL_MAC |
REG_ESW_VLAN_VAWD1_VTAG_EN | (ports << 16) |
REG_ESW_VLAN_VAWD1_VALID);
else
mt7530_w32(priv, REG_ESW_VLAN_VAWD1, 0);

/* egress mode */
val = 0;
for (port = 0; port < MT7530_NUM_PORTS; port++) {
if (etags & BIT(port))
val |= ETAG_CTRL_TAG << (port * 2);
else
val |= ETAG_CTRL_UNTAG << (port * 2);
}
mt7530_w32(priv, REG_ESW_VLAN_VAWD2, val);

/* write to vlan table */
mt7530_vtcr(priv, 1, vlan);
}

The above function is used to write vlan entries and vids into the vlan table of mt7530 switch chip. Please refer to vlan operations of cpsw_priv structure in mt7530_cpsw.c.</s>




NEXT




<s> swconfig_led_work_func(struct work_struct *work)
{
struct switch_led_trigger *sw_trig;
struct switch_dev *swdev;
u32 port_mask;
u32 link;
int i;

sw_trig = container_of(work, struct switch_led_trigger,
sw_led_work.work);

port_mask = sw_trig->port_mask;
swdev = sw_trig->swdev;

link = 0;
for (i = 0; i < SWCONFIG_LED_NUM_PORTS; i++) {
u32 port_bit;

sw_trig->link_speed[i] = 0;

port_bit = BIT(i);
if ((port_mask & port_bit) == 0)
continue;

if (swdev->ops->get_port_link) {
struct switch_port_link port_link;

memset(&port_link, '\0', sizeof(port_link));
swdev->ops->get_port_link(swdev, i, &port_link);

if (port_link.link) {
link |= port_bit;
switch (port_link.speed) {
case SWITCH_PORT_SPEED_UNKNOWN:
sw_trig->link_speed[i] =
SWCONFIG_LED_PORT_SPEED_NA;
break;
case SWITCH_PORT_SPEED_10:
sw_trig->link_speed[i] =
SWCONFIG_LED_PORT_SPEED_10;
break;
case SWITCH_PORT_SPEED_100:
sw_trig->link_speed[i] =
SWCONFIG_LED_PORT_SPEED_100;
break;
case SWITCH_PORT_SPEED_1000:
sw_trig->link_speed[i] =
SWCONFIG_LED_PORT_SPEED_1000;
break;
}
}
}

if (swdev->ops->get_port_stats) {
struct switch_port_stats port_stats;

memset(&port_stats, '\0', sizeof(port_stats));
swdev->ops->get_port_stats(swdev, i, &port_stats);
sw_trig->port_tx_traffic[i] = port_stats.tx_bytes;
sw_trig->port_rx_traffic[i] = port_stats.rx_bytes;
}
}

sw_trig->port_link = link;

swconfig_trig_update_leds(sw_trig);

schedule_delayed_work(&sw_trig->sw_led_work,
SWCONFIG_LED_TIMER_INTERVAL);
}

The above function is used to initialize all the LEDs on the network switch. Here, each LED is initialized as off when the network switch is started. This will ensure that all the LEDs are off when the switch is started. In the beginning, when there is no network




NEXT




<s> static int msdc_drv_remove(struct platform_device *pdev)
{
struct mmc_host *mmc;
struct msdc_host *host;

mmc  = platform_get_drvdata(pdev);
BUG_ON(!mmc);

host = mmc_priv(mmc);
BUG_ON(!host);

ERR_MSG("removed !!!");

platform_set_drvdata(pdev, NULL);
mmc_remove_host(host->mmc);
msdc_deinit_hw(host);

cancel_delayed_work_sync(&host->card_delaywork);

dma_free_coherent(&pdev->dev, MAX_GPD_NUM * sizeof(struct gpd),
host->dma.gpd, host->dma.gpd_addr);
dma_free_coherent(&pdev->dev, MAX_BD_NUM  * sizeof(struct bd),
host->dma.bd,  host->dma.bd_addr);

mmc_free_host(host->mmc);

return 0;
}

The above function is used to remove the msdc device.
The main logic of removing the msdc controller chip from the board contains mainly dma memory free, hardware init. and host free, card delay work cancel, and host remove.</s>




NEXT




<s> static int lq_cbc_des_decrypt(struct ablkcipher_request *areq)
{
struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);
struct des_ctx *ctx = crypto_ablkcipher_ctx(cipher);

return lq_queue_mgr(ctx, areq, areq->info, CRYPTO_DIR_DECRYPT, 1);
}

The above function is used to decrypt data in chunks. A chunk includes one or more AES blocks and is prefixed by a header which indicates the length of the chunk and is followed by a data block.</s>




NEXT




<s> static int rtl8366rb_enable_vlan4k(struct rtl8366_smi *smi, int enable)
{
return rtl8366_smi_rmwr(smi, RTL8366RB_SGCR,
RTL8366RB_SGCR_EN_VLAN_4KTB,
(enable) ? RTL8366RB_SGCR_EN_VLAN_4KTB : 0);
}

The above function is used to enable/disable 16K
VLAN Tables and the return value indicates whether
the operation has succeeded. We shall use this
function in our rtl8366_add_vlanv function of the
83




NEXT




<s> void mtk_switch_w32(struct mt7620_gsw *gsw, u32 val, unsigned reg)
{
iowrite32(val, gsw->base + reg);
}

The above function is used to store a 32bit value to a 32bit register. In a system with different endianness, we need to determine the endianness and reverse the 32bit value in order to write it to a 32




NEXT




<s> const char *zconf_curname(void)
{
return current_pos.file ? current_pos.file->name : "<none>";
}

The above function is used to get the name of the current open file. This
function is useful when doing multiple file copy operations or any other
file processing using the Zconf language.

In addition to getting the file name in this function, you can also check the




NEXT




<s> extern void ifx_deu_aes (void *ctx_arg, uint8_t *out_arg, const uint8_t *in_arg,
uint8_t *iv_arg, size_t nbytes, int encdec, int mode);
/* End of function decleration */

struct aes_ctx {
int key_length;
u8 buf[AES_MAX_KEY_SIZE];
u8 tweakkey[AES_MAX_KEY_SIZE];
u8 nonce[CTR_RFC3686_NONCE_SIZE];
u8 lastbuffer[4 * XTS_BLOCK_SIZE];
int use_tweak;
u32 byte_count;
u32 dbn;
int started;
u32 (*temp)[AES_BLOCK_WORDS];
u8 block[AES_BLOCK_SIZE];
u8 hash[AES_BLOCK_SIZE];
struct gf128mul_4k *gf128;
};

The above function is used to write a C function that performs the AES
encryption and decryption operations on various memory objects that are
passed to it. The function takes four pointers as arguments. The first two
pointers should point to two memory areas that




NEXT




<s> static void sym_set_changed(struct symbol *sym)
{
struct property *prop;

sym->flags |= SYMBOL_CHANGED;
for (prop = sym->prop; prop; prop = prop->next) {
if (prop->menu)
prop->menu->flags |= MENU_CHANGED;
}
}

The above function is used to mark a symbol (or its property) as changed so that related functions trigger a GUI update when they need to.

The main problem with this function is that the only entity that knows that something has *actually* changed is, well




NEXT




<s> static void rtl83xx_route_rm(struct rtl838x_switch_priv *priv, struct rtl83xx_route *r)
{
int id;

if (rhltable_remove(&priv->routes, &r->linkage, route_ht_params))
dev_warn(priv->dev, "Could not remove route\n");

if (r->is_host_route) {
id = priv->r->find_l3_slot(r, false);
pr_debug("%s: Got id for host route: %d\n", __func__, id);
r->attr.valid = false;
priv->r->host_route_write(id, r);
clear_bit(r->id - MAX_ROUTES, priv->host_route_use_bm);
} else {
/* If there is a HW representation of the route, delete it */
if (priv->r->route_lookup_hw) {
id = priv->r->route_lookup_hw(r);
pr_info("%s: Got id for prefix route: %d\n", __func__, id);
r->attr.valid = false;
priv->r->route_write(id, r);
}
clear_bit(r->id, priv->route_use_bm);
}

kfree(r);
}

The above function is used to delete an already created host route.
It removes the software representation of the route then calls one of
two route_write methods. The route_write method, if implemented,
copies the software route representation into an internal FPGA




NEXT




<s> static void rtl838x_eth_set_multicast_list(struct net_device *ndev)
{
/* Flood all classes of RMA addresses (01-80-C2-00-00-{01..2F})
* CTRL_0_FULL = GENMASK(21, 0) = 0x3FFFFF
*/
if (!(ndev->flags & (IFF_PROMISC | IFF_ALLMULTI))) {
sw_w32(0x0, RTL838X_RMA_CTRL_0);
sw_w32(0x0, RTL838X_RMA_CTRL_1);
}
if (ndev->flags & IFF_ALLMULTI)
sw_w32(GENMASK(21, 0), RTL838X_RMA_CTRL_0);
if (ndev->flags & IFF_PROMISC) {
sw_w32(GENMASK(21, 0), RTL838X_RMA_CTRL_0);
sw_w32(0x7fff, RTL838X_RMA_CTRL_1);
}
}

The above function is used to configure the multicast filter. The 0x3FFFFF will flooding all classes of RMA addresses (01-80-C2-00-00-{01..2F}) which can be referred




NEXT




<s> DSL_BSP_ATMLedCBUnregister (int (*ifx_adsl_ledcallback) (void))
{
g_adsl_ledcallback = adsl_dummy_ledcallback;
return 0;
}

The above function is used to unregister the user defined callback function and sets as default in case any callback function is registered before.

g_adsl_ledcallback is the global variable of type adsl_ledcallback;
DSL_BSP_ADSL




NEXT




<s> static int ag71xx_debugfs_generic_open(struct inode *inode, struct file *file)
{
file->private_data = inode->i_private;
return 0;
}

The above function is used to bind a file instance to a particular “debugfs” directory. Then the kernel knows that in case that file is opened it will be bound to the contents of that directory. So the real open function would be “debugfs_generic_open”




NEXT




<s> rtk_api_ret_t rtk_svlan_servicePort_get(rtk_portmask_t *pSvlan_portmask)
{
rtk_api_ret_t retVal;
rtk_uint32 phyMbrPmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pSvlan_portmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicSvlanUplinkPortMask(&phyMbrPmask)) != RT_ERR_OK)
return retVal;

if(rtk_switch_portmask_P2L_get(phyMbrPmask, pSvlan_portmask) != RT_ERR_OK)
return RT_ERR_FAILED;


return RT_ERR_OK;
}

The above function is used to retrieve the mbr svlan port for a 0-497 trunk port.

rtk_api_config_t(rtk_portmask_t   *vlan_port_mask)


rtk




NEXT




<s> static int rtl8366_smi_read_byte1(struct rtl8366_smi *smi, u8 *data)
{
u32 t;

/* read data */
rtl8366_smi_read_bits(smi, 8, &t);
*data = (t & 0xff);

/* send an ACK */
rtl8366_smi_write_bits(smi, 0x01, 1);

return 0;
}

The above function is used to read one byte from SMI by using the SMI_read_byte1() interface.</s>




NEXT




<s> static int qca807x_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
{
return GPIO_LINE_DIRECTION_OUT;
}

The above function is used to tell gpiochip driver that the pin is output
only. This function is called only when pin is initially configured
through devm_gpio_request_one().

But, for some unknown reasons (and may be due to some internal




NEXT




<s> static unsigned esw_get_pvid(struct rt305x_esw *esw, unsigned port)
{
unsigned s, val;

s = RT305X_ESW_PVIDC_PVID_S * (port % 2);
val = esw_r32(esw, RT305X_ESW_REG_PVIDC(port / 2));
return (val >> s) & RT305X_ESW_PVIDC_PVID_M;
}

The above function is used to determine port’s PVID value from the switches on-chip registers.

It was previously mentioned that we do not have a direct way of reading this value from the chip’s registers, instead we calculate the PVID value by shifting




NEXT




<s> ret_t rtl8367c_getAsicSvlanMC2SConf(rtk_uint32 index, rtl8367c_svlan_mc2s_t* pSvlanMc2sCfg)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint16 *accessPtr;
rtk_uint32 i;
rtk_uint16 smiSvlanMC2S[RTL8367C_SVLAN_MC2S_LEN];

if(index > RTL8367C_MC2SIDXMAX)
return RT_ERR_ENTRY_INDEX;

memset(smiSvlanMC2S, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_MC2S_LEN);

accessPtr = smiSvlanMC2S;

for(i = 0; i < 5; i++)
{
retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_MCAST2S_ENTRY_BASE_REG(index) + i, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*accessPtr = regData;
accessPtr ++;
}


_rtl8367c_svlanMc2sStSmi2User(pSvlanMc2sCfg, smiSvlanMC2S);

return RT_ERR_OK;
}

The above function is used to get the data from SMI area and store them
to the data area.
The format of each SVLAN entry is described in [RTL8367C_SVLAN_MCAST2S_ENTRY_DESC].






NEXT




<s> static int pci_msi_vec_set(struct pci_dev *dev, int nvec)
{
int pos;
u16 msgctl;

if (!is_power_of_2(nvec))
return -EINVAL;

pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
if (!pos)
return -EINVAL;

pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &msgctl);
msgctl &= ~PCI_MSI_FLAGS_QSIZE;
msgctl |= ((ffs(nvec) - 1) << 4);
pci_write_config_word(dev, pos + PCI_MSI_FLAGS, msgctl);
pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &msgctl);
return 0;
}

The above function is used to set the value of the MSI flags register’s QSIZE field which governs the message size of an MSI or MSI-X interrupt. QSIZE takes a value ranging from 1 to 6553, and specifies




NEXT




<s> rtk_api_ret_t rtk_qos_portPriSelIndex_get(rtk_port_t port, rtk_qos_priDecTbl_t *pIndex)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicPortPriorityDecisionIndex(rtk_switch_port_L2P_get(port), pIndex)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the port’s priority decision index.

rtk_qos_portPriSelIndex_set
#if (SYS_CPNT_VPORT == TRUE)
#error code not present
#else






NEXT




<s> static int mt7621_nfc_ecc_init(struct mt7621_nfc *nfc)
{
struct nand_chip *nand = &nfc->nand;
struct mtd_info *mtd = nand_to_mtd(nand);
u32 spare_per_sector, encode_block_size, decode_block_size;
u32 ecc_enccfg, ecc_deccfg;
int ecc_cap;

/* Only hardware ECC mode is supported */
if (nand->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST) {
dev_err(nfc->dev, "Only hardware ECC mode is supported\n");
return -EINVAL;
}

nand->ecc.size = ECC_SECTOR_SIZE;
nand->ecc.steps = mtd->writesize / nand->ecc.size;

spare_per_sector = mtd->oobsize / nand->ecc.steps;

ecc_cap = mt7621_nfc_calc_ecc_strength(nfc,
spare_per_sector - NFI_FDM_SIZE);
if (ecc_cap < 0)
return ecc_cap;

/* Sector + FDM */
encode_block_size = (nand->ecc.size + NFI_FDM_SIZE) * 8;
ecc_enccfg = ecc_cap | (ENC_MODE_NFI << ENC_MODE_S) |
(encode_block_size << ENC_CNFG_MSG_S);

/* Sector + FDM + ECC parity bits */
decode_block_size = ((nand->ecc.size + NFI_FDM_SIZE) * 8) +
nand->ecc.strength * ECC_PARITY_BITS;
ecc_deccfg = ecc_cap | (DEC_MODE_NFI << DEC_MODE_S) |
(decode_block_size << DEC_CS_S) |
(DEC_CON_EL << DEC_CON_S) | DEC_EMPTY_EN;

ecc_write32(nfc, ECC_FDMADDR, nfc->nfi_base + NFI_FDML(0));

mt7621_ecc_encoder_op(nfc, false);
ecc_write32(nfc, ECC_ENCCNFG, ecc_enccfg);

mt7621_ecc_decoder_op(nfc, false);
ecc_write32(nfc, ECC_DECCNFG, ecc_deccfg);

return 0;
}

The above function is used to configure and initialize hardware ECC engine. Function ecc_enccfg will configure the encoder and function ecc_deccfg will configure the decoder. It basically performs the initialization of ECC engine.

#include <linux/module




NEXT




<s> void rtl839x_setup_prio2queue_matrix(int *min_queues)
{
pr_info("Current Intprio2queue setting: %08x\n", sw_r32(RTL839X_QM_INTPRI2QID_CTRL(0)));
for (int i = 0; i < MAX_PRIOS; i++) {
int q = min_queues[i];
sw_w32(i << (q * 3), RTL839X_QM_INTPRI2QID_CTRL(q));
}
}

The above function is used to setup the interrupt prio->queue mapping in rtl839x
which maps the interrupt priority to a specific queue.

So if:

sw_r32(RTL839X_QM_INT




NEXT




<s> header_print_comment(FILE *fp, const char *value, void *arg)
{
const char *p = value;
size_t l;

fprintf(fp, "/*\n");
for (;;) {
l = strcspn(p, "\n");
fprintf(fp, " *");
if (l) {
fprintf(fp, " ");
xfwrite(p, l, 1, fp);
p += l;
}
fprintf(fp, "\n");
if (*p++ == '\0')
break;
}
fprintf(fp, " */\n");
}

The above function is used to print a string with the /* */ comments. This print string has extra work to be done in regards to the comments, but these aren't the main problem.

Let's imagine a slightly different function:

header_bake




NEXT




<s> static void gen_key(mbedtls_pk_context *key, bool rsa, int ksize, int exp,
mbedtls_ecp_group_id curve, bool pem)
{
mbedtls_pk_init(key);
if (rsa) {
fprintf(stderr, "Generating RSA private key, %i bit long modulus\n", ksize);
mbedtls_pk_setup(key, mbedtls_pk_info_from_type(MBEDTLS_PK_RSA));
if (!mbedtls_rsa_gen_key(mbedtls_pk_rsa(*key), _urandom, NULL, ksize, exp))
return;
} else {
fprintf(stderr, "Generating EC private key\n");
mbedtls_pk_setup(key, mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY));
if (!mbedtls_ecp_gen_key(curve, mbedtls_pk_ec(*key), _urandom, NULL))
return;
}
fprintf(stderr, "error: key generation failed\n");
exit(1);
}

The above function is used to generate a private key depending on the type
of PKI (RSA vs. EC) and length. The _urandom parameter is the standard
C function to read from /dev/urandom (or a random device on other
platform




NEXT




<s> static int rtl83xx_setup_tc_cls_flower(struct rtl838x_switch_priv *priv,
struct flow_cls_offload *cls_flower)
{
pr_debug("%s: %d\n", __func__, cls_flower->command);
switch (cls_flower->command) {
case FLOW_CLS_REPLACE:
return rtl83xx_configure_flower(priv, cls_flower);
case FLOW_CLS_DESTROY:
return rtl83xx_delete_flower(priv, cls_flower);
case FLOW_CLS_STATS:
return rtl83xx_stats_flower(priv, cls_flower);
default:
return -EOPNOTSUPP;
}
}

The above function is used to check if the flower offload is ready. Currently it only checks if the flower engine is turned on and the offload is enabled in the device. In the future, this should also check if the FLOW table has enough space available.






NEXT




<s> void	green_LED_on(void)
{
AT91PS_PIO	PIOB	= AT91C_BASE_PIOB;
//	PIOB->PIO_CODR		= GREEN_LED;
PIOB->PIO_CODR		= (1 << 0);
}

The above function is used to turn on the LED.
The function that is used to turn the LED on is

PIOB->PIO_CODR = Green_LED;

The function that is used to turn the LED off is.

PIOB->




NEXT




<s> int spi_claim_bus(void)
{
espi_claim_bus(&spi);

return 0;
}

The above function is used to disable the interrupt generation by masking the interrupt pin.

In order to generate an interrupt request, we have to enable the external interrupt generator pins by calling the function intx_enable(), passing the interrupt number as argument. On RZ




NEXT




<s> int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
{
int top,al,bl;
BIGNUM *rr;
int ret = 0;
#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)
int i;
#endif

#ifdef BN_COUNT
printf("BN_mul %d * %d\n",a->top,b->top);
#endif

bn_check_top(a);
bn_check_top(b);
bn_check_top(r);

al=a->top;
bl=b->top;

if ((al == 0) || (bl == 0))
{
BN_zero(r);
return(1);
}
top=al+bl;

BN_CTX_start(ctx);
if ((r == a) || (r == b))
{
if ((rr = BN_CTX_get(ctx)) == NULL) goto err;
}
else
rr = r;
rr->neg=a->neg^b->neg;

#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)
i = al-bl;
#endif
#ifdef BN_MUL_COMBA
if (i == 0)
{
# if 0
if (al == 4)
{
if (bn_wexpand(rr,8) == NULL) goto err;
rr->top=8;
bn_mul_comba4(rr->d,a->d,b->d);
goto end;
}
# endif
if (al == 8)
{
if (bn_wexpand(rr,16) == NULL) goto err;
rr->top=16;
bn_mul_comba8(rr->d,a->d,b->d);
goto end;
}
}
#endif /* BN_MUL_COMBA */
if (bn_wexpand(rr,top) == NULL) goto err;
rr->top=top;
bn_mul_normal(rr->d,a->d,al,b->d,bl);

#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)
end:
#endif
bn_fix_top(rr);
if (r != rr) BN_copy(r,rr);
ret=1;
err:
BN_CTX_end(ctx);
return(ret);
}

The above function is used to multiplies large numbers using BN_MUL_COMBA optimized version which optimizes multiplications in 8 and 16 bit modes and if the numbers are larger than that BN_MUL_NORMAL is called.

In the




NEXT




<s> static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
int cur_y, int cur_x, update_text_fn update_text,
void *data)
{
print_page(box, boxh, boxw, update_text, data);
print_position(dialog);
wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
wrefresh(dialog);
}

The above function is used to refresh text boxes (which are just wrappers that use print_page() to draw content and print_position() to refresh the dialog box). However the dialog box in its current state does not support a scroll bar. It would be trivial to add




NEXT




<s> static void msdc_abort_data(struct msdc_host *host)
{
void __iomem *base = host->base;
struct mmc_command *stop = host->mrq->stop;

ERR_MSG("Need to Abort.");

msdc_reset_hw(host);
msdc_clr_fifo();
msdc_clr_int();

// need to check FIFO count 0 ?

if (stop) {  /* try to stop, but may not success */
ERR_MSG("stop when abort CMD<%d>", stop->opcode);
(void)msdc_do_command(host, stop, 0, CMD_TIMEOUT);
}

//if (host->mclk >= 25000000) {
//      msdc_set_mclk(host, 0, host->mclk >> 1);
//}
}

The above function is used to abort data by resetting hardware. But it seems some things are neglected. In the msdc_reset_hw function, the RST signal is set low. I am not sure if we should check whether RST is pulled low or




NEXT




<s> be64enc(void *buf, uint64_t u)
{
uint8_t *p = buf;

be32enc(p, ((uint32_t) (u >> 32)));
be32enc(p + 4, ((uint32_t) (u & 0xffffffffULL)));
}

The above function is used to convert a uint64_t number to a big endian little endian
be16enc(void *buf, uint16_t u)
{
uint8_t *p = buf;

be8enc




NEXT




<s> static int rtl8366_reset(struct rtl8366_smi *smi)
{
if (smi->hw_reset) {
smi->hw_reset(smi, true);
msleep(RTL8366_SMI_HW_STOP_DELAY);
smi->hw_reset(smi, false);
msleep(RTL8366_SMI_HW_START_DELAY);
return 0;
}

return smi->ops->reset_chip(smi);
}

The above function is used to reset the Ethernet MAC and PHY. So it could not work without hardware.</s>




NEXT




<s> inline void rtl930x_exec_tbl1_cmd(u32 cmd)
{
sw_w32(cmd, RTL930X_TBL_ACCESS_CTRL_1);
do { } while (sw_r32(RTL930X_TBL_ACCESS_CTRL_1) & (1 << 17));
}

The above function is used to read or write mac-table.
The issue is if I set bit 17 of RTL930X_TBL_ACCESS_CTRL_1(SWD) high then read mac-table then change bit 17




NEXT




<s> rtk_api_ret_t rtk_svlan_defaultSvlan_set(rtk_port_t port, rtk_vlan_t svid)
{
rtk_api_ret_t retVal;
rtk_uint32 i;
rtl8367c_svlan_memconf_t svlanMemConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

/* svid must be 0~4095 */
if (svid > RTL8367C_VIDMAX)
return RT_ERR_SVLAN_VID;

for (i = 0; i < RTL8367C_SVIDXNO; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;

if (svid == svlanMemConf.vs_svid)
{
if ((retVal = rtl8367c_setAsicSvlanDefaultVlan(rtk_switch_port_L2P_get(port), i)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}
}

return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
}

The above function is used to set the default sVLAN member in the default vlan table. The function is called when the customer sets a port to a sVLAN tagged mode by svlan_set() or untagged mode by untag_set(), if




NEXT




<s> static int rb4xx_gpio_get(struct gpio_chip *chip, unsigned int offset)
{
struct rb4xx_gpio *gpio = gpiochip_get_data(chip);
int ret;

mutex_lock(&gpio->lock);
ret = (gpio->values >> offset) & 0x1;
mutex_unlock(&gpio->lock);

return ret;
}

The above function is used to read a single GPIO line. It takes two parameters:
- The gpio_chip structure, which represents the GPIO interface and holds information related to the GPIO lines.
- The offset of the GPIO line to read.

The code first




NEXT




<s> static void print_help(struct menu *menu)
{
struct gstr help = str_new();

menu_get_ext_help(menu, &help);

printf("\n%s\n", str_get(&help));
str_free(&help);
}

The above function is used to display a help message. It can be

1.	called without any parameter
2.	Called with a pointer to menu as parameter to display the extend help for an option menu. It calls a user created function called menu_get_




NEXT




<s> int rtl930x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val)
{
int err = 0;
u32 v;

mutex_lock(&smi_lock);

/* Set PHY to access */
sw_w32_mask(0xffff << 16, port << 16, RTL930X_SMI_ACCESS_PHY_CTRL_2);

/* Set MMD device number and register to write to */
sw_w32(devnum << 16 | (regnum & 0xffff), RTL930X_SMI_ACCESS_PHY_CTRL_3);

v = BIT(1) | BIT(0); /* MMD-access | EXEC */
sw_w32(v, RTL930X_SMI_ACCESS_PHY_CTRL_1);

do {
v = sw_r32(RTL930X_SMI_ACCESS_PHY_CTRL_1);
} while (v & BIT(0));
/* There is no error-checking via BIT 25 of v, as it does not seem to be set correctly */
*val = (sw_r32(RTL930X_SMI_ACCESS_PHY_CTRL_2) & 0xffff);
pr_debug("%s: port %d, regnum: %x, val: %x (err %d)\n", __func__, port, regnum, *val, err);

mutex_unlock(&smi_lock);

return err;
}

The above function is used to read from the PHY.

The read access to the MMD is always done via the SMI, which was discussed in much detail in the previous chapter. We can now look at the code that uses the SMI interface in the real




NEXT




<s> void	red_LED_off(void)
{
AT91PS_PIO	PIOB	= AT91C_BASE_PIOB;
//	PIOB->PIO_SODR		= RED_LED;
PIOB->PIO_SODR		= (1 << 2);
}

The above function is used to switch off the red LED and I am able to achieve the same result by calling the following function.

void
red_LED_off1(void)
{
volatile AT91PS_PIO PIO_port_B




NEXT




<s> static inline void sdalo(void)
{
gpio_direction_output(sda_index, 1);
udelay(ADAP_DELAY);
}

The above function is used to write data to a MPU on its serial data line. But the above definition could be more helpful in understanding the implementation if it were defined in the following manner:

It is a macro and so does not use the stack, and therefore needs




NEXT




<s> rtk_api_ret_t rtk_switch_portmask_L2P_get(rtk_portmask_t *pLogicalPmask, rtk_uint32 *pPhysicalPortmask)
{
rtk_uint32 log_port, phy_port;

if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(NULL == pLogicalPmask)
return RT_ERR_NULL_POINTER;

if(NULL == pPhysicalPortmask)
return RT_ERR_NULL_POINTER;

if(rtk_switch_isPortMaskValid(pLogicalPmask) != RT_ERR_OK)
return RT_ERR_PORT_MASK;

/* reset physical port mask */
*pPhysicalPortmask = 0;

RTK_PORTMASK_SCAN((*pLogicalPmask), log_port)
{
phy_port = rtk_switch_port_L2P_get((rtk_port_t)log_port);
*pPhysicalPortmask |= (0x0001 << phy_port);
}

return RT_ERR_OK;
}

The above function is used to get the logical and physical port associations in order to facilitate different kinds of programming requirement.</s>




NEXT




<s> ret_t rtl8367c_getAsicEgressFlowControlQueueDropThreshold(rtk_uint32 qid, rtk_uint32 *pThreshold)
{
if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;

return rtl8367c_getAsicRegBits(RTL8367C_FLOWCTRL_QUEUE_DROP_ON_REG(qid), RTL8367C_FLOWCTRL_QUEUE_DROP_ON_MASK, pThreshold);
}

The above function is used to get the port queue number and flow control drop threshold.

Note that the bit field should be changed to bit 31 to 13. The bit field will be changed from 0 to 13 as port queue from 0




NEXT




<s> static int bcm6348_cb_bridge_read(int where, int size, u32 *val)
{
struct bcm6348_cb *cb = &bcm6348_pci.cb;
unsigned int reg;
u32 data;

data = 0;
reg = where >> 2;
switch (reg) {
case (PCI_VENDOR_ID >> 2):
case (PCI_CB_SUBSYSTEM_VENDOR_ID >> 2):
/* create dummy vendor/device id from our cpu id */
data = (CARDBUS_DUMMY_ID << 16) | PCI_VENDOR_ID_BROADCOM;
break;

case (PCI_COMMAND >> 2):
data = (PCI_STATUS_DEVSEL_SLOW << 16);
data |= cb->pci_command;
break;

case (PCI_CLASS_REVISION >> 2):
data = (PCI_CLASS_BRIDGE_CARDBUS << 16);
break;

case (PCI_CACHE_LINE_SIZE >> 2):
data = (PCI_HEADER_TYPE_CARDBUS << 16);
break;

case (PCI_INTERRUPT_LINE >> 2):
/* bridge control */
data = (cb->bridge_control << 16);
/* pin:intA line:0xff */
data |= (0x1 << 8) | 0xff;
break;

case (PCI_CB_PRIMARY_BUS >> 2):
data = (cb->cb_latency << 24);
data |= (cb->subordinate_busn << 16);
data |= (cb->cardbus_busn << 8);
data |= cb->pci_busn;
break;

case (PCI_CB_MEMORY_BASE_0 >> 2):
data = cb->mem_base0;
break;

case (PCI_CB_MEMORY_LIMIT_0 >> 2):
data = cb->mem_limit0;
break;

case (PCI_CB_MEMORY_BASE_1 >> 2):
data = cb->mem_base1;
break;

case (PCI_CB_MEMORY_LIMIT_1 >> 2):
data = cb->mem_limit1;
break;

case (PCI_CB_IO_BASE_0 >> 2):
/* | 1 for 32bits io support */
data = cb->io_base0 | 0x1;
break;

case (PCI_CB_IO_LIMIT_0 >> 2):
data = cb->io_limit0;
break;

case (PCI_CB_IO_BASE_1 >> 2):
/* | 1 for 32bits io support */
data = cb->io_base1 | 0x1;
break;

case (PCI_CB_IO_LIMIT_1 >> 2):
data = cb->io_limit1;
break;
}

*val = postprocess_read(data, where, size);
return PCIBIOS_SUCCESSFUL;
}

The above function is used to return any specific PCI value from the
CB Bridge. For example if the PCI_VENDOR_ID registry value is wanted,
the above function is called for the offset PCI_VENDOR_ID.</s>




NEXT




<s> static int mtdsplit_parse_seil_fw(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct device_node *np = mtd_get_of_node(master);
struct mtd_partition *parts;
struct seil_header header;
size_t image_size = 0;
size_t rootfs_offset;
size_t hdrlen = sizeof(header);
size_t retlen;
int ret;
u64 id;

if (!seil_bootdev_is_active(np))
return -ENODEV;

ret = of_property_read_u64(np, "iij,seil-id", &id);
if (ret) {
pr_err("failed to get iij,seil-id from dt\n");
return ret;
}
pr_debug("got seil-id=0x%016llx from dt\n", id);

parts = kcalloc(NR_PARTS, sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

ret = mtd_read(master, 0, hdrlen, &retlen, (void *)&header);
if (ret)
goto err_free_parts;

if (retlen != hdrlen) {
ret = -EIO;
goto err_free_parts;
}

if (be64_to_cpu(header.id) != id ||
be32_to_cpu(header.vfmt) != SEIL_VFMT) {
pr_debug("no valid seil image found in \"%s\"\n", master->name);
ret = -ENODEV;
goto err_free_parts;
}

image_size = hdrlen + be32_to_cpu(header.dlen);
if (image_size > master->size) {
pr_err("seil image exceeds MTD device \"%s\"\n", master->name);
ret = -EINVAL;
goto err_free_parts;
}

/* find the roots after the seil image */
ret = mtd_find_rootfs_from(master, image_size,
master->size, &rootfs_offset, NULL);
if (ret || (master->size - rootfs_offset) == 0) {
pr_debug("no rootfs after seil image in \"%s\"\n",
master->name);
ret = -ENODEV;
goto err_free_parts;
}

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = 0;
parts[0].size = rootfs_offset;

parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = master->size - rootfs_offset;

*pparts = parts;
return NR_PARTS;

err_free_parts:
kfree(parts);
return ret;
}

The above function is used to parse the SEIL image from mtd devices, and it takes the following steps:
1. Check if the SEIL boot device is active by calling seil_bootdev_is_active function.
2. If the SEIL boot




NEXT




<s> void rtl839x_vlan_port_pvid_set(int port, enum pbvlan_type type, int pvid)
{
if (type == PBVLAN_TYPE_INNER)
sw_w32_mask(0xfff << 2, pvid << 2, RTL839X_VLAN_PORT_PB_VLAN + (port << 2));
else
sw_w32_mask(0xfff << 16, pvid << 16, RTL839X_VLAN_PORT_PB_VLAN + (port << 2));
}

The above function is used to set the priority of a port. However, the code does not check the port number. As a result, the priority of the wrong port may be set, and the behavior of the VLAN is unknown.

An example:







NEXT




<s> static int arc4_set_key_skcipher(struct crypto_skcipher *tfm, const u8 *inkey,
unsigned int key_len)
{
return arc4_set_key(crypto_skcipher_ctx(tfm), inkey, key_len);
}

The above function is used to perform arc4 operation for the cipher instance tfm.
Here, tfm is the pointer of crypto_skcipher type and inkey is the pointer to key
array of char type. Here the key_len is always 4




NEXT




<s> static void bcm6348_pci_fixup(struct pci_dev *dev)
{
struct bcm6348_pci *priv = &bcm6348_pci;
struct bcm6348_cb *cb = &priv->cb;
static int io_window = -1;
int i, found, new_io_window;
u32 val;

/* look for any io resource */
found = 0;
for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
if (pci_resource_flags(dev, i) & IORESOURCE_IO) {
found = 1;
break;
}
}

if (!found)
return;

/* skip our fake bus with only cardbus bridge on it */
if (dev->bus->number == priv->cb_bus)
return;

/* find on which bus the device is */
if (cb->bus_assigned &&
dev->bus->number == cb->cardbus_busn &&
PCI_SLOT(dev->devfn) == 0)
new_io_window = 1;
else
new_io_window = 0;

if (new_io_window == io_window)
return;

if (io_window != -1) {
pr_err("bcm63xx: both PCI and cardbus devices "
"need IO, which hardware cannot do\n");
return;
}

pr_info("bcm63xx: PCI IO window assigned to %s\n",
(new_io_window == 0) ? "PCI" : "cardbus");

val = __raw_readl(priv->pci + MPI_L2PIOREMAP_REG);
if (io_window)
val |= MPI_L2PREMAP_IS_CARDBUS_MASK;
else
val &= ~MPI_L2PREMAP_IS_CARDBUS_MASK;
__raw_writel(val, priv->pci + MPI_L2PIOREMAP_REG);

io_window = new_io_window;
}

The above function is used to fixup the PCI IO window allocation.

However, there are a few issues with this code:

* There are some "cardbus" windows assigned in addition to
"pci" or not - so, they always appear as additional




NEXT




<s> static void esw_set_port_disable(struct rt305x_esw *esw, unsigned disable_mask)
{
unsigned old_mask;
unsigned enable_mask;
unsigned changed;
int i;

old_mask = esw_get_port_disable(esw);
changed = old_mask ^ disable_mask;
enable_mask = old_mask & disable_mask;

/* enable before writing to MII */
esw_rmw(esw, RT305X_ESW_REG_POC0,
(RT305X_ESW_POC0_DIS_PORT_M <<
RT305X_ESW_POC0_DIS_PORT_S),
enable_mask << RT305X_ESW_POC0_DIS_PORT_S);

for (i = 0; i < RT305X_ESW_NUM_LEDS; i++) {
if (!(changed & (1 << i)))
continue;
if (disable_mask & (1 << i)) {
/* disable */
rt305x_mii_write(esw, i, MII_BMCR,
BMCR_PDOWN);
} else {
/* enable */
rt305x_mii_write(esw, i, MII_BMCR,
BMCR_FULLDPLX |
BMCR_ANENABLE |
BMCR_ANRESTART |
BMCR_SPEED100);
}
}

/* disable after writing to MII */
esw_rmw(esw, RT305X_ESW_REG_POC0,
(RT305X_ESW_POC0_DIS_PORT_M <<
RT305X_ESW_POC0_DIS_PORT_S),
disable_mask << RT305X_ESW_POC0_DIS_PORT_S);
}

The above function is used to disable or enebale port.

The old_mask and disable_mask mask are calculated as below:

old_mask = get_port_disable(esw); changed = old_mask ^ disable_mask;






NEXT




<s> void rtl930x_traffic_enable(int source, int dest)
{
struct table_reg *r = rtl_table_get(RTL9300_TBL_0, 6);
rtl_table_read(r, source);
sw_w32_mask(0, BIT(dest + 3), rtl_table_data(r, 0));
rtl_table_write(r, source);
rtl_table_release(r);
}

The above function is used to enable/disable traffic in the packet flow to a specific port/priority, by turning the Enable bit or otherwise (for the given priority).
It is found here: rtl930x.c

If I understand the source right




NEXT




<s> ret_t rtl8367c_setAsicGreenTrafficType(rtk_uint32 priority, rtk_uint32 traffictype)
{

if(priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBit(RTL8367C_REG_HIGHPRI_CFG, priority, (traffictype?1:0));
}

The above function is used to set the specific priority as high priority traffic.  It will not change the priority level.  You can set priority as high priority traffic without affecting the priority level.

RTL8367C chip supports five types of high priority traffic




NEXT




<s> static int rtl_table_exec(struct table_reg *r, bool is_write, int idx)
{
int ret = 0;
u32 cmd, val;

/* Read/write bit has inverted meaning on RTL838x */
if (r->rmode)
cmd = is_write ? 0 : BIT(r->c_bit);
else
cmd = is_write ? BIT(r->c_bit) : 0;

cmd |= BIT(r->c_bit + 1); /* Execute bit */
cmd |= r->tbl << r->t_bit; /* Table type */
cmd |= idx & (BIT(r->t_bit) - 1); /* Index */

sw_w32(cmd, r->addr);

ret = readx_poll_timeout(sw_r32, r->addr, val,
!(val & BIT(r->c_bit + 1)), 20, 10000);
if (ret)
pr_err("%s: timeout\n", __func__);

return ret;
}

The above function is used to write/read a register on the rtl8192eu. From the code, we can see that the function takes two arguments: an is_write argument and an idx argument. The is_write argument is used to determine if the




NEXT




<s> static void ep_mem_write(u8 __iomem *dst, const void *src, size_t len)
{
int i;
const u32 *src_addr = src;

if (len % 4)
pr_info("Warning!!: Copy len is not multiple of 4\n");

len = len >> 2;

for (i = 0; i < len; i++)
writel(src_addr[i], (dst + (i << 2)));
}

The above function is used to write data in kernel space to physical memory locations. The data sent to EP28F is also sent exactly in this manner. The kernel-space data to be written to the EP is in struct ep_info, which contains many parameters related to




NEXT




<s> ret_t rtl8367c_setAsicRmaCsstp(rtl8367c_rma_t* pRmacfg)
{
rtk_uint32 regData = 0;
ret_t retVal;

if(pRmacfg->operation >= RMAOP_END)
return RT_ERR_RMA_ACTION;

if(pRmacfg->trap_priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

regData |= (pRmacfg->portiso_leaky & 0x0001);
regData |= ((pRmacfg->vlan_leaky & 0x0001) << 1);
regData |= ((pRmacfg->keep_format & 0x0001) << 2);
regData |= ((pRmacfg->trap_priority & 0x0007) << 3);
regData |= ((pRmacfg->discard_storm_filter & 0x0001) << 6);
regData |= ((pRmacfg->operation & 0x0003) << 7);

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, pRmacfg->trap_priority);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_setAsicReg(RTL8367C_REG_RMA_CTRL_CSSTP, regData);
}

The above function is used to configure the rma csstp register's configuration.

The setAsicReg will directly change the register's value.

The setAsicRegBits will only change the bits at the specific position.

ret_




NEXT




<s> static void aca_xbar_ia_reset(struct dc_ep_priv *priv, int ia_id)
{
/* ACA IA reset */
wr32(XBAR_CTRL_CORE_RESET, ACA_AGENT_CTRL(ia_id));

/* Read till status become 1 */
while ((rd32(ACA_AGENT_STATUS(ia_id)) & XBAR_STAT_CORE_RESET) == 0)
;

/* Clear the IA Reset signal */
wr32(0, ACA_AGENT_CTRL(ia_id));

/* Read till status become 0 */
while ((rd32(ACA_AGENT_STATUS(ia_id)) & XBAR_STAT_CORE_RESET) == 1)
;

dev_dbg(priv->dev, "ACA XBAR IA(%d) reset done\n", ia_id);
}

The above function is used to reset the ACA XBAR instance during
ACA_AGENT_CTRL reset

static int aca_xbar_ia_init(struct dc_ep_priv *priv, int ia_num)
{





NEXT




<s> static void _rtl8367c_Vlan4kStSmi2User(rtk_uint16 *pSmiVlan4kEntry, rtl8367c_user_vlan4kentry *pUserVlan4kEntry)
{
pUserVlan4kEntry->mbr = (pSmiVlan4kEntry[0] & 0x00FF) | ((pSmiVlan4kEntry[2] & 0x0007) << 8);
pUserVlan4kEntry->untag = ((pSmiVlan4kEntry[0] & 0xFF00) >> 8) | (((pSmiVlan4kEntry[2] & 0x0038) >> 3) << 8);
pUserVlan4kEntry->fid_msti = pSmiVlan4kEntry[1] & 0x000F;
pUserVlan4kEntry->vbpen = (pSmiVlan4kEntry[1] & 0x0010) >> 4;
pUserVlan4kEntry->vbpri = (pSmiVlan4kEntry[1] & 0x00E0) >> 5;
pUserVlan4kEntry->envlanpol = (pSmiVlan4kEntry[1] & 0x0100) >> 8;
pUserVlan4kEntry->meteridx = ((pSmiVlan4kEntry[1] & 0x3E00) >> 9) | (((pSmiVlan4kEntry[2] & 0x0040) >> 6) << 5);
pUserVlan4kEntry->ivl_svl = (pSmiVlan4kEntry[1] & 0x4000) >> 14;
}

The above function is used to convert smi Vlan (Vlan 4k) table entry to user space format.</s>




NEXT




<s> int DSL_BSP_KernelIoctls (DSL_DEV_Device_t *, unsigned int, unsigned long);

static DSL_DEV_MeiError_t IFX_MEI_RunAdslModem (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_CpuModeSet (DSL_DEV_Device_t *, DSL_DEV_CpuMode_t);
static DSL_DEV_MeiError_t IFX_MEI_DownloadBootCode (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_ArcJtagEnable (DSL_DEV_Device_t *, int);
static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to register the interrupt callback function to enable user register interrupt callback for ATM showtime.

DSL_DRV_file_ops_t ifx_mei_file_ops = {
	.owner = THIS_MODULE,





NEXT




<s> static void fe_get_ethtool_stats(struct net_device *dev,
struct ethtool_stats *stats, u64 *data)
{
struct fe_priv *priv = netdev_priv(dev);
struct fe_hw_stats *hwstats = priv->hw_stats;
u64 *data_src, *data_dst;
unsigned int start;
int i;

if (netif_running(dev) && netif_device_present(dev)) {
if (spin_trylock(&hwstats->stats_lock)) {
fe_stats_update(priv);
spin_unlock(&hwstats->stats_lock);
}
}

do {
data_src = &hwstats->tx_bytes;
data_dst = data;
start = u64_stats_fetch_begin_irq(&hwstats->syncp);

for (i = 0; i < ARRAY_SIZE(fe_gdma_str); i++)
*data_dst++ = *data_src++;

} while (u64_stats_fetch_retry_irq(&hwstats->syncp, start));
}

The above function is used to collect the statistics of the network adapter. This function makes use of fe_stats_update()
function to fetch the hardware statistics for the current MAC-address. When the new statistics is fetched then these are updated in the same array. These




NEXT




<s> static inline int pinmux_set(struct dc_ep_dev *dev, u32 gpio, int func)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_pinmux_set(dev->priv, gpio, func);
}

The above function is used to configure the muxing on pins. It takes two arguments: dev (which should be passed in from a higher layer, such as a device driver), and gpio (the GPIO that should be
configured).

pinmux_




NEXT




<s> BigIntegerFromInt(n)
unsigned int n;
{
BIGNUM * a = BN_new();
BN_set_word(a, n);
return a;
}

The above function is used to convert an int to a BN_ULONG.

The BIGNUM type is a BigInteger, and BN_set_word simply moves the bits from an int to a BN_ULONG.

We could also




NEXT




<s> append_string(yytext, yyleng);
if (!first_ts)
first_ts = last_ts;
}
YY_BREAK
case YY_STATE_EOF(HELP):
{

The above function is used to create multiple threads in your application, and can be used by any C or C++ application that uses threads. You can also set flags in the parameters to make the scheduler create threads as soon as you call the function rather than when they are scheduled




NEXT




<s> static u32 rtl839x_packet_cntr_read(int counter)
{
u32 v;

/* Read LOG table (4) via register RTL8390_TBL_0 */
struct table_reg *r = rtl_table_get(RTL8390_TBL_0, 4);

pr_debug("In %s, id %d\n", __func__, counter);
rtl_table_read(r, counter / 2);

/* The table has a size of 2 registers */
if (counter % 2)
v = sw_r32(rtl_table_data(r, 0));
else
v = sw_r32(rtl_table_data(r, 1));

rtl_table_release(r);

return v;
}

The above function is used to read a counter which is read from a table. The table has a length of 2.</s>




NEXT




<s> ret_t rtl8367c_getAsicFieldSelector(rtk_uint32 index, rtk_uint32* pFormat, rtk_uint32* pOffset)
{
ret_t retVal;
rtk_uint32 regData;

retVal = rtl8367c_getAsicReg(RTL8367C_FIELD_SELECTOR_REG(index), &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pFormat    = ((regData & RTL8367C_FIELD_SELECTOR_FORMAT_MASK) >> RTL8367C_FIELD_SELECTOR_FORMAT_OFFSET);
*pOffset    = ((regData & RTL8367C_FIELD_SELECTOR_OFFSET_MASK) >> RTL8367C_FIELD_SELECTOR_OFFSET_OFFSET);

return RT_ERR_OK;
}

The above function is used to read the fields selector register FSELn.

The field selector registers are used to select an appropriate field (format and offset) for data processing done by the ingress or egress ports. In the case of data transmission, this field is




NEXT




<s> swconfig_load_uci(struct switch_dev *dev, const char *name)
{
struct uci_context *ctx;
struct uci_package *p = NULL;
int ret = -1;

ctx = uci_alloc_context();
if (!ctx)
return;

uci_load(ctx, name, &p);
if (!p) {
uci_perror(ctx, "Failed to load config file: ");
goto out;
}

ret = swlib_apply_from_uci(dev, p);
if (ret < 0)
fprintf(stderr, "Failed to apply configuration for switch '%s'\n", dev->dev_name);

out:
uci_free_context(ctx);
exit(ret);
}

The above function is used to load UCI configuration for a certain switch_dev structure.</s>




NEXT




<s> ret_t rtl8367c_getAsicRldp8051Portmask(rtk_uint32 *pPortmask)
{
rtk_uint32 tmpPmsk;
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_RLDP_CTRL0_REG,RTL8367C_RLDP_8051_LOOP_PORTMSK_MASK,&tmpPmsk);
if(retVal != RT_ERR_OK)
return retVal;
*pPortmask = tmpPmsk & 0xff;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_RLDP_CTRL5,RTL8367C_RLDP_CTRL5_MASK,&tmpPmsk);
if(retVal != RT_ERR_OK)
return retVal;
*pPortmask |= (tmpPmsk & 7) <<8;

return RT_ERR_OK;
}

The above function is used to retrieve the portMASK used in RLDP loop detection on the chip. I’m going to be using the same value later when configuring the portmask on the 8051 side of the link.

Note that there is




NEXT




<s> static int conf_askvalue(struct symbol *sym, const char *def)
{
if (!sym_has_value(sym))
printf("(NEW) ");

line[0] = '\n';
line[1] = 0;

if (!sym_is_changeable(sym)) {
printf("%s\n", def);
line[0] = '\n';
line[1] = 0;
return 0;
}

switch (input_mode) {
case oldconfig:
case syncconfig:
if (sym_has_value(sym)) {
printf("%s\n", def);
return 0;
}
/* fall through */
default:
fflush(stdout);
xfgets(line, sizeof(line), stdin);
break;
}

return 1;
}

The above function is used to initialize the value of symbol.</s>




NEXT




<s> ret_t rtl8367c_setAsicLutIpLookupMethod(rtk_uint32 type)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LUT_IPMC_LOOKUP_OP_OFFSET, type);
}

The above function is used to set the Asic LUT ip lookup method. It takes a uint32 as input, the value can be either RTL8367C_LOOKUP_OP_IPV4_IP, RTL8367




NEXT




<s> rtk_api_ret_t rtk_trap_unknownMcastPktAction_get(rtk_port_t port, rtk_mcast_type_t type, rtk_trap_mcast_action_t *pMcast_action)
{
rtk_api_ret_t retVal;
rtk_uint32 rawAction;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (type >= MCAST_END)
return RT_ERR_INPUT;

if(NULL == pMcast_action)
return RT_ERR_NULL_POINTER;

switch (type)
{
case MCAST_L2:
if ((retVal = rtl8367c_getAsicUnknownL2MulticastBehavior(rtk_switch_port_L2P_get(port), &rawAction)) != RT_ERR_OK)
return retVal;

if(L2_UNKOWN_MULTICAST_DROP_EXCLUDE_RMA == rawAction)
*pMcast_action = MCAST_ACTION_DROP_EX_RMA;
else
*pMcast_action = (rtk_trap_mcast_action_t)rawAction;

break;
case MCAST_IPV4:
if ((retVal = rtl8367c_getAsicUnknownIPv4MulticastBehavior(rtk_switch_port_L2P_get(port), &rawAction)) != RT_ERR_OK)
return retVal;

*pMcast_action = (rtk_trap_mcast_action_t)rawAction;
break;
case MCAST_IPV6:
if ((retVal = rtl8367c_getAsicUnknownIPv6MulticastBehavior(rtk_switch_port_L2P_get(port), &rawAction)) != RT_ERR_OK)
return retVal;

*pMcast_action = (rtk_trap_mcast_action_t)rawAction;
break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to get the specific Mcast Pkt Action that will execute whenever receiving Mcast frames. This API provides three input parameters including Port(port), Mcast type(type) and Mcast Pkt Action structure(pMcast_action). Firstly




NEXT




<s> static void rtl839x_route_write(int idx, struct rtl83xx_route *rt)
{
u32 v;

/* Read ROUTING table (2) via register RTL8390_TBL_1 */
struct table_reg *r = rtl_table_get(RTL8390_TBL_1, 2);

pr_debug("In %s\n", __func__);
sw_w32(rt->nh.gw >> 16, rtl_table_data(r, 0));
v = rt->nh.gw << 16;
v |= rt->switch_mac_id << 12;
sw_w32(v, rtl_table_data(r, 1));
rtl_table_write(r, idx);

rtl_table_release(r);
}

The above function is used to write the route information to routing table which is indexed by route id. Now the problem is it will change route id (rtl_tidx) to zero.

The below code is in rtl839x_route




NEXT




<s> static int rtl8366rb_sw_get_monitor_isolation_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366RB_PMCR, &data);
if (data & RTL8366RB_PMCR_MIRROR_ISO)
val->value.i = 1;
else
val->value.i = 0;

return 0;
}

The above function is used to retrieve the RSM mirror isolation configuration information for the specific port . As we said in the previous blog, Mirror Isolation is a feature which makes traffic mirror to itself impossible even if there is no error for a certain port , the port is still




NEXT




<s> rtk_api_ret_t rtk_ptp_refTime_set(rtk_ptp_timeStamp_t timeStamp)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (timeStamp.nsec > RTK_MAX_NUM_OF_NANO_SECOND)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicEavSysTime(timeStamp.sec, timeStamp.nsec))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the reference time as system time in software. System time clock is obtained by reading the high precision OSC clock by software and this reading is passed to hardware for setting up the reference time. This reference time can either be the current system time or




NEXT




<s> static void gpio_latch_unlock(struct gpio_latch_chip *glc, bool disable)
{
if (glc->latch_enabled)
mutex_unlock(&glc->latch_mutex);

if (disable)
glc->latch_enabled = true;

mutex_unlock(&glc->mutex);
}

The above function is used to unlock the mutex in order to write values to the GPIO registers.  Note that the function only takes glc from a latch_enabled = false to latch_enabled = true and never back to latch_enabled = false. 




NEXT




<s> static inline int vr9_pp32_download_code(int pp32, u32 *code_src, unsigned int code_dword_len, u32 *data_src, unsigned int data_dword_len)
{
unsigned int clr, set;
volatile u32 *dest;

if ( code_src == 0 || ((unsigned long)code_src & 0x03) != 0
|| data_src == 0 || ((unsigned long)data_src & 0x03) != 0 )
return -1;

clr = pp32 ? 0xF0 : 0x0F;
if ( code_dword_len <= CDM_CODE_MEMORYn_DWLEN(0) )
set = pp32 ? (3 << 6): (2 << 2);
else
set = 0x00;
IFX_REG_W32_MASK(clr, set, CDM_CFG);

dest = CDM_CODE_MEMORY(pp32, 0);
while ( code_dword_len-- > 0 )
IFX_REG_W32(*code_src++, dest++);

dest = CDM_DATA_MEMORY(pp32, 0);
while ( data_dword_len-- > 0 )
IFX_REG_W32(*data_src++, dest++);

return 0;
}

The above function is used to download PP32 code and data to PP32. It will be first called in a function named IFX_PP32_DOWNLOAD_CODE to download PP32 data. It will have arguments of struct pp32* pp




NEXT




<s> ret_t rtl8367c_getAsicPriorityDecision(rtk_uint32 index, rtk_uint32 prisrc, rtk_uint32* pDecisionPri)
{
ret_t retVal;

if(index >= PRIDEC_IDX_END )
return RT_ERR_ENTRY_INDEX;

if(prisrc >= PRIDEC_END )
return RT_ERR_QOS_SEL_PRI_SOURCE;

switch(index)
{
case PRIDEC_IDX0:
if((retVal = rtl8367c_getAsicRegBits(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_REG(prisrc), RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_MASK(prisrc), pDecisionPri))!=  RT_ERR_OK)
return retVal;
break;
case PRIDEC_IDX1:
if((retVal = rtl8367c_getAsicRegBits(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_REG(prisrc), RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_MASK(prisrc), pDecisionPri))!=  RT_ERR_OK)
return retVal;
break;
default:
break;
};

return RT_ERR_OK;

}

The above function is used to get the decision for each priority source. The function return value is stored at decision parameter. We support two different type of Prio-decision register. The first one is located at QOS_INTERNAL_PRIORITY_DECISION




NEXT




<s> rtk_api_ret_t rtk_vlan_portPvid_set(rtk_port_t port, rtk_vlan_t pvid, rtk_pri_t priority)
{
rtk_api_ret_t retVal;
rtk_uint32 index;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

/* vid must be 0~8191 */
if (pvid > RTL8367C_EVIDMAX)
return RT_ERR_VLAN_VID;

/* priority must be 0~7 */
if (priority > RTL8367C_PRIMAX)
return RT_ERR_VLAN_PRIORITY;

if((retVal = rtk_vlan_checkAndCreateMbr(pvid, &index)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicVlanPortBasedVID(rtk_switch_port_L2P_get(port), index, priority)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set port VLAN port based PVID.

rtk_api_ret_t rtk_vlan_portPvid_get(rtk_port_t port, rtk_vlan_t *pvid,




NEXT




<s> rtl_init(void)
{
phy_register_fixup_for_id(PHY_ANY_ID, rtl8306_fixup);
return phy_driver_register(&rtl8306_driver, THIS_MODULE);
}

The above function is used to hook into the phy interface API to initialize.

phy_register_fixup_for_id(PHY_ANY_ID, rtl8306_fixup);

Here, we register a “fixup”




NEXT




<s> static int msdc_check_busy(struct mmc_host *mmc, struct msdc_host *host)
{
u32 err = 0;
u32 status = 0;

do {
err = msdc_get_card_status(mmc, host, &status);
if (err)
return err;
/* need cmd12? */
ERR_MSG("cmd<13> resp<0x%x>", status);
} while (R1_CURRENT_STATE(status) == 7);

return err;
}

The above function is used to send the host 12 command and wait for the response and check it is ready for the data transfer. If it is not ready, then the function will wait till it is ready.

The above function seems innocent, but do you know




NEXT




<s> ret_t rtl8367c_getAsicIGMPBypassGroup(rtk_uint32 bypassType, rtk_uint32 *pEnabled)
{
ret_t   retVal;
rtk_uint32 offset;

switch(bypassType)
{
case BYPASS_224_0_0_X:
offset = RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_0_OFFSET;
break;
case BYPASS_224_0_1_X:
offset = RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_1_OFFSET;
break;
case BYPASS_239_255_255_X:
offset = RTL8367C_IGMP_MLD_IP4_BYPASS_239_255_255_OFFSET;
break;
case BYPASS_IPV6_00XX:
offset = RTL8367C_IGMP_MLD_IP6_BYPASS_OFFSET;
break;
default:
return RT_ERR_INPUT;
}

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG3, offset, pEnabled);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the setting of the 3-tuple IGMP bypass groups on IGMP module.
It is a basic interface to read the IGMP bypass configuration.
Below is an example of bypassing multicast




NEXT




<s> fis_close(void)
{
if (fis_desc)
munmap(fis_desc, fis_erasesize);

if (fis_fd >= 0)
close(fis_fd);

fis_fd = -1;
fis_desc = NULL;
}

The above function is used to close the file descriptor
to which floppy_image is opened. This function is used
when floppy_image needs to open another floppy image.</s>




NEXT




<s> int rt2880_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 val)
{
struct fe_priv *priv = bus->priv;
int err;
u32 t;

pr_debug("%s: addr=%04x, reg=%04x, value=%04x\n", __func__,
phy_addr, phy_reg, fe_r32(FE_MDIO_ACCESS) & 0xffff);

err = rt2880_mdio_wait_ready(priv);
if (err)
return err;

t = (1 << 30) | (phy_addr << 24) | (phy_reg << 16) | val;
fe_w32(t, FE_MDIO_ACCESS);
t |= BIT(31);
fe_w32(t, FE_MDIO_ACCESS);

return rt2880_mdio_wait_ready(priv);
}

The above function is used to set a read or write register via MDIO. It’s used by every driver in our tree.</s>




NEXT




<s> static inline uint32_t le32_to_cpu(uint8_t *buf)
{
return buf[0] | buf[1] << 8 | buf[2] << 16 | buf[3] << 24;
}

The above function is used to convert a 32-bit unsigned integer from little
endian format to host byte order.

It's defined in <asm-generic/byteorder/generic.h>:

#define cpu_to_le32




NEXT




<s> static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to get input from the current source file.
A typical grammar might read `int x;`, in which case the parser would
call the above function to return the string ``int''.  Another typical
grammar might read ``a [




NEXT




<s> static inline void rtl8366_debugfs_remove(struct rtl8366_smi *smi) {}

The above function is used to remove a debug entry from smi_info in smi_ops.

However, the above function contains a bug.

In the second argument of function call:

if (mib->index == debugfs_debug_




NEXT




<s> void rt2880_port_init(struct fe_priv *priv, struct device_node *np)
{
const __be32 *id = of_get_property(np, "reg", NULL);
const __be32 *link;
int size;
phy_interface_t phy_mode = PHY_INTERFACE_MODE_NA;

if (!id || (be32_to_cpu(*id) != 0)) {
pr_err("%s: invalid port id\n", np->name);
return;
}

priv->phy->phy_fixed[0] = of_get_property(np,
"mediatek,fixed-link", &size);
if (priv->phy->phy_fixed[0] &&
(size != (4 * sizeof(*priv->phy->phy_fixed[0])))) {
pr_err("%s: invalid fixed link property\n", np->name);
priv->phy->phy_fixed[0] = NULL;
return;
}

of_get_phy_mode(np, &phy_mode);
switch (phy_mode) {
case PHY_INTERFACE_MODE_RGMII:
break;
case PHY_INTERFACE_MODE_MII:
break;
case PHY_INTERFACE_MODE_RMII:
break;
default:
if (!priv->phy->phy_fixed[0])
dev_err(priv->dev, "port %d - invalid phy mode\n",
priv->phy->speed[0]);
break;
}

priv->phy->phy_node[0] = of_parse_phandle(np, "phy-handle", 0);
if (!priv->phy->phy_node[0] && !priv->phy->phy_fixed[0])
return;

if (priv->phy->phy_fixed[0]) {
link = priv->phy->phy_fixed[0];
priv->phy->speed[0] = be32_to_cpup(link++);
priv->phy->duplex[0] = be32_to_cpup(link++);
priv->phy->tx_fc[0] = be32_to_cpup(link++);
priv->phy->rx_fc[0] = be32_to_cpup(link++);

priv->link[0] = 1;
switch (priv->phy->speed[0]) {
case SPEED_10:
break;
case SPEED_100:
break;
case SPEED_1000:
break;
default:
dev_err(priv->dev, "invalid link speed: %d\n",
priv->phy->speed[0]);
priv->phy->phy_fixed[0] = 0;
return;
}
dev_info(priv->dev, "using fixed link parameters\n");
rt2880_mdio_link_adjust(priv, 0);
return;
}

if (priv->phy->phy_node[0] && mdiobus_get_phy(priv->mii_bus, 0))
fe_connect_phy_node(priv, priv->phy->phy_node[0], 0);
}

The above function is used to parse the phandle from device tree and to initialize the phy for rtl8168. The function rt2880_port_init() is called from rt2880_ethtool_nway().




NEXT




<s> void zconfdump(FILE *out)
{
struct property *prop;
struct symbol *sym;
struct menu *menu;

menu = rootmenu.list;
while (menu) {
if ((sym = menu->sym))
print_symbol(out, menu);
else if ((prop = menu->prompt)) {
switch (prop->type) {
case P_COMMENT:
fputs("\ncomment ", out);
print_quoted_string(out, prop->text);
fputs("\n", out);
break;
case P_MENU:
fputs("\nmenu ", out);
print_quoted_string(out, prop->text);
fputs("\n", out);
break;
default:
;
}
if (!expr_is_yes(prop->visible.expr)) {
fputs("  depends ", out);
expr_fprint(prop->visible.expr, out);
fputc('\n', out);
}
}

if (menu->list)
menu = menu->list;
else if (menu->next)
menu = menu->next;
else while ((menu = menu->parent)) {
if (menu->prompt && menu->prompt->type == P_MENU)
fputs("\nendmenu\n", out);
if (menu->next) {
menu = menu->next;
break;
}
}
}
}

The above function is used to write out the main menu for zshell. When invoking zconfdump with no arguments, the main menu will be created if there are no menus to merge.

Zsh shell contains a mechanism to merge two menus into one




NEXT




<s> static int ar934x_nfc_alloc_buf(struct ar934x_nfc *nfc, unsigned size)
{
nfc->buf = dma_alloc_coherent(nfc->parent, size,
&nfc->buf_dma, GFP_KERNEL);
if (nfc->buf == NULL) {
dev_err(nfc->parent, "no memory for DMA buffer\n");
return -ENOMEM;
}

nfc->buf_size = size;
nfc_dbg(nfc, "buf:%p size:%u\n", nfc->buf, nfc->buf_size);

return 0;
}

The above function is used to allocate a DMA buffer for the NFC.</s>




NEXT




<s> ret_t rtl8367c_setAsicMacAddress(ether_addr_t mac)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint8 *accessPtr;
rtk_uint32 i;

accessPtr =  (rtk_uint8*)&mac;

regData = *accessPtr;
accessPtr ++;
regData = (regData << 8) | *accessPtr;
accessPtr ++;
for(i = 0; i <=2; i++)
{
retVal = rtl8367c_setAsicReg(RTL8367C_REG_SWITCH_MAC2 - i, regData);
if(retVal != RT_ERR_OK)
return retVal;

regData = *accessPtr;
accessPtr ++;
regData = (regData << 8) | *accessPtr;
accessPtr ++;
}

return retVal;
}

The above function is used to set the Ethernet MAC address and is currently being used in the init and set_mac of the at91mcp4410_main() function to configure the chip as an uplink router with its own MAC address of




NEXT




<s> static ssize_t rtc_read(UNUSED struct file *filp, char *buf, size_t count,
loff_t *ppos)
{
char wbuf[23];
struct rtc_time tm;
ssize_t len;

if (count == 0 || *ppos != 0)
return 0;

get_rtc_time(&tm);

len = sprintf(wbuf, "%04d:%02d:%02d:%d:%02d:%02d:%02d\n",
tm.tm_year + RTC_EPOCH,
tm.tm_mon + 1,
tm.tm_mday,
tm.tm_wday,
tm.tm_hour,
tm.tm_min,
tm.tm_sec);

if (len > (ssize_t)count)
len = count;

if (copy_to_user(buf, wbuf, len))
return -EFAULT;

*ppos += len;

return len;
}

The above function is used to read the time, it does not support random read and write, like 80286's read function.
At the beginning there is a simple judgment, if not set to 0, or it has not reached the beginning,




NEXT




<s> int cbc_aes_decrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int dec_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = dec_bytes = walk.nbytes)) {
u8 *iv = walk.iv;
dec_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_cbc(ctx, walk.dst.virt.addr, walk.src.virt.addr,
iv, dec_bytes, CRYPTO_DIR_DECRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

return err;
}

The above function is used to decrypt data using CBC mode in HW. The input provided to hardware are as follows-

1.

ctx -> enc_ctx.skey[0] : key which will be used in SBOX

ctx ->




NEXT




<s> ret_t rtl8367c_getAsicLutLearnOverAct(rtk_uint32* pAction)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_SECURITY_CTRL, RTL8367C_LUT_LEARN_OVER_ACT_MASK, pAction);
}

The above function is used to read the LUT Learn Over Action bit.  But the register description on FGPA 8367C datasheet is as below:

The bit is assigned to both PORT_SECURITY_CTRL and STATE_




NEXT




<s> ret_t rtl8367c_setAsicReg(rtk_uint32 reg, rtk_uint32 value)
{
#if defined(RTK_X86_ASICDRV)/*RTK-CNSD2-NickWu-20061222: for x86 compile*/

ret_t retVal;

retVal = Access_Write(reg,2,value);
if(TRUE != retVal) return RT_ERR_SMI;

if(0x8367B == cleDebuggingDisplay)
PRINT("W[0x%4.4x]=0x%4.4x\n",reg,value);

#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)

/*MIBs emulating*/
if(reg == RTL8367C_REG_MIB_ADDRESS)
{
CleVirtualReg[RTL8367C_MIB_COUNTER_BASE_REG] = 0x1;
CleVirtualReg[RTL8367C_MIB_COUNTER_BASE_REG+1] = 0x2;
CleVirtualReg[RTL8367C_MIB_COUNTER_BASE_REG+2] = 0x3;
CleVirtualReg[RTL8367C_MIB_COUNTER_BASE_REG+3] = 0x4;
}

if(reg >= CLE_VIRTUAL_REG_SIZE)
return RT_ERR_OUT_OF_RANGE;

CleVirtualReg[reg] = value;

if(0x8367B == cleDebuggingDisplay)
PRINT("W[0x%4.4x]=0x%4.4x\n",reg,CleVirtualReg[reg]);

#elif defined(EMBEDDED_SUPPORT)
if(reg > RTL8367C_REGDATAMAX || value > RTL8367C_REGDATAMAX )
return RT_ERR_INPUT;

setReg(reg, value);

#else
ret_t retVal;

retVal = smi_write(reg, value);
if(retVal != RT_ERR_OK)
return RT_ERR_SMI;
#ifdef CONFIG_RTL865X_CLE
if(0x8367B == cleDebuggingDisplay)
PRINT("W[0x%4.4x]=0x%4.4x\n",reg,value);
#endif

#endif

return RT_ERR_OK;
}

The above function is used to access and write to the general registers in ASIC. When a device
is embedded in a system, it is sometimes difficult to write to the registers due to lack of system
configuration and the embedded ASIC registers might not be accessible by the S




NEXT




<s> static int aw9523_init_gpiochip(struct aw9523 *awi, unsigned int npins)
{
struct device *dev = awi->dev;
struct gpio_chip *gpiochip = &awi->gpio;

gpiochip->label = devm_kstrdup(dev, dev_name(dev), GFP_KERNEL);
if (!gpiochip->label)
return -ENOMEM;

gpiochip->base = -1;
gpiochip->ngpio = npins;
gpiochip->get_direction = aw9523_gpio_get_direction;
gpiochip->direction_input = aw9523_direction_input;
gpiochip->direction_output = aw9523_direction_output;
gpiochip->get = aw9523_gpio_get;
gpiochip->get_multiple = aw9523_gpio_get_multiple;
gpiochip->set = aw9523_gpio_set;
gpiochip->set_multiple = aw9523_gpio_set_multiple;
gpiochip->set_config = gpiochip_generic_config;
gpiochip->parent = dev;
gpiochip->of_node = dev->of_node;
gpiochip->owner = THIS_MODULE;
gpiochip->can_sleep = true;

return 0;
}

The above function is used to initialize the GPIO chip. The GPIO chips are used to control the pins on the board. The first line of the function creates a pointer to the GPIO chip. The second line sets the label of the GPIO chip. The third line sets the base




NEXT




<s> ar8327_sw_get_port_igmp_snooping(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
int port = val->port_vlan;

if (port >= dev->ports)
return -EINVAL;

mutex_lock(&priv->reg_mutex);
val->value.i = ar8327_get_port_igmp(priv, port);
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to obtain IGMP status (0 or 1) on an IGMP port. This function is called during init to fill up the initial information about those ports in SMI database. Also we use this function to change IGMP sno




NEXT




<s> static int rtl8214c_phy_probe(struct phy_device *phydev)
{
struct device *dev = &phydev->mdio.dev;
int addr = phydev->mdio.addr;

/* All base addresses of the PHYs start at multiples of 8 */
devm_phy_package_join(dev, phydev, addr & (~7),
sizeof(struct rtl83xx_shared_private));

if (!(addr % 8)) {
struct rtl83xx_shared_private *shared = phydev->shared->priv;
shared->name = "RTL8214C";
/* Configuration must be done whil patching still possible */
return rtl8380_configure_rtl8214c(phydev);
}

return 0;
}

The above function is used to probe rtl8214c
phy. I got rtl83xx from r8153 since r83xx used
very similar implementation at rtl83xx.

For me in this case, I




NEXT




<s> parse_message(struct ead_packet *pkt, int len)
{
bool (*handler)(struct ead_packet *pkt, int len, int *nstate);
int min_len = sizeof(struct ead_packet);
int nstate = state;
int type = ntohl(pkt->msg.type);

if ((type >= EAD_TYPE_GET_PRIME) &&
(state != type))
return;

if ((type != EAD_TYPE_PING) &&
((ntohs(pkt->msg.sid) & EAD_INSTANCE_MASK) >>
EAD_INSTANCE_SHIFT) != instance->id)
return;

switch(type) {
case EAD_TYPE_PING:
handler = handle_ping;
break;
case EAD_TYPE_SET_USERNAME:
handler = handle_set_username;
min_len += sizeof(struct ead_msg_user);
break;
case EAD_TYPE_GET_PRIME:
handler = handle_get_prime;
break;
case EAD_TYPE_SEND_A:
handler = handle_send_a;
min_len += sizeof(struct ead_msg_number);
break;
case EAD_TYPE_SEND_AUTH:
handler = handle_send_auth;
min_len += sizeof(struct ead_msg_auth);
break;
case EAD_TYPE_SEND_CMD:
handler = handle_send_cmd;
min_len += sizeof(struct ead_msg_cmd) + sizeof(struct ead_msg_encrypted);
break;
default:
return;
}

if (len < min_len) {
DEBUG(2, "discarding packet: message too small\n");
return;
}

pktbuf->msg.magic = htonl(EAD_MAGIC);
pktbuf->msg.type = htonl(type + 1);
pktbuf->msg.nid = htons(nid);
pktbuf->msg.sid = pkt->msg.sid;
pktbuf->msg.len = 0;

if (handler(pkt, len, &nstate)) {
DEBUG(2, "sending response to packet type %d: %d\n", type + 1, ntohl(pktbuf->msg.len));
/* format response packet */
ead_send_packet_clone(pkt);
}
set_state(nstate);
}

The above function is used to parse the actual input from client, and also the responses received from other clients to handle. The handler function pointer points to the relevant functions in order to handle the request.

In example 2, the function handle_send_a(.)




NEXT




<s> ar8xxx_mib_op(struct ar8xxx_priv *priv, u32 op)
{
unsigned mib_func = priv->chip->mib_func;
int ret;

lockdep_assert_held(&priv->mib_lock);

/* Capture the hardware statistics for all ports */
ar8xxx_rmw(priv, mib_func, AR8216_MIB_FUNC, (op << AR8216_MIB_FUNC_S));

/* Wait for the capturing to complete. */
ret = ar8xxx_reg_wait(priv, mib_func, AR8216_MIB_BUSY, 0, 10);
if (ret)
goto out;

ret = 0;

out:
return ret;
}

The above function is used to capture the hardware statistics for all ports on the switch. It is used by the AR8216 device to gather port statistics such as incoming and outgoing packets, transmitted bytes, and received bytes (AR) and transmitted errors (CR




NEXT




<s> mvswitch_read_status(struct phy_device *pdev)
{
pdev->speed = SPEED_100;
pdev->duplex = DUPLEX_FULL;
pdev->link = 1;

/* XXX ugly workaround: we can't force the switch
* to gracefully handle hosts moving from one port to another,
* so we have to regularly clear the ATU database */

/* wait for the ATU to become available */
mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);

/* flush the ATU */
w16(pdev, MV_SWITCHREG(ATU_OP),
MV_ATUOP_INPROGRESS |
MV_ATUOP_FLUSH_ALL
);

/* wait for operation to complete */
mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);

return 0;
}

The above function is used to probe the mvswitch and can be used to read out the properties of the phy using 16bit io reads.

The following question arose.

If I were to get the mvswitch to 10 G




NEXT




<s> ar8216_atu_flush(struct ar8xxx_priv *priv)
{
int ret;

ret = ar8216_wait_bit(priv, AR8216_REG_ATU_FUNC0, AR8216_ATU_ACTIVE, 0);
if (!ret)
ar8xxx_write(priv, AR8216_REG_ATU_FUNC0, AR8216_ATU_OP_FLUSH |
AR8216_ATU_ACTIVE);

return ret;
}

The above function is used to invalidate the ATU cache entries. In case of V4L driver (i.e. v4l2 mxc), on calling ar8216_atu_open, this flush will be done. Also it will be fl




NEXT




<s> show_global(struct switch_dev *dev)
{
struct switch_val val;

printf("Global attributes:\n");
show_attrs(dev, dev->ops, &val);
}

The above function is used to display the global attributes of the switch. It first calls the show_attrs function, which is a part of the switch operation to display the attributes.

In conclusion, the show_attrs function is a part of the switch operation used to display




NEXT




<s> static inline int rtl930x_l2_port_new_salrn(int p)
{
return RTL930X_L2_PORT_SALRN(p);
}

The above function is used to translate an port number into a logical port number used by lldp in the RTL930X. However, on my RTL930X, all lldp port numbers are 0. This is because the function conver




NEXT




<s> static int rtl83xx_mc_group_alloc(struct rtl838x_switch_priv *priv, int port)
{
int mc_group = find_first_zero_bit(priv->mc_group_bm, MAX_MC_GROUPS - 1);
u64 portmask;

if (mc_group >= MAX_MC_GROUPS - 1)
return -1;

set_bit(mc_group, priv->mc_group_bm);
portmask = BIT_ULL(port);
priv->r->write_mcast_pmask(mc_group, portmask);

return mc_group;
}

The above function is used to find a free mc_group member and then map the MC table. The following bug is introduced by the code.

if (mc_group >= MAX_MC_GROUPS - 1)
return -1;

We




NEXT




<s> static int rfc3686_aes_setkey(struct crypto_ablkcipher *tfm,
const u8 *in_key, unsigned int keylen)
{
struct aes_ctx *ctx = crypto_ablkcipher_ctx(tfm);
unsigned long *flags = (unsigned long *)&tfm->base.crt_flags;

DPRINTF(2, "ctr_rfc3686_aes_set_key in %s\n", __FILE__);

memcpy(ctx->nonce, in_key + (keylen - CTR_RFC3686_NONCE_SIZE),
CTR_RFC3686_NONCE_SIZE);

keylen -= CTR_RFC3686_NONCE_SIZE; // remove 4 bytes of nonce

if (keylen != 16 && keylen != 24 && keylen != 32) {
*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
return -EINVAL;
}

ctx->key_length = keylen;

memcpy ((u8 *) (ctx->buf), in_key, keylen);

return 0;
}

The above function is used to set the keys of RFC 3686 counter mode.

The input key contains a 4 byte nonce prefixed to the key. The nonce is
always of size 4 bytes. Next comes the actual key.




NEXT




<s> static int rtl8214fc_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)
{
struct phy_device *phydev = upstream;

rtl8214fc_media_set(phydev, true);

return 0;
}

The above function is used to configure the phy device when it is plugged out or a new phy is plugged in.

It is used to set the link status. But when testing on Intel Corporation Integrated Network 10/100/1




NEXT




<s> ret_t rtl8367c_setAsicLutLearnLimitNo(rtk_uint32 port, rtk_uint32 number)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(number > RTL8367C_LUT_LEARNLIMITMAX)
return RT_ERR_LIMITED_L2ENTRY_NUM;

if(port < 8)
return rtl8367c_setAsicReg(RTL8367C_LUT_PORT_LEARN_LIMITNO_REG(port), number);
else
return rtl8367c_setAsicReg(RTL8367C_REG_LUT_PORT8_LEARN_LIMITNO+port-8, number);

}

The above function is used to set LUT Learn limit. (port 0~7: RTL8367C_LUT_PORT_LEARN_LIMITNO_REG(port); port 8~31: RTL8367




NEXT




<s> int dc_ep_dev_num_get(int *dev_num)
{
if ((g_dc_ep_info.dev_num <= 0)
|| (g_dc_ep_info.dev_num > DC_EP_MAX_NUM))
return -EIO;

*dev_num = g_dc_ep_info.dev_num;
return 0;
}

The above function is used to obtain the number of DC
channel that exists in the device. The number of DC
channel in a device is defined by the constant
DC_EP_MAX_NUM.

#
8.4 DC Channel Management Functions






NEXT




<s> extern void	rtcl_838x_dram_start(void);
extern int	rtcl_838x_dram_size;

extern void	(*rtcl_838x_dram_set_rate)(int clk_idx, int ctrl0, int ctrl1);
static void	(*rtcl_838x_sram_set_rate)(int clk_idx, int ctrl0, int ctrl1);

extern void	rtcl_839x_dram_start(void);
extern int	rtcl_839x_dram_size;

extern void	(*rtcl_839x_dram_set_rate)(int clk_idx, int ctrl0, int ctrl1);
static void	(*rtcl_839x_sram_set_rate)(int clk_idx, int ctrl0, int ctrl1);

/*
* clock setter/getter functions
*/

static unsigned long rtcl_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
{
struct rtcl_clk *clk = rtcl_hw_to_clk(hw);
unsigned int ctrl0, ctrl1, div1, div2, cmu_ncode_in;
unsigned int cmu_sel_prediv, cmu_sel_div4, cmu_divn2, cmu_divn2_selb, cmu_divn3_sel;

if ((clk->idx >= CLK_COUNT) || (!rtcl_ccu) || (rtcl_ccu->soc >= SOC_COUNT))
return 0;

ctrl0 = read_sw(rtcl_regs[rtcl_ccu->soc][REG_CTRL0][clk->idx]);
ctrl1 = read_sw(rtcl_regs[rtcl_ccu->soc][REG_CTRL1][clk->idx]);

cmu_sel_prediv = 1 << RTL_PLL_CTRL0_CMU_SEL_PREDIV(ctrl0);
cmu_sel_div4 = RTL_PLL_CTRL0_CMU_SEL_DIV4(ctrl0) ? 4 : 1;
cmu_ncode_in = RTL_PLL_CTRL0_CMU_NCODE_IN(ctrl0) + 4;
cmu_divn2 = RTL_PLL_CTRL0_CMU_DIVN2(ctrl0) + 4;

switch (rtcl_ccu->soc) {
case SOC_RTL838X:
if ((ctrl0 == 0) && (ctrl1 == 0) && (clk->idx == CLK_LXB))
return 200000000;

cmu_divn2_selb = RTL838X_PLL_CTRL1_CMU_DIVN2_SELB(ctrl1);
cmu_divn3_sel = rtcl_divn3[RTL838X_PLL_CTRL1_CMU_DIVN3_SEL(ctrl1)];
break;
case SOC_RTL839X:
cmu_divn2_selb = RTL839X_PLL_CTRL1_CMU_DIVN2_SELB(ctrl1);
cmu_divn3_sel = rtcl_divn3[RTL839X_PLL_CTRL1_CMU_DIVN3_SEL(ctrl1)];
break;
}
div1 = cmu_divn2_selb ? cmu_divn3_sel : cmu_divn2;
div2 = rtcl_xdiv[clk->idx];

return (((parent_rate / 16) * cmu_ncode_in) / (div1 * div2)) *
cmu_sel_prediv * cmu_sel_div4 * 16;
}

The above function is used to make rtcl get the proper rate in the clk_set_rate function.

clk_set_parent_rate is the function that handles the dynamic rate setting as well as using the same divider when the clock parent changes for the user




NEXT




<s> static char *do_warning_if(int argc, char *argv[])
{
if (!strcmp(argv[0], "y"))
fprintf(stderr, "%s:%d: %s\n",
current_file->name, yylineno, argv[1]);

return xstrdup("");
}

The above function is used to output a warning.

However, when using the gcc compiler, and gcc version is "gcc (gcc) 4.2.0 20060410
(Release) [cobra




NEXT




<s> static uint32_t nmbm_get_spare_block_count(uint32_t block_count)
{
uint32_t val;

val = (block_count + NMBM_SPARE_BLOCK_DIV / 2) / NMBM_SPARE_BLOCK_DIV;
val *= NMBM_SPARE_BLOCK_MULTI;

if (val < NMBM_SPARE_BLOCK_MIN)
val = NMBM_SPARE_BLOCK_MIN;

return val;
}

The above function is used to calculate the number of spare blocks that are being allocated for a
file. If 'block_count' is a multiple of NMBM_SPARE_BLOCK_DIV, the spare block count will be the same
for this file as




NEXT




<s> ret_t rtl8367c_setAsicSvlanSP2CConf(rtk_uint32 index, rtl8367c_svlan_s2c_t* pSvlanSp2cCfg)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint16 *accessPtr;
rtk_uint32 i;
rtk_uint16 smiSvlanSP2C[RTL8367C_SVLAN_SP2C_LEN];

if(index > RTL8367C_SP2CMAX)
return RT_ERR_ENTRY_INDEX;

memset(smiSvlanSP2C, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_SP2C_LEN);
_rtl8367c_svlanSp2cStUser2Smi(pSvlanSp2cCfg,smiSvlanSP2C);

accessPtr = smiSvlanSP2C;

regData = *accessPtr;
for(i = 0; i < 2; i++)
{
retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_S2C_ENTRY_BASE_REG(index) + i, regData);
if(retVal != RT_ERR_OK)
return retVal;

accessPtr ++;
regData = *accessPtr;
}

return retVal;
}

The above function is used to set the SP2C table based on the input SP2C configuration table as a parameter. Each row of the table is programed to the chip as 2 registers(4 bytes).

The SVLAN_S2C_ENTRY_




NEXT




<s> static int ecb_arc4_decrypt(struct skcipher_request *req)
{
struct arc4_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
unsigned int nbytes;
int err;

DPRINTF(1, "\n");
err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = walk.nbytes)) {
_deu_arc4_ecb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
NULL, nbytes, CRYPTO_DIR_DECRYPT, 0);
nbytes &= ARC4_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

return err;
}

The above function is used to decrypt data using ecb_cipher mode. In
this function we call the _deu_arc4_ecb function which is used to
implement the actual cipher algorithm. But the most interesting thing
is that the _




NEXT




<s> rtk_api_ret_t rtk_port_rtctDisable_set(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Mask Valid */
RTK_CHK_PORTMASK_VALID_ONLY_UTP(pPortmask);

if ((retVal = rtl8367c_setAsicPortRTCTDisable(pPortmask->bits[0]))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to disable the MAC rate control time-out.


rpk_rtct_disable = 0,

{.f = rtk_port_rtctDisable_set},

rtk_port_rtct_




NEXT




<s> ret_t rtl8367c_setAsicUnknownMulticastTrapPriority(rtk_uint32 priority)
{
if(priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBits(RTL8367C_QOS_TRAP_PRIORITY_CTRL0_REG, RTL8367C_UNKNOWN_MC_PRIORTY_MASK, priority);
}

The above function is used to set the priority of multicast frames if the filter matched it's own mac.
In my tests, this function should be called before rtl8367c_setAsicAsicMulticastFilter.
When this




NEXT




<s> static int preprocess_write(u32 orig_data, u32 val, int where,
unsigned int size)
{
u32 ret = 0;

switch (size) {
case 1:
ret = (orig_data & ~(0xff << ((where & 3) << 3))) |
(val << ((where & 3) << 3));
break;
case 2:
ret = (orig_data & ~(0xffff << ((where & 3) << 3))) |
(val << ((where & 3) << 3));
break;
case 4:
ret = val;
break;
}

return ret;
}

The above function is used to set/change  the 1,2,4 byte of the bus value.
When we need a write op, we need to translate the value to that form.

And the post_write does the opposite operation.

Al




NEXT




<s> static int ip17xx_aneg_done(struct phy_device *pdev)
{
return 1;	/* Return any positive value */
}

The above function is used to signal to the rest of the stack that the
Auto Negotiation procedure completed successfully. The above function is
usually used with the following line in the NVM_ANEG structure which is
configured during system initializsation




NEXT




<s> static void inline MEI_MASK_AND_ACK_IRQ(int x)
{
struct irq_data d;
d.hwirq = x;
ltq_mask_and_ack_irq(&d);
}

The above function is used to mask and acknowledge an IRQ and as a result,
it will call the __irq_chip_mask/__irq_chip_unmask functions of the relevant
irqchip.

The purpose of this proposal is to have the same




NEXT




<s> SHA256_Update(SHA256_CTX * ctx, const void *in, size_t len)
{
uint64_t bitlen;
uint32_t r;
const unsigned char *src = in;

/* Number of bytes left in the buffer from previous updates */
r = (ctx->count >> 3) & 0x3f;

/* Convert the length into a number of bits */
bitlen = len << 3;

/* Update number of bits */
ctx->count += bitlen;

/* Handle the case where we don't need to perform any transforms */
if (len < 64 - r) {
memcpy(&ctx->buf[r], src, len);
return;
}

/* Finish the current block */
memcpy(&ctx->buf[r], src, 64 - r);
SHA256_Transform(ctx->state, ctx->buf);
src += 64 - r;
len -= 64 - r;

/* Perform complete blocks */
while (len >= 64) {
SHA256_Transform(ctx->state, src);
src += 64;
len -= 64;
}

/* Copy left over data into buffer */
memcpy(ctx->buf, src, len);
}

The above function is used to add the last bytes to the SHA256 state. For a more complete understanding I would like to point you to CACertification where a much better explanation can be found.

You can run this code using gcc to see that




NEXT




<s> int mtk_gsw_init(struct fe_priv *priv)
{
struct device_node *eth_node = priv->dev->of_node;
struct device_node *phy_node, *mdiobus_node;
struct device_node *np = priv->switch_np;
struct platform_device *pdev = of_find_device_by_node(np);
struct mt7620_gsw *gsw;
const __be32 *id;
int ret;
u8 val;

if (!pdev)
return -ENODEV;

if (!of_device_is_compatible(np, mediatek_gsw_match->compatible))
return -EINVAL;

gsw = platform_get_drvdata(pdev);
priv->soc->swpriv = gsw;

gsw->ephy_disable = of_property_read_bool(np, "mediatek,ephy-disable");

mdiobus_node = of_get_child_by_name(eth_node, "mdio-bus");
if (mdiobus_node) {
for_each_child_of_node(mdiobus_node, phy_node) {
id = of_get_property(phy_node, "reg", NULL);
if (id && (be32_to_cpu(*id) == 0x1f))
gsw->ephy_disable = true;
}

of_node_put(mdiobus_node);
}

gsw->port4_ephy = !of_property_read_bool(np, "mediatek,port4-gmac");

if (of_property_read_u8(np, "mediatek,ephy-base", &val) == 0)
gsw->ephy_base = val;
else
gsw->ephy_base = 0;

mt7620_mac_init(gsw);

mt7620_ephy_init(gsw);

if (gsw->irq) {
ret = request_irq(gsw->irq, gsw_interrupt_mt7620, 0,
"gsw", priv);
if (ret) {
dev_err(&pdev->dev, "Failed to request irq");
return ret;
}
mtk_switch_w32(gsw, ~PORT_IRQ_ST_CHG, GSW_REG_IMR);
}

return 0;
}

The above function is used to initialize the mtk_gsw_init structure in mac80211_core.c. During the initialization process, the interrupt register IRQ is registered, and the function pointer interrupt_mt7620 is used as the




NEXT




<s> static void rtl930x_host_route_read(int idx, struct rtl83xx_route *rt)
{
u32 v;
/* Read L3_HOST_ROUTE_IPUC table (1) via register RTL9300_TBL_1 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_1, 1);

idx = ((idx / 6) * 8) + (idx % 6);

pr_debug("In %s, physical index %d\n", __func__, idx);
rtl_table_read(r, idx);
/* The table has a size of 5 (for UC, 11 for MC) registers */
v = sw_r32(rtl_table_data(r, 0));
rt->attr.valid = !!(v & BIT(31));
if (!rt->attr.valid)
goto out;
rt->attr.type = (v >> 29) & 0x3;
switch (rt->attr.type) {
case 0: /* IPv4 Unicast route */
rt->dst_ip = sw_r32(rtl_table_data(r, 4));
break;
case 2: /* IPv6 Unicast route */
ipv6_addr_set(&rt->dst_ip6,
sw_r32(rtl_table_data(r, 3)), sw_r32(rtl_table_data(r, 2)),
sw_r32(rtl_table_data(r, 1)), sw_r32(rtl_table_data(r, 0)));
break;
case 1: /* IPv4 Multicast route */
case 3: /* IPv6 Multicast route */
pr_warn("%s: route type not supported\n", __func__);
goto out;
}

rt->attr.hit = !!(v & BIT(20));
rt->attr.dst_null = !!(v & BIT(19));
rt->attr.action = (v >> 17) & 3;
rt->nh.id = (v >> 6) & 0x7ff;
rt->attr.ttl_dec = !!(v & BIT(5));
rt->attr.ttl_check = !!(v & BIT(4));
rt->attr.qos_as = !!(v & BIT(3));
rt->attr.qos_prio =  v & 0x7;
pr_debug("%s: index %d is valid: %d\n", __func__, idx, rt->attr.valid);
pr_debug("%s: next_hop: %d, hit: %d, action :%d, ttl_dec %d, ttl_check %d, dst_null %d\n",
__func__, rt->nh.id, rt->attr.hit, rt->attr.action, rt->attr.ttl_dec, rt->attr.ttl_check,
rt->attr.dst_null);
pr_debug("%s: Destination: %pI4\n", __func__, &rt->dst_ip);

out:
rtl_table_release(r);
}

The above function is used to read route table from 24 registers. Here is the layout of the registers:

- RTL9300_TBL_1
+
+0 | 1 | 2 | 3 | 4 | 




NEXT




<s> static int sha1_hmac_transform(struct shash_desc *desc, u32 const *in)
{
struct sha1_hmac_ctx *sctx =  crypto_shash_ctx(desc->tfm);

if ( ((sctx->dbn<<4)+1) > SHA1_HMAC_DBN_TEMP_SIZE )
{
//printk("SHA1_HMAC_DBN_TEMP_SIZE exceeded\n");
sha1_hmac_final_impl(desc, (u8 *)sctx->hash, false);
}

memcpy(&sctx->temp[sctx->dbn], in, 64); //dbn workaround
sctx->dbn += 1;

return 0;
}

The above function is used to update the context of SHA1-HMAC. The issue is that the context, if 64-byte aligned, will overflow. The SHA1-HMAC implementation only has 56 bytes in the temporary buffer, and this overflow over




NEXT




<s> static int avl_compare_macaddr(const void *k1, const void *k2, void *ptr)
{
return memcmp(k1, k2, ETH_ALEN);
}

The above function is used to compare two network interface addresses to
sort them in the table.

However, instead of always using this function, I think it would be
better to store the network addresses themselves in some format, like
IPv4, that can




NEXT




<s> static void __exit rtl8366rb_module_exit(void)
{
platform_driver_unregister(&rtl8366rb_driver);
}

The above function is used to "release" the platform driver. platform_driver_unregister() is used to release the reference to the platform driver.

What are the side-effects if you remove and install the platform driver in the running system?

What happens




NEXT




<s> static int ltq_deu_remove(struct platform_device *pdev)
{
//#ifdef CONFIG_CRYPTO_DEV_PWR_SAVE_MODE
#if defined(CONFIG_CRYPTO_DEV_DES)
ifxdeu_fini_des ();
#endif
#if defined(CONFIG_CRYPTO_DEV_AES)
ifxdeu_fini_aes ();
#endif
#if defined(CONFIG_CRYPTO_DEV_ARC4)
ifxdeu_fini_arc4 ();
#endif
#if defined(CONFIG_CRYPTO_DEV_SHA1)
ifxdeu_fini_sha1 ();
#endif
#if defined(CONFIG_CRYPTO_DEV_MD5)
ifxdeu_fini_md5 ();
#endif
#if defined(CONFIG_CRYPTO_DEV_SHA1_HMAC)
ifxdeu_fini_sha1_hmac ();
#endif
#if defined(CONFIG_CRYPTO_DEV_MD5_HMAC)
ifxdeu_fini_md5_hmac ();
#endif
printk("DEU has exited successfully\n");

return 0;
}

The above function is used to de-initialize/exit when a crypto driver uses the same crypto hardware. The Linux security patch LKMSecurity_20150509 allows a malicious user to execute arbitrary code due to incorrect device de-initialization




NEXT




<s> static int rtl83xx_delete_flower(struct rtl838x_switch_priv *priv,
struct flow_cls_offload * cls_flower)
{
struct rtl83xx_flow *flow;

pr_debug("In %s\n", __func__);
rcu_read_lock();
flow = rhashtable_lookup_fast(&priv->tc_ht, &cls_flower->cookie, tc_ht_params);
if (!flow) {
rcu_read_unlock();
return -EINVAL;
}

priv->r->pie_rule_rm(priv, &flow->rule);

rhashtable_remove_fast(&priv->tc_ht, &flow->node, tc_ht_params);

kfree_rcu(flow, rcu_head);

rcu_read_unlock();

return 0;
}

The above function is used to remove a flower from RTL83xx Flow Controller’s
hashtable. To remove a flower, it should find a flower with the same cookie ID as
provided using the rhashtable_lookup_fast() function.




NEXT




<s> static int rtl83xx_port_lag_change(struct dsa_switch *ds, int port)
{
pr_debug("%s: %d\n", __func__, port);
/* Nothing to be done... */

return 0;
}

The above function is used to notify the NAPI polling logic while port is changed due to LAG(link aggregation). This happens when link is added or removed from LAG.

I am using this logic as a generic one since there is no specific function defined




NEXT




<s> static void rtk_dump_mib_type(rtk_stat_port_type_t cntr_idx)
{
rtk_port_t port;
rtk_stat_counter_t Cntr;

for (port = UTP_PORT0; port < (UTP_PORT0 + 5); port++) {
rtk_stat_port_get(port, cntr_idx, &Cntr);
printk("%8llu", Cntr);
}

for (port = EXT_PORT0; port < (EXT_PORT0 + 2); port++) {
rtk_stat_port_get(port, cntr_idx, &Cntr);
printk("%8llu", Cntr);
}

printk("\n");
}

The above function is used to print the value of the counter registers on ROM code. Since all the counters are declared in the struct type rtk_rtk_mib_stat_type.
After the MIB_TYPE is configured to 0x0




NEXT




<s> static void uc_gc_timer(struct uloop_timeout *timeout)
{
ucv_gc(&vm);
}

The above function is used to periodically trigger the UCV garbage collection. We have to firstly create an event with a timer of 3 seconds. Then, we create a uloop object that will hold the function we are going to attach to the event above. As a




NEXT




<s> slen = BigIntegerToBytes(S, sbuf);

BigIntegerFree(S);
BigIntegerFree(res);
BigIntegerFree(b);
BigIntegerFree(n);

t_sessionkey(ts->session_key, sbuf, slen);
memset(sbuf, 0, slen);

SHA1Update(&ts->oldhash, ts->session_key, sizeof(ts->session_key));
SHA1Update(&ts->oldckhash, ts->session_key, sizeof(ts->session_key));
SHA1Update(&ts->ckhash, ts->session_key, sizeof(ts->session_key));

return ts->session_key;
}

_TYPE( int )
t_serververify(ts, resp)
struct t_server * ts;
unsigned char * resp;
{

The above function is used to verify the session key generated in the first two functions t_clientkey and sessionkey. The key generated here is compared with the key that was previously generated.

The steps to be followed are as follows:
  1. Allocating




NEXT




<s> static void ar934x_nfc_restart(struct ar934x_nfc *nfc);

static inline bool is_all_ff(u8 *buf, int len)
{
while (len--)
if (buf[len] != 0xff)
return false;

return true;
}

The above function is used to check the end of data

The buffer size is sent to the NFC chip via the NFC_SID

This is implemented as a 16-bit word

The value sent to the NFC is

0




NEXT




<s> static void ubnt_ledbar_perform_transaction(struct ubnt_ledbar *ledbar,
const char *transaction, int len,
char *result, int result_len)
{
int i;

for (i = 0; i < len; i++)
i2c_smbus_write_byte(ledbar->client, transaction[i]);

for (i = 0; i < result_len; i++)
result[i] = i2c_smbus_read_byte(ledbar->client);
}

The above function is used to send commands, such as SET to the client,
receive responses, etc.

I had to use a similar function to send ETHERNET command to a client to
receive ETHERNET address (for example).</s>




NEXT




<s> static char *hash_string(unsigned char *buf, int len)
{
static char str[SHA256_DIGEST_LENGTH * 2 + 1];
int i;

if (len * 2 + 1 > sizeof(str))
return NULL;

for (i = 0; i < len; i++)
sprintf(&str[i * 2], "%02x", buf[i]);

return str;
}

The above function is used to convert a binary array to an hexadecimal string.</s>




NEXT




<s> gettcid
(id)
int id;
{
struct t_preconf *tcp;

if (id <= 0 || id > t_getprecount()) {
return NULL;
}
tcp = t_getpreparam(id - 1);
sysconf.index = id;
sysconf.modulus = tcp->modulus;
sysconf.generator = tcp->generator;

return &sysconf;
}

The above function is used to store the tclint value in the sysconf structure. This value (t_getpremodulus()) is also a parameter of the SHA1 hash algorithm. This value will be used to store the data to be hashed by this algorithm.




NEXT




<s> mtk_bmt_read(struct mtd_info *mtd, loff_t from,
struct mtd_oob_ops *ops)
{
struct mtd_oob_ops cur_ops = *ops;
int retry_count = 0;
loff_t cur_from;
int ret = 0;
int max_bitflips = 0;

ops->retlen = 0;
ops->oobretlen = 0;

while (ops->retlen < ops->len || ops->oobretlen < ops->ooblen) {
int cur_ret;

u32 offset = from & (bmtd.blk_size - 1);
u32 block = from >> bmtd.blk_shift;
int cur_block;

cur_block = bmtd.ops->get_mapping_block(block);
if (cur_block < 0)
return -EIO;

cur_from = ((loff_t)cur_block << bmtd.blk_shift) + offset;

cur_ops.oobretlen = 0;
cur_ops.retlen = 0;
cur_ops.len = min_t(u32, mtd->erasesize - offset,
ops->len - ops->retlen);
cur_ret = bmtd._read_oob(mtd, cur_from, &cur_ops);
if (cur_ret < 0)
ret = cur_ret;
else
max_bitflips = max_t(int, max_bitflips, cur_ret);
if (cur_ret < 0 && !mtd_is_bitflip(cur_ret)) {
if (mtk_bmt_remap_block(block, cur_block, mtd->erasesize) &&
retry_count++ < 10)
continue;

goto out;
}

if (mtd->bitflip_threshold && cur_ret >= mtd->bitflip_threshold)
mtk_bmt_remap_block(block, cur_block, mtd->erasesize);

ops->retlen += cur_ops.retlen;
ops->oobretlen += cur_ops.oobretlen;

cur_ops.ooboffs = 0;
cur_ops.datbuf += cur_ops.retlen;
cur_ops.oobbuf += cur_ops.oobretlen;
cur_ops.ooblen -= cur_ops.oobretlen;

if (!cur_ops.len)
cur_ops.len = mtd->erasesize - offset;

from += cur_ops.len;
retry_count = 0;
}

out:
if (ret < 0)
return ret;

return max_bitflips;
}

The above function is used to read the data on NAND Flash for which the BMT (Bad Block Table) has to be maintained in order to prevent any kind of hardware failure. This table helps to maintain the blocks present in a NAND memory that are defective. It




NEXT




<s> free(a);
return size - j + 1;
}

/*
* Convert a raw byte string into a null-terminated base64 ASCII string.
*/
_TYPE( char * )
t_tob64(dst, src, size)
register char *dst, *src;
register unsigned size;
{

The above function is used to convert a text string into an unformatted
base64 ASCII text string. The function does not allocate or return memory;
the caller must supply a destination buffer and handle overflow. This is
part of a series of text-




NEXT




<s> rtk_api_ret_t rtk_port_rgmiiDelayExt_get(rtk_port_t port, rtk_data_t *pTxDelay, rtk_data_t *pRxDelay)
{
rtk_api_ret_t retVal;
rtk_uint32 regAddr, regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_EXT(port);

if( (NULL == pTxDelay) || (NULL == pRxDelay) )
return RT_ERR_NULL_POINTER;

if(port == EXT_PORT0)
regAddr = RTL8367C_REG_EXT1_RGMXF;
else if(port == EXT_PORT1)
regAddr = RTL8367C_REG_EXT2_RGMXF;
else
return RT_ERR_INPUT;

if ((retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
return retVal;

*pTxDelay = (regData & 0x0008) >> 3;
*pRxDelay = regData & 0x0007;

return RT_ERR_OK;
}

The above function is used to get the receiver and transmitter relative delay for external PHY port(s), which is 2 bits.

/* ------------------------------------------------------------
*/
rtk_api_ret_t rtk_port_rgmiiDelay




NEXT




<s> static void wpas_ubus_ref_inc(void)
{
ctx_ref++;
}

The above function is used to increase the reference count of a ubus
context, and it is called each time such a context is accessed.
Unfortunately, there is a race condition between wpas_ubus_ref_inc and
wpas_ubus_




NEXT




<s> static int b53_mdio_write16(struct b53_device *dev, u8 page, u8 reg,
u16 value)
{
struct mii_bus *bus = dev->priv;
int ret;

ret = mdiobus_write(bus, B53_PSEUDO_PHY, REG_MII_DATA0, value);
if (ret)
return ret;

return b53_mdio_op(dev, page, reg, REG_MII_ADDR_WRITE);
}

The above function is used to both write and read MII registers after setting a page register. It’s used in a lot of places. This code is wrong in several ways:

1. It writes 16 bits of data to the MDIO bus at once




NEXT




<s> ret_t rtl8367c_setAsicFlowControlPauseAllThreshold(rtk_uint32 threshold)
{
if(threshold >= RTL8367C_PAGE_NUMBER)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_ALL_ON, RTL8367C_FLOWCTRL_ALL_ON_THRESHOLD_MASK, threshold);
}

The above function is used to change the threshold of all-on flow control.

rtl8367cEthernetConfig_t rtl8367c_getEthernetConfig(void)
{
rtk_uint32




NEXT




<s> static int rtl8214fc_phy_probe(struct phy_device *phydev)
{
struct device *dev = &phydev->mdio.dev;
int addr = phydev->mdio.addr;
int ret = 0;

/* 839x has internal SerDes */
if (soc_info.id == 0x8393)
return -ENODEV;

/* All base addresses of the PHYs start at multiples of 8 */
devm_phy_package_join(dev, phydev, addr & (~7),
sizeof(struct rtl83xx_shared_private));

if (!(addr % 8)) {
struct rtl83xx_shared_private *shared = phydev->shared->priv;
shared->name = "RTL8214FC";
/* Configuration must be done while patching still possible */
ret = rtl8380_configure_rtl8214fc(phydev);
if (ret)
return ret;
}

return phy_sfp_probe(phydev, &rtl8214fc_sfp_ops);
}

The above function is used to probe in PHY device (to determine the interface) and SFP port.

1. The “phydev->shared->priv ” parameter is used store the private data pointer to access the shared  data of the base address.
2




NEXT




<s> static inline int danube_pp32_download_code(u32 *code_src, unsigned int code_dword_len, u32 *data_src, unsigned int data_dword_len)
{
volatile u32 *dest;

if ( code_src == 0 || ((unsigned long)code_src & 0x03) != 0
|| data_src == 0 || ((unsigned long)data_src & 0x03) != 0 )
return -1;

if ( code_dword_len <= CDM_CODE_MEMORYn_DWLEN(0) )
IFX_REG_W32(0x00, CDM_CFG);
else
IFX_REG_W32(0x04, CDM_CFG);

/*  copy code   */
dest = CDM_CODE_MEMORY(0, 0);
while ( code_dword_len-- > 0 )
IFX_REG_W32(*code_src++, dest++);

/*  copy data   */
dest = CDM_DATA_MEMORY(0, 0);
while ( data_dword_len-- > 0 )
IFX_REG_W32(*data_src++, dest++);

return 0;
}

The above function is used to transfer a code and
data pair from external memory to the CPU and to the
PP core respectively. Each code or data word has
to be a multiple of 4 bytes in size. The maximum
length of each code/data word array




NEXT




<s> int cbc_des_decrypt(struct skcipher_request *req)
{
struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int dec_bytes, nbytes;

DPRINTF(1, "\n");
err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = dec_bytes = walk.nbytes)) {
u8 *iv = walk.iv;
dec_bytes -= (nbytes % DES_BLOCK_SIZE);
ifx_deu_des_cbc(ctx, walk.dst.virt.addr, walk.src.virt.addr,
iv, dec_bytes, CRYPTO_DIR_DECRYPT, 0);
nbytes &= DES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

return err;
}

The above function is used to decrypt a set of packets, each packet is of variable size that should not be less than 8 bytes. A packet may need to be padded if the size is not a multiple of 8. DES is block cipher that works on




NEXT




<s> void hostapd_ubus_free_bss(struct hostapd_data *hapd)
{
struct ubus_object *obj = &hapd->ubus.obj;
char *name = (char *) obj->name;

#ifdef CONFIG_MESH
if (hapd->conf->mesh & MESH_ENABLED)
return;
#endif

if (!ctx)
return;

if (obj->id) {
ubus_remove_object(ctx, obj);
hostapd_ubus_ref_dec();
}

free(name);
}

The above function is used to free the BSS entry after sending a DEAUTH. So,
if we free the object and send a DEAUTH packet to this station, there will be 2
free for a BSS entry. The DEAUTH packet will never reach the




NEXT




<s> int BN_num_bits(const BIGNUM *a)
{
BN_ULONG l;
int i;

bn_check_top(a);

if (a->top == 0) return(0);
l=a->d[a->top-1];
assert(l != 0);
i=(a->top-1)*BN_BITS2;
return(i+BN_num_bits_word(l));
}

The above function is used to return the number of bits. If top is zero,
then no bit is present in BN_DIG, so in that case the function returns 0.</s>




NEXT




<s> rtk_api_ret_t rtk_vlan_portAcceptFrameType_set(rtk_port_t port, rtk_vlan_acceptFrameType_t accept_frame_type)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (accept_frame_type >= ACCEPT_FRAME_TYPE_END)
return RT_ERR_VLAN_ACCEPT_FRAME_TYPE;

if ((retVal = rtl8367c_setAsicVlanAccpetFrameType(rtk_switch_port_L2P_get(port), (rtl8367c_accframetype)accept_frame_type)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to modify VLAN of port that accepts the BPDUs and MAC Frame Type. There are five MAC frame types for which a port can be configured:

– MACFrameType_All – all incoming broadcast/multicast/unknown destinations




NEXT




<s> static int sata_oxnas_scr_read_port(struct ata_port *ap, unsigned int sc_reg,
u32 *val)
{
*val = sata_oxnas_link_read(ap, 0x20 + (sc_reg*4));
return 0;
}

The above function is used to access SERR register using sata_oxnas_scr_read_port. I do not know what it is and what it is for. Can you please explain about it?

I am also trying to read out the ATA_




NEXT




<s> void	 yellow_LED_on(void)
{
AT91PS_PIO	PIOB	= AT91C_BASE_PIOB;
//	PIOB->PIO_CODR		= YELLOW_LED;
PIOB->PIO_CODR		= (1 << 1);
}

The above function is used to light up the Yellow led which is PIO0_1.

In the main file the following codes are used to test out this LED.

int	 main(void)
{
	yellow_LED_on();





NEXT




<s> static int ar934x_nfc_send_write(struct ar934x_nfc *nfc, unsigned command,
int column, int page_addr, int len)
{
u32 cmd_reg;

nfc_dbg(nfc, "write, column=%d page=%d len=%d\n",
column, page_addr, len);

nfc_debug_data("[data] ", nfc->buf, len);

cmd_reg = NAND_CMD_SEQIN << AR934X_NFC_CMD_CMD0_S;
cmd_reg |= command << AR934X_NFC_CMD_CMD1_S;
cmd_reg |= AR934X_NFC_CMD_SEQ_12;

return ar934x_nfc_do_rw_command(nfc, column, page_addr, len,
cmd_reg, nfc->ctrl_reg, true);
}

The above function is used to implement writing the NAND Flash data. Please see the following implementation:

static int ar934x_nfc_do_rw_command(struct ar934x_nfc *nfc, int cs_column




NEXT




<s> ret_t rtl8367c_setAsicSvlanDefaultVlan(rtk_uint32 port, rtk_uint32 index)
{
ret_t retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(index > RTL8367C_SVIDXMAX)
return RT_ERR_SVLAN_ENTRY_INDEX;

if(port < 8){
if(port & 1)
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL0 + (port >> 1), RTL8367C_VS_PORT1_SVIDX_MASK,index);
else
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL0 + (port >> 1), RTL8367C_VS_PORT0_SVIDX_MASK,index);
}else{
switch(port){
case 8:
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL4, RTL8367C_VS_PORT8_SVIDX_MASK,index);
break;

case 9:
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL4, RTL8367C_VS_PORT9_SVIDX_MASK,index);
break;

case 10:
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL5, RTL8367C_SVLAN_PORTBASED_SVIDX_CTRL5_MASK,index);
break;
}
}

return retVal;
}

The above function is used to set default vlan value on port or port group for a
Port_Based Tag Switch module in RTL8367C_SVIDX_CTRL0 register.

When port is even number, index is set as VS




NEXT




<s> IFX_MEI_DFEMemoryFree (DSL_DEV_Device_t * pDev, int type)
{
int idx = 0;
smmu_mem_info_t *adsl_mem_info =
DSL_DEV_PRIVATE(pDev)->adsl_mem_info;

for (idx = 0; idx < MAX_BAR_REGISTERS; idx++) {
if (type == FREE_ALL ||adsl_mem_info[idx].type == type) {
if (adsl_mem_info[idx].size > 0) {
IFX_MEI_DMSG ("Freeing memory %p (%s)\n", adsl_mem_info[idx].org_address, free_str[adsl_mem_info[idx].type]);
if ( idx == XDATA_REGISTER ) {
g_xdata_addr = NULL;
if ( ifx_mei_atm_showtime_exit )
ifx_mei_atm_showtime_exit();
}
kfree (adsl_mem_info[idx].org_address);
adsl_mem_info[idx].org_address = 0;
adsl_mem_info[idx].address = 0;
adsl_mem_info[idx].size = 0;
adsl_mem_info[idx].type = 0;
adsl_mem_info[idx].nCopy = 0;
}
}
}

if(mei_arc_swap_buff != NULL){
IFX_MEI_DMSG("free %dKB swap buff memory at: 0x%p\n", ksize(mei_arc_swap_buff)/1024, mei_arc_swap_buff);
kfree(mei_arc_swap_buff);
mei_arc_swap_buff=NULL;
}

return 0;
}

The above function is used to free the DFE Memory for specific device. By passing the pointer to the IFX_MEI_DFEMemoryAllocate function, the memory block is allocated along with the pointer to the memory block. Now this pointer is passed to this function




NEXT




<s> int xts_aes_encrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int enc_bytes, nbytes, processed;

err = skcipher_walk_virt(&walk, req, false);

if (req->cryptlen < XTS_BLOCK_SIZE)
return -EINVAL;

ctx->use_tweak = 1;
aes_encrypt(req->base.tfm, walk.iv, walk.iv);
ctx->use_tweak = 0;
processed = 0;

while ((nbytes = walk.nbytes) && (walk.nbytes >= (XTS_BLOCK_SIZE * 2)) ) {
u8 *iv = walk.iv;
if (nbytes == walk.total) {
enc_bytes = nbytes;
} else {
enc_bytes = nbytes & ~(XTS_BLOCK_SIZE - 1);
if ((req->cryptlen - processed - enc_bytes) < (XTS_BLOCK_SIZE)) {
if (enc_bytes > (2 * XTS_BLOCK_SIZE)) {
enc_bytes -= XTS_BLOCK_SIZE;
} else {
break;
}
}
}
ifx_deu_aes_xts(ctx, walk.dst.virt.addr, walk.src.virt.addr,
iv, enc_bytes, CRYPTO_DIR_ENCRYPT);
err = skcipher_walk_done(&walk, nbytes - enc_bytes);
processed += enc_bytes;
}

if ((walk.nbytes)) {
u8 *iv = walk.iv;
nbytes = req->cryptlen - processed;
scatterwalk_map_and_copy(ctx->lastbuffer, req->src, (req->cryptlen - nbytes), nbytes, 0);
ifx_deu_aes_xts(ctx, ctx->lastbuffer, ctx->lastbuffer,
iv, nbytes, CRYPTO_DIR_ENCRYPT);
scatterwalk_map_and_copy(ctx->lastbuffer, req->dst, (req->cryptlen - nbytes), nbytes, 1);
skcipher_request_complete(req, 0);
}

return err;
}

The above function is used to encrypt plaintext messages and produce cipher texts. The xts_aes_encrypt function consists of two modes:

- 1. Initial Message Encryption Mode

- 2. Residual Message Encryption




NEXT




<s> rtk_api_ret_t rtk_vlan_reservedVidAction_get(rtk_vlan_resVidAction_t *pAction_vid0, rtk_vlan_resVidAction_t *pAction_vid4095)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(pAction_vid0 == NULL)
return RT_ERR_NULL_POINTER;

if(pAction_vid4095 == NULL)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getReservedVidAction((rtk_uint32 *)pAction_vid0, (rtk_uint32 *)pAction_vid4095)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the VLAN reserved value 0,4095.

rtk_api_ret_t rtk_vlan_reservedVidAction_set(rtk_vlan_resVidAction_t




NEXT




<s> static u64 rtl839x_read_mcast_pmask(int idx)
{
u64 portmask;
/* Read MC_PMSK (2) via register RTL8390_TBL_L2 */
struct table_reg *q = rtl_table_get(RTL8390_TBL_L2, 2);

rtl_table_read(q, idx);
portmask = sw_r32(rtl_table_data(q, 0));
portmask <<= 32;
portmask |= sw_r32(rtl_table_data(q, 1));
portmask >>= 11;  /* LSB is bit 11 in data registers */
rtl_table_release(q);

return portmask;
}

The above function is used to get the portmask of a specific port for the multicast portmasks table on the RTL_8390 chip. RTL_8390 supports only four multicast portmasks tables.</s>




NEXT




<s> static int rtl8367_sw_get_max_length(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8367_SWC0_REG, &data);
val->value.i = (data & RTL8367_SWC0_MAX_LENGTH_MASK) >>
RTL8367_SWC0_MAX_LENGTH_SHIFT;

return 0;
}

The above function is used to determine an egress port length. The function
returns the length value from the RTL8367_SWC0_MAX_LENGTH_SHIFT
register.

The above function does not use the input structure and returns a value




NEXT




<s> BigIntegerModMul(res, prod, A, n);

BigIntegerFree(A);
BigIntegerFree(v);
BigIntegerFree(prod);

if(BigIntegerCmpInt(res, 1) <= 0) {   /* Check for Av^u == 1 (mod n) */
BigIntegerFree(res);
BigIntegerFree(b);
BigIntegerFree(n);
return NULL;
}

The above function is used to calculate the powers of an element g (ie. v) to the 'powertopower '( ie. u ) . Also it is to be noted that powers are calculated from the 'BigInteger' library .

The above function is




NEXT




<s> static int b53_mdio_write32(struct b53_device *dev, u8 page, u8 reg,
u32 value)
{
struct mii_bus *bus = dev->priv;
unsigned int i;
u32 temp = value;

for (i = 0; i < 2; i++) {
int ret = mdiobus_write(bus, B53_PSEUDO_PHY, REG_MII_DATA0 + i,
temp & 0xffff);
if (ret)
return ret;
temp >>= 16;
}

return b53_mdio_op(dev, page, reg, REG_MII_ADDR_WRITE);

}

The above function is used to get the result of a MAC/PHY register read operation. B53_MII_SPEED10_MDI is used as the MDIO device id so that a MDIO operation can be used to read the MAC/PHY register




NEXT




<s> static int rb91x_nand_probe(struct platform_device *pdev)
{
struct rb91x_nand_drvdata *drvdata;
struct mtd_info *mtd;
int r;
struct device *dev = &pdev->dev;
struct gpio_descs *gpios;

drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
if (!drvdata)
return -ENOMEM;

platform_set_drvdata(pdev, drvdata);

gpios = gpiod_get_array(dev, NULL, GPIOD_OUT_LOW);
if (IS_ERR(gpios)) {
if (PTR_ERR(gpios) != -EPROBE_DEFER) {
dev_err(dev, "failed to get gpios: %ld\n",
PTR_ERR(gpios));
}
return PTR_ERR(gpios);
}

if (gpios->ndescs != RB91X_NAND_GPIOS) {
dev_err(dev, "expected %d gpios\n", RB91X_NAND_GPIOS);
return -EINVAL;
}

drvdata->gpio = gpios->desc;

gpiod_direction_input(drvdata->gpio[RB91X_NAND_RDY]);

drvdata->ath79_gpio_base = ioremap(AR71XX_GPIO_BASE, AR71XX_GPIO_SIZE);

drvdata->dev = dev;

drvdata->chip.priv = drvdata;

drvdata->chip.legacy.cmd_ctrl = rb91x_nand_cmd_ctrl;
drvdata->chip.legacy.dev_ready = rb91x_nand_dev_ready;
drvdata->chip.legacy.read_byte = rb91x_nand_read_byte;
drvdata->chip.legacy.write_buf = rb91x_nand_write_buf;
drvdata->chip.legacy.read_buf = rb91x_nand_read_buf;

drvdata->chip.legacy.chip_delay = 25;
drvdata->chip.ecc.engine_type      = NAND_ECC_ENGINE_TYPE_SOFT;
drvdata->chip.ecc.algo             = NAND_ECC_ALGO_HAMMING;
drvdata->chip.options = NAND_NO_SUBPAGE_WRITE;

r = nand_scan(&drvdata->chip, 1);
if (r) {
dev_err(dev, "nand_scan() failed: %d\n", r);
return r;
}

mtd = nand_to_mtd(&drvdata->chip);
mtd->dev.parent = dev;
mtd_set_of_node(mtd, dev->of_node);
mtd->owner = THIS_MODULE;
if (mtd->writesize == 512)
mtd_set_ooblayout(mtd, &rb91x_nand_ecclayout_ops);

r = mtd_device_register(mtd, NULL, 0);
if (r) {
dev_err(dev, "mtd_device_register() failed: %d\n",
r);
goto err_release_nand;
}

return 0;

err_release_nand:
rb91x_nand_release(drvdata);
return r;
}

The above function is used to initialize the driver of the NAND flash. The function first allocates memory for the driver through devm_kzalloc() and initializes the mtd structure through mtd_device_register(). Finally, the nand_scan() is




NEXT




<s> int at91_serial_getc()
{
while(1) {
#if 0
if (!port_detected) {
if (us == usa[0]) {
us = usa[1];
}
else {
us = usa[0];
}
}
#endif
if(AT91F_US_RxReady((AT91PS_USART)us)) {
#if 0
port_detected = 1;
#endif
return((int)AT91F_US_GetChar((AT91PS_USART)us));
}
}
}

The above function is used to poll for an incoming byte. This has been taken from the AT91SAM9263 evaluation board source code. It works, but in a way which will not produce an interrupt driven serial port. In order to get more performance out




NEXT




<s> ret_t rtl8367c_getAsicEavPortInterruptStatus(rtk_uint32 port, rtk_uint32* pIms)
{

if(port > RTL8367C_PORTNO)
return RT_ERR_PORT_ID;
if(port < 5)
return rtl8367c_getAsicRegBits(RTL8367C_EAV_PORT_CFG_REG(port), RTL8367C_PTP_INTR_MASK, pIms);
else if(port == 5)
return rtl8367c_getAsicRegBits(RTL8367C_REG_P5_EAV_CFG, RTL8367C_PTP_INTR_MASK, pIms);
else if(port == 6)
return rtl8367c_getAsicRegBits(RTL8367C_REG_P6_EAV_CFG, RTL8367C_PTP_INTR_MASK,pIms);
else if(port == 7)
return rtl8367c_getAsicRegBits(RTL8367C_REG_P7_EAV_CFG, RTL8367C_PTP_INTR_MASK,pIms);
else if(port == 8)
return rtl8367c_getAsicRegBits(RTL8367C_REG_P8_EAV_CFG, RTL8367C_PTP_INTR_MASK,pIms);
else if(port == 9)
return rtl8367c_getAsicRegBits(RTL8367C_REG_P9_EAV_CFG, RTL8367C_PTP_INTR_MASK,pIms);

return RT_ERR_OK;

}

The above function is used to read the port related PTP interrupt bitmask registers. For example: to read register 0x16:0x1f, rtl8367c_getAsicEavPortInterruptStatus(0) is used




NEXT




<s> static int number(int num, int base, int size,
int precision, int type)
{
char c, sign, tmp[66];
const char *digits="0123456789ABCDEF";
int i;

if (type & LEFT)
type &= ~ZEROPAD;
if (base < 2 || base > 16)
return 0;
c = (type & ZEROPAD) ? '0' : ' ';
sign = 0;

if(type & SIGN && num < 0)
{
sign = '-';
num = -num;
size--;
}

i = 0;
if(num == 0)
tmp[i++] = digits[0];
else while(num != 0)
tmp[i++] = digits[do_div(num, base)];

if(i > precision)
precision = i;
size -= precision;

if(!(type&(ZEROPAD+LEFT)))
while(size-->0)
putc(' ');

if(sign)
putc(sign);

if (!(type & LEFT))
while (size-- > 0)
putc(c);

while (i < precision--)
putc('0');

while (i-- > 0)
putc(tmp[i]);

while (size-- > 0)
putc(' ');;

return 1;
}

The above function is used to display either numbers or bitfield masks and uses the do_div(num, base) function to generate values in base 10, 8, or 16 as requested. The other numbers returned are the bit fields in the format argument




NEXT




<s> ret_t rtl8367c_getAsicRemarkingDot1pSrc(rtk_uint32 *pType)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_RMK_CFG_SEL_CTRL, RTL8367C_RMK_1Q_CFG_SEL_OFFSET, pType);
}

The above function is used to return the Priority map of dot1p for all the packets. I’m not sure that this is correct. Should this not be done in the application itself?

I am using the code below I am not seeing any modification happening to




NEXT




<s> static standard_t get_standard(const uint8_t *xtse) {
if (xtse[0] & XTSE_1_01_A_T1_413)
return STD_T1_413;

if (xtse[0] & XTSE_1_02_C_TS_101388)
return STD_TS_101_388;

if ((xtse[0] & XTSE_1_03_A_1_NO) ||
(xtse[0] & XTSE_1_04_A_1_O) ||
(xtse[0] & XTSE_1_05_B_1_NO) ||
(xtse[0] & XTSE_1_06_B_1_O) ||
(xtse[0] & XTSE_1_07_C_1_NO) ||
(xtse[0] & XTSE_1_08_C_1_O))
return STD_G_992_1;

if ((xtse[1] & XTSE_2_01_A_2_NO) ||
(xtse[1] & XTSE_2_02_B_2_O) ||
(xtse[1] & XTSE_2_03_C_2_NO) ||
(xtse[1] & XTSE_2_04_C_2_O))
return STD_G_992_2;

if ((xtse[2] & XTSE_3_03_A_3_NO) ||
(xtse[2] & XTSE_3_04_A_3_O) ||
(xtse[2] & XTSE_3_05_B_3_NO) ||
(xtse[2] & XTSE_3_06_B_3_O) ||
(xtse[3] & XTSE_4_05_I_3_NO) ||
(xtse[3] & XTSE_4_06_I_3_O) ||
(xtse[3] & XTSE_4_07_J_3_NO) ||
(xtse[3] & XTSE_4_08_J_3_O) ||
(xtse[4] & XTSE_5_03_L_3_NO) ||
(xtse[4] & XTSE_5_04_L_3_NO) ||
(xtse[4] & XTSE_5_05_L_3_O) ||
(xtse[4] & XTSE_5_06_L_3_O) ||
(xtse[4] & XTSE_5_07_M_3_NO) ||
(xtse[4] & XTSE_5_08_M_3_O))
return STD_G_992_3;

if ((xtse[3] & XTSE_4_01_A_4_NO) ||
(xtse[3] & XTSE_4_02_A_4_O) ||
(xtse[4] & XTSE_5_01_I_4_NO) ||
(xtse[4] & XTSE_5_02_I_4_O))
return STD_G_992_4;

if ((xtse[5] & XTSE_6_01_A_5_NO) ||
(xtse[5] & XTSE_6_02_A_5_O) ||
(xtse[5] & XTSE_6_03_B_5_NO) ||
(xtse[5] & XTSE_6_04_B_5_O) ||
(xtse[5] & XTSE_6_07_I_5_NO) ||
(xtse[5] & XTSE_6_08_I_5_O) ||
(xtse[6] & XTSE_7_01_J_5_NO) ||
(xtse[6] & XTSE_7_02_J_5_O) ||
(xtse[6] & XTSE_7_03_M_5_NO) ||
(xtse[6] & XTSE_7_04_M_5_O))
return STD_G_992_5;

if (xtse[7] & XTSE_8_08)
return STD_G_993_1;

if ((xtse[7] & XTSE_8_01_A) ||
(xtse[7] & XTSE_8_02_B) ||
(xtse[7] & XTSE_8_03_C))
return STD_G_993_2;

return STD_UNKNOWN;
}

The above function is used to identify the standard that a TSE/TSE2 frame is using.  It is called by both the send and receive threads, though the XTSE parameters may come from various locations.  For instance, during the recv process, the




NEXT




<s> struct expr *expr_alloc_comp(enum expr_type type, struct symbol *s1, struct symbol *s2)
{
struct expr *e = xcalloc(1, sizeof(*e));
e->type = type;
e->left.sym = s1;
e->right.sym = s2;
return e;
}

The above function is used to allocate memory for a compound expression in the interpreter and as well as set the node up with the information needed for later processing.

The struct expresses that will be used to store compiled expressions in your virtual machine (we’ll get to




NEXT




<s> void sig_teardown(int sig)
{
run_stop = 1;
}

The above function is used to terminate multithreading of my code and return to original function. But, it is not called with thread 1 i.e main function. The code goes to the end of the main function i.e it is not executed before the




NEXT




<s> send_a(void)
{
struct ead_msg_number *num = EAD_DATA(msg, number);
A = t_clientgenexp(tc);
msg->type = htonl(EAD_TYPE_SEND_A);
msg->len = htonl(sizeof(struct ead_msg_number) + A->len);
memcpy(num->data, A->data, A->len);
return send_packet(EAD_TYPE_SEND_B, handle_b, 1);
}

The above function is used to calculate the hash of
data when one sends the EADSEND_A message but the function
send_packet is not used to calculate the hash of that data .
how does this happen since the EADSEND_B message that




NEXT




<s> ret_t rtl8367c_getAsicAprMeter(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 *apridx)
{
ret_t retVal;
rtk_uint32 regAddr;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;

if(port < 8)
retVal = rtl8367c_getAsicRegBits(RTL8367C_SCHEDULE_PORT_APR_METER_REG(port, qid), RTL8367C_SCHEDULE_PORT_APR_METER_MASK(qid), apridx);
else {
regAddr = RTL8367C_REG_SCHEDULE_PORT8_APR_METER_CTRL0 + ((port-8) << 1) + (qid / 5);
retVal = rtl8367c_getAsicRegBits(regAddr, RTL8367C_SCHEDULE_PORT_APR_METER_MASK(qid), apridx);
}

return retVal;
}

The above function is used to read Asic scheduler port apr-meter configuration register via chip register

ret_t rtl8367c_setAsicAprMeter(rtk_uint32 port, rtk_uint32 q




NEXT




<s> static int aw9523_gpio_get_direction(struct gpio_chip *chip,
unsigned int offset)
{
struct aw9523 *awi = gpiochip_get_data(chip);
u8 regbit = offset % AW9523_PINS_PER_PORT;
int ret;

mutex_lock(&awi->i2c_lock);
ret = aw9523_get_pin_direction(awi->regmap, offset, regbit);
mutex_unlock(&awi->i2c_lock);

return ret;
}

The above function is used to get the pin direction of a single gpio. As you can see, there is no argument about the gpios group number. So it is impossible for the driver to determine which gpio group a GPIO belongs to.</s>




NEXT




<s> ret_t rtl8367c_setAsicIGMPQueryInterval(rtk_uint32 interval)
{
ret_t  retVal;

if(interval > RTL8367C_MAX_QUERY_INT)
return RT_ERR_OUT_OF_RANGE;

/* Query Interval */
retVal = rtl8367c_setAsicReg(RTL8367C_REG_IGMP_MLD_CFG2, interval);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the query interval of IGMP and MLD. The range of the value is 0-5, which is converted to 1-6 during the process.

Note

The range of the query interval is from 0




NEXT




<s> void rtl83xx_setup_prio2queue_cpu_matrix(int *max_queues)
{
int reg = soc_info.family == RTL8380_FAMILY_ID ? RTL838X_QM_PKT2CPU_INTPRI_MAP
: RTL839X_QM_PKT2CPU_INTPRI_MAP;
u32 v = 0;

pr_info("QM_PKT2CPU_INTPRI_MAP: %08x\n", sw_r32(reg));
for (int i = 0; i < MAX_PRIOS; i++)
v |= max_queues[i] << (i * 3);
sw_w32(v, reg);
}

The above function is used to set the cpu-mapping table as per max_queues[i]: it reads the current table content as
currently all packet received by QM is mapped to the cpu specified by the highest priority in the PRIMap, e.g




NEXT




<s> ret_t rtl8367c_getAsicSvlanIngressUntag(rtk_uint32* pMode)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UNTAG_MASK, pMode);
}

The above function is used to query the mode of the SVLAN untag forwarding engine.

There are three modes defined:


- RTL8367C_VPORT_UNTAG_DIS              Disable the SVLAN untag forwarding




NEXT




<s> static int rtl8366s_set_mc_index(struct rtl8366_smi *smi, int port, int index)
{
if (port >= RTL8366S_NUM_PORTS || index >= RTL8366S_NUM_VLANS)
return -EINVAL;

return rtl8366_smi_rmwr(smi, RTL8366S_PORT_VLAN_CTRL_REG(port),
RTL8366S_PORT_VLAN_CTRL_MASK <<
RTL8366S_PORT_VLAN_CTRL_SHIFT(port),
(index & RTL8366S_PORT_VLAN_CTRL_MASK) <<
RTL8366S_PORT_VLAN_CTRL_SHIFT(port));
}

The above function is used to configure the multicast index (MC index) of an
Ethernet port.




static int rtl8366s_clear_port_mcasts(struct rtl8366_sm




NEXT




<s> swconfig_lookup_attr(struct switch_dev *dev, struct genl_info *info,
struct switch_val *val)
{
struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
const struct switch_attrlist *alist;
const struct switch_attr *attr = NULL;
unsigned int attr_id;

/* defaults */
struct switch_attr *def_list;
unsigned long *def_active;
int n_def;

if (!info->attrs[SWITCH_ATTR_OP_ID])
goto done;

switch (hdr->cmd) {
case SWITCH_CMD_SET_GLOBAL:
case SWITCH_CMD_GET_GLOBAL:
alist = &dev->ops->attr_global;
def_list = default_global;
def_active = &dev->def_global;
n_def = ARRAY_SIZE(default_global);
break;
case SWITCH_CMD_SET_VLAN:
case SWITCH_CMD_GET_VLAN:
alist = &dev->ops->attr_vlan;
def_list = default_vlan;
def_active = &dev->def_vlan;
n_def = ARRAY_SIZE(default_vlan);
if (!info->attrs[SWITCH_ATTR_OP_VLAN])
goto done;
val->port_vlan = nla_get_u32(info->attrs[SWITCH_ATTR_OP_VLAN]);
if (val->port_vlan >= dev->vlans)
goto done;
break;
case SWITCH_CMD_SET_PORT:
case SWITCH_CMD_GET_PORT:
alist = &dev->ops->attr_port;
def_list = default_port;
def_active = &dev->def_port;
n_def = ARRAY_SIZE(default_port);
if (!info->attrs[SWITCH_ATTR_OP_PORT])
goto done;
val->port_vlan = nla_get_u32(info->attrs[SWITCH_ATTR_OP_PORT]);
if (val->port_vlan >= dev->ports)
goto done;
break;
default:
WARN_ON(1);
goto done;
}

if (!alist)
goto done;

attr_id = nla_get_u32(info->attrs[SWITCH_ATTR_OP_ID]);
if (attr_id >= SWITCH_ATTR_DEFAULTS_OFFSET) {
attr_id -= SWITCH_ATTR_DEFAULTS_OFFSET;
if (attr_id >= n_def)
goto done;
if (!test_bit(attr_id, def_active))
goto done;
attr = &def_list[attr_id];
} else {
if (attr_id >= alist->n_attr)
goto done;
attr = &alist->attr[attr_id];
}

if (attr->disabled)
attr = NULL;

done:
if (!attr)
pr_debug("attribute lookup failed\n");
val->attr = attr;
return attr;
}

The above function is used to look up in switch config file for the attribute which we want to set/get. We need to understand the arguments:

struct switch_dev *: Switch config is stored in switch_device in struct switch_dev in net_switch.




NEXT




<s> static int rtl8367_sw_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
{
struct switch_port *port;
struct rtl8367_vlan_info vlan;
int i;

if (!rtl8367c_is_vlan_valid(val->port_vlan))
return -EINVAL;

if(rtl8367c_get_vlan(val->port_vlan, &vlan))
return -EINVAL;

port = &val->value.ports[0];
val->len = 0;
for (i = 0; i <RTL8367C_NUM_PORTS ; i++) {
if (!(vlan.member & BIT(i)))
continue;

port->id = i;
port->flags = (vlan.untag & BIT(i)) ?
0 : BIT(SWITCH_PORT_FLAG_TAGGED);
val->len++;
port++;
}
return 0;
}

The above function is used to get the information of vlan port list. In the
function, we get the information of vlan, which port of the vlan is tagged,
and put each port information into the structure switch_port.
As the switch supports




NEXT




<s> load_userfile(struct radius_state *s)
{
enum {
USERDATA_PHASE1,
USERDATA_PHASE2,
__USERDATA_MAX
};
static const struct blobmsg_policy policy[__USERDATA_MAX] = {
[USERDATA_PHASE1] = { "phase1", BLOBMSG_TYPE_TABLE },
[USERDATA_PHASE2] = { "phase2", BLOBMSG_TYPE_TABLE },
};
struct blob_attr *tb[__USERDATA_MAX], *cur;
static struct blob_buf b;
struct stat st;
int rem;

if (stat(s->user_file, &st))
return;

if (s->user_file_ts == st.st_mtime)
return;

s->user_file_ts = st.st_mtime;
radius_userdata_free(&s->phase1);
radius_userdata_free(&s->phase2);

blob_buf_init(&b, 0);
blobmsg_add_json_from_file(&b, s->user_file);
blobmsg_parse(policy, __USERDATA_MAX, tb, blob_data(b.head), blob_len(b.head));
radius_userdata_load(&s->phase1, tb[USERDATA_PHASE1]);
radius_userdata_load(&s->phase2, tb[USERDATA_PHASE2]);

blob_buf_free(&b);
}

The above function is used to load the specified file into different phases in the IETF RFC 2865 protocol for user parameters.
In detail, the data of the user file is parsed to load into phase one and phase two.
In addition, this




NEXT




<s> ret_t rtl8367c_getAsicTrunkingMode(rtk_uint32* pMode)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_DUMB_OFFSET, pMode);
}

The above function is used to get the Trunking mode. If we do:

unsigned int mode = 0;
rtl8367c_getAsicTrunkingMode(&mode);
printf("%u\n",mode);






NEXT




<s> static void rtl930x_set_l3_egress_mac(u32 idx, u64 mac)
{
/* Access L3_EGR_INTF_MAC table (2) via register RTL9300_TBL_2 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_2, 2);

/* The table has a size of 2 registers */
sw_w32(mac >> 32, rtl_table_data(r, 0));
sw_w32(mac, rtl_table_data(r, 1));

pr_debug("%s: setting index %d to %016llx\n", __func__, idx, mac);
rtl_table_write(r, idx);
rtl_table_release(r);
}

The above function is used to set L3_EGR_INTF_MAC for 5000G.

It tries to set 2.1 (a 32-bit entry) at once, and thus write 5000G




NEXT




<s> ret_t rtl8367c_setAsicMIBsUsageMode(rtk_uint32 mode)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_CTRL4, RTL8367C_MIB_USAGE_MODE_OFFSET, mode);
}

The above function is used to enable the Asic MIB usage, we should enable the CSM of MIB usage before doing the MIB enable. It calls following function eventually.

ret_t rtl8367c_setAsicRegBit(




NEXT




<s> static int rtl8214fc_get_eee(struct phy_device *phydev,
struct ethtool_eee *e)
{
int addr = phydev->mdio.addr;

pr_debug("In %s port %d, enabled %d\n", __func__, addr, e->eee_enabled);
if (rtl8214fc_media_is_fibre(phydev)) {
netdev_err(phydev->attached_dev, "Port %d configured for FIBRE", addr);
return -ENOTSUPP;
}

return rtl8218b_get_eee(phydev, e);
}

The above function is used to get eee information.

It is only supported by copper cable ports.

When fibre optic cable is used, eee is not supported, so it will return error.

We could use fibre optic cable if




NEXT




<s> void rtl931x_vlan_port_keep_tag_set(int port, bool keep_outer, bool keep_inner)
{
sw_w32(FIELD_PREP(RTL931X_VLAN_PORT_TAG_EGR_OTAG_STS_MASK,
keep_outer ? RTL931X_VLAN_PORT_TAG_STS_TAGGED : RTL931X_VLAN_PORT_TAG_STS_UNTAG) |
FIELD_PREP(RTL931X_VLAN_PORT_TAG_EGR_ITAG_STS_MASK,
keep_inner ? RTL931X_VLAN_PORT_TAG_STS_TAGGED : RTL931X_VLAN_PORT_TAG_STS_UNTAG),
RTL931X_VLAN_PORT_TAG_CTRL(port));
}

The above function is used to set the “keep tag” bit. In the code, we can see for port 2, outer tag is 0 and inner tag is 1.

This command is used by rtl9301_tuntap.




NEXT




<s> static int mt7620_gsw_config(struct fe_priv *priv)
{
struct mt7620_gsw *gsw = (struct mt7620_gsw *) priv->soc->swpriv;
u32 val;

/* is the mt7530 internal or external */
if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, 0x1f)) {
mt7530_probe(priv->dev, gsw->base, NULL, 0);
mt7530_probe(priv->dev, NULL, priv->mii_bus, 1);

/* magic values from original SDK */
val = mt7530_mdio_r32(gsw, 0x7830);
val &= ~BIT(0);
val |= BIT(1);
mt7530_mdio_w32(gsw, 0x7830, val);

val = mt7530_mdio_r32(gsw, 0x7a40);
val &= ~BIT(30);
mt7530_mdio_w32(gsw, 0x7a40, val);

mt7530_mdio_w32(gsw, 0x7a78, 0x855);

pr_info("mt7530: mdio central align\n");
} else {
mt7530_probe(priv->dev, gsw->base, NULL, 1);
}

return 0;
}

The above function is used to select 2 PHYs to connect to GSW, one for CPU and the other for LAN. You should modify the function in 3.0-rc1.</s>




NEXT




<s> rtk_api_ret_t rtk_cpu_tagPosition_set(rtk_cpu_position_t position)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (position >= CPU_POS_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicCputagPosition(position)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the position of the cpu tag to the value of the argument position. There are four supported cpu tag positions in the 8367B (position 0 to position 3), and each of these positions is for one tag.





NEXT




<s> static void get_def_str(struct gstr *r, struct menu *menu)
{
str_printf(r, "Defined at %s:%d\n",
menu->file->name, menu->lineno);
}

The above function is used to return an error message when the GST
object does not point to a valid MENU_STRUCT or MENU_ENTRY_STRUCT.
In the above function, the MENU_STRUCT is passed by itself, but the





NEXT




<s> static void arc4_crypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
{
struct arc4_ctx *ctx = crypto_tfm_ctx(tfm);

_deu_arc4 (ctx, out, in, NULL, ARC4_BLOCK_SIZE,
CRYPTO_DIR_DECRYPT, 0);

}

The above function is used to decrypt and it does exactly the same as the
_en_arc4() that is used to encrypt.
There’s a slight difference and I did not understand why the _deu_arc4()
has an additional NULL




NEXT




<s> wpas_bss_get_features(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);

blob_buf_init(&b, 0);
blobmsg_add_u8(&b, "ht_supported", ht_supported(wpa_s->hw.modes));
blobmsg_add_u8(&b, "vht_supported", vht_supported(wpa_s->hw.modes));
ubus_send_reply(ctx, req, b.head);

return 0;
}

The above function is used to fetch the support for the higher modes
and other things like support for channel bonding, HT, VHT etc. I can
tweak this as below and add my own feature like "40m". Please note
that the wpa




NEXT




<s> u32 rtl838x_get_egress_rate(struct rtl838x_switch_priv *priv, int port)
{
if (port > priv->cpu_port)
return 0;

return sw_r32(RTL838X_SCHED_P_EGR_RATE_CTRL(port)) & 0x3fff;
}

The above function is used to get the egress rate of a port; however, there is currently no command to set
the egress rate and this is to be implemented in the future.

6.2.3 ACL Flow-entry Operation
The flow-




NEXT




<s> rtk_api_ret_t rtk_led_groupAbility_set(rtk_led_group_t group, rtk_led_ability_t *pAbility)
{
rtk_api_ret_t retVal;
rtk_uint32 regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (LED_GROUP_END <= group)
return RT_ERR_FAILED;

if(pAbility == NULL)
return RT_ERR_NULL_POINTER;

if( (pAbility->link_10m >= RTK_ENABLE_END) || (pAbility->link_100m >= RTK_ENABLE_END)||
(pAbility->link_500m >= RTK_ENABLE_END) || (pAbility->link_1000m >= RTK_ENABLE_END)||
(pAbility->act_rx >= RTK_ENABLE_END) || (pAbility->act_tx >= RTK_ENABLE_END) )
{
return RT_ERR_INPUT;
}

if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_LED0_DATA_CTRL + (rtk_uint32)group, &regData)) != RT_ERR_OK)
return retVal;

if(pAbility->link_10m == ENABLED)
regData |= 0x0001;
else
regData &= ~0x0001;

if(pAbility->link_100m == ENABLED)
regData |= 0x0002;
else
regData &= ~0x0002;

if(pAbility->link_500m == ENABLED)
regData |= 0x0004;
else
regData &= ~0x0004;

if(pAbility->link_1000m == ENABLED)
regData |= 0x0008;
else
regData &= ~0x0008;

if(pAbility->act_rx == ENABLED)
regData |= 0x0010;
else
regData &= ~0x0010;

if(pAbility->act_tx == ENABLED)
regData |= 0x0020;
else
regData &= ~0x0020;

regData |= (0x0001 << 6);

if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_LED0_DATA_CTRL + (rtk_uint32)group, regData)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set LED Group Ability mode.</s>




NEXT




<s> static inline unsigned int rttm_get_counter(void __iomem *base)
{
return ioread32(base + RTTM_CNT);
}

The above function is used to read the counter value in the hardware rttm device, ioread32() reads 32bits of data from the base address. The complete details of rttm hardware device is provided in the below post , http://the-




NEXT




<s> int dsa_phy_write(struct dsa_switch *ds, int phy_addr, int phy_reg, u16 val)
{
u32 offset = 0;
struct rtl838x_switch_priv *priv = ds->priv;

if ((phy_addr >= 24) &&
(phy_addr <= 27) &&
(priv->ports[24].phy == PHY_RTL838X_SDS)) {
if (phy_addr == 26)
offset = 0x100;
sw_w32(val, RTL838X_SDS4_FIB_REG0 + offset + (phy_reg << 2));
return 0;
}
return write_phy(phy_addr, 0, phy_reg, val);
}

The above function is used to set the regester value of the RTL8386D.
And when we set the regester value of the SD0, we can see that the value
set is written into the FW register, but SD1, SD




NEXT




<s> ret_t rtl8367c_setAsicCputagPortmask(rtk_uint32 portmask)
{
if(portmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

return rtl8367c_setAsicReg(RTL8367C_CPU_PORT_MASK_REG, portmask);
}

The above function is used to set cpu tag with port mask and port mask is a macros as follows:

/* The asic cpu tag port mask for RTL8367C */
#define RTL8367C_PORTMASK 0




NEXT




<s> void __init plat_time_init(void)
{
/*
* Initialization routine resembles generic MIPS plat_time_init() with
* lazy error handling. The final fallback is only needed until we have
* converted all device trees to new clock syntax.
*/
struct device_node *np;
struct clk *clk;

of_clk_init(NULL);

mips_hpt_frequency = 0;
np = of_get_cpu_node(0, NULL);
if (!np) {
pr_err("Failed to get CPU node\n");
} else {
clk = of_clk_get(np, 0);
if (IS_ERR(clk)) {
pr_err("Failed to get CPU clock: %ld\n", PTR_ERR(clk));
} else {
mips_hpt_frequency = clk_get_rate(clk) / 2;
clk_put(clk);
}
}

if (!mips_hpt_frequency)
plat_time_init_fallback();

timer_probe();
}

The above function is used to initialize the timer on the MIPS platform.

You will notice the use of:
clk_init(OF_CLK_INIT_DEFAULT);

This will ensure that the clock is initialized with the device tree.

In the




NEXT




<s> static void show_usage(void)
{
printf("Usage:\n");
printf("	resolveip -h\n");
printf("	resolveip [-t timeout] hostname\n");
printf("	resolveip -4 [-t timeout] hostname\n");
printf("	resolveip -6 [-t timeout] hostname\n");
exit(255);
}

The above function is used to display information about the usage of the utility to any user. If they do something odd like passing -gjshl to the utility, or maybe -gjsfhg to the utility then the script will stop immediately and show the user how




NEXT




<s> static void ip175c_correct_vlan_state(struct ip17xx_state *state)
{
int i, j;
state->num_vlans = 0;
for (i=0; i<MAX_VLANS; i++) {
if (state->vlans[i].ports != 0) {
state->num_vlans = i+1; // Hack -- we need to store the "set" vlans somewhere...
}
}

for (i=0; i<state->regs->NUM_PORTS; i++) {
unsigned int portmask = (1<<i);
if (!state->vlan_enabled) {
// Share with everybody!
state->ports[i].shareports = (1<<state->regs->NUM_PORTS)-1;
continue;
}
state->ports[i].shareports = portmask;
for (j=0; j<MAX_VLANS; j++) {
if (state->vlans[j].ports & portmask)
state->ports[i].shareports |= state->vlans[j].ports;
}
}
}

The above function is used to determine and store "vlan_shareports"
based on the contents of the "vlans[]" array. It is called from
ip175c_reinit_config() after a configuration change.

ip17




NEXT




<s> enum symbol_type sym_get_type(struct symbol *sym)
{
enum symbol_type type = sym->type;

if (type == S_TRISTATE) {
if (sym_is_choice_value(sym) && sym->visible == yes)
type = S_BOOLEAN;
else if (modules_val == no)
type = S_BOOLEAN;
}
return type;
}

The above function is used to compute the data type of an entity (or expression) in a given simulation. The above is equivalent to

enum symbol_type sym_get_type(struct symbol *sym)
{
enum symbol_type type = sym->type




NEXT




<s> static int sha1_update(struct shash_desc * desc, const u8 *data,
unsigned int len)
{
struct sha1_ctx *sctx = shash_desc_ctx(desc);
unsigned int i, j;

j = (sctx->count >> 3) & 0x3f;
sctx->count += len << 3;

if ((j + len) > 63) {
memcpy (&sctx->buffer[j], data, (i = 64 - j));
sha1_transform1 (sctx, sctx->state, (const u32 *)sctx->buffer);
for (; i + 63 < len; i += 64) {
sha1_transform1 (sctx, sctx->state, (const u32 *)&data[i]);
}

j = 0;
}
else
i = 0;

memcpy (&sctx->buffer[j], &data[i], len - i);
return 0;
}

The above function is used to update the state of SHA1 hash function.
If the count is not of multiple of 8 then in first go, 2 extra round are
need to process. As the hash function is iterative in nature, so on each pass





NEXT




<s> static int bcm6368_enetsw_refill_rx(struct net_device *ndev, bool napi_mode)
{
struct bcm6368_enetsw *priv = netdev_priv(ndev);
struct platform_device *pdev = priv->pdev;
struct device *dev = &pdev->dev;

while (priv->rx_desc_count < priv->rx_ring_size) {
struct bcm6368_enetsw_desc *desc;
int desc_idx;
u32 len_stat;

desc_idx = priv->rx_dirty_desc;
desc = &priv->rx_desc_cpu[desc_idx];

if (!priv->rx_buf[desc_idx]) {
unsigned char *buf;
dma_addr_t p;

if (likely(napi_mode))
buf = napi_alloc_frag(priv->rx_frag_size);
else
buf = netdev_alloc_frag(priv->rx_frag_size);

if (unlikely(!buf))
break;

p = dma_map_single(dev, buf + NET_SKB_PAD,
priv->rx_buf_size, DMA_FROM_DEVICE);
if (unlikely(dma_mapping_error(dev, p))) {
skb_free_frag(buf);
break;
}

priv->rx_buf[desc_idx] = buf;
desc->address = p;
}

len_stat = priv->rx_buf_size << DMADESC_LENGTH_SHIFT;
len_stat |= DMADESC_OWNER_MASK;
if (priv->rx_dirty_desc == priv->rx_ring_size - 1) {
len_stat |= DMADESC_WRAP_MASK;
priv->rx_dirty_desc = 0;
} else {
priv->rx_dirty_desc++;
}
wmb();
desc->len_stat = len_stat;

priv->rx_desc_count++;

/* tell dma engine we allocated one buffer */
dma_writel(priv, 1, DMA_BUFALLOC_REG(priv->rx_chan));
}

/* If rx ring is still empty, set a timer to try allocating
* again at a later time. */
if (priv->rx_desc_count == 0 && netif_running(ndev)) {
dev_warn(dev, "unable to refill rx ring\n");
priv->rx_timeout.expires = jiffies + HZ;
add_timer(&priv->rx_timeout);
}

return 0;
}

The above function is used to refill the Rx Ring whenever needed (in the context of net_rx_action callback). The Rx descriptor count keeps track of how many buffers are avaiable in the Rx Ring so the function checks it first. Then, it




NEXT




<s> ret_t rtl8367c_setAsicVlanFilter(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_VLAN_CTRL, RTL8367C_VLAN_CTRL_OFFSET, enabled);
}

The above function is used to set VLAN Filter Enable bit in the VLCNTL.

A function is used to set IP Filtering Enable bit in the BCNTL register.  IP Filtering Enable bit is used to configure the IPv4 filtering in




NEXT




<s> void rtl8390_get_version(struct rtl838x_switch_priv *priv)
{
u32 info, model;

sw_w32_mask(0xf << 28, 0xa << 28, RTL839X_CHIP_INFO);
info = sw_r32(RTL839X_CHIP_INFO);

model = sw_r32(RTL839X_MODEL_NAME_INFO);
priv->version = RTL8390_VERSION_A + ((model & 0x3f) >> 1);

pr_info("RTL839X Chip-Info: %x, version %c\n", info, priv->version);
}

The above function is used to query the version of the switch chip,
but it return 0 in RTL8390, why?

Answer:

The 8390 and 8392 are basically identical. The main difference




NEXT




<s> static void aca_dma_parse(struct dc_ep_priv *priv, const char *data, int chn)
{
int i;
u32 cid, dbase;
struct aca_fw_dma *fw_dma;
struct aca_fw_info *fw_info = to_fw_info(priv);

fw_info->chan_num = chn;

for (i = 0; i < fw_info->chan_num; i++) {
fw_dma = (struct aca_fw_dma *)(data + i * sizeof(*fw_dma));
cid = be32_to_cpu(fw_dma->cid);
dbase = be32_to_cpu(fw_dma->base);
fw_info->adma_desc_base[cid] = dbase;
dev_dbg(priv->dev, "dma channel %d desc base 0x%08x\n",
cid, dbase);
}
}

The above function is used to parse dma information from firmware</s>




NEXT




<s> static inline int block_count(size_t size)
{
return (size + VFS_BLOCK_SIZE - 1) / VFS_BLOCK_SIZE;
}

The above function is used to count the number of blocks needed for a particular file, folder or device. The size is converted to blocks by diving (/) it by the block size. To find the total number of blocks that need to be stored on a floppy drive




NEXT




<s> ret_t rtl8367c_getAsicVlanPortAndProtocolBased(rtk_uint32 port, rtk_uint32 index, rtl8367c_protocolvlancfg *pPpbCfg)
{
rtk_uint32  reg_addr, bit_mask, bit_value;
ret_t   retVal;

/* Error Checking */
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(index > RTL8367C_PROTOVLAN_GIDX_MAX)
return RT_ERR_VLAN_PROTO_AND_PORT;

if(pPpbCfg == NULL)
return RT_ERR_INPUT;

/* Valid bit */
reg_addr  = RTL8367C_VLAN_PPB_VALID_REG(index);
bit_mask  = 0x0001 << port;
retVal    = rtl8367c_getAsicRegBits(reg_addr, bit_mask, &bit_value);
if(retVal != RT_ERR_OK)
return retVal;

pPpbCfg->valid = bit_value;

/* CVLAN index */
if(port < 8)
{
reg_addr = RTL8367C_VLAN_PPB_CTRL_REG(index, port);
bit_mask = RTL8367C_VLAN_PPB_CTRL_MASK(port);
}
else if(port == 8)
{
reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT8_INDEX_MASK;
}
else if(port == 9)
{
reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT9_INDEX_MASK;
}
else if(port == 10)
{
reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT10_INDEX_MASK;
}

retVal = rtl8367c_getAsicRegBits(reg_addr, bit_mask, &bit_value);
if(retVal != RT_ERR_OK)
return retVal;

pPpbCfg->vlan_idx = bit_value;


/* priority */
reg_addr = RTL8367C_VLAN_PPB_PRIORITY_ITEM_REG(port,index);
bit_mask = RTL8367C_VLAN_PPB_PRIORITY_ITEM_MASK(port);
retVal = rtl8367c_getAsicRegBits(reg_addr, bit_mask, &bit_value);
if(retVal != RT_ERR_OK)
return retVal;

pPpbCfg->priority = bit_value;
return RT_ERR_OK;
}

The above function is used to read CVLAN index of protocol based vlan, and the priority.

*/</s>




NEXT




<s> ret_t rtl8367c_getAsicStormFilterExtMulticastMeter(rtk_uint32 *pMeter)
{
if(NULL == pMeter)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG0, RTL8367C_MC_STORM_EXT_METERIDX_MASK, pMeter);
}

The above function is used to get the current METERIDX of Storm Filter Extender.
The API definition is in file “rtl8367c_storm_filter_ext.c”.

There are multiple steps to enable the extended multic




NEXT




<s> static inline int reset_device(struct dc_ep_dev *dev, u32 bits)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_reset_device(dev->priv, bits);
}

The above function is used to send a reset command to the Display Controller and hence
resetting the whole video pipeline. Since this is the most commonly used function, it’s important to understand the different
parameters it takes.

The first parameter is a pointer to a




NEXT




<s> static int ar934x_nfc_write_page_raw(
struct nand_chip *chip, const u8 *buf,
int oob_required, int page)
{
struct ar934x_nfc *nfc = chip->priv;
struct mtd_info *mtd = ar934x_nfc_to_mtd(nfc);
int len;

nfc_dbg(nfc, "write_page_raw: page:%d oob:%d\n", page, oob_required);

memcpy(nfc->buf, buf, mtd->writesize);
len = mtd->writesize;

if (oob_required) {
memcpy(&nfc->buf[mtd->writesize], chip->oob_poi, mtd->oobsize);
len += mtd->oobsize;
}

return ar934x_nfc_send_write(nfc, NAND_CMD_PAGEPROG, 0, page, len);
}

The above function is used to upload raw data to NAND and erase raw data also. But it doesn't handle page/block boundaries. Sometimes, the page size has some restriction that they are not divisible by bytes. So user data can be written in the last




NEXT




<s> static int rtl9300_i2c_read(struct rtl9300_i2c *i2c, u8 *buf, int len)
{
return i2c_read(REG(i2c, RTL9300_I2C_DATA_WORD0), buf, len);
}

The above function is used to read any register address in i2c mode. I am reading register address rtl9300_registers[0]. This register address contains 3 bytes. The value is saved as below :

rtl9300




NEXT




<s> static void ag71xx_ring_tx_clean(struct ag71xx *ag)
{
struct ag71xx_ring *ring = &ag->tx_ring;
struct net_device *dev = ag->dev;
int ring_mask = BIT(ring->order) - 1;
u32 bytes_compl = 0, pkts_compl = 0;

while (ring->curr != ring->dirty) {
struct ag71xx_desc *desc;
u32 i = ring->dirty & ring_mask;

desc = ag71xx_ring_desc(ring, i);
if (!ag71xx_desc_empty(desc)) {
desc->ctrl = 0;
dev->stats.tx_errors++;
}

if (ring->buf[i].skb) {
bytes_compl += ring->buf[i].len;
pkts_compl++;
dev_kfree_skb_any(ring->buf[i].skb);
}
ring->buf[i].skb = NULL;
ring->dirty++;
}

/* flush descriptors */
wmb();

netdev_completed_queue(dev, pkts_compl, bytes_compl);
}

The above function is used to clean TX ring. This function looks through all the descriptors in the TX ring and check if any of the descriptor is valid and full of data. If not, then it is marked to be dirty and to be flushed during transmission. Below is




NEXT




<s> static int ctr_aes_encrypt (struct ablkcipher_request *areq)
{
struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);
struct aes_ctx *ctx = crypto_ablkcipher_ctx(cipher);

return lq_aes_queue_mgr(ctx, areq, areq->info, CRYPTO_DIR_ENCRYPT, 4);

}

The above function is used to initialize the function of lq_aes_queue_mgr. The lq_aes_queue_mgr function is implemented in lq_aes_queue_encrypt(), the function is used to encrypt the plaintext data




NEXT




<s> int conf_write_defconfig(const char *filename)
{
struct symbol *sym;
struct menu *menu;
FILE *out;

out = fopen(filename, "w");
if (!out)
return 1;

sym_clear_all_valid();

/* Traverse all menus to find all relevant symbols */
menu = rootmenu.list;

while (menu != NULL)
{
sym = menu->sym;
if (sym == NULL) {
if (!menu_is_visible(menu))
goto next_menu;
} else if (!sym_is_choice(sym)) {
sym_calc_value(sym);
if (!(sym->flags & SYMBOL_WRITE))
goto next_menu;
sym->flags &= ~SYMBOL_WRITE;
/* If we cannot change the symbol - skip */
if (!sym_is_changeable(sym))
goto next_menu;
/* If symbol equals to default value - skip */
if (strcmp(sym_get_string_value(sym), sym_get_string_default(sym)) == 0)
goto next_menu;

/*
* If symbol is a choice value and equals to the
* default for a choice - skip.
* But only if value is bool and equal to "y" and
* choice is not "optional".
* (If choice is "optional" then all values can be "n")
*/
if (sym_is_choice_value(sym)) {
struct symbol *cs;
struct symbol *ds;

cs = prop_get_symbol(sym_get_choice_prop(sym));
ds = sym_choice_default(cs);
if (!sym_is_optional(cs) && sym == ds) {
if ((sym->type == S_BOOLEAN) &&
sym_get_tristate_value(sym) == yes)
goto next_menu;
}
}
conf_write_symbol(out, sym, &kconfig_printer_cb, NULL);
}
next_menu:
if (menu->list != NULL) {
menu = menu->list;
}
else if (menu->next != NULL) {
menu = menu->next;
} else {
while ((menu = menu->parent)) {
if (menu->next != NULL) {
menu = menu->next;
break;
}
}
}
}
fclose(out);
return 0;
}

The above function is used to write current configuration data to a file. It’s important to understand how the function works — the main logic is as follows:
1. A list of all symbols is built
2. One by one symbols are written out using the code shown




NEXT




<s> rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_get(rtk_port_t port, rtk_vlan_proto_type_t proto_type, rtk_vlan_protoVlan_frameType_t frame_type, rtk_vlan_protoAndPortInfo_t *pInfo)
{
rtk_api_ret_t retVal;
rtk_uint32 i;
rtk_uint32 ppb_idx;
rtl8367c_protocolgdatacfg ppb_data_cfg;
rtl8367c_protocolvlancfg ppb_vlan_cfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (proto_type > RTK_MAX_NUM_OF_PROTO_TYPE)
return RT_ERR_OUT_OF_RANGE;

if (frame_type >= FRAME_TYPE_END)
return RT_ERR_OUT_OF_RANGE;

ppb_idx = 0;

for (i = 0; i<= RTL8367C_PROTOVLAN_GIDX_MAX; i++)
{
if ((retVal = rtl8367c_getAsicVlanProtocolBasedGroupData(i, &ppb_data_cfg)) != RT_ERR_OK)
return retVal;

if ( (ppb_data_cfg.frameType == (rtl8367c_provlan_frametype)frame_type) && (ppb_data_cfg.etherType == proto_type) )
{
ppb_idx = i;
break;
}
else if (RTL8367C_PROTOVLAN_GIDX_MAX == i)
return RT_ERR_TBL_FULL;
}

if ((retVal = rtl8367c_getAsicVlanPortAndProtocolBased(rtk_switch_port_L2P_get(port), ppb_idx, &ppb_vlan_cfg)) != RT_ERR_OK)
return retVal;

if (FALSE == ppb_vlan_cfg.valid)
return RT_ERR_FAILED;

pInfo->frame_type = frame_type;
pInfo->proto_type = proto_type;
pInfo->cvid = vlan_mbrCfgVid[ppb_vlan_cfg.vlan_idx];
pInfo->cpri = ppb_vlan_cfg.priority;

return RT_ERR_OK;
}

The above function is used to get VLAN configuration and VLAN status.

rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_set(rtk_port_t port, rtk_vlan_proto_




NEXT




<s> static int __init mt7988_pinctrl_init(void)
{
return platform_driver_register(&mt7988_pinctrl_driver);
}

The above function is used to register mt7988_pinctrl platform driver.
After registering the driver, the default configuration of pins will be loaded from fw_pinctrl_defconfig_4.cxx.

# include "




NEXT




<s> void msdc_sdio_profile(struct sdio_profile *result)
{
struct cmd_profile *cmd;
u32 i;

printk("sdio === performance dump ===\n");
printk("sdio === total execute tick<%d> time<%dms> Tx<%dB> Rx<%dB>\n",
result->total_tc, result->total_tc / TICKS_ONE_MS,
result->total_tx_bytes, result->total_rx_bytes);

/* CMD52 Dump */
cmd = &result->cmd52_rx;
printk("sdio === CMD52 Rx <%d>times tick<%d> Max<%d> Min<%d> Aver<%d>\n", cmd->count, cmd->tot_tc,
cmd->max_tc, cmd->min_tc, cmd->tot_tc / cmd->count);
cmd = &result->cmd52_tx;
printk("sdio === CMD52 Tx <%d>times tick<%d> Max<%d> Min<%d> Aver<%d>\n", cmd->count, cmd->tot_tc,
cmd->max_tc, cmd->min_tc, cmd->tot_tc / cmd->count);

/* CMD53 Rx bytes + block mode */
for (i = 0; i < 512; i++) {
cmd = &result->cmd53_rx_byte[i];
if (cmd->count) {
printk("sdio<%6d><%3dB>_Rx_<%9d><%9d><%6d><%6d>_<%9dB><%2dM>\n", cmd->count, i, cmd->tot_tc,
cmd->max_tc, cmd->min_tc, cmd->tot_tc / cmd->count,
cmd->tot_bytes, (cmd->tot_bytes / 10) * 13 / (cmd->tot_tc / 10));
}
}
for (i = 0; i < 100; i++) {
cmd = &result->cmd53_rx_blk[i];
if (cmd->count) {
printk("sdio<%6d><%3d>B_Rx_<%9d><%9d><%6d><%6d>_<%9dB><%2dM>\n", cmd->count, i, cmd->tot_tc,
cmd->max_tc, cmd->min_tc, cmd->tot_tc / cmd->count,
cmd->tot_bytes, (cmd->tot_bytes / 10) * 13 / (cmd->tot_tc / 10));
}
}

/* CMD53 Tx bytes + block mode */
for (i = 0; i < 512; i++) {
cmd = &result->cmd53_tx_byte[i];
if (cmd->count) {
printk("sdio<%6d><%3dB>_Tx_<%9d><%9d><%6d><%6d>_<%9dB><%2dM>\n", cmd->count, i, cmd->tot_tc,
cmd->max_tc, cmd->min_tc, cmd->tot_tc / cmd->count,
cmd->tot_bytes, (cmd->tot_bytes / 10) * 13 / (cmd->tot_tc / 10));
}
}
for (i = 0; i < 100; i++) {
cmd = &result->cmd53_tx_blk[i];
if (cmd->count) {
printk("sdio<%6d><%3d>B_Tx_<%9d><%9d><%6d><%6d>_<%9dB><%2dM>\n", cmd->count, i, cmd->tot_tc,
cmd->max_tc, cmd->min_tc, cmd->tot_tc / cmd->count,
cmd->tot_bytes, (cmd->tot_bytes / 10) * 13 / (cmd->tot_tc / 10));
}
}

printk("sdio === performance dump done ===\n");
}

The above function is used to dump the performance result of various
IO modes of SDIO host.

In the performance, "Burst" means SDIO host is running in multiple
block mode (block count > 10).

If the performance is poor




NEXT




<s> void flush_cache(unsigned long start_addr, unsigned long size)
{
unsigned long lsize = CONFIG_CACHELINE_SIZE;
unsigned long addr = start_addr & ~(lsize - 1);
unsigned long aend = (start_addr + size + (lsize - 1)) & ~(lsize - 1);

printf("blasting from 0x%08x to 0x%08x (0x%08x - 0x%08x)\n", start_addr, size, addr, aend);

while (1) {
cache_op(Hit_Writeback_Inv_D, addr);
cache_op(Hit_Invalidate_I, addr);
if (addr == aend)
break;
addr += lsize;
}
}

The above function is used to clear cache when the buffer needs to be cleared.

The main problem I see is that the kernel is able to call the function
when the buffer is being cleared. If a kernel driver does the
clear, it means the buffer would be




NEXT




<s> static void _rtl8367c_svlanSp2cStUser2Smi(rtl8367c_svlan_s2c_t *pUserSt, rtk_uint16 *pSmiSt)
{
pSmiSt[0] |= (pUserSt->dstport & 0x0007);
pSmiSt[0] |= (pUserSt->svidx & 0x003F) << 3;
pSmiSt[0] |= ((pUserSt->dstport & 0x0008) >> 3) << 9;

pSmiSt[1] |= (pUserSt->vid & 0x0FFF);
pSmiSt[1] |= (pUserSt->valid & 0x0001) << 12;
}

The above function is used to map rtl8367c_svlan_s2c_t to smi register, the pUserSt struct is defined as below:

typedef struct
{
rtk_uint16   vid;




NEXT




<s> static void hostapd_ubus_ref_dec(void)
{
ctx_ref--;
if (!ctx)
return;

if (ctx_ref)
return;

uloop_fd_delete(&ctx->sock);
ubus_free(ctx);
ctx = NULL;
}

The above function is used to close and then free the structure used
to store the details of the connection to ubusd.

The function is called by the main program if:

1) No more connections are used,
OR
ubusd closes




NEXT




<s> static unsigned int ptm_poll(int, unsigned int);
static int ptm_napi_poll(struct napi_struct *, int);
static int ptm_hard_start_xmit(struct sk_buff *, struct net_device *);
static int ptm_ioctl(struct net_device *, struct ifreq *, int);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
static void ptm_tx_timeout(struct net_device *);
#else
static void ptm_tx_timeout(struct net_device *, unsigned int txqueue);
#endif

static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to calculate checksum only
#define PTMDISCVLANID		0x8100

#define PTM_CHECKSUM_SKB	2
#define PTMTX_QUEUES	8 /* 7




NEXT




<s> header_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
{

switch (sym->type) {
case S_BOOLEAN:
case S_TRISTATE: {
const char *suffix = "";

switch (*value) {
case 'n':
break;
case 'm':
suffix = "_MODULE";
/* fall through */
default:
fprintf(fp, "#define %s%s%s 1\n",
CONFIG_, sym->name, suffix);
}
break;
}
case S_HEX: {
const char *prefix = "";

if (value[0] != '0' || (value[1] != 'x' && value[1] != 'X'))
prefix = "0x";
fprintf(fp, "#define %s%s %s%s\n",
CONFIG_, sym->name, prefix, value);
break;
}
case S_STRING:
case S_INT:
fprintf(fp, "#define %s%s %s\n",
CONFIG_, sym->name, value);
break;
default:
break;
}

}

The above function is used to output a configuration line for a given symbol name and value; the S_ value specifies the type of the symbol (int, string, #define, etc.).  You can use S_AUTO to have a header_define(5) macro




NEXT




<s> rtk_api_ret_t rtk_qos_dscpRemark_set(rtk_pri_t int_pri, rtk_dscp_t dscp)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (int_pri > RTK_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

if (dscp > RTK_DSCPMAX)
return RT_ERR_QOS_DSCP_VALUE;

if ((retVal = rtl8367c_setAsicRemarkingDscpParameter(int_pri, dscp)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set DSCP marking function parameters for prioritization. It marks DSCP to different port priority values. This function is used in both forwarding and mirror ports.

# DSCP Remarking Function

DSC




NEXT




<s> static inline void rtl838x_exec_tbl1_cmd(u32 cmd)
{
sw_w32(cmd, RTL838X_TBL_ACCESS_CTRL_1);
do { } while (sw_r32(RTL838X_TBL_ACCESS_CTRL_1) & BIT(15));
}

The above function is used to trigger the execution of the command
that is stored in one of the five 16-byte cmd tables.

static inline void rtl838x_write_tbl1_cmd(u32 base, u16




NEXT




<s> void rtl_table_init(void)
{
for (int i = 0; i < RTL_TBL_END; i++)
mutex_init(&rtl838x_tbl_regs[i].lock);
}

The above function is used to initialize the mutex in rtl_table.</s>




NEXT




<s> static inline size_t block_offset(int block)
{
return VFS_ERASEBLOCK_SIZE * (block / (VFS_BLOCKS_PER_ERASEBLOCK-1))
+ VFS_BLOCK_SIZE * (1 + (block % (VFS_BLOCKS_PER_ERASEBLOCK-1)));
}

The above function is used to calculate the start block of the block group, and how many blocks are used.
The problem is: how to start?
The FAT32 boot record does not contain any information about the location of the first block group.
However,




NEXT




<s> ar8xxx_phy_detach(struct phy_device *phydev)
{
struct net_device *dev = phydev->attached_dev;

if (!dev)
return;

#ifdef CONFIG_ETHERNET_PACKET_MANGLE
dev->phy_ptr = NULL;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
dev->priv_flags &= ~IFF_NO_IP_ALIGN;
#else
dev->extra_priv_flags &= ~IFF_NO_IP_ALIGN;
#endif
dev->eth_mangle_rx = NULL;
dev->eth_mangle_tx = NULL;
#endif
}

The above function is used to detach the physical layer device from one device. In general, a physical layer device is attached to one device at a time.

#ifdef CONFIG_ETHERNET_PACKET_MANGLE
dev->phy_ptr;





NEXT




<s> static nvram_handle_t * nvram_open_staging(void)
{
if( nvram_find_staging() != NULL || nvram_to_staging() == 0 )
return nvram_open(NVRAM_STAGING, NVRAM_RW);

return NULL;
}

The above function is used to check whether a staging file exists or not.
And it creates the staging file too if file does not exists in flash.
The problem is in function nvram_to_staging(), which is responsible for
generating the st




NEXT




<s> void BN_CTX_init(BN_CTX *ctx)
{
int i;
ctx->tos = 0;
ctx->flags = 0;
ctx->depth = 0;
ctx->too_many = 0;
for (i = 0; i < BN_CTX_NUM; i++)
BN_init(&(ctx->bn[i]));
}

The above function is used to initialize a BN_CTX structure for use in Big Number Library. This post can be considered a part of my study towards securing BN-based applications.</s>




NEXT




<s> ret_t rtl8367c_getAsicTrunkingHashSelect(rtk_uint32* pHashsel)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_HASH_MASK, pHashsel);
}

The above function is used to query Asic hash select for trunk port. If the value is 0, the hash selection is according to the port number. If the value is 1, the hash selection is according to Vlan number.

In the example bellow




NEXT




<s> static void rtl931x_sds_rst(u32 sds)
{
u32 o, v, o_mode;
int shift = ((sds & 0x3) << 3);

/* TODO: We need to lock this! */

o = sw_r32(RTL931X_PS_SERDES_OFF_MODE_CTRL_ADDR);
v = o | BIT(sds);
sw_w32(v, RTL931X_PS_SERDES_OFF_MODE_CTRL_ADDR);

o_mode = sw_r32(RTL931X_SERDES_MODE_CTRL + 4 * (sds >> 2));
v = BIT(7) | 0x1F;
sw_w32_mask(0xff << shift, v << shift, RTL931X_SERDES_MODE_CTRL + 4 * (sds >> 2));
sw_w32(o_mode, RTL931X_SERDES_MODE_CTRL + 4 * (sds >> 2));

sw_w32(o, RTL931X_PS_SERDES_OFF_MODE_CTRL_ADDR);
}

The above function is used to reset specific serdes lane.

The serdes_mode_ctrl_reg is an array of size 32, where a write to index x controls the x-th lane in an 8x lane PHY.
Bit 




NEXT




<s> IFX_MEI_LongWordWriteOffset (DSL_DEV_Device_t * pDev, u32 ul_address,
u32 ul_data)
{
IFX_MEI_WRITE_REGISTER_L (ul_data, pDev->base_address + ul_address);
wmb();
return;
}

The above function is used to write long-word (32-bit) value to
a user-configurable register in the MEI Daughter Board.
The MEI Daughterboard consists of two subblocks: the Data Converter
Block (DCB)




NEXT




<s> rtk_api_ret_t rtk_igmp_checksumErrorAction_set(rtk_igmp_checksumErrorAction_t action)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(action >= IGMP_CRC_ERR_OP_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIGMPCRCErrOP((rtk_uint32)action))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the igmp checksum error action.

rtk_api_t | 17482 |
rtl8367c_setAsicIGMPCRCErrOP() | 3000




NEXT




<s> int rtl839x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val)
{
int err = 0;
u32 v;

/* Take bug on RTL839x Rev <= C into account */
if (port >= RTL839X_CPU_PORT)
return -EIO;

mutex_lock(&smi_lock);

/* Set PHY to access */
rtl839x_set_port_reg_le(BIT_ULL(port), RTL839X_PHYREG_PORT_CTRL);

/* Set data to write */
sw_w32_mask(0xffff << 16, val << 16, RTL839X_PHYREG_DATA_CTRL);

/* Set MMD device number and register to write to */
sw_w32(devnum << 16 | (regnum & 0xffff), RTL839X_PHYREG_MMD_CTRL);

v = BIT(3) | BIT(2) | BIT(0); /* WRITE | MMD-access | EXEC */
sw_w32(v, RTL839X_PHYREG_ACCESS_CTRL);

err = rtl839x_smi_wait_op(100000);
if (err)
goto errout;

pr_debug("%s: port %d, regnum: %x, val: %x (err %d)\n", __func__, port, regnum, val, err);

errout:
mutex_unlock(&smi_lock);

return err;
}

The above function is used to write a register on a phy port. Note the order in which the registries are set, and make sure you have read up on the MMD register format.

Hopefully this has helped anyone with similar questions as me.




NEXT




<s> IFX_MEI_CleanUpDevNode (int num)
{
if (num == 0)
unregister_chrdev (dev_major, MEI_DIRNAME);
return 0;
}

The above function is used to clean-up the device nodes, which were registered in the earlier function, ifx_mei_setup_devnodes. The ifx_mei_cleanup_devnodes function is called, when the module is exiting.






NEXT




<s> ret_t rtl8367c_getAsicSvlanDefaultVlan(rtk_uint32 port, rtk_uint32* pIndex)
{
ret_t retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8){
if(port & 1)
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL0 + (port >> 1), RTL8367C_VS_PORT1_SVIDX_MASK,pIndex);
else
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL0 + (port >> 1), RTL8367C_VS_PORT0_SVIDX_MASK,pIndex);
}else{
switch(port){
case 8:
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL4, RTL8367C_VS_PORT8_SVIDX_MASK,pIndex);
break;

case 9:
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL4, RTL8367C_VS_PORT9_SVIDX_MASK,pIndex);
break;

case 10:
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL5, RTL8367C_SVLAN_PORTBASED_SVIDX_CTRL5_MASK,pIndex);
break;
}
}

return retVal;

}

The above function is used to get current VS Id for port based SVLAN and return the value to pIndex.

The code is tested by below program.

#if 1
#define _XOPEN_SOURCE 500
#include <




NEXT




<s> static int ip17xx_read_status(struct phy_device *pdev)
{
pdev->speed = SPEED_100;
pdev->duplex = DUPLEX_FULL;
pdev->pause = pdev->asym_pause = 0;
pdev->link = 1;

return 0;
}

The above function is used to identify how the PHY link status is to be determined. By default for all switches supported.

This is the flowchart on how this driver works:

Here in this case you have to make sure that pdev->init(




NEXT




<s> void ifx_deu_des_encrypt (struct crypto_tfm *tfm, uint8_t * out, const uint8_t * in)
{
struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(tfm);
ifx_deu_des (ctx, out, in, NULL, DES_BLOCK_SIZE,
CRYPTO_DIR_ENCRYPT, 0);

}

The above function is used to encrypt data using the DES algorithm in ECB mode, 64 bit blocks of data are taken as input (8 bytes) and 64 bit blocks as output (8 bytes). The first 7 bytes of the out bytes are always




NEXT




<s> void mt7530_mdio_w32(struct mt7620_gsw *gsw, u32 reg, u32 val)
{
_mt7620_mii_write(gsw, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
_mt7620_mii_write(gsw, 0x1f, (reg >> 2) & 0xf,  val & 0xffff);
_mt7620_mii_write(gsw, 0x1f, 0x10, val >> 16);
}

The above function is used to write multiple registers to MDIO.

I would like to write a command to the Ethernet driver to initiate
the MDIO read/write to the MDIO registers in order to be able to read
the MDIO PHY




NEXT




<s> static void myoutput(void *arg, char *s, int l)
{
int i;

// special termination call
if ((l==1) && (s[0] == '\0')) return;

for (i=0; i< l; i++) {
Uart16550Put(s[i]);
if (s[i] == '\n') Uart16550Put('\r');
}
}

The above function is used to output some text, it takes a character string and prints it out to the UART using a very simple function (not to be used in any production code!).

Let's start the program:

int main(void) {}




NEXT




<s> static int rtcl_probe_late(struct platform_device *pdev)
{
int ret;

if (!rtcl_ccu) {
dev_err(&pdev->dev, "early initialization not run");
return -ENXIO;
}
rtcl_ccu->pdev = pdev;
ret = rtcl_init_sram();
if (ret)
return ret;

rtcl_ccu_log_late();

return 0;
}

The above function is used to test the operation
of clock tree subsystem late phase.</s>




NEXT




<s> static void sata_oxnas_irq_on(struct ata_port *ap);
static void sata_oxnas_post_reset_init(struct ata_port *ap);

static int sata_oxnas_acquire_hw(struct ata_port *ap, int may_sleep,
int timeout_jiffies);
static void sata_oxnas_release_hw(struct ata_port *ap);

static const void *HW_LOCKER_UID = (void *)0xdeadbeef;

/***************************************************************************
* ASIC access
***************************************************************************/
static void wait_cr_ack(void __iomem *phy_base)
{
while ((ioread32(phy_base + PHY_STAT) >> 16) & 0x1f)
; /* wait for an ack bit to be set */
}

The above function is used to spinwait on the data transfer completing on
the PHY port.

/***************************************************************************
* Oxnas SATA port init
***************************************************************************/
static void sata_oxnas_port_




NEXT




<s> ret_t rtl8367c_getAsic1xGVOpdir(rtk_uint32 *pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_GVOPDIR_OFFSET, pEnabled);
}

The above function is used to get/set the 'dot1x gvopdir' bit from/to the corresponding physical register. You can call this function multiple times to read/write the 'dot1x gvopdir' bit. For example:
rt




NEXT




<s> static int rtl931x_pie_rule_write(struct rtl838x_switch_priv *priv, int idx, struct pie_rule *pr)
{
/* Access IACL table (0) via register 1, the table size is 4096 */
struct table_reg *q = rtl_table_get(RTL9310_TBL_1, 0);
u32 r[22];
int block = idx / PIE_BLOCK_SIZE;
u32 t_select = sw_r32(RTL931X_PIE_BLK_TMPLTE_CTRL(block));

pr_info("%s: %d, t_select: %08x\n", __func__, idx, t_select);

for (int i = 0; i < 22; i++)
r[i] = 0;

if (!pr->valid) {
rtl_table_write(q, idx);
rtl_table_release(q);
return 0;
}
rtl931x_write_pie_fixed_fields(r, pr);

pr_info("%s: template %d\n", __func__, (t_select >> (pr->tid * 4)) & 0xf);
rtl931x_write_pie_templated(r, pr, fixed_templates[(t_select >> (pr->tid * 4)) & 0xf]);

rtl931x_write_pie_action(r, pr);

rtl931x_pie_rule_dump_raw(r);

for (int i = 0; i < 22; i++)
sw_w32(r[i], rtl_table_data(q, i));

rtl_table_write(q, idx);
rtl_table_release(q);

return 0;
}

The above function is used to download a pie_rule (Pie Rule) to Ethernet Switch Controller,
and it is related to the PIE (Packet In Encap) engine.

The pie_rules are used for encapsulation of packets in E




NEXT




<s> static void rtl931x_write_cam(int idx, struct rtl838x_l2_entry *e)
{
}

The above function is used to write RTL838X (9310, 9312) L2 multicast address
entry to TCAM. Below is the definition of the above function.

static void rtl836x




NEXT




<s> static int __init mtdsplit_fit_init(void)
{
register_mtd_parser(&uimage_parser);

return 0;
}

The above function is used to initialize the firmware loading driver. The main functionality of this function is to register the U-boot parser and fit loader with the module.

/*
 * U-Boot and FIT parsers. This module is used to parse the u




NEXT




<s> extern int rtl838x_read_sds_phy(int phy_addr, int phy_reg);
extern int rtl839x_read_sds_phy(int phy_addr, int phy_reg);
extern int rtl839x_write_sds_phy(int phy_addr, int phy_reg, u16 v);
extern int rtl930x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl930x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl931x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl931x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl930x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl930x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);
extern int rtl931x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl931x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);

/* On the RTL93XX, the RTL93XX_DMA_IF_RX_RING_CNTR track the fill level of
* the rings. Writing x into these registers substracts x from its content.
* When the content reaches the ring size, the ASIC no longer adds
* packets to this receive queue.
*/
void rtl838x_update_cntr(int r, int released)
{
/* This feature is not available on RTL838x SoCs */
}

The above function is used to track the fill level of the RTL838x's receive queues. If the function is needed on your platform, simply define it in your platform HAL.

## RX and TX Frame Queuing

RTL9




NEXT




<s> mtd_dump(const char *mtd, int part_offset, int size)
{
int ret = 0, offset = 0;
int fd;
char *buf;

if (quiet < 2)
fprintf(stderr, "Dumping %s ...\n", mtd);

fd = mtd_check_open(mtd);
if(fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd);
return -1;
}

if (!size)
size = mtdsize;

if (part_offset)
lseek(fd, part_offset, SEEK_SET);

buf = malloc(erasesize);
if (!buf)
return -1;

do {
int len = (size > erasesize) ? (erasesize) : (size);
int rlen = read(fd, buf, len);

if (rlen < 0) {
if (errno == EINTR)
continue;
ret = -1;
goto out;
}
if (!rlen || rlen != len)
break;
if (mtd_block_is_bad(fd, offset)) {
fprintf(stderr, "skipping bad block at 0x%08x\n", offset);
} else {
size -= rlen;
write(1, buf, rlen);
}
offset += rlen;
} while (size > 0);

out:
close(fd);
return ret;
}

The above function is used to dump a MT-D of a given device. We can use a block size of 4096 (erasesize = 4096), or a larger block size with a MT-D block size of more than 4




NEXT




<s> ret_t rtl8367c_getAsicPortEnableAll(rtk_uint32 *pEnable)
{
ret_t retVal;
rtk_uint32 regData;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_PHY_AD, RTL8367C_PDNPHY_OFFSET, &regData);
if(retVal !=  RT_ERR_OK)
return retVal;

if (regData==0)
*pEnable = 1;
else
*pEnable = 0;

return RT_ERR_OK;
}

The above function is used to determine if the selected port's PHY has been activated or deactivated by the end user. This function accesses the PDNPHY register.

The register is 32 bits long.
The offset of this register is 




NEXT




<s> static int aca_hif_param_init(struct dc_ep_priv *priv)
{
struct dc_aca *aca  = to_aca(priv);

aca->hif_params = kzalloc(sizeof(struct aca_hif_params), GFP_KERNEL);
if (!aca->hif_params)
return -ENOMEM;
aca->hif_params->task_mask = 0x0000000F;
dev_dbg(priv->dev, "%s\n", __func__);
return 0;
}

The above function is used to initialize hif param struct. If aca->hif_params->task_mask is not 0x1,
Then the BGR format is chosen.
Then the bgr format can not generate the YCC422 output




NEXT




<s> static inline void init_pdma(void);
static inline void init_mailbox(void);
static inline void init_atm_tc(void);
static inline void clear_share_buffer(void);

#define IFX_PMU_MODULE_PPE_SLL01  BIT(19)
#define IFX_PMU_MODULE_PPE_TC     BIT(21)
#define IFX_PMU_MODULE_PPE_EMA    BIT(22)
#define IFX_PMU_MODULE_PPE_QSB    BIT(18)
#define IFX_PMU_MODULE_AHBS       BIT(13)
#define IFX_PMU_MODULE_DSL_DFE    BIT(9)


static inline void init_pmu(void)
{
ltq_pmu_enable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_AHBS |
IFX_PMU_MODULE_DSL_DFE);

}

The above function is used to initialize power management unit of the SOC.
It enables all the modules except the QSB module. The QSB module is
enabled programmatically later.
The power management unit is used to power ON/OFF various peripherals.





NEXT




<s> int DSL_BSP_EventCBRegister(DSL_BSP_EventCallBack_t *p)
{
if (!p) {
IFX_MEI_EMSG("Invalid parameter!\n");
return -EINVAL;
}
if (p->event > DSL_BSP_CB_LAST || p->event < DSL_BSP_CB_FIRST) {
IFX_MEI_EMSG("Invalid Event %d\n", p->event);
return -EINVAL;
}
if (dsl_bsp_event_callback[p->event].function) {
IFX_MEI_EMSG("Event %d already has a callback function registered!\n", p->event);
return -1;
} else {
dsl_bsp_event_callback[p->event].function = p->function;
dsl_bsp_event_callback[p->event].event    = p->event;
dsl_bsp_event_callback[p->event].pData    = p->pData;
}
return 0;
}

The above function is used to register for an event notification.
Here, event type to be registered is DSL_BSP_CB_RESET.</s>




NEXT




<s> static int rtl8366_get_mib_counter(struct rtl8366_smi *smi, int counter,
int port, unsigned long long *val)
{
int i;
int err;
u32 addr, data;
u64 mibvalue;

if (port > RTL8366S_NUM_PORTS || counter >= RTL8366S_MIB_COUNT)
return -EINVAL;

switch (rtl8366s_mib_counters[counter].base) {
case 0:
addr = RTL8366S_MIB_COUNTER_BASE +
RTL8366S_MIB_COUNTER_PORT_OFFSET * port;
break;

case 1:
addr = RTL8366S_MIB_COUNTER_BASE2 +
RTL8366S_MIB_COUNTER_PORT_OFFSET2 * port;
break;

default:
return -EINVAL;
}

addr += rtl8366s_mib_counters[counter].offset;

/*
* Writing access counter address first
* then ASIC will prepare 64bits counter wait for being retrived
*/
data = 0; /* writing data will be discard by ASIC */
err = rtl8366_smi_write_reg(smi, addr, data);
if (err)
return err;

/* read MIB control register */
err =  rtl8366_smi_read_reg(smi, RTL8366S_MIB_CTRL_REG, &data);
if (err)
return err;

if (data & RTL8366S_MIB_CTRL_BUSY_MASK)
return -EBUSY;

if (data & RTL8366S_MIB_CTRL_RESET_MASK)
return -EIO;

mibvalue = 0;
for (i = rtl8366s_mib_counters[counter].length; i > 0; i--) {
err = rtl8366_smi_read_reg(smi, addr + (i - 1), &data);
if (err)
return err;

mibvalue = (mibvalue << 16) | (data & 0xFFFF);
}

*val = mibvalue;
return 0;
}

The above function is used to retrieve the MIB value from the register on ASIC.</s>




NEXT




<s> extern void __ehci_set_usbmode(int index);
void ehci_set_usbmode(int index)
{
#define  or_txttfill_tuning	_reserved_1_[0]
u32 tmp;

__ehci_set_usbmode(index);

tmp = ehci_readl(&ghcor->or_txfilltuning);
tmp &= ~0x00ff0000;
tmp |= 0x003f0000; /* set burst pre load count to 0x40 (63 * 4 bytes)  */
tmp |= 0x16; /* set sheduler overhead to 22 * 1.267us (HS) or 22 * 6.33us (FS/LS)*/
ehci_writel(&ghcor->or_txfilltuning, tmp);

tmp = ehci_readl(&ghcor->or_txttfill_tuning);
tmp |= 0x2; /* set sheduler overhead to 2 * 6.333us */
ehci_writel(&ghcor->or_txttfill_tuning, tmp);
}

The above function is used to configure the transfer tuning parameters in HCOR.

extern void __ehci_set_usbmode(int index);
void ehci_set_usbmode(int index)
{
#define  or_txt




NEXT




<s> rtk_api_ret_t rtk_filter_vidrange_get(rtk_uint32 index, rtk_filter_vidrange_t *pType, rtk_uint32 *pUpperVid, rtk_uint32 *pLowerVid)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if((NULL == pType) || (NULL == pUpperVid) || (NULL == pLowerVid))
return RT_ERR_NULL_POINTER;

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

if((ret = rtl8367c_getAsicAclVidRange(index, pType, pUpperVid, pLowerVid)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to get the default value of FILTER_VIDRANGE entry.

r_1: The index is less than 0 or Index greater than 7.
r_2: The pType, pUpperVid or pLowerV




NEXT




<s> static int ip17xx_set_port_speed(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int nr = val->port_vlan;
int ctrl;
int autoneg;
int speed;
if (val->value.i == 100) {
speed = 1;
autoneg = 0;
} else if (val->value.i == 10) {
speed = 0;
autoneg = 0;
} else {
autoneg = 1;
speed = 1;
}

/* Can't set speed for cpu port */
if (nr == state->regs->CPU_PORT)
return -EINVAL;

if (nr >= dev->ports || nr < 0)
return -EINVAL;

ctrl = ip_phy_read(state, nr, 0);
if (ctrl < 0)
return -EIO;

ctrl &= (~(1<<12));
ctrl &= (~(1<<13));
ctrl |= (autoneg<<12);
ctrl |= (speed<<13);

return ip_phy_write(state, nr, 0, ctrl);
}

The above function is used to set the port speed for specified port. As I show below this function is used to set port speed 100Mbps for port 1.

cat /sys/class/net/eth0/phys/phy0/




NEXT




<s> int init_led(struct led **led, char *ledname)
{
struct led *newled;
struct stat statbuffer;
int status;
char *bp;
FILE *bfp;

bp = calloc(sizeof(char), strlen(ledname) + strlen(LEDS_BASEPATH) + 12);
if ( ! bp )
goto return_error;

sprintf(bp, "%s%s/brightness", LEDS_BASEPATH, ledname);

status = stat(bp, &statbuffer);
if ( status )
goto cleanup_fname;

bfp = fopen( bp, "w" );
if ( !bfp )
goto cleanup_fname;

if ( ferror(bfp) )
goto cleanup_fp;

/* sysfs path exists and, allocate LED struct */
newled = calloc(sizeof(struct led),1);
if ( !newled )
goto cleanup_fp;

newled->sysfspath = bp;
newled->controlfd = bfp;

*led = newled;

if ( set_led(newled, 255) )
goto cleanup_fp;

if ( set_led(newled, 0) )
goto cleanup_fp;

return 0;

cleanup_fp:
fclose(bfp);
cleanup_fname:
free(bp);
return_error:
syslog(LOG_CRIT, "can't open LED %s\n", ledname);
*led = NULL;
return -1;
}

The above function is used to create a new struct led,
pointing it to the sysfs file ( /sys/class/leds/\<ledname\>\/brightness ).
When the function completes successfully, the LED is set to 25




NEXT




<s> ret_t rtl8367c_getAsicLutIpmcFwdRouterPort(rtk_uint32 *pEnable)
{
if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG2, RTL8367C_LUT_IPMC_FWD_RPORT_OFFSET, pEnable);
}

The above function is used to read the 18th bit from the rtl8367c_lut_cfg2 register. The rtl8367c_reg_lut_cfg2 register holds the following bitfields:

+




NEXT




<s> static void lzma_init_data(void)
{
extern unsigned char _lzma_data_start[];
extern unsigned char _lzma_data_end[];

kernel_la = LOADADDR;
lzma_data = _lzma_data_start;
lzma_datasize = _lzma_data_end - _lzma_data_start;
}

The above function is used to initialize _lzma_data_start and _lzma_data_end. However, this code is only compiled in linux-xen kernel build and does nothing on the root filesystem (as you are correct in pointing out




NEXT




<s> static int b53_do_vlan_op(struct b53_device *dev, u8 op)
{
unsigned int i;

b53_write8(dev, B53_ARLIO_PAGE, dev->vta_regs[0], VTA_START_CMD | op);

for (i = 0; i < 10; i++) {
u8 vta;

b53_read8(dev, B53_ARLIO_PAGE, dev->vta_regs[0], &vta);
if (!(vta & VTA_START_CMD))
return 0;

usleep_range(100, 200);
}

return -EIO;
}

The above function is used to setup VLAN configuration in B53. The b53_vlan_add function also internally invokes a variant of the above function (see b53_vlan_add).

The other problem, which I encountered




NEXT




<s> static void sata_oxnas_host_stop(struct ata_host *host_set)
{
DPRINTK("\n");
}

The above function is used to stop the DMA transfers before putting the
oxnas OHCI Controller into its reset state.  We don't do this in the
initalization function because the controller could be in any mode at that time and
trying to




NEXT




<s> static void aw9523_irq_bus_sync_unlock(struct irq_data *d)
{
struct aw9523 *awi = gpiochip_get_data(irq_data_get_irq_chip_data(d));

regcache_cache_only(awi->regmap, false);
regcache_sync(awi->regmap);
mutex_unlock(&awi->irq->lock);
}

The above function is used to unlock the IRQ bus. This function is actually
called only if irq_data_bus_sync_unlock() returns 0 - as is the case when
irq_data_bus_sync_unlock() is called while irq_set




NEXT




<s> static char* upperstr(char *str) {
for (char *s = str; *s; s++)
*s = toupper((unsigned char) *s);
return str;
}

The above function is used to convert a character string into an all capital letters character string. The function has two parameters. The first one is a pointer to the character string that needs to be modified and the second one is a pointer to character that returns the new string that has been




NEXT




<s> static int rtl8366s_is_vlan_valid(struct rtl8366_smi *smi, unsigned vlan)
{
unsigned max = RTL8366S_NUM_VLANS;

if (smi->vlan4k_enabled)
max = RTL8366S_NUM_VIDS - 1;

if (vlan == 0 || vlan >= max)
return 0;

return 1;
}

The above function is used to determine whether a specific VLAN is valid
for inclusion in a QinQ trunk port.

Since the rtl8366s_is_vlan_valid() is supposed to be only used to check the trunk
V




NEXT




<s> rtk_api_ret_t rtk_igmp_dropLeaveZeroEnable_get(rtk_enable_t *pEnabled)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnabled)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPDropLeaveZero((rtk_uint32 *)pEnabled))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;

}

The above function is used to get the IGMP-join/leave drop by zero member count .</s>




NEXT




<s> int rtl931x_sds_cmu_band_set(int sds, bool enable, u32 band, phy_interface_t mode)
{
u32 asds;
int page = rtl931x_sds_cmu_page_get(mode);

sds -= (sds % 2);
sds = sds & ~1;
asds = rtl931x_get_analog_sds(sds);
page += 1;

if (enable) {
rtl9310_sds_field_w(asds, page, 0x7, 13, 13, 0);
rtl9310_sds_field_w(asds, page, 0x7, 11, 11, 0);
} else {
rtl9310_sds_field_w(asds, page, 0x7, 13, 13, 0);
rtl9310_sds_field_w(asds, page, 0x7, 11, 11, 0);
}

rtl9310_sds_field_w(asds, page, 0x7, 4, 0, band);

rtl931x_sds_rst(sds);

return 0;
}

The above function is used to set sds parameters of rtl2832u based devices. As you can see, this function sets the frequency band
used by the sds. The valid ranges of frequency band are in the table below.


Samples




NEXT




<s> void ifx_ptm_init_chip(struct platform_device *pdev)
{
init_pmu();

reset_ppe(pdev);

init_pdma();

init_mailbox();

init_atm_tc();

clear_share_buffer();
}

The above function is used to initialize the PHY of ifx_ptm. However the order of these function is not properly followed. For e.g.: in reset_ppe() function PLL is initialized and then after ptm_init() function, a call to




NEXT




<s> block_dev_desc_t * spl_get_block_device(void)
{
block_dev_desc_t * device;

spl_block_device_init();

device = get_dev(CONFIG_SPL_BLOCKDEV_INTERFACE, CONFIG_SPL_BLOCKDEV_ID);
if (!device) {
printf("blk device %s%d not exists\n",
CONFIG_SPL_BLOCKDEV_INTERFACE,
CONFIG_SPL_BLOCKDEV_ID);
hang();
}

return device;
}

The above function is used to get a block device. We pass two parameters to this function; one is the interface name. This is used to indicate which interface the driver can be searched according to its name. The second parameter indicates this block device’s ID. This field is




NEXT




<s> static void ubnt_ledbar_reset(struct ubnt_ledbar *ledbar)
{
static const char init_msg[16] = {0x02, 0x81, 0xfd, 0x7e,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00};
char init_response[4];

if (!ledbar->reset_gpio)
return;

mutex_lock(&ledbar->lock);

gpiod_set_value(ledbar->reset_gpio, 1);
msleep(10);
gpiod_set_value(ledbar->reset_gpio, 0);

msleep(10);

gpiod_set_value(ledbar->enable_gpio, 1);
msleep(10);
ubnt_ledbar_perform_transaction(ledbar, init_msg, sizeof(init_msg), init_response, sizeof(init_response));
msleep(10);
gpiod_set_value(ledbar->enable_gpio, 0);

mutex_unlock(&ledbar->lock);
}

The above function is used to reset the Ubnt LED bar after we finish our program.
The main loop of our program is written as follows. We wait for 3 minutes 20 seconds before we reset the LED bar.


309 ms





NEXT




<s> rtk_api_ret_t rtk_qos_dscpPriRemap_set(rtk_dscp_t dscp, rtk_pri_t int_pri)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (int_pri > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

if (dscp > RTL8367C_DSCPMAX)
return RT_ERR_QOS_DSCP_VALUE;

if ((retVal = rtl8367c_setAsicPriorityDscpBased(dscp, int_pri)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the remapped output port's priorities based upon the input DSCP value. The function is provided to reduce the hardware complexity in the QoS chip.

To remap the priorities, an input DSCP value (which




NEXT




<s> static ssize_t read_file_rx_ring(struct file *file, char __user *user_buf,
size_t count, loff_t *ppos)
{
struct ag71xx *ag = file->private_data;

return read_file_ring(file, user_buf, count, ppos, ag, &ag->rx_ring,
AG71XX_REG_RX_DESC);
}

The above function is used to read a file backed with a TX ring. To use it
effectively, you need to call set_file_backing_dev() for the file with which you
want to work with the ring. And make sure that your structure field




NEXT




<s> static int fe_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
struct fe_priv *priv = netdev_priv(dev);

if (!priv->phy_dev)
return -ENODEV;


return phy_mii_ioctl(priv->phy_dev, ifr, cmd);
}

The above function is used to implement ioctl() on the device. Since mII
is used, we need to use phy_mii_ioctl()
function from net/phy/mii.c.</s>




NEXT




<s> int aes_set_key (struct crypto_tfm *tfm, const u8 *in_key, unsigned int key_len)
{
struct aes_ctx *ctx = crypto_tfm_ctx(tfm);

//printk("set_key in %s\n", __FILE__);

//aes_chip_init();

if (key_len != 16 && key_len != 24 && key_len != 32) {
return -EINVAL;
}

ctx->key_length = key_len;
ctx->use_tweak = 0;
DPRINTF(0, "ctx @%p, key_len %d, ctx->key_length %d\n", ctx, key_len, ctx->key_length);
memcpy ((u8 *) (ctx->buf), in_key, key_len);

return 0;
}

The above function is used to save the plain text or cipher text in struct aes_ctx structure.

We use the below function to send message to aes_encrypt .
aes_encrypt() is basically used to encrypt the data using key




NEXT




<s> static int rtl839x_pie_rule_write(struct rtl838x_switch_priv *priv, int idx, struct pie_rule *pr)
{
/* Access IACL table (2) via register 0 */
struct table_reg *q = rtl_table_get(RTL8390_TBL_0, 2);
u32 r[17];
int block = idx / PIE_BLOCK_SIZE;
u32 t_select = sw_r32(RTL839X_ACL_BLK_TMPLTE_CTRL(block));

pr_debug("%s: %d, t_select: %08x\n", __func__, idx, t_select);

for (int i = 0; i < 17; i++)
r[i] = 0;

if (!pr->valid) {
rtl_table_write(q, idx);
rtl_table_release(q);
return 0;
}
rtl839x_write_pie_fixed_fields(r, pr);

pr_debug("%s: template %d\n", __func__, (t_select >> (pr->tid * 3)) & 0x7);
rtl839x_write_pie_templated(r, pr, fixed_templates[(t_select >> (pr->tid * 3)) & 0x7]);

rtl839x_write_pie_action(r, pr);

/*	rtl839x_pie_rule_dump_raw(r); */

for (int i = 0; i < 17; i++)
sw_w32(r[i], rtl_table_data(q, i));

rtl_table_write(q, idx);
rtl_table_release(q);

return 0;
}

The above function is used to set PIE (port based flow control) data.</s>




NEXT




<s> ret_t rtl8367c_getAsicMIBsLength(rtk_uint32 *pTxLengthMode, rtk_uint32 *pRxLengthMode)
{
ret_t retVal;

if( (retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_RMON_LEN_CTRL, RTL8367C_TX_LENGTH_CTRL_OFFSET, pTxLengthMode)) != RT_ERR_OK)
return retVal;

if( (retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_RMON_LEN_CTRL, RTL8367C_RX_LENGTH_CTRL_OFFSET, pRxLengthMode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the TX/RX RMON length mode from the register RTL8367C_REG_MIB_RMON_LEN_CTRL. Based on the above function, the following function is used to set the TX/RX R




NEXT




<s> static inline int rtl931x_mac_port_ctrl(int p)
{
return RTL931X_MAC_L2_PORT_CTRL + (p << 7);
}

The above function is used to convert the port number to an address
which contains the port control register as well as port mapping
registers. Since we want to read the port control register, we need
to mask it out from the above number like so.

static




NEXT




<s> static int mt7621_nfc_exec_op(struct nand_chip *nand,
const struct nand_operation *op, bool check_only)
{
struct mt7621_nfc *nfc = nand_get_controller_data(nand);
int i, ret;

if (check_only)
return 0;

/* Only CS0 available */
nfi_write16(nfc, NFI_CSEL, 0);

for (i = 0; i < op->ninstrs; i++) {
ret = mt7621_nfc_exec_instr(nand, &op->instrs[i]);
if (ret)
return ret;
}

return 0;
}

The above function is used to call 20100-nfc driver for executing NAND-Related operation such as Programming data, erasing flash, and etc.

static int nand_mt7621_bbt_scan




NEXT




<s> int rtl8380_sds_power(int mac, int val)
{
u32 mode = (val == 1) ? 0x4 : 0x9;
u32 offset = (mac == 24) ? 5 : 0;

if ((mac != 24) && (mac != 26)) {
pr_err("%s: not a fibre port: %d\n", __func__, mac);
return -1;
}

sw_w32_mask(0x1f << offset, mode << offset, RTL838X_SDS_MODE_SEL);

rtl8380_sds_rst(mac);

return 0;
}

The above function is used to re-enable SDS function.

The following is a patch that is submitted on Oct 2nd, 2012.

http://git.kernel.org/cgit/linux/kernel/git/firm




NEXT




<s> static int adm6996_fixup(struct phy_device *dev)
{
struct mii_bus *bus = dev->mdio.bus;
u16 reg;

/* Our custom registers are at PHY addresses 0-10. Claim those. */
if (dev->mdio.addr > 10)
return 0;

/* look for the switch on the bus */
reg = bus->read(bus, PHYADDR(ADM_SIG0)) & ADM_SIG0_MASK;
if (reg != ADM_SIG0_VAL)
return 0;

reg = bus->read(bus, PHYADDR(ADM_SIG1)) & ADM_SIG1_MASK;
if (reg != ADM_SIG1_VAL)
return 0;

dev->phy_id = (ADM_SIG0_VAL << 16) | ADM_SIG1_VAL;

return 0;
}

The above function is used to probe for the adm6996/adm1096/adm1111 and
configure the bus.

In the driver for those chips there are two functions that need to be
called to register a bus




NEXT




<s> static int rtl8231_pin_dir(struct rtl8231_gpios *gpios, u32 gpio, u32 dir)
{
u32 v;
int pin_sel_addr = RTL8231_GPIO_PIN_SEL(gpio);
int pin_dir_addr = RTL8231_GPIO_DIR(gpio);
int dpin = gpio % 16;

if (gpio > 31) {
pr_debug("WARNING: HIGH pin\n");
dpin += 5;
pin_dir_addr = pin_sel_addr;
}

v = rtl8231_read_cached(gpios, pin_dir_addr);
if (v & 0x80000000) {
pr_err("Error reading RTL8231\n");
return -1;
}

v = (v & ~(1 << dpin)) | (dir << dpin);
rtl8231_write(gpios, pin_dir_addr, v);
gpios->reg_shadow[pin_dir_addr] = v;
gpios->reg_cached |= 1 << pin_dir_addr;

return 0;
}

The above function is used to set the direction of a GPIO pin to either input or output. It is called in the RTL8231_GPIOpinInit() function which is executed by the i2c_driver_register() function.</s>




NEXT




<s> rtk_api_ret_t rtk_igmp_fastLeave_set(rtk_enable_t state)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(state >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIGMPFastLeaveEn((rtk_uint32)state))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set igmp fast leave function.

rkt_enable_t  The Enable Type of IGMP Fast Leave , when state is ENABLED,  the igmp fast leave is enable.

- Enable Type
enable





NEXT




<s> static int rtl8366rb_read_phy_reg(struct rtl8366_smi *smi,
u32 phy_no, u32 page, u32 addr, u32 *data)
{
u32 reg;
int ret;

if (phy_no > RTL8366RB_PHY_NO_MAX)
return -EINVAL;

if (page > RTL8366RB_PHY_PAGE_MAX)
return -EINVAL;

if (addr > RTL8366RB_PHY_ADDR_MAX)
return -EINVAL;

ret = rtl8366_smi_write_reg(smi, RTL8366RB_PHY_ACCESS_CTRL_REG,
RTL8366RB_PHY_CTRL_READ);
if (ret)
return ret;

reg = 0x8000 | (1 << (phy_no + RTL8366RB_PHY_NO_OFFSET)) |
((page << RTL8366RB_PHY_PAGE_OFFSET) & RTL8366RB_PHY_PAGE_MASK) |
(addr & RTL8366RB_PHY_REG_MASK);

ret = rtl8366_smi_write_reg(smi, reg, 0);
if (ret)
return ret;

ret = rtl8366_smi_read_reg(smi, RTL8366RB_PHY_ACCESS_DATA_REG, data);
if (ret)
return ret;

return 0;
}

The above function is used to read the register value of IEEE 802.3
media-independent interface (MII) mechanism.

In Section 4.1, IEEE 802.3 MII is used to perform data communication




NEXT




<s> static void halt(void)
{
printf("\nSystem halted!\n");
for(;;);
}

The above function is used to shutdown the system and is very much similar with the other *nix operating system shutdown function, shutdown. However, for its implementation, we need a device called console, which is a kind of driver software, and we need to initialize




NEXT




<s> rtk_api_ret_t rtk_svlan_ipmc2s_add(ipaddr_t ipmc, ipaddr_t ipmcMsk,rtk_vlan_t svid)
{
rtk_api_ret_t retVal, i;
rtk_uint32 empty_idx;
rtk_uint32 svidx;
rtl8367c_svlan_memconf_t svlanMemConf;
rtl8367c_svlan_mc2s_t svlanMC2SConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (svid > RTL8367C_VIDMAX)
return RT_ERR_SVLAN_VID;

if ((ipmc&0xF0000000)!=0xE0000000)
return RT_ERR_INPUT;

svidx = 0xFFFF;

for (i = 0; i < RTL8367C_SVIDXNO; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;

if (svid == svlanMemConf.vs_svid)
{
svidx = i;
break;
}
}

if (0xFFFF == svidx)
return RT_ERR_SVLAN_ENTRY_NOT_FOUND;


empty_idx = 0xFFFF;

for (i = RTL8367C_MC2SIDXMAX; i >= 0; i--)
{
if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;

if (TRUE == svlanMC2SConf.valid)
{
if (svlanMC2SConf.format == SVLAN_MC2S_MODE_IP &&
svlanMC2SConf.sdata==ipmc&&
svlanMC2SConf.smask==ipmcMsk)
{
svlanMC2SConf.svidx = svidx;
if ((retVal = rtl8367c_setAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;
}
}
else
{
empty_idx = i;
}
}

if (empty_idx!=0xFFFF)
{
svlanMC2SConf.valid = TRUE;
svlanMC2SConf.svidx = svidx;
svlanMC2SConf.format = SVLAN_MC2S_MODE_IP;
svlanMC2SConf.sdata = ipmc;
svlanMC2SConf.smask = ipmcMsk;
if ((retVal = rtl8367c_setAsicSvlanMC2SConf(empty_idx, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;
return RT_ERR_OK;
}

return RT_ERR_OUT_OF_RANGE;

}

The above function is used to add the IP multicast MAC address to the vlan MAC table.

The following functions are used to make IP vlan MAC table entry to the IP-P2P table of VLAN.

rtk_api_ret




NEXT




<s> ret_t rtl8367c_getAsicLutLinkDownForceAging(rtk_uint32 *pEnable)
{
rtk_uint32  value;
ret_t   retVal;

if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LINKDOWN_AGEOUT_OFFSET, &value)) != RT_ERR_OK)
return retVal;

*pEnable = value ? 0 : 1;
return RT_ERR_OK;
}

The above function is used to check whether disable force aging or not, you just write the code like the script below:

rtk_uint32 enabled;
if (rtl8367c_getAsicLutLinkDownForceAging(&




NEXT




<s> int ifx_mei_atm_led_blink(void)
{
return g_adsl_ledcallback();
}

The above function is used to blink LED when the ATM is registered. How can I modify to led2 ? I tried to write a customised gsmei_addled_atm_cb with a different LED_NUMBER(like LED2_NUMBER ,etc




NEXT




<s> rtk_api_ret_t rtk_l2_ipVidMcastAddr_del(rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pIpVidMcastAddr)
return RT_ERR_NULL_POINTER;

if (pIpVidMcastAddr->vid > RTL8367C_VIDMAX)
return RT_ERR_L2_VID;

if( (pIpVidMcastAddr->dip & 0xF0000000) != 0xE0000000)
return RT_ERR_INPUT;

memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
l2Table.sip = pIpVidMcastAddr->sip;
l2Table.dip = pIpVidMcastAddr->dip;
l2Table.l3lookup = 1;
l2Table.l3vidlookup = 1;
l2Table.l3_vid = pIpVidMcastAddr->vid;
method = LUTREADMETHOD_MAC;
retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
if (RT_ERR_OK == retVal)
{
l2Table.sip = pIpVidMcastAddr->sip;
l2Table.dip = pIpVidMcastAddr->dip;
l2Table.mbr= 0;
l2Table.nosalearn = 0;
l2Table.l3lookup = 1;
l2Table.l3vidlookup = 1;
l2Table.l3_vid = pIpVidMcastAddr->vid;
if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
return retVal;

pIpVidMcastAddr->address = l2Table.address;
return RT_ERR_OK;
}
else
return retVal;
}

The above function is used to delete the multicast-address mapping entry of certain MCIPv4 IP. According to multicast address map, to assign MCIPv4 IP to certain MC group, and realize multicast address mapping. Multicast address mapping




NEXT




<s> rtk_api_ret_t rtk_l2_ipMcastGroupEntry_del(ipaddr_t ip_addr, rtk_uint32 vid)
{
rtk_int32       index;
ipaddr_t        group_addr;
rtk_uint32      group_vid;
rtk_uint32      pmask;
rtk_uint32      valid;
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (vid > RTL8367C_VIDMAX)
return RT_ERR_L2_VID;

if((ip_addr & 0xF0000000) != 0xE0000000)
return RT_ERR_INPUT;

for(index = 0; index <= RTL8367C_LUT_IPMCGRP_TABLE_MAX; index++)
{
if ((retVal = rtl8367c_getAsicLutIPMCGroup((rtk_uint32)index, &group_addr, &group_vid, &pmask, &valid))!=RT_ERR_OK)
return retVal;

if( (valid == ENABLED) && (group_addr == ip_addr) && (group_vid == vid) )
{
group_addr = 0xE0000000;
group_vid = 0;
pmask = 0;
if ((retVal = rtl8367c_setAsicLutIPMCGroup(index, group_addr, group_vid, pmask, DISABLED))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}
}

return RT_ERR_FAILED;
}

The above function is used to delete the specified Mcast Group entry</s>




NEXT




<s> void sata_oxnas_freeze_host(struct ata_port *ap)
{
struct sata_oxnas_host_priv *hd = ap->host->private_data;

DPRINTK("ENTER\n");
hd->port_in_eh |= BIT(ap->port_no);
smp_wmb();
}

The above function is used to freeze a given port to prevent it from issuing any DMA commands. Freezing a port works in a similar way to freezing a disk, i.e the BIOS or OS can use this feature to stop I/O, but not




NEXT




<s> static void dc_ep_info_xchange(struct pci_dev *pdev, int card_num)
{
/* More cards supported, exchange address information
* For example, suppose three cards dected.
* 0, <1, 2>
* 1, <0, 2>
* 2, <0, 1>
* For four cards detected
* 0, <1, 2, 3>
* 1, <0, 2, 3>
* 2, <0, 1, 3>
* 3, <0, 1, 2>
* and etc
*/
int i, j, k;
int peer_num;
#ifdef DC_EP_DBG
struct dc_ep_priv *priv;
#endif /* DC_EP_DBG */
spin_lock(&dc_ep_lock);
if (card_num > 1) {
peer_num = card_num - 1;
for (i = 0; i < card_num; i++) {
struct dc_ep_priv *ep = &g_dc_ep_info.pcie_ep[i];
j = 0;
k = 0;
ep->peer_num = peer_num;
do {
struct dc_ep_priv *partner;

if (j == i) {
j++;
continue;
}
partner = &g_dc_ep_info.pcie_ep[j];
ep->peer_mem[k] = partner->mem;
ep->peer_phymem[k] = partner->phymem;
ep->peer_memsize[k] = partner->memsize;
k++;
j++;
} while ((k < peer_num) && (j < card_num));
}
}
spin_unlock(&dc_ep_lock);

#ifdef DC_EP_DBG
dev_dbg(&pdev->dev, "Total cards found %d\n", card_num);
/* Dump detailed debug information */
for (i = 0; i < card_num; i++) {
priv = &g_dc_ep_info.pcie_ep[i];
dev_dbg(&pdev->dev, "card %d attached\n", priv->ep_idx);
dev_dbg(&pdev->dev, "irq base %d irq numbers %d\n",
priv->irq_base, priv->irq_num);
dev_dbg(&pdev->dev,
"its own phymem 0x%08x mem 0x%p size 0x%08x\n",
priv->phymem, priv->mem, priv->memsize);
if (card_num > 1) {
for (j = 0; j < priv->peer_num; j++)
dev_dbg(&pdev->dev,
"its peer phymem 0x%08x mem 0x%p size 0x%08x\n",
priv->peer_phymem[j],
priv->peer_mem[j], priv->peer_memsize[j]);
}
}
#endif /* DC_EP_DBG */
}

The above function is used to distribute PCI memory address information. The algorithm for information distribution is as follows.

The first to detect is given the memory address of the remaining memory after subtraction by the size of its own memory address from the memory space of 32




NEXT




<s> ret_t rtl8367c_setAsicSvlanPrioritySel(rtk_uint32 priSel)
{
if(priSel >= SPRISEL_END)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_SPRISEL_MASK, priSel);
}

The above function is used to set the SVLAN priority selection for SVLAN VLAN ID priority. The priority (priority level) is either 1-4 or 1-5. The default priority level is 4. The value is determined by the user who can change




NEXT




<s> static void dma_tx_ch_cfg(struct dc_ep_dev *dev, int ch, u32 desc_base,
u32 desc_phys, dma_addr_t data_base, int desc_num)
{
int i;
struct tx_desc_2dw *tx_desc;

for (i = 0; i < desc_num; i++) {
tx_desc = (struct tx_desc_2dw *)
(desc_base + (i * sizeof(*tx_desc)));
tx_desc->data_pointer = (((u32)(data_base +
(i * dma_pkt_size))) & 0xfffffff8);
tx_desc->status.word = 0;
tx_desc->status.field.byte_offset = 0;
tx_desc->status.field.data_len = dma_pkt_size;

tx_desc->status.field.sop = 1;
tx_desc->status.field.eop = 1;
tx_desc->status.field.own = 1;
wmb();
#if 0
pr_info("Tx desc num %d word 0x%08x data pointer 0x%08x\n",
i, tx_desc->status.word, tx_desc->data_pointer);
#endif
}
ep_wr32(ch, DMA_CS);
ep_wr32(desc_phys, DMA_CDBA);
ep_wr32(desc_num, DMA_CDLEN);
ep_wr32(0, DMA_CIE);
}

The above function is used to set channel for DMA transmission.

The parameter passed:
1. device: Pointer to device structure.
2. ch: Channel number of device.
3. desc_base: Physical start address of transfer
descriptors in internal ram




NEXT




<s> static void wl_glue_bcma_remove(struct bcma_device *dev)
{
void *wldev = bcma_get_drvdata(dev);

if (remove_cb)
remove_cb(wldev);

bcma_set_drvdata(dev, NULL);
}

The above function is used to free resources that are registered for a Broadcom BCMA device. The function is called only once, before the device is freed.

static void wl_glue_bcma_add(struct bcma_device *dev)





NEXT




<s> static int b53_global_get_jumbo_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct b53_device *priv = sw_to_b53(dev);

val->value.i = priv->enable_jumbo;

return 0;
}

The above function is used to get the “enable-jumbo” attribute’s value from b53.

static int b53_global_set_jumbo_enable(struct switch_dev *dev,
const struct switch_attr *




NEXT




<s> static void rijndaelDecrypt(const u32 rk[/*44*/], const u8 ct[16], u8 pt[16])
{
u32 s0, s1, s2, s3, t0, t1, t2, t3;
const int Nr = 10;
#ifndef FULL_UNROLL
int r;
#endif /* ?FULL_UNROLL */

/*
* map byte array block to cipher state
* and add initial round key:
*/
s0 = GETU32(ct     ) ^ rk[0];
s1 = GETU32(ct +  4) ^ rk[1];
s2 = GETU32(ct +  8) ^ rk[2];
s3 = GETU32(ct + 12) ^ rk[3];

#define ROUND(i,d,s) \
d##0 = TD0(s##0) ^ TD1(s##3) ^ TD2(s##2) ^ TD3(s##1) ^ rk[4 * i]; \
d##1 = TD0(s##1) ^ TD1(s##0) ^ TD2(s##3) ^ TD3(s##2) ^ rk[4 * i + 1]; \
d##2 = TD0(s##2) ^ TD1(s##1) ^ TD2(s##0) ^ TD3(s##3) ^ rk[4 * i + 2]; \
d##3 = TD0(s##3) ^ TD1(s##2) ^ TD2(s##1) ^ TD3(s##0) ^ rk[4 * i + 3]

#ifdef FULL_UNROLL

ROUND(1,t,s);
ROUND(2,s,t);
ROUND(3,t,s);
ROUND(4,s,t);
ROUND(5,t,s);
ROUND(6,s,t);
ROUND(7,t,s);
ROUND(8,s,t);
ROUND(9,t,s);

rk += Nr << 2;

#else  /* !FULL_UNROLL */

/* Nr - 1 full rounds: */
r = Nr >> 1;
for (;;) {
ROUND(1,t,s);
rk += 8;
if (--r == 0)
break;
ROUND(0,s,t);
}

#endif /* ?FULL_UNROLL */

#undef ROUND

/*
* apply last round and
* map cipher state to byte array block:
*/
s0 = TD41(t0) ^ TD42(t3) ^ TD43(t2) ^ TD44(t1) ^ rk[0];
PUTU32(pt     , s0);
s1 = TD41(t1) ^ TD42(t0) ^ TD43(t3) ^ TD44(t2) ^ rk[1];
PUTU32(pt +  4, s1);
s2 = TD41(t2) ^ TD42(t1) ^ TD43(t0) ^ TD44(t3) ^ rk[2];
PUTU32(pt +  8, s2);
s3 = TD41(t3) ^ TD42(t2) ^ TD43(t1) ^ TD44(t0) ^ rk[3];
PUTU32(pt + 12, s3);
}

The above function is used to decrypt data using a Rijndael 128 bit (Advanced Encryption Standard (AES)) encryption algorithm. The rk 4x44 matrix contains the key of which the first 16 words are the secret




NEXT




<s> static void match_prefix(int *pdlen, struct in6_addr *pd, struct blob_attr *cur,
const struct in6_addr *ipv6prefix, int prefix6len, bool lw4o6)
{
struct blob_attr *d;
unsigned drem;

if (!cur || blobmsg_type(cur) != BLOBMSG_TYPE_ARRAY || !blobmsg_check_attr(cur, false))
return;

blobmsg_for_each_attr(d, cur, drem) {
struct blob_attr *ptb[PREFIX_ATTR_MAX];
blobmsg_parse(prefix_attrs, PREFIX_ATTR_MAX, ptb,
blobmsg_data(d), blobmsg_data_len(d));

if (!ptb[PREFIX_ATTR_ADDRESS] || !ptb[PREFIX_ATTR_MASK])
continue;

struct in6_addr prefix = IN6ADDR_ANY_INIT;
int mask = blobmsg_get_u32(ptb[PREFIX_ATTR_MASK]);
inet_pton(AF_INET6, blobmsg_get_string(ptb[PREFIX_ATTR_ADDRESS]), &prefix);

// lw4over6 /128-address-as-PD matching madness workaround
if (lw4o6 && mask == 128)
mask = 64;

if (*pdlen < mask && mask >= prefix6len &&
!bmemcmp(&prefix, ipv6prefix, prefix6len)) {
bmemcpy(pd, &prefix, mask);
*pdlen = mask;
} else if (lw4o6 && *pdlen < prefix6len && mask < prefix6len &&
!bmemcmp(&prefix, ipv6prefix, mask)) {
bmemcpy(pd, ipv6prefix, prefix6len);
*pdlen = prefix6len;
}
}
}

The above function is used to parse a BLOB and check a prefix or
prefixes if present.</s>




NEXT




<s> int AT91F_MCI_SDCard_GetOCR (AT91PS_MciDevice pMCI_Device)
{
unsigned int	response =0x0;

// The RCA to be used for CMD55 in Idle state shall be the card's default RCA=0x0000.
pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address = 0x0;

while( (response & AT91C_CARD_POWER_UP_BUSY) != AT91C_CARD_POWER_UP_BUSY )
{
response = AT91F_MCI_SDCard_SendAppCommand(pMCI_Device,
AT91C_SDCARD_APP_OP_COND_CMD,
AT91C_MMC_HOST_VOLTAGE_RANGE);
if (response != AT91C_CMD_SEND_OK)
return AT91C_INIT_ERROR;

response = AT91C_BASE_MCI->MCI_RSPR[0];
}

return(AT91C_BASE_MCI->MCI_RSPR[0]);
}

The above function is used to configure the interface voltage range of the card, if necessary. It also clears any interrupt conditions and any previous card power up

I don't understand the usage of App Command, is it in place of the normal commands that are sent ??




NEXT




<s> static void fe_reset_fe(struct fe_priv *priv)
{
if (!priv->resets)
return;

reset_control_assert(priv->resets);
usleep_range(60, 120);
reset_control_deassert(priv->resets);
usleep_range(1000, 1200);
}

The above function is used to reset the front end.

This function will assert the reset line for 0.6-1.2 ms and then deassert the line for 1000-1500 us. This ensures that the CPU is reset




NEXT




<s> static int __rtl8366_mdio_write_reg(struct rtl8366_smi *smi, u32 addr, u32 data)
{
u32 phy_id = MDC_REALTEK_PHY_ADDR;
struct mii_bus *mbus = smi->ext_mbus;

BUG_ON(in_interrupt());

mutex_lock(&mbus->mdio_lock);

/* Write Start command to register 29 */
mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);

/* Write address control code to register 31 */
mbus->write(mbus, phy_id, MDC_MDIO_CTRL0_REG, MDC_MDIO_ADDR_OP);

/* Write Start command to register 29 */
mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);

/* Write address to register 23 */
mbus->write(mbus, phy_id, MDC_MDIO_ADDRESS_REG, addr);

/* Write Start command to register 29 */
mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);

/* Write data to register 24 */
mbus->write(mbus, phy_id, MDC_MDIO_DATA_WRITE_REG, data);

/* Write Start command to register 29 */
mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);

/* Write data control code to register 21 */
mbus->write(mbus, phy_id, MDC_MDIO_CTRL1_REG, MDC_MDIO_WRITE_OP);

mutex_unlock(&mbus->mdio_lock);
return 0;
}

The above function is used to write one register value in the given MII chip. It uses the following commands in MDIO
bus:

    - 30) Write START command -> reg_29
    - 31) Write 2-




NEXT




<s> static int ip17xx_set_ports(struct switch_dev *dev, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int i;

if (val->port_vlan >= dev->vlans || val->port_vlan < 0)
return -EINVAL;

state->vlans[val->port_vlan].ports = 0;
for (i = 0; i < val->len; i++) {
unsigned int bitmask = (1<<val->value.ports[i].id);
state->vlans[val->port_vlan].ports |= bitmask;
if (val->value.ports[i].flags & (1<<SWITCH_PORT_FLAG_TAGGED)) {
state->add_tag |= bitmask;
state->remove_tag &= (~bitmask);
} else {
state->add_tag &= (~bitmask);
state->remove_tag |= bitmask;
}
}

return state->regs->update_state(state);
}

The above function is used to set a specific port's vlan to a specific vlans,
but it suffers of an overflow issue:

int i;

...

if (val->port_vlan >= dev->vlans || val->




NEXT




<s> static void rtl839x_enable_bcast_flood(int port, bool enable)
{

}

The above function is used to control forward/flood broadcast packets for certain ports.
If it enables the broadcast flooding, only the host and broadcast MAC address will be updated during the packet transmission. That causes the frame to be forwarded to all ports.
In




NEXT




<s> rtk_api_ret_t rtk_qos_dscpPriRemap_get(rtk_dscp_t dscp, rtk_pri_t *pInt_pri)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (dscp > RTL8367C_DSCPMAX)
return RT_ERR_QOS_DSCP_VALUE;

if ((retVal = rtl8367c_getAsicPriorityDscpBased(dscp, pInt_pri)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the inti-Pri of one input value of dscp.</s>




NEXT




<s> int staging_to_nvram(void)
{
int fdmtd, fdstg, stat;
char *mtd = nvram_find_mtd();
char buf[nvram_part_size];

stat = -1;

if( (mtd != NULL) && (nvram_part_size > 0) )
{
if( (fdstg = open(NVRAM_STAGING, O_RDONLY)) > -1 )
{
if( read(fdstg, buf, sizeof(buf)) == sizeof(buf) )
{
if( (fdmtd = open(mtd, O_WRONLY | O_SYNC)) > -1 )
{
write(fdmtd, buf, sizeof(buf));
fsync(fdmtd);
close(fdmtd);
stat = 0;
}
}

close(fdstg);

if( !stat )
stat = unlink(NVRAM_STAGING) ? 1 : 0;
}
}

free(mtd);
return stat;
}

The above function is used to write a NVRAM file out to a file system that can be used to read/write the NVRAM with a host computer.

## How do I know if my router is using NVRAM

Look at the bottom your




NEXT




<s> static int rttm_state_periodic(struct clock_event_device *clkevt)
{
struct timer_of *to = to_timer_of(clkevt);

RTTM_DEBUG(to->of_base.base);
rttm_stop_timer(to->of_base.base);
rttm_set_period(to->of_base.base, RTTM_TICKS_PER_SEC / HZ);
rttm_start_timer(to, RTTM_CTRL_TIMER);

return 0;
}

The above function is used to configure the periodic timer. It
first stops the timer. It then sets the timer period. It finally
starts the periodic timer. If the periodic timer was configured earlier,
then this results in reconfiguring the periodic timer.






NEXT




<s> static int rtl8367b_detect(struct rtl8366_smi *smi)
{
const char *chip_name;
u32 chip_num;
u32 chip_ver;
u32 chip_mode;
int ret;

/* TODO: improve chip detection */
rtl8366_smi_write_reg(smi, RTL8367B_RTL_MAGIC_ID_REG,
RTL8367B_RTL_MAGIC_ID_VAL);

ret = rtl8366_smi_read_reg(smi, RTL8367B_CHIP_NUMBER_REG, &chip_num);
if (ret) {
dev_err(smi->parent, "unable to read %s register\n",
"chip number");
return ret;
}

ret = rtl8366_smi_read_reg(smi, RTL8367B_CHIP_VER_REG, &chip_ver);
if (ret) {
dev_err(smi->parent, "unable to read %s register\n",
"chip version");
return ret;
}

ret = rtl8366_smi_read_reg(smi, RTL8367B_CHIP_MODE_REG, &chip_mode);
if (ret) {
dev_err(smi->parent, "unable to read %s register\n",
"chip mode");
return ret;
}

switch (chip_ver) {
case 0x1000:
chip_name = "8367RB";
break;
case 0x1010:
chip_name = "8367R-VB";
break;
default:
dev_err(smi->parent,
"unknown chip num:%04x ver:%04x, mode:%04x\n",
chip_num, chip_ver, chip_mode);
return -ENODEV;
}

dev_info(smi->parent, "RTL%s chip found\n", chip_name);

return 0;
}

The above function is used to detect whether the chip is rtl8367b or not.
Function rtl8366_smi_write_reg and rtl8366_smi_read_reg are used to write and read




NEXT




<s> static int zyxel_bootconfig_read(struct zyxel_bootconfig *config, struct zyxel_bootconfig_mtd *mtd) {
char *args = NULL;
int ret = 0;

/* Allocate memory for reading boot-config partition */
args = calloc(1, mtd->mtd_info.erasesize);
if (!args) {
fprintf(stderr, "Could not allocate memory!\n");
ret = -1;
goto out;
}

/* Read bootconfig partition */
pread(mtd->fd, args, mtd->mtd_info.erasesize, 0);

/* Parse config */
memset(config, 0, sizeof(*config));

config->image0_status = (args[BOOTCONFIG_IMAGE_STATUS] & IMAGE_0_MASK) >> IMAGE_0_SHIFT;
config->image1_status = (args[BOOTCONFIG_IMAGE_STATUS] & IMAGE_1_MASK) >> IMAGE_1_SHIFT;
config->active_image = (args[BOOTCONFIG_ACTIVE_IMAGE] & ACTIVE_IMAGE_MASK);

out:
if (args)
free(args);
return ret;
}

The above function is used to parse the boot-config partition using a predefined structure and data buffer.

static int zyxel_bootconfig_write(struct zyxel_bootconfig *config, struct zyxel_bootconfig_m




NEXT




<s> ar8xxx_phy_write(struct mii_bus *bus, int phy_addr, int reg_addr,
u16 reg_val)
{
struct ar8xxx_priv *priv = bus->priv;
return priv->chip->phy_write(priv, phy_addr, reg_addr, reg_val);
}

The above function is used to write the register value to the MII-Bus. I
am trying to change the “phy_write” interface to be used to communicate
with the PHY. Currently there is only one PHY (phy0) and it is a




NEXT




<s> int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
int max,min;
register BN_ULONG t1,t2,*ap,*bp,*rp;
int i,carry;
#if defined(IRIX_CC_BUG) && !defined(LINT)
int dummy;
#endif

bn_check_top(a);
bn_check_top(b);

if (a->top < b->top) /* hmm... should not be happening */
{
return(0);
}

max=a->top;
min=b->top;
if (bn_wexpand(r,max) == NULL) return(0);

ap=a->d;
bp=b->d;
rp=r->d;

#if 1
carry=0;
for (i=0; i<min; i++)
{
t1= *(ap++);
t2= *(bp++);
if (carry)
{
carry=(t1 <= t2);
t1=(t1-t2-1)&BN_MASK2;
}
else
{
carry=(t1 < t2);
t1=(t1-t2)&BN_MASK2;
}
#if defined(IRIX_CC_BUG) && !defined(LINT)
dummy=t1;
#endif
*(rp++)=t1&BN_MASK2;
}
#else
carry=bn_sub_words(rp,ap,bp,min);
ap+=min;
bp+=min;
rp+=min;
i=min;
#endif
if (carry) /* subtracted */
{
while (i < max)
{
i++;
t1= *(ap++);
t2=(t1-1)&BN_MASK2;
*(rp++)=t2;
if (t1 > t2) break;
}
}
#if 0
memcpy(rp,ap,sizeof(*rp)*(max-i));
#else
if (rp != ap)
{
for (;;)
{
if (i++ >= max) break;
rp[0]=ap[0];
if (i++ >= max) break;
rp[1]=ap[1];
if (i++ >= max) break;
rp[2]=ap[2];
if (i++ >= max) break;
rp[3]=ap[3];
rp+=4;
ap+=4;
}
}
#endif

r->top=max;
bn_fix_top(r);
return(1);
}

The above function is used to compute the remainder of a multi digit multiplication, i.e.

x=m1*n1+ m2*n2.. +mk*nk mod y

which means to return x such that:

x




NEXT




<s> static inline void atm_free_tx_skb_vcc(struct sk_buff *, struct atm_vcc *);
static inline struct sk_buff *get_skb_rx_pointer(unsigned int);
static inline int get_tx_desc(unsigned int);

/*
*  mailbox handler and signal function
*/
static inline void mailbox_oam_rx_handler(void);
static inline void mailbox_aal_rx_handler(void);
static irqreturn_t mailbox_irq_handler(int, void *);
static inline void mailbox_signal(unsigned int, int);
static void do_ppe_tasklet(unsigned long);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
DECLARE_TASKLET(g_dma_tasklet, do_ppe_tasklet, 0);
#else
DECLARE_TASKLET_OLD(g_dma_tasklet, do_ppe_tasklet);
#endif

/*
*  QSB & HTU setting functions
*/
static void set_qsb(struct atm_vcc *, struct atm_qos *, unsigned int);
static void qsb_global_set(void);
static inline void set_htu_entry(unsigned int, unsigned int, unsigned int, int, int);
static inline void clear_htu_entry(unsigned int);
static void validate_oam_htu_entry(void);
static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to send OAM messages to the host
#endif /* defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE) */


#include <linux/if_atm.h>




NEXT




<s> static int b53_spi_write48(struct b53_device *dev, u8 page, u8 reg, u64 value)
{
struct spi_device *spi = dev->priv;
int ret;
u8 txbuf[10];

ret = b53_prepare_reg_access(spi, page);
if (ret)
return ret;

txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
txbuf[1] = reg;
put_unaligned_le64(value, &txbuf[2]);

return spi_write(spi, txbuf, sizeof(txbuf) - 2);
}

The above function is used to write 48 bit registers. It works fine
until the caller tries to write 0x644C010000100000, which gets
expanded (in spi_build_tx




NEXT




<s> static int ptm_ioctl(struct net_device *, struct ifreq *, int);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
static void ptm_tx_timeout(struct net_device *);
#else
static void ptm_tx_timeout(struct net_device *, unsigned int txqueue);
#endif

static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to initializes the private data structures
associated with the ptm driver. It should be called only once before the netdevice
is created. Please see ptm_main() for a place to call this function.
static inline int ptm




NEXT




<s> rtk_api_ret_t rtk_led_serialModePortmask_set(rtk_led_serialOutput_t output, rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(output >= SERIAL_LED_END)
return RT_ERR_INPUT;

if(pPortmask == NULL)
return RT_ERR_NULL_POINTER;

if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicLedSerialOutput((rtk_uint32)output, pmask))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the serial output portmask with serial output value (default is 0)
and the portmask.

Output parameters:
pPortmask：Point to the variable that will get the outgoing portmask

Output status:





NEXT




<s> static void _rtl8367c_svlanMc2sStUser2Smi(rtl8367c_svlan_mc2s_t *pUserSt, rtk_uint16 *pSmiSt)
{
pSmiSt[0] |= (pUserSt->svidx & 0x003F);
pSmiSt[0] |= (pUserSt->format & 0x0001) << 6;
pSmiSt[0] |= (pUserSt->valid & 0x0001) << 7;

pSmiSt[1] = (rtk_uint16)(pUserSt->smask & 0x0000FFFF);
pSmiSt[2] = (rtk_uint16)((pUserSt->smask & 0xFFFF0000) >> 16);

pSmiSt[3] = (rtk_uint16)(pUserSt->sdata & 0x0000FFFF);
pSmiSt[4] = (rtk_uint16)((pUserSt->sdata & 0xFFFF0000) >> 16);
}

The above function is used to convert svlan user to smi.

static int
rtk_st_api_set_vlan(void *ctx, int nport, rtl8367c_mdio_reg_t port, r




NEXT




<s> rtk_api_ret_t rtk_rate_shareMeterBucket_set(rtk_meter_id_t index, rtk_uint32 bucket_size)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (index > RTK_MAX_METER_ID)
return RT_ERR_FILTER_METER_ID;

if(bucket_size > RTL8367C_METERBUCKETSIZEMAX)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicShareMeterBucketSize(index, bucket_size)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the queue bandwidth. The rtl8367c_setAsicShareMeterBucketSize is used to configuration of the queue bandwidth. The index is the meter id, the bucket_size is the queue bandwidth.




NEXT




<s> srg_led_set_brightness(struct led_classdev *led_cdev,
enum led_brightness value)
{
struct srg_led *sysled = container_of(led_cdev, struct srg_led, led);
struct srg_led_ctrl *sysled_ctrl = sysled->ctrl;
int ret;

mutex_lock(&sysled_ctrl->lock);
ret = srg_led_i2c_write(sysled_ctrl, sysled->index + 4, value);
if (!ret) {
sysled_ctrl->control[sysled->index] = !!value;
ret = srg_led_control_sync(sysled_ctrl);
}
mutex_unlock(&sysled_ctrl->lock);
return ret;
}

The above function is used to set the brightness of a PWM LED. The argument led_cdev parameter is a pointer to a struct led_classdev struct that represents a LED. The sysled parameter is a pointer to the srg_led struct that represents the




NEXT




<s> static void parse_entry(uint8_t *buffer, uint32_t pos,
struct tffs_entry *entry)
{
entry->header = (struct tffs_entry_header *) &buffer[pos];
entry->val = &buffer[pos + sizeof(struct tffs_entry_header)];
}

The above function is used to parse an entry from a given buffer, with the current buffer position stored in pos. This is called by tffs_entry_parse2 to construct an entry from an existing buffer. The problem is that the pos parameter is not declared as a




NEXT




<s> static int ehci_oxnas_reset(struct usb_hcd *hcd)
{
#define  txttfill_tuning	reserved2[0]

struct ehci_hcd	*ehci;
u32 tmp;
int retval = ehci_setup(hcd);
if (retval)
return retval;

ehci = hcd_to_ehci(hcd);
tmp = ehci_readl(ehci, &ehci->regs->txfill_tuning);
tmp &= ~0x00ff0000;
tmp |= 0x003f0000; /* set burst pre load count to 0x40 (63 * 4 bytes)  */
tmp |= 0x16; /* set sheduler overhead to 22 * 1.267us (HS) or 22 * 6.33us (FS/LS)*/
ehci_writel(ehci, tmp,  &ehci->regs->txfill_tuning);

tmp = ehci_readl(ehci, &ehci->regs->txttfill_tuning);
tmp |= 0x2; /* set sheduler overhead to 2 * 6.333us */
ehci_writel(ehci, tmp,  &ehci->regs->txttfill_tuning);

return retval;
}

The above function is used to reset the scheduler overhead calculation value. As per the USB specification, the following are the steps involved in scheduler overhead:-

The first 3 bytes of every USB packet are the address of the packet. The 1st byte is




NEXT




<s> void serial_console_putchar(char c)
{
while ((in_8(reg_base + (UART_LSR << reg_shift)) & UART_LSR_THRE) == 0);
out_8(reg_base, c);
}

The above function is used to send data from the serial port of the device. So when i am running the above piece of code I am getting the below error.

While compiling :

Error C2061: syntax error : identifier 'UART_




NEXT




<s> static long ubootenv_ioctl(struct file *file, u_int cmd, u_long arg)
{
struct ubootenv_drvdata *data = to_ubootenv_drvdata(file);
void __user *argp = (void __user *)arg;
struct mtd_info_user info = {
.type = MTD_NORFLASH,
.size = data->rmem->size,
};

switch (cmd) {
case MEMISLOCKED:
case MEMERASE:
break;
case MEMGETINFO:
if (copy_to_user(argp, &info, sizeof(struct mtd_info_user)))
return -EFAULT;
break;
default:
return -ENOTTY;
}
return 0;
}

The above function is used to implement the ioctl function of our file system driver. It takes a file pointer, an ioctl code, and an argument as input and returns a long integer as output. The first part of the code checks if the given cmd is supported by the




NEXT




<s> static int dc_ep_ppe_mbox_int_stress_test(struct dc_ep_dev *dev)
{
int i;
int j;
int ret;

/* Clear it first */
ep_wr32(PPE_MBOX_TEST_BIT, MBOX_IGU0_ISRC);

ret = request_irq(dev->irq, dc_ep_ppe_intr, 0, "PPE_MSI", dev);
if (ret) {
pr_err("%s request irq %d failed\n", __func__, dev->irq);
return -1;
}
pr_info("PPE test\n");
ep_wr32(PPE_MBOX_TEST_BIT, MBOX_IGU0_IER);
ppe_irq_num = 0;
/* Purposely trigger interrupt */
for (i = 0; i < PPE_MBOX_IRQ_TEST_NUM; i++) {
j = 0;
while ((ep_rd32(MBOX_IGU0_ISR) & PPE_MBOX_TEST_BIT)) {
j++;
if (j > PPE_INT_TIMEOUT)
break;
}
ep_wr32(PPE_MBOX_TEST_BIT, MBOX_IGU0_ISRS);
/* Write flush */
ep_rd32(MBOX_IGU0_ISR);
}
mdelay(10);
pr_info("irq triggered %d expected %d\n", ppe_irq_num,
PPE_MBOX_IRQ_TEST_NUM);
dc_ep_ppe_mbox_reg_dump(dev);
ppe_irq_num = 0;
return 0;
}

The above function is used to send and receive messages from an interrupt based PPE mailbox. We send and receive ips_mailbox_int_t commands by interrupt and also send and receive mailboxes by a polling based technique. The test has been run a total




NEXT




<s> void str_free(struct gstr *gs)
{
if (gs->s)
free(gs->s);
gs->s = NULL;
gs->len = 0;
}

The above function is used to free the s field in a gstr. You may have noted that if s is not a pointer to the memory allocated using malloc, the above function may call free which may lead to a segmentation fault.

This is what you should




NEXT




<s> void rtl931x_vlan_port_pvidmode_set(int port, enum pbvlan_type type, enum pbvlan_mode mode)
{
if (type == PBVLAN_TYPE_INNER)
sw_w32_mask(0x3 << 12, mode << 12, RTL931X_VLAN_PORT_IGR_CTRL + (port << 2));
else
sw_w32_mask(0x3 << 26, mode << 26, RTL931X_VLAN_PORT_IGR_CTRL + (port << 2));
}

The above function is used to set ingress PVID mode on a particular L2 port. It uses the sw_w32_mask function. A single call to sw_w32_mask modifies (or writes) a 32 bit value to a




NEXT




<s> rtl_attr_get_vlan_int(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
if (val->port_vlan >= dev->vlans)
return -EINVAL;

return rtl_attr_get_int(dev, attr, val);
}

The above function is used to get the vlan id from the vlan attr. In order to debug this, I put a breakpoint on rtl_attr_get_int and found that when I configure a port to a vlan mode and check the port attribute by




NEXT




<s> static void sha_transform(uint32_t *digest, const unsigned char *in, uint32_t *W)
{
uint32_t a, b, c, d, e, t, i;

for (i = 0; i < 16; i++) {
int ofs = 4 * i;

/* word load/store may be unaligned here, so use bytes instead */
W[i] =
(in[ofs+0] << 24) |
(in[ofs+1] << 16) |
(in[ofs+2] << 8) |
in[ofs+3];
}

for (i = 0; i < 64; i++)
W[i+16] = rol32(W[i+13] ^ W[i+8] ^ W[i+2] ^ W[i], 1);

a = digest[0];
b = digest[1];
c = digest[2];
d = digest[3];
e = digest[4];

for (i = 0; i < 20; i++) {
t = f1(b, c, d) + K1 + rol32(a, 5) + e + W[i];
e = d; d = c; c = rol32(b, 30); b = a; a = t;
}

for (; i < 40; i ++) {
t = f2(b, c, d) + K2 + rol32(a, 5) + e + W[i];
e = d; d = c; c = rol32(b, 30); b = a; a = t;
}

for (; i < 60; i ++) {
t = f3(b, c, d) + K3 + rol32(a, 5) + e + W[i];
e = d; d = c; c = rol32(b, 30); b = a; a = t;
}

for (; i < 80; i ++) {
t = f2(b, c, d) + K4 + rol32(a, 5) + e + W[i];
e = d; d = c; c = rol32(b, 30); b = a; a = t;
}

digest[0] += a;
digest[1] += b;
digest[2] += c;
digest[3] += d;
digest[4] += e;
}

The above function is used to update the input data block at every 64 bytes. This is the step where SHA-1 processes the input data as message digest (MD) algorithm.</s>




NEXT




<s> int rtl8366_sw_get_port_pvid(struct switch_dev *dev, int port, int *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
return rtl8366_get_pvid(smi, port, val);
}

The above function is used to read the port's PVID.

The function above is implemented is rtl8366_hw.c in drivers/usb/host/net/rtl8366

The function "rtl83




NEXT




<s> static int airoha_get_dir(struct gpio_chip *gc, unsigned int gpio)
{
struct airoha_gpio_ctrl *ctrl = gc_to_ctrl(gc);
u32 dir = ioread32(ctrl->dir[gpio / 16]);
u32 mask = BIT((gpio % 16) * 2);

return (dir & mask) ? GPIO_LINE_DIRECTION_OUT : GPIO_LINE_DIRECTION_IN;
}

The above function is used to return the direction of a pin.
In the debugger, there is the ability to set/reset a breakpoint and step through code at the function level (e.g. airoha_set_dir).  Can we use this




NEXT




<s> static int fe_nway_reset(struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);

if (!priv->phy_dev)
goto out_nway_reset;

return genphy_restart_aneg(priv->phy_dev);

out_nway_reset:
return -EOPNOTSUPP;
}

The above function is used to reset the PHY which is to be called by the netif_nway_reset function. This is called during the device initialization and at this time the phy_dev data is NULL i.e there is no PHY attached to the




NEXT




<s> ret_t rtl8367c_setAsicPortUnknownDaFloodingPortmask(rtk_uint32 portmask)
{
if(portmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

return rtl8367c_setAsicReg(RTL8367C_UNUCAST_FLOADING_PMSK_REG, portmask);
}

The above function is used to change the RTL8367C(A) flood port mask of unknown destination. This function does not support other 8XX devices.

rtk_uint32 rtl8367c_getAsicPort




NEXT




<s> ret_t rtl8367c_getAsicLeakyBucketParameter(rtk_uint32 *tick, rtk_uint32 *token)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_LEAKY_BUCKET_TICK_REG, RTL8367C_LEAKY_BUCKET_TICK_MASK, tick);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_LEAKY_BUCKET_TOKEN_REG, RTL8367C_LEAKY_BUCKET_TOKEN_MASK, token);

return retVal;
}

The above function is used to set QOS leaky bucket parameter on some 8367B platform. However, this function may produce unexpected results on some other type of platforms such as 8367S, E.

Reason:

According




NEXT




<s> static inline void icu_disable_intr(struct dc_ep_dev *dev, u32 bits)
{
if (WARN_ON(!dev))
return;
if (WARN_ON(!dev->priv))
return;

dc_ep_icu_dis_intr(dev->priv, bits);
}

The above function is used to turn off an IRQs that might be masked.

The function is responsible for actually turning the interrupts off.

Note: I assume that the code calls dc_ep_intr_set_int_mask.






NEXT




<s> static int rtl8214fc_match_phy_device(struct phy_device *phydev)
{
int addr = phydev->mdio.addr;

return phydev->phy_id == PHY_ID_RTL8214FC && addr >= 24;
}

The above function is used to detect and register PHY as RTL8214FC type.

The 8211 series devices were added to uCode about the same time as
8214FC, with code to implement some of the M




NEXT




<s> ret_t rtl8367c_setAsicPortBcastFloodingPortmask(rtk_uint32 portmask)
{
if(portmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

return rtl8367c_setAsicReg(RTL8367C_BCAST_FLOADING_PMSK_REG, portmask);
}

The above function is used to set the broadcast flooding portmask during device initialization. The user can set this register in order to decide which ports are allowed to broadcast packet.

The following are the default value of the BCastFloodingPortmask when the user is




NEXT




<s> ret_t rtl8367c_setAsicLutForceFlush(rtk_uint32 portmask)
{
ret_t retVal;

if(portmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

retVal = rtl8367c_setAsicRegBits(RTL8367C_FORCE_FLUSH_REG, RTL8367C_FORCE_FLUSH_PORTMASK_MASK, portmask & 0xff);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FORCE_FLUSH1, RTL8367C_PORTMASK1_MASK, (portmask >> 8) & 0x7);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to flush LUT cache by setting bits 43-35 of RTL8367C_FORCE_FLUSH_REG.

Portmask for LUT flush cache is as follows:

(If the above function




NEXT




<s> ar8xxx_sw_set_mirror_monitor_port(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

mutex_lock(&priv->reg_mutex);
priv->monitor_port = val->value.i;
priv->chip->set_mirror_regs(priv);
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to set the port on which the monitor port will be configured. But before we actually set the monitor port, the first step is to check what kind of port the monitor port will be and configure it accordingly. We do this by getting the phy_




NEXT




<s> static void ag71xx_hw_start(struct ag71xx *ag)
{
/* start RX engine */
ag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);

/* enable interrupts */
ag71xx_wr(ag, AG71XX_REG_INT_ENABLE, AG71XX_INT_INIT);

netif_wake_queue(ag->dev);
}

The above function is used to start the ag71xx MAC.
But it must be called with the ag71xx spin lock aquired. That’s done
where?

In the main loop of the interrupt handler. But interrupts are
disabled in




NEXT




<s> yyensure_buffer_stack ();
YY_CURRENT_BUFFER_LVALUE =
yy_create_buffer( yyin, YY_BUF_SIZE );
}

yy_load_buffer_state(  );
}

{

int str = 0;
int ts, i;

while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
{

The above function is used to initialise the various data-structures required for parsing as well as to load the current input stream for parsing before the actual invocation of the parser.
Before the parser actually begins parsing the input file it needs data. Parsing




NEXT




<s> _IFX_MEI_DBGLongWordRead (DSL_DEV_Device_t * pDev, u32 DEC_mode,
u32 address, u32 * data)
{
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_DBG_DECODE, DEC_mode);
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_DBG_RD_AD, address);
meiPollForDbgDone (pDev);
IFX_MEI_LongWordReadOffset (pDev, (u32) ME_DBG_DATA, data);
return DSL_DEV_MEI_ERR_SUCCESS;
}

The above function is used to read a single long word value from memory. This
value can then be used to construct the PACKED struct in our code by doing
a binary read of a number of data bytes followed by a binary read of a number
of data bytes




NEXT




<s> static void gpio_keys_polled_close(struct gpio_keys_button_dev *bdev)
{
struct gpio_keys_platform_data *pdata = bdev->pdata;

cancel_delayed_work_sync(&bdev->work);

if (pdata->disable)
pdata->disable(bdev->dev);
}

The above function is used to close a button by disabling the GPIO and
canceling the timed work.</s>




NEXT




<s> static int qca807x_get_tunable(struct phy_device *phydev,
struct ethtool_tunable *tuna, void *data)
{
switch (tuna->id) {
case ETHTOOL_PHY_DOWNSHIFT:
return qca807x_get_downshift(phydev, data);
default:
return -EOPNOTSUPP;
}
}

The above function is used to get the tunable value of qca807x PHY.

If the function works fine and does not have issues, then it needs to be
moved into the qca807x_config_set_t




NEXT




<s> static int b53_srab_write8(struct b53_device *dev, u8 page, u8 reg, u8 value)
{
u8 __iomem *regs = dev->priv;
int ret = 0;

ret = b53_srab_request_grant(dev);
if (ret)
goto err;

writel(value, regs + B53_SRAB_WD_L);

ret = b53_srab_op(dev, page, reg, B53_SRAB_CMDSTAT_WRITE);

err:
b53_srab_release_grant(dev);

return ret;
}

The above function is used to write 8-bit value to SRAM of B53 device. Page, Reg and Value, they are three input parameters. In most of the cases, page is zero, which indicates 64-byte SRAM. Reg is the




NEXT




<s> static int b53_apply(struct b53_device *dev)
{
int i;

/* clear all vlan entries */
if (is5325(dev) || is5365(dev)) {
for (i = 1; i < dev->sw_dev.vlans; i++)
b53_set_vlan_entry(dev, i, 0, 0);
} else {
b53_do_vlan_op(dev, VTA_CMD_CLEAR);
}

b53_enable_vlan(dev, dev->enable_vlan);

/* fill VLAN table */
if (dev->enable_vlan) {
for (i = 0; i < dev->sw_dev.vlans; i++) {
struct b53_vlan *vlan = &dev->vlans[i];

if (!vlan->members)
continue;

b53_set_vlan_entry(dev, i, vlan->members, vlan->untag);
}

b53_for_each_port(dev, i)
b53_write16(dev, B53_VLAN_PAGE,
B53_VLAN_PORT_DEF_TAG(i),
dev->ports[i].pvid);
} else {
b53_for_each_port(dev, i)
b53_write16(dev, B53_VLAN_PAGE,
B53_VLAN_PORT_DEF_TAG(i), 1);

}

b53_enable_ports(dev);

if (!is5325(dev) && !is5365(dev))
b53_set_jumbo(dev, dev->enable_jumbo, 1);

return 0;
}

The above function is used to configure the VLAN hardware
according the software data structure.
Note that the function doesn’t use any vlan tag

Note that the above function is used before a vlan member port is enabled such that when the port gets enabled




NEXT




<s> ret_t rtl8367c_setAsicFlowControlPortJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_OFF, RTL8367C_FLOWCTRL_JUMBO_PORT_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_ON, RTL8367C_FLOWCTRL_JUMBO_PORT_ON_MASK, onThreshold);

return retVal;
}

The above function is used to set up the port threshold used in the flow control
(10Kbps) for jumbo packets. In the following example, onThreshold is set to 5.

Therefore, if the flow control on the selected port




NEXT




<s> static int __init mtdsplit_seama_init(void)
{
register_mtd_parser(&mtdsplit_seama_parser);

return 0;
}

The above function is used to register this driver with the MTD subsystem. 1. MTD split and parse. The parse function tries to obtain a memory block and the physical flash location for this block. Since the SEAM memory is not connected directly to a flash we




NEXT




<s> const char *sym_escape_string_value(const char *in)
{
const char *p;
size_t reslen;
char *res;
size_t l;

reslen = strlen(in) + strlen("\"\"") + 1;

p = in;
for (;;) {
l = strcspn(p, "\"\\");
p += l;

if (p[0] == '\0')
break;

reslen++;
p++;
}

res = xmalloc(reslen);
res[0] = '\0';

strcat(res, "\"");

p = in;
for (;;) {
l = strcspn(p, "\"\\");
strncat(res, p, l);
p += l;

if (p[0] == '\0')
break;

strcat(res, "\\");
strncat(res, p++, 1);
}

strcat(res, "\"");
return res;
}

The above function is used to sanitize a string that is used as a symbol escape argument and replace the escaped string representation of the symbol value. The resulting escape sequence will be enclosed in quotes.

I don’t intend to include the symbol escape functions as a formal




NEXT




<s> rtk_api_ret_t rtk_switch_isPortMaskExt(rtk_portmask_t *pPmask)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(NULL == pPmask)
return RT_ERR_NULL_POINTER;

if( (pPmask->bits[0] | halCtrl->valid_ext_portmask) != halCtrl->valid_ext_portmask )
return RT_ERR_FAILED;
else
return RT_ERR_OK;
}

The above function is used to find whether a given portmask is valid, but for now
it is merely an empty routine. Implementation is currently underway.

rtk_api_ret_t rtk_switch_setPortMaskExt(rtk_




NEXT




<s> static u32 ag71xx_ethtool_get_msglevel(struct net_device *dev)
{
struct ag71xx *ag = netdev_priv(dev);

return ag->msg_enable;
}

The above function is used to retrieve the value of ‘ETX_MSG_ENABLE’ and we can use it to enable or disable the statistics. In the code, the functions are used to enable or disable the statistics as: ag->msg_enable = 0xff0




NEXT




<s> static int bcm6348_emac_mdio_init(struct bcm6348_emac *emac,
struct device_node *np)
{
struct platform_device *pdev = emac->pdev;
struct device *dev = &pdev->dev;
struct device_node *mnp;
struct mii_bus *mii_bus;
int ret;

mnp = of_get_child_by_name(np, "mdio");
if (!mnp)
return -ENODEV;

mii_bus = devm_mdiobus_alloc(dev);
if (!mii_bus) {
of_node_put(mnp);
return -ENOMEM;
}

mii_bus->priv = emac;
mii_bus->name = np->full_name;
snprintf(mii_bus->id, MII_BUS_ID_SIZE, "%s-mii", dev_name(dev));
mii_bus->parent = dev;
mii_bus->read = bcm6348_emac_mdio_read;
mii_bus->write = bcm6348_emac_mdio_write;
mii_bus->phy_mask = 0x3f;

ret = devm_of_mdiobus_register(dev, mii_bus, mnp);
of_node_put(mnp);
if (ret) {
dev_err(dev, "MDIO bus registration failed\n");
return ret;
}

dev_info(dev, "MDIO bus init\n");

return 0;
}

The above function is used to register the MDIO bus.The
following code snippet is used to register the MDIO bus driver
when the driver is built.It is the same as the one we mentioned
previously.There is nothing special.

static




NEXT




<s> x = BigIntegerFromBytes(dig, sizeof(dig));

BigIntegerModExp(v, g, x, n);
tpw->pebuf.password.len = BigIntegerToBytes(v, tpw->pebuf.password.data);

BigIntegerFree(v);
BigIntegerFree(x);
BigIntegerFree(g);
BigIntegerFree(n);

return &tpw->pebuf;
}

int
t_pwcopy(pwdest, pwsrc, diff)
FILE * pwdest;
FILE * pwsrc;
struct t_pwent * diff;
{

The above function is used to copy passwords from system hashing to LANSA hashing, from "pg_password" file to "security_password" dictionary and vice-versa.</s>




NEXT




<s> struct property *menu_add_prompt(enum prop_type type, char *prompt,
struct expr *dep)
{
struct property *prop = menu_add_prop(type, NULL, dep);

if (isspace(*prompt)) {
prop_warn(prop, "leading whitespace ignored");
while (isspace(*prompt))
prompt++;
}
if (current_entry->prompt)
prop_warn(prop, "prompt redefined");

/* Apply all upper menus' visibilities to actual prompts. */
if (type == P_PROMPT) {
struct menu *menu = current_entry;

while ((menu = menu->parent) != NULL) {
struct expr *dup_expr;

if (!menu->visibility)
continue;
/*
* Do not add a reference to the menu's visibility
* expression but use a copy of it. Otherwise the
* expression reduction functions will modify
* expressions that have multiple references which
* can cause unwanted side effects.
*/
dup_expr = expr_copy(menu->visibility);

prop->visible.expr = expr_alloc_and(prop->visible.expr,
dup_expr);
}
}

current_entry->prompt = prop;
prop->text = prompt;

return prop;
}

The above function is used to add prompts which define the visible part of the submenu. These prompts are not defined with the menu command (as you could've guessed by searching "prop_add_prompt" (1). It can be seen in the code




NEXT




<s> static void rtl9310_sda_sel(struct i2c_mux_core *muxc, int pin)
{
struct rtl9300_mux *mux = i2c_mux_priv(muxc);
u32 v;

/* Set SDA pin to I2C functionality */
v = readl(REG(0, RTL9310_I2C_MST_IF_SEL));
v |= BIT(pin);
writel(v, REG(0, RTL9310_I2C_MST_IF_SEL));
}

The above function is used to select one of the i2c controller.
The pin parameter passed to the function is the index of the i2c controller. 0 indicates the first controller.
rtl9310_sense_irq is used to sense




NEXT




<s> makeCMV (u8 opcode, u8 group, u16 address, u16 index, int size, u16 * data, u16 *CMVMSG)
{
memset (CMVMSG, 0, MSG_LENGTH * 2);
CMVMSG[0] = (opcode << 4) + (size & 0xf);
CMVMSG[1] = (((index == 0) ? 0 : 1) << 7) + (group & 0x7f);
CMVMSG[2] = address;
CMVMSG[3] = index;
if (opcode == H2D_CMV_WRITE)
memcpy (CMVMSG + 4, data, size * 2);
return;
}

The above function is used to generate the CMV message that can be used to control a target, it’s not used for read actions but it could be used as per the above description. The next function is used to make the actual request to the target and process the responses




NEXT




<s> ret_t rtl8367c_setAsic1xPBEnConfig(rtk_uint32 port, rtk_uint32 enabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_PORT_ENABLE_REG, port, enabled);
}

The above function is used to enable/disable Dot1X for all ports on the system.
Each port can have three states:
-Disable -This means that the port will not participate in the Dot1X workgroup. This is the default setting.





NEXT




<s> static int rtl8367_led_blinkrate_set(struct rtl8366_smi *smi, unsigned int rate)
{
u16 mask;
u16 set;
int err;

mask = RTL8367_LED_MODE_RATE_M << RTL8367_LED_MODE_RATE_S;
set = (rate & RTL8367_LED_MODE_RATE_M) << RTL8367_LED_MODE_RATE_S;
REG_RMW(smi, RTL8367_LED_MODE_REG, mask, set);

return 0;
}

The above function is used to set the blinking time for the LED after the chip
is reset and it cannot change the blinking time for the LED, as the chip is
reset.

For reference:</s>




NEXT




<s> static void dma_sdram_preload(void *sdram_data_tx_ptr, void *sdram_data_rx_ptr)
{
int i;
int j;

u32 testaddr = (u32)sdram_data_tx_ptr;

for (i = 0; i < desc_num; i++) {
for (j = 0; j < dma_pkt_size; j = j + 4) {
REG32(testaddr + i * dma_pkt_size + j)
= DEFAULT_TEST_PATTEN;
}
}
pr_info("SDR Preload(0x55aa00ff) with data on TX location done\n");

testaddr = (u32)sdram_data_rx_ptr;
pr_info("RX Preload start address:0x%08x\n", (u32)(testaddr));

for (i = 0; i < desc_num; i++) {
for (j = 0; j < roundup(dma_pkt_size,
dma_burst << 2); j = j + 4)
REG32(testaddr + i * dma_pkt_size + j) = 0xcccccccc;
}
pr_info("SDR locations for Memcopy RX preset to 0xcccccccc done\n");
}

The above function is used to clear sdram data.</s>




NEXT




<s> static void rtl839x_read_pie_fixed_fields(u32 r[], struct pie_rule *pr)
{
pr->spmmask_fix = (r[6] >> 30) & 0x3;
pr->spn = (r[6] >> 24) & 0x3f;
pr->mgnt_vlan = (r[6] >> 23) & 1;
pr->dmac_hit_sw = (r[6] >> 22) & 1;
pr->not_first_frag = (r[6] >> 21) & 1;
pr->frame_type_l4 = (r[6] >> 18) & 7;
pr->frame_type = (r[6] >> 16) & 3;
pr->otag_fmt = (r[6] >> 15) & 1;
pr->itag_fmt = (r[6] >> 14) & 1;
pr->otag_exist = (r[6] >> 13) & 1;
pr->itag_exist = (r[6] >> 12) & 1;
pr->frame_type_l2 = (r[6] >> 10) & 3;
pr->tid = (r[6] >> 8) & 3;

pr->spmmask_fix_m = (r[12] >> 6) & 0x3;
pr->spn_m = r[12]  & 0x3f;
pr->mgnt_vlan_m = (r[13] >> 31) & 1;
pr->dmac_hit_sw_m = (r[13] >> 30) & 1;
pr->not_first_frag_m = (r[13] >> 29) & 1;
pr->frame_type_l4_m = (r[13] >> 26) & 7;
pr->frame_type_m = (r[13] >> 24) & 3;
pr->otag_fmt_m = (r[13] >> 23) & 1;
pr->itag_fmt_m = (r[13] >> 22) & 1;
pr->otag_exist_m = (r[13] >> 21) & 1;
pr->itag_exist_m = (r[13] >> 20) & 1;
pr->frame_type_l2_m = (r[13] >> 18) & 3;
pr->tid_m = (r[13] >> 16) & 3;

pr->valid = r[13] & BIT(15);
pr->cond_not = r[13] & BIT(14);
pr->cond_and1 = r[13] & BIT(13);
pr->cond_and2 = r[13] & BIT(12);
}

The above function is used to process the first 8 bytes of the RTL_PIE_RULE_FIXED_FIELDS structure for the rx data path. This has changed in later releases of kernel. I am not sure whether these changes were made in the




NEXT




<s> static int do_set(nvram_handle_t *nvram, const char *pair)
{
char *val = strstr(pair, "=");
char var[strlen(pair)];
int stat = 1;

if( val != NULL )
{
memset(var, 0, sizeof(var));
strncpy(var, pair, (int)(val-pair));
stat = nvram_set(nvram, var, (char *)(val + 1));
}

return stat;
}

The above function is used to set the nvram pair value.
In uci, you can use the set statement. For example:
Code:
set fio-client=a.b.c=1
will set the fio-client=a.




NEXT




<s> static void rtl839x_write_pie_fixed_fields(u32 r[],  struct pie_rule *pr)
{
r[6] = ((u32) (pr->spmmask_fix & 0x3)) << 30;
r[6] |= ((u32) (pr->spn & 0x3f)) << 24;
r[6] |= pr->mgnt_vlan ? BIT(23) : 0;
r[6] |= pr->dmac_hit_sw ? BIT(22) : 0;
r[6] |= pr->not_first_frag ? BIT(21) : 0;
r[6] |= ((u32) (pr->frame_type_l4 & 0x7)) << 18;
r[6] |= ((u32) (pr->frame_type & 0x3)) << 16;
r[6] |= pr->otag_fmt ? BIT(15) : 0;
r[6] |= pr->itag_fmt ? BIT(14) : 0;
r[6] |= pr->otag_exist ? BIT(13) : 0;
r[6] |= pr->itag_exist ? BIT(12) : 0;
r[6] |= ((u32) (pr->frame_type_l2 & 0x3)) << 10;
r[6] |= ((u32) (pr->tid & 0x3)) << 8;

r[12] |= ((u32) (pr->spmmask_fix_m & 0x3)) << 6;
r[12] |= (u32) (pr->spn_m & 0x3f);
r[13] |= pr->mgnt_vlan_m ? BIT(31) : 0;
r[13] |= pr->dmac_hit_sw_m ? BIT(30) : 0;
r[13] |= pr->not_first_frag_m ? BIT(29) : 0;
r[13] |= ((u32) (pr->frame_type_l4_m & 0x7)) << 26;
r[13] |= ((u32) (pr->frame_type_m & 0x3)) << 24;
r[13] |= pr->otag_fmt_m ? BIT(23) : 0;
r[13] |= pr->itag_fmt_m ? BIT(22) : 0;
r[13] |= pr->otag_exist_m ? BIT(21) : 0;
r[13] |= pr->itag_exist_m ? BIT(20) : 0;
r[13] |= ((u32) (pr->frame_type_l2_m & 0x3)) << 18;
r[13] |= ((u32) (pr->tid_m & 0x3)) << 16;

r[13] |= pr->valid ? BIT(15) : 0;
r[13] |= pr->cond_not ? BIT(14) : 0;
r[13] |= pr->cond_and1 ? BIT(13) : 0;
r[13] |= pr->cond_and2 ? BIT(12) : 0;
}

The above function is used to program fixed fields of PIE rule. Following table lists these fixed fields. Other rule fields that are programmable as parameters are programmed from other functions.

Rule Field    Register Bit    Description
sTID    FIFO-




NEXT




<s> static int ag71xx_ethtool_nway_reset(struct net_device *dev)
{
struct ag71xx *ag = netdev_priv(dev);
struct phy_device *phydev = ag->phy_dev;

if (!phydev)
return -ENODEV;

return genphy_restart_aneg(phydev);
}

The above function is used to reinitialize the autonegotiation
process. This call is triggered if the auto-negotiation process
takes too long or is stuck in a loop. After this call, the hardware
will perform an auto-negotiation sequence




NEXT




<s> rtk_api_ret_t rtk_vlan_portFid_get(rtk_port_t port, rtk_enable_t *pEnable, rtk_fid_t *pFid)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if(NULL == pFid)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortBasedFidEn(rtk_switch_port_L2P_get(port), pEnable))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicPortBasedFid(rtk_switch_port_L2P_get(port), pFid))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read VLAN port FID configuration. The structure of the port fid configuration is illustrated in the Table 5.1 “Port FID Configuration table”</s>




NEXT




<s> u32 msdc_time_calc(u32 old_L32, u32 old_H32, u32 new_L32, u32 new_H32)
{
u32 ret = 0;

if (new_H32 == old_H32) {
ret = new_L32 - old_L32;
} else if (new_H32 == (old_H32 + 1)) {
if (new_L32 > old_L32)
printk("msdc old_L<0x%x> new_L<0x%x>\n", old_L32, new_L32);
ret = (0xffffffff - old_L32);
ret += new_L32;
} else {
printk("msdc old_H<0x%x> new_H<0x%x>\n", old_H32, new_H32);
}

return ret;
}

The above function is used to calculate elapsed time for the interrupt timeout.
The problem is that new_L32 is greater than old_L32, resulting in a negative time.
The reason why our interrupt is frequently triggered is that the timing is incorrect.




NEXT




<s> hostapd_ubus_vlan_action(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
const char *action)
{
struct vlan_description *desc = &vlan->vlan_desc;
void *c;
int i;

if (!hapd->ubus.obj.has_subscribers)
return;

blob_buf_init(&b, 0);
blobmsg_add_string(&b, "ifname", vlan->ifname);
blobmsg_add_string(&b, "bridge", vlan->bridge);
blobmsg_add_u32(&b, "vlan_id", vlan->vlan_id);

if (desc->notempty) {
blobmsg_add_u32(&b, "untagged", desc->untagged);
c = blobmsg_open_array(&b, "tagged");
for (i = 0; i < ARRAY_SIZE(desc->tagged) && desc->tagged[i]; i++)
blobmsg_add_u32(&b, "", desc->tagged[i]);
blobmsg_close_array(&b, c);
}

ubus_notify(ctx, &hapd->ubus.obj, action, b.head, -1);
}

The above function is used to send the blob message to ubus server, using
which the client (ubus) will be able to identify which of the vlans are
active in the driver and make the configuration accordingly. It is also
used to change the vlan




NEXT




<s> static int rtl8367b_reset_chip(struct rtl8366_smi *smi)
{
int timeout = 10;
int err;
u32 data;

REG_WR(smi, RTL8367B_CHIP_RESET_REG, RTL8367B_CHIP_RESET_HW);
msleep(RTL8367B_RESET_DELAY);

do {
REG_RD(smi, RTL8367B_CHIP_RESET_REG, &data);
if (!(data & RTL8367B_CHIP_RESET_HW))
break;

msleep(1);
} while (--timeout);

if (!timeout) {
dev_err(smi->parent, "chip reset timed out\n");
return -ETIMEDOUT;
}

return 0;
}

The above function is used to reset the CHIP_RST_N
pin which can be seen in the reset_chip function of the 83666 driver. What it
does exactly is simple as it is written, it writes to the
836




NEXT




<s> int LzmaLenDecode(CProb *p, CRangeDecoder *rd, int posState)
{
if(RangeDecoderBitDecode(p + LenChoice, rd) == 0)
return RangeDecoderBitTreeDecode(p + LenLow +
(posState << kLenNumLowBits), kLenNumLowBits, rd);
if(RangeDecoderBitDecode(p + LenChoice2, rd) == 0)
return kLenNumLowSymbols + RangeDecoderBitTreeDecode(p + LenMid +
(posState << kLenNumMidBits), kLenNumMidBits, rd);
return kLenNumLowSymbols + kLenNumMidSymbols +
RangeDecoderBitTreeDecode(p + LenHigh, kLenNumHighBits, rd);
}

The above function is used to decode the length to use for a stream when the stream length is limited by a 16-bit unsigned integer variable (p + LenChoiceHigh, kLenNumHighBits). It decompresses the current stream based on the range of stream




NEXT




<s> static bool nmbm_check_info_table_header(struct nmbm_instance *ni, void *data)
{
struct nmbm_info_table_header *ifthdr = data;

if (ifthdr->header.magic != NMBM_MAGIC_INFO_TABLE)
return false;

if (ifthdr->header.size != ni->info_table_size)
return false;

if (ifthdr->mapping_table_off - ifthdr->state_table_off < ni->state_table_size)
return false;

if (ni->info_table_size - ifthdr->mapping_table_off < ni->mapping_table_size)
return false;

return true;
}

The above function is used to check if the content of an NMBM state is valid. It checks the magic header of
the NMBM info table, which is a signature, in section [state_mapping64.info.bin], to check if the





NEXT




<s> rtk_api_ret_t rtk_rate_shareMeter_set(rtk_meter_id_t index, rtk_meter_type_t type, rtk_rate_t rate, rtk_enable_t ifg_include)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (index > RTK_MAX_METER_ID)
return RT_ERR_FILTER_METER_ID;

if (type >= METER_TYPE_END)
return RT_ERR_INPUT;

if (ifg_include >= RTK_ENABLE_END)
return RT_ERR_INPUT;

switch (type)
{
case METER_TYPE_KBPS:
if (rate > RTL8367C_QOS_RATE_INPUT_MAX_HSG || rate < RTL8367C_QOS_RATE_INPUT_MIN)
return RT_ERR_RATE ;

if ((retVal = rtl8367c_setAsicShareMeter(index, rate >> 3, ifg_include)) != RT_ERR_OK)
return retVal;

break;
case METER_TYPE_PPS:
if (rate > RTL8367C_QOS_PPS_INPUT_MAX || rate < RTL8367C_QOS_PPS_INPUT_MIN)
return RT_ERR_RATE ;

if ((retVal = rtl8367c_setAsicShareMeter(index, rate, ifg_include)) != RT_ERR_OK)
return retVal;

break;
default:
return RT_ERR_INPUT;
}

/* Set Type */
if ((retVal = rtl8367c_setAsicShareMeterType(index, (rtk_uint32)type)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the rate share meter.
The following values should be taken into consideration when configuring this API. If type equals METER_TYPE_KBPS, the rate value is the rate in kbit/s and the input_if




NEXT




<s> rtk_api_ret_t  rtk_oam_parserAction_set(rtk_port_t port, rtk_oam_parser_act_t action)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (action >= OAM_PARSER_ACTION_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicOamParser(rtk_switch_port_L2P_get(port), action))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to modify the action for OAM parse action with given port number and action.

rtk_api_ret_t  rtk_oam_parserAction_get(rtk_port_t port, rtk_oam




NEXT




<s> ret_t rtl8367c_getAsicStormFilterUnknownMulticastMeter(rtk_uint32 port, rtk_uint32 *pMeter)
{
ret_t retVal;

if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_STORM_UNMC_METER_CTRL_REG(port), RTL8367C_STORM_UNMC_METER_CTRL_MASK(port), pMeter);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_UNMC_METER_CTRL4 + ((port - 8) >> 1), RTL8367C_STORM_UNMC_METER_CTRL_MASK(port), pMeter);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to get Asic Storm Filter Unknown Multicast Meter value. By default, the function uses a macro called _rtl8367c_getAsicRegBits(addr, mask, pdata) to get Asic Storm Filter




NEXT




<s> rtk_api_ret_t rtk_stat_queueManage_reset(void)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_setAsicMIBsCounterReset(FALSE,TRUE,0)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to disable all the Q1_EN queue.
It is recommended to use this API when user wants to move packets from any
one queue to another queue.</s>




NEXT




<s> ead_open_pcap(const char *ifname, char *errbuf, bool rx)
{
pcap_t *p;

p = pcap_create(ifname, errbuf);
if (p == NULL)
goto out;

pcap_set_snaplen(p, PCAP_MRU);
pcap_set_promisc(p, rx);
pcap_set_timeout(p, PCAP_TIMEOUT);
pcap_set_protocol_linux(p, (rx ? htons(ETH_P_IP) : 0));
pcap_set_buffer_size(p, (rx ? 10 : 1) * PCAP_MRU);
pcap_activate(p);
set_recv_type(p, rx);
out:
return p;
}

The above function is used to open a libpcap object file. It’s a simple API exposed in libpcap (e.g. see here). The first 4 arguments passed to pcap_create() are used to specify the capture interface and its parameters.




NEXT




<s> static unsigned long msp430_blink_delay(unsigned long delay)
{
unsigned long msp430_delay;

msp430_delay = delay + MSP430_LED_BLINK_MS / 2;
msp430_delay = msp430_delay / MSP430_LED_BLINK_MS;
if (msp430_delay == 0)
msp430_delay = 1;

return msp430_delay;
}

The above function is used to calculate MSP430 delay values. The value of "msp430_delay" is a calculation of multiplying delay by a number.

The value of the "msp430_delay" calculation depends on




NEXT




<s> static void gpio_keys_handle_button(struct gpio_keys_button_data *bdata)
{
unsigned int type = bdata->b->type ?: EV_KEY;
int state = gpio_button_get_value(bdata);
unsigned long seen = jiffies;

pr_debug(PFX "event type=%u, code=%u, pressed=%d\n",
type, bdata->b->code, state);

/* is this the initialization state? */
if (bdata->last_state == -1) {
/*
* Don't advertise unpressed buttons on initialization.
* Just save their state and continue otherwise this
* can cause OpenWrt to enter failsafe.
*/
if (type == EV_KEY && state == 0)
goto set_state;
/*
* But we are very interested in pressed buttons and
* initial switch state. These will be reported to
* userland.
*/
} else if (bdata->last_state == state) {
/* reset asserted counter (only relevant for polled keys) */
bdata->count = 0;
return;
}

if (bdata->count < bdata->threshold) {
bdata->count++;
return;
}

if (bdata->seen == 0)
bdata->seen = seen;

button_hotplug_create_event(button_map[bdata->map_entry].name, type,
(seen - bdata->seen) / HZ, state);
bdata->seen = seen;

set_state:
bdata->last_state = state;
bdata->count = 0;
}

The above function is used to respond to single button presses
and will be executed by our button event handler.
The most important thing to notice is the asserted counter which
handles polled devices.</s>




NEXT




<s> static int rb91x_nand_dev_ready(struct nand_chip *chip)
{
struct rb91x_nand_drvdata *drvdata = (struct rb91x_nand_drvdata *)(chip->priv);

return gpiod_get_value_cansleep(drvdata->gpio[RB91X_NAND_RDY]);
}

The above function is used to check the Ready status of the flash.</s>




NEXT




<s> struct ringbuf_entry * ringbuf_add(struct ringbuf *r)
{
struct timeval t;
struct ringbuf_entry *e;

gettimeofday(&t, NULL);

e = r->buf + (r->fill++ * r->slen);
r->fill %= r->len;

memset(e, 0, r->slen);

e->sec = t.tv_sec;
e->usec = t.tv_usec;

return e;
}

The above function is used to add entries to a ring buffer. How can I get `t.tv_sec` and `t.tv_usec` which in this function are a timeval structure to be `long` instead?

The reason I ask is




NEXT




<s> rtk_api_ret_t rtk_port_adminEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t retVal;
rtk_uint32      data;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

if (enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtk_port_phyReg_get(port, PHY_CONTROL_REG, &data)) != RT_ERR_OK)
return retVal;

if (ENABLED == enable)
{
data &= 0xF7FF;
data |= 0x0200;
}
else if (DISABLED == enable)
{
data |= 0x0800;
}

if ((retVal = rtk_port_phyReg_set(port, PHY_CONTROL_REG, data)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable the physical port.

# Port PHY Registers

The physical port registers are stored in the NVRAM by the chip’s initialization.

## PHY Control Register

Address
PHY_CONTROL_REG





NEXT




<s> ar8xxx_sw_get_port_link(struct switch_dev *dev, int port,
struct switch_port_link *link)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

ar8216_read_port_link(priv, port, link);
return 0;
}

The above function is used to get the link of a port of a switch. This function makes a call to the function ar8216_read_port_link of the submodule driver ar8216. The function call is made in the line number 




NEXT




<s> static void bmemcpy(void *av, const void *bv, size_t bits)
{
uint8_t *a = av;
const uint8_t *b = bv;

size_t bytes = bits / 8;
bits %= 8;
memcpy(a, b, bytes);

if (bits > 0) {
uint8_t mask = (1 << (8 - bits)) - 1;
a[bytes] = (a[bytes] & mask) | ((~mask) & b[bytes]);
}
}

The above function is used to efficiently copy bits.
The function copies 1 byte at a time and does optimizations for when bits are not transfered between byte
boundaries. The function uses 2 temporary copy buffers with size 0x400 bytes in size




NEXT




<s> static void fe_get_drvinfo(struct net_device *dev,
struct ethtool_drvinfo *info)
{
struct fe_priv *priv = netdev_priv(dev);
struct fe_soc_data *soc = priv->soc;

strlcpy(info->driver, priv->dev->driver->name, sizeof(info->driver));
strlcpy(info->version, MTK_FE_DRV_VERSION, sizeof(info->version));
strlcpy(info->bus_info, dev_name(priv->dev), sizeof(info->bus_info));

if (soc->reg_table[FE_REG_FE_COUNTER_BASE])
info->n_stats = ARRAY_SIZE(fe_gdma_str);
}

The above function is used to get driver info.
I think it should be used at driver initialization.

Is it enough to get the driver name(‘fe_10g_nics’ in fe_soc_list_of_dmas.c and




NEXT




<s> static int rtl8366rb_sw_get_port_rate_out(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

if (val->port_vlan >= RTL8366RB_NUM_PORTS)
return -EINVAL;

rtl8366_smi_read_reg(smi, RTL8366RB_EB_REG(val->port_vlan), &data);
data &= RTL8366RB_EB_BDTH_MASK;
if (data < RTL8366RB_EB_BDTH_MASK)
data += 1;

val->value.i = (int)data * RTL8366RB_BDTH_UNIT;

return 0;
}

The above function is used to get the bandwidth rate of the port if
VLAN tagging is enabled.

RTL8366RB_EB_BDTH_MASK is a value to determine if VLAN tagging is
enabled.  If V




NEXT




<s> int BN_bn2bin(const BIGNUM *a, unsigned char *to)
{
int n,i;
BN_ULONG l;

n=i=BN_num_bytes(a);
while (i-- > 0)
{
l=a->d[i/BN_BYTES];
*(to++)=(unsigned char)(l>>(8*(i%BN_BYTES)))&0xff;
}
return(n);
}

The above function is used to convert a BIG Num object to an array of
unsigned char, which is required by the OpenSSL AES API; to be able to
send the key to OpenSSL we needed to use this function on the BIGNUM
object.




NEXT




<s> int AT91F_MCI_SDCard_GetCID (AT91PS_MciDevice pMCI_Device, unsigned int *response)
{
if(AT91F_MCI_SendCommand(pMCI_Device,
AT91C_ALL_SEND_CID_CMD,
AT91C_NO_ARGUMENT) != AT91C_CMD_SEND_OK)
return AT91C_CMD_SEND_ERROR;

response[0] = AT91C_BASE_MCI->MCI_RSPR[0];
response[1] = AT91C_BASE_MCI->MCI_RSPR[1];
response[2] = AT91C_BASE_MCI->MCI_RSPR[2];
response[3] = AT91C_BASE_MCI->MCI_RSPR[3];

return AT91C_CMD_SEND_OK;
}

The above function is used to retrieve Card ID response for the SD Card. To be particular the card ID response is received in the
form of a 16-bit string which is stored in the register MCI_RSPR[5..0] which means the




NEXT




<s> uc_bpf_module_get_programs(uc_vm_t *vm, size_t nargs)
{
struct bpf_object *obj = uc_fn_thisval("bpf.module");
struct bpf_program *prog = NULL;
uc_value_t *rv;
int i = 0;

if (!obj)
err_return(EINVAL, NULL);

rv = ucv_array_new(vm);
bpf_object__for_each_program(prog, obj)
ucv_array_set(rv, i++, ucv_string_new(bpf_program__name(prog)));

return rv;
}

The above function is used to enumerate the progarmms of the bpf programs that were loaded by UC.

For example, below is a program that enumerates the bpf programs after loading them in a loop:

for (int i = 




NEXT




<s> int BN_num_bits_word(BN_ULONG l)
{
static const char bits[256]={
0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
};

#if defined(SIXTY_FOUR_BIT_LONG)
if (l & 0xffffffff00000000L)
{
if (l & 0xffff000000000000L)
{
if (l & 0xff00000000000000L)
{
return(bits[(int)(l>>56)]+56);
}
else    return(bits[(int)(l>>48)]+48);
}
else
{
if (l & 0x0000ff0000000000L)
{
return(bits[(int)(l>>40)]+40);
}
else    return(bits[(int)(l>>32)]+32);
}
}
else
#else
#ifdef SIXTY_FOUR_BIT
if (l & 0xffffffff00000000LL)
{
if (l & 0xffff000000000000LL)
{
if (l & 0xff00000000000000LL)
{
return(bits[(int)(l>>56)]+56);
}
else    return(bits[(int)(l>>48)]+48);
}
else
{
if (l & 0x0000ff0000000000LL)
{
return(bits[(int)(l>>40)]+40);
}
else    return(bits[(int)(l>>32)]+32);
}
}
else
#endif
#endif
{
#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)
if (l & 0xffff0000L)
{
if (l & 0xff000000L)
return(bits[(int)(l>>24L)]+24);
else    return(bits[(int)(l>>16L)]+16);
}
else
#endif
{
#if defined(SIXTEEN_BIT) || defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)
if (l & 0xff00L)
return(bits[(int)(l>>8)]+8);
else
#endif
return(bits[(int)(l   )]  );
}
}
}

The above function is used to quickly count how many base-2 bits are in a word (4 bytes in x86 assembly - I believe - or 32 bits). To count how many bits are in the entire number, we just count the number of words in





NEXT




<s> int dokey(bool rsa, char **arg)
{
mbedtls_pk_context key;
unsigned int ksize = 512;
int exp = 65537;
char *path = NULL;
bool pem = true;
mbedtls_ecp_group_id curve = MBEDTLS_ECP_DP_SECP256R1;

while (*arg && **arg == '-') {
if (!strcmp(*arg, "-out") && arg[1]) {
path = arg[1];
arg++;
} else if (!strcmp(*arg, "-3")) {
exp = 3;
} else if (!strcmp(*arg, "-der")) {
pem = false;
}
arg++;
}

if (*arg && rsa) {
ksize = (unsigned int)atoi(*arg);
} else if (*arg) {
curve = ecp_curve((const char *)*arg);
if (curve == MBEDTLS_ECP_DP_NONE) {
fprintf(stderr, "error: invalid curve name: %s\n", *arg);
return 1;
}
}

gen_key(&key, rsa, ksize, exp, curve, pem);
write_key(&key, path, pem);

mbedtls_pk_free(&key);

return 0;
}

The above function is used to decrypt the private keys. It can be used to decrypt the keys generated by mnemonic phrases and backup files. To do this, you need to specify the parameters -3, -out and -der. This function will output the




NEXT




<s> uint8_t hndcrc8 (
uint8_t * pdata,  /* pointer to array of data to process */
uint32_t nbytes,  /* number of input data bytes to process */
uint8_t crc       /* either CRC8_INIT_VALUE or previous return value */
) {
while (nbytes-- > 0)
crc = crc8_table[(crc ^ *pdata++) & 0xff];

return crc;
}

The above function is used to compute a checksum, called the Cyclic Redundancy Check (CRC, for short), over an arbitrary data input (up to 255,000 bytes) to form an error detection value which is calculated over the data




NEXT




<s> rtk_api_ret_t rtk_vlan_egrFilterEnable_set(rtk_enable_t egrFilter)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(egrFilter >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

/* enable VLAN */
if ((retVal = rtl8367c_setAsicVlanFilter((rtk_uint32)egrFilter)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the egress VLAN filtering on ports of a switch to enable the RGMII interface.

#include<soc/dpp/port_sw/port_sw.h>
#include<soc/dpp/




NEXT




<s> void aes_decrypt (struct crypto_tfm *tfm, uint8_t *out, const uint8_t *in)
{
struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
ifx_deu_aes (ctx, out, in, NULL, AES_BLOCK_SIZE,
CRYPTO_DIR_DECRYPT, 0);
}

The above function is used to decrypt a block of data:
unsigned char dst[16] = { 0 };
unsigned char data_out[16] = { 0 };
unsigned char data_in[16] = { 4,




NEXT




<s> static int mtdsplit_parse_elf(struct mtd_info *mtd,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct elf_header hdr;
size_t loader_size, rootfs_offset;
enum mtdsplit_part_type type;
struct mtd_partition *parts;
int err;

err = mtdsplit_elf_read_mtd(mtd, 0, (uint8_t *)&hdr, sizeof(hdr));
if (err)
return err;

if (be32_to_cpu(hdr.ident.magic) != ELF_MAGIC) {
pr_debug("invalid ELF magic %08x\n",
be32_to_cpu(hdr.ident.magic));
return -EINVAL;
}

switch (hdr.ident.class) {
case ELF_CLASS_32:
err = elf32_determine_size(mtd, &hdr, &loader_size);
break;
case ELF_CLASS_64:
err = elf64_determine_size(mtd, &hdr, &loader_size);
break;
default:
pr_debug("invalid ELF class %i\n", hdr.ident.class);
err = -EINVAL;
}

if (err)
return err;

err = mtd_find_rootfs_from(mtd, loader_size, mtd->size,
&rootfs_offset, &type);
if (err)
return err;

if (rootfs_offset == mtd->size) {
pr_debug("no rootfs found in \"%s\"\n", mtd->name);
return -ENODEV;
}

parts = kzalloc(ELF_NR_PARTS * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = 0;
parts[0].size = rootfs_offset;

if (type == MTDSPLIT_PART_TYPE_UBI)
parts[1].name = UBI_PART_NAME;
else
parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = mtd->size - rootfs_offset;

*pparts = parts;
return ELF_NR_PARTS;
}

The above function is used to parse elf to find out all the partition information in it. This is done by reading the magic bytes first to confirm if it is an elf file, then confirm the elf class type and how long the elf file is. The elf file structure will also




NEXT




<s> int ctr_rfc3686_aes_encrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
unsigned int nbytes, enc_bytes;
int err;
u8 rfc3686_iv[16];

err = skcipher_walk_virt(&walk, req, false);
nbytes = walk.nbytes;

/* set up counter block */
memcpy(rfc3686_iv, ctx->nonce, CTR_RFC3686_NONCE_SIZE);
memcpy(rfc3686_iv + CTR_RFC3686_NONCE_SIZE, walk.iv, CTR_RFC3686_IV_SIZE);

/* initialize counter portion of counter block */
*(__be32 *)(rfc3686_iv + CTR_RFC3686_NONCE_SIZE + CTR_RFC3686_IV_SIZE) =
cpu_to_be32(1);

while ((nbytes = enc_bytes = walk.nbytes) && (walk.nbytes >= AES_BLOCK_SIZE)) {
enc_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_ctr(ctx, walk.dst.virt.addr, walk.src.virt.addr,
rfc3686_iv, enc_bytes, CRYPTO_DIR_ENCRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

/* to handle remaining bytes < AES_BLOCK_SIZE */
if (walk.nbytes) {
ifx_deu_aes_ctr(ctx, walk.dst.virt.addr, walk.src.virt.addr,
rfc3686_iv, walk.nbytes, CRYPTO_DIR_ENCRYPT, 0);
err = skcipher_walk_done(&walk, 0);
}

return err;
}

The above function is used to encrypt (or decrypt) a CTR protected message in RFC3686. It is called when the call to crypto API (crypto_tfm_encrypt()) is made. The function basically invokes the crypto specific call




NEXT




<s> ar8xxx_sw_set_mib_type(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

if (!ar8xxx_has_mib_counters(priv))
return -EOPNOTSUPP;
priv->mib_type = val->value.i;
return 0;
}

The above function is used to set the counters type. So, if you have a counter which is for Ethernet then you have to set this counter to 0 or Ethernet. Similarly, you can set the value to 1 or Token Ring.






NEXT




<s> static inline void vr9_reset_ppe(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct reset_control *dsp;
struct reset_control *dfe;
struct reset_control *tc;

dsp = devm_reset_control_get(dev, "dsp");
if (IS_ERR(dsp)) {
if (PTR_ERR(dsp) != -EPROBE_DEFER)
dev_err(dev, "Failed to lookup dsp reset\n");
// 		return PTR_ERR(dsp);
}

dfe = devm_reset_control_get(dev, "dfe");
if (IS_ERR(dfe)) {
if (PTR_ERR(dfe) != -EPROBE_DEFER)
dev_err(dev, "Failed to lookup dfe reset\n");
// 		return PTR_ERR(dfe);
}

tc = devm_reset_control_get(dev, "tc");
if (IS_ERR(tc)) {
if (PTR_ERR(tc) != -EPROBE_DEFER)
dev_err(dev, "Failed to lookup tc reset\n");
// 		return PTR_ERR(tc);
}

reset_control_assert(dsp);
udelay(1000);
reset_control_assert(dfe);
udelay(1000);
reset_control_assert(tc);
udelay(1000);
*PP32_SRST &= ~0x000303CF;
udelay(1000);
*PP32_SRST |= 0x000303CF;
udelay(1000);
}

The above function is used to reset APE of VRX1700.
APE is Powered from L1 domain
Power down L1
Wait for 1ms
Power up L1
Wait for 1ms
Restart SPR(D




NEXT




<s> void bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp)
{
int i,j,max;
BN_ULONG *ap,*rp;

max=n*2;
ap=a;
rp=r;
rp[0]=rp[max-1]=0;
rp++;
j=n;

if (--j > 0)
{
ap++;
rp[j]=bn_mul_words(rp,ap,j,ap[-1]);
rp+=2;
}

for (i=n-2; i>0; i--)
{
j--;
ap++;
rp[j]=bn_mul_add_words(rp,ap,j,ap[-1]);
rp+=2;
}

bn_add_words(r,r,r,max);

/* There will not be a carry */

bn_sqr_words(tmp,a,n);

bn_add_words(r,r,tmp,max);
}

The above function is used to compute bn_sqr1 to compute bn_mul1. This does
an inplace square.</s>




NEXT




<s> ar8xxx_rmw(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
{
struct mii_bus *bus = priv->mii_bus;
u16 r1, r2, page;
u32 ret;

split_addr((u32) reg, &r1, &r2, &page);

mutex_lock(&bus->mdio_lock);

bus->write(bus, 0x18, 0, page);
wait_for_page_switch();

ret = ar8xxx_mii_read32(priv, 0x10 | r2, r1);
ret &= ~mask;
ret |= val;
ar8xxx_mii_write32(priv, 0x10 | r2, r1, ret);

mutex_unlock(&bus->mdio_lock);

return ret;
}

The above function is used to set up a register and it is the way it is.  It takes an index of the register that you want to setup and it takes a mask and a value.  How hard would it be to pass in a structure that has the index,




NEXT




<s> static inline void sata_oxnas_clear_CS_error(struct ata_port *ap)
{
struct sata_oxnas_port_priv *pd = ap->private_data;
u32 *base = pd->port_base;
u32 reg;

reg = ioread32(base + SATA_CONTROL);
reg &= SATA_CTL_ERR_MASK;
iowrite32(reg, base + SATA_CONTROL);
}

The above function is used to reset the CS error bit in the SATA_CONTROL register.  That's fine, and there was nothing stopping an ISR (for example) from calling the above from within an atomic section.

The problem is that the oxnas




NEXT




<s> void __init device_tree_init(void)
{
if (!fdt_check_header(&__appended_dtb)) {
fdt = &__appended_dtb;
pr_info("Using appended Device Tree.\n");
}
initial_boot_params = (void *)fdt;
unflatten_and_copy_device_tree();
}

The above function is used to initialize Device Tree. We use  the appended device tree file if we are on S390 mainframe. The __appended_dtb is global to the current kernel.

The unflatten_and_copy_device




NEXT




<s> rtk_api_ret_t rtk_switch_isSgmiiPort(rtk_port_t logicalPort)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(logicalPort >= RTK_SWITCH_PORT_NUM)
return RT_ERR_FAILED;

if( ((0x01 << logicalPort) & halCtrl->sg_logical_portmask) != 0)
return RT_ERR_OK;
else
return RT_ERR_FAILED;
}

The above function is used to identify whether the logical port of a switch is a Serial Gigabit Media Interface port or not.

Usage example in the case of a software driver:
```#include &quot;rtk_switch.h&quot




NEXT




<s> static int mt7620_gsw_probe(struct platform_device *pdev)
{
struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
struct mt7620_gsw *gsw;

gsw = devm_kzalloc(&pdev->dev, sizeof(struct mt7620_gsw), GFP_KERNEL);
if (!gsw)
return -ENOMEM;

gsw->base = devm_ioremap_resource(&pdev->dev, res);
if (IS_ERR(gsw->base))
return PTR_ERR(gsw->base);

gsw->dev = &pdev->dev;

gsw->irq = platform_get_irq(pdev, 0);

gsw->rst_ephy = devm_reset_control_get_exclusive(&pdev->dev, "ephy");
if (IS_ERR(gsw->rst_ephy)) {
dev_err(gsw->dev, "failed to get EPHY reset: %pe\n", gsw->rst_ephy);
gsw->rst_ephy = NULL;
}

platform_set_drvdata(pdev, gsw);

return 0;
}

The above function is used to prob the driver and for other function it is written below as per the requirement.</s>




NEXT




<s> static void zyxel_bootconfig_mtd_close(struct zyxel_bootconfig_mtd *mtd) {
close(mtd->fd);
}

The above function is used to close the MTD flash. I'm using zyxel_bootconfig.c
from the gp2x-distro-20080224 as gcc-c does not support __func__. I




NEXT




<s> static void memcopy_data_check(u32 rx_data_addr)
{
int i, j;
u32 read_data;

for (i = 0; i < desc_num; i++) {
for (j = 0; j < dma_pkt_size; j = j + 4) {
read_data = REG32(rx_data_addr + i * dma_pkt_size + j);
if (read_data != ___swab32(DEFAULT_TEST_PATTEN))
pr_info("Memcopy ERROR at addr 0x%08x data 0x%08x\n",
(rx_data_addr + j), read_data);
}
}
}

The above function is used to detect the mismatch between the data read from the shared DMA memory and the expected values. The function starts by assuming the expected value to be ___swab32(Default Test Pattern). Then for each packet, the first 4 byte of packet




NEXT




<s> static int button_hotplug_connect(struct input_handler *handler,
struct input_dev *dev, const struct input_device_id *id)
{
struct bh_priv *priv;
int ret;
int i;

for (i = 0; i < ARRAY_SIZE(button_map); i++)
if (test_bit(button_map[i].code, dev->keybit))
break;

if (i == ARRAY_SIZE(button_map))
return -ENODEV;

priv = kzalloc(sizeof(*priv) +
(sizeof(unsigned long) * ARRAY_SIZE(button_map)),
GFP_KERNEL);
if (!priv)
return -ENOMEM;

priv->seen = (unsigned long *) &priv[1];
priv->handle.private = priv;
priv->handle.dev = dev;
priv->handle.handler = handler;
priv->handle.name = DRV_NAME;

ret = input_register_handle(&priv->handle);
if (ret)
goto err_free_priv;

ret = input_open_device(&priv->handle);
if (ret)
goto err_unregister_handle;

BH_DBG("connected to %s\n", dev->name);

return 0;

err_unregister_handle:
input_unregister_handle(&priv->handle);

err_free_priv:
kfree(priv);
return ret;
}

The above function is used to attach the button hotplug and connect the handler to specific device.

Next, we will discuss about other two functions of button_handler.c and then we will finish the device hotplug code.</s>




NEXT




<s> rtk_api_ret_t rtk_vlan_transparent_get(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask)
{
rtk_api_ret_t retVal;
rtk_uint32    pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(egr_port);

if(NULL == pIgr_pmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicVlanTransparent(rtk_switch_port_L2P_get(egr_port), &pmask)) != RT_ERR_OK)
return retVal;

if(rtk_switch_portmask_P2L_get(pmask, pIgr_pmask) != RT_ERR_OK)
return RT_ERR_FAILED;

return RT_ERR_OK;
}

The above function is used to get egress port's transparent configuration.

rtk_api_ret_t rtk_vlan_transparent_set(rtk_port_t egr_port, rtk_portmask_t ig_




NEXT




<s> static int ip17xx_probe(struct phy_device *pdev)
{
struct ip17xx_state *state;
struct switch_dev *dev;
int err;

/* We only attach to PHY 0, but use all available PHYs */
if (pdev->mdio.addr != 0)
return -ENODEV;

state = kzalloc(sizeof(*state), GFP_KERNEL);
if (!state)
return -ENOMEM;

dev = &state->dev;

pdev->priv = state;
state->mii_bus = pdev->mdio.bus;

err = get_model(state);
if (err < 0)
goto error;

dev->vlans = MAX_VLANS;
dev->cpu_port = state->regs->CPU_PORT;
dev->ports = state->regs->NUM_PORTS;
dev->name = state->regs->NAME;
dev->ops = &ip17xx_ops;

pr_info("IP17xx: Found %s at %s\n", dev->name, dev_name(&pdev->mdio.dev));
return 0;

error:
kfree(state);
return err;
}

The above function is used to attach the ip17xx switch driver to the device tree node when switch is enabled in the device tree node.

static int ip17xx_suspend(struct switch_state *st)
{
struct ip17xx_




NEXT




<s> rtk_api_ret_t rtk_igmp_fastLeave_get(rtk_enable_t *pState)
{
rtk_uint32      fast_leave;
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(pState == NULL)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPFastLeaveEn(&fast_leave))!=RT_ERR_OK)
return retVal;

*pState = ((fast_leave == 1) ? ENABLED : DISABLED);
return RT_ERR_OK;
}

The above function is used to configure fast leave function.
To configure, user could read the value before sending the control in the function and then set the pState to ENABLED or DISABLED,
and finally send the control to the API function.</s>




NEXT




<s> int ofb_aes_decrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int dec_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = dec_bytes = walk.nbytes) && (walk.nbytes >= AES_BLOCK_SIZE)) {
dec_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_ofb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, dec_bytes, CRYPTO_DIR_DECRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

/* to handle remaining bytes < AES_BLOCK_SIZE */
if (walk.nbytes) {
ifx_deu_aes_ofb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, walk.nbytes, CRYPTO_DIR_DECRYPT, 0);
err = skcipher_walk_done(&walk, 0);
}

return err;
}

The above function is used to decrypt a plain text using OFB stream cipher mode. The data is divided into n chunks where n >= AES_BLOCK_SIZE, so that every of those chunks of n bytes are processed first and then it will be followed by dec




NEXT




<s> inline static int rtl838x_trk_mbr_ctr(int group)
{
return RTL838X_TRK_MBR_CTR + (group << 2);
}

The above function is used to track MAC address entry in the MAC address table using MAC address entry number (0 ~ 255 for all entry group).
This function should be called for any MAC address which MAC address entry is not exists in the MAC address table to increase




NEXT




<s> static bool rtl8214fc_media_is_fibre(struct phy_device *phydev)
{
int mac = phydev->mdio.addr;

static int reg[] = {16, 19, 20, 21};
u32 val;

phy_package_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_INTERNAL);
val = phy_package_read_paged(phydev, RTL821X_PAGE_PORT, reg[mac % 4]);
phy_package_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_AUTO);

if (val & BMCR_PDOWN)
return false;

return true;
}

The above function is used to detect the type of media (fibre, coax, or uTP) connected on R8214/R8334 devices running an 83xx driver.

R8214 is connected to a




NEXT




<s> static void __exit rtl8367_module_exit(void)
{
platform_driver_unregister(&rtl8367_driver);
}

The above function is used to unregister the platform that was already registered. When platform_register(&device_driver)  is used to register the driver, platform_driver_unregister(&rtl8367_driver)  is used to unregister the same driver




NEXT




<s> rtk_api_ret_t rtk_trap_unmatchMacMoving_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortUnmatchedSaMoving(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the state of the unmatch unicast and multicast MAC address mobility feature in port.
Function Arguments:
* pEnable: Pointer to a Boolean variable. If the variable is set to "1", it means that the




NEXT




<s> static void __init wsap3715i_setup_arch(void)
{
if (ppc_md.progress)
ppc_md.progress("wsap3715i_setup_arch()", 0);

fsl_pci_assign_primary();

pr_info("WS-AP3715i from Enterasys\n");
}

The above function is used to register the PCI device which is a LAN PCI network adapter. It is part of the wsap3715i.h header files created by the developer for this driver.

The above is one simple step for the PCI Driver creation




NEXT




<s> int rtl83xx_l2_nexthop_add(struct rtl838x_switch_priv *priv, struct rtl83xx_nexthop *nh)
{
struct rtl838x_l2_entry e;
u64 seed = priv->r->l2_hash_seed(nh->mac, nh->rvid);
u32 key = priv->r->l2_hash_key(priv, seed);
int idx = -1;
u64 entry;

pr_debug("%s searching for %08llx vid %d with key %d, seed: %016llx\n",
__func__, nh->mac, nh->rvid, key, seed);

e.type = L2_UNICAST;
u64_to_ether_addr(nh->mac, &e.mac[0]);
e.port = nh->port;

/* Loop over all entries in the hash-bucket and over the second block on 93xx SoCs */
for (int i = 0; i < priv->l2_bucket_size; i++) {
entry = priv->r->read_l2_entry_using_hash(key, i, &e);

if (!e.valid || ((entry & 0x0fffffffffffffffULL) == seed)) {
idx = i > 3 ? ((key >> 14) & 0xffff) | i >> 1
: ((key << 2) | i) & 0xffff;
break;
}
}

if (idx < 0) {
pr_err("%s: No more L2 forwarding entries available\n", __func__);
return -1;
}

/* Found an existing (e->valid is true) or empty entry, make it a nexthop entry */
nh->l2_id = idx;
if (e.valid) {
nh->port = e.port;
nh->vid = e.vid;		/* Save VID */
nh->rvid = e.rvid;
nh->dev_id = e.stack_dev;
/* If the entry is already a valid next hop entry, don't change it */
if (e.next_hop)
return 0;
} else {
e.valid = true;
e.is_static = true;
e.rvid = nh->rvid;
e.is_ip_mc = false;
e.is_ipv6_mc = false;
e.block_da = false;
e.block_sa = false;
e.suspended = false;
e.age = 0;			/* With port-ignore */
e.port = priv->port_ignore;
u64_to_ether_addr(nh->mac, &e.mac[0]);
}
e.next_hop = true;
e.nh_route_id = nh->id;			/* NH route ID takes place of VID */
e.nh_vlan_target = false;

priv->r->write_l2_entry_using_hash(idx >> 2, idx & 0x3, &e);

return 0;
}

The above function is used to handle nexthop address.  If the nexthop address already exist on  the switch, we check if the NH is IP MC address or IPV6 MC address then set the e->is_ip_mc or e




NEXT




<s> static int rtk_gsw_probe(struct platform_device *pdev)
{
struct device_node *np = pdev->dev.of_node;
struct device_node *mdio;
struct mii_bus *mdio_bus;
struct rtk_gsw *gsw;
const char *pm;
int ret;

mdio = of_parse_phandle(np, "mediatek,mdio", 0);

if (!mdio)
return -EINVAL;

mdio_bus = of_mdio_find_bus(mdio);

if (!mdio_bus)
return -EPROBE_DEFER;

gsw = devm_kzalloc(&pdev->dev, sizeof(struct rtk_gsw), GFP_KERNEL);

if (!gsw)
return -ENOMEM;

gsw->dev = &pdev->dev;

gsw->bus = mdio_bus;

gsw->reset_pin = of_get_named_gpio(np, "mediatek,reset-pin", 0);
if (gsw->reset_pin >= 0) {
ret = devm_gpio_request(gsw->dev, gsw->reset_pin, "mediatek,reset-pin");
if (ret)
printk("fail to devm_gpio_request\n");
}

_gsw = gsw;

init_gsw();

//init default vlan or init swocnfig
if(!of_property_read_string(pdev->dev.of_node,
"mediatek,port_map", &pm)) {

if (!strcasecmp(pm, "wllll"))
rtl8367s_vlan_config(1);
else
rtl8367s_vlan_config(0);

} else {
#ifdef CONFIG_SWCONFIG
rtl8367s_swconfig_init(&init_gsw);
#else
rtl8367s_vlan_config(0);
#endif
}

gsw_debug_proc_init();

platform_set_drvdata(pdev, gsw);

return 0;

}

The above function is used to probe gsw driver when it is plugged
to the Linux kernel, which is a very critical function. I have to
find it by the function name. After my search, I found

static int rtk_gsw_probe




NEXT




<s> hostapd_bss_get_sta_ies(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
struct blob_attr *tb;
struct sta_info *sta;
u8 addr[ETH_ALEN];

blobmsg_parse(addr_policy, 1, &tb, blobmsg_data(msg), blobmsg_len(msg));

if (!tb || hwaddr_aton(blobmsg_data(tb), addr))
return UBUS_STATUS_INVALID_ARGUMENT;

sta = ap_get_sta(hapd, addr);
if (!sta || (!sta->probe_ie_taxonomy && !sta->assoc_ie_taxonomy))
return UBUS_STATUS_NOT_FOUND;

blob_buf_init(&b, 0);
hostapd_add_b64_data("probe_ie", sta->probe_ie_taxonomy);
hostapd_add_b64_data("assoc_ie", sta->assoc_ie_taxonomy);
ubus_send_reply(ctx, req, b.head);

return 0;
}

The above function is used to retrieve sta_ie's for the specified station. It
reads 2 different iess from ap_get_sta structure. As soon as they are read, they
are added into a blob_buf and blob_buf is returned




NEXT




<s> static int ptm_showtime_exit(void)
{
int i;

if ( !g_showtime )
return -1;

//#ifdef CONFIG_VR9
//    IFX_REG_W32_MASK(0, 1 << 17, FFSM_CFG0);
//#endif

IFX_REG_W32(0x00, UTP_CFG);

for ( i = 0; i < ARRAY_SIZE(g_net_dev); i++ )
netif_carrier_off(g_net_dev[i]);

g_showtime = 0;

//  TODO: ReTX clean state
g_xdata_addr = NULL;

printk("leave showtime\n");

return 0;
}

The above function is used to tell firmware that we are leaving VDSL data transfer session. It will release all resources. For details, please refer to g_showtime variable.</s>




NEXT




<s> static void gpio_keys_polled_queue_work(struct gpio_keys_button_dev *bdev)
{
struct gpio_keys_platform_data *pdata = bdev->pdata;
unsigned long delay = msecs_to_jiffies(pdata->poll_interval);

if (delay >= HZ)
delay = round_jiffies_relative(delay);
schedule_delayed_work(&bdev->work, delay);
}

The above function is used to queue up the GPIO keys polled work function with a delay. GPIO keys are used to control the keyboard inputs on android and this is done by assigning the GPIO pins as input and then polling the status of the GPIO pin.</s>




NEXT




<s> yy_current_state = yy_get_previous_state(  );

/* Okay, we're now positioned to make the NUL
* transition.  We couldn't have
* yy_get_previous_state() go ahead and do it
* for us because it doesn't know how to deal
* with the possibility of jamming (and we don't
* want to build jamming into it because then it
* will run more slowly).
*/

yy_next_state = yy_try_NUL_trans( yy_current_state );

yy_bp = (yytext_ptr) + YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ++(yy_c_buf_p);
yy_current_state = yy_next_state;
goto yy_match;
}

The above function is used to return from within a rule to the main yacc driver. The rule is considered done if the NUL character is consumed.

- A rule's actions are executed if the associated token and the lookahead token in the input are identical




NEXT




<s> static int __init nct5104d_find(int addr, struct nct5104d_sio *sio)
{
int err;
u16 devid;
u8 gpio_cfg;

err = superio_enter(addr);
if (err)
return err;

err = -ENODEV;

devid = superio_inw(addr, SIO_CHIPID);
switch (devid) {
case SIO_NCT5104D_ID:
case SIO_PCENGINES_APU_NCT5104D_ID1:
case SIO_PCENGINES_APU_NCT5104D_ID2:
sio->type = nct5104d;
/* enable GPIO0 and GPIO1 */
superio_select(addr, SIO_LD_GPIO);
gpio_cfg = superio_inb(addr, SIO_GPIO_ENABLE);
gpio_cfg |= 0x03;
superio_outb(addr, SIO_GPIO_ENABLE, gpio_cfg);
break;
default:
pr_info(DRVNAME ": Unsupported device 0x%04x\n", devid);
goto err;
}
sio->addr = addr;
err = 0;

pr_info(DRVNAME ": Found %s at %#x chip id 0x%04x\n",
nct5104d_names[sio->type],
(unsigned int) addr,
(int) superio_inw(addr, SIO_CHIPID));

superio_select(sio->addr, SIO_LD_GPIO_MODE);
superio_outb(sio->addr, SIO_GPIO1_MODE, 0x0);
superio_outb(sio->addr, SIO_GPIO2_MODE, 0x0);

err:
superio_exit(addr);
return err;
}

The above function is used to locate the SuperIO device at a specific port number (addr). Then the device ID is read with the help of sio_inw() function to determine the device type as per its id. The found port is stored in sio.addr




NEXT




<s> static void print_data_header(struct data_header *printed_header)
{
printf("id: 0x%02X "
"type: 0x%02X "
"unknown: 0x%04X "
"length: 0x%04X\n"
"data: ",
printed_header->id,
printed_header->type,
printed_header->unknown, printed_header->length);

for (uint16_t i = 0; i < printed_header->length; i++)
printf("%02X ", printed_header->data[i]);

printf("\n");

}

The above function is used to display header data for the input file to the user. All functions in this program are very similar to functions in my other projects.</s>




NEXT




<s> ar8216_wait_bit(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
{
int timeout = 20;
u32 t = 0;

while (1) {
t = ar8xxx_read(priv, reg);
if ((t & mask) == val)
return 0;

if (timeout-- <= 0)
break;

udelay(10);
cond_resched();
}

pr_err("ar8216: timeout on reg %08x: %08x & %08x != %08x\n",
(unsigned int) reg, t, mask, val);
return -ETIMEDOUT;
}

The above function is used to make sure the requested bit will be set
correctly. As per the document this function is called from ar8216_do_dscp_tag_cmd,
where DSCP tag is being configured. Let us see




NEXT




<s> static void md5_hmac_exit_tfm(struct crypto_tfm *tfm)
{
struct md5_hmac_ctx *mctx = crypto_tfm_ctx(tfm);
kfree(mctx->temp);
kfree(mctx->desc);
}

The above function is used to exit the hmac_md5 transaction.
When exiting the HMAC-MD5 transaction, the memory allocated for the
hash digest and the intermediate digest are freed, but unfortunately,
it fails to free the memory for the message and




NEXT




<s> void wpas_ubus_add_bss(struct wpa_supplicant *wpa_s)
{
struct ubus_object *obj = &wpa_s->ubus.obj;
char *name;
int ret;

if (!wpas_ubus_init())
return;

if (asprintf(&name, "wpa_supplicant.%s", wpa_s->ifname) < 0)
return;

obj->name = name;
obj->type = &bss_object_type;
obj->methods = bss_object_type.methods;
obj->n_methods = bss_object_type.n_methods;
ret = ubus_add_object(ctx, obj);
wpas_ubus_ref_inc();
}

The above function is used to add an object name for BSS (BSSID, beacon interval, operational mode, and channel) to the ubus interface. The ubus_add_object function takes three parameters: struct ubus_context *ctx, a pointer




NEXT




<s> start_servers(bool restart)
{
struct ead_instance *in;
struct list_head *p;

list_for_each(p, &instances) {
in = list_entry(p, struct ead_instance, list);
if (in->pid > 0)
continue;

sleep(1);
start_server(in);
}
}

The above function is used to start servers. And “sleep(1)” calls only waits for 1s.
It means if the server is still not started after 1s, the function will skip this server and try next server.
So If some servers




NEXT




<s> static int rtl8214fc_set_eee(struct phy_device *phydev,
struct ethtool_eee *e)
{
u32 poll_state;
int port = phydev->mdio.addr;
bool an_enabled;
u32 val;

pr_debug("In %s port %d, enabled %d\n", __func__, port, e->eee_enabled);

if (rtl8214fc_media_is_fibre(phydev)) {
netdev_err(phydev->attached_dev, "Port %d configured for FIBRE", port);
return -ENOTSUPP;
}

poll_state = disable_polling(port);

/* Set GPHY page to copper */
phy_write_paged(phydev, RTL821X_PAGE_GPHY, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_COPPER);

/* Get auto-negotiation status */
val = phy_read(phydev, MII_BMCR);
an_enabled = val & BMCR_ANENABLE;

pr_info("%s: aneg: %d\n", __func__, an_enabled);
val = phy_read_paged(phydev, RTL821X_PAGE_MAC, 25);
val &= ~BIT(5);  /* Use MAC-based EEE */
phy_write_paged(phydev, RTL821X_PAGE_MAC, 25, val);

/* Enable 100M (bit 1) / 1000M (bit 2) EEE */
phy_write_paged(phydev, 7, MDIO_AN_EEE_ADV, e->eee_enabled ? (MDIO_EEE_100TX | MDIO_EEE_1000T) : 0);

/* 500M EEE ability */
val = phy_read_paged(phydev, RTL821X_PAGE_GPHY, 20);
if (e->eee_enabled)
val |= BIT(7);
else
val &= ~BIT(7);

phy_write_paged(phydev, RTL821X_PAGE_GPHY, 20, val);

/* Restart AN if enabled */
if (an_enabled) {
pr_info("%s: doing aneg\n", __func__);
val = phy_read(phydev, MII_BMCR);
val |= BMCR_ANRESTART;
phy_write(phydev, MII_BMCR, val);
}

/* GPHY page back to auto */
phy_write_paged(phydev, RTL821X_PAGE_GPHY, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_AUTO);

resume_polling(poll_state);

return 0;
}

The above function is used to enable/disable 802.3az energy-efficient Ethernet (EEE) on a network adapter through the phydev.</s>




NEXT




<s> static void rtl839x_write_mcast_pmask(int idx, u64 portmask)
{
/* Access MC_PMSK (2) via register RTL8380_TBL_L2 */
struct table_reg *q = rtl_table_get(RTL8390_TBL_L2, 2);

portmask <<= 11; /* LSB is bit 11 in data registers */
sw_w32((u32)(portmask >> 32), rtl_table_data(q, 0));
sw_w32((u32)((portmask & 0xfffff800)), rtl_table_data(q, 1));
rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to set the unicast port mask in table L2 of RTL8392 chipset. It is used when setting up the port configuration for VLAN based switch mode operation or when implementing the egress filtering in VLAN based switch




NEXT




<s> static void rtl839x_pie_init(struct rtl838x_switch_priv *priv)
{
u32 template_selectors;

mutex_init(&priv->pie_mutex);

/* Power on all PIE blocks */
for (int i = 0; i < priv->n_pie_blocks; i++)
sw_w32_mask(0, BIT(i), RTL839X_PS_ACL_PWR_CTRL);

/* Set ingress and egress ACL blocks to 50/50: first Egress block is 9 */
sw_w32_mask(0x1f, 9, RTL839X_ACL_CTRL);  /* Writes 9 to cutline field */

/* Include IPG in metering */
sw_w32(1, RTL839X_METER_GLB_CTRL);

/* Delete all present rules */
rtl839x_pie_rule_del(priv, 0, priv->n_pie_blocks * PIE_BLOCK_SIZE - 1);

/* Enable predefined templates 0, 1 for blocks 0-2 */
template_selectors = 0 | (1 << 3);
for (int i = 0; i < 3; i++)
sw_w32(template_selectors, RTL839X_ACL_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 2, 3 for blocks 3-5 */
template_selectors = 2 | (3 << 3);
for (int i = 3; i < 6; i++)
sw_w32(template_selectors, RTL839X_ACL_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 1, 4 for blocks 6-8 */
template_selectors = 2 | (3 << 3);
for (int i = 6; i < 9; i++)
sw_w32(template_selectors, RTL839X_ACL_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 0, 1 for blocks 9-11 */
template_selectors = 0 | (1 << 3);
for (int i = 9; i < 12; i++)
sw_w32(template_selectors, RTL839X_ACL_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 2, 3 for blocks 12-14 */
template_selectors = 2 | (3 << 3);
for (int i = 12; i < 15; i++)
sw_w32(template_selectors, RTL839X_ACL_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 1, 4 for blocks 15-17 */
template_selectors = 2 | (3 << 3);
for (int i = 15; i < 18; i++)
sw_w32(template_selectors, RTL839X_ACL_BLK_TMPLTE_CTRL(i));
}

The above function is used to initialize the PIE (Policy Interface Engine) of the RTL839x switch (it is present between ODM and E200 for the RTL839x switches).</s>




NEXT




<s> static int rtl839x_mdio_write_paged(struct mii_bus *bus, int mii_id, u16 page,
int regnum, u16 value)
{
struct rtl838x_eth_priv *priv = bus->priv;
int err;

if (mii_id >= 48 && mii_id <= 49 && priv->id == 0x8393)
return rtl839x_write_sds_phy(mii_id, regnum, value);

if (regnum & (MII_ADDR_C45 | MII_ADDR_C22_MMD)) {
err = rtl839x_write_mmd_phy(mii_id, mdiobus_c45_devad(regnum),
regnum, value);
pr_debug("MMD: %d dev %x register %x write %x, err %d\n", mii_id,
mdiobus_c45_devad(regnum), mdiobus_c45_regad(regnum),
value, err);

return err;
}

err = rtl839x_write_phy(mii_id, page, regnum, value);
pr_debug("PHY: %d register %x write %x, err %d\n", mii_id, regnum, value, err);

return err;
}

The above function is used to write to Phy registers and to special registers
(C22 and C45) in the Phy chip.

The 8364 can access C22 and C45 registers without accessing the Phy registers




NEXT




<s> void danube_stop(int pp32)
{
IFX_REG_W32(DBG_CTRL_STOP_SET(1), PP32_DBG_CTRL);
}

The above function is used to stop a running danube.  It is called from
the interrupt handler that is triggered when a DMA completion is
signaled to the processor.

IFX_REG_W32( <value>,  <register> ) calls




NEXT




<s> ret_t rtl8367c_getAsicSvlanTpid(rtk_uint32* pProtocolType)
{
return rtl8367c_getAsicReg(RTL8367C_REG_VS_TPID, pProtocolType);
}

The above function is used to get a register value. In this method, there is a variable that is declared as follows:

rtk_uint32 protocolType;

The function “getAsicReg” will use the pointer of “protocolType” to




NEXT




<s> static void rtl838x_pie_rule_rm(struct rtl838x_switch_priv *priv, struct pie_rule *pr)
{
int idx = pr->id;

rtl838x_pie_rule_del(priv, idx, idx);
clear_bit(idx, priv->pie_use_bm);
}

The above function is used to remove a PIE rule from a given entry index. All the other related pieces are set up like:

static void rtl838x_pie_rule_del(struct rtl838x_switch_priv *




NEXT




<s> ret_t rtl8367c_getAsicIGMPDropLeaveZero(rtk_uint32 *pDrop)
{
ret_t   retVal;
rtk_uint32  regData;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG1, RTL8367C_DROP_LEAVE_ZERO_OFFSET, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pDrop = regData;
return RT_ERR_OK;
}

The above function is used to get the value of a ASIC regitsers at offset 0x106c(bit 0~1).
The register holds 2 values.Bit0(DROP_LEAVE_ZERO) and bit1(




NEXT




<s> rtk_api_ret_t rtk_trunk_portQueueEmpty_get(rtk_portmask_t *pEmpty_portmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEmpty_portmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicQeueuEmptyStatus(&pmask)) != RT_ERR_OK)
return retVal;

if ((retVal = rtk_switch_portmask_P2L_get(pmask, pEmpty_portmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get PortMask of the Ports to detect TX Queue Empty in 8367C Switch.</s>




NEXT




<s> uint32_t bcm4908img_crc32(uint32_t crc, const void *buf, size_t len) {
const uint8_t *in = buf;

while (len) {
crc = crc32_tbl[(crc ^ *in) & 0xff] ^ (crc >> 8);
in++;
len--;
}

return crc;
}

The above function is used to calculate a 32 bit CRC code for an arbitrary sequence of bytes. It’s handy for calculating CRC codes for files. For example, you can use the function below to calculate a CRC code for a file called “foo”:





NEXT




<s> static int rttm_state_shutdown(struct clock_event_device *clkevt)
{
struct timer_of *to = to_timer_of(clkevt);

RTTM_DEBUG(to->of_base.base);
rttm_stop_timer(to->of_base.base);

return 0;
}

The above function is used to free all resources when exiting from the clock source. The function rttm_stop_timer is used to stop timer and destroy the list entry to return the data structure back to the pool. The function rttm_state_shutdown




NEXT




<s> ret_t rtl8367c_getAsicPortMirrorVlanTxLeaky(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_TX_VLAN_LEAKY_OFFSET, pEnabled);
}

The above function is used to get the TX mirror setting of TX VLAN ID. It is an 1-bit register, where 1 means TX VLAN leakiness, while 0 means otherwise. It is recommended that only the TX switch path VLAN ID is leak




NEXT




<s> rtk_api_ret_t rtk_dot1x_portBasedEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsic1xPBEnConfig(rtk_switch_port_L2P_get(port),enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the Port-Based ACL Enable configuration to the ASIC. The function takes below arguments

port :Port ID value which is an input parameter
enable :Port-Based ACL enable to set in ASIC which is an input parameter




NEXT




<s> uc_bpf_map_delete_all(uc_vm_t *vm, size_t nargs)
{
struct uc_bpf_map *map = uc_fn_thisval("bpf.map");
uc_value_t *filter = uc_fn_arg(0);
bool has_next;
void *key, *next;

if (!map)
err_return(EINVAL, NULL);

key = alloca(map->key_size);
next = alloca(map->key_size);
has_next = !bpf_map_get_next_key(map->fd.fd, NULL, next);
while (has_next) {
bool skip = false;

memcpy(key, next, map->key_size);
has_next = !bpf_map_get_next_key(map->fd.fd, next, next);

if (ucv_is_callable(filter)) {
uc_value_t *rv;

uc_value_push(ucv_get(filter));
uc_value_push(ucv_string_new_length((const char *)key, map->key_size));
if (uc_call(1) != EXCEPTION_NONE)
break;

rv = uc_vm_stack_pop(vm);
if (!rv)
break;

skip = !ucv_is_truish(rv);
ucv_put(rv);
}

if (!skip)
bpf_map_delete_elem(map->fd.fd, key);
}

return TRUE;
}

The above function is used to iterate over the elements in a hash map and delete the elements that match a filter. The implementation is straightforward - we get the first element in the hash map, and then proceed to delete the next element, until the `has_next` flag




NEXT




<s> IFX_MEI_DownloadBootPages (DSL_DEV_Device_t * pDev)
{
int boot_loop;
int page_size;
u32 dest_addr;

/*
**     DMA the boot code page(s)
*/

for (boot_loop = 1;
boot_loop <
(DSL_DEV_PRIVATE(pDev)->img_hdr-> count); boot_loop++) {
if ((DSL_DEV_PRIVATE(pDev)-> img_hdr->page[boot_loop].p_size) & BOOT_FLAG) {
page_size = IFX_MEI_GetPage (pDev, boot_loop,
GET_PROG, MAXSWAPSIZE,
mei_arc_swap_buff,
&dest_addr);
if (page_size > 0) {
IFX_MEI_DMAWrite (pDev, dest_addr,
mei_arc_swap_buff,
page_size);
}
}
if ((DSL_DEV_PRIVATE(pDev)-> img_hdr->page[boot_loop].d_size) & BOOT_FLAG) {
page_size = IFX_MEI_GetPage (pDev, boot_loop,
GET_DATA, MAXSWAPSIZE,
mei_arc_swap_buff,
&dest_addr);
if (page_size > 0) {
IFX_MEI_DMAWrite (pDev, dest_addr,
mei_arc_swap_buff,
page_size);
}
}
}
return DSL_DEV_MEI_ERR_SUCCESS;
}

The above function is used to transfer the boot code from a
network device to the ACE and it uses a buffer called mei_arc_swap_buff
to temporarily hold the data.  Note that the buffer could be filled
with multiple page transfers.





NEXT




<s> static int b53_srab_read32(struct b53_device *dev, u8 page, u8 reg, u32 *val)
{
u8 __iomem *regs = dev->priv;
int ret = 0;

ret = b53_srab_request_grant(dev);
if (ret)
goto err;

ret = b53_srab_op(dev, page, reg, 0);
if (ret)
goto err;

*val = readl(regs + B53_SRAB_RD_L);

err:
b53_srab_release_grant(dev);

return ret;
}

The above function is used to read the register in device page page on SRAB. This function is very similar to b53_srab_read32(). The only difference is that this function is in a different file and that b53_srab_request




NEXT




<s> ret_t rtl8367c_getAsicGreenPortPage(rtk_uint32 port, rtk_uint32* pPage)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint32 pageMeter;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

retVal = rtl8367c_getAsicReg(RTL8367C_PAGEMETER_PORT_REG(port), &regData);
if(retVal != RT_ERR_OK)
return retVal;

pageMeter = regData;

retVal = rtl8367c_getAsicReg(RTL8367C_PAGEMETER_PORT_REG(port) + 1, &regData);
if(retVal != RT_ERR_OK)
return retVal;

pageMeter = pageMeter + (regData << 16);

*pPage = pageMeter;
return RT_ERR_OK;
}

The above function is used to get a MAC address related page-meter. In particular, it is used to get the page-meter address where a green port MAC address information is located. There will be multiple MAC addresses in a page-meter. A specific address




NEXT




<s> ret_t rtl8367c_setAsicOamCpuPri(rtk_uint32 priority)
{
if(priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_OAM_PRIOIRTY_MASK, priority);
}

The above function is used to set the CPU priority of a RTL8367C switch chip for all VLANs. The CPU will directly forward received frames with a set OAM priority with a given priority. If the priority is between INTMIN and INTMAX (




NEXT




<s> static int rtl8218b_int_phy_probe(struct phy_device *phydev)
{
struct device *dev = &phydev->mdio.dev;
int addr = phydev->mdio.addr;

if (soc_info.family != RTL8380_FAMILY_ID)
return -ENODEV;
if (addr >= 24)
return -ENODEV;

pr_debug("%s: id: %d\n", __func__, addr);
/* All base addresses of the PHYs start at multiples of 8 */
devm_phy_package_join(dev, phydev, addr & (~7),
sizeof(struct rtl83xx_shared_private));

if (!(addr % 8)) {
struct rtl83xx_shared_private *shared = phydev->shared->priv;
shared->name = "RTL8218B (internal)";
/* Configuration must be done while patching still possible */
return rtl8380_configure_int_rtl8218b(phydev);
}

return 0;
}

The above function is used to determine the existence of the internal phy to the rtl8139 chipset and then joins to it to become a physical phy.</s>




NEXT




<s> wrgg_fix_md5(struct wrgg03_header *shdr, int fd, size_t data_offset, size_t data_size)
{
char *buf;
ssize_t res;
MD5_CTX ctx;
unsigned char digest[16];
int i;
int err = 0;

buf = malloc(data_size);
if (!buf) {
err = -ENOMEM;
goto err_out;
}

res = pread(fd, buf, data_size, data_offset);
if (res != data_size) {
perror("pread");
err = -EIO;
goto err_free;
}

MD5_Init(&ctx);
MD5_Update(&ctx, (char *)&shdr->offset, sizeof(shdr->offset));
MD5_Update(&ctx, (char *)&shdr->dev_name, sizeof(shdr->dev_name));
MD5_Update(&ctx, buf, data_size);
MD5_Final(digest, &ctx);

if (!memcmp(digest, shdr->digest, sizeof(digest))) {
if (quiet < 2)
fprintf(stderr, "the header is fixed already\n");
return -1;
}

if (quiet < 2) {
fprintf(stderr, "new size:%u, new MD5: ", data_size);
for (i = 0; i < sizeof(digest); i++)
fprintf(stderr, "%02x", digest[i]);

fprintf(stderr, "\n");
}

/* update the size in the image */
shdr->size = data_size;

/* update the checksum in the image */
memcpy(shdr->digest, digest, sizeof(digest));

err_free:
free(buf);
err_out:
return err;
}

The above function is used to verify the validity of the checksums
contained in the Wii Region Free Game-Maker’s .elf or .raw files. Since
these files have been dumped from a console, they almost certainly should
match




NEXT




<s> nvram_handle_t * nvram_open(const char *file, int rdonly)
{
int i;
int fd;
char *mtd = NULL;
nvram_handle_t *h;
nvram_header_t *header;
int offset = -1;

/* If erase size or file are undefined then try to define them */
if( (nvram_part_size == 0) || (file == NULL) )
{
/* Finding the mtd will set the appropriate erase size */
if( (mtd = nvram_find_mtd()) == NULL || nvram_part_size == 0 )
{
free(mtd);
return NULL;
}
}

if( (fd = open(file ? file : mtd, O_RDWR)) > -1 )
{
char *mmap_area = (char *) mmap(
NULL, nvram_part_size, PROT_READ | PROT_WRITE,
(( rdonly == NVRAM_RO ) ? MAP_PRIVATE : MAP_SHARED) | MAP_LOCKED, fd, 0);

if( mmap_area != MAP_FAILED )
{
/*
* Start looking for NVRAM_MAGIC at beginning of MTD
* partition. Stop if there is less than NVRAM_MIN_SPACE
* to check, that was the lowest used size.
*/
for( i = 0; i <= ((nvram_part_size - NVRAM_MIN_SPACE) / sizeof(uint32_t)); i++ )
{
if( ((uint32_t *)mmap_area)[i] == NVRAM_MAGIC )
{
offset = i * sizeof(uint32_t);
break;
}
}

if( offset < 0 )
{
munmap(mmap_area, nvram_part_size);
free(mtd);
close(fd);
return NULL;
}
else if( (h = malloc(sizeof(nvram_handle_t))) != NULL )
{
memset(h, 0, sizeof(nvram_handle_t));

h->fd     = fd;
h->mmap   = mmap_area;
h->length = nvram_part_size;
h->offset = offset;

header = nvram_header(h);

if (header->magic == NVRAM_MAGIC &&
(rdonly || header->len < h->length - h->offset)) {
_nvram_rehash(h);
free(mtd);
return h;
}
else
{
munmap(h->mmap, h->length);
free(h);
}
}
}
}

free(mtd);
close(fd);
return NULL;
}

The above function is used to open a nvram file, or create it if not yet present. When opened, it reads the header of the nvram file, which is also stored inside mtd. If there is nothing present, it creates a empty file, and the header




NEXT




<s> static int b53_mmap_remove(struct platform_device *pdev)
{
struct b53_device *dev = platform_get_drvdata(pdev);

if (dev)
b53_switch_remove(dev);

return 0;
}

The above function is used to remove the switch from the memory and unplug the peripheral devices, which are bound to the switch. The function first checks if there is a pointer to the switch device and if it is present, calls the switch removal function to remove the switch from




NEXT




<s> ret_t rtl8367c_getAsicMIBsLogCounter(rtk_uint32 index, rtk_uint32 *pCounter)
{
ret_t retVal;
rtk_uint32 regAddr;
rtk_uint32 regData;
rtk_uint32 mibAddr;
rtk_uint16 i;
rtk_uint64 mibCounter;

if(index > RTL8367C_MIB_MAX_LOG_CNT_IDX)
return RT_ERR_ENTRY_INDEX;

mibAddr = RTL8367C_MIB_LOG_CNT_OFFSET + ((index / 2) * 4);

retVal = rtl8367c_setAsicReg(RTL8367C_REG_MIB_ADDRESS, (mibAddr >> 2));
if(retVal != RT_ERR_OK)
return retVal;

/*read MIB control register*/
retVal = rtl8367c_getAsicReg(RTL8367C_MIB_CTRL_REG, &regData);
if(retVal != RT_ERR_OK)
return retVal;

if(regData & RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK)
return RT_ERR_BUSYWAIT_TIMEOUT;

if(regData & RTL8367C_RESET_FLAG_MASK)
return RT_ERR_STAT_CNTR_FAIL;

mibCounter = 0;
if((index % 2) == 1)
regAddr = RTL8367C_MIB_COUNTER_BASE_REG + 3;
else
regAddr = RTL8367C_MIB_COUNTER_BASE_REG + 1;

for(i = 0; i <= 1; i++)
{
retVal = rtl8367c_getAsicReg(regAddr, &regData);

if(retVal != RT_ERR_OK)
return retVal;

mibCounter = (mibCounter << 16) | (regData & 0xFFFF);

regAddr --;
}

*pCounter = mibCounter;
return RT_ERR_OK;
}

The above function is used to read each AsicMIBsLogCounter. The structure definition of AsicMIBsLogCounters are follow:

typedef struct
{
rtk_uint32 u32InRxOctets;
rt




NEXT




<s> u32 rtl839x_get_egress_rate(struct rtl838x_switch_priv *priv, int port)
{
u32 rate;

pr_debug("%s: Getting egress rate on port %d to %d\n", __func__, port, rate);
if (port >= priv->cpu_port)
return 0;

mutex_lock(&priv->reg_mutex);

rtl839x_read_scheduling_table(port);

rate = sw_r32(RTL839X_TBL_ACCESS_DATA_2(7));
rate <<= 12;
rate |= sw_r32(RTL839X_TBL_ACCESS_DATA_2(8)) >> 20;

mutex_unlock(&priv->reg_mutex);

return rate;
}

The above function is used to get the egress rate of particular egress port. After getting rate it calls the rtl839x_read_scheduling_table.
In this function first it checks if scheduling table has been stored. If scheduling




NEXT




<s> ret_t rtl8367c_setAsicRemarkingDot1pParameter(rtk_uint32 priority, rtk_uint32 newPriority )
{
if(priority > RTL8367C_PRIMAX || newPriority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBits(RTL8367C_QOS_1Q_REMARK_REG(priority), RTL8367C_QOS_1Q_REMARK_MASK(priority), newPriority);
}

The above function is used to set the mapping between 1Q ingress priority to egress priority.
For the original 83xx chip, 8 bits priority number are divided to 8 fields to map to egress priority.
So, each field stores one




NEXT




<s> int sata_oxnas_check_link(struct ata_port *ap)
{
int reg;

sata_oxnas_scr_read_port(ap, SCR_STATUS, &reg);
/* Check for the cable present indicated by SCR status bit-0 set */
return reg & 0x1;
}

The above function is used to check if the cable connected to port is
good.

Now I think we can change this as follows:
sata_oxnas_scr_read_port(ap, SCR_STATUS, reg);
sata_ox




NEXT




<s> AT91S_DataFlashStatus AT91F_DataFlashErase(AT91PS_DataFlash pDataFlash)
{
unsigned int page;
unsigned int status;

AT91F_SpiEnable(pDataFlash->pDevice->cs);

for(page=0; page < pDataFlash->pDevice->pages_number; page++)
{
/* Erase dataflash page */
if ((page & 0x00FF) == 0)
printf("\rERA %d/%d", page, pDataFlash->pDevice->pages_number);
status = AT91F_PageErase(pDataFlash, page);
AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_DATAFLASH_TIMEOUT);
if (!status)
return AT91C_DATAFLASH_ERROR;
}

return AT91C_DATAFLASH_OK;
}

The above function is used to erase the dataflash memory. By default, the spi chip select is mapped to AT91C_DATAFLASH_CS, if your need the other chip select, please modify the source code accordingly.

#define AT9




NEXT




<s> void rtl9300_do_rx_calibration(int sds, phy_interface_t phy_mode)
{
u32 latch_sts;

rtl9300_do_rx_calibration_1(sds, phy_mode);
rtl9300_do_rx_calibration_2(sds);
rtl9300_do_rx_calibration_4(sds);
rtl9300_do_rx_calibration_5(sds, phy_mode);
mdelay(20);

/* Do this only for 10GR mode, SDS active in mode 0x1a */
if (rtl9300_sds_field_r(sds, 0x1f, 9, 11, 7) == 0x1a) {
pr_info("%s: SDS enabled\n", __func__);
latch_sts = rtl9300_sds_field_r(sds, 0x4, 1, 2, 2);
mdelay(1);
latch_sts = rtl9300_sds_field_r(sds, 0x4, 1, 2, 2);
if (latch_sts) {
rtl9300_do_rx_calibration_dfe_disable(sds);
rtl9300_do_rx_calibration_4(sds);
rtl9300_do_rx_calibration_5(sds, phy_mode);
}
}
}

The above function is used to adjust the RTL9300 PHYs IEEE802.3 Clause45 TX
calibration value in an adaptive way to get the best result.

The RTL9300 PHYs




NEXT




<s> struct gstr str_new(void)
{
struct gstr gs;
gs.s = xmalloc(sizeof(char) * 64);
gs.len = 64;
gs.max_width = 0;
strcpy(gs.s, "\0");
return gs;
}

The above function is used to initialize the global str data type, which is used to store strings in the game. It allocates 64 bytes of memory to store the string and initializes it to “\0” (null string).

str functions are a set




NEXT




<s> ar8327_set_mirror_regs(struct ar8xxx_priv *priv)
{
int port;

/* reset all mirror registers */
ar8xxx_rmw(priv, AR8327_REG_FWD_CTRL0,
AR8327_FWD_CTRL0_MIRROR_PORT,
(0xF << AR8327_FWD_CTRL0_MIRROR_PORT_S));
for (port = 0; port < AR8327_NUM_PORTS; port++) {
ar8xxx_reg_clear(priv, AR8327_REG_PORT_LOOKUP(port),
AR8327_PORT_LOOKUP_ING_MIRROR_EN);

ar8xxx_reg_clear(priv, AR8327_REG_PORT_HOL_CTRL1(port),
AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN);
}

/* now enable mirroring if necessary */
if (priv->source_port >= AR8327_NUM_PORTS ||
priv->monitor_port >= AR8327_NUM_PORTS ||
priv->source_port == priv->monitor_port) {
return;
}

ar8xxx_rmw(priv, AR8327_REG_FWD_CTRL0,
AR8327_FWD_CTRL0_MIRROR_PORT,
(priv->monitor_port << AR8327_FWD_CTRL0_MIRROR_PORT_S));

if (priv->mirror_rx)
ar8xxx_reg_set(priv, AR8327_REG_PORT_LOOKUP(priv->source_port),
AR8327_PORT_LOOKUP_ING_MIRROR_EN);

if (priv->mirror_tx)
ar8xxx_reg_set(priv, AR8327_REG_PORT_HOL_CTRL1(priv->source_port),
AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN);
}

The above function is used to set the mirror registers as per the user input.

1. The function is provided to set the registers using the input parameters
passed
through the user option:
2. The set of mirroring registers are
– mirror_




NEXT




<s> ret_t rtl8367c_setAsicPortIsolationEfid(rtk_uint32 port, rtk_uint32 efid)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if( efid > RTL8367C_EFIDMAX)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBits(RTL8367C_PORT_EFID_REG(port), RTL8367C_PORT_EFID_MASK(port), efid);
}

The above function is used to set the asic port isolation EFID for a single port for both MDIO and CLI.

In ACL, the isolation EFID(0 ~ 255) for a port means that packets whose EFID




NEXT




<s> int aes_memory_allocate(int value);
int des_memory_allocate(int value);
void memory_release(u32 *addr);
int aes_chip_init (void);
void des_chip_init (void);
int deu_dma_init (void);
u32 endian_swap(u32 input);
u32* memory_alignment(const u8 *arg, u32 *buff_alloc, int in_out, int nbytes);
void dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);
void chip_version(void);
void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to swap endian of the word. There is no need in this board and hence this function is not used.</s>




NEXT




<s> static int clk_mt7988_sgmii1_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(ARRAY_SIZE(sgmii1_clks));

if (!clk_data)
return -ENOMEM;

mtk_clk_register_gates(node, sgmii1_clks, ARRAY_SIZE(sgmii1_clks),
clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_data;
}
return r;

free_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to probe the MT7988 SGMII1 clock domain. It sets up the clock domain’s gates and registers it as a provider with the system. Its source code can be found in arch/arm/include/mach-mt




NEXT




<s> ret_t rtl8367c_setAsicIGMPQueryRX(rtk_uint32 port, rtk_uint32 allow_query)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

/* Allow Query */
if (port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_QUERY_MASK, allow_query);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_QUERY_MASK, allow_query);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to enable/disable the IGMP Query response packet that passes through the port, if set the port doesn't reply the IGMP Query packet, if not set the port reply IGMP Query packet.

Ports can enable/




NEXT




<s> rtk_api_ret_t rtk_int_control_get(rtk_int_type_t type, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtk_uint32 mask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicInterruptMask(&mask)) != RT_ERR_OK)
return retVal;

if (0 == (mask&(1<<type)))
*pEnable=DISABLED;
else
*pEnable=ENABLED;

return RT_ERR_OK;
}

The above function is used to get the Int Control setting.
In this function, when the function returns, the pEnable is set to ENABLED or DISABLED according to the actual situation of interrupt


rtk_api_ret_t rtk_




NEXT




<s> ret_t rtl8367c_getAsicFlowControlSelect(rtk_uint32 *pSelect)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_FLOWCTRL_CTRL0, RTL8367C_FLOWCTRL_TYPE_OFFSET, pSelect);
}

The above function is used to query the type of FLOW control. However the following query is used to set and write the FLOW control command. Since there is no writeable asic register for this FLOW control command, I have tried a couple of ways to do that




NEXT




<s> int rtl9300_sds_cmu_band_get(int sds)
{
u32 page;
u32 en;
u32 cmu_band;

/*	page = rtl9300_sds_cmu_page_get(sds); */
page = 0x25; /* 10GR and 1000BX */
sds = (sds % 2) ? (sds - 1) : (sds);

rtl9300_sds_field_w(sds, page, 0x1c, 15, 15, 1);
rtl9300_sds_field_w(sds + 1, page, 0x1c, 15, 15, 1);

en = rtl9300_sds_field_r(sds, page, 27, 1, 1);
if(!en) { /* Auto mode */
rtl930x_write_sds_phy(sds, 0x1f, 0x02, 31);

cmu_band = rtl9300_sds_field_r(sds, 0x1f, 0x15, 5, 1);
} else {
cmu_band = rtl9300_sds_field_r(sds, page, 30, 4, 0);
}

return cmu_band;
}

The above function is used to determine a port's cmu-band, the parameter sds
is the sw-port number if using internal phy, or external phy number if using
external phy.

The function returns the result in cmu-




NEXT




<s> static int b53_vlan_set_ports(struct switch_dev *dev, struct switch_val *val)
{
struct b53_device *priv = sw_to_b53(dev);
struct switch_port *port;
struct b53_vlan *vlan = &priv->vlans[val->port_vlan];
int i;

/* only BCM5325 and BCM5365 supports VID 0 */
if (val->port_vlan == 0 && !is5325(priv) && !is5365(priv))
return -EINVAL;

/* VLAN 4095 needs special handling */
if (val->port_vlan == 4095 && !priv->allow_vid_4095)
return -EINVAL;

port = &val->value.ports[0];
vlan->members = 0;
vlan->untag = 0;
for (i = 0; i < val->len; i++, port++) {
vlan->members |= BIT(port->id);

if (!(port->flags & BIT(SWITCH_PORT_FLAG_TAGGED))) {
vlan->untag |= BIT(port->id);
priv->ports[port->id].pvid = val->port_vlan;
};
}

/* ignore disabled ports */
vlan->members &= priv->enabled_ports;
vlan->untag &= priv->enabled_ports;

return 0;
}

The above function is used to set/change the VLAN membership on the B53 ports. It’s called from the SWITCH_SET action handler by passing in the portid the VID to set as well as the list of ports to include/exclude




NEXT




<s> static irqreturn_t dc_ep_ppe_intr(int irq, void *dev_id)
{
struct dc_ep_dev *dev = dev_id;

ppe_irq_num++;
if (ep_rd32(MBOX_IGU0_ISR) == 0) {
pr_err("Fatal error, dummy interrupt\n");
return IRQ_NONE;
}

ep_wr32(PPE_MBOX_TEST_BIT, MBOX_IGU0_ISRC);
ep_rd32(MBOX_IGU0_ISR);
return IRQ_HANDLED;
}

The above function is used to clear the PPE_MBOX_TEST_BIT at the end of each
interruption.</s>




NEXT




<s> static void g977_get_bit_allocation(int fd, DSL_AccessDir_t direction) {
IOCTL_DIR(DSL_G997_BitAllocationNsc_t, DSL_FIO_G997_BIT_ALLOCATION_NSC_GET, direction);

// create default value to obtain consistent JSON structure
m_u32("groupsize", 1);
m_u32("groups", out.data.bitAllocationNsc.nNumData);
m_array("data", out.data.bitAllocationNsc.nNSCData, out.data.bitAllocationNsc.nNumData);
}

The above function is used to obtain the complete JSON object of group and group size of Gbit-allocation NSC.</s>




NEXT




<s> int mtd_block_is_bad(int fd, int offset)
{
int r = 0;
loff_t o = offset;

if (mtdtype == MTD_NANDFLASH)
{
r = ioctl(fd, MEMGETBADBLOCK, &o);
if (r < 0)
{
fprintf(stderr, "Failed to get erase block status\n");
exit(1);
}
}
return r;
}

The above function is used to check the erase block of the MTD (memory technology device) for wear out. This is very important for non-volatile memory devices. If you use devices such as an external memory card for a long time then there will be bad blocks




NEXT




<s> static int b53_port_get_link(struct switch_dev *dev, int port,
struct switch_port_link *link)
{
struct b53_device *priv = sw_to_b53(dev);

if (is_cpu_port(priv, port)) {
link->link = 1;
link->duplex = 1;
link->speed = is5325(priv) || is5365(priv) ?
SWITCH_PORT_SPEED_100 : SWITCH_PORT_SPEED_1000;
link->aneg = 0;
} else if (priv->enabled_ports & BIT(port)) {
u32 speed;
u16 lnk, duplex;

b53_read16(priv, B53_STAT_PAGE, B53_LINK_STAT, &lnk);
b53_read16(priv, B53_STAT_PAGE, priv->duplex_reg, &duplex);

lnk = (lnk >> port) & 1;
duplex = (duplex >> port) & 1;

if (is5325(priv) || is5365(priv)) {
u16 tmp;

b53_read16(priv, B53_STAT_PAGE, B53_SPEED_STAT, &tmp);
speed = SPEED_PORT_FE(tmp, port);
} else {
b53_read32(priv, B53_STAT_PAGE, B53_SPEED_STAT, &speed);
speed = SPEED_PORT_GE(speed, port);
}

link->link = lnk;
if (lnk) {
link->duplex = duplex;
switch (speed) {
case SPEED_STAT_10M:
link->speed = SWITCH_PORT_SPEED_10;
break;
case SPEED_STAT_100M:
link->speed = SWITCH_PORT_SPEED_100;
break;
case SPEED_STAT_1000M:
link->speed = SWITCH_PORT_SPEED_1000;
break;
}
}

link->aneg = 1;
} else {
link->link = 0;
}

return 0;

}

The above function is used to get the link state of a specified port, it is called by the switch driver and get the link state as input. If the port is the cpu port, then link status is set as 1. If it is the other ports, it reads




NEXT




<s> static int __init dc_ep_init(void)
{
pr_info("%s - version %s\n",
dc_ep_driver_string, dc_ep_driver_version);

pr_info("%s\n", dc_ep_copyright);
memset(&g_dc_ep_info, 0, sizeof(struct dc_ep_info));

if (pci_register_driver(&dc_ep_driver) < 0) {
pr_err("%s: No devices found, driver not installed.\n",
__func__);
return -ENODEV;
}
return 0;
}

The above function is used to register the driver and PCI device ID to
kernel. When no DC EP chip of the specified chip version is found, the
driver will not be registered. In this case, we print the driver string
and copyright to the kernel log messages and




NEXT




<s> srg_led_init_led(struct srg_led_ctrl *sysled_ctrl, struct device_node *np)
{
struct led_init_data init_data = {};
struct led_classdev *led_cdev;
struct srg_led *sysled;
int index, ret;

if (!np)
return -ENOENT;

ret = of_property_read_u32(np, "reg", &index);
if (ret) {
dev_err(&sysled_ctrl->client->dev,
"srg_led_init_led: no reg defined in np!\n");
return ret;
}

if (index < 1 || index > 4)
return -EINVAL;

sysled = &sysled_ctrl->channel[index - 1];
led_cdev = &sysled->led;

sysled->index = index;
sysled->ctrl = sysled_ctrl;

init_data.fwnode = of_fwnode_handle(np);

led_cdev->name = of_get_property(np, "label", NULL) ? : np->name;
led_cdev->brightness = LED_OFF;
led_cdev->max_brightness = LED_FULL;
led_cdev->brightness_set_blocking = srg_led_set_brightness;
led_cdev->blink_set = srg_led_set_pulse;

srg_led_i2c_write(sysled_ctrl, index + 4, 0);

ret = devm_led_classdev_register_ext(&sysled_ctrl->client->dev,
led_cdev, &init_data);
if (ret) {
dev_err(&sysled_ctrl->client->dev,
"srg_led_init_led: led register %s error ret %d!n",
led_cdev->name, ret);
return ret;
}

return 0;
}

The above function is used to initialize the system status indicator led,
and its control flow is as follows, step by step analysis:

Check if the system has no led control.
Allocate memeory for sysled and sysled_ctrl, and initialize it




NEXT




<s> MD5_end(void *resbuf, MD5_CTX *ctx)
{
unsigned char *result = resbuf;
unsigned long used, available;

used = ctx->lo & 0x3f;

ctx->buffer[used++] = 0x80;

available = 64 - used;

if (available < 8) {
memset(&ctx->buffer[used], 0, available);
MD5_body(ctx, ctx->buffer, 64);
used = 0;
available = 64;
}

memset(&ctx->buffer[used], 0, available - 8);

ctx->lo <<= 3;
ctx->buffer[56] = ctx->lo;
ctx->buffer[57] = ctx->lo >> 8;
ctx->buffer[58] = ctx->lo >> 16;
ctx->buffer[59] = ctx->lo >> 24;
ctx->buffer[60] = ctx->hi;
ctx->buffer[61] = ctx->hi >> 8;
ctx->buffer[62] = ctx->hi >> 16;
ctx->buffer[63] = ctx->hi >> 24;

MD5_body(ctx, ctx->buffer, 64);

result[0] = ctx->a;
result[1] = ctx->a >> 8;
result[2] = ctx->a >> 16;
result[3] = ctx->a >> 24;
result[4] = ctx->b;
result[5] = ctx->b >> 8;
result[6] = ctx->b >> 16;
result[7] = ctx->b >> 24;
result[8] = ctx->c;
result[9] = ctx->c >> 8;
result[10] = ctx->c >> 16;
result[11] = ctx->c >> 24;
result[12] = ctx->d;
result[13] = ctx->d >> 8;
result[14] = ctx->d >> 16;
result[15] = ctx->d >> 24;

memset(ctx, 0, sizeof(*ctx));
}

The above function is used to calculate all the MD5 checksum that
is used for various crypto and authentication processes. The
function is used by various processes which need a checksum. It
calculates a checksum if the given MD5 context is given with





NEXT




<s> static void rtl8367b_switch_cleanup(struct rtl8366_smi *smi)
{
unregister_switch(&smi->sw_dev);
}

The above function is used to clean up resources allocated by rtl8367b_switch_alloc_resources()
and it’s called in 2 situations:

1. When a switch resource is freed:

struct sw_resource *sw_




NEXT




<s> static u32 jffs2_dirent_crc(struct jffs2_raw_dirent *node)
{
return crc32(0, node, sizeof(struct jffs2_raw_dirent) - 8);
}

The above function is used to compute the crc of a JFFS2 dirent structure that is not padded out to align to a word boundary.

The testcase is a jffs2 filesystem on /dev/mtdblk8, which should




NEXT




<s> ar8xxx_create(void)
{
struct ar8xxx_priv *priv;

priv = kzalloc(sizeof(struct ar8xxx_priv), GFP_KERNEL);
if (priv == NULL)
return NULL;

mutex_init(&priv->reg_mutex);
mutex_init(&priv->mib_lock);
INIT_DELAYED_WORK(&priv->mib_work, ar8xxx_mib_work_func);

return priv;
}

The above function is used to dynamically create an ar8xxx_priv structure. The kzalloc() function is used to allocate memory for the structure. If there is no memory available, the return NULL will indicate that there was an error. Otherwise, initilaze the




NEXT




<s> static int b53_port_get_stats(struct switch_dev *sw_dev, int port,
struct switch_port_stats *stats)
{
struct b53_device *dev = sw_to_b53(sw_dev);
const struct b53_mib_desc *mibs;
int txb_id, rxb_id;
u64 rxb, txb;

if (!(BIT(port) & dev->enabled_ports))
return -EINVAL;

txb_id = B53XX_MIB_TXB_ID;
rxb_id = B53XX_MIB_RXB_ID;

if (is5365(dev)) {
if (port == 5)
port = 8;

mibs = b53_mibs_65;
} else if (is63xx(dev)) {
mibs = b53_mibs_63xx;
txb_id = B63XX_MIB_TXB_ID;
rxb_id = B63XX_MIB_RXB_ID;
} else {
mibs = b53_mibs;
}

dev->buf[0] = 0;

if (mibs->size == 8) {
b53_read64(dev, B53_MIB_PAGE(port), mibs[txb_id].offset, &txb);
b53_read64(dev, B53_MIB_PAGE(port), mibs[rxb_id].offset, &rxb);
} else {
u32 val32;

b53_read32(dev, B53_MIB_PAGE(port), mibs[txb_id].offset, &val32);
txb = val32;

b53_read32(dev, B53_MIB_PAGE(port), mibs[rxb_id].offset, &val32);
rxb = val32;
}

stats->tx_bytes = txb;
stats->rx_bytes = rxb;

return 0;
}

The above function is used to read the port status from the port control processor (PCP) of Barefoot Networks’ Tofino switching chip. In this function, tlb_id represents the table lookup buffer identifier (0: Tx bytes, 1:




NEXT




<s> static int rtl8367b_extif_set_force(struct rtl8366_smi *smi, int id,
struct rtl8367_port_ability *pa)
{
u32 mask;
u32 val;
int err;

mask = (RTL8367B_DI_FORCE_MODE |
RTL8367B_DI_FORCE_NWAY |
RTL8367B_DI_FORCE_TXPAUSE |
RTL8367B_DI_FORCE_RXPAUSE |
RTL8367B_DI_FORCE_LINK |
RTL8367B_DI_FORCE_DUPLEX |
RTL8367B_DI_FORCE_SPEED_MASK);

val = pa->speed;
val |= pa->force_mode ? RTL8367B_DI_FORCE_MODE : 0;
val |= pa->nway ? RTL8367B_DI_FORCE_NWAY : 0;
val |= pa->txpause ? RTL8367B_DI_FORCE_TXPAUSE : 0;
val |= pa->rxpause ? RTL8367B_DI_FORCE_RXPAUSE : 0;
val |= pa->link ? RTL8367B_DI_FORCE_LINK : 0;
val |= pa->duplex ? RTL8367B_DI_FORCE_DUPLEX : 0;

REG_RMW(smi, RTL8367B_DI_FORCE_REG(id), mask, val);

return 0;
}

The above function is used to set the PHY forcing bits used to control the
negotiated state to be more aggressive. The function should return 0 on
success.

It's interesting to note:

• The RTL8366 and




NEXT




<s> void Uart16550Init(uint32 baud, uint8 data, uint8 parity, uint8 stop)
{
/* disable interrupts */
UART16550_WRITE(OFS_INTR_ENABLE, 0);

/* set up buad rate */
{
uint32 divisor;

/* set DIAB bit */
UART16550_WRITE(OFS_LINE_CONTROL, 0x80);

/* set divisor */
divisor = MAX_BAUD / baud;
UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);
UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00)>>8);

/* clear DIAB bit */
UART16550_WRITE(OFS_LINE_CONTROL, 0x0);
}

/* set data format */
UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);
}

The above function is used to initialize 16550 serial UART peripheral at the beginning of the program. To use the terminal,

```c
static void uart2_tx_chars(char *str)
{
    volatile uint




NEXT




<s> uc_hostapd_iface_set_bss_order(uc_vm_t *vm, size_t nargs)
{
struct hostapd_iface *iface = uc_fn_thisval("hostapd.iface");
uc_value_t *bss_list = uc_fn_arg(0);
struct hostapd_data **new_bss;
struct hostapd_bss_config **new_conf;

if (!iface)
return NULL;

if (ucv_type(bss_list) != UC_ARRAY ||
ucv_array_length(bss_list) != iface->num_bss)
return NULL;

new_bss = calloc(iface->num_bss, sizeof(*new_bss));
new_conf = calloc(iface->num_bss, sizeof(*new_conf));
for (size_t i = 0; i < iface->num_bss; i++) {
struct hostapd_data *bss;

bss = ucv_resource_data(ucv_array_get(bss_list, i), "hostapd.bss");
if (bss->iface != iface)
goto free;

for (size_t k = 0; k < i; k++)
if (new_bss[k] == bss)
goto free;

new_bss[i] = bss;
new_conf[i] = bss->conf;
}

new_bss[0]->interface_added = 0;
for (size_t i = 1; i < iface->num_bss; i++)
new_bss[i]->interface_added = 1;

free(iface->bss);
iface->bss = new_bss;

free(iface->conf->bss);
iface->conf->bss = new_conf;
iface->conf->num_bss = iface->num_bss;
hostapd_drv_set_first_bss(iface->bss[0]);

return ucv_boolean_new(true);

free:
free(new_bss);
free(new_conf);
return NULL;
}

The above function is used to re-order the bss order. it has been called with the bss_list like [1, 0, 2] meaning bss3 should be the primary bss and the other bsses should be after it.





NEXT




<s> static ssize_t msdc_debug_proc_write(struct file *file,
const char __user *buf, size_t count, loff_t *data)
{
int ret;

int cmd, p1, p2;
int id, zone;
int mode, size;

if (count == 0)
return -1;
if (count > 255)
count = 255;

if (copy_from_user(cmd_buf, buf, count))
return -EFAULT;

cmd_buf[count] = '\0';
printk("msdc Write %s\n", cmd_buf);

sscanf(cmd_buf, "%x %x %x", &cmd, &p1, &p2);

if (cmd == SD_TOOL_ZONE) {
id = p1;
zone = p2;
zone &= 0x3ff;
printk("msdc host_id<%d> zone<0x%.8x>\n", id, zone);
if (id >= 0 && id <= 3) {
sd_debug_zone[id] = zone;
} else if (id == 4) {
sd_debug_zone[0] = sd_debug_zone[1] = zone;
sd_debug_zone[2] = sd_debug_zone[3] = zone;
} else {
printk("msdc host_id error when set debug zone\n");
}
} else if (cmd == SD_TOOL_SDIO_PROFILE) {
if (p1 == 1) { /* enable profile */
if (gpt_enable == 0) {
// msdc_init_gpt(); /* --- by chhung */
gpt_enable = 1;
}
sdio_pro_enable = 1;
if (p2 == 0)
p2 = 1;
if (p2 >= 30)
p2 = 30;
sdio_pro_time = p2;
} else if (p1 == 0) {
/* todo */
sdio_pro_enable = 0;
}
}

return count;
}

The above function is used to write data to proc file, just check it. As for how to use the function, I just copy the sample from linux kernel.</s>




NEXT




<s> rtk_api_ret_t rtk_rldp_portConfig_set(rtk_port_t port, rtk_rldp_portConfig_t *pPortConfig)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk;
rtk_uint32 phy_port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (pPortConfig->tx_enable>= RTK_ENABLE_END)
return RT_ERR_INPUT;

phy_port = rtk_switch_port_L2P_get(port);

if ((retVal = rtl8367c_getAsicRldpTxPortmask(&pmsk))!=RT_ERR_OK)
return retVal;

if (pPortConfig->tx_enable)
{
pmsk |=(1<<phy_port);
}
else
{
pmsk &= ~(1<<phy_port);
}

if ((retVal = rtl8367c_setAsicRldpTxPortmask(pmsk))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;

} /* end of rtk_rldp_portConfig_set */

The above function is used to enable/disable tx of a port.

The user can find rtk_rldp_port_t data type definition and the function header documentation in the following reference documents:

* Header file documentation: /docs/apid




NEXT




<s> static int aes_setkey(struct crypto_ablkcipher *tfm, const u8 *in_key,
unsigned int keylen)
{
struct aes_ctx *ctx = crypto_ablkcipher_ctx(tfm);
unsigned long *flags = (unsigned long *) &tfm->base.crt_flags;

DPRINTF(2, "set_key in %s\n", __FILE__);

if (keylen != 16 && keylen != 24 && keylen != 32) {
*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
return -EINVAL;
}

ctx->key_length = keylen;
DPRINTF(0, "ctx @%p, keylen %d, ctx->key_length %d\n", ctx, keylen, ctx->key_length);
memcpy ((u8 *) (ctx->buf), in_key, keylen);

return 0;

}

The above function is used to call AES with the given key, iv and a ciphertext.
If all goes right, the returned buffer contains the decrypted plaintext, but if not
then a bad ciphertext error may result instead.

As before




NEXT




<s> const char *menu_get_prompt(struct menu *menu)
{
if (menu->prompt)
return menu->prompt->text;
else if (menu->sym)
return menu->sym->name;
return NULL;
}

The above function is used to get the prompt text of menu item of certain menu structure.
This is very useful when we want to use an API of ncurses to make cursor visible on screen.


// Here's a sample code where we're printing




NEXT




<s> static int block_load_image_raw_os(block_dev_desc_t * device)
{
int n;

n = device->block_read(device->dev, CONFIG_SYS_BLOCK_RAW_MODE_ARGS_SECTOR,
CONFIG_SYS_BLOCK_RAW_MODE_ARGS_SECTORS,
(u32 *)CONFIG_SYS_SPL_ARGS_ADDR);
/* flush cache after read */
flush_cache(addr, CONFIG_SYS_BLOCK_RAW_MODE_ARGS_SECTORS * 512);

if (n != CONFIG_SYS_BLOCK_RAW_MODE_ARGS_SECTORS) {
printf("args blk read error\n");
return -1;
}

return block_load_image_raw(device, CONFIG_SYS_BLOCK_RAW_MODE_KERNEL_SECTOR);
}

The above function is used to load linux kernel. It will call
CONFIG_SYS_BLOCK_RAW_MODE_ARGS_KERNEL_SECTOR
to make sure the kernel image is loaded, then load other parameters
into CONFIG_SYS_SPL_ARGS




NEXT




<s> static int gpio_keys_remove(struct platform_device *pdev)
{
struct gpio_keys_button_dev *bdev = platform_get_drvdata(pdev);

platform_set_drvdata(pdev, NULL);

if (bdev->polled)
gpio_keys_polled_close(bdev);
else
gpio_keys_irq_close(bdev);

return 0;
}

The above function is used to remove from the platform. However, if someone calls this function directly, it will result in a race condition because bdev is already NULL. To get around this I add a static int bdev_flag; then change polled_close and irq




NEXT




<s> static int ar934x_nfc_read_page_raw(
struct nand_chip *chip, u8 *buf,
int oob_required, int page)
{
struct ar934x_nfc *nfc = chip->priv;
struct mtd_info *mtd = ar934x_nfc_to_mtd(nfc);
int len;
int err;

nfc_dbg(nfc, "read_page_raw: page:%d oob:%d\n", page, oob_required);

len = mtd->writesize;
if (oob_required)
len += mtd->oobsize;

err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, 0, page, len);
if (err)
return err;

memcpy(buf, nfc->buf, mtd->writesize);

if (oob_required)
memcpy(chip->oob_poi, &nfc->buf[mtd->writesize], mtd->oobsize);

return 0;
}

The above function is used to read pages after a badblock, which returns page size buffer. We can just store buffer address to be used in fuzzer later. We can just use the following to write data in an array into the memory of the chip:

static




NEXT




<s> static void rtk_hal_clear_table(void)
{
rtk_api_ret_t ret;

ret = rtk_l2_table_clear();
if (ret != RT_ERR_OK)
printk("rtk_l2_table_clear failed\n");
}

The above function is used to flush the L2 MAC entry from the CAM table
and only it is used before using rtk API for L2 or MAC entry
configurations/modifications. Please take a note here
that rtk_l2_table_




NEXT




<s> static void __init hiveap_330_setup_arch(void)
{
if (ppc_md.progress)
ppc_md.progress("hiveap_330_setup_arch()", 0);

mpc85xx_smp_init();

fsl_pci_assign_primary();

printk(KERN_INFO "HiveAP-330 board from Aerohive\n");
}

The above function is used to initialize and setup system for booting. It is called by ppc_generic_setup(), which is called by main.c during early initialization.

If ppc_md.progress is NULL, or 0 is passed to the progress




NEXT




<s> static int nmbm_mark_phys_bad_block(struct nmbm_instance *ni, uint32_t ba)
{
uint64_t addr = ba2addr(ni, ba);

nlog_info(ni, "Block %u [0x%08llx] will be marked bad\n", ba, addr);

return bmtd._block_markbad(bmtd.mtd, addr);
}

The above function is used to mark some bad blocks on nand flash. nmbm_mark_phys_bad_block is declared in nand.c, the block marking bad is implemented in bmtd.c.</s>




NEXT




<s> static void rtl931x_l2_learning_setup(void)
{
/* Portmask for flooding broadcast traffic */
rtl839x_set_port_reg_be(0x1FFFFFFFFFFFFFF, RTL931X_L2_BC_FLD_PMSK);

/* Portmask for flooding unicast traffic with unknown destination */
rtl839x_set_port_reg_be(0x1FFFFFFFFFFFFFF, RTL931X_L2_UNKN_UC_FLD_PMSK);

/* Limit learning to maximum: 64k entries, after that just flood (bits 0-2) */
sw_w32((0xffff << 3) | FORWARD, RTL931X_L2_LRN_CONSTRT_CTRL);
}

The above function is used to setup the learning function in RTL831x switch. If a switch is port is enabled for flood mode and the destination entry does not exist, a packet will be flooded out all ports except the incoming port and the broadcast port. But




NEXT




<s> static int msp430_pattern_set(struct led_classdev *led_cdev,
struct led_pattern *pattern,
u32 len, int repeat)
{
struct msp430_led *led =
container_of(led_cdev, struct msp430_led, cdev);
u8 tx[MSP430_CMD_BYTES] = {led->id, 0, 0, 0, 0, 0};
u8 rx[MSP430_CMD_BYTES];
unsigned long delay0;
unsigned long delay1;
int rc;

if (len != 2 ||
repeat > MSP430_LED_REPEAT_MAX ||
pattern[0].delta_t > MSP430_LED_BLINK_MAX ||
pattern[1].delta_t > MSP430_LED_BLINK_MAX)
return -EINVAL;

delay0 = msp430_blink_delay(pattern[0].delta_t);
delay1 = msp430_blink_delay(pattern[1].delta_t);

/* Infinite pattern */
if (repeat < 0)
repeat = 0;

/* Pulse: <off> <delay> <max> <delay> */
if (delay0 == delay1 &&
pattern[0].brightness == LED_OFF &&
pattern[1].brightness == MSP430_LED_BRIGHTNESS_MAX)
{
tx[1] = MSP430_LED_PULSE;
tx[2] = delay0;
tx[4] = (u8) repeat;
}

/* Pulse On: <off> <delay> <max> <0ms> */
if (pattern[0].delta_t != 0 &&
pattern[1].delta_t == 0 &&
pattern[0].brightness == LED_OFF &&
pattern[1].brightness == MSP430_LED_BRIGHTNESS_MAX) {
tx[1] = MSP430_LED_PULSE_ON;
tx[2] = delay0;
tx[4] = (u8) repeat;
}

/* Pulse Off: <max> <delay> <off> <0ms> */
if (pattern[0].delta_t != 0 &&
pattern[1].delta_t == 0 &&
pattern[0].brightness == MSP430_LED_BRIGHTNESS_MAX &&
pattern[1].brightness == LED_OFF) {
tx[1] = MSP430_LED_PULSE_OFF;
tx[2] = delay0;
tx[4] = (u8) repeat;
}

if (!tx[1])
return -EINVAL;

rc = msp430_cmd(led->spi, tx, rx);
if (rc)
return rc;

return 0;
}

The above function is used to set a blink pattern.  In addition we have to write a pattern handler to deal with the incoming patterns from the kernel.

// msp430-led.cpp
void msp430_led::pattern_response




NEXT




<s> rtk_api_ret_t rtk_svlan_trapPri_get(rtk_pri_t *pPriority)
{
rtk_api_ret_t   retVal;

RTK_CHK_INIT_STATE();

if(NULL == pPriority)
return RT_ERR_NULL_POINTER;

retVal = rtl8367c_getAsicSvlanTrapPriority(pPriority);

return retVal;
}   /* end of rtk_svlan_trapPri_get */

The above function is used to get the SVLAN trap priority.</s>




NEXT




<s> static struct symbol *sym_calc_choice(struct symbol *sym)
{
struct symbol *def_sym;
struct property *prop;
struct expr *e;
int flags;

/* first calculate all choice values' visibilities */
flags = sym->flags;
prop = sym_get_choice_prop(sym);
expr_list_for_each_sym(prop->expr, e, def_sym) {
sym_calc_visibility(def_sym);
if (def_sym->visible != no)
flags &= def_sym->flags;
}

sym->flags &= flags | ~SYMBOL_DEF_USER;

/* is the user choice visible? */
def_sym = sym->def[S_DEF_USER].val;
if (def_sym && def_sym->visible != no)
return def_sym;

def_sym = sym_choice_default(sym);

if (def_sym == NULL)
/* no choice? reset tristate value */
sym->curr.tri = no;

return def_sym;
}

The above function is used to calculate the state of a choice (if only one value is active then it takes it).


static struct attr_instance *attr_instance_get_new(void)
struct attr_instance *ai;

ai = m




NEXT




<s> static void aes_gcm_exit_tfm(struct crypto_tfm *tfm)
{
struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
if (ctx->gf128) gf128mul_free_4k(ctx->gf128);
}

The above function is used to free the gf128 table used in AES GCM.
The code looks pretty straight forward.

However, in the function the pointer “ctx->gf128” is NULL.

So, what is




NEXT




<s> ret_t rtl8367c_setAsicIGMPv3Opeartion(rtk_uint32 port, rtk_uint32 igmpv3_op)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(igmpv3_op >= PROTOCOL_OP_END)
return RT_ERR_INPUT;

/* IGMPv3 operation */
if(port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV3_OP_MASK, igmpv3_op);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV3_OP_MASK, igmpv3_op);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set Asic IGMPv3 operation.

return retVal = rtl8367c_setAsicRegBits(REG_IGMP_PORT1_CONTROL + port, REG_IGMP_PORT1_




NEXT




<s> static int rtl8366_set_vlan(struct rtl8366_smi *smi, int vid, u32 member,
u32 untag, u32 fid)
{
struct rtl8366_vlan_4k vlan4k;
int err;
int i;

/* Update the 4K table */
err = smi->ops->get_vlan_4k(smi, vid, &vlan4k);
if (err)
return err;

vlan4k.member = member;
vlan4k.untag = untag;
vlan4k.fid = fid;
err = smi->ops->set_vlan_4k(smi, &vlan4k);
if (err)
return err;

/* Try to find an existing MC entry for this VID */
for (i = 0; i < smi->num_vlan_mc; i++) {
struct rtl8366_vlan_mc vlanmc;

err = smi->ops->get_vlan_mc(smi, i, &vlanmc);
if (err)
return err;

if (vid == vlanmc.vid) {
/* update the MC entry */
vlanmc.member = member;
vlanmc.untag = untag;
vlanmc.fid = fid;

err = smi->ops->set_vlan_mc(smi, i, &vlanmc);
break;
}
}

return err;
}

The above function is used to setup the VLANs on an RTL8366. If the VLAN is a 1532, then the function “get_vlan_4k” is called to find the Vlan4k and “set




NEXT




<s> rtk_api_ret_t rtk_port_phyReg_set(rtk_port_t port, rtk_port_phy_reg_t reg, rtk_port_phy_data_t regData)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), reg, regData)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set specific register content at specified address belonging to current UTP port physical PHY. The register data is in little-endian and data length is set by the register's data field width.

Parameters
port : Specify which 




NEXT




<s> void hostapd_ubus_handle_link_measurement(struct hostapd_data *hapd, const u8 *data, size_t len)
{
const struct ieee80211_mgmt *mgmt = (const struct ieee80211_mgmt *) data;
const u8 *pos, *end;
u8 token;

end = data + len;
token = mgmt->u.action.u.rrm.dialog_token;
pos = mgmt->u.action.u.rrm.variable;

if (end - pos < 8)
return;

if (!hapd->ubus.obj.has_subscribers)
return;

blob_buf_init(&b, 0);
blobmsg_add_macaddr(&b, "address", mgmt->sa);
blobmsg_add_u16(&b, "dialog-token", token);
blobmsg_add_u16(&b, "rx-antenna-id", pos[4]);
blobmsg_add_u16(&b, "tx-antenna-id", pos[5]);
blobmsg_add_u16(&b, "rcpi", pos[6]);
blobmsg_add_u16(&b, "rsni", pos[7]);

ubus_notify(ctx, &hapd->ubus.obj, "link-measurement-report", b.head, -1);
}

The above function is used to receive link measurement report uAPI messages.</s>




NEXT




<s> uc_hostapd_disable_iface(struct hostapd_iface *iface)
{
switch (iface->state) {
case HAPD_IFACE_DISABLED:
break;
#ifdef CONFIG_ACS
case HAPD_IFACE_ACS:
acs_cleanup(iface);
iface->scan_cb = NULL;
/* fallthrough */
#endif
default:
hostapd_disable_iface(iface);
break;
}
}

The above function is used to disable an interface in hostapd. This function
is used to ensure that a interface is first disabled before it is being
unloaded. This prevents interfaces from being unloaded without taking care of
cleaning up the data structures related to




NEXT




<s> static void sha1_hmac_exit_tfm(struct crypto_tfm *tfm)
{
struct sha1_hmac_ctx *sctx = crypto_tfm_ctx(tfm);
kfree(sctx->temp);
kfree(sctx->desc);
}

The above function is used to free resources when a "hash" operation does not end with "hmac" operation for a particular transformation. "tfm" is the crypto_tfm data structure which gets populated by crypto subsystem and passed to the transform callback function for




NEXT




<s> void ifx_deu_aes_ctr (void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
ifx_deu_aes (ctx, dst, src, iv, nbytes, encdec, 4);
}

The above function is used to compute aes-ctr. To compute aes in a stream of
1, 2, 3, \ldots , n bytes, we simply invoke 'ifx_deu_aes_ctr()', multiple
times, providing




NEXT




<s> static int aw9523_init_irq(struct aw9523 *awi, int irq)
{
struct device *dev = awi->dev;
struct gpio_irq_chip *gpioirq;
struct irq_chip *irqchip;
int ret;

if (!device_property_read_bool(dev, "interrupt-controller"))
return 0;

irqchip = devm_kzalloc(dev, sizeof(*irqchip), GFP_KERNEL);
if (!irqchip)
return -ENOMEM;

awi->irq = devm_kzalloc(dev, sizeof(*awi->irq), GFP_KERNEL);
if (!awi->irq)
return -ENOMEM;

irqchip->name = devm_kstrdup(dev, dev_name(dev), GFP_KERNEL);
if (!irqchip->name)
return -ENOMEM;

irqchip->irq_mask = aw9523_irq_mask;
irqchip->irq_unmask = aw9523_irq_unmask;
irqchip->irq_bus_lock = aw9523_irq_bus_lock;
irqchip->irq_bus_sync_unlock = aw9523_irq_bus_sync_unlock;
irqchip->irq_set_type = aw9523_gpio_irq_type;
awi->irq->irqchip = irqchip;
mutex_init(&awi->irq->lock);

ret = devm_request_threaded_irq(dev, irq, NULL, aw9523_irq_thread_func,
IRQF_ONESHOT, dev_name(dev), awi);
if (ret) {
dev_err(dev, "Failed to request irq %d\n", irq);
return ret;
}

gpioirq = &awi->gpio.irq;
gpioirq->chip = irqchip;
gpioirq->parent_handler = NULL;
gpioirq->num_parents = 0;
gpioirq->parents = NULL;
gpioirq->default_type = IRQ_TYPE_LEVEL_MASK;
gpioirq->handler = handle_simple_irq;
gpioirq->threaded = true;
gpioirq->first = 0;

return 0;
}

The above function is used to initialize a threaded IRQ chip.</s>




NEXT




<s> ar8327_get_port_igmp(struct ar8xxx_priv *priv, int port)
{
u32 fwd_ctrl, frame_ack;

fwd_ctrl = (BIT(port) << AR8327_FWD_CTRL1_IGMP_S);
frame_ack = ((AR8327_FRAME_ACK_CTRL_IGMP_MLD |
AR8327_FRAME_ACK_CTRL_IGMP_JOIN |
AR8327_FRAME_ACK_CTRL_IGMP_LEAVE) <<
AR8327_FRAME_ACK_CTRL_S(port));

return (ar8xxx_read(priv, AR8327_REG_FWD_CTRL1) &
fwd_ctrl) == fwd_ctrl &&
(ar8xxx_read(priv, AR8327_REG_FRAME_ACK_CTRL(port)) &
frame_ack) == frame_ack;
}

The above function is used to check whether ports are set as IGMP snooping switch. We've mentioned in the previous post that the AR8327 chip has to be set-up to forward multicast traffic to ports configured as IGMP s




NEXT




<s> static void esw_reset_ephy(struct rt305x_esw *esw)
{
if (!esw->rst_ephy)
return;

reset_control_assert(esw->rst_ephy);
usleep_range(60, 120);
reset_control_deassert(esw->rst_ephy);
usleep_range(60, 120);
}

The above function is used to reset the ephy. It will be called by the driver when the ephy-link state is changed from
TX or RX or FW to LINKUP. On a fresh boot of the device, the ephy-link state is




NEXT




<s> ret_t rtl8367c_getAsicMIBsLoggingMode(rtk_uint32 index, rtk_uint32* pMode)
{
if(index > RTL8367C_MIB_MAX_LOG_MODE_IDX)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_CTRL3, index,pMode);
}

The above function is used to get the MIB logging mode of a certain register. If the register is not configured to be logged or the index is larger than the limit, the error code will be RTVR_ERR_OUT_OF_RANGE, which will be mapped




NEXT




<s> static int fe_hw_init(struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);
int i, err;

err = devm_request_irq(priv->dev, dev->irq, fe_handle_irq, 0,
dev_name(priv->dev), dev);
if (err)
return err;

if (priv->soc->set_mac)
priv->soc->set_mac(priv, dev->dev_addr);
else
fe_hw_set_macaddr(priv, dev->dev_addr);

/* disable delay interrupt */
fe_reg_w32(0, FE_REG_DLY_INT_CFG);

fe_int_disable(priv->soc->tx_int | priv->soc->rx_int);

/* frame engine will push VLAN tag regarding to VIDX feild in Tx desc */
if (fe_reg_table[FE_REG_FE_DMA_VID_BASE])
for (i = 0; i < 16; i += 2)
fe_w32(((i + 1) << 16) + i,
fe_reg_table[FE_REG_FE_DMA_VID_BASE] +
(i * 2));

if (priv->soc->fwd_config(priv))
netdev_err(dev, "unable to get clock\n");

if (fe_reg_table[FE_REG_FE_RST_GL]) {
fe_reg_w32(1, FE_REG_FE_RST_GL);
fe_reg_w32(0, FE_REG_FE_RST_GL);
}

return 0;
}

The above function is used to create the NIC from scratch.

This NIC is a single chip device which is responsible for MAC/DMA layers. The interrupt of the NIC can be generated when tx/rx descriptors run out or frame is received. To handle




NEXT




<s> static ssize_t sc_tag_store_bootdelays(const u8 *pld, u16 pld_len, const char *buf, size_t count)
{
u32 data;	// cpu-endian
int ret;

if (sizeof(data) != pld_len)
return -EINVAL;

ret = kstrtou32(buf, 10, &data);
if (ret)
return ret;

if ((data < RB_BOOT_DELAY_MIN) || (RB_BOOT_DELAY_MAX < data))
return -EINVAL;

write_lock(&sc_bufrwl);
*(u32 *)pld = data;		// pld aliases sc_buf
RB_SC_CLRCRC();
write_unlock(&sc_bufrwl);

return count;
}

The above function is used to set the boot delays for the SC module. It takes the buffer which is sent by LM to SC and checks if the value lies in the range 5ms to 500ms to prevent an out of range error where the L




NEXT




<s> ret_t rtl8367c_setAsicSvlanMemberConfiguration(rtk_uint32 index, rtl8367c_svlan_memconf_t* pSvlanMemCfg)
{
ret_t retVal;
rtk_uint32 regAddr, regData;
rtk_uint16 *accessPtr;
rtk_uint32 i;
rtk_uint16 smiSvlanMemConf[RTL8367C_SVLAN_MEMCONF_LEN];

if(index > RTL8367C_SVIDXMAX)
return RT_ERR_SVLAN_ENTRY_INDEX;

memset(smiSvlanMemConf, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_MEMCONF_LEN);
_rtl8367c_svlanConfStUser2Smi(pSvlanMemCfg, smiSvlanMemConf);

accessPtr = smiSvlanMemConf;

regData = *accessPtr;
for(i = 0; i < 3; i++)
{
retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_MEMBERCFG_BASE_REG(index) + i, regData);
if(retVal != RT_ERR_OK)
return retVal;

accessPtr ++;
regData = *accessPtr;
}

if(index < 63)
regAddr = RTL8367C_REG_SVLAN_MEMBERCFG0_CTRL4+index;
else if(index == 63)
regAddr = RTL8367C_REG_SVLAN_MEMBERCFG63_CTRL4;

retVal = rtl8367c_setAsicReg(regAddr, regData);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;

}

The above function is used to change the svlan configuration. As the function name implies, svlan_conf is used to configure the svlan entry. The parameter _svlanConf is an structure with the following parameter. svlan_conf is used to change the configuration of




NEXT




<s> ar8216_read_port_status(struct ar8xxx_priv *priv, int port)
{
return ar8xxx_read(priv, AR8216_REG_PORT_STATUS(port));
}

The above function is used to read the status of a specific port. But
it always returns port 7, no matter which parameter is put into it.
Because this function is only used in a local context when a device is
registered (it is not a hot




NEXT




<s> u64 rtl838x_traffic_get(int source)
{
return rtl838x_get_port_reg(rtl838x_port_iso_ctrl(source));
}

The above function is used to fetch the traffic, it’s a direct port of a function in linux rtl838x driver that get the traffic of a interface:

u32 bmac_traffic_get(struct sk_buff *skb




NEXT




<s> static int clk_mt7981_topckgen_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;
int nr = ARRAY_SIZE(top_divs) + ARRAY_SIZE(top_muxes) +
ARRAY_SIZE(top_aud_divs);

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(nr);
if (!clk_data)
return -ENOMEM;

mtk_clk_register_factors(top_divs, ARRAY_SIZE(top_divs), clk_data);
mtk_clk_register_muxes(top_muxes, ARRAY_SIZE(top_muxes), node,
&mt7981_clk_lock, clk_data);
mtk_clk_register_composites(top_aud_divs, ARRAY_SIZE(top_aud_divs), base,
&mt7981_clk_lock, clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);

if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_topckgen_data;
}
return r;

free_topckgen_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to register clk, and there are two ways to register.
The first is as follows:
r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);

The second




NEXT




<s> int xts_aes_decrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int dec_bytes, nbytes, processed;

err = skcipher_walk_virt(&walk, req, false);

if (req->cryptlen < XTS_BLOCK_SIZE)
return -EINVAL;

ctx->use_tweak = 1;
aes_encrypt(req->base.tfm, walk.iv, walk.iv);
ctx->use_tweak = 0;
processed = 0;

while ((nbytes = walk.nbytes) && (walk.nbytes >= (XTS_BLOCK_SIZE * 2))) {
u8 *iv = walk.iv;
if (nbytes == walk.total) {
dec_bytes = nbytes;
} else {
dec_bytes = nbytes & ~(XTS_BLOCK_SIZE - 1);
if ((req->cryptlen - processed - dec_bytes) < (XTS_BLOCK_SIZE)) {
if (dec_bytes > (2 * XTS_BLOCK_SIZE)) {
dec_bytes -= XTS_BLOCK_SIZE;
} else {
break;
}
}
}
ifx_deu_aes_xts(ctx, walk.dst.virt.addr, walk.src.virt.addr,
iv, dec_bytes, CRYPTO_DIR_DECRYPT);
err = skcipher_walk_done(&walk, nbytes - dec_bytes);
processed += dec_bytes;
}

if ((walk.nbytes)) {
u8 *iv = walk.iv;
nbytes = req->cryptlen - processed;
scatterwalk_map_and_copy(ctx->lastbuffer, req->src, (req->cryptlen - nbytes), nbytes, 0);
ifx_deu_aes_xts(ctx, ctx->lastbuffer, ctx->lastbuffer,
iv, nbytes, CRYPTO_DIR_DECRYPT);
scatterwalk_map_and_copy(ctx->lastbuffer, req->dst, (req->cryptlen - nbytes), nbytes, 1);
skcipher_request_complete(req, 0);
}

return err;
}

The above function is used to decrypt data using XTS mode. It is similar to our function, except for the function used for encryption. XTS_block_encrypt is used to encrypt the data.</s>




NEXT




<s> static int bcm6328_pcie_write(struct pci_bus *bus, unsigned int devfn,
int where, int size, u32 val)
{
struct bcm6328_pcie *priv = &bcm6328_pcie;
u32 data;
u32 reg = where & ~3;

if (!bcm6328_pcie_can_access(bus, devfn))
return PCIBIOS_DEVICE_NOT_FOUND;

if (bus->number == PCIE_BUS_DEVICE)
reg += PCIE_DEVICE_OFFSET;

data = __raw_readl(priv->base + reg);
data = preprocess_write(data, val, where, size);
__raw_writel(data, priv->base + reg);

return PCIBIOS_SUCCESSFUL;
}

The above function is used to write data to a PCIe device.

The function starts by checking if we are allowed to access the PCIe bus.
The function does this by checking the bcm6328_pcie_can_access pointer.





NEXT




<s> static int rtl930x_set_ageing_time(unsigned long msec)
{
int t = sw_r32(RTL930X_L2_AGE_CTRL);

t &= 0x1FFFFF;
t = (t * 7) / 10;
pr_debug("L2 AGING time: %d sec\n", t);

t = (msec / 100 + 6) / 7;
t = t > 0x1FFFFF ? 0x1FFFFF : t;
sw_w32_mask(0x1FFFFF, t, RTL930X_L2_AGE_CTRL);
pr_debug("Dynamic aging for ports: %x\n", sw_r32(RTL930X_L2_PORT_AGE_CTRL));

return 0;
}

The above function is used to dynamically change the aging_time for the ports/vlans without rebooting the network.</s>




NEXT




<s> struct symbol *sym_choice_default(struct symbol *sym)
{
struct symbol *def_sym;
struct property *prop;
struct expr *e;

/* any of the defaults visible? */
for_all_defaults(sym, prop) {
prop->visible.tri = expr_calc_value(prop->visible.expr);
if (prop->visible.tri == no)
continue;
def_sym = prop_get_symbol(prop);
if (def_sym->visible != no)
return def_sym;
}

/* just get the first visible value */
prop = sym_get_choice_prop(sym);
expr_list_for_each_sym(prop->expr, e, def_sym)
if (def_sym->visible != no)
return def_sym;

/* failed to locate any defaults */
return NULL;
}

The above function is used to return the default symbol when called from _syscall. It looks pretty simple, so I will not go into detail. However, before going to the following function, let me stress the important role of this function.

1) This function




NEXT




<s> rtk_api_ret_t rtk_port_rtctEnable_set(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Mask Valid */
RTK_CHK_PORTMASK_VALID_ONLY_UTP(pPortmask);

if ((retVal = rtl8367c_setAsicPortRTCTEnable(pPortmask->bits[0]))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set UTP port's RTCCT enable flag.

rtk_api_ret_t rtk_port_rtctEnable_get(rtk_portmask_t *pPortmask)
{
rtk




NEXT




<s> static void pm_retx_counters_total(int fd, DSL_XTUDir_t direction) {
#ifdef INCLUDE_DSL_CPE_PM_RETX_COUNTERS
IOCTL_DIR(DSL_PM_ReTxCountersTotal_t, DSL_FIO_PM_RETX_COUNTERS_TOTAL_GET, direction);

m_u32("leftrs", out.data.nLeftr);
#endif
}

The above function is used to retrieve total counters from device. It is called each time when total statistic values are requested.

The "nleft" counter consists of two bytes. Increment of nleft in first byte increments after incrementing second byte. When




NEXT




<s> void fe_mdio_cleanup(struct fe_priv *priv)
{
if (!priv->mii_bus)
return;

mdiobus_unregister(priv->mii_bus);
of_node_put(priv->mii_bus->dev.of_node);
kfree(priv->mii_bus);
}

The above function is used to disconnect the physical layer
from the phy and to free the allocated resources.</s>




NEXT




<s> irqreturn_t rtl839x_switch_irq(int irq, void *dev_id)
{
struct dsa_switch *ds = dev_id;
u32 status = sw_r32(RTL839X_ISR_GLB_SRC);
u64 ports = rtl839x_get_port_reg_le(RTL839X_ISR_PORT_LINK_STS_CHG);
u64 link;

/* Clear status */
rtl839x_set_port_reg_le(ports, RTL839X_ISR_PORT_LINK_STS_CHG);
pr_debug("RTL8390 Link change: status: %x, ports %llx\n", status, ports);

for (int i = 0; i < RTL839X_CPU_PORT; i++) {
if (ports & BIT_ULL(i)) {
link = rtl839x_get_port_reg_le(RTL839X_MAC_LINK_STS);
if (link & BIT_ULL(i))
dsa_port_phylink_mac_change(ds, i, true);
else
dsa_port_phylink_mac_change(ds, i, false);
}
}

return IRQ_HANDLED;
}

The above function is used to deal with ISR interrupt generated by PHY, for details can refer to [1].

The code for this project is available here: https://github.com/foolish-fool/RTL839X






NEXT




<s> yy_symbol_print (FILE *yyo,
yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
{
YYFPRINTF (yyo, "%s %s (",
yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));

yy_symbol_value_print (yyo, yykind, yyvaluep);
YYFPRINTF (yyo, ")");
}

The above function is used to print symbols and their arguments.</s>




NEXT




<s> static int __rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
{
unsigned long flags;
u8 lo = 0;
u8 hi = 0;
int ret;

spin_lock_irqsave(&smi->lock, flags);

rtl8366_smi_start(smi);

/* send READ command */
ret = rtl8366_smi_write_byte(smi, smi->cmd_read);
if (ret)
goto out;

/* set ADDR[7:0] */
ret = rtl8366_smi_write_byte(smi, addr & 0xff);
if (ret)
goto out;

/* set ADDR[15:8] */
ret = rtl8366_smi_write_byte(smi, addr >> 8);
if (ret)
goto out;

/* read DATA[7:0] */
rtl8366_smi_read_byte0(smi, &lo);
/* read DATA[15:8] */
rtl8366_smi_read_byte1(smi, &hi);

*data = ((u32) lo) | (((u32) hi) << 8);

ret = 0;

out:
rtl8366_smi_stop(smi);
spin_unlock_irqrestore(&smi->lock, flags);

return ret;
}

The above function is used to read a 16-bit register from the on-board EEPROM and we do not care about the value of the register. To avoid the compiler eliminating this function completely, we will do something to it. This patch causes a




NEXT




<s> static inline void emac_writel(struct bcm6348_emac *emac, u32 val, u32 off)
{
__raw_writel(val, emac->base + off);
}

The above function is used to write an emac_base to a peripheral.
emc_base = (u32*)emc_base;
return emc_base;
}

AFAIK, the problem is that the compiler doesn




NEXT




<s> static void nmbm_build_mapping_table(struct nmbm_instance *ni)
{
uint32_t pb, lb;

for (pb = 0, lb = 0; pb < ni->mgmt_start_ba; pb++) {
if (nmbm_get_block_state(ni, pb) == BLOCK_ST_BAD)
continue;

/* Always map to the next good block */
ni->block_mapping[lb++] = pb;
}

ni->data_block_count = lb;

/* Unusable/Management blocks */
for (pb = lb; pb < ni->block_count; pb++)
ni->block_mapping[pb] = -1;
}

The above function is used to construct the block_mapping array. The block_mapping array maps the logical block number to a mapping value indicating the physical location of the data block on a disk.

/* nmbm_get_block_mapping(): Convert a logical block




NEXT




<s> rtk_api_ret_t rtk_l2_limitLearningCnt_get(rtk_port_t port, rtk_mac_cnt_t *pMac_cnt)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pMac_cnt)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLutLearnLimitNo(rtk_switch_port_L2P_get(port), pMac_cnt)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the number of MAC entries allowed on the L2 Switch before learning stops on the L2 Switch.</s>




NEXT




<s> void ase_init(struct platform_device *pdev)
{
init_pmu();

reset_ppe(pdev);

init_ema();

init_mailbox();

init_atm_tc();

clear_share_buffer();
}

The above function is used to initialize the driver components. We can find a similar function in the same code base. Here a similar function is also used to initialize the same driver components but with a different purpose.

drivers/pci/drm/stmich




NEXT




<s> ret_t rtl8367c_setAsicMIBsResetLoggingCounter(rtk_uint32 index)
{
ret_t retVal;

if(index > RTL8367C_MIB_MAX_LOG_CNT_IDX)
return RT_ERR_OUT_OF_RANGE;

if(index < 16)
retVal = rtl8367c_setAsicReg(RTL8367C_REG_MIB_CTRL1, 1<<index);
else
retVal = rtl8367c_setAsicReg(RTL8367C_REG_MIB_CTRL2, 1<<(index-16));

return retVal;
}

The above function is used to reset a counter everytime that a MIB related event occcurs.

I'm using the function in the following manner:

r = rtl8367c_setAsicMIBsResetLoggingCounter(




NEXT




<s> static int ag71xx_rings_init(struct ag71xx *ag)
{
struct ag71xx_ring *tx = &ag->tx_ring;
struct ag71xx_ring *rx = &ag->rx_ring;
int ring_size = BIT(tx->order) + BIT(rx->order);
int tx_size = BIT(tx->order);

tx->buf = kzalloc(ring_size * sizeof(*tx->buf), GFP_KERNEL);
if (!tx->buf)
return -ENOMEM;

tx->descs_cpu = dma_alloc_coherent(&ag->pdev->dev, ring_size * AG71XX_DESC_SIZE,
&tx->descs_dma, GFP_KERNEL);
if (!tx->descs_cpu) {
kfree(tx->buf);
tx->buf = NULL;
return -ENOMEM;
}

rx->buf = &tx->buf[tx_size];
rx->descs_cpu = ((void *)tx->descs_cpu) + tx_size * AG71XX_DESC_SIZE;
rx->descs_dma = tx->descs_dma + tx_size * AG71XX_DESC_SIZE;

ag71xx_ring_tx_init(ag);
return ag71xx_ring_rx_init(ag);
}

The above function is used to initialize TX and RX rings along with their respective buffers and the DMA pointers etc.</s>




NEXT




<s> static inline void clear_htu_entry(unsigned int);
static void validate_oam_htu_entry(void);
static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to pass parameters for Ethertype 0x890A.
#endif
u8 *ifx_map_vcc(int, int);
unsigned int ifx_vcc_index(int, int);
void




NEXT




<s> IFX_MEI_IoctlCopyFrom (int from_kernel, char *dest, char *from, int size)
{
int ret = 0;

if (!from_kernel)
ret = copy_from_user ((char *) dest, (char *) from, size);
else
ret = (int)memcpy ((char *) dest, (char *) from, size);
return ret;
}

The above function is used to transfer data from user space to kernel space, and to copy data from kernel space to user space. But, both functions in the MEI_Kdriver.c file use the "ret = " operator to initialize their return value.
As the




NEXT




<s> static int rtl8366rb_set_vlan_mc(struct rtl8366_smi *smi, u32 index,
const struct rtl8366_vlan_mc *vlanmc)
{
u32 data[3];
int err;
int i;

if (index >= RTL8366RB_NUM_VLANS ||
vlanmc->vid >= RTL8366RB_NUM_VIDS ||
vlanmc->priority > RTL8366RB_PRIORITYMAX ||
vlanmc->member > RTL8366RB_VLAN_MEMBER_MASK ||
vlanmc->untag > RTL8366RB_VLAN_UNTAG_MASK ||
vlanmc->fid > RTL8366RB_FIDMAX)
return -EINVAL;

data[0] = (vlanmc->vid & RTL8366RB_VLAN_VID_MASK) |
((vlanmc->priority & RTL8366RB_VLAN_PRIORITY_MASK) <<
RTL8366RB_VLAN_PRIORITY_SHIFT);
data[1] = (vlanmc->member & RTL8366RB_VLAN_MEMBER_MASK) |
((vlanmc->untag & RTL8366RB_VLAN_UNTAG_MASK) <<
RTL8366RB_VLAN_UNTAG_SHIFT);
data[2] = vlanmc->fid & RTL8366RB_VLAN_FID_MASK;

for (i = 0; i < 3; i++) {
err = rtl8366_smi_write_reg(smi,
RTL8366RB_VLAN_MC_BASE(index) + i,
data[i]);
if (err)
return err;
}

return 0;
}

The above function is used to get/set a VLAN Multicast entry as detailed in 8.2 and 8.3 of Section 8 of rtl8366rb.pdf.

The following is a part code of the function:





NEXT




<s> int conf_read(const char *name)
{
struct symbol *sym;
int conf_unsaved = 0;
int i;

conf_set_changed(false);

if (conf_read_simple(name, S_DEF_USER)) {
sym_calc_value(modules_sym);
return 1;
}

sym_calc_value(modules_sym);

for_all_symbols(i, sym) {
sym_calc_value(sym);
if (sym_is_choice(sym) || (sym->flags & SYMBOL_NO_WRITE))
continue;
if (sym_has_value(sym) && (sym->flags & SYMBOL_WRITE)) {
/* check that calculated value agrees with saved value */
switch (sym->type) {
case S_BOOLEAN:
case S_TRISTATE:
if (sym->def[S_DEF_USER].tri == sym_get_tristate_value(sym))
continue;
break;
default:
if (!strcmp(sym->curr.val, sym->def[S_DEF_USER].val))
continue;
break;
}
} else if (!sym_has_value(sym) && !(sym->flags & SYMBOL_WRITE))
/* no previous value and not saved */
continue;
conf_unsaved++;
/* maybe print value in verbose mode... */
}

for_all_symbols(i, sym) {
if (sym_has_value(sym) && !sym_is_choice_value(sym)) {
/* Reset values of generates values, so they'll appear
* as new, if they should become visible, but that
* doesn't quite work if the Kconfig and the saved
* configuration disagree.
*/
if (sym->visible == no && !conf_unsaved)
sym->flags &= ~SYMBOL_DEF_USER;
switch (sym->type) {
case S_STRING:
case S_INT:
case S_HEX:
/* Reset a string value if it's out of range */
if (sym_string_within_range(sym, sym->def[S_DEF_USER].val))
break;
sym->flags &= ~(SYMBOL_VALID|SYMBOL_DEF_USER);
conf_unsaved++;
break;
default:
break;
}
}
}

if (conf_warnings || conf_unsaved)
conf_set_changed(true);

return 0;
}

The above function is used to read parameters from the module’s Kconfig, this function checks that the values we got from the Kconfig agree with the current value of any symbol in the configuration.</s>




NEXT




<s> static void msdc_dma_setup(struct msdc_host *host, struct msdc_dma *dma,
struct scatterlist *sg, unsigned int sglen)
{
BUG_ON(sglen > MAX_BD_NUM); /* not support currently */

dma->sg = sg;
dma->sglen = sglen;

dma->mode = MSDC_MODE_DMA_DESC;

N_MSG(DMA, "DMA mode<%d> sglen<%d> xfersz<%d>", dma->mode, dma->sglen,
host->xfer_size);

msdc_dma_config(host, dma);
}

The above function is used to setup data transfer through DMA.</s>




NEXT




<s> ret_t rtl8367c_setAsicEgressFlowControlPortDropThreshold(rtk_uint32 port, rtk_uint32 threshold)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(threshold >= RTL8367C_PAGE_NUMBER)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBits(RTL8367C_FLOWCTRL_PORT_DROP_ON_REG(port), RTL8367C_FLOWCTRL_PORT_DROP_ON_MASK, threshold);
}

The above function is used to set drop threshold for Asic Egress Flown Control.

In hardware, it is used following registers:

<![if !vml]><![endif]></s>




NEXT




<s> ret_t rtl8367c_getAsicFlowControlPortDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_OFF, RTL8367C_FLOWCTRL_FCOFF_PORT_OFF_MASK, pOffThreshold);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_ON, RTL8367C_FLOWCTRL_FCOFF_PORT_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to get the on/off threshold of flow control from MAC. If you want to set on/off threshold, use the below function call to set the value:

uint32_t portNum, portOffThr, portOnTh




NEXT




<s> static void handle_f2(int *key, struct menu *current_item);
static void handle_f3(int *key, struct menu *current_item);
static void handle_f4(int *key, struct menu *current_item);
static void handle_f5(int *key, struct menu *current_item);
static void handle_f6(int *key, struct menu *current_item);
static void handle_f7(int *key, struct menu *current_item);
static void handle_f8(int *key, struct menu *current_item);
static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to map a key to a specified function.

There is a function called fnmap which can be used to set a key to a
function call. The function fnmap is defined as
void fnmap(int key, const char *func




NEXT




<s> ar8xxx_sw_hw_apply(struct switch_dev *dev)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
const struct ar8xxx_chip *chip = priv->chip;
u8 portmask[AR8X16_MAX_PORTS];
int i, j;

mutex_lock(&priv->reg_mutex);
/* flush all vlan translation unit entries */
priv->chip->vtu_flush(priv);

memset(portmask, 0, sizeof(portmask));
if (!priv->init) {
/* calculate the port destination masks and load vlans
* into the vlan translation unit */
for (j = 0; j < dev->vlans; j++) {
u8 vp = priv->vlan_table[j];

if (!vp)
continue;

for (i = 0; i < dev->ports; i++) {
u8 mask = (1 << i);
if (vp & mask)
portmask[i] |= vp & ~mask;
}

chip->vtu_load_vlan(priv, priv->vlan_id[j],
priv->vlan_table[j]);
}
} else {
/* vlan disabled:
* isolate all ports, but connect them to the cpu port */
for (i = 0; i < dev->ports; i++) {
if (i == AR8216_PORT_CPU)
continue;

portmask[i] = 1 << AR8216_PORT_CPU;
portmask[AR8216_PORT_CPU] |= (1 << i);
}
}

/* update the port destination mask registers and tag settings */
for (i = 0; i < dev->ports; i++) {
chip->setup_port(priv, i, portmask[i]);
}

chip->set_mirror_regs(priv);

/* set age time */
if (chip->reg_arl_ctrl)
ar8xxx_set_age_time(priv, chip->reg_arl_ctrl);

mutex_unlock(&priv->reg_mutex);
return 0;
}

The above function is used to apply the data
from the switch port's data structure to the
physical switch, it involves a lot of code in this kernel version which
is a lot of work which can be achieved by the
compiler's auto-vectorization




NEXT




<s> void conf_reset(int def)
{
struct symbol *sym;
int i, def_flags;

def_flags = SYMBOL_DEF << def;
for_all_symbols(i, sym) {
sym->flags |= SYMBOL_CHANGED;
sym->flags &= ~(def_flags|SYMBOL_VALID);
if (sym_is_choice(sym))
sym->flags |= def_flags;
switch (sym->type) {
case S_INT:
case S_HEX:
case S_STRING:
if (sym->def[def].val)
free(sym->def[def].val);
/* fall through */
default:
sym->def[def].val = NULL;
sym->def[def].tri = no;
}
}
}

The above function is used to clear all the changed bits in the flag byte of all symbols in the file.</s>




NEXT




<s> ret_t rtl8367c_getAsicSystemLutLearnPortMask(rtk_uint32 *pPortmask)
{
rtk_uint32 tmpmask;
ret_t retVal;

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_PMASK_MASK, &tmpmask);
if(retVal != RT_ERR_OK)
return retVal;
*pPortmask = tmpmask & 0xff;
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_PMASK1_MASK, &tmpmask);
if(retVal != RT_ERR_OK)
return retVal;
*pPortmask |= (tmpmask & 0x7) << 8;

return RT_ERR_OK;
}

The above function is used to get system Learn Port mask

Please feel free to download demo and send us comments/questions</s>




NEXT




<s> int get_line_no(const char *text)
{
int i;
int total = 1;

if (!text)
return 0;

for (i = 0; text[i] != '\0'; i++)
if (text[i] == '\n')
total++;
return total;
}

The above function is used to know the number of lines present in the argument provided on the text. The return value is the total number of lines present in the argument.

C++</s>




NEXT




<s> ret_t rtl8367c_setAsicInterruptRelatedStatus(rtk_uint32 type, rtk_uint32 status)
{
CONST rtk_uint32 indicatorAddress[INTRST_END] = {RTL8367C_REG_LEARN_OVER_INDICATOR,
RTL8367C_REG_SPEED_CHANGE_INDICATOR,
RTL8367C_REG_SPECIAL_CONGEST_INDICATOR,
RTL8367C_REG_PORT_LINKDOWN_INDICATOR,
RTL8367C_REG_PORT_LINKUP_INDICATOR,
RTL8367C_REG_METER_OVERRATE_INDICATOR0,
RTL8367C_REG_METER_OVERRATE_INDICATOR1,
RTL8367C_REG_RLDP_LOOPED_INDICATOR,
RTL8367C_REG_RLDP_RELEASED_INDICATOR,
RTL8367C_REG_SYSTEM_LEARN_OVER_INDICATOR};

if(type >= INTRST_END )
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicReg(indicatorAddress[type], status);
}

The above function is used to enable/disable some specific indicators for special purpose that need to record by host(see Figure 20) .

For example, the host need to record the number the port-link-up and port-link-down event happen




NEXT




<s> ret_t rtl8367c_getAsicIGMPdynamicRouterPort2(rtk_uint32 *port, rtk_uint32 *timer)
{
ret_t   retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_DYNAMIC_ROUTER_PORT, RTL8367C_D_ROUTER_PORT_2_MASK, port);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_DYNAMIC_ROUTER_PORT, RTL8367C_D_ROUTER_PORT_TMR_2_MASK, timer);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the 2nd port of the dynamic router ports list and the timeout value of group.
We can use it to get the timeout to see if the router port in the list timed out.</s>




NEXT




<s> rtk_api_ret_t rtk_port_phyAutoNegoAbility_get(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
{
rtk_api_ret_t       retVal;
rtk_uint32          phyData0;
rtk_uint32          phyData4;
rtk_uint32          phyData9;
rtk_port_media_t    media_type;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

if(NULL == pAbility)
return RT_ERR_NULL_POINTER;

if (rtk_switch_isComboPort(port) == RT_ERR_OK)
{
if ((retVal = rtk_port_phyComboPortMedia_get(port, &media_type)) != RT_ERR_OK)
return retVal;

if(media_type == PORT_MEDIA_FIBER)
{
return _rtk_port_FiberModeAbility_get(port, pAbility);
}
}

/*Control register setting and restart auto*/
if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, &phyData0)) != RT_ERR_OK)
return retVal;

/*Auto-Negotiation control register setting*/
if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_AN_ADVERTISEMENT_REG, &phyData4)) != RT_ERR_OK)
return retVal;

/*1000 BASE-T control register setting*/
if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_1000_BASET_CONTROL_REG, &phyData9)) != RT_ERR_OK)
return retVal;

if (phyData9 & (1 << 9))
pAbility->Full_1000 = 1;
else
pAbility->Full_1000 = 0;

if (phyData4 & (1 << 11))
pAbility->AsyFC = 1;
else
pAbility->AsyFC = 0;

if (phyData4 & (1 << 10))
pAbility->FC = 1;
else
pAbility->FC = 0;


if (phyData4 & (1 << 8))
pAbility->Full_100 = 1;
else
pAbility->Full_100 = 0;

if (phyData4 & (1 << 7))
pAbility->Half_100 = 1;
else
pAbility->Half_100 = 0;

if (phyData4 & (1 << 6))
pAbility->Full_10 = 1;
else
pAbility->Full_10 = 0;

if (phyData4 & (1 << 5))
pAbility->Half_10 = 1;
else
pAbility->Half_10 = 0;


if (phyData0 & (1 << 12))
pAbility->AutoNegotiation = 1;
else
pAbility->AutoNegotiation = 0;

return RT_ERR_OK;
}

The above function is used to get the configuration value of the specified PORT PHY Ability.

The parameter pAbility is the address of the variable where the configuration value of the corresponding PHY Ability is returned.

<pre><code>
typed




NEXT




<s> ar8xxx_phy_read_status(struct phy_device *phydev)
{
struct ar8xxx_priv *priv = phydev->priv;
struct switch_port_link link;

/* check for switch port link changes */
ar8xxx_check_link_states(priv);

if (phydev->mdio.addr != 0)
return genphy_read_status(phydev);

ar8216_read_port_link(priv, phydev->mdio.addr, &link);
phydev->link = !!link.link;
if (!phydev->link)
return 0;

switch (link.speed) {
case SWITCH_PORT_SPEED_10:
phydev->speed = SPEED_10;
break;
case SWITCH_PORT_SPEED_100:
phydev->speed = SPEED_100;
break;
case SWITCH_PORT_SPEED_1000:
phydev->speed = SPEED_1000;
break;
default:
phydev->speed = 0;
}
phydev->duplex = link.duplex ? DUPLEX_FULL : DUPLEX_HALF;

phydev->state = PHY_RUNNING;
netif_carrier_on(phydev->attached_dev);
if (phydev->adjust_link)
phydev->adjust_link(phydev->attached_dev);

return 0;
}

The above function is used to check the link state as below:

/* check for switch port link changes */
ar8xxx_check_link_states(priv);</s>




NEXT




<s> ead_pcap_reopen(bool first)
{
static char errbuf[PCAP_ERRBUF_SIZE] = "";

if (pcap_fp_rx && (pcap_fp_rx != pcap_fp))
pcap_close(pcap_fp_rx);

if (pcap_fp)
pcap_close(pcap_fp);

pcap_fp_rx = NULL;
do {
if (instance->bridge[0]) {
pcap_fp_rx = ead_open_pcap(instance->bridge, errbuf, 1);
pcap_fp = ead_open_pcap(instance->ifname, errbuf, 0);
} else {
pcap_fp = ead_open_pcap(instance->ifname, errbuf, 1);
}

if (!pcap_fp_rx)
pcap_fp_rx = pcap_fp;
if (first && !pcap_fp) {
DEBUG(1, "WARNING: unable to open interface '%s'\n", instance->ifname);
first = false;
}
if (!pcap_fp)
sleep(1);
} while (!pcap_fp);
pcap_setfilter(pcap_fp_rx, &pktfilter);
}

The above function is used to reopen a libpcap file descriptor when data transmission or receiving is done via a different interface. In our case, the Eader can use libpcap to capture the traffic between its network interface card and the OpenRTSP server. Then,




NEXT




<s> static __inline__ unsigned char lzma_get_byte(void)
{
unsigned char c;

lzma_datasize--;
c = *lzma_data++;

return c;
}

The above function is used to read a byte directly from a compressed stream. When the code is compiled for x86 processors, the size of a byte is 4 bytes (char is 4 bytes). Hence, if "lzma_data" is at




NEXT




<s> rtk_api_ret_t rtk_igmp_bypassGroupRange_get(rtk_igmp_bypassGroup_t group, rtk_enable_t *pEnable)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(group >= IGMP_BYPASS_GROUP_END)
return RT_ERR_INPUT;

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPBypassGroup(group, pEnable))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read the igmp bypass group enable in RTL8367C, please refer to the API description for details.</s>




NEXT




<s> static int rtl8367_sw_get_port_stats(struct switch_dev *dev, int port,
struct switch_port_stats *stats)
{
return (rtl8366_sw_get_port_stats(dev, port, stats,
RTL8367_MIB_TXB_ID, RTL8367_MIB_RXB_ID));
}

The above function is used to get the port stats. When the above
function is called, the following statistics are retrieved:

RTL8367_MIB_TXB_ID, RTL8367_MIB_RXB_




NEXT




<s> static inline void rttm_ack_irq(void __iomem *base)
{
iowrite32(ioread32(base + RTTM_INT) | RTTM_INT_PENDING, base + RTTM_INT);
}

The above function is used to unacked an IRQ that is pending during the
RT-TIMER module's run. As I understand it, this function is called
at the beginning of a new iteration through the module's callbacks so
it is only called




NEXT




<s> static void aw9523_gpio_set(struct gpio_chip *chip,
unsigned int offset, int value)
{
struct aw9523 *awi = gpiochip_get_data(chip);
u8 regbit = offset % AW9523_PINS_PER_PORT;

mutex_lock(&awi->i2c_lock);
regmap_update_bits(awi->regmap, AW9523_REG_OUT_STATE(offset),
BIT(regbit), value ? BIT(regbit) : 0);
mutex_unlock(&awi->i2c_lock);
}

The above function is used to set gpio values for aw9523 chips using gpiochip structure. There are several chip configurations available in fw like aw9523-8. The aw9523_gpio_set_raw_gpio()




NEXT




<s> ar8xxx_phy_config_init(struct phy_device *phydev)
{
struct ar8xxx_priv *priv = phydev->priv;
#ifdef CONFIG_ETHERNET_PACKET_MANGLE
struct net_device *dev = phydev->attached_dev;
#endif
int ret;

if (WARN_ON(!priv))
return -ENODEV;

if (priv->chip->config_at_probe)
return ar8xxx_phy_check_aneg(phydev);

priv->phy = phydev;

if (phydev->mdio.addr != 0) {
if (chip_is_ar8316(priv)) {
/* switch device has been initialized, reinit */
priv->dev.ports = (AR8216_NUM_PORTS - 1);
priv->initialized = false;
priv->port4_phy = true;
ar8316_hw_init(priv);
return 0;
}

return 0;
}

ret = ar8xxx_start(priv);
if (ret)
return ret;

#ifdef CONFIG_ETHERNET_PACKET_MANGLE
/* VID fixup only needed on ar8216 */
if (chip_is_ar8216(priv)) {
dev->phy_ptr = priv;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
dev->priv_flags |= IFF_NO_IP_ALIGN;
#else
dev->extra_priv_flags |= IFF_NO_IP_ALIGN;
#endif
dev->eth_mangle_rx = ar8216_mangle_rx;
dev->eth_mangle_tx = ar8216_mangle_tx;
}
#endif

return 0;
}

The above function is used to configure the PHY based on the AR8216 register defaults for the RGMII interface. The switch is only initialized if the PHY has been detached from the NIC, and the MDIO interface has a valid address for this




NEXT




<s> static int psb6970_get_pvid(struct switch_dev *dev, int port, int *vlan)
{
struct psb6970_priv *priv = to_psb6970(dev);
*vlan = priv->pvid[port];
return 0;
}

The above function is used to obtain the private vlan id (PVID) for a particular port.
This is called in the function psb6970_config_switching_ports when a new port is discovered to be attached to the switch, and the




NEXT




<s> static irqreturn_t qca807x_handle_interrupt(struct phy_device *phydev)
{
int irq_status, int_enabled;

irq_status = phy_read(phydev, QCA807X_INTR_STATUS);
if (irq_status < 0) {
phy_error(phydev);
return IRQ_NONE;
}

/* Read the current enabled interrupts */
int_enabled = phy_read(phydev, QCA807X_INTR_ENABLE);
if (int_enabled < 0) {
phy_error(phydev);
return IRQ_NONE;
}

/* See if this was one of our enabled interrupts */
if (!(irq_status & int_enabled))
return IRQ_NONE;

phy_trigger_machine(phydev);

return IRQ_HANDLED;
}

The above function is used to handle interrupt for a physical device.

Now consider the below code snippet

#if defined(ENABLE_FIT_INTR)

#if (!defined(QCA807X) && !defined(QCA




NEXT




<s> int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
{
BIGNUM *t;
int r=0;

bn_check_top(a);
bn_check_top(b);
bn_check_top(m);

BN_CTX_start(ctx);
if ((t = BN_CTX_get(ctx)) == NULL) goto err;
if (a == b)
{ if (!BN_sqr(t,a,ctx)) goto err; }
else
{ if (!BN_mul(t,a,b,ctx)) goto err; }
if (!BN_mod(ret,t,m,ctx)) goto err;
r=1;
err:
BN_CTX_end(ctx);
return(r);
}

The above function is used to find the product of two numbers of BIGNUM type and is used for calculating the Hash from it as below

int Hash(unsigned int size, BIGNUM *a, BIGNUM *b, char *buffer)
{




NEXT




<s> static void rtl838x_set_mac_hw(struct net_device *dev, u8 *mac)
{
struct rtl838x_eth_priv *priv = netdev_priv(dev);
unsigned long flags;

spin_lock_irqsave(&priv->lock, flags);
pr_debug("In %s\n", __func__);
sw_w32((mac[0] << 8) | mac[1], priv->r->mac);
sw_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5], priv->r->mac + 4);

if (priv->family_id == RTL8380_FAMILY_ID) {
/* 2 more registers, ALE/MAC block */
sw_w32((mac[0] << 8) | mac[1], RTL838X_MAC_ALE);
sw_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
(RTL838X_MAC_ALE + 4));

sw_w32((mac[0] << 8) | mac[1], RTL838X_MAC2);
sw_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
RTL838X_MAC2 + 4);
}
spin_unlock_irqrestore(&priv->lock, flags);
}

The above function is used to set the MAC address from drivers/net/bcm8380.c and drivers/net/realtek.c and is called from netdev_auto_config.
There are more drivers which use it with a few modifications such




NEXT




<s> ret_t rtl8367c_setAsicUnknownL2MulticastBehavior(rtk_uint32 port, rtk_uint32 behave)
{
ret_t retVal;

if(port >  RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(behave >= L2_UNKOWN_MULTICAST_END)
return RT_ERR_NOT_ALLOWED;
if(port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_UNKNOWN_L2_MULTICAST_REG(port), RTL8367C_UNKNOWN_L2_MULTICAST_MASK(port), behave);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_UNKNOWN_L2_MULTICAST_CTRL1, 3 << ((port - 8) << 1), behave);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to modify the L2 behavior for each incoming unknown L2 multicast frames, including RTS, RTD.

L2_MCAST_RTS_BEHAVIOR_PORT0_F
L2_MCAST




NEXT




<s> static int bcm6318_pcie_write(struct pci_bus *bus, unsigned int devfn,
int where, int size, u32 val)
{
struct bcm6318_pcie *priv = &bcm6318_pcie;
u32 data;
u32 reg = where & ~3;

if (!bcm6318_pcie_can_access(bus, devfn))
return PCIBIOS_DEVICE_NOT_FOUND;

if (bus->number == PCIE_BUS_DEVICE)
reg += PCIE_DEVICE_OFFSET;

data = __raw_readl(priv->base + reg);
data = preprocess_write(data, val, where, size);
__raw_writel(data, priv->base + reg);

return PCIBIOS_SUCCESSFUL;
}

The above function is used to write a value to a register in the PCIe controller of the BCM6318.

I was having a bit of trouble writing the data value to the register, and the above function did not help.

However, I




NEXT




<s> static void rt5350_init_data(struct fe_soc_data *data,
struct net_device *netdev)
{
struct fe_priv *priv = netdev_priv(netdev);

priv->flags = FE_FLAG_HAS_SWITCH;
netdev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM;
}

The above function is used to initiate some variables to initialize the RTL8387R Ethernet switch. If the device wants to have hardware virtual switch such as the RTL8387R, the driver has to make the netdev data have the




NEXT




<s> static void Transform ();

static unsigned char PADDING[64] = {
0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

The above function is used to pad the block with extra data. Note: the first
byte is not actually changed as the program will do some extra things with it
later on. It can also be seen that the padding is all the same.

The first thing




NEXT




<s> static int aw9523_gpio_get(struct gpio_chip *chip, unsigned int offset)
{
struct aw9523 *awi = gpiochip_get_data(chip);
u8 regbit = offset % AW9523_PINS_PER_PORT;
unsigned int val;
int ret;

mutex_lock(&awi->i2c_lock);
ret = aw9523_get_port_state(awi->regmap, offset, regbit, &val);
mutex_unlock(&awi->i2c_lock);
if (ret)
return ret;

return !!(val & BIT(regbit));
}

The above function is used to get the state of GPIO. If the I2C interface is busy, the
busy wait method is used when reading, which will delay the system. What if the
interrupt mode is used instead of the polling mode?</s>




NEXT




<s> static inline int gpio_dcc_set(struct dc_ep_dev *dev, u32 gpio, u32 val)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_gpio_dcc_set(dev->priv, gpio, val);
}

The above function is used to enable GPIO in a particular pattern for the EP driver. Currently, it is used from HX-RT-A1, which requires GPIOs to be pulled down for proper operation (for which this DCC is used).</s>




NEXT




<s> int fe_mdio_init(struct fe_priv *priv)
{
struct device_node *mii_np;
int err;

if (!priv->soc->mdio_read || !priv->soc->mdio_write)
return 0;

spin_lock_init(&phy_ralink.lock);
priv->phy = &phy_ralink;

mii_np = of_get_child_by_name(priv->dev->of_node, "mdio-bus");
if (!mii_np) {
dev_err(priv->dev, "no %s child node found", "mdio-bus");
err = 0;
goto err_no_bus;
}

if (!of_device_is_available(mii_np)) {
err = 0;
goto err_put_node;
}

priv->mii_bus = mdiobus_alloc();
if (!priv->mii_bus) {
err = -ENOMEM;
goto err_put_node;
}

priv->mii_bus->name = "mdio";
priv->mii_bus->read = priv->soc->mdio_read;
priv->mii_bus->write = priv->soc->mdio_write;
priv->mii_bus->reset = fe_mdio_reset;
priv->mii_bus->priv = priv;
priv->mii_bus->parent = priv->dev;

snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "%s", mii_np->name);
err = of_mdiobus_register(priv->mii_bus, mii_np);
if (err)
goto err_free_bus;

return 0;

err_free_bus:
kfree(priv->mii_bus);
err_put_node:
of_node_put(mii_np);
err_no_bus:
dev_info(priv->dev, "%s disabled", "mdio-bus");
priv->mii_bus = NULL;
return err;
}

The above function is used to create the "mdio-bus" device node and allocate the mii_bus structure which is needed to interact with the MDIO interface.

The mdiobus_alloc function is used to allocate the mdiobus structure for




NEXT




<s> struct menu *menu_add_menu(void)
{
last_entry_ptr = &current_entry->list;
current_menu = current_entry;
return current_menu;
}

The above function is used to create a new menu with given number of entries.
But what happens when you call menu_add_menu ?

1. The menu is created
2. Last entry pointer is updated to point to the list of current entry
3.




NEXT




<s> ret_t rtl8367c_setAsicInterruptPolarity(rtk_uint32 polarity)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_INTR_CTRL, RTL8367C_INTR_CTRL_OFFSET, polarity);
}

The above function is used to set the interrupt polarity which is a bit of rtl8367c_reg_intr_ctrl. There are 6 bits, bit0 for RX_LPS_EN, 1-5 for TX_LPS




NEXT




<s> ret_t rtl8367c_getAsicSpanningTreeStatus(rtk_uint32 port, rtk_uint32 msti, rtk_uint32* pState)
{
rtk_uint32  reg_addr,bits_msk;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(msti > RTL8367C_MSTIMAX)
return RT_ERR_MSTI;

if(port < 8)
return rtl8367c_getAsicRegBits(RTL8367C_VLAN_MSTI_REG(msti,port), RTL8367C_VLAN_MSTI_MASK(port), pState);
else{
reg_addr = RTL8367C_VLAN_MSTI_REG(msti,port);
switch(port){
case 8: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT8_STATE_MASK;break;
case 9: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT9_STATE_MASK;break;
case 10: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT10_STATE_MASK;break;
}
return rtl8367c_getAsicRegBits(reg_addr, bits_msk, pState);
}

}

The above function is used to access MST forwarding state(i.e. if port is forwarding to the elected root). I will describe how to get it by using MDIO.</s>




NEXT




<s> static int get_number(char **, int *, int);
static inline void ignore_space(char **, int *);



/*
* ####################################
*            Local Variable
* ####################################
*/



/*
* ####################################
*            Local Function
* ####################################
*/

static inline void proc_file_create(void)
{
struct proc_dir_entry *res;

res = create_proc_entry("driver/ifx_ptm/mem",
0,
NULL);
if ( res != NULL )
res->write_proc = proc_write_mem;
else
printk("%s:%s:%d: failed to create proc mem!", __FILE__, __func__, __LINE__);

res = create_proc_entry("driver/ifx_ptm/pp32",
0,
NULL);
if ( res != NULL ) {
res->read_proc = proc_read_pp32;
res->write_proc = proc_write_pp32;
}
else
printk("%s:%s:%d: failed to create proc pp32!", __FILE__, __func__, __LINE__);
}

The above function is used to automatically create a link to create the "mem" and "pp32" links in the process directory.

static int driver_release(struct inode *inode, struct file *filp)
{
unregister_chrdev(MY




NEXT




<s> static u32 rtl9300_i2c_func(struct i2c_adapter *a)
{
return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
I2C_FUNC_SMBUS_BLOCK_DATA;
}

The above function is used to configure I2C driver specific functions.I2C_FUNC_SMBUS_QUICK is for quick I/0 operations.I2C_FUNC_SMBUS_BYTE is for sending or receiving a single data byte.I




NEXT




<s> static void sata_oxnas_qc_free(struct ata_queued_cmd *qc)
{
DPRINTK("\n");
sata_oxnas_release_hw(qc->ap);
}

The above function is used to free a queued command, however there’s one problem.  Since this function is supposed to be called after a command has been completed this means that the command is completed inside the critical section, so the function is called at the END of the




NEXT




<s> void dialog_clear(void)
{
int lines, columns;

lines = getmaxy(stdscr);
columns = getmaxx(stdscr);

attr_clear(stdscr, lines, columns, dlg.screen.atr);
/* Display background title if it exists ... - SLH */
if (dlg.backtitle != NULL) {
int i, len = 0, skip = 0;
struct subtitle_list *pos;

wattrset(stdscr, dlg.screen.atr);
mvwaddstr(stdscr, 0, 1, (char *)dlg.backtitle);

for (pos = dlg.subtitles; pos != NULL; pos = pos->next) {
/* 3 is for the arrow and spaces */
len += strlen(pos->text) + 3;
}

wmove(stdscr, 1, 1);
if (len > columns - 2) {
const char *ellipsis = "[...] ";
waddstr(stdscr, ellipsis);
skip = len - (columns - 2 - strlen(ellipsis));
}

for (pos = dlg.subtitles; pos != NULL; pos = pos->next) {
if (skip == 0)
waddch(stdscr, ACS_RARROW);
else
skip--;

if (skip == 0)
waddch(stdscr, ' ');
else
skip--;

if (skip < strlen(pos->text)) {
waddstr(stdscr, pos->text + skip);
skip = 0;
} else
skip -= strlen(pos->text);

if (skip == 0)
waddch(stdscr, ' ');
else
skip--;
}

for (i = len + 1; i < columns - 1; i++)
waddch(stdscr, ACS_HLINE);
}
wnoutrefresh(stdscr);
}

The above function is used to clear the display before drawing something new and it is called whenever something has changed.

The second function in use is called dialog(string, integer):

void dialog(struct dialog *d, char *text, int nr)
{




NEXT




<s> static int mt7530_sw_get_mib(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
static char buf[4096];
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
int i, len = 0;

len += snprintf(buf + len, sizeof(buf) - len, "Switch MIB counters\n");

for (i = 0; i < ARRAY_SIZE(mt7620_mibs); ++i) {
u64 counter;
len += snprintf(buf + len, sizeof(buf) - len,
"%-11s: ", mt7620_mibs[i].name);
counter = get_mib_counter_7620(priv, i);
len += snprintf(buf + len, sizeof(buf) - len, "%llu\n",
counter);
}

val->value.s = buf;
val->len = len;
return 0;
}

The above function is used to get the value of the corresponding hardware
MT7620 register. Its logic is simple and does
not need additional explanation.

In addition, the MT7620 switch supports a number of
getattr / getattr and




NEXT




<s> ret_t rtl8367c_setAsicFlowControlSystemDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SYS_OFF, RTL8367C_FLOWCTRL_FCOFF_SYS_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SYS_ON, RTL8367C_FLOWCTRL_FCOFF_SYS_ON_MASK, onThreshold);

return retVal;
}

The above function is used to program on and off threshold values for SYS on and off flow control registers.

The following are the details on register RTL8367C_REG_FLOWCTRL_FCOFF_SYS_ON and RTL8




NEXT




<s> rtk_api_ret_t rtk_l2_localPktPermit_set(rtk_port_t port, rtk_enable_t permit)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if (permit >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicPortBlockSpa(rtk_switch_port_L2P_get(port), permit)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the SPAN permit function of a given port. It can be executed by a terminal or an
application.
/* To prevent a port from participating in the port to
be monitored when spanning the source port into a non-




NEXT




<s> static inline void md5_transform_helper(struct md5_ctx *ctx)
{
//le32_to_cpu_array(ctx->block, sizeof(ctx->block) / sizeof(u32));
md5_transform(ctx, ctx->hash, ctx->block);
}

The above function is used to update the 128 bit hash, and hashes the chunk
of bytes given to the functions using the 16 32 byte blocks which are
previously zero-padded.

md5_transform(ctx,




NEXT




<s> static inline void rttm_set_period(void __iomem *base, unsigned int period)
{
iowrite32(period, base + RTTM_DATA);
}

The above function is used to set the period attribute of the timer.

static inline void rttm_set_value(void __iomem *base, unsigned int nxt)
{
iowrite32(nxt, base + RTTM




NEXT




<s> void __init firebox_t10_pic_init(void)
{
struct mpic *mpic;

mpic = mpic_alloc(NULL, 0,
MPIC_BIG_ENDIAN | MPIC_SINGLE_DEST_CPU,
0, 256, " OpenPIC  ");

BUG_ON(mpic == NULL);
mpic_init(mpic);
}

The above function is used to initialize the PIC for the OpenPIC
emulation of the FB0520.  The last argument to this function must
be a string for the mpic driver to put in the "name" field of the
MP




NEXT




<s> ret_t rtl8367c_getAsicTrunkingHashTable(rtk_uint32 hashval, rtk_uint32* pPortId)
{
if(hashval > RTL8367C_TRUNKING_HASHVALUE_MAX)
return RT_ERR_OUT_OF_RANGE;

if(hashval >= 8)
return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL1, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH8_MASK<<((hashval-8)*2), pPortId);
else
return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL0, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH0_MASK<<(hashval*2), pPortId);
}

The above function is used to get Port Trunk Hash Map. We'll now discuss how we can get the port-id based on its tag.
For example, in an 8*16 configuration we're having to VLAN-Tags for each port.




NEXT




<s> static void _smi_readBit(rtk_uint32 bitLen, rtk_uint32 *rData)
{
rtk_uint32 u = 0;

/* change GPIO pin to Input only */
GPIO_DIRECTION_SET(smi_SDA, GPIO_DIR_IN);

for (*rData = 0; bitLen > 0; bitLen--)
{
CLK_DURATION(DELAY);

/* clocking */
GPIO_DATA_SET(smi_SCK, 1);
CLK_DURATION(DELAY);
GPIO_DATA_GET(smi_SDA, &u);
GPIO_DATA_SET(smi_SCK, 0);

*rData |= (u << (bitLen - 1));
}

/* change GPIO pin to Output only */
GPIO_DIRECTION_SET(smi_SDA, GPIO_DIR_OUT);
}

The above function is used to read data at bit level (start bit, 8 data bits
and a stop bit).

static void _smi_writeBit(rtk_uint32 bitLen, rtk_uint32 wData)
{




NEXT




<s> rtk_api_ret_t rtk_rate_egrBandwidthCtrlRate_set( rtk_port_t port, rtk_rate_t rate,  rtk_enable_t ifg_include)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(rtk_switch_isHsgPort(port) == RT_ERR_OK)
{
if ((rate > RTL8367C_QOS_RATE_INPUT_MAX_HSG) || (rate < RTL8367C_QOS_RATE_INPUT_MIN))
return RT_ERR_QOS_EBW_RATE ;
}
else
{
if ((rate > RTL8367C_QOS_RATE_INPUT_MAX) || (rate < RTL8367C_QOS_RATE_INPUT_MIN))
return RT_ERR_QOS_EBW_RATE ;
}

if (ifg_include >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicPortEgressRate(rtk_switch_port_L2P_get(port), rate>>3)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicPortEgressRateIfg(ifg_include)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure egress bandwidth control rate of specified port.
The configuration item of egress bandwidth control is bandwidth limit rate. The limit rate to access bandwidth will be applied to this port as egress bandwidth control rate. For e




NEXT




<s> rtk_api_ret_t rtk_stat_global_getAll(rtk_stat_global_cntr_t *pGlobal_cntrs)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pGlobal_cntrs)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicMIBsCounter(0,DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX, &pGlobal_cntrs->dot1dTpLearnedEntryDiscards)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get MAC learning entry drop count in table 4.16(1) DOT1D TP LEARNED ENTRY DISCARDS entry.

Function Description : get table entry of DOT1D TP LE




NEXT




<s> static int rtl83xx_alloc_egress_intf(struct rtl838x_switch_priv *priv, u64 mac, int vlan)
{
int free_mac = -1;
struct rtl838x_l3_intf intf;
u64 m;

mutex_lock(&priv->reg_mutex);
for (int i = 0; i < MAX_SMACS; i++) {
m = priv->r->get_l3_egress_mac(L3_EGRESS_DMACS + i);
if (free_mac < 0 && !m) {
free_mac = i;
continue;
}
if (m == mac) {
mutex_unlock(&priv->reg_mutex);
return i;
}
}

if (free_mac < 0) {
pr_err("No free egress interface, cannot offload\n");
return -1;
}

/* Set up default egress interface 1 */
intf.vid = vlan;
intf.smac_idx = free_mac;
intf.ip4_mtu_id = 1;
intf.ip6_mtu_id = 1;
intf.ttl_scope = 1; /* TTL */
intf.hl_scope = 1;  /* Hop Limit */
intf.ip4_icmp_redirect = intf.ip6_icmp_redirect = 2;  /* FORWARD */
intf.ip4_pbr_icmp_redirect = intf.ip6_pbr_icmp_redirect = 2; /* FORWARD; */
priv->r->set_l3_egress_intf(free_mac, &intf);

priv->r->set_l3_egress_mac(L3_EGRESS_DMACS + free_mac, mac);

mutex_unlock(&priv->reg_mutex);

return free_mac;
}

The above function is used to allocate free mac addrs which are
actually free RX queues in RTL8366B/C but there is a bug
that actually it is used to allocate free egress interfaces.

When we allocate e




NEXT




<s> rtk_api_ret_t rtk_trap_unmatchMacMoving_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if(enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicPortUnmatchedSaMoving(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the status of Port Unmatched SA Moving. It calls the corresponding register API to configure related fields. If it is successful, return RT_ERR_OK. When it is not successful, return a corresponding error code. The register type is




NEXT




<s> ar8327_led_destroy(struct ar8327_led *aled)
{
ar8327_led_unregister(aled);
kfree(aled);
}

The above function is used to destroy an LED device of AR8237 chip. The register unregistering function ar8327_led_unregister (struct ar8327_led *aled) will call LED driver’s core function. The LED




NEXT




<s> hostapd_rrm_nr_list(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct hostapd_data *hapd = get_hapd_from_object(obj);
struct hostapd_neighbor_entry *nr;
void *c;

hostapd_rrm_nr_enable(hapd);
blob_buf_init(&b, 0);

c = blobmsg_open_array(&b, "list");
dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry, list) {
void *cur;

if (!memcmp(nr->bssid, hapd->own_addr, ETH_ALEN))
continue;

cur = blobmsg_open_array(&b, NULL);
hostapd_rrm_print_nr(nr);
blobmsg_close_array(&b, cur);
}
blobmsg_close_array(&b, c);

ubus_send_reply(ctx, req, b.head);

return 0;
}

The above function is used to provide the list of Neighbor Reports (NR) under a specific object (the specific object is the same as what is used in the get_device_nr_list method for the object of get_device) to the controller, who sends




NEXT




<s> rtk_api_ret_t rtk_rldp_status_get(rtk_rldp_status_t *pStatus)
{
rtk_api_ret_t retVal;
ether_addr_t seed;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_getAsicRldpRandomNumber(&seed))!=RT_ERR_OK)
return retVal;
memcpy(&pStatus->id, &seed, sizeof(ether_addr_t));

return RT_ERR_OK;
} /* end of rtk_rldp_status_get */

The above function is used to retrieve the seed ID allocated for LAG.

The following describes the definition of rtl8367c_getAsicRldpRandomNumber.
/* get seedID */
static rtk_api_ret_t




NEXT




<s> static void sata_oxnas_tf_load(struct ata_port *ap,
const struct ata_taskfile *tf);
static void sata_oxnas_irq_on(struct ata_port *ap);
static void sata_oxnas_post_reset_init(struct ata_port *ap);

static int sata_oxnas_acquire_hw(struct ata_port *ap, int may_sleep,
int timeout_jiffies);
static void sata_oxnas_release_hw(struct ata_port *ap);

static const void *HW_LOCKER_UID = (void *)0xdeadbeef;

/***************************************************************************
* ASIC access
***************************************************************************/
static void wait_cr_ack(void __iomem *phy_base)
{
while ((ioread32(phy_base + PHY_STAT) >> 16) & 0x1f)
; /* wait for an ack bit to be set */
}

The above function is used to ensure that ATA_SUSPEND and ATA_RESET
commands have been correctly received.

static int sata_oxnas_write_fsw(struct ata_link *link,
struct ata_feature_




NEXT




<s> ret_t rtl8367c_setAsicPriorityDot1qRemapping(rtk_uint32 srcpriority, rtk_uint32 priority )
{
if((srcpriority > RTL8367C_PRIMAX) || (priority > RTL8367C_PRIMAX))
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBits(RTL8367C_QOS_1Q_PRIORITY_REMAPPING_REG(srcpriority), RTL8367C_QOS_1Q_PRIORITY_REMAPPING_MASK(srcpriority),priority);
}

The above function is used to set qos priority dot1q priority remapping table, and it accepts srcpriority and priority as inputs.

If srcpriority doesn’t exist in the 1Q priority remapping table, priority remapping will not be done for this




NEXT




<s> module_phy_driver(rtl83xx_phy_driver);

static struct mdio_device_id __maybe_unused rtl83xx_tbl[] = {
{ PHY_ID_MATCH_MODEL(PHY_ID_RTL8214FC) },
{ }
};

The above function is used to register a MDIO driver with the kernel. The MDIO driver is a generic interface for talking to I2C, SPI, and other I/O busses. The function takes three arguments from the I/O bus.

static




NEXT




<s> static int lq_deu_des_core (void *ctx_arg, u8 *out_arg, const u8 *in_arg,
u8 *iv_arg, u32 nbytes, int encdec, int mode);

struct des_ctx {
int controlr_M;
int key_length;
u8 iv[DES_BLOCK_SIZE];
u32 expkey[DES3_EDE_EXPKEY_WORDS];
};

The above function is used to implement the three modes of DES
encryption - Electronic Codebook Mode (ECB), Cipher Block Chaining
(CBC) And Cipher Feedback (CFB) modes. The same can be used to
dech




NEXT




<s> static int AT91F_LoadBoot(void)
{
//	volatile unsigned int crc1 = 0, crc2 = 0;
volatile unsigned int SizeToDownload = 0x21400;
volatile unsigned int AddressToDownload = AT91C_BOOT_ADDR;

#if 0
/* Read vector 6 to extract size to load */
if (read_dataflash(AT91C_BOOT_DATAFLASH_ADDR, 32,
(char *)AddressToDownload) != AT91C_DATAFLASH_OK)
{
printf("Bad Code Size\n");
return IMAGE_BAD_SIZE;
}
/* calculate the size to download */
SizeToDownload = *(int *)(AddressToDownload + AT91C_OFFSET_VECT6);
#endif

//	printf("\nLoad UBOOT from dataflash[%x] to SDRAM[%x]\n",
//	       AT91C_BOOT_DATAFLASH_ADDR, AT91C_BOOT_ADDR);
if (read_dataflash(AT91C_BOOT_DATAFLASH_ADDR, SizeToDownload + 8,
(char *)AddressToDownload) != AT91C_DATAFLASH_OK)
{
printf("F DF RD\n");
return IMAGE_READ_FAILURE;
}
#if 0
pAT91->CRC32((const unsigned char *)AT91C_BOOT_ADDR,
(unsigned int)SizeToDownload , (unsigned int *)&crc2);
crc1 = (int)(*(char *)(AddressToDownload + SizeToDownload)) +
(int)(*(char *)(AddressToDownload + SizeToDownload + 1) << 8) +
(int)(*(char *)(AddressToDownload + SizeToDownload + 2) << 16) +
(int)(*(char *)(AddressToDownload + SizeToDownload + 3) << 24);

/* Restore the value of Vector 6 */
*(int *)(AddressToDownload + AT91C_OFFSET_VECT6) =
*(int *)(AddressToDownload + SizeToDownload + 4);

if (crc1 != crc2) {
printf("DF CRC bad %x != %x\n",crc1,crc2);
return	IMAGE_CRC_ERROR;
}
#endif
return SUCCESS;
}

The above function is used to download the required bootrom from the dataflash
flash to the sdram.

static int AT91S_LoadBoot(void)
{
/* Reset the BOOT register */
pAT91->BOOTCR




NEXT




<s> static int mt7621_nfc_check_empty_page(struct nand_chip *nand, const u8 *buf)
{
struct mtd_info *mtd = nand_to_mtd(nand);
uint32_t i, j;
u8 *oobptr;

if (buf) {
for (i = 0; i < mtd->writesize; i++)
if (buf[i] != 0xff)
return 0;
}

for (i = 0; i < nand->ecc.steps; i++) {
oobptr = oob_fdm_ptr(nand, i);
for (j = 0; j < NFI_FDM_SIZE; j++)
if (oobptr[j] != 0xff)
return 0;
}

return 1;
}

The above function is used to check for empty bad blocks:

static void mt7621_mark_all_nonempty(struct mt7621_nand *nand)
{
struct nand_chip *this = &nand




NEXT




<s> static void AT91F_UndefHandler()
{
puts("IUD");
while (1);
}

The above function is used to replace the default "undefined" handler. This one simply displays "IUD" on the LCD

A few weeks ago, I saw what I think was an example that set the default undefined handler to AT91F_UndefHandler




NEXT




<s> void hostapd_ubus_notify_bss_transition_response(
struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 status_code,
u8 bss_termination_delay, const u8 *target_bssid,
const u8 *candidate_list, u16 candidate_list_len)
{
#ifdef CONFIG_WNM_AP
u16 i;

if (!hapd->ubus.obj.has_subscribers)
return;

if (!addr)
return;

blob_buf_init(&b, 0);
blobmsg_add_macaddr(&b, "address", addr);
blobmsg_add_u8(&b, "dialog-token", dialog_token);
blobmsg_add_u8(&b, "status-code", status_code);
blobmsg_add_u8(&b, "bss-termination-delay", bss_termination_delay);
if (target_bssid)
blobmsg_add_macaddr(&b, "target-bssid", target_bssid);

hostapd_ubus_notify_bss_transition_add_candidate_list(candidate_list, candidate_list_len);

ubus_notify(ctx, &hapd->ubus.obj, "bss-transition-response", b.head, -1);
#endif
}

The above function is used to send back a response to the notification sent out which the response is supposed to be in the same structure sent out to send the request. This function is currently unused in Linux. The structure used to send this notification is defined as below.

struct




NEXT




<s> static int button_hotplug_fill_event(struct bh_event *event)
{
int ret;

ret = bh_event_add_var(event, 0, "HOME=%s", "/");
if (ret)
return ret;

ret = bh_event_add_var(event, 0, "PATH=%s",
"/sbin:/bin:/usr/sbin:/usr/bin");
if (ret)
return ret;

ret = bh_event_add_var(event, 0, "SUBSYSTEM=%s", "button");
if (ret)
return ret;

ret = bh_event_add_var(event, 0, "ACTION=%s", event->action);
if (ret)
return ret;

ret = bh_event_add_var(event, 0, "BUTTON=%s", event->name);
if (ret)
return ret;

if (event->type == EV_SW) {
ret = bh_event_add_var(event, 0, "TYPE=%s", "switch");
if (ret)
return ret;
}

ret = bh_event_add_var(event, 0, "SEEN=%ld", event->seen);
if (ret)
return ret;

ret = bh_event_add_var(event, 0, "SEQNUM=%llu", uevent_next_seqnum());

return ret;
}

The above function is used to create a uevent. However it only works for the
USB devices which are plugged in and then plugged out. So I modified this
function to include other devices too.

static int button_hotplug_fill_event(




NEXT




<s> static int rtl8366rb_remove(struct platform_device *pdev)
{
struct rtl8366_smi *smi = platform_get_drvdata(pdev);

if (smi) {
rtl8366rb_switch_cleanup(smi);
platform_set_drvdata(pdev, NULL);
rtl8366_smi_cleanup(smi);
kfree(smi);
}

return 0;
}

The above function is used to unregister the platform for the PF chip and free up the device. At the end of the module, the drivers core will call the platform device de-registration.

This driver is just using a simple switch core for the demo purpose




NEXT




<s> ret_t rtl8367c_setAsicTrunkingFlood(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_FLOOD_OFFSET, enabled);
}

The above function is used to control the traffic flood of a trunk port





void rtl8367c_ethTrunk_receive(rtk_uint32 pkt_type, rtk_uint16 len)
{




NEXT




<s> static int ag71xx_remove(struct platform_device *pdev)
{
struct net_device *dev = platform_get_drvdata(pdev);
struct ag71xx *ag;

if (!dev)
return 0;

ag = netdev_priv(dev);
ag71xx_debugfs_exit(ag);
ag71xx_phy_disconnect(ag);
unregister_netdev(dev);
platform_set_drvdata(pdev, NULL);
return 0;
}

The above function is used to remove the ag71xx driver from the kernel, and is called when the hardware is hot-pluggable and the device is un-plugged. There are a few things done by this function:

Disconnect from the physical layer




NEXT




<s> rtk_api_ret_t rtk_igmp_protocol_get(rtk_port_t port, rtk_igmp_protocol_t protocol, rtk_igmp_action_t *pAction)
{
rtk_uint32      operation;
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if(protocol >= PROTOCOL_END)
return RT_ERR_INPUT;

if(pAction == NULL)
return RT_ERR_NULL_POINTER;

switch(protocol)
{
case PROTOCOL_IGMPv1:
if ((retVal = rtl8367c_getAsicIGMPv1Opeartion(rtk_switch_port_L2P_get(port), &operation))!=RT_ERR_OK)
return retVal;

break;
case PROTOCOL_IGMPv2:
if ((retVal = rtl8367c_getAsicIGMPv2Opeartion(rtk_switch_port_L2P_get(port), &operation))!=RT_ERR_OK)
return retVal;

break;
case PROTOCOL_IGMPv3:
if ((retVal = rtl8367c_getAsicIGMPv3Opeartion(rtk_switch_port_L2P_get(port), &operation))!=RT_ERR_OK)
return retVal;

break;
case PROTOCOL_MLDv1:
if ((retVal = rtl8367c_getAsicMLDv1Opeartion(rtk_switch_port_L2P_get(port), &operation))!=RT_ERR_OK)
return retVal;

break;
case PROTOCOL_MLDv2:
if ((retVal = rtl8367c_getAsicMLDv2Opeartion(rtk_switch_port_L2P_get(port), &operation))!=RT_ERR_OK)
return retVal;

break;
default:
return RT_ERR_INPUT;

}

switch(operation)
{
case PROTOCOL_OP_FLOOD:
*pAction = IGMP_ACTION_FORWARD;
break;
case PROTOCOL_OP_TRAP:
*pAction = IGMP_ACTION_TRAP2CPU;
break;
case PROTOCOL_OP_DROP:
*pAction = IGMP_ACTION_DROP;
break;
case PROTOCOL_OP_ASIC:
*pAction = IGMP_ACTION_ASIC;
break;
default:
return RT_ERR_FAILED;
}

return RT_ERR_OK;
}

The above function is used to get protocol operation of an port.

For more interface information to access MLD/IGMP protocol, please refer to related API specifications.</s>




NEXT




<s> rtl8367_sw_get_vlan_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8367_priv *priv = container_of(dev, struct rtl8367_priv, swdev);

val->value.i = priv->global_vlan_enable;

return 0;
}

The above function is used to set the VLAN feature of the chip. The value here is 0 or 1. When you call sw_get_vlan_enable(), you can get its value. After configuring the global VLAN feature, the VLAN configuration




NEXT




<s> static int hc_wlan_data_unpack(const u16 tag_id, const size_t tofs, size_t tlen,
void *outbuf, size_t *outlen)
{
const u8 *lbuf;
u32 magic;
int ret;

/* Caller ensure tlen > 0. tofs is aligned */
if ((tofs + tlen) > hc_buflen)
return -EIO;

lbuf = hc_buf + tofs;
magic = *(u32 *)lbuf;

ret = -ENODATA;
switch (magic) {
case RB_MAGIC_LZOR:
/* Skip magic */
lbuf += sizeof(magic);
tlen -= sizeof(magic);
ret = hc_wlan_data_unpack_lzor(tag_id, lbuf, tlen, outbuf, outlen);
break;
case RB_MAGIC_ERD:
/* Skip magic */
lbuf += sizeof(magic);
tlen -= sizeof(magic);
ret = hc_wlan_data_unpack_erd(tag_id, lbuf, tlen, outbuf, outlen);
break;
default:
/*
* If the RB_ID_WLAN_DATA payload doesn't start with a
* magic number, the payload itself is the raw RLE-encoded
* calibration data. Only RB_WLAN_ERD_ID_SOLO makes sense here.
*/
if (RB_WLAN_ERD_ID_SOLO == tag_id) {
ret = routerboot_rle_decode(lbuf, tlen, outbuf, outlen);
if (ret)
pr_debug(RB_HC_PR_PFX "RLE decoding error (%d)\n", ret);
}
break;
}

return ret;
}

The above function is used to decode one specific packet type. Here's an overview of the entire flow of WIFI packets:

1. The upper host OS gets a new RB_ID_WLAN_DATA packet over a SIO interface. It contains:




NEXT




<s> static int rtl930x_pie_rule_write(struct rtl838x_switch_priv *priv, int idx, struct pie_rule *pr)
{
/* Access IACL table (2) via register 0 */
struct table_reg *q = rtl_table_get(RTL9300_TBL_0, 2);
u32 r[19];
int block = idx / PIE_BLOCK_SIZE;
u32 t_select = sw_r32(RTL930X_PIE_BLK_TMPLTE_CTRL(block));

pr_debug("%s: %d, t_select: %08x\n", __func__, idx, t_select);

for (int i = 0; i < 19; i++)
r[i] = 0;

if (!pr->valid) {
rtl_table_write(q, idx);
rtl_table_release(q);
return 0;
}
rtl930x_write_pie_fixed_fields(r, pr);

pr_debug("%s: template %d\n", __func__, (t_select >> (pr->tid * 4)) & 0xf);
rtl930x_write_pie_templated(r, pr, fixed_templates[(t_select >> (pr->tid * 4)) & 0xf]);

rtl930x_write_pie_action(r, pr);

/*	rtl930x_pie_rule_dump_raw(r); */

for (int i = 0; i < 19; i++)
sw_w32(r[i], rtl_table_data(q, i));

rtl_table_write(q, idx);
rtl_table_release(q);

return 0;
}

The above function is used to change values of the IE templates and Action types of PIE rules.

The following is what the Action Type part does:
sw_w32(r[18], PIE_ACTION(pr->action));

This




NEXT




<s> ar8xxx_sw_get_port_stats(struct switch_dev *dev, int port,
struct switch_port_stats *stats)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
u64 *mib_stats;

if (!ar8xxx_has_mib_counters(priv) || !priv->mib_poll_interval)
return -EOPNOTSUPP;

if (!(priv->chip->mib_rxb_id || priv->chip->mib_txb_id))
return -EOPNOTSUPP;

if (port >= dev->ports)
return -EINVAL;

mutex_lock(&priv->mib_lock);

mib_stats = &priv->mib_stats[port * priv->chip->num_mibs];

stats->tx_bytes = mib_stats[priv->chip->mib_txb_id];
stats->rx_bytes = mib_stats[priv->chip->mib_rxb_id];

mutex_unlock(&priv->mib_lock);
return 0;
}

The above function is used to get a set of port counters that are not related to the hardware. They are specific to the software design and can have different meaning for different platforms. But since there is no generic mechanism to query different platforms to discover those details of the counters




NEXT




<s> ret_t rtl8367c_getAsicCputagRxMinLength(rtk_uint32 *pMode)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_RXBYTECOUNT_OFFSET, pMode);
}

The above function is used to get AsicCputagRxMinLength function code that is part of OAM-PPP-OAM-MIB definition.
This function returns the minimal number of bytes for the length field in the received RX packet.






NEXT




<s> static inline int b53_prepare_reg_access(struct spi_device *spi, u8 page)
{
int ret = b53_spi_clear_status(spi);

if (ret)
return ret;

return b53_spi_set_page(spi, page);
}

The above function is used to setup the SPI slave for register access.
First it clears all errors and status codes.

Then it does some setup for the next sequence including setting the page register and setting the SPI_REG_ADDR bits.

Now, if




NEXT




<s> static int b53_global_apply_config(struct switch_dev *dev)
{
struct b53_device *priv = sw_to_b53(dev);

/* disable switching */
b53_set_forwarding(priv, 0);

b53_apply(priv);

/* enable switching */
b53_set_forwarding(priv, 1);

return 0;
}

The above function is used to process global configs and applies them
to the device. Unfortunately, one issue here is that when you apply a
global config, this also affects any configs that have been applied to
the device. e.g. A global config change




NEXT




<s> static u16 find_valid_block(u16 block)
{
u8 fdm[4];
int ret;
int loop = 0;

retry:
if (block >= bmtd.total_blks)
return 0;

ret = bbt_nand_read(blk_pg(block), bmtd.data_buf, bmtd.pg_size,
fdm, sizeof(fdm));
/* Read the 1st byte of FDM to judge whether it's a bad
* or not
*/
if (ret || fdm[0] != 0xff) {
pr_info("nand: found bad block 0x%x\n", block);
if (loop >= bmtd.bb_max) {
pr_info("nand: FATAL ERR: too many bad blocks!!\n");
return 0;
}

loop++;
block++;
goto retry;
}

return block;
}

The above function is used to find out a bad block. When the block_map
becomes full and the find_valid_block returns, it will return 0 means there
is no valid block on the nand.
So, when the host detects it




NEXT




<s> static irqreturn_t aw9523_irq_thread_func(int irq, void *dev_id)
{
struct aw9523 *awi = (struct aw9523 *)dev_id;
unsigned long n, val = 0;
unsigned long changed_gpio;
unsigned int tmp, port_pin, i, ret;

for (i = 0; i < AW9523_NUM_PORTS; i++) {
port_pin = i * AW9523_PINS_PER_PORT;
ret = regmap_read(awi->regmap,
AW9523_REG_IN_STATE(port_pin),
&tmp);
if (ret)
return ret;
val |= (u8)tmp << (i * 8);
}

/* Handle GPIO input release interrupt as well */
changed_gpio = awi->irq->cached_gpio ^ val;
awi->irq->cached_gpio = val;

/*
* To avoid up to four *slow* i2c reads from any driver hooked
* up to our interrupts, just check for the irq_find_mapping
* result: if the interrupt is not mapped, then we don't want
* to care about it.
*/
for_each_set_bit(n, &changed_gpio, awi->gpio.ngpio) {
tmp = irq_find_mapping(awi->gpio.irq.domain, n);
if (tmp <= 0)
continue;
handle_nested_irq(tmp);
}

return IRQ_HANDLED;
}

The above function is used to handle the GPIO interrupt on the BeagleBone Black, but it really has little to do with the GPIO. What the above code does is to do nothing at all!</s>




NEXT




<s> static void adm6996_gpio_write(struct adm6996_priv *priv, int cs, char *buf, unsigned int bits)
{
int i, len = (bits + 7) / 8;
u8 mask;

gpio_set_value(priv->eecs, cs);
udelay(EECK_EDGE_TIME);

/* Byte assemble from MSB to LSB */
for (i = 0; i < len; i++) {
/* Bit bang from MSB to LSB */
for (mask = 0x80; mask && bits > 0; mask >>= 1, bits --) {
/* Clock low */
gpio_set_value(priv->eesk, 0);
udelay(EECK_EDGE_TIME);

/* Output on rising edge */
gpio_set_value(priv->eedi, (mask & buf[i]));
udelay(EEDI_SETUP_TIME);

/* Clock high */
gpio_set_value(priv->eesk, 1);
udelay(EECK_EDGE_TIME);
}
}

/* Clock low */
gpio_set_value(priv->eesk, 0);
udelay(EECK_EDGE_TIME);

if (cs)
gpio_set_value(priv->eecs, 0);
}

The above function is used to write a GPIO bit (bit to be sent by eeprom) into the chip.
We take the bit we want to send
We set up the GPIO pins
We send the bit from MSB (Most Significant Byte)




NEXT




<s> static inline int fe_cal_txd_req(struct sk_buff *skb)
{
struct sk_buff *head = skb;
int i, nfrags = 0;
skb_frag_t *frag;

next_frag:
nfrags++;
if (skb_is_gso(skb)) {
for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
frag = &skb_shinfo(skb)->frags[i];
nfrags += DIV_ROUND_UP(skb_frag_size(frag), TX_DMA_BUF_LEN);
}
} else {
nfrags += skb_shinfo(skb)->nr_frags;
}

skb = fe_next_frag(head, skb);
if (skb)
goto next_frag;

return DIV_ROUND_UP(nfrags, 2);
}

The above function is used to calculate how much Tx data buffer the socket is sending and divide by 4.</s>




NEXT




<s> int rtl8366_sw_get_vlan_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

if (attr->ofs > 2)
return -EINVAL;

if (attr->ofs == 1)
val->value.i = smi->vlan_enabled;
else
val->value.i = smi->vlan4k_enabled;

return 0;
}

The above function is used to get some info from hardware that belongs to
a switch driver, the smi->vlan_enabled and smi->vlan4k_enabled are the
only two values that belong to the driver. The other two values are from





NEXT




<s> BigIntegerCmpInt(c1, c2)
BigInteger c1;
unsigned int c2;
{
BIGNUM * a = BN_new();
int rv;
BN_set_word(a, c2);
rv = BN_cmp(c1, a);
BN_free(a);
return rv;
}

The above function is used to compare BigInteger's to int's, for instance the comparison "bigint = 8" or "bigint -= 4".

In gc_compare_int BIGNUM_cmp is used, but in BIGN




NEXT




<s> ret_t rtl8367c_getAsicIGMPQueryInterval(rtk_uint32 *pinterval)
{
ret_t   retVal;
rtk_uint32  value;

/* Query Interval */
retVal = rtl8367c_getAsicReg(RTL8367C_REG_IGMP_MLD_CFG2, &value);
if(retVal != RT_ERR_OK)
return retVal;

*pinterval = value;

return RT_ERR_OK;
}

The above function is used to get the query interval of IGMP protocol, e.g. The default value of query interval is 125.</s>




NEXT




<s> static void __md5_Pad(struct MD5Context *);
static void __md5_Final(unsigned char [16], struct MD5Context *);
static void __md5_Transform(uint32_t [4], const unsigned char [64]);


#define MD5_MAGIC_STR "$1$"
#define MD5_MAGIC_LEN (sizeof(MD5_MAGIC_STR) - 1)
static const unsigned char __md5__magic[] = MD5_MAGIC_STR;


#ifdef i386
#define __md5_Encode memcpy
#define __md5_Decode memcpy
#else /* i386 */

/*
* __md5_Encodes input (uint32_t) into output (unsigned char). Assumes len is
* a multiple of 4.
*/
static void
__md5_Encode(unsigned char *output, uint32_t *input, unsigned int len)
{
unsigned int i, j;

for (i = 0, j = 0; j < len; i++, j += 4) {
output[j] = input[i];
output[j+1] = (input[i] >> 8);
output[j+2] = (input[i] >> 16);
output[j+3] = (input[i] >> 24);
}
}

The above function is used to convert uint32_t values into unsigned char
values. I've seen the same thing done, without casting, as:

output[j] = input[i];
output[j+1] = (input[i




NEXT




<s> static u64 disable_polling(int port)
{
u64 saved_state;

mutex_lock(&poll_lock);

switch (soc_info.family) {
case RTL8380_FAMILY_ID:
saved_state = sw_r32(RTL838X_SMI_POLL_CTRL);
sw_w32_mask(BIT(port), 0, RTL838X_SMI_POLL_CTRL);
break;
case RTL8390_FAMILY_ID:
saved_state = sw_r32(RTL839X_SMI_PORT_POLLING_CTRL + 4);
saved_state <<= 32;
saved_state |= sw_r32(RTL839X_SMI_PORT_POLLING_CTRL);
sw_w32_mask(BIT(port % 32), 0,
RTL839X_SMI_PORT_POLLING_CTRL + ((port >> 5) << 2));
break;
case RTL9300_FAMILY_ID:
saved_state = sw_r32(RTL930X_SMI_POLL_CTRL);
sw_w32_mask(BIT(port), 0, RTL930X_SMI_POLL_CTRL);
break;
case RTL9310_FAMILY_ID:
pr_warn("%s not implemented for RTL931X\n", __func__);
break;
}

mutex_unlock(&poll_lock);

return saved_state;
}

The above function is used to disable polling for interrupt by clearing the bit of

Interrupt Enable (IE) Register

which is

port

IE[bit7]

for RTL9300/RTL9320/




NEXT




<s> rtk_api_ret_t rtk_l2_ipVidMcastAddr_add(rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pIpVidMcastAddr)
return RT_ERR_NULL_POINTER;

/* check port mask */
RTK_CHK_PORTMASK_VALID(&pIpVidMcastAddr->portmask);

if (pIpVidMcastAddr->vid > RTL8367C_VIDMAX)
return RT_ERR_L2_VID;

if( (pIpVidMcastAddr->dip & 0xF0000000) != 0xE0000000)
return RT_ERR_INPUT;

/* Get Physical port mask */
if ((retVal = rtk_switch_portmask_L2P_get(&pIpVidMcastAddr->portmask, &pmask)) != RT_ERR_OK)
return retVal;

memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
l2Table.sip = pIpVidMcastAddr->sip;
l2Table.dip = pIpVidMcastAddr->dip;
l2Table.l3lookup = 1;
l2Table.l3vidlookup = 1;
l2Table.l3_vid = pIpVidMcastAddr->vid;
method = LUTREADMETHOD_MAC;
retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
if (RT_ERR_OK == retVal)
{
l2Table.sip = pIpVidMcastAddr->sip;
l2Table.dip = pIpVidMcastAddr->dip;
l2Table.mbr = pmask;
l2Table.nosalearn = 1;
l2Table.l3lookup = 1;
l2Table.l3vidlookup = 1;
l2Table.l3_vid = pIpVidMcastAddr->vid;
if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
return retVal;

pIpVidMcastAddr->address = l2Table.address;
return RT_ERR_OK;
}
else if (RT_ERR_L2_ENTRY_NOTFOUND == retVal)
{
memset(&l2Table, 0, sizeof(rtl8367c_luttb));
l2Table.sip = pIpVidMcastAddr->sip;
l2Table.dip = pIpVidMcastAddr->dip;
l2Table.mbr = pmask;
l2Table.nosalearn = 1;
l2Table.l3lookup = 1;
l2Table.l3vidlookup = 1;
l2Table.l3_vid = pIpVidMcastAddr->vid;
if ((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
return retVal;

pIpVidMcastAddr->address = l2Table.address;

method = LUTREADMETHOD_MAC;
retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
if (RT_ERR_L2_ENTRY_NOTFOUND == retVal)
return     RT_ERR_L2_INDEXTBL_FULL;
else
return retVal;

}
else
return retVal;
}

The above function is used to set up an L2 multicast address and a virtual local area network identifier (VLAN) identifier for a logical interface or a range of logical interface. When a multicast packet is to be forwarded on a given logical interface, an




NEXT




<s> static int msp430_pattern_clear(struct led_classdev *ldev)
{
msp430_brightness_set(ldev, LED_OFF);

return 0;
}

The above function is used to clear the LEDs. Currently the LED brightness is
changed via the `msp430_brightness_set` routine and this
requires us to call `msp430_pattern_blink` prior




NEXT




<s> static void rtl931x_create_tx_header(struct p_hdr *h, unsigned int dest_port, int prio)
{
h->cpu_tag[0] = 0x8000;  /* CPU tag marker */
h->cpu_tag[1] = h->cpu_tag[2] = 0;
h->cpu_tag[3] = 0;
h->cpu_tag[4] = h->cpu_tag[5] = h->cpu_tag[6] = h->cpu_tag[7] = 0;
if (dest_port >= 32) {
dest_port -= 32;
h->cpu_tag[4] = BIT(dest_port) >> 16;
h->cpu_tag[5] = BIT(dest_port) & 0xffff;
} else {
h->cpu_tag[6] = BIT(dest_port) >> 16;
h->cpu_tag[7] = BIT(dest_port) & 0xffff;
}

/* Enable (AS_QID) and set priority queue (QID) */
if (prio >= 0)
h->cpu_tag[2] = (BIT(5) | (prio & 0x1f)) << 8;
}

The above function is used to create the Tx header for a packet. This function creates the CPU_tag of the packet and if the destination port is more that 31 then it assigns the same in the CPU_tag. Also if there is a priority assigned to




NEXT




<s> static void rtl839x_enable_mcast_flood(int port, bool enable)
{

}

The above function is used to control promiscuous mode of a port. When it is enabled, the port works in promiscuous mode, all data sent to or receive from this port will be dump to NIC level.

When the device is in prom




NEXT




<s> static void mt7620_tx_dma(struct fe_tx_dma *txd)
{
}

The above function is used to enable the transmission of packets via DMA (Direct Memory Access). It is used in the mt7620_tx_dma function which is part of the mt7620 driver for the Madwifi Project. The mt762




NEXT




<s> DSL_DEV_MeiError_t DSL_BSP_Showtime (DSL_DEV_Device_t *, DSL_uint32_t, DSL_uint32_t);
DSL_DEV_MeiError_t DSL_BSP_AdslLedInit (DSL_DEV_Device_t *, DSL_DEV_LedId_t, DSL_DEV_LedType_t, DSL_DEV_LedHandler_t);
//DSL_DEV_MeiError_t DSL_BSP_AdslLedSet (DSL_DEV_Device_t *, DSL_DEV_LedId_t, DSL_DEV_LedMode_t);
DSL_DEV_MeiError_t DSL_BSP_MemoryDebugAccess (DSL_DEV_Device_t *, DSL_BSP_MemoryAccessType_t, DSL_uint32_t, DSL_uint32_t*, DSL_uint32_t);
DSL_DEV_MeiError_t DSL_BSP_SendCMV (DSL_DEV_Device_t *, u16 *, int, u16 *);

int DSL_BSP_KernelIoctls (DSL_DEV_Device_t *, unsigned int, unsigned long);

static DSL_DEV_MeiError_t IFX_MEI_RunAdslModem (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_CpuModeSet (DSL_DEV_Device_t *, DSL_DEV_CpuMode_t);
static DSL_DEV_MeiError_t IFX_MEI_DownloadBootCode (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_ArcJtagEnable (DSL_DEV_Device_t *, int);
static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to notify  to ATM subsystem and it can be used by the other platform module.
This function is called in the bsp/lib/dev/dsl/dsl_mib.c in DSL_DRV_Showtime




NEXT




<s> BigIntegerModExpInt(prod, v, u, n);
res = BigIntegerFromInt(0);
BigIntegerModMul(res, prod, A, n);

BigIntegerFree(A);
BigIntegerFree(v);
BigIntegerFree(prod);

if(BigIntegerCmpInt(res, 1) <= 0) {   /* Check for Av^u == 1 (mod n) */
BigIntegerFree(res);
BigIntegerFree(b);
BigIntegerFree(n);
return NULL;
}

The above function is used to generate strong prime factors of a large prime, "n". This procedure produces the maximum number of strong prime factors possible.

How is the above procedure working so well?</s>




NEXT




<s> static int wlc_ifname(wlc_param param, void *data, void *value)
{
char *val = (char *) value;
int ret = 0;

if (param & SET) {
if (strlen(val) < 16)
strcpy(interface, val);
else ret = -1;
}
if (param & GET) {
strcpy(val, interface);
}

return ret;
}

The above function is used to get and set the interface parameter. The current implementation (i.e. 4.0.0.0), however, does not include this parameter. When the parameter is defined in the next ACLD, the function will be included in




NEXT




<s> roulette()
{
#ifdef OLD_TRUERAND
if (setjmp(env)) {
count ^= (count>>3) ^ (count>>6) ^ ocount;
count &= 0x7;
ocount=count;
buffer = (buffer<<3) ^ count;
return buffer;
}
#else
done = 0;
#endif
(void) signal(SIGALRM, interrupt);
count = 0;
tick();
#ifdef OLD_TRUERAND
for (;;)
#else
while(done == 0)
#endif
count++;        /* about 1 MHz on VAX 11/780 */
#ifndef OLD_TRUERAND
count ^= (count>>3) ^ (count>>6) ^ ocount;
count &= 0x7;
ocount=count;
buffer = (buffer<<3) ^ count;
return buffer;
#endif
}

The above function is used to produce a uniformly distributed pseudo-random integer. The range is 0 <= n <=2^15-1 = 32767. It computes a 2's complement binary sequence.

int random ()





NEXT




<s> static void bcm6318_pcie_reset(struct bcm6318_pcie *priv)
{
u32 val;

reset_control_deassert(priv->reset_hard);

reset_control_assert(priv->reset);
reset_control_assert(priv->reset_core);
reset_control_assert(priv->reset_ext);
mdelay(10);

reset_control_deassert(priv->reset_ext);
mdelay(10);

reset_control_deassert(priv->reset);
mdelay(10);

val = __raw_readl(priv->base + PCIE_HARD_DEBUG_REG);
val &= ~HARD_DEBUG_SERDES_IDDQ;
__raw_writel(val, priv->base + PCIE_HARD_DEBUG_REG);
mdelay(10);

reset_control_deassert(priv->reset_core);
mdelay(200);
}

The above function is used to reset the PCie core and serdes.

The core itself is reset by deasserting the MGMT_RST# signal that is
used to assert the reset of all the other IPs by deasserting the
reset-




NEXT




<s> static int get_model(struct ip17xx_state *state)
{
int id1, id2;
int oui_id, model_no, rev_no, chip_no;

id1 = ip_phy_read(state, 0, 2);
id2 = ip_phy_read(state, 0, 3);
oui_id = (id1 << 6) | ((id2 >> 10) & 0x3f);
model_no = (id2 >> 4) & 0x3f;
rev_no = id2 & 0xf;
pr_debug("IP17xx: Identified oui=%06x model=%02x rev=%X\n", oui_id, model_no, rev_no);

if (oui_id != 0x0090c3)  // No other oui_id should have reached us anyway
return -ENODEV;

if (model_no == IP175A.MODEL_NO) {
state->regs = &IP175A;
} else if (model_no == IP175C.MODEL_NO) {
/*
*  Several models share the same model_no:
*  178C has more PHYs, so we try whether the device responds to a read from PHY5
*  175D has a new chip ID register
*  175C has neither
*/
if (ip_phy_read(state, 5, 2) == 0x0243) {
state->regs = &IP178C;
} else {
chip_no = ip_phy_read(state, 20, 0);
pr_debug("IP17xx: Chip ID register reads %04x\n", chip_no);
if (chip_no == 0x175d) {
state->regs = &IP175D;
} else {
state->regs = &IP175C;
}
}
} else {
pr_warn("IP17xx: Found an unknown IC+ switch with model number %02x, revision %X.\n", model_no, rev_no);
return -EPERM;
}
return 0;
}

The above function is used to determine the device’s model number and from this, which structure to use from a list I had already created. It’s much faster than using the switch_id.c file in the kernel.
#if defined(CONFIG_IP1




NEXT




<s> rtk_api_ret_t rtk_l2_agingEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLutDisableAging(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;

if(*pEnable == 1)
*pEnable = 0;
else
*pEnable = 1;

return RT_ERR_OK;
}

The above function is used to query whether L2 aging is enabled on Port x. If the function querying is successful, the L2 aging_enable_get is returned by the function. If the function fails, the return value of RT_ERROR_PORT_DISABLE is




NEXT




<s> static void olr_statistics(int fd, DSL_AccessDir_t direction) {
IOCTL_DIR(DSL_OlrStatistics_t, DSL_FIO_OLR_STATISTICS_GET, direction)

void *c = blobmsg_open_table(&b, "bitswap");
m_u32("requested", out.data.nBitswapRequested + out.data.nBitswapRequested);
m_u32("executed", out.data.nBitswapExecuted);
m_u32("rejected", out.data.nBitswapRejected);
m_u32("timeout", out.data.nBitswapTimeout);
blobmsg_close_table(&b, c);

c = blobmsg_open_table(&b, "sra");
m_u32("requested", out.data.nSraRequested);
m_u32("executed", out.data.nSraExecuted);
m_u32("rejected", out.data.nSraRejected);
m_u32("timeout", out.data.nSraTimeout);
blobmsg_close_table(&b, c);

c = blobmsg_open_table(&b, "sos");
m_u32("requested", out.data.nSosRequested);
m_u32("executed", out.data.nSosExecuted);
m_u32("rejected", out.data.nSosRejected);
m_u32("timeout", out.data.nSosTimeout);
blobmsg_close_table(&b, c);
}

The above function is used to print statistics about Distributed Streaming (DS).

You can use the DSL_ACCESS_OVERLAY for DS. Currently, the DS is only implemented in the RS side for now. Once the FQ side implementation is made




NEXT




<s> static void fe_reset_pending(struct fe_priv *priv)
{
struct net_device *dev = priv->netdev;
int err;

rtnl_lock();
fe_stop(dev);

err = fe_open(dev);
if (err) {
netif_alert(priv, ifup, dev,
"Driver up/down cycle failed, closing device.\n");
dev_close(dev);
}
rtnl_unlock();
}

The above function is used to restore the network interface to its previous state in the case that an exception has been detected. This is especially useful for resetting the network interface due to a network cable/Ethernet connection coming offline.

You can see it used in




NEXT




<s> static void _rtl8367c_aclRuleStSmi2User( rtl8367c_aclrule *pAclUser, rtl8367c_aclrulesmi *pAclSmi)
{
rtk_uint8 *care_ptr, *data_ptr;
rtk_uint8 care_tmp, data_tmp;
rtk_uint32 i;

pAclUser->data_bits.active_portmsk = (((pAclSmi->data_bits_ext.rule_info >> 1) & 0x0007) << 8) | ((pAclSmi->data_bits.rule_info >> 8) & 0x00FF);
pAclUser->data_bits.type = (pAclSmi->data_bits.rule_info & 0x0007);
pAclUser->data_bits.tag_exist = (pAclSmi->data_bits.rule_info & 0x00F8) >> 3;

care_ptr = (rtk_uint8*)&pAclSmi->care_bits;
data_ptr = (rtk_uint8*)&pAclSmi->data_bits;

for ( i = 0; i < sizeof(struct acl_rule_smi_st); i++)
{
care_tmp = *(care_ptr + i) ^ (*(data_ptr + i));
data_tmp = *(data_ptr + i);

*(care_ptr + i) = care_tmp;
*(data_ptr + i) = data_tmp;
}

care_ptr = (rtk_uint8*)&pAclSmi->care_bits_ext;
data_ptr = (rtk_uint8*)&pAclSmi->data_bits_ext;
care_tmp = (*care_ptr) ^ (*data_ptr);
data_tmp = (*data_ptr);
*care_ptr = care_tmp;
*data_ptr = data_tmp;

for(i = 0; i < RTL8367C_ACLRULEFIELDNO; i++)
pAclUser->data_bits.field[i] = pAclSmi->data_bits.field[i];

pAclUser->valid = pAclSmi->valid;

pAclUser->care_bits.active_portmsk = (((pAclSmi->care_bits_ext.rule_info >> 1) & 0x0007) << 8) | ((pAclSmi->care_bits.rule_info >> 8) & 0x00FF);
pAclUser->care_bits.type = (pAclSmi->care_bits.rule_info & 0x0007);
pAclUser->care_bits.tag_exist = (pAclSmi->care_bits.rule_info & 0x00F8) >> 3;

for(i = 0; i < RTL8367C_ACLRULEFIELDNO; i++)
pAclUser->care_bits.field[i] = pAclSmi->care_bits.field[i];
}

The above function is used to convert the fields of struct aclSmiRuleSt to struct aclRuleUserSt.</s>




NEXT




<s> void dc_ep_assert_device(struct dc_ep_priv *priv, u32 bits)
{
struct dc_aca *aca = to_aca(priv);

spin_lock(&aca->rcu_lock);
wr32_mask(0, bits, RCU_REQ);
spin_unlock(&aca->rcu_lock);
}

The above function is used to assert a request to the ACAA.  The
parameter bits is one or more of DC_ACA_X_REQ bits, set in the context
of the DC function that initiates the request.  In the case that this





NEXT




<s> bool rtl839x_decode_tag(struct p_hdr *h, struct dsa_tag *t)
{
/* cpu_tag[0] is reserved. Fields are off-by-one */
t->reason = h->cpu_tag[5] & 0x1f;
t->queue = (h->cpu_tag[4] & 0xe000) >> 13;
t->port = h->cpu_tag[1] & 0x3f;
t->crc_error = h->cpu_tag[4] & BIT(6);

pr_debug("Reason: %d\n", t->reason);
if ((t->reason >= 7 && t->reason <= 13) || /* NIC_RX_REASON_RMA */
(t->reason >= 23 && t->reason <= 25))  /* NIC_RX_REASON_SPECIAL_TRAP */
t->l2_offloaded = 0;
else
t->l2_offloaded = 1;

return t->l2_offloaded;
}

The above function is used to process the tag field in rx mbufs. A tagged
rx mbuf contains a 5-byte tag (starting at byte 1 if you count from
0), followed by rx data. The first byte in the tag is




NEXT




<s> static void rtl930x_set_igr_filter(int port,  enum igr_filter state)
{
sw_w32_mask(0x3 << ((port & 0xf)<<1), state << ((port & 0xf)<<1),
RTL930X_VLAN_PORT_IGR_FLTR + (((port >> 4) << 2)));
}

The above function is used to set the igre filter on the 930x, but what does is actually do. I am not finding a definition in the 9572 datasheet, so is there another document that defines the igr filter setting?




NEXT




<s> int	sata_oxnas_init_controller(struct ata_host *host)
{
return 0;
}

The above function is used to initialize SATA card in ATA_OXNAS. For some
reason, the function is simply returning 0 now, which bypasses a lot of
work that is to be done for proper initialization. Because of this, the




NEXT




<s> void rt2880_mdio_link_adjust(struct fe_priv *priv, int port)
{
u32 mdio_cfg;

if (!priv->link[0]) {
netif_carrier_off(priv->netdev);
netdev_info(priv->netdev, "link down\n");
return;
}

mdio_cfg = FE_MDIO_CFG_TX_CLK_SKEW_200 |
FE_MDIO_CFG_RX_CLK_SKEW_200 |
FE_MDIO_CFG_GP1_FRC_EN;

if (priv->phy->duplex[0] == DUPLEX_FULL)
mdio_cfg |= FE_MDIO_CFG_GP1_DUPLEX;

if (priv->phy->tx_fc[0])
mdio_cfg |= FE_MDIO_CFG_GP1_FC_TX;

if (priv->phy->rx_fc[0])
mdio_cfg |= FE_MDIO_CFG_GP1_FC_RX;

switch (priv->phy->speed[0]) {
case SPEED_10:
mdio_cfg |= FE_MDIO_CFG_GP1_SPEED_10;
break;
case SPEED_100:
mdio_cfg |= FE_MDIO_CFG_GP1_SPEED_100;
break;
case SPEED_1000:
mdio_cfg |= FE_MDIO_CFG_GP1_SPEED_1000;
break;
default:
BUG();
}

fe_w32(mdio_cfg, FE_MDIO_CFG);

netif_carrier_on(priv->netdev);
netdev_info(priv->netdev, "link up (%sMbps/%s duplex)\n",
rt2880_speed_str(priv),
(priv->phy->duplex[0] == DUPLEX_FULL) ? "Full" : "Half");
}

The above function is used to adjust the transmit clock frequency
based on the received data for adjusting link frequency.</s>




NEXT




<s> static void rt5350_rxcsum_config(bool enable)
{
if (enable)
fe_w32(fe_r32(RT5350_SDM_CFG) | (RT5350_SDM_ICS_EN |
RT5350_SDM_TCS_EN | RT5350_SDM_UCS_EN),
RT5350_SDM_CFG);
else
fe_w32(fe_r32(RT5350_SDM_CFG) & ~(RT5350_SDM_ICS_EN |
RT5350_SDM_TCS_EN | RT5350_SDM_UCS_EN),
RT5350_SDM_CFG);
}

The above function is used to write to the RT5350 chip to enable/disable the CRC generator in the device. When this CRC generator is enabled, it will check the entire received packet from the device for errors. Once errors are found, a checksum error will




NEXT




<s> static bool nmbm_erase_block_and_check(struct nmbm_instance *ni, uint32_t ba)
{
uint64_t addr, off;
bool success;
int ret;

success = nmbm_erase_phys_block(ni, ba2addr(ni, ba));
if (!success)
return false;

if (!ni->empty_page_ecc_ok)
return true;

/* Check every page to make sure there aren't too many bitflips */

addr = ba2addr(ni, ba);

for (off = 0; off < bmtd.blk_size; off += bmtd.pg_size) {
ret = nmbm_read_phys_page(ni, addr + off, ni->page_cache, NULL);
if (ret == -EBADMSG) {
/*
* empty_page_ecc_ok means the empty page is
* still protected by ECC. So reading pages with ECC
* enabled and -EBADMSG means there are too many
* bitflips that can't be recovered, and the block
* containing the page should be marked bad.
*/
nlog_err(ni,
"Too many bitflips in empty page at 0x%llx\n",
addr + off);
return false;
}
}

return true;
}

The above function is used to check if an erased block contains any non-zero bits.</s>




NEXT




<s> static int rtl8366s_mii_read(struct mii_bus *bus, int addr, int reg)
{
struct rtl8366_smi *smi = bus->priv;
u32 val = 0;
int err;

err = rtl8366s_read_phy_reg(smi, addr, 0, reg, &val);
if (err)
return 0xffff;

return val;
}

The above function is used to read value from MII register via
SMI bus.
SMI bus is a single 32-bit wide bus used to access on-chip device.

rtl8366_smi.c file has the




NEXT




<s> static int mirror_open(struct inode *inode, struct file *file)
{
return single_open(file, mirror_show, 0);
}

The above function is used to open the mirror file in the system.
The function single open is used as the callback function of file_operations in the mirror_open function. The file_operations acts as an I/O request broker, which routes the functions to the correct




NEXT




<s> const char *prop_get_type_name(enum prop_type type)
{
switch (type) {
case P_PROMPT:
return "prompt";
case P_COMMENT:
return "comment";
case P_MENU:
return "menu";
case P_DEFAULT:
return "default";
case P_CHOICE:
return "choice";
case P_SELECT:
return "select";
case P_IMPLY:
return "imply";
case P_RANGE:
return "range";
case P_SYMBOL:
return "symbol";
case P_RESET:
return "reset";
case P_UNKNOWN:
break;
}
return "unknown";
}

The above function is used to convert the indexes of the option_t enum
defined in menu.h to strings that can be displayed in the user interface.</s>




NEXT




<s> swlib_scan(struct switch_dev *dev)
{
struct attrlist_arg arg;

if (dev->ops || dev->port_ops || dev->vlan_ops)
return 0;

arg.atype = SWLIB_ATTR_GROUP_GLOBAL;
arg.dev = dev;
arg.id = dev->id;
arg.prev = NULL;
arg.head = &dev->ops;
swlib_call(SWITCH_CMD_LIST_GLOBAL, add_attr, add_id, &arg);

arg.atype = SWLIB_ATTR_GROUP_PORT;
arg.prev = NULL;
arg.head = &dev->port_ops;
swlib_call(SWITCH_CMD_LIST_PORT, add_attr, add_id, &arg);

arg.atype = SWLIB_ATTR_GROUP_VLAN;
arg.prev = NULL;
arg.head = &dev->vlan_ops;
swlib_call(SWITCH_CMD_LIST_VLAN, add_attr, add_id, &arg);

return 0;
}

The above function is used to scan a switch device and populate the internal data structs that contain information on the operations supported by the device. The switch_cmd_list_sw_ops call is invoked to scan through the different groups of the switch and to call the add




NEXT




<s> hostapd_parse_capab_blobmsg(struct sta_info *sta)
{
void *r, *v;

v = blobmsg_open_table(&b, "capabilities");

if (sta->vht_capabilities) {
r = blobmsg_open_table(&b, "vht");
hostapd_parse_vht_capab_blobmsg(sta->vht_capabilities);
blobmsg_close_table(&b, r);
}

/* ToDo: Add HT / HE capability parsing */

blobmsg_close_table(&b, v);
}

The above function is used to parse the Capabilities blobmsg that is received from the STA. As you can see, it has a nested blobmsg named “vht” which is responsible for parsing VHT (VHT1-3) and HT (HT2




NEXT




<s> mt7530_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
u32 member;
u32 etags;
int i;

val->len = 0;

if (val->port_vlan < 0 || val->port_vlan >= MT7530_NUM_VLANS)
return -EINVAL;

mt7530_vtcr(priv, 0, val->port_vlan);

member = mt7530_r32(priv, REG_ESW_VLAN_VAWD1);
member >>= 16;
member &= 0xff;

etags = mt7530_r32(priv, REG_ESW_VLAN_VAWD2);

for (i = 0; i < MT7530_NUM_PORTS; i++) {
struct switch_port *p;
int etag;

if (!(member & BIT(i)))
continue;

p = &val->value.ports[val->len++];
p->id = i;

etag = (etags >> (i * 2)) & 0x3;

if (etag == ETAG_CTRL_TAG)
p->flags |= BIT(SWITCH_PORT_FLAG_TAGGED);
else if (etag != ETAG_CTRL_UNTAG)
printk("vlan %d port %d egress tag control neither untag nor tag: %d.\n",
val->port_vlan, i, etag);
}

return 0;
}

The above function is used to get the list of ports whose frames (with VLAN tagged as
val->port_vlan) can be forwarded by the switch.

mt7530_vlan_rx_ctrl(struct switch_dev *




NEXT




<s> ret_t rtl8367c_getAsicIGMPPortMAXGroup(rtk_uint32 port, rtk_uint32 *max_group)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT01_MAX_GROUP + (port/2), RTL8367C_PORT0_MAX_GROUP_MASK << (RTL8367C_PORT1_MAX_GROUP_OFFSET * (port%2)), &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT89_MAX_GROUP + (port/2), RTL8367C_PORT0_MAX_GROUP_MASK << (RTL8367C_PORT1_MAX_GROUP_OFFSET * (port%2)), &value);
if(retVal != RT_ERR_OK)
return retVal;
}

*max_group = value;
return RT_ERR_OK;
}

The above function is used to retrieve the maximum group support for any port.

#include <linux/init.h>
#include <linux/module.h>
#include <linux/types.h>
#include <net/netlink.h




NEXT




<s> static void ip17xx_remove(struct phy_device *pdev)
{
struct ip17xx_state *state = pdev->priv;

if (state->registered)
unregister_switch(&state->dev);
kfree(state);
}

The above function is used to stop and remove the IPI2110_SWITCH driver after being deregistered.

static struct ip17xx_state *ip17xx_init(void)
{
int status;
struct




NEXT




<s> int rtl838x_write_phy(u32 port, u32 page, u32 reg, u32 val)
{
int err;
u32 v;
u32 park_page;

val &= 0xffff;
if (port > 31 || page > 4095 || reg > 31)
return -ENOTSUPP;

mutex_lock(&smi_lock);
err = rtl838x_smi_wait_op(100000);
if (err)
goto errout;

sw_w32(BIT(port), RTL838X_SMI_ACCESS_PHY_CTRL_0);
mdelay(10);

sw_w32_mask(0xffff0000, val << 16, RTL838X_SMI_ACCESS_PHY_CTRL_2);

park_page = sw_r32(RTL838X_SMI_ACCESS_PHY_CTRL_1) & ((0x1f << 15) | 0x2);
v = reg << 20 | page << 3 | 0x4;
sw_w32(v | park_page, RTL838X_SMI_ACCESS_PHY_CTRL_1);
sw_w32_mask(0, 1, RTL838X_SMI_ACCESS_PHY_CTRL_1);

err = rtl838x_smi_wait_op(100000);
if (err)
goto errout;

err = 0;

errout:
mutex_unlock(&smi_lock);

return err;
}

The above function is used to write data to the PHY register. It assumes that SMI is on and initialized, and PHY control state is setup properly before calling

We had to use it to write into the PHY page that is not within the default page setting




NEXT




<s> static inline void clear_share_buffer(void);

#define IFX_PMU_MODULE_PPE_SLL01  BIT(19)
#define IFX_PMU_MODULE_PPE_TC     BIT(21)
#define IFX_PMU_MODULE_PPE_EMA    BIT(22)
#define IFX_PMU_MODULE_PPE_QSB    BIT(18)
#define IFX_PMU_MODULE_AHBS       BIT(13)
#define IFX_PMU_MODULE_DSL_DFE    BIT(9)


static inline void init_pmu(void)
{
ltq_pmu_enable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_AHBS |
IFX_PMU_MODULE_DSL_DFE);

}

The above function is used to initialize PMU module.</s>




NEXT




<s> static void sprom_extract_r23(struct ssb_sprom *out, const u16 *in)
{
SPEX(boardflags_hi, SSB_SPROM2_BFLHI, 0xFFFF, 0);
SPEX(opo, SSB_SPROM2_OPO, SSB_SPROM2_OPO_VALUE, 0);
SPEX(pa1lob0, SSB_SPROM2_PA1LOB0, 0xFFFF, 0);
SPEX(pa1lob1, SSB_SPROM2_PA1LOB1, 0xFFFF, 0);
SPEX(pa1lob2, SSB_SPROM2_PA1LOB2, 0xFFFF, 0);
SPEX(pa1hib0, SSB_SPROM2_PA1HIB0, 0xFFFF, 0);
SPEX(pa1hib1, SSB_SPROM2_PA1HIB1, 0xFFFF, 0);
SPEX(pa1hib2, SSB_SPROM2_PA1HIB2, 0xFFFF, 0);
SPEX(maxpwr_ah, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_HI, 0);
SPEX(maxpwr_al, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_LO,
SSB_SPROM2_MAXP_A_LO_SHIFT);
}

The above function is used to extract the 2.2.3.0 ssb_sprom structure
from the 0x2000 ssb_sprom buffer.

The first 64 bytes is the 2.0.x s




NEXT




<s> static int AT91F_DisplayMenu(void)
{
int i, mci_present = 0;
printf("\nDF LOADER %s %s %s\n",AT91C_VERSION,__DATE__,__TIME__);
AT91F_DataflashPrintInfo();
mci_present = AT91F_MCI_Init();
for(i = 0; i < MAXMENU; i++) {
puts(menu_dataflash[i]);
}
return mci_present;
}

The above function is used to display the contents of the AT91C_MENU_DATAFLASH.

The contents of this file can be changed with the standard "EDIT" command "AT91F_EditAT91File("AT91




NEXT




<s> static void __exit nct5104d_gpio_exit(void)
{
platform_device_unregister(nct5104d_gpio_pdev);
platform_driver_unregister(&nct5104d_gpio_driver);
}

The above function is used to register the i2c driver and use the GPIOs as inputs and outputs.

The nct5104d_gpio_probe() function is then called when the driver is loaded, and it does the following:

-




NEXT




<s> ret_t rtl8367c_getAsicInterruptMask(rtk_uint32* pImr)
{
return rtl8367c_getAsicReg(RTL8367C_REG_INTR_IMR, pImr);
}

The above function is used to get the current ASIC interrupt-mask register setting.

The first argument is the pointer to the register setting, and second argument pImr is an output argument. It means that this function reads the current Asic Interrupt-mask register




NEXT




<s> ret_t rtl8367c_setAsicEee100M(rtk_uint32 port, rtk_uint32 enable)
{
rtk_api_ret_t   retVal;
rtk_uint32      regData;

if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if (enable > 1)
return RT_ERR_INPUT;

if((retVal = rtl8367c_getAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, &regData)) != RT_ERR_OK)
return retVal;

if(enable)
regData |= (0x0001 << 1);
else
regData &= ~(0x0001 << 1);

if((retVal = rtl8367c_setAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, regData)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set EEE mode of 100Base-T in Asic. If EEE is enabled, the function will set the enable bit in EEE_OCP_PHY_ADDR to one. Please refer to register table in Data sheet




NEXT




<s> static void hostapd_ubus_ref_inc(void)
{
ctx_ref++;
}

The above function is used to inc ref counter for ubus context. This is the function that is in use in hostapd_ubus_ref_exit(). The only problem is that function is never called because of the bug. There's no need for ref counter




NEXT




<s> static int wl_glue_bcma_probe(struct bcma_device *dev)
{
void *wldev;

if (!attach_cb)
{
pr_err("No attach callback registered\n");
return -ENOSYS;
}

if (dev->bus->hosttype != BCMA_HOSTTYPE_SOC)
{
pr_err("Unsupported BCMA bus type %d\n", dev->bus->hosttype);
return -EINVAL;
}

/*
* NB:
* 0x18000000 = BCMA_ADDR_BASE
* 0x1000     = BCMA_CORE_SIZE
*/

wldev = attach_cb(dev->id.manuf, dev->id.id, (ulong)dev->addr, dev, dev->irq);

if (!wldev)
{
pr_err("The attach callback failed, BCMA probe aborted\n");
return -ENODEV;
}

bcma_set_drvdata(dev, wldev);
return 0;
}

The above function is used to call attach_cb as it doesnt have the bus address attached to it.

It’s a simple driver with just some IOCTL’s defined it. Most of the work is done by the wl_glue_probe which




NEXT




<s> static int rtl8226_read_page(struct phy_device *phydev)
{
return __phy_read(phydev, RTL8XXX_PAGE_SELECT);
}

The above function is used to switch page for a
particular chip of phy.
In above function, __phy_read(....)is responsible for
switching the specified page.
It gets the specified chip of phydev and also the number which will




NEXT




<s> static void g997_xtu_system_enabling(int fd, standard_t *standard) {
IOCTL(DSL_G997_XTUSystemEnabling_t, DSL_FIO_G997_XTU_SYSTEM_ENABLING_STATUS_GET)

m_array("xtse", out.data.XTSE, DSL_G997_NUM_XTSE_OCTETS);

const char *str;
switch (get_annex(out.data.XTSE)) {
STR_CASE(ANNEX_A, "A")
STR_CASE(ANNEX_B, "B")
STR_CASE(ANNEX_C, "C")
STR_CASE(ANNEX_I, "I")
STR_CASE(ANNEX_J, "J")
STR_CASE(ANNEX_L, "L")
STR_CASE(ANNEX_M, "M")
default:
str = NULL;
break;
};
if (str)
m_str("annex", str);

*standard = get_standard(out.data.XTSE);

switch (*standard) {
STR_CASE(STD_T1_413, "T1.413")
STR_CASE(STD_TS_101_388, "TS 101 388")
STR_CASE(STD_G_992_1, "G.992.1")
STR_CASE(STD_G_992_2, "G.992.2")
STR_CASE(STD_G_992_3, "G.992.3")
STR_CASE(STD_G_992_4, "G.992.4")
STR_CASE(STD_G_992_5, "G.992.5")
STR_CASE(STD_G_993_1, "G.993.1")
STR_CASE(STD_G_993_2, "G.993.2")
default:
str = NULL;
break;
}
if (str)
m_str("standard", str);
}

The above function is used to retrieve configuration information for a given G997 XTSE. This function will only work if the XTU controller is enabled.</s>




NEXT




<s> void ringbuf_free(struct ringbuf *r)
{
free(r->buf);
memset(r, 0, sizeof(*r));
}

The above function is used to free Ringbuffers that aren't needed anymore. In some scenarios, your application knows in advance that it doesn't need a ringbuffer anymore. This function is provided exactly for this use case.

Example usage:

struct ring




NEXT




<s> static void ddr_issue_command(int commmand)
{
*(volatile UINT *) C_DDR_CMD_REG = commmand;
ddr_poll_until_not_busy();
}

The above function is used to issue ddr related commands to chip. But it looks very inefficient. I suspect the polling function does the same as previous command function in busy loop, so the function actually issue the command, let the CPU idle a while and then get the




NEXT




<s> builtin_platform_driver(clk_mt7988_topckgen_drv);

static const struct of_device_id of_match_clk_mt7988_mcusys[] = {
{
.compatible = "mediatek,mt7988-mcusys",
},
{}
};

The above function is used to register a platform driver so that it can be found at run-time when the device is matched with the device tree property in the
“dts” file. “MTK_DRV_ID” is the id of our platform driver. “




NEXT




<s> static int esw_set_port_bool(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
int idx = val->port_vlan;

if (idx < 0 || idx >= RT305X_ESW_NUM_PORTS ||
val->value.i < 0 || val->value.i > 1)
return -EINVAL;

switch (attr->id) {
case RT305X_ESW_ATTR_PORT_DISABLE:
esw->ports[idx].disable = val->value.i;
break;
case RT305X_ESW_ATTR_PORT_DOUBLETAG:
esw->ports[idx].doubletag = val->value.i;
break;
case RT305X_ESW_ATTR_PORT_UNTAG:
esw->ports[idx].untag = val->value.i;
break;
default:
return -EINVAL;
}

return 0;
}

The above function is used to set the port boolean attributes (disable, doubletag and untag).

The next task is to initialize the function pointers to the corresponding operations. The switch provides the following operations: query for the attribute of a port, get port info




NEXT




<s> static int rtl8366rb_get_vlan_mc(struct rtl8366_smi *smi, u32 index,
struct rtl8366_vlan_mc *vlanmc)
{
u32 data[3];
int err;
int i;

memset(vlanmc, '\0', sizeof(struct rtl8366_vlan_mc));

if (index >= RTL8366RB_NUM_VLANS)
return -EINVAL;

for (i = 0; i < 3; i++) {
err = rtl8366_smi_read_reg(smi,
RTL8366RB_VLAN_MC_BASE(index) + i,
&data[i]);
if (err)
return err;
}

vlanmc->vid = data[0] & RTL8366RB_VLAN_VID_MASK;
vlanmc->priority = (data[0] >> RTL8366RB_VLAN_PRIORITY_SHIFT) &
RTL8366RB_VLAN_PRIORITY_MASK;
vlanmc->untag = (data[1] >> RTL8366RB_VLAN_UNTAG_SHIFT) &
RTL8366RB_VLAN_UNTAG_MASK;
vlanmc->member = data[1] & RTL8366RB_VLAN_MEMBER_MASK;
vlanmc->fid = data[2] & RTL8366RB_VLAN_FID_MASK;

return 0;
}

The above function is used to get the VLAN Multicast configuration.

This function returns the VLAN number, priority, untagged status, member port
mask and VLAN Filter port(FID).
static int rtl8366rb_




NEXT




<s> int dsa_phy_read(struct dsa_switch *ds, int phy_addr, int phy_reg)
{
u32 val;
u32 offset = 0;
struct rtl838x_switch_priv *priv = ds->priv;

if ((phy_addr >= 24) &&
(phy_addr <= 27) &&
(priv->ports[24].phy == PHY_RTL838X_SDS)) {
if (phy_addr == 26)
offset = 0x100;
val = sw_r32(RTL838X_SDS4_FIB_REG0 + offset + (phy_reg << 2)) & 0xffff;
return val;
}

read_phy(phy_addr, 0, phy_reg, &val);
return val;
}

The above function is used to read the fib register
of SDS interface.

The SDS interface is shared by 4 ports, so 4 ports'
fib registers use the same register space.

The SDS register space is 0xE0




NEXT




<s> static int esw_set_alt_vlan_disable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

esw->alt_vlan_disable = val->value.i != 0;

return 0;
}

The above function is used to switch between vlan tagging and bridge
operation.

The switch is configured using an external file.

If we run the following commands, then it is configured properly. (I used
iplink to set the vlan id




NEXT




<s> ret_t rtl8367c_getAsicSvlanEgressUnassign(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UIFSEG_OFFSET, pEnabled);
}

The above function is used to check if the Egress Unassign in SVLAN is enabled. If a switch is configured to run VLAN then usually SVLAN function should be disabled . The following shows a sample of the get SVLAN Egress Unassign function is used.





NEXT




<s> int dc_ep_pinmux_get(struct dc_ep_priv *priv, u32 gpio, int *func)
{
struct dc_aca *aca = to_aca(priv);

if (gpio > aca->max_gpio)
return -EINVAL;

*func = rd32(PADC_MUX(gpio));
return 0;
}

The above function is used to read the pin multiplexer register associated
the given pin number in the DC system. This allows user to know whether
the given pin should be read or configured by any DC peripheral. It is
also a check to ensure that the user




NEXT




<s> static bool nmbn_write_verify_data(struct nmbm_instance *ni, uint64_t addr,
const void *data, uint32_t size)
{
uint64_t off = addr;
const uint8_t *ptr = data;
uint32_t sizeremain = size, chunksize, leading;
bool success;
int ret;

while (sizeremain) {
leading = off & (bmtd.pg_size - 1);
chunksize = bmtd.pg_size - leading;
if (chunksize > sizeremain)
chunksize = sizeremain;

/* Prepare page data. fill 0xff to unused region */
memset(ni->page_cache, 0xff, ni->rawpage_size);
memcpy(ni->page_cache + leading, ptr, chunksize);

success = nmbm_write_phys_page(ni, off - leading,
ni->page_cache, NULL);
if (!success)
return false;

/* Verify the data just written. ECC error indicates failure */
ret = nmbm_read_phys_page(ni, off - leading, ni->page_cache, NULL);
if (ret < 0)
return false;

if (memcmp(ni->page_cache + leading, ptr, chunksize))
return false;

off += chunksize;
ptr += chunksize;
sizeremain -= chunksize;
}

return true;
}

The above function is used to write a specified region of
data to the flash memory on the board, and checks that
the data is correct via a comparison of data written to and read
from flash memory. Errors in ECC encoding during the write
process would indicate




NEXT




<s> static int mtdsplit_parse_minor(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct minor_header hdr;
size_t hdr_len, retlen;
size_t rootfs_offset;
struct mtd_partition *parts;
int err;

hdr_len = sizeof(hdr);
err = mtd_read(master, 0, hdr_len, &retlen, (void *) &hdr);
if (err)
return err;

if (retlen != hdr_len)
return -EIO;

/* match header */
if (hdr.yaffs_type != YAFFS_OBJECT_TYPE_FILE)
return -EINVAL;

if (hdr.yaffs_obj_id != YAFFS_OBJECTID_ROOT)
return -EINVAL;

if (hdr.yaffs_sum_unused != YAFFS_SUM_UNUSED)
return -EINVAL;

if (memcmp(hdr.yaffs_name, YAFFS_NAME, sizeof(YAFFS_NAME)))
return -EINVAL;

err = mtd_find_rootfs_from(master, master->erasesize, master->size,
&rootfs_offset, NULL);
if (err)
return err;

parts = kzalloc(MINOR_NR_PARTS * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = 0;
parts[0].size = rootfs_offset;

parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = master->size - rootfs_offset;

*pparts = parts;
return MINOR_NR_PARTS;
}

The above function is used to partition MTD.</s>




NEXT




<s> static int rtl8367_probe(struct platform_device *pdev)
{
struct rtl8366_smi *smi;
int err;

smi = rtl8366_smi_probe(pdev);
if (IS_ERR(smi))
return PTR_ERR(smi);

smi->clk_delay = 1500;
smi->cmd_read = 0xb9;
smi->cmd_write = 0xb8;
smi->ops = &rtl8367_smi_ops;
smi->cpu_port = RTL8367_CPU_PORT_NUM;
smi->num_ports = RTL8367_NUM_PORTS;
smi->num_vlan_mc = RTL8367_NUM_VLANS;
smi->mib_counters = rtl8367_mib_counters;
smi->num_mib_counters = ARRAY_SIZE(rtl8367_mib_counters);

err = rtl8366_smi_init(smi);
if (err)
goto err_free_smi;

platform_set_drvdata(pdev, smi);

err = rtl8367_switch_init(smi);
if (err)
goto err_clear_drvdata;

return 0;

err_clear_drvdata:
platform_set_drvdata(pdev, NULL);
rtl8366_smi_cleanup(smi);
err_free_smi:
kfree(smi);
return err;
}

The above function is used to initial the register of RTL8366/8367 chip which provides basic information of chip resources as well. The specific initialization steps are as follows:

1, Allocate internal memory size.
2, Register GPIO and




NEXT




<s> void MD5_begin(MD5_CTX *ctx)
{
ctx->a = 0x67452301;
ctx->b = 0xefcdab89;
ctx->c = 0x98badcfe;
ctx->d = 0x10325476;

ctx->lo = 0;
ctx->hi = 0;
}

The above function is used to initializes the context being used for computing a hash by setting the value of the working variables to a known starting point.
A good implementation of this function would probably include the definition of a structure for the ctx variable to allow for better implementation of this




NEXT




<s> ar8xxx_mdiodev_probe(struct mdio_device *mdiodev)
{
const struct of_device_id *match;
struct ar8xxx_priv *priv;
struct switch_dev *swdev;
struct device_node *mdio_node;
int ret;

match = of_match_device(ar8xxx_mdiodev_of_match, &mdiodev->dev);
if (!match)
return -EINVAL;

priv = ar8xxx_create();
if (priv == NULL)
return -ENOMEM;

priv->mii_bus = mdiodev->bus;
priv->pdev = &mdiodev->dev;
priv->chip = (const struct ar8xxx_chip *) match->data;

ret = of_property_read_u32(priv->pdev->of_node, "qca,mib-poll-interval",
&priv->mib_poll_interval);
if (ret)
priv->mib_poll_interval = 0;

ret = ar8xxx_read_id(priv);
if (ret)
goto free_priv;

ret = ar8xxx_probe_switch(priv);
if (ret)
goto free_priv;

if (priv->chip->phy_read && priv->chip->phy_write) {
priv->sw_mii_bus = devm_mdiobus_alloc(&mdiodev->dev);
priv->sw_mii_bus->name = "ar8xxx-mdio";
priv->sw_mii_bus->read = ar8xxx_phy_read;
priv->sw_mii_bus->write = ar8xxx_phy_write;
priv->sw_mii_bus->priv = priv;
priv->sw_mii_bus->parent = &mdiodev->dev;
snprintf(priv->sw_mii_bus->id, MII_BUS_ID_SIZE, "%s",
dev_name(&mdiodev->dev));
mdio_node = of_get_child_by_name(priv->pdev->of_node, "mdio-bus");
ret = of_mdiobus_register(priv->sw_mii_bus, mdio_node);
if (ret)
goto free_priv;
}

swdev = &priv->dev;
swdev->alias = dev_name(&mdiodev->dev);

if (of_property_read_bool(priv->pdev->of_node, "qca,phy4-mii-enable")) {
priv->port4_phy = true;
swdev->ports--;
}

ret = register_switch(swdev, NULL);
if (ret)
goto free_priv;

pr_info("%s: %s rev. %u switch registered on %s\n",
swdev->devname, swdev->name, priv->chip_rev,
dev_name(&priv->mii_bus->dev));

mutex_lock(&ar8xxx_dev_list_lock);
list_add(&priv->list, &ar8xxx_dev_list);
mutex_unlock(&ar8xxx_dev_list_lock);

priv->use_count++;

ret = ar8xxx_start(priv);
if (ret)
goto err_unregister_switch;

dev_set_drvdata(&mdiodev->dev, priv);

return 0;

err_unregister_switch:
if (--priv->use_count)
return ret;

unregister_switch(&priv->dev);

free_priv:
ar8xxx_free(priv);
return ret;
}

The above function is used to probe ar8xxx ethereal onboard switch device driver
and also does the probe action to the ar8xxx switch device.
Developers can check this function to learn the code structure of driver probe
and probe action (ar




NEXT




<s> static int ip17xx_set_reg(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int new_reg = val->value.i;

if (new_reg < 0 || new_reg > 31)
state->proc_mii.m = (u16)-1;
else
state->proc_mii.m = (u16)new_reg;
return 0;
}

The above function is used to set data sent by set_reg to MII register.
The value MUST be between 0 and 31. If it isn't, then m is set to -1 in the switch struct so that the later call to m




NEXT




<s> static void rtl931x_write_mcast_pmask(int idx, u64 portmask)
{
u64 pm = portmask;

/* Access MC_PMSK (2) via register RTL9310_TBL_0 */
struct table_reg *q = rtl_table_get(RTL9310_TBL_0, 2);

pr_debug("%s: Index idx %d has portmask %016llx\n", __func__, idx, pm);
pm <<= 7;
sw_w32((u32)(pm >> 32), rtl_table_data(q, 0));
sw_w32((u32)pm, rtl_table_data(q, 1));
rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to set/get port mask of the mirror group,
but i see a problem here.

As RTL9310_TBL_0 is a 4-field table,
index could not be set out of ([




NEXT




<s> ar8xxx_phy_remove(struct phy_device *phydev)
{
struct ar8xxx_priv *priv = phydev->priv;

if (WARN_ON(!priv))
return;

phydev->priv = NULL;

mutex_lock(&ar8xxx_dev_list_lock);

if (--priv->use_count > 0) {
mutex_unlock(&ar8xxx_dev_list_lock);
return;
}

list_del(&priv->list);
mutex_unlock(&ar8xxx_dev_list_lock);

unregister_switch(&priv->dev);
ar8xxx_mib_stop(priv);
ar8xxx_free(priv);
}

The above function is used to remove a device from the chip. A call similar
to the one in this article is made in ar8xxx_phy_remove().

When a call is made to ar8xxx_phy_remove(), it will check if there are




NEXT




<s> static void show_all_key_names(struct tffs_key_name_table *key_names)
{
for (uint32_t i = 0; i < key_names->size; i++)
printf("%s\n", key_names->entries[i].val);
}

The above function is used to dump the currently added names of all the key entries in the key name table, i.e., the table which is used to provide a human-recognizable name for each key.

The function shown above is a very simple example of a




NEXT




<s> int rtl8366_sw_reset_switch(struct switch_dev *dev)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
int err;

err = rtl8366_reset(smi);
if (err)
return err;

err = smi->ops->setup(smi);
if (err)
return err;

err = rtl8366_smi_reset_vlan(smi);
if (err)
return err;

err = rtl8366_smi_enable_vlan(smi, 1);
if (err)
return err;

return rtl8366_smi_enable_all_ports(smi, 1);
}

The above function is used to enable the ports in a switch devic. After the enablement, the chip will do a series of resetting. I want to check the operation of those resetting. However, I have no idea that how to use gdb to check the




NEXT




<s> ar8327_sw_get_igmp_v3(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
u32 val_reg;

mutex_lock(&priv->reg_mutex);
val_reg = ar8xxx_read(priv, AR8327_REG_FRAME_ACK_CTRL1);
val->value.i = ((val_reg & AR8327_FRAME_ACK_CTRL_IGMP_V3_EN) != 0);
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to get the value of IGMPv3 setting in the firmware.</s>




NEXT




<s> static inline void ar934x_nfc_disable_hwecc(struct ar934x_nfc *nfc)
{
nfc->ctrl_reg &= ~AR934X_NFC_CTRL_ECC_EN;
nfc->ctrl_reg |= AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
}

The above function is used to disable HWECC in firmware in NXP Ar934x SoC.
It seems to be an unused function and hence disabled for this release. Will
include it later in the firmware.

Signed-off




NEXT




<s> static int sym_rel_comp(const void *sym1, const void *sym2)
{
const struct sym_match *s1 = sym1;
const struct sym_match *s2 = sym2;
int exact1, exact2;

/* Exact match:
* - if matched length on symbol s1 is the length of that symbol,
*   then this symbol should come first;
* - if matched length on symbol s2 is the length of that symbol,
*   then this symbol should come first.
* Note: since the search can be a regexp, both symbols may match
* exactly; if this is the case, we can't decide which comes first,
* and we fallback to sorting alphabetically.
*/
exact1 = (s1->eo - s1->so) == strlen(s1->sym->name);
exact2 = (s2->eo - s2->so) == strlen(s2->sym->name);
if (exact1 && !exact2)
return -1;
if (!exact1 && exact2)
return 1;

/* As a fallback, sort symbols alphabetically */
return strcmp(s1->sym->name, s2->sym->name);
}

The above function is used to sort the found symbols from the file before
merging them with the table.

It allows to know which is more relevant a symbol matching exactly, or
less relevant a shorter matching, or really unrelavant a really short
match




NEXT




<s> int rtl8366_smi_write_reg_noack(struct rtl8366_smi *smi, u32 addr, u32 data)
{
return __rtl8366_smi_write_reg(smi, addr, data, false);
}

The above function is used to send a write SMI message to the controller. The difference is the call to __rtl8366_smi_write_reg:

static u32 __rtl8366_smi_write_




NEXT




<s> static void g997_line_inventory(int fd) {
IOCTL_DIR(DSL_G997_LineInventory_t, DSL_FIO_G997_LINE_INVENTORY_GET, DSL_DOWNSTREAM)

m_array("vendor_id", out.data.G994VendorID, DSL_G997_LI_MAXLEN_VENDOR_ID);
m_vendor("vendor", out.data.G994VendorID);
m_array("system_vendor_id", out.data.SystemVendorID, DSL_G997_LI_MAXLEN_VENDOR_ID);
m_vendor("system_vendor", out.data.SystemVendorID);
m_array("version", out.data.VersionNumber, DSL_G997_LI_MAXLEN_VERSION);
m_array("serial", out.data.SerialNumber, DSL_G997_LI_MAXLEN_SERIAL);
}

The above function is used to retrieve inventory of the downstream DSL line and parse it:</s>




NEXT




<s> int mtd_check_open(const char *mtd)
{
struct mtd_info_user mtdInfo;
int fd;

fd = mtd_open(mtd, false);
if(fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd);
return -1;
}

if(ioctl(fd, MEMGETINFO, &mtdInfo)) {
fprintf(stderr, "Could not get MTD device info from %s\n", mtd);
close(fd);
return -1;
}
mtdsize = mtdInfo.size;
erasesize = mtdInfo.erasesize;
mtdtype = mtdInfo.type;

return fd;
}

The above function is used to check whether the given mount point has
been opened correctly. If this function returns -1, then your kernel
does not support the filesystem you are trying to mount.</s>




NEXT




<s> srg_led_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
struct device_node *np = client->dev.of_node, *child;
struct srg_led_ctrl *sysled_ctrl;

sysled_ctrl = devm_kzalloc(&client->dev, sizeof(*sysled_ctrl), GFP_KERNEL);
if (!sysled_ctrl)
return -ENOMEM;

sysled_ctrl->client = client;

mutex_init(&sysled_ctrl->lock);

i2c_set_clientdata(client, sysled_ctrl);

for_each_child_of_node(np, child) {
if (srg_led_init_led(sysled_ctrl, child))
continue;

msleep(5);
}

return srg_led_control_sync(sysled_ctrl);;
}

The above function is used to detect led and initialization. The first thing to be noted here is I2C device node.
Next thing is of node that will help in parsing of node tree and extracting the specific device node.

For a proper understanding ,we




NEXT




<s> hostapd_remove_iface_bss_conf(struct hostapd_config *iconf,
struct hostapd_bss_config *conf)
{
int i;

for (i = 0; i < iconf->num_bss; i++)
if (iconf->bss[i] == conf)
break;

if (i == iconf->num_bss)
return;

for (i++; i < iconf->num_bss; i++)
iconf->bss[i - 1] = iconf->bss[i];
iconf->num_bss--;
}

The above function is used to remove a bss_config from an existing conf struct
and rearrange the contents of the array as such.

There is a call to this function in hostapd_bss_event(83-87) in





NEXT




<s> static void aca_rxin_init(struct dc_ep_priv *priv,
struct aca_cfg_param *aca_rxin)
{
u32 val = 0;
struct aca_mem_layout *mem_layout = to_mem_layout(priv);
struct aca_hif_params *hif_params = to_hif_params(priv);
struct aca_hif_param *rxin_param = &hif_params->rxin;

if (aca_rxin->byteswap)
val = BYTE_SWAP_EN;

val |= (aca_rxin->hd_size_in_dw - 1)
| SM((aca_rxin->pd_size_in_dw - 1), PD_DESC_IN_DW);
wr32(val, RXIN_CONV_CFG);

/* SoC cumulative counter address */
wr32(aca_rxin->soc_cmlt_cnt_addr, GNRC_RXIN_CMLT_CNT_ADDR);

/* RXIN may not be used */
if (!(aca_rxin->soc_desc_base))
goto __RXIN_DONE;
/* SoC descriptors */
rxin_param->soc_desc_base = aca_rxin->soc_desc_base;
rxin_param->soc_desc_num = aca_rxin->soc_desc_num;

/* Ping/pong buffer */
rxin_param->pp_buf_base = (u32)priv->phymem
+ mem_layout->rxin_host_desc_base;

rxin_param->pp_buf_num = mem_layout->rxin_host_dnum;

/* PD ring */
rxin_param->pd_desc_base = (u32)priv->phymem
+ aca_rxin->pd_desc_base;
rxin_param->pd_desc_num = aca_rxin->pd_desc_num;

rxin_param->pd_desc_threshold = aca_rxin->pp_buf_desc_num;

__RXIN_DONE:
dev_dbg(priv->dev, "aca rxin init done\n");
}

The above function is used to set the parameters related to the ACA RXIN.
Here are descriptions of some parameters set here:

byte-swap

It sets bit 1 in RXIN_CONV_CFG register to enable byte swapping





NEXT




<s> static inline int gpio_src_set(struct dc_ep_dev *dev, u32 gpio, int val)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_gpio_src_set(dev->priv, gpio, val);
}

The above function is used to set GPIO output values by the hardware side,
which is to be mapped to a system GPIO. When the gpio_src_set fails,
we will re-set the sysfs attribute to its actual physical value.</s>




NEXT




<s> ar8327_sw_set_igmp_v3(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

mutex_lock(&priv->reg_mutex);
if (val->value.i)
ar8xxx_reg_set(priv, AR8327_REG_FRAME_ACK_CTRL1,
AR8327_FRAME_ACK_CTRL_IGMP_V3_EN);
else
ar8xxx_reg_clear(priv, AR8327_REG_FRAME_ACK_CTRL1,
AR8327_FRAME_ACK_CTRL_IGMP_V3_EN);
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to set igmpv3 in AR8327. AR8327 registers are mapped out of the switch device context.
AR8327 has two registers AR8327_FRAME_ACK_CTRL and AR8




NEXT




<s> static void ath79_set_pllval(struct ag71xx *ag)
{
u32 pll_reg = ag->pllreg[1];
u32 pll_val;

if (!ag->pllregmap)
return;

switch (ag->speed) {
case SPEED_10:
pll_val = ag->plldata[2];
break;
case SPEED_100:
pll_val = ag->plldata[1];
break;
case SPEED_1000:
pll_val = ag->plldata[0];
break;
default:
BUG();
}

if (pll_val)
regmap_write(ag->pllregmap, pll_reg, pll_val);
}

The above function is used to set PLL based on speed selected for the device. If pll_val is zero , PLL is to be switched off. I'm trying to figure out how pll register map and plldata is being populated based on speed




NEXT




<s> mtk_bmt_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
int retry_count = 0;
u16 orig_block = ofs >> bmtd.blk_shift;
u16 block;
int ret;

retry:
block = bmtd.ops->get_mapping_block(orig_block);
ret = bmtd._block_isbad(mtd, (loff_t)block << bmtd.blk_shift);
if (ret) {
if (mtk_bmt_remap_block(orig_block, block, bmtd.blk_size) &&
retry_count++ < 10)
goto retry;
}
return ret;
}

The above function is used to check if block is bad, and there is remap_func,
so I have add a simple remap test:
#define test_remap

In remap_func(), I have add 1 line code:
orig




NEXT




<s> ret_t rtl8367c_setRealKeepRemarkEn(rtk_uint32 enabled)
{
ret_t   retVal;

if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_1P_REMARK_BYPASS_REALKEEP_OFFSET, enabled)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the Real time keep remark bit, when we need to do the following things:

1. Set the Real time keep remark bit to turn on the remark feature if we need.
2. Set the Real time keep remark bit to turn




NEXT




<s> int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
{
unsigned char prop0;
if (size < LZMA_PROPERTIES_SIZE)
return LZMA_RESULT_DATA_ERROR;
prop0 = propsData[0];
if (prop0 >= (9 * 5 * 5))
return LZMA_RESULT_DATA_ERROR;
{
for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
propsRes->lc = prop0;
/*
unsigned char remainder = (unsigned char)(prop0 / 9);
propsRes->lc = prop0 % 9;
propsRes->pb = remainder / 5;
propsRes->lp = remainder % 5;
*/
}

#ifdef _LZMA_OUT_READ
{
int i;
propsRes->DictionarySize = 0;
for (i = 0; i < 4; i++)
propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
if (propsRes->DictionarySize == 0)
propsRes->DictionarySize = 1;
}
#endif
return LZMA_RESULT_OK;
}

The above function is used to decode the properties of the dictionary in the Lzma block.  The following function is similar except it is used to decode the properties from the block stream.  The output function calls LzmaDecodeProperties.

int LzmaDecode




NEXT




<s> void yy_flush_buffer ( YY_BUFFER_STATE b  );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to create and update the current buffer.
This function must be called once per datafile that is scanned.</s>




NEXT




<s> static void bcm4908img_close(FILE *fp) {
if (fp != stdin)
fclose(fp);
}

The above function is used to clean up any resources used up by functions. Here it will close the file descriptor used to open an image file. If you are using the functions in a program, you need to implement bcm4908img_close when it needs to




NEXT




<s> static int mt7621_nfc_write_oob_hwecc(struct nand_chip *nand, int page)
{
return mt7621_nfc_write_page_hwecc(nand, NULL, 1, page);
}

The above function is used to write one page OOB of the page data. It can be observed here that the data of the page is provided by the mt7621_nfc_read_page() function. As you can see, the data is supplied by




NEXT




<s> static void zyxel_bootconfig_print_usage(char *programm)
{
struct zyxel_image_status* s = image_status_codes;

printf("Usage: %s <mtd-device> <command> [args]\n", programm);
printf("Available commands:\n");
printf("	get-status\n");
printf("	set-image-status [0/1] [");

while (s->name) {
printf("%s", s->name);
s++;

if (s->name)
printf(",");
}

printf("]\n");
printf("	set-active-image [0/1]\n");
}

The above function is used to give the user information about supported
commands when running the utility as without any arguments.

There is also some support for passing arguments from the kernel command line through the
linux-image boot script. We are using the first (index 0




NEXT




<s> static int bcm63xx_read_image_tag(struct mtd_info *master, loff_t offset,
struct bcm_tag *hdr)
{
int ret;
size_t retlen;
u32 computed_crc;

ret = mtd_read(master, offset, sizeof(*hdr), &retlen, (void *) hdr);
if (ret)
return ret;

if (retlen != sizeof(*hdr))
return -EIO;

computed_crc = crc32_le(IMAGETAG_CRC_START, (u8 *)hdr,
offsetof(struct bcm_tag, header_crc));
if (computed_crc == hdr->header_crc) {
STR_NULL_TERMINATE(hdr->board_id);
STR_NULL_TERMINATE(hdr->tag_version);

pr_info("CFE image tag found at 0x%llx with version %s, "
"board type %s\n", offset, hdr->tag_version,
hdr->board_id);

return 0;
} else {
pr_err("CFE image tag at 0x%llx CRC invalid "
"(expected %08x, actual %08x)\n",
offset, hdr->header_crc, computed_crc);

return 1;
}
}

The above function is used to retrieve the tag information from the NOR
memory space.</s>




NEXT




<s> static void zerr(int ret)
{
switch (ret) {
case Z_ERRNO:
if (ferror(stdin))
fputs("error reading stdin\n", stderr);
if (ferror(stdout))
fputs("error writing stdout\n", stderr);
break;
case Z_STREAM_ERROR:
fputs("invalid compression level\n", stderr);
break;
case Z_DATA_ERROR:
fputs("invalid or incomplete deflate data\n", stderr);
break;
case Z_MEM_ERROR:
fputs("out of memory\n", stderr);
break;
case Z_VERSION_ERROR:
fputs("zlib version mismatch!\n", stderr);
}
}

The above function is used to return error messages in the case of
problematic decoding.

It does not actually return an error code (zlib_decode_file doesn't
even return anything)

The idea of "zerr" is to




NEXT




<s> rtl8306_config_init(struct phy_device *pdev)
{
struct net_device *netdev = pdev->attached_dev;
struct rtl_priv *priv = pdev->priv;
struct switch_dev *dev = &priv->dev;
struct switch_val val;
unsigned int chipid, chipver, chiptype;
int err;

/* Only init the switch for the primary PHY */
if (pdev->mdio.addr != 0)
return 0;

val.value.i = 1;
priv->dev.cpu_port = RTL8306_PORT_CPU;
priv->dev.ports = RTL8306_NUM_PORTS;
priv->dev.vlans = RTL8306_NUM_VLANS;
priv->dev.ops = &rtl8306_ops;
priv->do_cpu = 0;
priv->page = -1;
priv->bus = pdev->mdio.bus;

chipid = rtl_get(dev, RTL_REG_CHIPID);
chipver = rtl_get(dev, RTL_REG_CHIPVER);
chiptype = rtl_get(dev, RTL_REG_CHIPTYPE);
switch(chiptype) {
case 0:
case 2:
strncpy(priv->hwname, RTL_NAME_S, sizeof(priv->hwname));
priv->type = RTL_TYPE_S;
break;
case 1:
strncpy(priv->hwname, RTL_NAME_SD, sizeof(priv->hwname));
priv->type = RTL_TYPE_SD;
break;
case 3:
strncpy(priv->hwname, RTL_NAME_SDM, sizeof(priv->hwname));
priv->type = RTL_TYPE_SDM;
break;
default:
strncpy(priv->hwname, RTL_NAME_UNKNOWN, sizeof(priv->hwname));
break;
}

dev->name = priv->hwname;
rtl_hw_init(dev);

printk(KERN_INFO "Registering %s switch with Chip ID: 0x%04x, version: 0x%04x\n", priv->hwname, chipid, chipver);

err = register_switch(dev, netdev);
if (err < 0) {
kfree(priv);
return err;
}

return 0;
}

The above function is used to initialize switch and register to driver to the Linux kernel. The function can be used to register PCI device as switch to the kernel.</s>




NEXT




<s> static void rtl931x_fill_l2_entry(u32 r[], struct rtl838x_l2_entry *e)
{
pr_debug("In %s valid?\n", __func__);
e->valid = !!(r[0] & BIT(31));
if (!e->valid)
return;

pr_debug("%s: entry valid, raw: %08x %08x %08x %08x\n", __func__, r[0], r[1], r[2], r[3]);
e->is_ip_mc = false;
e->is_ipv6_mc = false;

e->mac[0] = r[0] >> 8;
e->mac[1] = r[0];
e->mac[2] = r[1] >> 24;
e->mac[3] = r[1] >> 16;
e->mac[4] = r[1] >> 8;
e->mac[5] = r[1];

e->is_open_flow = !!(r[0] & BIT(30));
e->is_pe_forward = !!(r[0] & BIT(29));
e->next_hop = !!(r[2] & BIT(30));
e->rvid = (r[0] >> 16) & 0xfff;

/* Is it a unicast entry? check multicast bit */
if (!(e->mac[0] & 1)) {
e->type = L2_UNICAST;
e->is_l2_tunnel = !!(r[2] & BIT(31));
e->is_static = !!(r[2] & BIT(13));
e->port = (r[2] >> 19) & 0x3ff;
/* Check for trunk port */
if (r[2] & BIT(29)) {
e->is_trunk = true;
e->stack_dev = (e->port >> 9) & 1;
e->trunk = e->port & 0x3f;
} else {
e->is_trunk = false;
e->stack_dev = (e->port >> 6) & 0xf;
e->port = e->port & 0x3f;
}

e->block_da = !!(r[2] & BIT(14));
e->block_sa = !!(r[2] & BIT(15));
e->suspended = !!(r[2] & BIT(12));
e->age = (r[2] >> 16) & 3;

/* the UC_VID field in hardware is used for the VID or for the route id */
if (e->next_hop) {
e->nh_route_id = r[2] & 0x7ff;
e->vid = 0;
} else {
e->vid = r[2] & 0xfff;
e->nh_route_id = 0;
}
if (e->is_l2_tunnel)
e->l2_tunnel_id = ((r[2] & 0xff) << 4) | (r[3] >> 28);
/* TODO: Implement VLAN conversion */
} else {
e->type = L2_MULTICAST;
e->is_local_forward = !!(r[2] & BIT(31));
e->is_remote_forward = !!(r[2] & BIT(17));
e->mc_portmask_index = (r[2] >> 18) & 0xfff;
e->l2_tunnel_list_id = (r[2] >> 4) & 0x1fff;
}
}

The above function is used to parse the L2 entry. The first thing that comes to note is that when the entry is for an mc address it is ignored. This means the routing hardware will not do anything with mc addresses.

So let us start going




NEXT




<s> static int i2c_read(void __iomem *r0, u8 *buf, int len)
{
if (len > 16)
return -EIO;

for (int i = 0; i < len; i++) {
u32 v;

if (i % 4 == 0)
v = readl(r0 + i);
buf[i] = v;
v >>= 8;
}

return len;
}

The above function is used to read from an i2c bus. The function will return a positive value which will be passed to the user after which the user can use this function in order to return a positive value back to the i2co driver. In the case of this




NEXT




<s> static struct airoha_gpio_ctrl *gc_to_ctrl(struct gpio_chip *gc)
{
return container_of(gc, struct airoha_gpio_ctrl, gc);
}

The above function is used to convert a struct of a struct because
a struct of a struct pointer is used in a function parameter.
However, the above function is not a “struct of struct pointer”
user pointer type but a “struct pointer” user pointer type.




NEXT




<s> void *xmalloc(size_t size)
{
void *p = malloc(size);
if (p)
return p;
fprintf(stderr, "Out of memory.\n");
exit(1);
}

The above function is used to avoid memory overflows. When a user requests
certain amount of memory to be allocated, the function checks with the
allocated memory in the heap, and if it is less than the amount the user
requested, it exits




NEXT




<s> ret_t rtl8367c_getAsicLutFlushFid(rtk_uint32* pFid)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL1, RTL8367C_LUT_FLUSH_FID_MASK, pFid);
}

The above function is used to query the hardware about the FID used for the L2 flushing.

The hardware supports eight L2 flushing instances, each instance has a FID. If the instance has a non-null FID assigned to it, it can




NEXT




<s> static inline int b53_spi_clear_status(struct spi_device *spi)
{
unsigned int i;
u8 rxbuf;
int ret;

for (i = 0; i < 10; i++) {
ret = b53_spi_read_reg(spi, B53_SPI_STATUS, &rxbuf, 1);
if (ret)
return ret;

if (!(rxbuf & B53_SPI_CMD_SPIF))
break;

mdelay(1);
}

if (i == 10)
return -EIO;

return 0;
}

The above function is used to ensure that the command is completely processed by the FPGA. This is useful primarily for FS_MODE_32 and FS_MODE_16 where, if the next command is not waited for sufficiently as a result of a failure




NEXT




<s> static void ag71xx_dump_regs(struct ag71xx *ag)
{
DBG("%s: mac_cfg1=%08x, mac_cfg2=%08x, ipg=%08x, hdx=%08x, mfl=%08x\n",
ag->dev->name,
ag71xx_rr(ag, AG71XX_REG_MAC_CFG1),
ag71xx_rr(ag, AG71XX_REG_MAC_CFG2),
ag71xx_rr(ag, AG71XX_REG_MAC_IPG),
ag71xx_rr(ag, AG71XX_REG_MAC_HDX),
ag71xx_rr(ag, AG71XX_REG_MAC_MFL));
DBG("%s: mac_ifctl=%08x, mac_addr1=%08x, mac_addr2=%08x\n",
ag->dev->name,
ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL),
ag71xx_rr(ag, AG71XX_REG_MAC_ADDR1),
ag71xx_rr(ag, AG71XX_REG_MAC_ADDR2));
DBG("%s: fifo_cfg0=%08x, fifo_cfg1=%08x, fifo_cfg2=%08x\n",
ag->dev->name,
ag71xx_rr(ag, AG71XX_REG_FIFO_CFG0),
ag71xx_rr(ag, AG71XX_REG_FIFO_CFG1),
ag71xx_rr(ag, AG71XX_REG_FIFO_CFG2));
DBG("%s: fifo_cfg3=%08x, fifo_cfg4=%08x, fifo_cfg5=%08x\n",
ag->dev->name,
ag71xx_rr(ag, AG71XX_REG_FIFO_CFG3),
ag71xx_rr(ag, AG71XX_REG_FIFO_CFG4),
ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5));
}

The above function is used to dump the values stored in the chip. What can notice is that it dumps the values stored in the following registers (of the chip):-

REG_MAC_CFG1
REG_MAC_CFG2
REG_MAC_IP




NEXT




<s> int rtl930x_read_phy(u32 port, u32 page, u32 reg, u32 *val)
{
u32 v;
int err = 0;

if (port > 63 || page > 4095 || reg > 31)
return -ENOTSUPP;

mutex_lock(&smi_lock);

sw_w32_mask(0xffff << 16, port << 16, RTL930X_SMI_ACCESS_PHY_CTRL_2);
v = reg << 20 | page << 3 | 0x1f << 15 | 1;
sw_w32(v, RTL930X_SMI_ACCESS_PHY_CTRL_1);

do {
v = sw_r32(RTL930X_SMI_ACCESS_PHY_CTRL_1);
} while ( v & 0x1);

if (v & BIT(25)) {
pr_debug("Error reading phy %d, register %d\n", port, reg);
err = -EIO;
}
*val = (sw_r32(RTL930X_SMI_ACCESS_PHY_CTRL_2) & 0xffff);

pr_debug("%s: port %d, page: %d, reg: %x, val: %x\n", __func__, port, page, reg, *val);

mutex_unlock(&smi_lock);

return err;
}

The above function is used to interface with 100Mbps RTL930X EMAC PHY chip
(available on the RTL8192UE-ASIC and other boards). The chip can be controlled
with SMI or I




NEXT




<s> int nvram_unset(nvram_handle_t *h, const char *name)
{
uint32_t i;
nvram_tuple_t *t, **prev;

if (!name)
return 0;

/* Hash the name */
i = hash(name) % NVRAM_ARRAYSIZE(h->nvram_hash);

/* Find the associated tuple in the hash table */
for (prev = &h->nvram_hash[i], t = *prev;
t && strcmp(t->name, name); prev = &t->next, t = *prev);

/* Move it to the dead table */
if (t) {
*prev = t->next;
t->next = h->nvram_dead;
h->nvram_dead = t;
}

return 0;
}

The above function is used to unset variables in a very much similar way as
nvram_set is used for getting variables.</s>




NEXT




<s> rtk_api_ret_t rtk_rldp_portStatus_set(rtk_port_t port, rtk_rldp_portStatus_t *pPortStatus)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

pmsk = (pPortStatus->loop_enter)<<rtk_switch_port_L2P_get(port);
if ((retVal = rtl8367c_setAsicRldpEnterLoopedPortmask(pmsk))!=RT_ERR_OK)
return retVal;

pmsk = (pPortStatus->loop_leave)<<rtk_switch_port_L2P_get(port);
if ((retVal = rtl8367c_setAsicRldpLeaveLoopedPortmask(pmsk))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set port status. It is related to the port which the RLDP agent uses to get status from all the ports on the chip and loop detection feature, i.e. when RLDP agent receives a frame from a port, then based




NEXT




<s> static int rtl8366s_sw_get_max_length(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366S_SGCR, &data);

val->value.i = ((data & (RTL8366S_SGCR_MAX_LENGTH_MASK)) >> 4);

return 0;
}

The above function is used to get the maximum possible length
value for switch port (VLAN_ID != 0).
This is not a good idea, since the values set in rtl8366s_set_max_length
could be higher than




NEXT




<s> static void rtl930x_write_pie_action(u32 r[],  struct pie_rule *pr)
{
/* Either drop or forward */
if (pr->drop) {
r[14] |= BIT(24) | BIT(25) | BIT(26); /* Do Green, Yellow and Red drops */
/* Actually DROP, not PERMIT in Green / Yellow / Red */
r[14] |= BIT(23) | BIT(22) | BIT(20);
} else {
r[14] |= pr->fwd_sel ? BIT(27) : 0;
r[14] |= pr->fwd_act << 18;
r[14] |= BIT(14); /* We overwrite any drop */
}
if (pr->phase == PHASE_VACL)
r[14] |= pr->fwd_sa_lrn ? BIT(15) : 0;
r[13] |= pr->bypass_sel ? BIT(5) : 0;
r[13] |= pr->nopri_sel ? BIT(4) : 0;
r[13] |= pr->tagst_sel ? BIT(3) : 0;
r[13] |= pr->ovid_sel ? BIT(1) : 0;
r[14] |= pr->ivid_sel ? BIT(31) : 0;
r[14] |= pr->meter_sel ? BIT(30) : 0;
r[14] |= pr->mir_sel ? BIT(29) : 0;
r[14] |= pr->log_sel ? BIT(28) : 0;

r[14] |= ((u32)(pr->fwd_data & 0x3fff)) << 3;
r[15] |= pr->log_octets ? BIT(31) : 0;
r[15] |= (u32)(pr->meter_data) << 23;

r[15] |= ((u32)(pr->ivid_act) << 21) & 0x3;
r[15] |= ((u32)(pr->ivid_data) << 9) & 0xfff;
r[16] |= ((u32)(pr->ovid_act) << 30) & 0x3;
r[16] |= ((u32)(pr->ovid_data) & 0xfff) << 16;
r[16] |= (pr->mir_data & 0x3) << 6;
r[17] |= ((u32)(pr->tagst_data) & 0xf) << 28;
r[17] |= ((u32)(pr->nopri_data) & 0x7) << 25;
r[17] |= pr->bypass_ibc_sc ? BIT(16) : 0;
}

The above function is used to write the forward actions to the FAC in the PIE
module. The following lists the meaning for the various fields :-

r[14]


0 : Do nothing
1 : Mark green
2 : Mark yellow




NEXT




<s> rtk_api_ret_t rtk_stat_lengthMode_get(rtk_stat_lengthMode_t *pTxMode, rtk_stat_lengthMode_t *pRxMode)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pTxMode)
return RT_ERR_NULL_POINTER;

if(NULL == pRxMode)
return RT_ERR_NULL_POINTER;

if((retVal = rtl8367c_getAsicMIBsLength((rtk_uint32 *)pTxMode, (rtk_uint32 *)pRxMode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get statistic packet length mode.

void rtk_stat_lengthMode_set(rtk_stat_lengthMode_t TxMode, rtk_stat_lengthMode_t RxMode)
{
rt




NEXT




<s> static void psb6970_mii_write(struct phy_device *phydev, int reg, u16 val)
{
struct mii_bus *bus = phydev->mdio.bus;

bus->write(bus, PHYADDR(reg), val);
}

The above function is used to write in phy register (which is accessed through bus device)

Question: In above function first line is getting me stuck.
Can you explain this 'bus' variable

bus->write(bus, PHYADDR(reg),




NEXT




<s> static int rb4xx_cpld_read_nand(struct rb4xx_cpld *cpld, void *rx_buf,
unsigned int len)
{
struct spi_message m;
static const u8 cmd[2] = {
CPLD_CMD_READ_NAND, 0
};
struct spi_transfer t[2] = {
{
.tx_buf = &cmd,
.len = sizeof(cmd),
}, {
.rx_buf = rx_buf,
.len = len,
},
};

spi_message_init(&m);
spi_message_add_tail(&t[0], &m);
spi_message_add_tail(&t[1], &m);
return spi_sync(cpld->spi, &m);
}

The above function is used to read nand data. It will be used to download the image to nand flash. However, we can see that this function is only called by the cp_update(kernel/cpu/cpus.c). Thus, if an attacker




NEXT




<s> rtk_api_ret_t rtk_qos_1pRemarkEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicRemarkingDot1pAbility(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the ability of port for qos for 1P remark.</s>




NEXT




<s> int rtl839x_get_scheduling_algorithm(struct rtl838x_switch_priv *priv, int port)
{
u32 v;

mutex_lock(&priv->reg_mutex);

rtl839x_read_scheduling_table(port);
v = sw_r32(RTL839X_TBL_ACCESS_DATA_2(8));

mutex_unlock(&priv->reg_mutex);

if (v & BIT(19))
return WEIGHTED_ROUND_ROBIN;

return WEIGHTED_FAIR_QUEUE;
}

The above function is used to get the scheduling algorithm on the port. As shown on the figure, weighted round-robin(WRR) scheduling algorithm is selected on port 1.</s>




NEXT




<s> static int rt5350_fwd_config(struct fe_priv *priv)
{
struct net_device *dev = priv_netdev(priv);

rt5350_rxcsum_config((dev->features & NETIF_F_RXCSUM));

return 0;
}

The above function is used to configure the forward packet function in the
RX path of the driver.

In this instance, as we are not doing checksum processing for any of the
incoming packets the configuration is done by simply returning 0 from the
device driver




NEXT




<s> ret_t rtl8367c_getAsicGreenTrafficType(rtk_uint32 priority, rtk_uint32* pTraffictype)
{
if(priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_getAsicRegBit(RTL8367C_REG_HIGHPRI_CFG, priority, pTraffictype);
}

The above function is used to get traffic type of high priority queue.

Note:
This function is supported on some boards.


rtk_uint32
rtl8367c_getGbQueueCountByPriority(rtk_




NEXT




<s> int ehci_hcd_init(int index, enum usb_init_type init, struct ehci_hccr **hccr,
struct ehci_hcor **hcor)
{
start_oxnas_usb_ehci();
*hccr = (struct ehci_hccr *)(USB_HOST_BASE + 0x100);
*hcor = (struct ehci_hcor *)((uint32_t)*hccr +
HC_LENGTH(ehci_readl(&(*hccr)->cr_capbase)));
ghcor = *hcor;
return 0;
}

The above function is used to init an ehci controller. This function is called for usb ehci_hcd_reset().

ehci_hcd_reset()
 {
 if (start_oxnas_usb_ehci() < 0) {




NEXT




<s> __ar8216_setup_port(struct ar8xxx_priv *priv, int port, u32 members,
bool ath_hdr_en)
{
u32 header;
u32 egress, ingress;
u32 pvid;

if (priv->vlan) {
pvid = priv->vlan_id[priv->pvid[port]];
if (priv->vlan_tagged & (1 << port))
egress = AR8216_OUT_ADD_VLAN;
else
egress = AR8216_OUT_STRIP_VLAN;
ingress = AR8216_IN_SECURE;
} else {
pvid = port;
egress = AR8216_OUT_KEEP;
ingress = AR8216_IN_PORT_ONLY;
}

header = ath_hdr_en ? AR8216_PORT_CTRL_HEADER : 0;

ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
AR8216_PORT_CTRL_LEARN | AR8216_PORT_CTRL_VLAN_MODE |
AR8216_PORT_CTRL_SINGLE_VLAN | AR8216_PORT_CTRL_STATE |
AR8216_PORT_CTRL_HEADER | AR8216_PORT_CTRL_LEARN_LOCK,
AR8216_PORT_CTRL_LEARN | header |
(egress << AR8216_PORT_CTRL_VLAN_MODE_S) |
(AR8216_PORT_STATE_FORWARD << AR8216_PORT_CTRL_STATE_S));

ar8xxx_rmw(priv, AR8216_REG_PORT_VLAN(port),
AR8216_PORT_VLAN_DEST_PORTS | AR8216_PORT_VLAN_MODE |
AR8216_PORT_VLAN_DEFAULT_ID,
(members << AR8216_PORT_VLAN_DEST_PORTS_S) |
(ingress << AR8216_PORT_VLAN_MODE_S) |
(pvid << AR8216_PORT_VLAN_DEFAULT_ID_S));
}

The above function is used to configure the VLAN settings in a port of ar8216 nic based device. It is assumed that the device support the VLAN functionality and it will always be invoked by the kernel if a virtual network interface is created or deleted. It will




NEXT




<s> send_username(void)
{
msg->type = htonl(EAD_TYPE_SET_USERNAME);
msg->len = htonl(sizeof(struct ead_msg_user));
strcpy(EAD_DATA(msg, user)->username, username);
return send_packet(EAD_TYPE_ACK_USERNAME, handle_none, 1);
}

The above function is used to send set_username request;
the corresponding request handling function is as follows:

handle_user((void *) msg)
{
struct ead_msg_user *ud;

if((msg->len != sizeof(struct




NEXT




<s> static int rtl9300_i2c_smbus_xfer(struct i2c_adapter * adap, u16 addr,
unsigned short flags, char read_write,
u8 command, int size, union i2c_smbus_data * data)
{
struct rtl9300_i2c *i2c = i2c_get_adapdata(adap);
struct i2c_drv_data *drv_data = (struct i2c_drv_data *)device_get_match_data(i2c->dev);
int len = 0, ret;

mutex_lock(&i2c_lock);
switch (size) {
case I2C_SMBUS_QUICK:
drv_data->config_xfer(i2c, addr, 0);
drv_data->reg_addr_set(i2c, 0, 0);
break;

case I2C_SMBUS_BYTE:
if (read_write == I2C_SMBUS_WRITE) {
drv_data->config_xfer(i2c, addr, 0);
drv_data->reg_addr_set(i2c, command, 1);
} else {
drv_data->config_xfer(i2c, addr, 1);
drv_data->reg_addr_set(i2c, 0, 0);
}
break;

case I2C_SMBUS_BYTE_DATA:
pr_debug("I2C_SMBUS_BYTE_DATA %02x, read %d cmd %02x\n", addr, read_write, command);
drv_data->reg_addr_set(i2c, command, 1);
drv_data->config_xfer(i2c, addr, 1);

if (read_write == I2C_SMBUS_WRITE) {
pr_debug("--> data %02x\n", data->byte);
drv_data->writel(i2c, data->byte);
}
break;

case I2C_SMBUS_WORD_DATA:
pr_debug("I2C_SMBUS_WORD %02x, read %d\n", addr, read_write);
drv_data->reg_addr_set(i2c, command, 1);
drv_data->config_xfer(i2c, addr, 2);
if (read_write == I2C_SMBUS_WRITE)
drv_data->writel(i2c, data->word);
break;

case I2C_SMBUS_BLOCK_DATA:
pr_debug("I2C_SMBUS_BLOCK_DATA %02x, read %d, len %d\n",
addr, read_write, data->block[0]);
drv_data->reg_addr_set(i2c, command, 1);
drv_data->config_xfer(i2c, addr, data->block[0]);
if (read_write == I2C_SMBUS_WRITE)
drv_data->write(i2c, &data->block[1], data->block[0]);
len = data->block[0];
break;

default:
dev_warn(&adap->dev, "Unsupported transaction %d\n", size);
return -EOPNOTSUPP;
}

ret = drv_data->execute_xfer(i2c, read_write, size, data, len);

mutex_unlock(&i2c_lock);

return ret;
}

The above function is used to initiate a transaction via hardware using the current configuration and the device is already locked in this function. There is one issue in here: the above function calls the device-specific function execute_xfer(). Since the driver-internal data structure can not




NEXT




<s> int rtl839x_eee_port_ability(struct rtl838x_switch_priv *priv, struct ethtool_eee *e, int port)
{
u64 link, a;

if (port >= 48)
return 0;

link = rtl839x_get_port_reg_le(RTL839X_MAC_LINK_STS);
if (!(link & BIT_ULL(port)))
return 0;

if (sw_r32(rtl839x_mac_force_mode_ctrl(port)) & BIT(8))
e->advertised |= ADVERTISED_100baseT_Full;

if (sw_r32(rtl839x_mac_force_mode_ctrl(port)) & BIT(10))
e->advertised |= ADVERTISED_1000baseT_Full;

a = rtl839x_get_port_reg_le(RTL839X_MAC_EEE_ABLTY);
pr_info("Link partner: %016llx\n", a);
if (rtl839x_get_port_reg_le(RTL839X_MAC_EEE_ABLTY) & BIT_ULL(port)) {
e->lp_advertised = ADVERTISED_100baseT_Full;
e->lp_advertised |= ADVERTISED_1000baseT_Full;
return 1;
}

return 0;
}

The above function is used to find out EEE (Energy efficient Ethernet) capability of a given Gbit link (only in Gbit).

The EEE ability information of port0 can be seen in following picture.</s>




NEXT




<s> static void g997_power_management_status(int fd) {
IOCTL(DSL_G997_PowerManagementStatus_t, DSL_FIO_G997_POWER_MANAGEMENT_STATUS_GET)

int map = PSTATE_MAP_UNKNOWN;
const char *str;
switch (out.data.nPowerManagementStatus) {
STR_CASE_MAP(DSL_G997_PMS_NA, "Power management state is not available", PSTATE_MAP_NA)
STR_CASE_MAP(DSL_G997_PMS_L0, "L0 - Synchronized", PSTATE_MAP_L0)
STR_CASE_MAP(DSL_G997_PMS_L1, "L1 - Power Down Data transmission (G.992.2)", PSTATE_MAP_L1)
STR_CASE_MAP(DSL_G997_PMS_L2, "L2 - Power Down Data transmission (G.992.3 and G.992.4)", PSTATE_MAP_L2)
STR_CASE_MAP(DSL_G997_PMS_L3, "L3 - No power", PSTATE_MAP_L3)
default:
str = NULL;
break;
};

if (str)
m_str("power_state", str);

if (map != PSTATE_MAP_UNKNOWN)
m_u32("power_state_num", map);
}

The above function is used to query the power state of the DSL connector. This is used mainly by dspmon to determine if the connection is currently transmitting or idle.

The above function shows a way of reading data from an ioctl structure using the switch




NEXT




<s> static void dma_start_read(ulong* buffer, int num_bytes)
{
// Assemble complete memory settings
oxnas_dma_device_settings_t mem_settings = oxnas_ram_dma_settings;
mem_settings.address_ = (unsigned long) buffer;
mem_settings.address_mode_ = OXNAS_DMA_MODE_INC;

writel(encode_control_status(&oxnas_sata_dma_settings, &mem_settings),
SATA_DMA_REGS_BASE + DMA_CTRL_STATUS);
writel(oxnas_sata_dma_settings.address_,
SATA_DMA_REGS_BASE + DMA_BASE_SRC_ADR);
writel(mem_settings.address_, SATA_DMA_REGS_BASE + DMA_BASE_DST_ADR);
writel(encode_final_eot(&oxnas_sata_dma_settings, &mem_settings,
num_bytes),
SATA_DMA_REGS_BASE + DMA_BYTE_CNT);

dma_start();
}

The above function is used to configure the DMA engine to perform a single bulk DMA read from DDR to SATA buffer. This function uses oxnas_dma_device_settings_t type variable oxnas_sata_dma_settings to configure the address settings, channel




NEXT




<s> static u8 sata_oxnas_check_status(struct ata_port *ap);
static int sata_oxnas_cleanup(struct ata_host *ah);
static void sata_oxnas_tf_load(struct ata_port *ap,
const struct ata_taskfile *tf);
static void sata_oxnas_irq_on(struct ata_port *ap);
static void sata_oxnas_post_reset_init(struct ata_port *ap);

static int sata_oxnas_acquire_hw(struct ata_port *ap, int may_sleep,
int timeout_jiffies);
static void sata_oxnas_release_hw(struct ata_port *ap);

static const void *HW_LOCKER_UID = (void *)0xdeadbeef;

/***************************************************************************
* ASIC access
***************************************************************************/
static void wait_cr_ack(void __iomem *phy_base)
{
while ((ioread32(phy_base + PHY_STAT) >> 16) & 0x1f)
; /* wait for an ack bit to be set */
}

The above function is used to wait for an ACK bit to be set in the PHY
status register, as well as ensure ATA writes take effect in the PHY.

For this purpose, the ACK bit mask was designed to be in a write-




NEXT




<s> void hostapd_ucode_free_bss(struct hostapd_data *hapd)
{
uc_value_t *val;

val = wpa_ucode_registry_remove(bss_registry, hapd->ucode.idx);
if (!val)
return;

hapd->ucode.idx = 0;
if (wpa_ucode_call_prepare("bss_remove"))
return;

uc_value_push(ucv_string_new(hapd->conf->iface));
uc_value_push(ucv_get(val));
ucv_put(wpa_ucode_call(2));
ucv_gc(vm);
}

The above function is used to free an UCODE bss when the interface
is being taken down, and I use it with the following function for
freeing UCODE on WMM and IE:

void hostapd_free_ucode_on_iface




NEXT




<s> rtk_api_ret_t rtk_led_modeForce_get(rtk_port_t port, rtk_led_group_t group, rtk_led_force_mode_t *pMode)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

/* No LED for CPU port */
if(rtk_switch_isCPUPort(port) == RT_ERR_OK)
return RT_ERR_PORT_ID;

if (group >= LED_GROUP_END)
return RT_ERR_INPUT;

if (NULL == pMode)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicForceLed(rtk_switch_port_L2P_get(port), group, pMode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get a certain LED mode on the CPU port.

rtk_api_ret_t rtk_led_modeForce_set(rtk_port_t port, rtk_led_group_t group, rtk




NEXT




<s> static void dump_skb(struct sk_buff *, u32, char *, int, int, int);
#else
#define dump_skb(skb, len, title, port, ch, is_tx)    do {} while (0)

The above function is used to print data from a packet during packet tracing.

#### 127.290.51.254 -> 127.255.255.255: icmp: Redirect




NEXT




<s> uc_hostapd_bss_delete(uc_vm_t *vm, size_t nargs)
{
struct hostapd_data *hapd = uc_fn_thisval("hostapd.bss");
struct hostapd_iface *iface;
int i, idx;

if (!hapd)
return NULL;

iface = hapd->iface;
if (iface->num_bss == 1) {
wpa_printf(MSG_ERROR, "trying to delete last bss of an iface: %s\n", hapd->conf->iface);
return NULL;
}

for (idx = 0; idx < iface->num_bss; idx++)
if (iface->bss[idx] == hapd)
break;

if (idx == iface->num_bss)
return NULL;

for (i = idx + 1; i < iface->num_bss; i++)
iface->bss[i - 1] = iface->bss[i];

iface->num_bss--;

iface->bss[0]->interface_added = 0;
hostapd_drv_set_first_bss(iface->bss[0]);
hapd->interface_added = 1;

hostapd_drv_stop_ap(hapd);
hostapd_bss_deinit(hapd);
hostapd_remove_iface_bss_conf(iface->conf, hapd->conf);
hostapd_config_free_bss(hapd->conf);
os_free(hapd);

hostapd_ucode_update_interfaces();
ucv_gc(vm);

return NULL;
}

The above function is used to remove the last operating(or at least active) bss as part of removing an interface. After we delete the interface, we need to disable the previous bss by de-init-ing it and freeing the conf for the bss as




NEXT




<s> rtk_api_ret_t rtk_port_efid_set(rtk_port_t port, rtk_data_t efid)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

/* efid must be 0~7 */
if (efid > RTK_EFID_MAX)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicPortIsolationEfid(rtk_switch_port_L2P_get(port), efid))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to change the edge filtering/isolation unit
of a port.

This is called whenever a port is being enabled or disabled during bootup, or to
change the edge isolation of a port.

This does the necessary edge filter




NEXT




<s> void rtl931x_set_distribution_algorithm(int group, int algoidx, u32 algomsk)
{
u32 l3shift = 0;
u32 newmask = 0;

/* TODO: for now we set algoidx to 0 */
algoidx = 0;

if (algomsk & TRUNK_DISTRIBUTION_ALGO_SIP_BIT) {
l3shift = 4;
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_SIP_BIT;
}
if (algomsk & TRUNK_DISTRIBUTION_ALGO_DIP_BIT) {
l3shift = 4;
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_DIP_BIT;
}
if (algomsk & TRUNK_DISTRIBUTION_ALGO_SRC_L4PORT_BIT) {
l3shift = 4;
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_SRC_L4PORT_BIT;
}
if (algomsk & TRUNK_DISTRIBUTION_ALGO_SRC_L4PORT_BIT) {
l3shift = 4;
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_SRC_L4PORT_BIT;
}

if (l3shift == 4) {
if (algomsk & TRUNK_DISTRIBUTION_ALGO_SMAC_BIT)
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_SMAC_BIT;
if (algomsk & TRUNK_DISTRIBUTION_ALGO_DMAC_BIT)
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_DMAC_BIT;
} else {
if (algomsk & TRUNK_DISTRIBUTION_ALGO_SMAC_BIT)
newmask |= TRUNK_DISTRIBUTION_ALGO_L2_SMAC_BIT;
if (algomsk & TRUNK_DISTRIBUTION_ALGO_DMAC_BIT)
newmask |= TRUNK_DISTRIBUTION_ALGO_L2_DMAC_BIT;
}

sw_w32(newmask << l3shift, RTL931X_TRK_HASH_CTRL + (algoidx << 2));
}

The above function is used to set Trunk distribution algorithm. The below function is used to retrieve current setting of the trunk hash distribution algorithm.
/****/
u32 rtl931x_get_distribution_algorithm(int group, int algoid




NEXT




<s> static inline int b53_spi_set_page(struct spi_device *spi, u8 page)
{
u8 txbuf[3];

txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
txbuf[1] = B53_SPI_PAGE_SELECT;
txbuf[2] = page;

return spi_write(spi, txbuf, sizeof(txbuf));
}

The above function is used to set the page which currently the SPI
protocol is operating. On this NOR, the page is a 4KB block, so it
sets it by writing the page number which it wants to access. There is
a page register on




NEXT




<s> static void set_rtl8367s_rgmii(void)
{
rtk_port_mac_ability_t mac_cfg;
rtk_mode_ext_t mode;

mode = MODE_EXT_RGMII;
mac_cfg.forcemode = MAC_FORCE;
mac_cfg.speed = PORT_SPEED_1000M;
mac_cfg.duplex = PORT_FULL_DUPLEX;
mac_cfg.link = PORT_LINKUP;
mac_cfg.nway = DISABLED;
mac_cfg.txpause = ENABLED;
mac_cfg.rxpause = ENABLED;
rtk_port_macForceLinkExt_set(EXT_PORT1, mode, &mac_cfg);
rtk_port_rgmiiDelayExt_set(EXT_PORT1, 1, 3);
rtk_port_phyEnableAll_set(ENABLED);

}

The above function is used to set the rtl8367s register for Gigabit.
It has no impact if the rtl8367s is plugged into the switch. Because the switch driver will read the device tree node and set the




NEXT




<s> int on_key_resize(void)
{
dialog_clear();
return KEY_RESIZE;
}

The above function is used to reset the window positioning, when the tcl/tk session is resized (usually
when tk window is moved or resized). It is important that dialogs are not moved to new positions when
the window is resized unless




NEXT




<s> swconfig_parse_link(struct sk_buff *msg, struct nlattr *nla,
struct switch_port_link *link)
{
struct nlattr *tb[SWITCH_LINK_ATTR_MAX + 1];

if (nla_parse_nested_deprecated(tb, SWITCH_LINK_ATTR_MAX, nla, link_policy, NULL))
return -EINVAL;

link->duplex = !!tb[SWITCH_LINK_FLAG_DUPLEX];
link->aneg = !!tb[SWITCH_LINK_FLAG_ANEG];
link->speed = nla_get_u32(tb[SWITCH_LINK_SPEED]);

return 0;
}

The above function is used to parse the switchdev attribute. We will
focus our hack on this function as we wish to intercept all the
requests in netlink to the kernel that changes the link attributes.

The switchdev attribute is an integer attribute that maps to




NEXT




<s> static int __init ifx_ptm_test_init(void)
{
proc_file_create();

return 0;
}

The above function is used to create the proc file and register the functions which will be used to handle the proc file.

static void __exit ifx_ptm_test_exit(void)
{
proc_file_destroy();
 }

 The




NEXT




<s> ar8xxx_phy_mmd_write(struct ar8xxx_priv *priv, int phy_addr, u16 addr, u16 reg, u16 data)
{
struct mii_bus *bus = priv->mii_bus;

mutex_lock(&bus->mdio_lock);
ar8xxx_phy_mmd_prep(bus, phy_addr, addr, reg);
bus->write(bus, phy_addr, MII_ATH_MMD_DATA, data);
mutex_unlock(&bus->mdio_lock);
}

The above function is used to write bytes to an MMD register of phy.
Before entering the MD believers (bus->write), it will do a preprocess work
as below:
u16 addr = ar8xxx_phy_mmd_pre




NEXT




<s> void *memalign(size_t alignment, size_t bytes)
{
ulong mem = ALIGN(next_mem, alignment);

next_mem = mem + bytes;

if (next_mem > CONFIG_SYS_SDRAM_BASE + CONFIG_MIN_SDRAM_SIZE) {
printf("spl: out of memory\n");
hang();
}

return (void *)mem;
}

The above function is used to allocate memory.
And the ALIGN() is a macro define:

#define ALIGN(value, align) ((((value) + ((align) - 1)) / (align)) * (align))

I think,




NEXT




<s> static int rtl8366rb_sw_set_monitor_isolation_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

if (val->value.i)
data = RTL8366RB_PMCR_MIRROR_ISO;
else
data = 0;

return rtl8366_smi_rmwr(smi, RTL8366RB_PMCR, RTL8366RB_PMCR_MIRROR_ISO, data);
}

The above function is used to set monitor isolation for each VLAN.

However, when setting isolation enable value to 1, it also sets
PMCR_TXDIS bit, which disables packet transmit. As a result,
setting monitor isolation enable makes network connection




NEXT




<s> static int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)
{
char *p2;

switch (sym->type) {
case S_TRISTATE:
if (p[0] == 'm') {
sym->def[def].tri = mod;
sym->flags |= def_flags;
break;
}
/* fall through */
case S_BOOLEAN:
if (p[0] == 'y') {
sym->def[def].tri = yes;
sym->flags |= def_flags;
break;
}
if (p[0] == 'n') {
sym->def[def].tri = no;
sym->flags |= def_flags;
break;
}
if (def != S_DEF_AUTO)
conf_warning("symbol value '%s' invalid for %s",
p, sym->name);
return 1;
case S_STRING:
if (*p++ != '"')
break;
for (p2 = p; (p2 = strpbrk(p2, "\"\\")); p2++) {
if (*p2 == '"') {
*p2 = 0;
break;
}
memmove(p2, p2 + 1, strlen(p2));
}
if (!p2) {
if (def != S_DEF_AUTO)
conf_warning("invalid string found");
return 1;
}
/* fall through */
case S_INT:
case S_HEX:
if (sym_string_valid(sym, p)) {
sym->def[def].val = xstrdup(p);
sym->flags |= def_flags;
} else {
if (def != S_DEF_AUTO)
conf_warning("symbol value '%s' invalid for %s",
p, sym->name);
return 1;
}
break;
default:
;
}
return 0;
}

The above function is used to determine if the symbol value is valid. It uses
sym_string_valid(sym, p) to validate the symbol string value provided by the
user. This function checks if the string provided matches the expected format for
the type of symbol




NEXT




<s> static void _rtl8367c_svlanSp2cStSmi2User(rtl8367c_svlan_s2c_t *pUserSt, rtk_uint16 *pSmiSt)
{
pUserSt->dstport = (((pSmiSt[0] & 0x0200) >> 9) << 3) | (pSmiSt[0] & 0x0007);
pUserSt->svidx   = (pSmiSt[0] & 0x01F8) >> 3;
pUserSt->vid     = (pSmiSt[1] & 0x0FFF);
pUserSt->valid   = (pSmiSt[1] & 0x1000) >> 12;
}

The above function is used to convert the SMI Static Table to SMI Port, VID, and SVLAN tag entries. The VID and SVID entries match the bits defined in rtl8367c.h as follows:

        typedef struct




NEXT




<s> swconfig_trig_update_leds(struct switch_led_trigger *sw_trig)
{
struct list_head *entry;
struct led_trigger *trigger;

trigger = &sw_trig->trig;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
spin_lock(&trigger->leddev_list_lock);
#else
read_lock(&trigger->leddev_list_lock);
#endif
list_for_each(entry, &trigger->led_cdevs) {
struct led_classdev *led_cdev;

led_cdev = list_entry(entry, struct led_classdev, trig_list);
swconfig_trig_led_event(sw_trig, led_cdev);
}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
spin_unlock(&trigger->leddev_list_lock);
#else
read_unlock(&trigger->leddev_list_lock);
#endif
}

The above function is used to dispatch LED events. But the problem is the structure of led_trig_event_trigger which is given below which can only handle 8 events.

struct led_trigger {
const u8 *names;
const u8 *




NEXT




<s> int rtl8366_sw_get_vlan_fid(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_vlan_4k vlan4k;
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
int err;

if (!smi->ops->is_vlan_valid(smi, val->port_vlan))
return -EINVAL;

err = smi->ops->get_vlan_4k(smi, val->port_vlan, &vlan4k);
if (err)
return err;

val->value.i = vlan4k.fid;

return 0;
}

The above function is used to get the VLAN forwarding ID (fid) corresponding to the specified VLAN tag. The parameter dev represents the switch device and attr is a pointer to the switch attribute structure. val is a pointer to the switch value struct in which the fid




NEXT




<s> static int ip175c_set_state(struct ip17xx_state *state)
{
int j;
int i;
SET_PORT_BITS(state, state->add_tag,
state->regs->ADD_TAG_REG, state->regs->ADD_TAG_BIT);
SET_PORT_BITS(state, state->remove_tag,
state->regs->REMOVE_TAG_REG, state->regs->REMOVE_TAG_BIT);

if (REG_SUPP(state->regs->VLAN_LOOKUP_REG)) {
for (j=0; j<state->regs->NUM_PORTS; j++) {
reg addr;
const bitnum *bit_lookup = (j%2==0)?
state->regs->VLAN_LOOKUP_EVEN_BIT:
state->regs->VLAN_LOOKUP_ODD_BIT;

addr = state->regs->VLAN_LOOKUP_REG;
if (state->regs->SIMPLE_VLAN_REGISTERS) {
addr.m += j;
} else {
switch (j) {
case 0:
case 1:
break;
case 2:
case 3:
addr.m+=1;
break;
case 4:
addr.m+=2;
break;
case 5:
addr = state->regs->VLAN_LOOKUP_REG_5;
break;
default:
addr.m = -1; // shouldn't get here, but...
break;
}
}
//printf("shareports for %d is %02X\n",j,state->ports[j].shareports);
if (REG_SUPP(addr)) {
SET_PORT_BITS(state, state->ports[j].shareports, addr, bit_lookup);
}
}
}
if (REG_SUPP(state->regs->TAG_VLAN_MASK_REG)) {
for (j=0; j<MAX_VLANS; j++) {
reg addr = state->regs->TAG_VLAN_MASK_REG;
const bitnum *bit_lookup = (j%2==0)?
state->regs->TAG_VLAN_MASK_EVEN_BIT:
state->regs->TAG_VLAN_MASK_ODD_BIT;
unsigned int vlan_mask;
if (state->regs->SIMPLE_VLAN_REGISTERS) {
addr.m += j;
} else {
addr.m += j/2;
}
vlan_mask = state->vlans[j].ports;
SET_PORT_BITS(state, vlan_mask, addr, bit_lookup);
}
}

for (i=0; i<MAX_PORTS; i++) {
if (REG_SUPP(state->regs->VLAN_DEFAULT_TAG_REG[i])) {
int err = setPhy(state, state->regs->VLAN_DEFAULT_TAG_REG[i],
state->ports[i].pvid);
if (err < 0) {
return err;
}
}
}

return ip175c_set_flags(state);
}

The above function is used to configure the hardware for a given set of
VLANs, a set of ports for each vlan (and its associated tagging
settings) and which ports in a tagged vlan have their own VLAN tag.

The main




NEXT




<s> rtl8306_fixup(struct phy_device *pdev)
{
struct rtl_priv priv;
u16 chipid;

/* Attach to primary LAN port and WAN port */
if (pdev->mdio.addr != 0 && pdev->mdio.addr != 4)
return 0;

memset(&priv, 0, sizeof(priv));
priv.fixup = true;
priv.page = -1;
priv.bus = pdev->mdio.bus;
chipid = rtl_get(&priv.dev, RTL_REG_CHIPID);
if (chipid == 0x5988)
pdev->phy_id = RTL8306_MAGIC;

return 0;
}

The above function is used to configure the PHY device driver attached to the WAN port. The phy_driver driver is initialized by the chipset driver. If a special phy driver is used, the phy_driver module will need to be modified.






NEXT




<s> static void ar934x_nfc_read_buf(struct nand_chip *chip, u8 *buf, int len)
{
struct ar934x_nfc *nfc = chip->priv;
int buf_index;
int i;

WARN_ON(nfc->buf_index + len > nfc->buf_size);

buf_index = nfc->buf_index;

if (nfc->swap_dma || nfc->read_id) {
for (i = 0; i < len; i++) {
buf[i] = nfc->buf[buf_index ^ 3];
buf_index++;
}
} else {
for (i = 0; i < len; i++) {
buf[i] = nfc->buf[buf_index];
buf_index++;
}
}

nfc->buf_index = buf_index;
}

The above function is used to read data from the memory controller buffer. You can see that this function is divided into two parts: one part is swapped with DMA; The other is directly read from NAND Flash memory. These two parts may be mixed.

What'




NEXT




<s> void rtl931x_vlan_port_pvid_set(int port, enum pbvlan_type type, int pvid)
{
if (type == PBVLAN_TYPE_INNER)
sw_w32_mask(0xfff, pvid, RTL931X_VLAN_PORT_IGR_CTRL + (port << 2));
else
sw_w32_mask(0xfff << 14, pvid << 14, RTL931X_VLAN_PORT_IGR_CTRL + (port << 2));
}

The above function is used to set the Port-Based VLAN Priority Vector for a specific port. The `uint32` argument that is the high bit is the pvid, and the low bits correspond to the VLAN priority bitmask. To clear an entry,




NEXT




<s> wpas_bss_wps_start(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
int rc;
struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);
struct blob_attr *tb[__WPS_START_MAX], *cur;
int multi_ap = 0;

blobmsg_parse(wps_start_policy, __WPS_START_MAX, tb, blobmsg_data(msg), blobmsg_data_len(msg));

if (tb[WPS_START_MULTI_AP])
multi_ap = blobmsg_get_bool(tb[WPS_START_MULTI_AP]);

rc = wpas_wps_start_pbc(wpa_s, NULL, 0, multi_ap);

if (rc != 0)
return UBUS_STATUS_NOT_SUPPORTED;

return 0;
}

The above function is used to initiate the PBAC procedure for a WPS client. If you are using the legacy WPS, this function should do the trick for you. Otherwise, please use wpa_supplicant wpa_supplicant –legacy




NEXT




<s> static int rtl8366s_setup(struct rtl8366_smi *smi)
{
struct rtl8366_platform_data *pdata;
int err;
unsigned i;
#ifdef CONFIG_OF
struct device_node *np;
unsigned num_initvals;
const __be32 *paddr;
#endif

pdata = smi->parent->platform_data;
if (pdata && pdata->num_initvals && pdata->initvals) {
dev_info(smi->parent, "applying initvals\n");
for (i = 0; i < pdata->num_initvals; i++)
REG_WR(smi, pdata->initvals[i].reg,
pdata->initvals[i].val);
}

#ifdef CONFIG_OF
np = smi->parent->of_node;

paddr = of_get_property(np, "realtek,initvals", &num_initvals);
if (paddr) {
dev_info(smi->parent, "applying initvals from DTS\n");

if (num_initvals < (2 * sizeof(*paddr)))
return -EINVAL;

num_initvals /= sizeof(*paddr);

for (i = 0; i < num_initvals - 1; i += 2) {
u32 reg = be32_to_cpup(paddr + i);
u32 val = be32_to_cpup(paddr + i + 1);

REG_WR(smi, reg, val);
}
}

if (of_property_read_bool(np, "realtek,green-ethernet-features")) {
dev_info(smi->parent, "activating Green Ethernet features\n");

err = rtl8366s_set_green(smi, 1);
if (err)
return err;

for (i = 0; i <= RTL8366S_PHY_NO_MAX; i++) {
err = rtl8366s_set_green_port(smi, i, 1);
if (err)
return err;
}
}
#endif

/* set maximum packet length to 1536 bytes */
REG_RMW(smi, RTL8366S_SGCR, RTL8366S_SGCR_MAX_LENGTH_MASK,
RTL8366S_SGCR_MAX_LENGTH_1536);

/* enable learning for all ports */
REG_WR(smi, RTL8366S_SSCR0, 0);

/* enable auto ageing for all ports */
REG_WR(smi, RTL8366S_SSCR1, 0);

/*
* discard VLAN tagged packets if the port is not a member of
* the VLAN with which the packets is associated.
*/
REG_WR(smi, RTL8366S_VLAN_MEMBERINGRESS_REG, RTL8366S_PORT_ALL);

/* don't drop packets whose DA has not been learned */
REG_RMW(smi, RTL8366S_SSCR2, RTL8366S_SSCR2_DROP_UNKNOWN_DA, 0);

return 0;
}

The above function is used to initialize the PHY and Port
configuration according to the device tree nodes, e.g., the
number of ports, and 64-bit address support. It also initializes
the MAC and VLAN control registers like
set-




NEXT




<s> ulong get_tbclk (void)
{
ulong tbclk;
tbclk = CONFIG_SYS_HZ;
return tbclk;
}

The above function is used to get the Timer Clock of the SoC. The Timer Clock must be configured by the designer for his SoC. You can use CONFIG_SYS_HZ_FREQUENCY_MAX to get the maximum frequency in




NEXT




<s> ret_t rtl8367c_setAsicFlowControlQueueEgressEnable(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 enabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;

return rtl8367c_setAsicRegBit(RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG(port), RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG_OFFSET(port)+ qid, enabled);
}

The above function is used to enable/disable flow control queue for given port and queue.
We can use the above function to configure flow control queue on RTL8367C.
Following are sample code to set 10M/100M




NEXT




<s> static int rtl8366_init_vlan(struct rtl8366_smi *smi)
{
int port;
int err;

err = rtl8366_smi_reset_vlan(smi);
if (err)
return err;

for (port = 0; port < smi->num_ports; port++) {
u32 mask;

if (port == smi->cpu_port)
mask = (1 << smi->num_ports) - 1;
else
mask = (1 << port) | (1 << smi->cpu_port);

err = rtl8366_set_vlan(smi, (port + 1), mask, mask, 0);
if (err)
return err;

err = rtl8366_set_pvid(smi, port, (port + 1));
if (err)
return err;
}

return rtl8366_smi_enable_vlan(smi, 1);
}

The above function is used to initialize VLAN-related register values in the controller to make sure that our VLAN implementation is correct.</s>




NEXT




<s> static uint32_t nmbm_get_block_state_raw(u32 *block_state,
uint32_t ba)
{
uint32_t unit, shift;

unit = ba / NMBM_BITMAP_BLOCKS_PER_UNIT;
shift = (ba % NMBM_BITMAP_BLOCKS_PER_UNIT) * NMBM_BITMAP_BITS_PER_BLOCK;

return (block_state[unit] >> shift) & BLOCK_ST_MASK;
}

The above function is used to return the state of a block as defined in nb_states.h. As you can see from the code, the bitmap is stored in a fixed width array, which is then returned as part of the `block_state` field during the




NEXT




<s> rtk_api_ret_t rtk_port_sgmiiNway_get(rtk_port_t port, rtk_enable_t *pState)
{
rtk_uint32 ext_id;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
if(rtk_switch_isSgmiiPort(port) != RT_ERR_OK)
return RT_ERR_PORT_ID;

if(NULL == pState)
return RT_ERR_NULL_POINTER;

ext_id = port - 15;
return rtl8367c_getSgmiiNway(ext_id, (rtk_uint32 *)pState);
}

The above function is used to read the state of the SGMII mode

# rtk_port_sgmiiNway_set
r = rtwill_port_sgmiiNway_set(port, en, mode);
The above




NEXT




<s> static void esw_set_vmsc(struct rt305x_esw *esw, unsigned vlan, unsigned msc)
{
unsigned s;

s = RT305X_ESW_VMSC_MSC_S * (vlan % 4);
esw_rmw(esw,
RT305X_ESW_REG_VMSC(vlan / 4),
RT305X_ESW_VMSC_MSC_M << s,
(msc & RT305X_ESW_VMSC_MSC_M) << s);
}

The above function is used to set and clear Msc in vlan entry for multicast tagging. I noticed that the function name of function "esw_set_vmsc" in linux 5.14-rc2 is changed to "modem




NEXT




<s> ar8xxx_mii_write32(struct ar8xxx_priv *priv, int phy_id, int regnum, u32 val)
{
struct mii_bus *bus = priv->mii_bus;
u16 lo, hi;

lo = val & 0xffff;
hi = (u16) (val >> 16);

if (priv->chip->mii_lo_first)
{
bus->write(bus, phy_id, regnum, lo);
bus->write(bus, phy_id, regnum + 1, hi);
} else {
bus->write(bus, phy_id, regnum + 1, hi);
bus->write(bus, phy_id, regnum, lo);
}
}

The above function is used to write a 32 bit value in a specific location of
PHY device. However this has a bug. If we observe the function, it can be
observed that for LSBIT first PHY, hi part of value is written first




NEXT




<s> ret_t rtl8367c_getAsicPortIsolationEfid(rtk_uint32 port, rtk_uint32 *pEfid)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_PORT_EFID_REG(port), RTL8367C_PORT_EFID_MASK(port), pEfid);
}

The above function is used to get the Efid of a specific port, it calls rtl8367c_getAsicRegBits() function in rtl8367c.c

rtk_int rtl8367c




NEXT




<s> static int rtl8366s_set_green(struct rtl8366_smi *smi, int enable)
{
int err;
unsigned i;
u32 data = 0;

if (!enable) {
for (i = 0; i <= RTL8366S_PHY_NO_MAX; i++) {
rtl8366s_set_green_port(smi, i, 0);
}
}

if (enable)
data = (RTL8366S_GREEN_ETHERNET_TX_BIT | RTL8366S_GREEN_ETHERNET_RX_BIT);

REG_RMW(smi, RTL8366S_GREEN_ETHERNET_CTRL_REG, RTL8366S_GREEN_ETHERNET_CTRL_MASK, data);

return 0;
}

The above function is used to set green eth mode. And we can get it from:

```

0196979356e:> lsmod| grep 8366
rtl8366a




NEXT




<s> static u64 notrace rttm_read_clock(void)
{
return (u64)rttm_get_counter(rttm_cs.to.of_base.base);
}

The above function is used to retrieve the value from counter registers. Here base field represents the base address of the registers in the module and ‘to’ represents the specific register to be read. You can read the same as rttm_base->to.  The to part




NEXT




<s> ret_t rtl8367c_setAsicMIBsLoggingType(rtk_uint32 index, rtk_uint32 type)
{
if(index > RTL8367C_MIB_MAX_LOG_MODE_IDX)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_CTRL5, index,type);
}

The above function is used to set the interface's loggimg type to per-port based type. This function can be executed by an asic's global MIB function pointer stored to ucMIBCallBack in rtl8367c_mi




NEXT




<s> extern int rtl930x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl931x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl931x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl930x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl930x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);
extern int rtl931x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl931x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);

/* On the RTL93XX, the RTL93XX_DMA_IF_RX_RING_CNTR track the fill level of
* the rings. Writing x into these registers substracts x from its content.
* When the content reaches the ring size, the ASIC no longer adds
* packets to this receive queue.
*/
void rtl838x_update_cntr(int r, int released)
{
/* This feature is not available on RTL838x SoCs */
}

The above function is used to update the CTR register value on the RTL93XX devices which should be adjusted for RTL8370(RTL838x) series of devices for RX counters. The following two functions should be used to




NEXT




<s> rtk_api_ret_t rtk_leaky_portIsolation_set(rtk_leaky_type_t type, rtk_enable_t enable)
{
rtk_api_ret_t retVal;
rtk_uint32 port;
rtl8367c_rma_t rmacfg;
rtk_uint32 tmp;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= LEAKY_END)
return RT_ERR_INPUT;

if (enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if (type >= 0 && type <= LEAKY_UNDEF_GARP_2F)
{
if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.portiso_leaky = enable;

if ((retVal = rtl8367c_setAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (LEAKY_IPMULTICAST == type)
{
for (port = 0; port < RTK_MAX_NUM_OF_PORT; port++)
{
if ((retVal = rtl8367c_setAsicIpMulticastPortIsoLeaky(port,enable)) != RT_ERR_OK)
return retVal;
}
}
else if (LEAKY_IGMP == type)
{
if ((retVal = rtl8367c_setAsicIGMPIsoLeaky(enable)) != RT_ERR_OK)
return retVal;
}
else if (LEAKY_CDP == type)
{
if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.portiso_leaky = enable;

if ((retVal = rtl8367c_setAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (LEAKY_CSSTP == type)
{
if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.portiso_leaky = enable;

if ((retVal = rtl8367c_setAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (LEAKY_LLDP == type)
{
if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.portiso_leaky = enable;

if ((retVal = rtl8367c_setAsicRmaLldp(tmp, &rmacfg)) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set the IGMP / CDP / CSSTP / LLDP / MLD / IPMC / GARP ports isolation type and Enable / Disable.

rtk_api_ret_t rtk_leaky_




NEXT




<s> IFX_MEI_IsModemReady (DSL_DEV_Device_t * pDev)
{
return DSL_DEV_PRIVATE(pDev)->modem_ready;
}

The above function is used to check if MEI is ready or not.

MEI Module will be able to communicate with PLC after initializing itself using above function.
Due to multiple threads run simultaneously in PLC (ie 2-3 threads), we




NEXT




<s> static int __init rtl8366rb_module_init(void)
{
return platform_driver_register(&rtl8366rb_driver);
}

The above function is used to register driver rtl8366rb_driver, and is called when the system is booting. The initialization of the driver is shown below.

static int __init macb_module_init(void) {

The




NEXT




<s> rtk_api_ret_t rtk_stp_mstpState_set(rtk_stp_msti_id_t msti, rtk_port_t port, rtk_stp_state_t stp_state)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (msti > RTK_MAX_NUM_OF_MSTI)
return RT_ERR_MSTI;

if (stp_state >= STP_STATE_END)
return RT_ERR_MSTP_STATE;

if ((retVal = rtl8367c_setAsicSpanningTreeStatus(rtk_switch_port_L2P_get(port), msti, stp_state)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the spanning tree status of the specified msti, port.</s>




NEXT




<s> ret_t rtl8367c_setAsicFlowControlSelect(rtk_uint32 select)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_FLOWCTRL_CTRL0, RTL8367C_FLOWCTRL_TYPE_OFFSET, select);
}

The above function is used to set port flow Control mode and flow controls port selection.

There are various modes of port flow control, please refer to datasheet for more details. This page shows only part of flow control mechanism related functions

// flow control
rt




NEXT




<s> int rtl8366_smi_write_reg(struct rtl8366_smi *smi, u32 addr, u32 data)
{
if (smi->ext_mbus)
return __rtl8366_mdio_write_reg(smi, addr, data);
else
return __rtl8366_smi_write_reg(smi, addr, data, true);
}

The above function is used to directly write a data to SMI registers without locking.

The main purpose of this optimization is to release write lock as quickly as possible to avoid SMI write lock conflicts, which is really helpful when the driver needs to control multiple devices in




NEXT




<s> static int sha1_hmac_setkey(struct crypto_shash *tfm, const u8 *key, unsigned int keylen)
{
struct sha1_hmac_ctx *sctx = crypto_shash_ctx(tfm);
int err;

if (keylen > SHA1_HMAC_MAX_KEYLEN) {
char *hash_alg_name = "sha1";

sctx->desc->tfm = crypto_alloc_shash(hash_alg_name, 0, 0);
if (IS_ERR(sctx->desc->tfm)) return PTR_ERR(sctx->desc->tfm);

memset(sctx->key, 0, SHA1_HMAC_MAX_KEYLEN);
err = crypto_shash_digest(sctx->desc, key, keylen, sctx->key);
if (err) return err;

sctx->keylen = SHA1_DIGEST_SIZE;

crypto_free_shash(sctx->desc->tfm);
} else {
memcpy(sctx->key, key, keylen);
sctx->keylen = keylen;
}
memset(sctx->key + sctx->keylen, 0, SHA1_HMAC_MAX_KEYLEN - sctx->keylen);

//printk("Setting keys of len: %d\n", keylen);

return 0;
}

The above function is used to set a key into the sha1_hmac HMAC context
structure for the crypto_shash. If the key is not bigger than SHA1_HMAC_MAX_KEYLEN,
then it copies over the key data into a




NEXT




<s> static void update_text(char *buf, size_t start, size_t end, void *_data)
{
struct search_data *data = _data;
struct jump_key *pos;
int k = 0;

list_for_each_entry(pos, data->head, entries) {
if (pos->offset >= start && pos->offset < end) {
char header[4];

if (k < JUMP_NB) {
int key = '0' + (pos->index % JUMP_NB) + 1;

sprintf(header, "(%c)", key);
data->keys[k] = key;
data->targets[k] = pos->target;
k++;
} else {
sprintf(header, "   ");
}

memcpy(buf + pos->offset, header, sizeof(header) - 1);
}
}
data->keys[k] = 0;
}

The above function is used to update the offset 127-135 with a header of two characters.</s>




NEXT




<s> ret_t rtl8367c_getAsicStormFilterExtUnknownUnicastMeter(rtk_uint32 *pMeter)
{
if(NULL == pMeter)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG1, RTL8367C_UNUC_STORM_EXT_METERIDX_MASK, pMeter);
}

The above function is used to acquire a unicast meter id for Storm meter

(
uint32 meterid;
) =
{
rtk_getAsicStormFilterExtUnknownUnicastMeter(&meterid);
return meter




NEXT




<s> fclose(fp);
return NULL;
}
tpw->instream = fp;
tpw->close_on_exit = close_flag;
tpw->state = FILE_ONLY;

return tpw;
}

_TYPE( struct t_pw * )
t_openpwbyname(pwname)
const char * pwname;
{
FILE * fp;
struct t_pw * t;

if(pwname == NULL)            /* Deprecated */
return t_openpw(NULL);

if((fp = fopen(pwname, "r")) == NULL)
return NULL;

t = t_openpw(fp);
t->close_on_exit = 1;
return t;
}

_TYPE( void )
t_closepw(tpw)
struct t_pw * tpw;
{
if(tpw->close_on_exit)
fclose(tpw->instream);
free(tpw);
}

_TYPE( void )
t_rewindpw(tpw)
struct t_pw * tpw;
{
#ifdef ENABLE_YP
if(tpw->state == IN_NIS)
tpw->state = FILE_NIS;
#endif
rewind(tpw->instream);
}

#ifdef ENABLE_YP
static void
savepwent(tpw, pwent)
struct t_pw * tpw;
struct t_pwent *pwent;
{
tpw->pebuf.name = tpw->userbuf;
tpw->pebuf.password.data = tpw->pwbuf;
tpw->pebuf.salt.data = tpw->saltbuf;
strcpy(tpw->pebuf.name, pwent->name);
tpw->pebuf.password.len = pwent->password.len;
memcpy(tpw->pebuf.password.data, pwent->password.data, pwent->password.len);
tpw->pebuf.salt.len = pwent->salt.len;
memcpy(tpw->pebuf.salt.data, pwent->salt.data, pwent->salt.len);
tpw->pebuf.index = pwent->index;
}
#endif /* ENABLE_YP */

_TYPE( struct t_pwent * )
t_getpwbyname(tpw, user)
struct t_pw * tpw;
const char * user;
{
char indexbuf[16];
char passbuf[MAXB64PARAMLEN];
char saltstr[MAXB64SALTLEN];
char username[MAXUSERLEN];
#ifdef ENABLE_YP
struct t_passwd * nisent;
#endif

t_rewindpw(tpw);

while(t_nextfield(tpw->instream, username, MAXUSERLEN) > 0) {

The above function is used to retrieve the record for a password entry from a password file. The return data structure contains the password entry information that is stored in the following fields:

passbuf[]
    Contants the encoded password for the record
indexbuf[]
   




NEXT




<s> static void adj_match_dir(match_f *match_direction)
{
if (*match_direction == FIND_NEXT_MATCH_DOWN)
*match_direction =
MATCH_TINKER_PATTERN_DOWN;
else if (*match_direction == FIND_NEXT_MATCH_UP)
*match_direction =
MATCH_TINKER_PATTERN_UP;
/* else, do no change.. */
}

The above function is used to adjust/navigate within a "matching" pattern.
However, I'm confused about to where exactly the match_direction variable
resolves to.. and I'm not understanding whats going on in the else.
Can anyone




NEXT




<s> rtk_api_ret_t rtk_filter_iprange_set(rtk_uint32 index, rtk_filter_iprange_t type, ipaddr_t upperIp, ipaddr_t lowerIp)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

if(type >= IPRANGE_END)
return RT_ERR_OUT_OF_RANGE;

if(lowerIp > upperIp)
return RT_ERR_INPUT;

if((ret = rtl8367c_setAsicAclIpRange(index, type, upperIp, lowerIp)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to set an IP range to the ACL Entry.

It returns RT_ERR_OK for successful operation, RT_ERR_FAILED for general
failed operation, RT_ERR_OUT_OF_RANGE if any invalid index, type or




NEXT




<s> static int esw_get_port_link(struct switch_dev *dev,
int port,
struct switch_port_link *link)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
u32 speed, poa;

if (port < 0 || port >= RT305X_ESW_NUM_PORTS)
return -EINVAL;

poa = esw_r32(esw, RT305X_ESW_REG_POA) >> port;

link->link = (poa >> RT305X_ESW_LINK_S) & 1;
link->duplex = (poa >> RT305X_ESW_DUPLEX_S) & 1;
if (port < RT305X_ESW_NUM_LEDS) {
speed = (poa >> RT305X_ESW_SPD_S) & 1;
} else {
if (port == RT305X_ESW_NUM_PORTS - 1)
poa >>= 1;
speed = (poa >> RT305X_ESW_SPD_S) & 3;
}
switch (speed) {
case 0:
link->speed = SWITCH_PORT_SPEED_10;
break;
case 1:
link->speed = SWITCH_PORT_SPEED_100;
break;
case 2:
case 3: /* forced gige speed can be 2 or 3 */
link->speed = SWITCH_PORT_SPEED_1000;
break;
default:
link->speed = SWITCH_PORT_SPEED_UNKNOWN;
break;
}

return 0;
}

The above function is used to query the port link settings of each port.
From the function description, we can find that the port link settings of each
port of 80G can be queried by this method.

There may be many different types of functions




NEXT




<s> u16 rtl93xx_pick_tx_queue(struct net_device *dev, struct sk_buff *skb,
struct net_device *sb_dev)
{
if (skb->priority >= TC_PRIO_CONTROL)
return 1;

return 0;
}

The above function is used to select default Tx QID. This function doesn't
work well because the skb->priority values are not accurate, since it is based
on iptables Priority marking. Due to which the traffic is not transmitted
acc




NEXT




<s> static int fe_remove(struct platform_device *pdev)
{
struct net_device *dev = platform_get_drvdata(pdev);
struct fe_priv *priv = netdev_priv(dev);

netif_napi_del(&priv->rx_napi);
kfree(priv->hw_stats);

cancel_work_sync(&priv->pending_work);

unregister_netdev(dev);
free_netdev(dev);
platform_set_drvdata(pdev, NULL);

return 0;
}

The above function is used to release the device on removing the device from the system</s>




NEXT




<s> static u64 rtl931x_read_l2_entry_using_hash(u32 hash, u32 pos, struct rtl838x_l2_entry *e)
{
u32 r[4];
struct table_reg *q = rtl_table_get(RTL9310_TBL_0, 0);
u32 idx;
u64 mac;
u64 seed;

pr_debug("%s: hash %08x, pos: %d\n", __func__, hash, pos);

/* On the RTL93xx, 2 different hash algorithms are used making it a total of
* 8 buckets that need to be searched, 4 for each hash-half
* Use second hash space when bucket is between 4 and 8
*/
if (pos >= 4) {
pos -= 4;
hash >>= 16;
} else {
hash &= 0xffff;
}

idx = (0 << 14) | (hash << 2) | pos; /* Search SRAM, with hash and at pos in bucket */
pr_debug("%s: NOW hash %08x, pos: %d\n", __func__, hash, pos);

rtl_table_read(q, idx);
for (int i = 0; i < 4; i++)
r[i] = sw_r32(rtl_table_data(q, i));

rtl_table_release(q);

rtl931x_fill_l2_entry(r, e);

pr_debug("%s: valid: %d, nh: %d\n", __func__, e->valid, e->next_hop);
if (!e->valid)
return 0;

mac = ((u64)e->mac[0]) << 40 |
((u64)e->mac[1]) << 32 |
((u64)e->mac[2]) << 24 |
((u64)e->mac[3]) << 16 |
((u64)e->mac[4]) << 8 |
((u64)e->mac[5]);

seed = rtl931x_l2_hash_seed(mac, e->rvid);
pr_debug("%s: mac %016llx, seed %016llx\n", __func__, mac, seed);

/* return vid with concatenated mac as unique id */
return seed;
}

The above function is used to query l2 entries in the CAM.
There are three problems:
It returns a hash of a seed combining the mac address and the vid but these have nothing to do with each other, hence a mac change with the same vid would cause




NEXT




<s> ret_t rtl8367c_getAsicPortMirrorIsolationTxLeaky(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_TX_ISOLATION_LEAKY_OFFSET, pEnabled);
}

The above function is used to check if port mirroring isolation is enabled for tx leak mode for all switch. The bit map 0 is for switch 0 and bit map 1 is for switch 1. To enable tx leak mode, both bit map should be




NEXT




<s> static void rtl930x_get_l3_router_mac(u32 idx, struct rtl93xx_rt_mac *m)
{
u32 v, w;
/* Read L3_ROUTER_MAC table (0) via register RTL9300_TBL_1 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_1, 0);

rtl_table_read(r, idx);
/* The table has a size of 7 registers, 64 entries */
v = sw_r32(rtl_table_data(r, 0));
w = sw_r32(rtl_table_data(r, 3));
m->valid = !!(v & BIT(20));
if (!m->valid)
goto out;

m->p_type = !!(v & BIT(19));
m->p_id = (v >> 13) & 0x3f;  /* trunk id of port */
m->vid = v & 0xfff;
m->vid_mask = w & 0xfff;
m->action = sw_r32(rtl_table_data(r, 6)) & 0x7;
m->mac_mask = ((((u64)sw_r32(rtl_table_data(r, 5))) << 32) & 0xffffffffffffULL) |
(sw_r32(rtl_table_data(r, 4)));
m->mac = ((((u64)sw_r32(rtl_table_data(r, 1))) << 32) & 0xffffffffffffULL) |
(sw_r32(rtl_table_data(r, 2)));
/* Bits L3_INTF and BMSK_L3_INTF are 0 */

out:
rtl_table_release(r);
}

The above function is used to get the IP/MAC mapping of a port. For instance,
the function gets all the 64 entries and selects a specific one if the specified
index is provided.</s>




NEXT




<s> int ifxdeu_init_md5 (void)
{
int ret = -ENOSYS;


if ((ret = crypto_register_shash(&ifxdeu_md5_alg)))
goto md5_err;

printk (KERN_NOTICE "IFX DEU MD5 initialized%s.\n", disable_deudma ? "" : " (DMA)");
return ret;

md5_err:
printk(KERN_ERR "IFX DEU MD5 initialization failed!\n");
return ret;
}

The above function is used to register the MD5 algorithm for usage in the driver, when the ‘IFXDEU_DMA’ capability is not requested. The driver is then unable to use hardware acceleration to implement SHA1, SHA224,SHA256




NEXT




<s> static void rtl931x_vlan_set_untagged(u32 vlan, u64 portmask)
{
struct table_reg *r = rtl_table_get(RTL9310_TBL_3, 0);

rtl839x_set_port_reg_be(portmask << 7, rtl_table_data(r, 0));
rtl_table_write(r, vlan);
rtl_table_release(r);
}

The above function is used to set VLAN and untagged ports.

However, in RTL9311B I'm using,
rtl_table_get(RTL9310_TBL_3, 4)





NEXT




<s> static void rtk_hal_set_phy_reg(unsigned int port ,unsigned int reg_addr,unsigned int reg_val)
{
ret_t retVal;

retVal = rtk_port_phyReg_set(port, reg_addr, reg_val);
if (retVal == RT_ERR_OK)
printk("Set: phy[%d].reg[%d] = 0x%04x\n", port, reg_addr, reg_val);
else
printk("write phy reg failed\n");
}

The above function is used to write Phy register.The value of reg_addr should
be a MAC_CONTROL,MAC_STATUS register at first.I need to know which register value
should be set through it.

What is the structure of RTK register




NEXT




<s> static void qca955x_device_reset_clear(unsigned int mask)
{
unsigned int t, reg;

reg = KSEG1ADDR(AR71XX_RESET_BASE +
QCA955X_RESET_REG_RESET_MODULE);

t = READREG(reg);
WRITEREG(reg, t & ~mask);
}

The above function is used to clear some software reset flags on
AR71XX. But due to my misplaced trust in the kernel code I started
to assume that the code was correct and all the devices were reset
after power on and after reset. Which was




NEXT




<s> static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to forward 0..4 byte long OAM frames  within the
network stack. It is expected that this function will be implemented by the
network stack driver. Because the network stack is not always used with
Atm hardware we need to use




NEXT




<s> sig_catch (sig)
int     sig;
{
sig_caught = 1;
}

The above function is used to interrupt the program after a signal is caught. The program can continue after the signal is caught so the function returns a value.

The signal that was caught is given by the sig parameter. A common mistake is to call sig_catch in a




NEXT




<s> static int b53_phy_config_init(struct phy_device *phydev)
{
struct b53_device *dev = phydev->priv;

/* we don't use page 0xff, so force a page set */
dev->current_page = 0xff;
/* force the ethX as alias */
dev->sw_dev.alias = phydev->attached_dev->name;

return 0;
}

The above function is used to intialise the bcm5303a0/bcs303a0 for the ethernet interface.

It has already been used for the bcm83343a1/bcs83




NEXT




<s> static AT91S_DataFlashStatus AT91F_DataFlashGetStatus(AT91PS_DataflashDesc pDesc)
{
AT91S_DataFlashStatus status;

/* first send the read status command (D7H) */
pDesc->command[0] = DB_STATUS;
pDesc->command[1] = 0;

pDesc->DataFlash_state = GET_STATUS;
pDesc->tx_data_size    = 0 ; /* Transmit the command and receive response */
pDesc->tx_cmd_pt       = pDesc->command ;
pDesc->rx_cmd_pt       = pDesc->command ;
pDesc->rx_cmd_size     = 2 ;
pDesc->tx_cmd_size     = 2 ;
status = AT91F_SpiWrite (pDesc);

pDesc->DataFlash_state = *( (unsigned char *) (pDesc->rx_cmd_pt) +1);
return status;
}

The above function is used to check the status of the DataFlash. The value is returned from the 'AT91F_DataFlash GetStatus' function if the value for 'AT91F_SPI Write' in the previous code is non-zero.




NEXT




<s> ret_t rtl8367c_setAsicLedBlinkRate(rtk_uint32 blinkRate)
{
if(blinkRate >= LEDBLINKRATE_END)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBits(RTL8367C_REG_LED_MODE, RTL8367C_SEL_LEDRATE_MASK, blinkRate);
}

The above function is used to set ASIC LED flash rate. It takes in one parameters for as the LED flash rate value. And it returns error if it is out of the value range.

The below is to calculate 100 microsecond for one blink rate




NEXT




<s> swconfig_get_link(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct switch_port_link *link = val->value.link;

if (val->port_vlan >= dev->ports)
return -EINVAL;

if (!dev->ops->get_port_link)
return -EOPNOTSUPP;

memset(link, 0, sizeof(*link));
return dev->ops->get_port_link(dev, val->port_vlan, link);
}

The above function is used to get the configuration of the logical or physical port on the chip.

There is just one argument to this function, the switch_port_link* pointer that is used to return the configuration of device ports which is described in the below structure.




NEXT




<s> int AT91F_MCI_GetCSD (AT91PS_MciDevice pMCI_Device, unsigned int relative_card_address , unsigned int * response)
{

if(AT91F_MCI_SendCommand(pMCI_Device,
AT91C_SEND_CSD_CMD,
(relative_card_address << 16)) != AT91C_CMD_SEND_OK)
return AT91C_CMD_SEND_ERROR;

response[0] = AT91C_BASE_MCI->MCI_RSPR[0];
response[1] = AT91C_BASE_MCI->MCI_RSPR[1];
response[2] = AT91C_BASE_MCI->MCI_RSPR[2];
response[3] = AT91C_BASE_MCI->MCI_RSPR[3];

return AT91C_CMD_SEND_OK;
}

The above function is used to read CSD Register, the function is to read the four bytes in the CSD register, when writing to the response is an array.
From the function AT91F_MCI_GetCSD is called in the function , it




NEXT




<s> void rtl839x_mask_port_reg_be(u64 clear, u64 set, int reg)
{
sw_w32_mask((u32)(clear >> 32), (u32)(set >> 32), reg);
sw_w32_mask((u32)(clear & 0xffffffff), (u32)(set & 0xffffffff), reg + 4);
}

The above function is used to set some port fields, for example:

rtl839x_mask_port_reg_be(

#if SUPPORT_8023_WLAN_MODE && IS_GMAC_SWIT




NEXT




<s> read_uimage_header(struct mtd_info *mtd, size_t offset, u_char *buf,
size_t header_len)
{
size_t retlen;
int ret;

ret = mtd_read(mtd, offset, header_len, &retlen, buf);
if (ret) {
pr_debug("read error in \"%s\"\n", mtd->name);
return ret;
}

if (retlen != header_len) {
pr_debug("short read in \"%s\"\n", mtd->name);
return -EIO;
}

return 0;
}

The above function is used to read raw image header from MTD, this function is only used for raw image or UBI image format.</s>




NEXT




<s> static int rtl8367_get_vlan_mc(struct rtl8366_smi *smi, u32 index,
struct rtl8366_vlan_mc *vlanmc)
{
u32 data[RTL8367_VLAN_MC_DATA_SIZE];
int err;
int i;

memset(vlanmc, '\0', sizeof(struct rtl8366_vlan_mc));

if (index >= RTL8367_NUM_VLANS)
return -EINVAL;

for (i = 0; i < ARRAY_SIZE(data); i++)
REG_RD(smi, RTL8367_VLAN_MC_BASE(index) + i, &data[i]);

vlanmc->member = (data[0] >> RTL8367_VLAN_MC_MEMBER_SHIFT) &
RTL8367_VLAN_MC_MEMBER_MASK;
vlanmc->fid = (data[1] >> RTL8367_VLAN_MC_FID_SHIFT) &
RTL8367_VLAN_MC_FID_MASK;
vlanmc->vid = (data[3] >> RTL8367_VLAN_MC_EVID_SHIFT) &
RTL8367_VLAN_MC_EVID_MASK;

return 0;
}

The above function is used to retrieve MAC learning information
from registers, where index is the VLAN index.

static int rtl8367_set_vlan_mc(struct rtl8366_smi *smi, int index




NEXT




<s> static void rtl839x_set_static_move_action(int port, bool forward)
{
int shift = MV_ACT_PORT_SHIFT(port);
u32 val = forward ? MV_ACT_FORWARD : MV_ACT_DROP;

sw_w32_mask(MV_ACT_MASK << shift, val << shift,
RTL839X_L2_PORT_STATIC_MV_ACT(port));
}

The above function is used to enable/disable forwarding of frames, for a specified port.

For example, I was able to use netfilter to write a program that can block access for a MAC address:

int i = 0;

char *




NEXT




<s> static int aw9523_pmx_set_mux(struct pinctrl_dev *pctl, unsigned int fsel,
unsigned int grp)
{
struct aw9523 *awi = pinctrl_dev_get_drvdata(pctl);
int ret, pin = aw9523_pins[grp].number % AW9523_PINS_PER_PORT;

if (fsel >= ARRAY_SIZE(aw9523_pmx))
return -EINVAL;

/*
* This maps directly to the aw9523_pmx array: programming a
* high bit means "gpio" and a low bit means "pwm".
*/
mutex_lock(&awi->i2c_lock);
ret = regmap_update_bits(awi->regmap, AW9523_REG_PORT_MODE(pin),
BIT(pin), (fsel ? BIT(pin) : 0));
mutex_unlock(&awi->i2c_lock);
return ret;
}

The above function is used to set function for single pin

static void aw9523_pin_mux_setup(struct pinctrl_dev *pctl)
{
struct aw9523 *__pctl_data = pinctrl




NEXT




<s> static int bcm6348_emac_remove(struct platform_device *pdev)
{
struct net_device *ndev = platform_get_drvdata(pdev);
struct bcm6348_emac *emac = netdev_priv(ndev);
unsigned int i;

emac_writel(emac, 0, ENET_MIISC_REG);

for (i = 0; i < emac->num_resets; i++)
reset_control_assert(emac->reset[i]);

for (i = 0; i < emac->num_clocks; i++)
clk_disable_unprepare(emac->clock[i]);

return 0;
}

The above function is used to release resources when the BCM6348 emac driver is removed. In this function, we disable the clocks and reset the emac.

We also need to release the resources used by the MII chip. We can do




NEXT




<s> ret_t rtl8367c_getAsic1xPBAuthConfig(rtk_uint32 port, rtk_uint32 *pAuth)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_PORT_AUTH_REG, port, pAuth);
}

The above function is used to check whether the 802.1x for a port is enabled.

Ret_t rtl8367c_set1xEnable(rtk_port_t port_num, rtl_xchg_




NEXT




<s> static void fe_get_ringparam(struct net_device *dev,
struct ethtool_ringparam *ring)
{
struct fe_priv *priv = netdev_priv(dev);

ring->rx_max_pending = MAX_DMA_DESC;
ring->tx_max_pending = MAX_DMA_DESC;
ring->rx_pending = priv->rx_ring.rx_ring_size;
ring->tx_pending = priv->tx_ring.tx_ring_size;
}

The above function is used to populate the ring parameters of ethtool
device in system memory. But currently the values of priv->rx_ring.rx_ring_size
and priv->tx_ring.tx_ring_size are NULL.

How




NEXT




<s> ret_t rtl8367c_setAsicSvlanMC2SConf(rtk_uint32 index,rtl8367c_svlan_mc2s_t* pSvlanMc2sCfg)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint16 *accessPtr;
rtk_uint32 i;
rtk_uint16 smiSvlanMC2S[RTL8367C_SVLAN_MC2S_LEN];

if(index > RTL8367C_MC2SIDXMAX)
return RT_ERR_ENTRY_INDEX;

memset(smiSvlanMC2S, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_MC2S_LEN);
_rtl8367c_svlanMc2sStUser2Smi(pSvlanMc2sCfg, smiSvlanMC2S);

accessPtr = smiSvlanMC2S;

regData = *accessPtr;
for(i = 0; i < 5; i++)
{
retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_MCAST2S_ENTRY_BASE_REG(index) + i, regData);
if(retVal != RT_ERR_OK)
return retVal;

accessPtr ++;
regData = *accessPtr;
}

return retVal;
}

The above function is used to set multiple SVLAN as MC to SGID mapping in one go. This function takes multiple SVLAN indexes to register a mapping between VLANs and SVIDs and can only be called from SMIs.</s>




NEXT




<s> init_state_t rtk_switch_initialState_get(void)
{
return init_state;
}

The above function is used to return the state where the process is initialized.
rtk_switch_init_state_set is used to change the state where the process is
initialized.

The following is the code to initialize the state where the process is initialized.




NEXT




<s> static int b53_mdio_phy_write16(struct b53_device *dev, int addr, u8 reg,
u16 value)
{
struct mii_bus *bus = dev->priv;

return mdiobus_write(bus, addr, reg, value);
}

The above function is used to write a u16 value to the register specified in
reg at the address specified in addr. This function is used to write the MAC
address of the PHY and other parameters.

static int b53_mdio_phy




NEXT




<s> static bool nmbm_write_mgmt_range(struct nmbm_instance *ni, uint32_t ba,
uint32_t limit, const void *data,
uint32_t size, uint32_t *actual_start_ba,
uint32_t *actual_end_ba)
{
const uint8_t *ptr = data;
uint32_t sizeremain = size, chunksize;
bool success;

while (sizeremain && ba < limit) {
chunksize = sizeremain;
if (chunksize > bmtd.blk_size)
chunksize = bmtd.blk_size;

if (nmbm_get_block_state(ni, ba) != BLOCK_ST_GOOD)
goto next_block;

/* Insurance to detect unexpected bad block marked by user */
if (nmbm_check_bad_phys_block(ni, ba)) {
nmbm_set_block_state(ni, ba, BLOCK_ST_BAD);
goto next_block;
}

success = nmbm_erase_block_and_check(ni, ba);
if (!success)
goto skip_bad_block;

success = nmbn_write_verify_data(ni, ba2addr(ni, ba), ptr,
chunksize);
if (!success)
goto skip_bad_block;

if (sizeremain == size)
*actual_start_ba = ba;

ptr += chunksize;
sizeremain -= chunksize;

goto next_block;

skip_bad_block:
nmbm_mark_phys_bad_block(ni, ba);
nmbm_set_block_state(ni, ba, BLOCK_ST_BAD);

next_block:
ba++;
}

if (sizeremain)
return false;

*actual_end_ba = ba;

return true;
}

The above function is used to write management info to the internal MMC, which
is called at start and finish of the data stage, e.g., a data write
operation would use both the start and finish functions.

I used this function to investigate the failure




NEXT




<s> struct device * wl_glue_get_dmadev(void *dev)
{
struct device *dma_dev;

switch (active_bus_type)
{
#ifdef CONFIG_SSB
case WL_GLUE_BUS_TYPE_SSB:
dma_dev = ((struct ssb_device *)dev)->dma_dev;
break;
#endif /* CONFIG_SSB */

#ifdef CONFIG_BCMA
case WL_GLUE_BUS_TYPE_BCMA:
dma_dev = ((struct bcma_device *)dev)->dma_dev;
break;
#endif /* CONFIG_BCMA */

default:
BUG();
dma_dev = NULL;
break;
}

return dma_dev;
}

The above function is used to get the device that will be used as the DMA engine for a particular device.  The WL_GLUE_BUS_TYPE_SSB and the WL_GLUE_BUS_TYPE_BCMA are defined as macros in




NEXT




<s> static void fe_phy_stop(struct fe_priv *priv)
{
unsigned long flags;
int i;

for (i = 0; i < 8; i++)
if (priv->phy->phy_fixed[i]) {
spin_lock_irqsave(&priv->phy->lock, flags);
priv->link[i] = 0;
if (priv->soc->mdio_adjust_link)
priv->soc->mdio_adjust_link(priv, i);
spin_unlock_irqrestore(&priv->phy->lock, flags);
} else if (priv->phy->phy[i]) {
phy_stop(priv->phy->phy[i]);
}
}

The above function is used to stop a PHY. When we want to remove the device we want it to be in a known power down state. We first check if the port is fixed by the board definition and only bother if it isn’t already connected to something else.




NEXT




<s> static int mt798x_2p5ge_phy_config_aneg(struct phy_device *phydev)
{
bool changed = false;
u32 adv;
int ret;

if (phydev->autoneg == AUTONEG_DISABLE) {
/* Configure half duplex with genphy_setup_forced,
* because genphy_c45_pma_setup_forced does not support.
*/
return phydev->duplex != DUPLEX_FULL
? genphy_setup_forced(phydev)
: genphy_c45_pma_setup_forced(phydev);
}

ret = genphy_c45_an_config_aneg(phydev);
if (ret < 0)
return ret;
if (ret > 0)
changed = true;

adv = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);
ret = phy_modify_changed(phydev, MII_CTRL1000,
ADVERTISE_1000FULL | ADVERTISE_1000HALF,
adv);
if (ret < 0)
return ret;
if (ret > 0)
changed = true;

return genphy_c45_check_and_restart_aneg(phydev, changed);
}

The above function is used to configure Genphy to support 2.5G link only. When 2.5G link mode is detected, the autonegotiation should be disabled. In order to support this behavior, we modify the function name to mt798




NEXT




<s> int aes_set_key_skcipher (struct crypto_skcipher *tfm, const u8 *in_key, unsigned int key_len)
{
return aes_set_key(crypto_skcipher_tfm(tfm), in_key, key_len);
}

The above function is used to apply the new key (which is inputted by in_key argument and the length of such input is decided by key_len argument) to the AES algorithm.

If this function returns an error code, the new key cannot be applied




NEXT




<s> rtk_api_ret_t rtk_vlan_UntagDscpPriorityEnable_get(rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtk_uint32  value;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicVlanUntagDscpPriorityEn(&value)) != RT_ERR_OK)
return retVal;

*pEnable = (rtk_enable_t)value;
return RT_ERR_OK;
}

The above function is used to get the VLAN configuration of Untagged DSCP Priority Enable.

## 2.1.24.26 VLAN_UNTAG_DSCP_PRIORITY_EN

| 7




NEXT




<s> static void set_mono_theme(void)
{
dlg.screen.atr = A_NORMAL;
dlg.shadow.atr = A_NORMAL;
dlg.dialog.atr = A_NORMAL;
dlg.title.atr = A_BOLD;
dlg.border.atr = A_NORMAL;
dlg.button_active.atr = A_REVERSE;
dlg.button_inactive.atr = A_DIM;
dlg.button_key_active.atr = A_REVERSE;
dlg.button_key_inactive.atr = A_BOLD;
dlg.button_label_active.atr = A_REVERSE;
dlg.button_label_inactive.atr = A_NORMAL;
dlg.inputbox.atr = A_NORMAL;
dlg.inputbox_border.atr = A_NORMAL;
dlg.searchbox.atr = A_NORMAL;
dlg.searchbox_title.atr = A_BOLD;
dlg.searchbox_border.atr = A_NORMAL;
dlg.position_indicator.atr = A_BOLD;
dlg.menubox.atr = A_NORMAL;
dlg.menubox_border.atr = A_NORMAL;
dlg.item.atr = A_NORMAL;
dlg.item_selected.atr = A_REVERSE;
dlg.tag.atr = A_BOLD;
dlg.tag_selected.atr = A_REVERSE;
dlg.tag_key.atr = A_BOLD;
dlg.tag_key_selected.atr = A_REVERSE;
dlg.check.atr = A_BOLD;
dlg.check_selected.atr = A_REVERSE;
dlg.uarrow.atr = A_BOLD;
dlg.darrow.atr = A_BOLD;
}

The above function is used to set the monochrome theme. It looks as if you’re only changing the text colors using this code, but this code will also update the background color to default if it was configured to a non-default value using the other theme select.




NEXT




<s> void wpas_ubus_notify(struct wpa_supplicant *wpa_s, const struct wps_credential *cred)
{
u16 auth_type;
char *ifname, *encryption, *ssid, *key;
size_t ifname_len;

if (!cred)
return;

auth_type = cred->auth_type;

if (auth_type == (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK))
auth_type = WPS_AUTH_WPA2PSK;

if (auth_type != WPS_AUTH_OPEN &&
auth_type != WPS_AUTH_WPAPSK &&
auth_type != WPS_AUTH_WPA2PSK) {
wpa_printf(MSG_DEBUG, "WPS: Ignored credentials for "
"unsupported authentication type 0x%x",
auth_type);
return;
}

if (auth_type == WPS_AUTH_WPAPSK || auth_type == WPS_AUTH_WPA2PSK) {
if (cred->key_len < 8 || cred->key_len > 2 * PMK_LEN) {
wpa_printf(MSG_ERROR, "WPS: Reject PSK credential with "
"invalid Network Key length %lu",
(unsigned long) cred->key_len);
return;
}
}

blob_buf_init(&b, 0);

ifname_len = strlen(wpa_s->ifname);
ifname = blobmsg_alloc_string_buffer(&b, "ifname", ifname_len + 1);
memcpy(ifname, wpa_s->ifname, ifname_len + 1);
ifname[ifname_len] = '\0';
blobmsg_add_string_buffer(&b);

switch (auth_type) {
case WPS_AUTH_WPA2PSK:
encryption = "psk2";
break;
case WPS_AUTH_WPAPSK:
encryption = "psk";
break;
default:
encryption = "none";
break;
}

blobmsg_add_string(&b, "encryption", encryption);

ssid = blobmsg_alloc_string_buffer(&b, "ssid", cred->ssid_len + 1);
memcpy(ssid, cred->ssid, cred->ssid_len);
ssid[cred->ssid_len] = '\0';
blobmsg_add_string_buffer(&b);

if (cred->key_len > 0) {
key = blobmsg_alloc_string_buffer(&b, "key", cred->key_len + 1);
memcpy(key, cred->key, cred->key_len);
key[cred->key_len] = '\0';
blobmsg_add_string_buffer(&b);
}

//	ubus_notify(ctx, &wpa_s->ubus.obj, "wps_credentials", b.head, -1);
ubus_send_event(ctx, "wps_credentials", b.head);
}

The above function is used to convert wps Credential into ubus notifications.

The new ubus event is "wps_credentials"</s>




NEXT




<s> t_pwcopy(bakfp, passfp, diff);

fclose(bakfp);
fclose(passfp);

#ifdef USE_RENAME
unlink(bakfile);
if(rename(pwname, bakfile) < 0) {
free(bakfile);
free(bakfile2);
return -1;
}

The above function is used to change the password of an existing account. The pwentry_t passed to this function must be associated with an existing account. If you try to change the password for a non-existent user, or if the account does not exist, this




NEXT




<s> uc_bpf_tc_detach(uc_vm_t *vm, size_t nargs)
{
uc_value_t *ifname = uc_fn_arg(0);
uc_value_t *type = uc_fn_arg(1);
uc_value_t *prio = uc_fn_arg(2);

return uc_bpf_set_tc_hook(ifname, type, prio, -1);
}

The above function is used to undo attaching a TC hook. The return value is either OK or error code.

- #include <stdio.h>
- #include <stdlib.h>
- #include "bpf_program.




NEXT




<s> ret_t rtl8367c_setAsicEavSysTimeAdjust(rtk_uint32 type, rtk_uint32 second, rtk_uint32 nanoSecond)
{
ret_t retVal;
rtk_uint32 sec_h, sec_l, nsec8_h, nsec8_l;
rtk_uint32 nano_second_8;
rtk_uint32 regData, busyFlag, count;

if (type >= PTP_TIME_ADJ_END)
return RT_ERR_INPUT;
if(nanoSecond > RTL8367C_EAV_NANOSECONDMAX)
return RT_ERR_INPUT;

regData = 0;
sec_h = second >>16;
sec_l = second & 0xFFFF;
nano_second_8 = nanoSecond >> 3;
nsec8_h = (nano_second_8 >>16) & RTL8367C_PTP_TIME_NSEC_H_NSEC_MASK;
nsec8_l = nano_second_8 &0xFFFF;

if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_SEC_H_SEC, sec_h)) != RT_ERR_OK)
return retVal;
if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_SEC_L_SEC, sec_l)) != RT_ERR_OK)
return retVal;
if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_NSEC_L_NSEC, nsec8_l)) != RT_ERR_OK)
return retVal;

if (PTP_TIME_ADJ_INC == type)
regData = nsec8_h | (PTP_TIME_INC<<RTL8367C_PTP_TIME_NSEC_H_CMD_OFFSET) | RTL8367C_PTP_TIME_NSEC_H_EXEC_MASK;
else
regData = nsec8_h | (PTP_TIME_DEC<<RTL8367C_PTP_TIME_NSEC_H_CMD_OFFSET) | RTL8367C_PTP_TIME_NSEC_H_EXEC_MASK;

if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, regData)) != RT_ERR_OK)
return retVal;

count = 0;
do {
if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, RTL8367C_PTP_TIME_NSEC_H_EXEC_OFFSET, &busyFlag)) != RT_ERR_OK)
return retVal;
count++;
} while ((busyFlag != 0)&&(count<5));

if (busyFlag != 0)
return RT_ERR_BUSYWAIT_TIMEOUT;

return RT_ERR_OK;
}

The above function is used to perform software system time adjustment through
8367c hardware register.The software call the above function to perform this
adjustment task at application
level.

#endif</s>




NEXT




<s> static inline void oxnas_register_value_mask(void __iomem *p,
unsigned mask, unsigned new_value)
{
/* TODO sanity check mask & new_value = new_value */
u32 val = readl_relaxed(p);

val &= ~mask;
val |= new_value;
writel_relaxed(val, p);
}

The above function is used to change a value contained in memory, taking into account that the
actual value can be modified by interrupt handlers.

The problem is that it uses `writel_relaxed` which will not call write barrier.
The issue was




NEXT




<s> int AT91F_MCI_MMC_GetAllCID (AT91PS_MciDevice pMCI_Device, unsigned int *response)
{
int Nb_Cards_Found=-1;

while(1)
{
if(AT91F_MCI_SendCommand(pMCI_Device,
AT91C_MMC_ALL_SEND_CID_CMD,
AT91C_NO_ARGUMENT) != AT91C_CMD_SEND_OK)
return Nb_Cards_Found;
else
{
Nb_Cards_Found = 0;
//* Assignation of the relative address to the MMC CARD
pMCI_Device->pMCI_DeviceFeatures[Nb_Cards_Found].Relative_Card_Address = Nb_Cards_Found + AT91C_FIRST_RCA;
//* Set the insert flag
pMCI_Device->pMCI_DeviceFeatures[Nb_Cards_Found].Card_Inserted = AT91C_MMC_CARD_INSERTED;

if (AT91F_MCI_SendCommand(pMCI_Device,
AT91C_MMC_SET_RELATIVE_ADDR_CMD,
(Nb_Cards_Found + AT91C_FIRST_RCA) << 16) != AT91C_CMD_SEND_OK)
return AT91C_CMD_SEND_ERROR;

//* If no error during assignation address ==> Increment Nb_cards_Found
Nb_Cards_Found++ ;
}
}
}

The above function is used to initialize the multimedia card after a MMC CARD is inserted (for the first time).
This function is also used to count the number of multimedia cards inserted.

It is invoked by the following source code:

if(




NEXT




<s> static inline void sata_oxnas_clear_reg_access_error(struct ata_port *ap)
{
struct sata_oxnas_port_priv *pd = ap->private_data;
u32 *base = pd->port_base;
u32 reg;

reg = ioread32(base + INT_STATUS);

DPRINTK("ENTER\n");
if (reg & INT_REG_ACCESS_ERR) {
DPRINTK("clearing register access error on port %d\n",
ap->port_no);
iowrite32(INT_REG_ACCESS_ERR, base + INT_STATUS);
}
reg = ioread32(base + INT_STATUS);
if (reg & INT_REG_ACCESS_ERR)
DPRINTK("register access error didn't clear\n");
}

The above function is used to clear the register access error that occurs due
to improper write operation of the IORDY register.

In the previous patch to fix this error, there was some hard coded
delay which led to incorrect read/write access to the




NEXT




<s> static int ubnt_ledbar_apply_state(struct ubnt_ledbar *ledbar)
{
char setup_msg[UBNT_LEDBAR_TRANSACTION_LENGTH] = {0x40, 0x10, 0x00, 0x00,
0x00, 0x00, 0x00, 0x11};
char led_msg[UBNT_LEDBAR_TRANSACTION_LENGTH] = {0x40, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00};
char i2c_response;
int ret = 0;

mutex_lock(&ledbar->lock);

led_msg[UBNT_LEDBAR_TRANSACTION_BLUE_IDX] = ledbar->led_blue.brightness;
led_msg[UBNT_LEDBAR_TRANSACTION_GREEN_IDX] = ledbar->led_green.brightness;
led_msg[UBNT_LEDBAR_TRANSACTION_RED_IDX] = ledbar->led_red.brightness;
led_msg[UBNT_LEDBAR_TRANSACTION_LED_COUNT_IDX] = ledbar->led_count;

gpiod_set_value(ledbar->enable_gpio, 1);

msleep(10);

ubnt_ledbar_perform_transaction(ledbar, setup_msg, sizeof(setup_msg), &i2c_response, sizeof(i2c_response));
if (i2c_response != UBNT_LEDBAR_TRANSACTION_SUCCESS) {
dev_err(&ledbar->client->dev, "Error initializing LED transaction: %02hhx\n", i2c_response);
ret = -EINVAL;
goto out_gpio;
}

ubnt_ledbar_perform_transaction(ledbar, led_msg, sizeof(led_msg), &i2c_response, sizeof(i2c_response));
if (i2c_response != UBNT_LEDBAR_TRANSACTION_SUCCESS) {
dev_err(&ledbar->client->dev, "Failed LED transaction: %02hhx\n", i2c_response);
ret = -EINVAL;
goto out_gpio;
}

msleep(10);
out_gpio:
gpiod_set_value(ledbar->enable_gpio, 0);

mutex_unlock(&ledbar->lock);

return ret;
}

The above function is used to update LED state. LED_count will determine how many LEDs to turn on.

The following LED states are supported.</s>




NEXT




<s> static inline int fe_skb_padto(struct sk_buff *skb, struct fe_priv *priv)
{
unsigned int len;
int ret;

ret = 0;
if (unlikely(skb->len < VLAN_ETH_ZLEN)) {
if ((priv->flags & FE_FLAG_PADDING_64B) &&
!(priv->flags & FE_FLAG_PADDING_BUG))
return ret;

if (skb_vlan_tag_present(skb))
len = ETH_ZLEN;
else if (skb->protocol == cpu_to_be16(ETH_P_8021Q))
len = VLAN_ETH_ZLEN;
else if (!(priv->flags & FE_FLAG_PADDING_64B))
len = ETH_ZLEN;
else
return ret;

if (skb->len < len) {
ret = skb_pad(skb, len - skb->len);
if (ret < 0)
return ret;
skb->len = len;
skb_set_tail_pointer(skb, len);
}
}

return ret;
}

The above function is used to pad the sk_buff for the required
length. By default, this function takes care of the minimum
payload size. But for some ethernet frames 64Bytes are
not the minimum padding. So we have made it as a




NEXT




<s> rtk_api_ret_t rtk_igmp_robustness_set(rtk_uint32 robustness)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(robustness > RTL8367C_MAX_ROB_VAR)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIGMPRobVar(robustness))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to update maximum IGMP Report interval, Report Query interval and Leave group interval for IGMP router robustness feature. See page 397 of data sheet for the description of those parameters.</s>




NEXT




<s> static inline int getsda(void)
{
return (gpio_get_value(sda_index));
}

The above function is used to check whether GPIO0 is active

Below is the output from the program
If GPIO0 is active, this will output GPIO0:active. If GPIO1 is active, this will output GPIO1:active

if (getsd




NEXT




<s> static int __init firebox_t10_probe(void)
{
if (of_machine_is_compatible("watchguard,firebox-t10"))
return 1;
return 0;
}

The above function is used to probe the Firebox T10 model to find out if the adapter supports it. The call to of_machine_is_compatible() will return a 1 if the adapter supports the T10 model.

The above code will check




NEXT




<s> static int rtl8390_serdes_probe(struct phy_device *phydev)
{
int addr = phydev->mdio.addr;

if (soc_info.family != RTL8390_FAMILY_ID)
return -ENODEV;

if (addr < 24)
return -ENODEV;

return rtl8390_configure_generic(phydev);
}

The above function is used to probe RTL8390 phy driver. The following is a piece of code in rtl83xx_mii.c file:
int phy_init_one(struct phy_device *phydev)





NEXT




<s> rtk_api_ret_t rtk_storm_bypass_get(rtk_storm_bypass_t type, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;
rtk_uint32 tmp;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= BYPASS_END)
return RT_ERR_INPUT;

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if (type >= 0 && type <= BYPASS_UNDEF_GARP_2F)
{
if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.discard_storm_filter;
}
else if(type == BYPASS_IGMP)
{
if ((retVal = rtl8367c_getAsicIGMPBypassStormCTRL(pEnable)) != RT_ERR_OK)
return retVal;
}
else if (type == BYPASS_CDP)
{
if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.discard_storm_filter;
}
else if (type == BYPASS_CSSTP)
{
if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.discard_storm_filter;
}
else if (type == BYPASS_LLDP)
{
if ((retVal = rtl8367c_getAsicRmaLldp(&tmp,&rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.discard_storm_filter;
}
else
return RT_ERR_INPUT;

return RT_ERR_OK;
}

The above function is used to get the storm_bypass configuration. rtk_igmp_bypass_get(), rtk_cdp_bypass_get(), rtk_csstp_bypass_get(), and rtk_lldp_




NEXT




<s> void rtl839x_mask_port_reg_le(u64 clear, u64 set, int reg)
{
sw_w32_mask((u32)clear, (u32)set, reg);
sw_w32_mask((u32)(clear >> 32), (u32)(set >> 32), reg + 4);
}

The above function is used to change the value of port register with a mask. The registers have 32-bit width, sw_w32 writes 32 bits in register, sw_w32_mask writes bits in register with a 32-




NEXT




<s> static int fe_phy_connect(struct fe_priv *priv)
{
int i;

for (i = 0; i < 8; i++) {
if (priv->phy->phy_node[i]) {
if (!priv->phy_dev) {
priv->phy_dev = priv->phy->phy[i];
priv->phy_flags = FE_PHY_FLAG_PORT;
}
} else if (priv->mii_bus) {
struct phy_device *phydev;

phydev = mdiobus_get_phy(priv->mii_bus, i);
if (!phydev || phydev->attached_dev)
continue;

phy_init(priv, phydev);
if (!priv->phy_dev) {
priv->phy_dev = mdiobus_get_phy(priv->mii_bus, i);
priv->phy_flags = FE_PHY_FLAG_ATTACH;
}
}
}

return 0;
}

The above function is used to setup PHY data struct before probing is done.

static int fe_phy_probe(struct fe_priv *priv)
{
if (priv->phy->phy_node[priv->lane_id]) {
if




NEXT




<s> static int rtl8366_get_pvid(struct rtl8366_smi *smi, int port, int *val)
{
struct rtl8366_vlan_mc vlanmc;
int err;
int index;

err = smi->ops->get_mc_index(smi, port, &index);
if (err)
return err;

err = smi->ops->get_vlan_mc(smi, index, &vlanmc);
if (err)
return err;

*val = vlanmc.vid;
return 0;
}

The above function is used to get the pvid in rtl8366.c. In the following, the pvid related functions will be illustrated as below:

#include</s>




NEXT




<s> static int mtk_bmt_init_nmbm(struct device_node *np)
{
struct nmbm_instance *ni;
int ret;

ni = kzalloc(nmbm_calc_structure_size(), GFP_KERNEL);
if (!ni)
return -ENOMEM;

bmtd.ni = ni;

if (of_property_read_u32(np, "mediatek,bmt-max-ratio", &ni->max_ratio))
ni->max_ratio = 1;
if (of_property_read_u32(np, "mediatek,bmt-max-reserved-blocks",
&ni->max_reserved_blocks))
ni->max_reserved_blocks = 256;
if (of_property_read_bool(np, "mediatek,empty-page-ecc-protected"))
ni->empty_page_ecc_ok = true;
if (of_property_read_bool(np, "mediatek,bmt-force-create"))
ni->force_create = true;

ret = nmbm_attach(ni);
if (ret)
goto out;

bmtd.mtd->size = ni->data_block_count << bmtd.blk_shift;

return 0;

out:
kfree(ni);
bmtd.ni = NULL;

return ret;
}

The above function is used to initialize the driver when NMBM driver gets a request to initialize itself, this happens when the user is trying to use BMT. Also, if BMT is used, kernel will always use the NMBM backend and the driver gets called with




NEXT




<s> fis_open(void)
{
struct fis_image_desc *desc;

if (fis_fd >= 0)
fis_close();

fis_fd = mtd_check_open("FIS directory");
if (fis_fd < 0)
goto error;

close(fis_fd);
fis_fd = mtd_open("FIS directory", true);
if (fis_fd < 0)
goto error;

fis_erasesize = erasesize;
desc = mmap(NULL, erasesize, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_LOCKED, fis_fd, 0);
if (desc == MAP_FAILED)
goto error;

fis_desc = desc;
return desc;

error:
fis_close();
return NULL;
}

The above function is used to open a "flash interchange system" (FIS) image. It looks up an existing description in the cache if it exists and then will attempt to open and map it.</s>




NEXT




<s> static int rtl83xx_get_sset_count(struct dsa_switch *ds, int port, int sset)
{
if (sset != ETH_SS_STATS)
return 0;

return ARRAY_SIZE(rtl83xx_mib);
}

The above function is used to count statistics set(sset), currently
ETH_SS_STATS is used which has 15 statistics counters, including
RX/TX packers, RX/TX Octets counters, unicast/multicast




NEXT




<s> static void set_randconfig_seed(void)
{
unsigned int seed;
char *env;
bool seed_set = false;

env = getenv("KCONFIG_SEED");
if (env && *env) {
char *endp;

seed = strtol(env, &endp, 0);
if (*endp == '\0')
seed_set = true;
}

if (!seed_set) {
struct timeval now;

/*
* Use microseconds derived seed, compensate for systems where it may
* be zero.
*/
gettimeofday(&now, NULL);
seed = (now.tv_sec + 1) * (now.tv_usec + 1);
}

printf("KCONFIG_SEED=0x%X\n", seed);
srand(seed);
}

The above function is used to set a seed for our pseudo random number generator, which is then used by the
random_seed() function to initialize the random number generator. The above function is called by the configure function
during the build process of every kernel and hence the




NEXT




<s> static void rtl838x_route_read(int idx, struct rtl83xx_route *rt)
{
/* Read ROUTING table (2) via register RTL8380_TBL_1 */
struct table_reg *r = rtl_table_get(RTL8380_TBL_1, 2);

pr_debug("In %s, id %d\n", __func__, idx);
rtl_table_read(r, idx);

/* The table has a size of 2 registers */
rt->nh.gw = sw_r32(rtl_table_data(r, 0));
rt->nh.gw <<= 32;
rt->nh.gw |= sw_r32(rtl_table_data(r, 1));

rtl_table_release(r);
}

The above function is used to read the 2nd register of 2-byte ROUTING table entry.
When this function is called after rtl838x_routing_entry_add, the ROUTING table is already updated.
However, if




NEXT




<s> hostapd_bss_del_client(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct blob_attr *tb[__DEL_CLIENT_MAX];
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
struct sta_info *sta;
bool deauth = false;
int reason;
u8 addr[ETH_ALEN];

blobmsg_parse(del_policy, __DEL_CLIENT_MAX, tb, blob_data(msg), blob_len(msg));

if (!tb[DEL_CLIENT_ADDR])
return UBUS_STATUS_INVALID_ARGUMENT;

if (hwaddr_aton(blobmsg_data(tb[DEL_CLIENT_ADDR]), addr))
return UBUS_STATUS_INVALID_ARGUMENT;

if (tb[DEL_CLIENT_REASON])
reason = blobmsg_get_u32(tb[DEL_CLIENT_REASON]);

if (tb[DEL_CLIENT_DEAUTH])
deauth = blobmsg_get_bool(tb[DEL_CLIENT_DEAUTH]);

sta = ap_get_sta(hapd, addr);
if (sta) {
if (deauth) {
hostapd_drv_sta_deauth(hapd, addr, reason);
ap_sta_deauthenticate(hapd, sta, reason);
} else {
hostapd_drv_sta_disassoc(hapd, addr, reason);
ap_sta_disassociate(hapd, sta, reason);
}
}

if (tb[DEL_CLIENT_BAN_TIME])
hostapd_bss_ban_client(hapd, addr, blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]));

return 0;
}

The above function is used to remove a certain client from hostapd’s list of clients. Notice that if `tb[DEL_CLIENT_DEAUTH]` is true, the caller of this function will be notified that the client is deauthed and will




NEXT




<s> static int mt7621_nfc_ooblayout_free(struct mtd_info *mtd, int section,
struct mtd_oob_region *oob_region)
{
struct nand_chip *nand = mtd_to_nand(mtd);

if (section >= nand->ecc.steps)
return -ERANGE;

oob_region->length = NFI_FDM_SIZE - 1;
oob_region->offset = section * NFI_FDM_SIZE + 1;

return 0;
}

The above function is used to provide the layout of the NAND flash oob data
at the time of free (erase) operation. Currently it is working only with
the NFI format. It is used to extract NFI format oob data layout to provide
to




NEXT




<s> static inline uint32_t read_uint32(void *buf, ptrdiff_t off)
{
uint32_t tmp = *(uint32_t *)(buf + off);
if (swap_bytes) {
tmp = be32toh(tmp);
}
return tmp;
}

The above function is used to read uint32 values from a buffer starting from a given offset. The `off` parameter is simply
the offset relative to the start of the buffer. The rest of the code in this function is pretty straightforward for most readers.
The code




NEXT




<s> static int aw9523_drive_reset_gpio(struct aw9523 *awi)
{
unsigned int chip_id;
int ret;

/*
* If the chip is already configured for any reason, then we
* will probably succeed in sending the soft reset signal to
* the hardware through I2C: this operation takes less time
* compared to a full HW reset and it gives the same results.
*/
ret = regmap_write(awi->regmap, AW9523_REG_SOFT_RESET, 0);
if (ret == 0)
goto done;

dev_dbg(awi->dev, "Cannot execute soft reset: trying hard reset\n");
ret = gpiod_direction_output(awi->reset_gpio, 0);
if (ret)
return ret;

/* The reset pulse has to be longer than 20uS due to deglitch */
usleep_range(AW9523_HW_RESET_US, AW9523_HW_RESET_US + 1);

ret = gpiod_direction_output(awi->reset_gpio, 1);
if (ret)
return ret;
done:
/* The HW needs at least 1uS to reliably recover after reset */
usleep_range(AW9523_HW_RESET_RECOVERY_US,
AW9523_HW_RESET_RECOVERY_US + 1);

/* Check the ChipID */
ret = regmap_read(awi->regmap, AW9523_REG_CHIPID, &chip_id);
if (ret) {
dev_err(awi->dev, "Cannot read Chip ID: %d\n", ret);
return ret;
}
if (chip_id != AW9523_VAL_EXPECTED_CHIPID) {
dev_err(awi->dev, "Bad ChipID; read 0x%x, expected 0x%x\n",
chip_id, AW9523_VAL_EXPECTED_CHIPID);
return -EINVAL;
}

return 0;
}

The above function is used to reset AW9523 chips using GPIO's, a delay between 110 uSecond to 1 ms is required to perform the chip reset. Using these information I designed a PCB (single-sided) to reset




NEXT




<s> uc_bpf_open_module(uc_vm_t *vm, size_t nargs)
{
DECLARE_LIBBPF_OPTS(bpf_object_open_opts, bpf_opts);
uc_value_t *path = uc_fn_arg(0);
uc_value_t *opts = uc_fn_arg(1);
struct bpf_object *obj;

if (ucv_type(path) != UC_STRING)
err_return(EINVAL, "module path");

init_env();
obj = bpf_object__open_file(ucv_string_get(path), &bpf_opts);
if (libbpf_get_error(obj))
err_return(errno, NULL);

if (uc_bpf_module_set_opts(obj, opts)) {
bpf_object__close(obj);
return NULL;
}

if (bpf_object__load(obj)) {
bpf_object__close(obj);
err_return(errno, NULL);
}

return uc_resource_new(module_type, obj);
}

The above function is used to load a module in userspace and then pass it to Libbpf to be loaded in the kernel.

## uc_bpf_attach_progs(uc_vm_t *vm, uc_value_t **




NEXT




<s> static inline int sata_oxnas_is_host_frozen(struct ata_host *ah)
{
struct sata_oxnas_host_priv *hd = ah->private_data;

smp_rmb();
return hd->port_in_eh || hd->port_frozen;
}

The above function is used to check if the SATA OXNA chip is currently in eh
and should not be asked to process requests.

However, since the code uses RMB, we are not sure which is the correct
memory barrier for the specific platforms




NEXT




<s> ar8327_led_schedule_change(struct ar8327_led *aled, u8 pattern)
{
if (aled->pattern == pattern)
return;

aled->pattern = pattern;
schedule_work(&aled->led_work);
}

The above function is used to change the pattern of LED and triggers a work. The function uses a statically allocated workqueue as in kernel_led_init. It is used to execute this kernel LED driver function.

static void ar8327_led




NEXT




<s> void refresh_all_windows(WINDOW *main_window)
{
update_panels();
touchwin(main_window);
refresh();
}

The above function is used to refresh all windows which is main_window + its child. What i want to know is if there is a way to refresh only some windows say window1 only. In the above definition of refresh_all_windows(WINDOW *main_window




NEXT




<s> static void set_rtc_time(struct rtc_time *rtc_tm)
{
rtc_tm->tm_sec  = to_bcd(rtc_tm->tm_sec);
rtc_tm->tm_min  = to_bcd(rtc_tm->tm_min);
rtc_tm->tm_hour = to_bcd(rtc_tm->tm_hour);
rtc_tm->tm_mday = to_bcd(rtc_tm->tm_mday);
rtc_tm->tm_mon  = to_bcd(rtc_tm->tm_mon + 1);
rtc_tm->tm_year = to_bcd(rtc_tm->tm_year);

if (rtc_tm->tm_year >= 0x100) {
rtc_tm->tm_year -= 0x100;
rtc_tm->tm_mon |= RTC_Y2K_MASK;
}

spin_lock_irq(&rtc_lock);
i2c_start();
i2c_outb(RTC_I2C_ADDRESS | I2C_WRITE_MASK);
i2c_outb(0x00);	/* set starting register to 0 (=seconds) */
i2c_outb(rtc_tm->tm_sec);
i2c_outb(rtc_tm->tm_min);
i2c_outb(rtc_tm->tm_hour);
i2c_outb(rtc_tm->tm_wday);
i2c_outb(rtc_tm->tm_mday);
i2c_outb(rtc_tm->tm_mon);
i2c_outb(rtc_tm->tm_year);
i2c_stop();
spin_unlock_irq(&rtc_lock);
}

The above function is used to write current time to the PCM1805 BCD-RTC. It takes the time in the rtc_time format and converts it to the format RTC_I2C_ADDRESS | I2C_WRITE_




NEXT




<s> static int adm6996_config_init(struct phy_device *pdev)
{
struct adm6996_priv *priv;
int ret;

linkmode_zero(pdev->supported);
linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, pdev->supported);
linkmode_copy(pdev->advertising, pdev->supported);

if (pdev->mdio.addr != 0) {
pr_info ("%s: PHY overlaps ADM6996, providing fixed PHY 0x%x.\n"
, pdev->attached_dev->name, pdev->mdio.addr);
return 0;
}

priv = devm_kzalloc(&pdev->mdio.dev, sizeof(struct adm6996_priv), GFP_KERNEL);
if (!priv)
return -ENOMEM;

mutex_init(&priv->reg_mutex);
mutex_init(&priv->mib_lock);
priv->priv = pdev;
priv->read = adm6996_read_mii_reg;
priv->write = adm6996_write_mii_reg;

ret = adm6996_switch_init(priv, pdev->attached_dev->name, pdev->attached_dev);
if (ret < 0)
return ret;

pdev->priv = priv;

return 0;
}

The above function is used to initialize ADM6996 configuration before link down.

The first three lines is to set the PHY supported mode as 100M.

The fourth function is to check whether the PHY address is overlapped with




NEXT




<s> ret_t rtl8367c_getAsicTrunkingFlood(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_FLOOD_OFFSET, pEnabled);
}

The above function is used to control 8367 flood setting.
The parameter is set as an integer, 0 for disable, 1 for enable.
When it is used as an input parameter, it will read the register setting and return the result to user




NEXT




<s> ret_t rtl8367c_setAsicLeakyBucketParameter(rtk_uint32 tick, rtk_uint32 token)
{
ret_t retVal;

if(tick > 0xFF)
return RT_ERR_TICK;

if(token > 0xFF)
return RT_ERR_TOKEN;

retVal = rtl8367c_setAsicRegBits(RTL8367C_LEAKY_BUCKET_TICK_REG, RTL8367C_LEAKY_BUCKET_TICK_MASK, tick);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_LEAKY_BUCKET_TOKEN_REG, RTL8367C_LEAKY_BUCKET_TOKEN_MASK, token);

return retVal;
}

The above function is used to set the leaky bucket tick and token.
There are two registers in RTL8367 series, RTL8367C_LEAKY_BUCKET_TICK_REG and RTL8367C




NEXT




<s> adm6996_get_port_stats(struct switch_dev *dev, int port,
struct switch_port_stats *stats)
{
struct adm6996_priv *priv = to_adm(dev);
int id;
u32 reg = 0;

if (port >= ADM_NUM_PORTS)
return -EINVAL;

mutex_lock(&priv->mib_lock);

id = ADM6996_MIB_TXB_ID;
reg = r16(priv, adm6996_mibs[id].offset + ADM_OFFSET_PORT(port));
reg += r16(priv, adm6996_mibs[id].offset + ADM_OFFSET_PORT(port) + 1) << 16;
stats->tx_bytes = reg;

id = ADM6996_MIB_RXB_ID;
reg = r16(priv, adm6996_mibs[id].offset + ADM_OFFSET_PORT(port));
reg += r16(priv, adm6996_mibs[id].offset + ADM_OFFSET_PORT(port) + 1) << 16;
stats->rx_bytes = reg;

mutex_unlock(&priv->mib_lock);

return 0;
}

The above function is used to read the value of two consecutive bytes read from 0x8140. From the implementation, we can see it reads 0x8140+0x4 (=0x8144) as well.





NEXT




<s> handle_send_auth(struct ead_packet *pkt, int len, int *nstate)
{
struct ead_msg *msg = &pkt->msg;
struct ead_msg_auth *auth = EAD_DATA(msg, auth);

if (t_serververify(ts, auth->data) != 0) {
DEBUG(2, "Client authentication failed\n");
*nstate = EAD_TYPE_SET_USERNAME;
return false;
}

msg = &pktbuf->msg;
auth = EAD_DATA(msg, auth);
msg->len = htonl(sizeof(struct ead_msg_auth));

DEBUG(2, "Client authentication successful\n");
memcpy(auth->data, t_serverresponse(ts), sizeof(auth->data));

*nstate = EAD_TYPE_SEND_CMD;
return true;
}

The above function is used to handle authentication request from the client and returns true if the client authentication is successful else it will return false.

In our case, the client authentication failed means the data provided by the client is wrong. So we set the state for requesting the




NEXT




<s> static int rtl83xx_get_mac_eee(struct dsa_switch *ds, int port,
struct ethtool_eee *e)
{
struct rtl838x_switch_priv *priv = ds->priv;

e->supported = SUPPORTED_100baseT_Full | SUPPORTED_1000baseT_Full;

priv->r->eee_port_ability(priv, e, port);

e->eee_enabled = priv->ports[port].eee_enabled;

e->eee_active = !!(e->advertised & e->lp_advertised);

return 0;
}

The above function is used to query EEE capability via ethtool interface. It only supports legacy EEE capability.
Now letâ€™s create the following file in the drivers/net/ethernet/rtl83xx/rtl83xx_




NEXT




<s> static int b53_mdio_op(struct b53_device *dev, u8 page, u8 reg, u16 op)
{
int i;
u16 v;
int ret;
struct mii_bus *bus = dev->priv;

if (dev->current_page != page) {
/* set page number */
v = (page << 8) | REG_MII_PAGE_ENABLE;
ret = mdiobus_write(bus, B53_PSEUDO_PHY, REG_MII_PAGE, v);
if (ret)
return ret;
dev->current_page = page;
}

/* set register address */
v = (reg << 8) | op;
ret = mdiobus_write(bus, B53_PSEUDO_PHY, REG_MII_ADDR, v);
if (ret)
return ret;

/* check if operation completed */
for (i = 0; i < 5; ++i) {
v = mdiobus_read(bus, B53_PSEUDO_PHY, REG_MII_ADDR);
if (!(v & (REG_MII_ADDR_WRITE | REG_MII_ADDR_READ)))
break;
usleep_range(10, 100);
}

if (WARN_ON(i == 5))
return -EIO;

return 0;
}

The above function is used to read and write register through MDIO interface.

In order to access BMAC registers through MDIO, we need configure the bcm device with below config.
CONFIG88 = 0x4008;
CONFIG89




NEXT




<s> int strlen(const char *str)
{
int len = 0;

if(str == (char *)0)
return 0;

while(*str++ != 0)
len++;

return len;
}

The above function is used to find the length of a string(char array)
and I'm using a loop to find this. My question is...is there a direct function available in C which will help me do this task??</s>




NEXT




<s> static void print_ciphers(const OBJ_NAME *name,void *arg) {
fprintf(arg, "\t%s\n", name->name);
}

The above function is used to print all the key exchange ciphers. The output from this function looks something similar to the below:

$ openssl ciphers | grep 'ECDH'</s>




NEXT




<s> static void print_mac(struct data_header **data_table, int cnt)
{

for (int i = 0; i < cnt; i++) {
if (data_table[i]->type == DATA_HEADER_CONFIG
&& data_table[i]->id == DATA_HEADER_ID_MAC) {
int j;
for (j = 0; j < 5; j++)
printf("%02x:", data_table[i]->data[j]);
printf("%02x\n", data_table[i]->data[j]);
}

}

}

The above function is used to print the MAC addresses that are stored in a data table in a binary file. The data table is passed to the function as a pointer. The cnt argument indicates the number of elements in the data table.

// A sample usage of the print




NEXT




<s> mtd_fixseama(const char *mtd, size_t offset, size_t data_size)
{
int fd;
char *first_block;
ssize_t res;
size_t block_offset;
size_t data_offset;
struct seama_entity_header *shdr;

if (quiet < 2)
fprintf(stderr, "Trying to fix SEAMA header in %s at 0x%x...\n",
mtd, offset);

block_offset = offset & ~(erasesize - 1);
offset -= block_offset;

fd = mtd_check_open(mtd);
if(fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd);
exit(1);
}

if (block_offset + erasesize > mtdsize) {
fprintf(stderr, "Offset too large, device size 0x%x\n",
mtdsize);
exit(1);
}

first_block = malloc(erasesize);
if (!first_block) {
perror("malloc");
exit(1);
}

res = pread(fd, first_block, erasesize, block_offset);
if (res != erasesize) {
perror("pread");
exit(1);
}

shdr = (struct seama_entity_header *)(first_block + offset);
if (shdr->magic != htonl(SEAMA_MAGIC)) {
fprintf(stderr, "No SEAMA header found\n");
exit(1);
} else if (!ntohl(shdr->size)) {
fprintf(stderr, "Seama entity with empty image\n");
exit(1);
}

data_offset = offset + sizeof(struct seama_entity_header) + ntohs(shdr->metasize);
if (!data_size)
data_size = mtdsize - data_offset;
if (data_size > ntohl(shdr->size))
data_size = ntohl(shdr->size);
if (seama_fix_md5(shdr, fd, data_offset, data_size))
goto out;

if (mtd_erase_block(fd, block_offset)) {
fprintf(stderr, "Can't erease block at 0x%x (%s)\n",
block_offset, strerror(errno));
exit(1);
}

if (quiet < 2)
fprintf(stderr, "Rewriting block at 0x%x\n", block_offset);

if (pwrite(fd, first_block, erasesize, block_offset) != erasesize) {
fprintf(stderr, "Error writing block (%s)\n", strerror(errno));
exit(1);
}

if (quiet < 2)
fprintf(stderr, "Done.\n");

out:
close (fd);
sync();

return 0;
}

The above function is used to fix a file with a damaged SEAMA header. It erases and writes back the corresponding block.</s>




NEXT




<s> rtk_api_ret_t rtk_l2_ipVidMcastAddr_get(rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pIpVidMcastAddr)
return RT_ERR_NULL_POINTER;

if (pIpVidMcastAddr->vid > RTL8367C_VIDMAX)
return RT_ERR_L2_VID;

if( (pIpVidMcastAddr->dip & 0xF0000000) != 0xE0000000)
return RT_ERR_INPUT;

memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
l2Table.sip = pIpVidMcastAddr->sip;
l2Table.dip = pIpVidMcastAddr->dip;
l2Table.l3lookup = 1;
l2Table.l3vidlookup = 1;
l2Table.l3_vid = pIpVidMcastAddr->vid;
method = LUTREADMETHOD_MAC;
if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
return retVal;

pIpVidMcastAddr->address = l2Table.address;

/* Get Logical port mask */
if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pIpVidMcastAddr->portmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the configuration of Ip Vid Multicast Address Table.

rtk_api_ret_t rtk_l2_ipVidMcastAddr_set(rtk_l2_ipVidMcast




NEXT




<s> rtk_api_ret_t rtk_port_isolation_get(rtk_port_t port, rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortIsolationPermittedPortmask(rtk_switch_port_L2P_get(port), &pmask)) != RT_ERR_OK)
return retVal;

if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the isolation configuration at the input port.
The following figure shows how to call this function.

If the isolation is enabled at port 1, port 2 and port 3;
it is not enabled at port 5 and




NEXT




<s> static void prop_warn(struct property *prop, const char *fmt, ...)
{
va_list ap;
va_start(ap, fmt);
fprintf(stderr, "%s:%d:warning: ", prop->file->name, prop->lineno);
vfprintf(stderr, fmt, ap);
fprintf(stderr, "\n");
va_end(ap);
}

The above function is used to warn users when setting certain property values
for which it's not possible to represent the actual value set by the user in the
xml output. This happens for example for the "file.sha1"

property which takes the checksum




NEXT




<s> static int en7523_pci_prepare(struct clk_hw *hw)
{
struct en_clk_gate *cg = container_of(hw, struct en_clk_gate, hw);
void __iomem *np_base = cg->base;
u32 val, mask;

/* Need to pull device low before reset */
val = readl(np_base + REG_PCI_CONTROL);
val &= ~(REG_PCI_CONTROL_PERSTOUT1 | REG_PCI_CONTROL_PERSTOUT);
writel(val, np_base + REG_PCI_CONTROL);
usleep_range(1000, 2000);

/* Enable PCIe port 1 */
val |= REG_PCI_CONTROL_REFCLK_EN1;
writel(val, np_base + REG_PCI_CONTROL);
usleep_range(1000, 2000);

/* Reset to default */
val = readl(np_base + REG_RESET_CONTROL);
mask = REG_RESET_CONTROL_PCIE1 | REG_RESET_CONTROL_PCIE2 |
REG_RESET_CONTROL_PCIEHB;
writel(val & ~mask, np_base + REG_RESET_CONTROL);
usleep_range(1000, 2000);
writel(val | mask, np_base + REG_RESET_CONTROL);
msleep(100);
writel(val & ~mask, np_base + REG_RESET_CONTROL);
usleep_range(5000, 10000);

/* Release device */
mask = REG_PCI_CONTROL_PERSTOUT1 | REG_PCI_CONTROL_PERSTOUT;
val = readl(np_base + REG_PCI_CONTROL);
writel(val & ~mask, np_base + REG_PCI_CONTROL);
usleep_range(1000, 2000);
writel(val | mask, np_base + REG_PCI_CONTROL);
msleep(250);

return 0;
}

The above function is used to prepare the PCIe controller before PCIe
link speed (and thus, clock) is set, and its purpose is to pull the PCIe
device low so that it will come back up again after the PCIe link speed is set.





NEXT




<s> static void vr9_stop(int pp32)
{
unsigned int mask = 1 << (pp32 << 4);

IFX_REG_W32_MASK(0, mask, PP32_FREEZE);
}

The above function is used to freeze the current programmable pipe 32.

However, the code shown in the sample isn't compiling right now, as the
"mask" variable is not defined. Also, the "PP32" macro is




NEXT




<s> static int ubootenv_remove(struct platform_device *pdev)
{
struct ubootenv_drvdata *data = platform_get_drvdata(pdev);

data->env = NULL;
misc_deregister(&data->misc);
return 0;
}

The above function is used to remove the uboot env variables from eMMC.It is always executed only at boot time for the first time.</s>




NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_field_sel_get(rtk_uint32 index, rtk_field_sel_t *pFormat, rtk_uint32 *pOffset)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pFormat || NULL == pOffset)
return RT_ERR_NULL_POINTER;

if(index >= RTL8367C_FIELDSEL_FORMAT_NUMBER)
return RT_ERR_OUT_OF_RANGE;

if((ret = rtl8367c_getAsicFieldSelector(index, pFormat, pOffset)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to retrieve the format selected by the IG filter. The function is written in C, but the format selection is actually performed in ASIC by software. Therefore, the rtl8367c_getAsicFieldSelector function in the AS




NEXT




<s> static void ath79_set_pll(struct ag71xx *ag)
{
u32 pll_cfg = ag->pllreg[0];
u32 pll_shift = ag->pllreg[2];

if (!ag->pllregmap)
return;

regmap_update_bits(ag->pllregmap, pll_cfg, 3 << pll_shift, 2 << pll_shift);
udelay(100);

ath79_set_pllval(ag);

regmap_update_bits(ag->pllregmap, pll_cfg, 3 << pll_shift, 3 << pll_shift);
udelay(100);

regmap_update_bits(ag->pllregmap, pll_cfg, 3 << pll_shift, 0);
udelay(100);
}

The above function is used to set the PLL in the AG71xx/AG7190. Since
its a register based configuration, the operation was done on the
register values. The PLL is set using the register map available in
the ag7




NEXT




<s> swconfig_get_dev(struct genl_info *info)
{
struct switch_dev *dev = NULL;
struct switch_dev *p;
int id;

if (!info->attrs[SWITCH_ATTR_ID])
goto done;

id = nla_get_u32(info->attrs[SWITCH_ATTR_ID]);
swconfig_lock();
list_for_each_entry(p, &swdevs, dev_list) {
if (id != p->id)
continue;

dev = p;
break;
}
if (dev)
mutex_lock(&dev->sw_mutex);
else
pr_debug("device %d not found\n", id);
swconfig_unlock();
done:
return dev;
}

The above function is used to extract a device from the netdevice list. The device is determined by an ID which the swconfig module has set previously.

This function is actually a part of swconfig and does not perform any configuration of the switch device, but it is




NEXT




<s> static bool wpas_ubus_init(void)
{
if (ctx)
return true;

eloop_add_uloop();
ctx = ubus_connect(NULL);
if (!ctx)
return false;

ctx->connection_lost = wpas_ubus_connection_lost;
ubus_add_uloop(ctx);

return true;
}

The above function is used to connect to ubus and is called by a timer.

If you check it, you'll see that the only error that will
occur in this function will be the context being set. If the context
is set, we know




NEXT




<s> static int add_dir(const char *name, int parent)
{
struct jffs2_raw_inode ri;
int inode;

inode = add_dirent(name, IFTODT(S_IFDIR), parent);

if (rbytes() < sizeof(ri))
pad(erasesize);
prep_eraseblock();

memset(&ri, 0, sizeof(ri));
ri.magic = JFFS2_MAGIC_BITMASK;
ri.nodetype = JFFS2_NODETYPE_INODE;
ri.totlen = sizeof(ri);
ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node) - 4);

ri.ino = inode;
ri.mode = S_IFDIR | 0755;
ri.uid = ri.gid = 0;
ri.atime = ri.ctime = ri.mtime = 0;
ri.isize = ri.csize = ri.dsize = 0;
ri.version = 1;
ri.node_crc = crc32(0, &ri, sizeof(ri) - 8);
ri.data_crc = 0;

add_data((char *) &ri, sizeof(ri));
pad(4);
return inode;
}

The above function is used to add a dirent entry to the directory. The problem
is the line ri.mode = S_IFDIR | 0755;
In fact, we're treating this in JFFS2_FILE_UNIX mode




NEXT




<s> static void dma_ctrl_rst(struct dc_ep_dev *dev)
{
ep_wr32_mask(ACA_PMU_DMA | ACA_PMU_EMA, 0, ACA_PMU_CTRL);

udelay(10);
ep_wr32_mask(0, 1, DMA_CTRL);
udelay(10);
ep_wr32(0, DMA_CLC);
}

The above function is used to reset the DMA. The call order of this function is like this.

DMA_ctrl_rst() is called in ACA_init(). ACA_init() is called in dc_ep_hw_init(). dc_ep




NEXT




<s> static void pilot_tones_status(int fd) {
#ifndef INCLUDE_DSL_CPE_API_DANUBE
IOCTL(DSL_PilotTonesStatus_t, DSL_FIO_PILOT_TONES_STATUS_GET);

m_array_u16("pilot_tones", out.data.nPilotTone, out.data.nNumData);
#endif
}

The above function is used to query the Pilot tone status.
The result is returned in the structure out.data. After successful initialization, the value of out.data.nPilotTone is set to the number of pilot tones which have been discovered in




NEXT




<s> struct symbol *sym_find(const char *name)
{
struct symbol *symbol = NULL;
int hash = 0;

if (!name)
return NULL;

if (name[0] && !name[1]) {
switch (name[0]) {
case 'y': return &symbol_yes;
case 'm': return &symbol_mod;
case 'n': return &symbol_no;
}
}
hash = strhash(name) % SYMBOL_HASHSIZE;

for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
if (symbol->name &&
!strcmp(symbol->name, name) &&
!(symbol->flags & SYMBOL_CONST))
break;
}

return symbol;
}

The above function is used to search the symbol table which has been defined in symbol.c, and if it found something then it will be returned to us.

What I wanna do is to search the symbol table, and if I found something then it will be stored in




NEXT




<s> hostapd_bss_list_bans(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
struct ubus_banned_client *ban;
void *c;

blob_buf_init(&b, 0);
c = blobmsg_open_array(&b, "clients");
avl_for_each_element(&hapd->ubus.banned, ban, avl)
blobmsg_add_macaddr(&b, NULL, ban->addr);
blobmsg_close_array(&b, c);
ubus_send_reply(ctx, req, b.head);

return 0;
}

The above function is used to display the banned clients data in banned.json file.</s>




NEXT




<s> static inline int fe_max_buf_size(int frag_size)
{
int buf_size = frag_size - NET_SKB_PAD - NET_IP_ALIGN -
SKB_DATA_ALIGN(sizeof(struct skb_shared_info));

BUG_ON(buf_size < MAX_RX_LENGTH);
return buf_size;
}

The above function is used to calculate the buffer size the fe driver
is allowed to use. There is a problem here because if we give a big
buffer size, we run into a bug in skb_copy_datagram_iovec() since it
will assume we




NEXT




<s> int nvram_set(nvram_handle_t *h, const char *name, const char *value)
{
uint32_t i;
nvram_tuple_t *t, *u, **prev;

/* Hash the name */
i = hash(name) % NVRAM_ARRAYSIZE(h->nvram_hash);

/* Find the associated tuple in the hash table */
for (prev = &h->nvram_hash[i], t = *prev;
t && strcmp(t->name, name); prev = &t->next, t = *prev);

/* (Re)allocate tuple */
if (!(u = _nvram_realloc(h, t, name, value)))
return -12; /* -ENOMEM */

/* Value reallocated */
if (t && t == u)
return 0;

/* Move old tuple to the dead table */
if (t) {
*prev = t->next;
t->next = h->nvram_dead;
h->nvram_dead = t;
}

/* Add new tuple to the hash table */
u->next = h->nvram_hash[i];
h->nvram_hash[i] = u;

return 0;
}

The above function is used to set a custom variable. It basically calls the function below which actually sets the variable

int _nvram_set(nvram_handle_t *h, const char *name, const char *value)
{
uint32




NEXT




<s> rtk_api_ret_t rtk_l2_limitSystemLearningCntAction_set(rtk_l2_limitLearnCntAction_t action)
{
rtk_api_ret_t retVal;
rtk_uint32 data;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ( LIMIT_LEARN_CNT_ACTION_DROP == action )
data = 1;
else if ( LIMIT_LEARN_CNT_ACTION_FORWARD == action )
data = 0;
else if ( LIMIT_LEARN_CNT_ACTION_TO_CPU == action )
data = 2;
else
return RT_ERR_NOT_ALLOWED;

if ((retVal = rtl8367c_setAsicSystemLutLearnOverAct(data)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set Limit System Learning count Action to DROP, FORWARD or to CPU.

rtk_l2_limitSystemLearningCntAction_get

rtk_api_ret_t rtk_l




NEXT




<s> static void fe_reset_phy(struct fe_priv *priv)
{
int err, msec = 30;
struct gpio_desc *phy_reset;

phy_reset = devm_gpiod_get_optional(priv->dev, "phy-reset",
GPIOD_OUT_HIGH);
if (!phy_reset)
return;

if (IS_ERR(phy_reset)) {
dev_err(priv->dev, "Error acquiring reset gpio pins: %ld\n",
PTR_ERR(phy_reset));
return;
}

err = of_property_read_u32(priv->dev->of_node, "phy-reset-duration",
&msec);
if (!err && msec > 1000)
msec = 30;

if (msec > 20)
msleep(msec);
else
usleep_range(msec * 1000, msec * 1000 + 1000);

gpiod_set_value(phy_reset, 0);
}

The above function is used to initialize the PHY reset GPIO pin when we
are using a PHY. This PHY reset will take effect if the PLL is enabled.
When PHY is present, the PLL_READY signal will not be asserted if




NEXT




<s> ret_t rtl8367c_setAsicPortEnableAll(rtk_uint32 enable)
{
if(enable >= 2)
return RT_ERR_INPUT;

return rtl8367c_setAsicRegBit(RTL8367C_REG_PHY_AD, RTL8367C_PDNPHY_OFFSET, !enable);
}

The above function is used to enable or disable all of PHY ports. And it is a basic example of controlling PHY. For controlling PHY with RTL8367C, rtl8367c_setAsicRegBit is used mostly.




NEXT




<s> int __init b53_phy_driver_register(void)
{
int ret;

ret = phy_driver_register(&b53_phy_driver_id1, THIS_MODULE);
if (ret)
return ret;

ret = phy_driver_register(&b53_phy_driver_id2, THIS_MODULE);
if (ret)
goto err1;

ret = phy_driver_register(&b53_phy_driver_id3, THIS_MODULE);
if (!ret)
return 0;

phy_driver_unregister(&b53_phy_driver_id2);
err1:
phy_driver_unregister(&b53_phy_driver_id1);
return ret;
}

The above function is used to register the Phy driver. The b53_phy_driver_id1 function is the Phy driver for the ethernet interface driver b53. The b53_phy_driver_id2 function is the Phy




NEXT




<s> wpa_udebug_config(struct udebug_ubus *ctx, struct blob_attr *data,
bool enabled)
{
udebug_ubus_apply_config(&ud, udebug_rings, ARRAY_SIZE(udebug_rings),
data, enabled);

if (udebug_buf_valid(&ud_log)) {
wpa_printf_hook = udebug_printf_hook;
wpa_hexdump_hook = udebug_hexdump_hook;
} else {
wpa_printf_hook = NULL;
wpa_hexdump_hook = NULL;
}

if (udebug_buf_valid(&ud_nl[0]) ||
udebug_buf_valid(&ud_nl[1]) ||
udebug_buf_valid(&ud_nl[2]))
wpa_netlink_hook = udebug_netlink_hook;
else
wpa_netlink_hook = NULL;
}

The above function is used to initialize udebug before entering WPA
init(), and the initialization is done through blob_parse() which will
parse the blob and will invoke a custom plugin for parsing through
parse_blowfish_cred() as defined by “ude




NEXT




<s> static void rtl839x_eth_set_multicast_list(struct net_device *ndev)
{
/* Flood all classes of RMA addresses (01-80-C2-00-00-{01..2F})
* CTRL_0_FULL = GENMASK(31, 2) = 0xFFFFFFFC
* Lower two bits are reserved, corresponding to RMA 01-80-C2-00-00-00
* CTRL_1_FULL = CTRL_2_FULL = GENMASK(31, 0)
*/
if (!(ndev->flags & (IFF_PROMISC | IFF_ALLMULTI))) {
sw_w32(0x0, RTL839X_RMA_CTRL_0);
sw_w32(0x0, RTL839X_RMA_CTRL_1);
sw_w32(0x0, RTL839X_RMA_CTRL_2);
sw_w32(0x0, RTL839X_RMA_CTRL_3);
}
if (ndev->flags & IFF_ALLMULTI) {
sw_w32(GENMASK(31, 2), RTL839X_RMA_CTRL_0);
sw_w32(GENMASK(31, 0), RTL839X_RMA_CTRL_1);
sw_w32(GENMASK(31, 0), RTL839X_RMA_CTRL_2);
}
if (ndev->flags & IFF_PROMISC) {
sw_w32(GENMASK(31, 2), RTL839X_RMA_CTRL_0);
sw_w32(GENMASK(31, 0), RTL839X_RMA_CTRL_1);
sw_w32(GENMASK(31, 0), RTL839X_RMA_CTRL_2);
sw_w32(0x3ff, RTL839X_RMA_CTRL_3);
}
}

The above function is used to set MAC filters on the RTL839x chip. In this case we apply the MAC filters based on the flags in the
device structure which is passed to the function. Depending on the flags that are set we will either clear all




NEXT




<s> ret_t rtl8367c_setAsicEgressFlowControlQueueDropThreshold(rtk_uint32 qid, rtk_uint32 threshold)
{
if( threshold >= RTL8367C_PAGE_NUMBER)
return RT_ERR_OUT_OF_RANGE;

if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;

return rtl8367c_setAsicRegBits(RTL8367C_FLOWCTRL_QUEUE_DROP_ON_REG(qid), RTL8367C_FLOWCTRL_QUEUE_DROP_ON_MASK, threshold);
}

The above function is used to set egress flow control threshold of Qid. The value is 1.

ret_t rtl8367c_getAsicEgressFlowControlQueueDropThreshold(rtk_uint32 qid, r




NEXT




<s> ret_t rtl8367c_setAsicPortRTCTDisable(rtk_uint32 portmask)
{
ret_t       retVal;
rtk_uint32  regData;
rtk_uint32  port;

if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
return retVal;

if( (regData == 0x0276) || (regData == 0x0597) )
return RT_ERR_CHIP_NOT_SUPPORTED;

for(port = 0; port <= 10 ; port++)
{
if(portmask & (0x0001 << port))
{
if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa422, &regData)) != RT_ERR_OK)
return retVal;

regData &= 0x7FFF;
if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
return retVal;

regData |= 0x00F0;
if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
return retVal;

regData &= ~0x0001;
if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
return retVal;
}
}

return RT_ERR_OK;
}

The above function is used to disable RTCT on RT8367 chipset.

A sample application for using RTCT is listed below:

typedef union
{
unsigned char cArr[24];
struct
{
rtk_




NEXT




<s> ead_hash_message(struct ead_msg_encrypted *enc, uint32_t *hash, int len)
{
unsigned char *data = (unsigned char *) enc;

/* hash the packet with the stored hash part initialized to zero */
sha_init(hash);
memset(enc->hash, 0, sizeof(enc->hash));
while (len > 0) {
sha_transform(hash, data, W);
len -= 64;
data += 64;
}
}

The above function is used to create a hash of the body of a packet and
store it in the EAD header of the packet. The packet (enc) is already
encrypted with AES and contains all the required encryption keys in the
EAD header in the




NEXT




<s> ead_check_rx_iv(uint32_t iv)
{
if (iv <= ead_rx_iv)
return false;

if (iv > ead_rx_iv + EAD_MAX_IV_INCR)
return false;

ead_rx_iv = iv;
return true;
}

The above function is used to validate if the specified IV can be assigned to an incoming frame. Let us assume that this function worked as intended and returned true (we would not see this anyway since the data is invalid). The above frame is then decrypted and the frame is aut




NEXT




<s> ret_t rtl8367c_setAsic1xGVOpdir(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_GVOPDIR_OFFSET, enabled);
}

The above function is used to set Asic Dot1x enable/disable, if the above function returns SUCCESS, it means Asic Dot1x is enabled.

rtk_uint32 phy_read_mii_reg(rtk




NEXT




<s> static unsigned int sata_oxnas_qc_issue(struct ata_queued_cmd *qc)
{
struct sata_oxnas_port_priv *pd = qc->ap->private_data;
struct sata_oxnas_host_priv *hd = qc->ap->host->private_data;

void __iomem *port_base = pd->port_base;
void __iomem *core_base = pd->core_base;
int port_no = qc->ap->port_no;
int no_microcode = (hd->current_ucode == UNKNOWN_MODE);
u32 reg;

/* check the core is idle */
if (ioread32(port_base + SATA_COMMAND) & CMD_CORE_BUSY) {
int count = 0;

DPRINTK("core busy for a command on port %d\n",
qc->ap->port_no);
do {
mdelay(1);
if (++count > 100) {
DPRINTK("core busy for a command on port %d\n",
qc->ap->port_no);
/* CrazyDumpDebug(); */
sata_oxnas_cleanup(qc->ap->host);
}
} while (ioread32(port_base + SATA_COMMAND) & CMD_CORE_BUSY);
}

/* enable passing of error signals to DMA sub-core by clearing the
* appropriate bit */
reg = ioread32(core_base + DATA_PLANE_CTRL);
if (no_microcode)
reg |= (DPC_ERROR_MASK_BIT | (DPC_ERROR_MASK_BIT << 1));
reg &= ~(DPC_ERROR_MASK_BIT << port_no);
iowrite32(reg, core_base + DATA_PLANE_CTRL);

/* Disable all interrupts for ports and RAID controller */
iowrite32(~0, port_base + INT_DISABLE);

/* Disable all interrupts for core */
iowrite32(~0, core_base + CORE_INT_DISABLE);
wmb();

/* Load the command settings into the orb registers */
sata_oxnas_tf_load(qc->ap, &qc->tf);

/* both pio and dma commands use dma */
if (ata_is_dma(qc->tf.protocol) || ata_is_pio(qc->tf.protocol)) {
/* Start the DMA */
iowrite32(SGDMA_CONTROL_GO,	pd->sgdma_base + SGDMA_CONTROL);
wmb();
}

/* enable End of command interrupt */
iowrite32(INT_WANT, port_base + INT_ENABLE);
iowrite32(COREINT_END, core_base + CORE_INT_ENABLE);
wmb();

/* Start the command */
reg = ioread32(port_base + SATA_COMMAND);
reg &= ~SATA_OPCODE_MASK;
reg |= CMD_WRITE_TO_ORB_REGS;
iowrite32(reg , port_base + SATA_COMMAND);
wmb();

return 0;
}

The above function is used to submit qc-commands to the QMan hardware
and to start the execution of the command. The idea of the function is
that the execution of the command is handled on per port by the
hardware and there is no need for a




NEXT




<s> static void rtl930x_write_cam(int idx, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL9300_TBL_L2, 1); /* Access L2 Table 1 */

rtl930x_fill_l2_row(r, e);

for (int i = 0; i < 3; i++)
sw_w32(r[i], rtl_table_data(q, i));

rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to write the MAC address and the VLAN entry into the table.</s>




NEXT




<s> int rtk_hal_set_egress_rate(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;

if (data->on_off == 1)
ret =
rtk_rate_egrBandwidthCtrlRate_set(data->port, data->bw, 1);
else
ret = rtk_rate_egrBandwidthCtrlRate_set(data->port, 1048568, 1);

return ret;
}

The above function is used to set the Egress rate on the port. The default rate is 10 Mb/s. When we set the bandwidth width 300, the rate is automatically changed to 1 Gb/s. And according to the




NEXT




<s> static void rtl838x_eth_tx_timeout(struct net_device *ndev, unsigned int txqueue)
{
unsigned long flags;
struct rtl838x_eth_priv *priv = netdev_priv(ndev);

pr_warn("%s\n", __func__);
spin_lock_irqsave(&priv->lock, flags);
rtl838x_hw_stop(priv);
rtl838x_hw_ring_setup(priv);
rtl838x_hw_en_rxtx(priv);
netif_trans_update(ndev);
netif_start_queue(ndev);
spin_unlock_irqrestore(&priv->lock, flags);
}

The above function is used to set TX timeout function on the RTL838x card.
As long as card is stopped, we set the function by:

priv->tx_timeout = rtl838x_eth_tx_timeout;





NEXT




<s> static void b53_switch_reset_gpio(struct b53_device *dev)
{
int gpio = dev->reset_gpio;

if (gpio < 0)
return;

/*
* Reset sequence: RESET low(50ms)->high(20ms)
*/
gpio_set_value(gpio, 0);
mdelay(50);

gpio_set_value(gpio, 1);
mdelay(20);

dev->current_page = 0xff;
}

The above function is used to send the RESET gpio pin to low and then high
with a 50ms delay and 20ms delay respectively. This helps in switching the
GPIO pin from low to high and also in sending pulses to the RESET




NEXT




<s> ead_pktloop(void)
{
while (1) {
if (pcap_dispatch(pcap_fp_rx, 1, handle_packet, NULL) < 0) {
ead_pcap_reopen(false);
continue;
}
}
}

The above function is used to process received packets. handle_packet() is a callback that gets invoked for every incoming PCAP packet and the first parameter that is passed to it is the packet itself.

We don’t have to worry about the handling when a packet actually




NEXT




<s> static int rtl8231_pin_get(struct rtl8231_gpios *gpios, u32 gpio, u16 *state)
{
u32 v = rtl8231_read(gpios, RTL8231_GPIO_DATA(gpio));

if (v & 0x80000000) {
pr_err("Error reading RTL8231\n");
return -1;
}

*state = v & 0xffff;

return 0;
}

The above function is used to pull value form I/O pins.</s>




NEXT




<s> static int sata_oxnas_qc_new(struct ata_port *ap)
{
struct sata_oxnas_host_priv *hd = ap->host->private_data;

DPRINTK("port %d\n", ap->port_no);
smp_rmb();
if (hd->port_frozen || hd->port_in_eh)
return 1;
else
return !sata_oxnas_acquire_hw(ap, 0, 0);
}

The above function is used to check if there are already
enough active ports, thus preventing us to get too many ports
in a state which can prevent any new devices from being assigned
to them. Once one of the ports is "frozen" or the port




NEXT




<s> adm6996_set_enable_vlan(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);

if (val->value.i > 1)
return -EINVAL;

priv->enable_vlan = val->value.i;

return 0;
};

The above function is used to set the enable/disable vlan. Enable_vlan is a boolean attribute of the switch driver.

The function first checks if the given value is less than or equal to 1. If it is greater than 1, it returns




NEXT




<s> static int oxnas_pcie_phy_probe(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct device_node *np = pdev->dev.of_node;
struct phy *generic_phy;
struct phy_provider *phy_provider;
struct oxnas_pcie_phy *pciephy;
struct regmap *sys_ctrl;
struct reset_control *rstc;
void __iomem *membase;

membase = of_iomap(np, 0);
if (IS_ERR(membase))
return PTR_ERR(membase);

sys_ctrl = syscon_regmap_lookup_by_compatible("oxsemi,ox820-sys-ctrl");
if (IS_ERR(sys_ctrl))
return PTR_ERR(sys_ctrl);

rstc = devm_reset_control_get_shared(dev, "phy");
if (IS_ERR(rstc))
return PTR_ERR(rstc);

pciephy = devm_kzalloc(dev, sizeof(*pciephy), GFP_KERNEL);
if (!pciephy)
return -ENOMEM;

pciephy->sys_ctrl = sys_ctrl;
pciephy->rstc = rstc;
pciephy->membase = membase;
pciephy->dev = dev;
pciephy->ops = &ops;

generic_phy = devm_phy_create(dev, dev->of_node, pciephy->ops);
if (IS_ERR(generic_phy)) {
dev_err(dev, "failed to create PHY\n");
return PTR_ERR(generic_phy);
}

phy_set_drvdata(generic_phy, pciephy);
phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);

return PTR_ERR_OR_ZERO(phy_provider);
}

The above function is used to probe the PCie PHY on the OXNAS board.</s>




NEXT




<s> rtk_api_ret_t rtk_ptp_intStatus_get(rtk_ptp_intStatus_t *pStatusMask)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pStatusMask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicEavInterruptStatus(pStatusMask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the interrupt mask of PTP.</s>




NEXT




<s> static inline int gpio_pupd_set(struct dc_ep_dev *dev, u32 gpio, u32 val)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_gpio_pupd_set(dev->priv, gpio, val);
}

The above function is used to set the power up/down mode
of a given GPIO pin. If val is 1, the pin is configured to power down mode
and if ‘val’ is 0, the pin will be powered up.

DC_EP




NEXT




<s> u32 fe_reg_r32(enum fe_reg reg)
{
return fe_r32(fe_reg_table[reg]);
}

The above function is used to read the 8-bit register contents of one of the
16 registers present on the FE chip. It returns a 32-bit value, though only the
upper 16 bits (the lower 16 bits are all




NEXT




<s> t_nextline(fp)
FILE * fp;
{
int c;

while((c = getc(fp)) != '\n')
if(c == EOF)
return -1;
return 0;
}

The above function is used to return the number of lines in a file. But, It uses up a lot of system memory which is not so necessary. So this code is modified to be more memory efficient.

The code is below.

t_nextline(




NEXT




<s> static ssize_t hc_tag_show_mac(const u8 *pld, u16 pld_len, char *buf)
{
if (8 != pld_len)
return -EINVAL;

return sprintf(buf, "%pM\n", pld);
}

The above function is used to show the destination address information
in the IGMP message in the output file. If the Ethernet frame format is
used, then the length of the Ethernet header (6) is added after the
source address information so that




NEXT




<s> void rtl839x_vlan_port_keep_tag_set(int port, bool keep_outer, bool keep_inner)
{
sw_w32(FIELD_PREP(RTL839X_VLAN_PORT_TAG_STS_CTRL_OTAG_STS_MASK,
keep_outer ? RTL839X_VLAN_PORT_TAG_STS_TAGGED : RTL839X_VLAN_PORT_TAG_STS_UNTAG) |
FIELD_PREP(RTL839X_VLAN_PORT_TAG_STS_CTRL_ITAG_STS_MASK,
keep_inner ? RTL839X_VLAN_PORT_TAG_STS_TAGGED : RTL839X_VLAN_PORT_TAG_STS_UNTAG),
RTL839X_VLAN_PORT_TAG_STS_CTRL(port));
}

The above function is used to set the keep outer/inner tag bit in
RTL839x swicthes. The following are some example to change the
behavior of a port, for incoming packets, they can be (from normal to
inverse):




NEXT




<s> adm6996_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);

pr_devel("set_vid port %d vid %d\n", val->port_vlan, val->value.i);

if (val->value.i > ADM_VLAN_MAX_ID)
return -EINVAL;

priv->vlan_id[val->port_vlan] = val->value.i;

return 0;
};

The above function is used to set the port vid in switch_dev. It reads the port
vid by the variable val->port_vlan. The function returns 0 on success and a
negative value on failure. If the value returned is a negative number,





NEXT




<s> static unsigned int AT91F_SetPLL(void)
{
AT91_REG tmp;
AT91PS_PMC pPmc = AT91C_BASE_PMC;
AT91PS_CKGR pCkgr = AT91C_BASE_CKGR;

pPmc->PMC_IDR = 0xFFFFFFFF;

/* -Setup the PLL A */
pCkgr->CKGR_PLLAR = AT91C_PLLA_VALUE;

while (!(*AT91C_PMC_SR & AT91C_PMC_LOCKA));

/* - Switch Master Clock from PLLB to PLLA/3 */
tmp = pPmc->PMC_MCKR;
/* See Atmel Errata #27 and #28 */
if (tmp & 0x0000001C) {
tmp = (tmp & ~0x0000001C);
pPmc->PMC_MCKR = tmp;
while (!(*AT91C_PMC_SR & AT91C_PMC_MCKRDY));
}
if (tmp != 0x00000202) {
pPmc->PMC_MCKR = 0x00000202;
if ((tmp & 0x00000003) != 0x00000002)
while (!(*AT91C_PMC_SR & AT91C_PMC_MCKRDY));
}

return 1;
}

The above function is used to setup the 120Mhz clock for the AT91 processer. This routine also
searches for a 160Mhz PLL and sets it up for the SDRAM so the AT91




NEXT




<s> static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to push oam data to the next driver
#endif

/**
 * \brief	Init TX tables.
 *
 *	This routine initializes the TX tables.
 */
void init_tx_tables(void)
{




NEXT




<s> int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
const BIGNUM *m, BN_CTX *ctx)
{
int i,j,bits,ret=0,wstart,wend,window,wvalue,ts=0;
int start=1;
BIGNUM *d;
BIGNUM val[TABLE_SIZE];

bits=BN_num_bits(p);

if (bits == 0)
{
BN_one(r);
return(1);
}

BN_CTX_start(ctx);
if ((d = BN_CTX_get(ctx)) == NULL) goto err;

BN_init(&(val[0]));
ts=1;
if (!BN_mod(&(val[0]),a,m,ctx)) goto err;               /* 1 */

window = BN_window_bits_for_exponent_size(bits);
if (window > 1)
{
if (!BN_mod_mul(d,&(val[0]),&(val[0]),m,ctx))
goto err;                               /* 2 */
j=1<<(window-1);
for (i=1; i<j; i++)
{
BN_init(&(val[i]));
if (!BN_mod_mul(&(val[i]),&(val[i-1]),d,m,ctx))
goto err;
}
ts=i;
}

start=1;        /* This is used to avoid multiplication etc
* when there is only the value '1' in the
* buffer. */
wvalue=0;       /* The 'value' of the window */
wstart=bits-1;  /* The top bit of the window */
wend=0;         /* The bottom bit of the window */

if (!BN_one(r)) goto err;

for (;;)
{
if (BN_is_bit_set(p,wstart) == 0)
{
if (!start)
if (!BN_mod_mul(r,r,r,m,ctx))
goto err;
if (wstart == 0) break;
wstart--;
continue;
}
/* We now have wstart on a 'set' bit, we now need to work out
* how bit a window to do.  To do this we need to scan
* forward until the last set bit before the end of the
* window */
j=wstart;
wvalue=1;
wend=0;
for (i=1; i<window; i++)
{
if (wstart-i < 0) break;
if (BN_is_bit_set(p,wstart-i))
{
wvalue<<=(i-wend);
wvalue|=1;
wend=i;
}
}

/* wend is the size of the current window */
j=wend+1;
/* add the 'bytes above' */
if (!start)
for (i=0; i<j; i++)
{
if (!BN_mod_mul(r,r,r,m,ctx))
goto err;
}

/* wvalue will be an odd number < 2^window */
if (!BN_mod_mul(r,r,&(val[wvalue>>1]),m,ctx))
goto err;

/* move the 'window' down further */
wstart-=wend+1;
wvalue=0;
start=0;
if (wstart < 0) break;
}
ret=1;
err:
BN_CTX_end(ctx);
for (i=0; i<ts; i++)
BN_clear_free(&(val[i]));
return(ret);
}

The above function is used to perform exponentiation when no speed up
is necessary.  It is used in other functions and
subroutines.

int BN_mod_exp(BIGNUM *r, BIGNUM *b, BIGNUM




NEXT




<s> int expr_contains_symbol(struct expr *dep, struct symbol *sym)
{
if (!dep)
return 0;

switch (dep->type) {
case E_AND:
case E_OR:
return expr_contains_symbol(dep->left.expr, sym) ||
expr_contains_symbol(dep->right.expr, sym);
case E_SYMBOL:
return dep->left.sym == sym;
case E_EQUAL:
case E_GEQ:
case E_GTH:
case E_LEQ:
case E_LTH:
case E_UNEQUAL:
return dep->left.sym == sym ||
dep->right.sym == sym;
case E_NOT:
return expr_contains_symbol(dep->left.expr, sym);
default:
;
}
return 0;
}

The above function is used to determine whether the dependency declaration declares a subroutine with a particular symbol (e.g., whether it declares an A_GEQ).</s>




NEXT




<s> int getc()
{
return at91_serial_getc();
}

The above function is used to get a character from the serial port. Note that it refers to another (C++) function with the same name. By convention, the names of routines written in C and not C++ must start with a lower-case letter.

There




NEXT




<s> static struct rtl83xx_route *rtl83xx_route_alloc(struct rtl838x_switch_priv *priv, u32 ip)
{
struct rtl83xx_route *r;
int idx = 0, err;

mutex_lock(&priv->reg_mutex);

idx = find_first_zero_bit(priv->route_use_bm, MAX_ROUTES);
pr_debug("%s id: %d, ip %pI4\n", __func__, idx, &ip);

r = kzalloc(sizeof(*r), GFP_KERNEL);
if (!r) {
mutex_unlock(&priv->reg_mutex);
return r;
}

r->id = idx;
r->gw_ip = ip;
r->pr.id = -1; /* We still need to allocate a rule in HW */
r->is_host_route = false;

err = rhltable_insert(&priv->routes, &r->linkage, route_ht_params);
if (err) {
pr_err("Could not insert new rule\n");
mutex_unlock(&priv->reg_mutex);
goto out_free;
}

set_bit(idx, priv->route_use_bm);

mutex_unlock(&priv->reg_mutex);

return r;

out_free:
kfree(r);

return NULL;
}

The above function is used to allocate a route in order to send packets to a destination.</s>




NEXT




<s> static char *do_lineno(int argc, char *argv[])
{
char buf[16];

sprintf(buf, "%d", yylineno);

return xstrdup(buf);
}

The above function is used to return line number, where the current symbol token is defined.

I modified the code to get the corresponding line number

where 4th parameter to yyparse is to the function

yy parse code is in ./gcc/parser




NEXT




<s> static int __init mtdsplit_eva_init(void)
{
register_mtd_parser(&mtdsplit_eva_parser);

return 0;
}

The above function is used to handle all of the initialization steps
required before the actual mtdsplit operation can start.  This
means that for the most part this consists only of registering the
parasers for handling the available types of flash chips that this





NEXT




<s> u32 _mt7620_mii_write(struct mt7620_gsw *gsw, u32 phy_addr,
u32 phy_register, u32 write_data)
{
if (mt7620_mii_busy_wait(gsw))
return -1;

write_data &= 0xffff;

mtk_switch_w32(gsw, GSW_MDIO_ACCESS | GSW_MDIO_START | GSW_MDIO_WRITE |
(phy_register << GSW_MDIO_REG_SHIFT) |
(phy_addr << GSW_MDIO_ADDR_SHIFT) | write_data,
MT7620A_GSW_REG_PIAC);

if (mt7620_mii_busy_wait(gsw))
return -1;

return 0;
}

The above function is used to write data.
It’s a good idea to write data to MDIO_ACCESS[31] bit of GSW_REG_PIAC before reading.

After reading, MDIO_READ[31] bit of G




NEXT




<s> ret_t rtl8367c_setAsicRldpEnable8051(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_8051_ENABLE_OFFSET, enabled);
}

The above function is used to enable 8051.

rtk_uint32 rtl8367c_getAsicRldpHcsRegBaseAddr(void)
{
rtk_uint32 base;






NEXT




<s> int wpas_ucode_init(struct wpa_global *gl)
{
static const uc_function_list_t global_fns[] = {
{ "printf",	uc_wpa_printf },
{ "getpid", uc_wpa_getpid },
{ "add_iface", uc_wpas_add_iface },
{ "remove_iface", uc_wpas_remove_iface },
{ "udebug_set", uc_wpa_udebug_set },
};
static const uc_function_list_t iface_fns[] = {
{ "status", uc_wpas_iface_status },
};
uc_value_t *data, *proto;

wpa_global = gl;
vm = wpa_ucode_create_vm();

global_type = uc_type_declare(vm, "wpas.global", global_fns, NULL);
iface_type = uc_type_declare(vm, "wpas.iface", iface_fns, NULL);

iface_registry = ucv_array_new(vm);
uc_vm_registry_set(vm, "wpas.iface_registry", iface_registry);

global = wpa_ucode_global_init("wpas", global_type);

if (wpa_ucode_run(HOSTAPD_UC_PATH "wpa_supplicant.uc"))
goto free_vm;

ucv_gc(vm);
return 0;

free_vm:
wpa_ucode_free_vm();
return -1;
}

The above function is used to initialize the ucode, and the ucode must
contain a file called wpa_supplicant.uc with the following contents:

uc_set_program_name("wpas_ucode_init");
uc_




NEXT




<s> static irqreturn_t rtl93xx_net_irq(int irq, void *dev_id)
{
struct net_device *dev = dev_id;
struct rtl838x_eth_priv *priv = netdev_priv(dev);
u32 status_rx_r = sw_r32(priv->r->dma_if_intr_rx_runout_sts);
u32 status_rx = sw_r32(priv->r->dma_if_intr_rx_done_sts);
u32 status_tx = sw_r32(priv->r->dma_if_intr_tx_done_sts);

pr_debug("In %s, status_tx: %08x, status_rx: %08x, status_rx_r: %08x\n",
__func__, status_tx, status_rx, status_rx_r);

/*  Ignore TX interrupt */
if (status_tx) {
/* Clear ISR */
pr_debug("TX done\n");
sw_w32(status_tx, priv->r->dma_if_intr_tx_done_sts);
}

/* RX interrupt */
if (status_rx) {
pr_debug("RX IRQ\n");
/* ACK and disable RX interrupt for given rings */
sw_w32(status_rx, priv->r->dma_if_intr_rx_done_sts);
sw_w32_mask(status_rx, 0, priv->r->dma_if_intr_rx_done_msk);
for (int i = 0; i < priv->rxrings; i++) {
if (status_rx & BIT(i)) {
pr_debug("Scheduling queue: %d\n", i);
napi_schedule(&priv->rx_qs[i].napi);
}
}
}

/* RX buffer overrun */
if (status_rx_r) {
pr_debug("RX buffer overrun: status %x, mask: %x\n",
status_rx_r, sw_r32(priv->r->dma_if_intr_rx_runout_msk));
sw_w32(status_rx_r, priv->r->dma_if_intr_rx_runout_sts);
rtl838x_rb_cleanup(priv, status_rx_r);
}

return IRQ_HANDLED;
}

The above function is used to handle all the RX
interrupts for the device.</s>




NEXT




<s> static int rtcl_ccu_create(struct device_node *np)
{
int soc;

if (of_device_is_compatible(np, "realtek,rtl8380-clock"))
soc = SOC_RTL838X;
else if (of_device_is_compatible(np, "realtek,rtl8390-clock"))
soc = SOC_RTL839X;
else
return -ENXIO;

rtcl_ccu = kzalloc(sizeof(*rtcl_ccu), GFP_KERNEL);
if (IS_ERR(rtcl_ccu))
return -ENOMEM;

rtcl_ccu->np = np;
rtcl_ccu->soc = soc;
rtcl_ccu->dram.type = RTL_MC_MCR_DRAMTYPE(read_soc(RTL_MC_MCR));
rtcl_ccu->dram.buswidth = RTL_MC_DCR_BUSWIDTH(read_soc(RTL_MC_DCR));
spin_lock_init(&rtcl_ccu->lock);

return 0;
}

The above function is used to create a clock controller device. In short, an RTClk driver
needs a clock device, on which the functions that configure the bus clock, DRAM clock and
other kinds of clocks are registered.

An RTClk




NEXT




<s> static irqreturn_t ag71xx_interrupt(int irq, void *dev_id)
{
struct net_device *dev = dev_id;
struct ag71xx *ag = netdev_priv(dev);
u32 status;

status = ag71xx_rr(ag, AG71XX_REG_INT_STATUS);
ag71xx_dump_intr(ag, "raw", status);

if (unlikely(!status))
return IRQ_NONE;

if (unlikely(status & AG71XX_INT_ERR)) {
if (status & AG71XX_INT_TX_BE) {
ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE);
dev_err(&dev->dev, "TX BUS error\n");
}
if (status & AG71XX_INT_RX_BE) {
ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE);
dev_err(&dev->dev, "RX BUS error\n");
}
}

if (likely(status & AG71XX_INT_POLL)) {
ag71xx_int_disable(ag, AG71XX_INT_POLL);
DBG("%s: enable polling mode\n", dev->name);
napi_schedule(&ag->napi);
}

ag71xx_debugfs_update_int_stats(ag, status);

return IRQ_HANDLED;
}

The above function is used to handle all the interrupts from the Ag71xx devices. The function begins by checking if there are any interrupts, if there aren't then the function returns none. If an interrupt is occurring then it checks if there is an error interrupt




NEXT




<s> rtk_api_ret_t rtk_qos_portPri_get(rtk_port_t port, rtk_pri_t *pInt_pri)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicPriorityPortBased(rtk_switch_port_L2P_get(port), pInt_pri)) != RT_ERR_OK)
return retVal;


return RT_ERR_OK;
}

The above function is used to get the value of internal Port Priority.

#ifdef PORT_PRI_SHOW_BY_COS
rtk_api_ret_t rtk_qos_portPri_getRange(rtk_port




NEXT




<s> static void swconfig_defaults_init(struct switch_dev *dev)
{
const struct switch_dev_ops *ops = dev->ops;

dev->def_global = 0;
dev->def_vlan = 0;
dev->def_port = 0;

if (ops->get_vlan_ports || ops->set_vlan_ports)
set_bit(VLAN_PORTS, &dev->def_vlan);

if (ops->get_port_pvid || ops->set_port_pvid)
set_bit(PORT_PVID, &dev->def_port);

if (ops->get_port_link &&
!swconfig_find_attr_by_name(&ops->attr_port, "link"))
set_bit(PORT_LINK, &dev->def_port);

/* always present, can be no-op */
set_bit(GLOBAL_APPLY, &dev->def_global);
set_bit(GLOBAL_RESET, &dev->def_global);
}

The above function is used to initialize the defaults of a switch_dev
structure. The actual application is in __add_switch.

struct switch_dev switch_dev = {
.ops = &ops,
.name = SWITCHDEV_NAME,




NEXT




<s> static int rtl8366rb_sw_set_port_led(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;
u32 mask;
u32 reg;

if (val->port_vlan >= RTL8366RB_NUM_PORTS)
return -EINVAL;

if (val->port_vlan == RTL8366RB_PORT_NUM_CPU) {
reg = RTL8366RB_LED_BLINKRATE_REG;
mask = 0xF << 4;
data = val->value.i << 4;
} else {
reg = RTL8366RB_LED_CTRL_REG;
mask = 0xF << (val->port_vlan * 4),
data = val->value.i << (val->port_vlan * 4);
}

return rtl8366_smi_rmwr(smi, reg, mask, data);
}

The above function is used to set the port's specific led on/off setting:</s>




NEXT




<s> static int superio_inw(int base, int reg)
{
int val;

outb(reg++, base);
val = inb(base + 1) << 8;
outb(reg, base);
val |= inb(base + 1);

return val;
}

The above function is used to read from the Super I/O port (usually LPC). The function accesses the port twice, with the lower 8 bits of the register the first time and upper 8 bits for the second time.
- There is a subtle




NEXT




<s> ret_t rtl8367c_setAsic1xPBAuthConfig(rtk_uint32 port, rtk_uint32 auth)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_PORT_AUTH_REG, port, auth);
}

The above function is used to configure whether a given port supports
802.1x port based authentication. However, RT device driver does not allow
user to configure this parameter because this device parameter is only useful
to 802.11 client stations to




NEXT




<s> void hexdump(unsigned char *buf, unsigned int len)
{
print_hex_dump(KERN_CONT, "", DUMP_PREFIX_OFFSET,
16, 1,
buf, len, false);
}

The above function is used to dump the data being passed to the output. Each iteration of this function uses read_file
to read out 512 bytes. These 512 bytes are then processed by the hexdump function. This function returns a pointer





NEXT




<s> int rtl_table_read(struct table_reg *r, int idx)
{
return rtl_table_exec(r, false, idx);
}

The above function is used to read the value of the indexed register table field using a function pointer to the table. As before, the function uses rtl_table_exec() to read the field value and store it in the return value. The value of the indexed




NEXT




<s> static int gpio_rb91x_key_remove(struct platform_device *pdev)
{
struct gpio_rb91x_key *drvdata = platform_get_drvdata(pdev);

gpiochip_remove(&drvdata->gc);
return 0;
}

The above function is used to unload the “Rb91x USB Mouse Key/Touchpad”. We can test it on the following demo:

[shell#] #modprobe rb91x-key-touch-usb
[shell#] #




NEXT




<s> uc_bpf_map_arg(uc_value_t *val, const char *kind, unsigned int size)
{
static union {
uint32_t u32;
uint64_t u64;
} val_int;

switch (ucv_type(val)) {
case UC_INTEGER:
if (size == 4)
val_int.u32 = ucv_int64_get(val);
else if (size == 8)
val_int.u64 = ucv_int64_get(val);
else
break;

return &val_int;
case UC_STRING:
if (size != ucv_string_length(val))
break;

return ucv_string_get(val);
default:
err_return(EINVAL, "%s type", kind);
}

err_return(EINVAL, "%s size mismatch (expected: %d)", kind, size);
}

The above function is used to set all "map argument" fields.

The only other field is bpf_args_cnt - which would just be a uint32_t, as seen
here:

struct bpf_map_create_Args {




NEXT




<s> rtk_api_ret_t rtk_led_blinkRate_get(rtk_led_blink_rate_t *pBlinkRate)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pBlinkRate)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLedBlinkRate(pBlinkRate)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get value of LED blink rate register.</s>




NEXT




<s> rtk_api_ret_t rtk_int_polarity_get(rtk_int_polarity_t *pType)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pType)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicInterruptPolarity(pType)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get INT polarity.</s>




NEXT




<s> t_random(data, size)
unsigned char * data;
unsigned size;
{
if(!initialized)
t_initrand();

if(size <= 0)         /* t_random(NULL, 0) forces seed initialization */
return;

while(size > outpos) {
if(outpos > 0) {
memcpy(data, randout + (sizeof(randout) - outpos), outpos);
data += outpos;
size -= outpos;
}

/* Recycle */
SHA1Init(&randctxt);
SHA1Update(&randctxt, randpool, sizeof(randpool));
SHA1Final(randout, &randctxt);
SHA1Init(&randctxt);
SHA1Update(&randctxt, (unsigned char *) &randcnt, sizeof(randcnt));
SHA1Update(&randctxt, randpool, sizeof(randpool));
SHA1Final(randpool, &randctxt);
++randcnt;
outpos = sizeof(randout);
}

if(size > 0) {
memcpy(data, randout + (sizeof(randout) - outpos), size);
outpos -= size;
}
}

The above function is used to seed the pseudo-random number generator. The following function is used to increment the seed number (that is, the value that will be returned by t_random) as well as compute the output (that is, the result of invoking t_




NEXT




<s> rtk_api_ret_t rtk_l2_flushLinkDownPortAddrEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (port != RTK_WHOLE_SYSTEM)
return RT_ERR_PORT_ID;

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicLutLinkDownForceAging(enable)) != RT_ERR_OK)
return retVal;


return RT_ERR_OK;
}

The above function is used to enable/disable the aging timer for the whole port system from the application layer.

RTK_L2_FLUSH_LINK_DOWN_PORT_ADDR_ENABLE
   Enable/Disable Aging timer.</s>




NEXT




<s> ret_t rtl8367c_getAsicLutDisableAging(rtk_uint32 port, rtk_uint32 *pDisabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_LUT_AGEOUT_CTRL_REG, port, pDisabled);
}

The above function is used to set/get Asic LUT Disable Aging Mode. The aging mode configures if the HB is aging or not. The aging will force the MAC to age out the entry with zero packet arrival before it timeout. If aging mode is




NEXT




<s> static u64 rtl83xx_mc_group_del_port(struct rtl838x_switch_priv *priv, int mc_group, int port)
{
u64 portmask = priv->r->read_mcast_pmask(mc_group);

pr_debug("%s: %d\n", __func__, port);

portmask &= ~BIT_ULL(port);
priv->r->write_mcast_pmask(mc_group, portmask);
if (!portmask)
clear_bit(mc_group, priv->mc_group_bm);

return portmask;
}

The above function is used to remove a port number form the given mcast group.

Let’s say I have the function executed on this mcast group

For this entry, I will be looking for the port number.
Let’s say the entry is




NEXT




<s> IFX_MEI_DebugRead (DSL_DEV_Device_t * pDev, u32 srcaddr, u32 * databuff, u32 databuffsize)
{
u32 i;
u32 temp = 0x0;
u32 address = 0x0;
u32 *buffer = 0x0;

//      Open the debug port before DMP memory read
IFX_MEI_ControlModeSet (pDev, MEI_MASTER_MODE);

//      For the requested length, write the address and read the data
address = srcaddr;
buffer = databuff;
for (i = 0; i < databuffsize; i++) {
_IFX_MEI_DBGLongWordRead (pDev, ME_DBG_DECODE_DMP1_MASK, address, &temp);
*buffer = temp;
address += 4;
buffer++;
}

//      Close the debug port after DMP memory read
IFX_MEI_ControlModeSet (pDev, JTAG_MASTER_MODE);

return DSL_DEV_MEI_ERR_SUCCESS;
}

The above function is used to read the debug register.</s>




NEXT




<s> static void rb91x_nand_read(struct rb91x_nand_drvdata *drvdata,
u8 *read_buf,
unsigned len)
{
void __iomem *base = drvdata->ath79_gpio_base;
u32 oe_reg;
u32 out_reg;
unsigned i;

/* Enable read mode */
gpiod_set_value_cansleep(drvdata->gpio[RB91X_NAND_READ], 1);

rb91x_nand_latch_lock(drvdata, 1);
rb91x_nand_rst_key_poll_disable(drvdata, 1);

/* Save registers */
oe_reg = __raw_readl(base + AR71XX_GPIO_REG_OE);
out_reg = __raw_readl(base + AR71XX_GPIO_REG_OUT);

/* Set data lines to input mode */
__raw_writel(oe_reg | RB91X_NAND_DATA_BITS,
base + AR71XX_GPIO_REG_OE);

for (i = 0; i < len; i++) {
u32 in;
u8 data;

/* Activate RE line */
__raw_writel(RB91X_NAND_NRW_BIT, base + AR71XX_GPIO_REG_CLEAR);
/* Flush write */
__raw_readl(base + AR71XX_GPIO_REG_CLEAR);

/* Read input lines */
in = __raw_readl(base + AR71XX_GPIO_REG_IN);

/* Deactivate RE line */
__raw_writel(RB91X_NAND_NRW_BIT, base + AR71XX_GPIO_REG_SET);

data = (in & RB91X_NAND_LOW_DATA_MASK);
data |= (in >> RB91X_NAND_HIGH_DATA_SHIFT) &
RB91X_NAND_HIGH_DATA_MASK;

read_buf[i] = data;
}

/* Restore  registers */
__raw_writel(out_reg, base + AR71XX_GPIO_REG_OUT);
__raw_writel(oe_reg, base + AR71XX_GPIO_REG_OE);
/* Flush write */
__raw_readl(base + AR71XX_GPIO_REG_OUT);

rb91x_nand_rst_key_poll_disable(drvdata, 0);
rb91x_nand_latch_lock(drvdata, 0);

/* Disable read mode */
gpiod_set_value_cansleep(drvdata->gpio[RB91X_NAND_READ], 0);
}

The above function is used to perform a read-only NAND read operation.</s>




NEXT




<s> int dc_ep_reset_device(struct dc_ep_priv *priv, u32 bits)
{
int retry = EP_TIMEOUT;

wr32(bits, RCU_REQ);
do { } while (retry-- && (!(rd32(RCU_STAT) & bits)));

if (retry == 0) {
dev_err(priv->dev, "%s failed to reset\n", __func__);
return -ETIME;
}
return 0;
}

The above function is used to reset the DC_EP module.</s>




NEXT




<s> static uint32_t size2blk(struct nmbm_instance *ni, uint64_t size)
{
return (size + bmtd.blk_size - 1) >> bmtd.blk_shift;
}

The above function is used to convert logical block size into a logical block number for reading/writing.

Here is how this is tested in the testsuite:

struct nmbm_instance *n = nmbm_init(bmf_get_fd




NEXT




<s> int ase_start(int pp32)
{
int ret;

/*  download firmware   */
ret = pp32_download_code(firmware_binary_code, sizeof(firmware_binary_code) / sizeof(*firmware_binary_code), firmware_binary_data, sizeof(firmware_binary_data) / sizeof(*firmware_binary_data));
if ( ret != 0 )
return ret;

/*  run PP32    */
IFX_REG_W32(DBG_CTRL_RESTART, PP32_DBG_CTRL);

/*  idle for a while to let PP32 init itself    */
udelay(10);

return 0;
}

The above function is used to control PP32 through ASE, ASE and PP32 are communication together. Firmware in PP32 will be updated when control ASE, and ase_start will start PP32 if it is stopped by before.




NEXT




<s> ret_t rtl8367c_setAsicPortMirrorMask(rtk_uint32 SourcePortmask)
{
if( SourcePortmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

return rtl8367c_setAsicRegBits(RTL8367C_REG_MIRROR_SRC_PMSK, RTL8367C_MIRROR_SRC_PMSK_MASK, SourcePortmask);
}

The above function is used to set mirror mask for a port
In portmask, we define that:

0: port 0
RTL8367C_PORTMASK: port 15

If want to use port 4, then set




NEXT




<s> static void esw_set_pvid(struct rt305x_esw *esw, unsigned port, unsigned pvid)
{
unsigned s;

s = RT305X_ESW_PVIDC_PVID_S * (port % 2);
esw_rmw(esw,
RT305X_ESW_REG_PVIDC(port / 2),
RT305X_ESW_PVIDC_PVID_M << s,
(pvid & RT305X_ESW_PVIDC_PVID_M) << s);
}

The above function is used to map the pvid of etherent ports. One point in this function should be highlighted and that is:

The function esw_rmw(esw, RT305X_ESW_REG_PVIDC(




NEXT




<s> rtk_api_ret_t rtk_switch_maxPktLenCfg_set(rtk_uint32 cfgId, rtk_uint32 pktLen)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(cfgId > MAXPKTLEN_CFG_ID_MAX)
return RT_ERR_INPUT;

if(pktLen > RTK_SWITCH_MAX_PKTLEN)
return RT_ERR_INPUT;

if((retVal = rtl8367c_setAsicMaxLengthCfg(cfgId, pktLen)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the maximum length (in bytes) for packet,
which is used for flow control and packet filtering on the input and output ports
for the given flow direction of the port.

Example:

    rtk_switch_




NEXT




<s> uc_bpf_program_pin(uc_vm_t *vm, size_t nargs)
{
return uc_bpf_obj_pin(vm, nargs, "bpf.program");
}

The above function is used to pin the BPF program into memory. This is done on a per process basis when the process is booted. This is done so the BPF program does not get relocated. The function returns a uc_bpf_program_




NEXT




<s> get_prime(void)
{
msg->type = htonl(EAD_TYPE_GET_PRIME);
msg->len = 0;
return send_packet(EAD_TYPE_PRIME, handle_prime, 1);
}

The above function is used to get information on
the EAD server.  At this time, the only
information available is the prime that is
used for RSA encryption/decryption.

handle_prime(void *data, u_int16_




NEXT




<s> static int msp430_blink_set(struct led_classdev *led_cdev,
unsigned long *delay_on,
unsigned long *delay_off)
{
struct msp430_led *led =
container_of(led_cdev, struct msp430_led, cdev);
u8 tx[MSP430_CMD_BYTES] = {led->id, MSP430_LED_FLASH, 0, 0, 0, 0};
u8 rx[MSP430_CMD_BYTES];
unsigned long delay;

if (!*delay_on)
*delay_on = MSP430_LED_BLINK_DEF;
if (!*delay_off)
*delay_off = MSP430_LED_BLINK_DEF;

delay = msp430_blink_delay(*delay_on);
if (delay != msp430_blink_delay(*delay_off)) {
dev_dbg(led_cdev->dev,
"fallback to soft blinking (delay_on != delay_off)\n");
return -EINVAL;
}

if (delay > MSP430_LED_BLINK_MASK) {
dev_dbg(led_cdev->dev,
"fallback to soft blinking (delay > %ums)\n",
MSP430_LED_BLINK_MAX);
return -EINVAL;
}

tx[3] = delay;

return msp430_cmd(led->spi, tx, rx);
}

The above function is used to control an LED via msp430_blink_set,
it is used to modify the delay time of one period of blinking on this LED.

The LED can be turned to on and off via msp43




NEXT




<s> rtk_uint32 rtk_switch_phyPortMask_get(void)
{
if(init_state != INIT_COMPLETED)
return 0x00; /* No port in portmask */

return (halCtrl->phy_portmask);
}

The above function is used to get the Phy mask of the switch.</s>




NEXT




<s> void rtl8218d_eee_set(struct phy_device *phydev, bool enable)
{
u32 val;
bool an_enabled;

pr_debug("In %s %d, enable %d\n", __func__, phydev->mdio.addr, enable);
/* Set GPHY page to copper */
phy_write_paged(phydev, RTL821X_PAGE_GPHY, RTL821XEXT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_COPPER);

val = phy_read(phydev, MII_BMCR);
an_enabled = val & BMCR_ANENABLE;

val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
val |= MDIO_EEE_1000T | MDIO_EEE_100TX;
phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, enable ? (MDIO_EEE_100TX | MDIO_EEE_1000T) : 0);

/* 500M EEE ability */
val = phy_read_paged(phydev, RTL821X_PAGE_GPHY, 20);
if (enable)
val |= BIT(7);
else
val &= ~BIT(7);
phy_write_paged(phydev, RTL821X_PAGE_GPHY, 20, val);

/* Restart AN if enabled */
if (an_enabled) {
val = phy_read(phydev, MII_BMCR);
val |= BMCR_ANRESTART;
phy_write(phydev, MII_BMCR, val);
}

/* GPHY page back to auto */
phy_write_paged(phydev, RTL821X_PAGE_GPHY, RTL821XEXT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_AUTO);
}

The above function is used to configure EEE on the upstream/downstream phy.

To get link up and down status, use the polling function above.

Below are a couple of tests where link came up after some time.
In general




NEXT




<s> static void msdc_init_gpd_bd(struct msdc_host *host, struct msdc_dma *dma)
{
struct gpd *gpd = dma->gpd;
struct bd  *bd  = dma->bd;
int i;

/* we just support one gpd, but gpd->next must be set for desc
* DMA. That's why we alloc 2 gpd structurs.
*/

memset(gpd, 0, sizeof(struct gpd) * 2);

gpd->bdp  = 1;   /* hwo, cs, bd pointer */
gpd->ptr = (void *)dma->bd_addr; /* physical address */
gpd->next = (void *)((u32)dma->gpd_addr + sizeof(struct gpd));

memset(bd, 0, sizeof(struct bd) * MAX_BD_NUM);
for (i = 0; i < (MAX_BD_NUM - 1); i++)
bd[i].next = (void *)(dma->bd_addr + sizeof(*bd) * (i + 1));
}

The above function is used to initialize the BD and GPD pointers. For
example, "bdp" is 0b1 in BD and 0b101 in GPD; 0b11 is in the BD of
GP




NEXT




<s> static inline struct wpa_supplicant *get_wpas_from_object(struct ubus_object *obj)
{
return container_of(obj, struct wpa_supplicant, ubus.obj);
}

The above function is used to retrieve the wpa_supplicant structure inside ubus_object object.
So, here the ubus_object is a wrapper of the wpa_supplicant.
The ubus can be seen as an interface for linux




NEXT




<s> ar8xxx_sw_set_flush_port_arl_table(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
int port, ret;

port = val->port_vlan;
if (port >= dev->ports)
return -EINVAL;

mutex_lock(&priv->reg_mutex);
ret = priv->chip->atu_flush_port(priv, port);
mutex_unlock(&priv->reg_mutex);

return ret;
}

The above function is used to flush a specific port AR-to-RL table which
is set up during ARP table synchronization to force the recomputation
of the table. It would be helpful if we could know when it is
safe to call this function with




NEXT




<s> rtk_api_ret_t rtk_trunk_hashMappingTable_set(rtk_trunk_group_t trk_gid, rtk_trunk_hashVal2Port_t *pHash2Port_array)
{
rtk_api_ret_t retVal;
rtk_uint32 hashValue;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Trunk Group Valid */
RTK_CHK_TRUNK_GROUP_VALID(trk_gid);

if(NULL == pHash2Port_array)
return RT_ERR_NULL_POINTER;

if(trk_gid <= TRUNK_GROUP1)
{
for(hashValue = 0; hashValue < RTK_MAX_NUM_OF_TRUNK_HASH_VAL; hashValue++)
{
if ((retVal = rtl8367c_setAsicTrunkingHashTable(hashValue, pHash2Port_array->value[hashValue])) != RT_ERR_OK)
return retVal;
}
}
else
{
for(hashValue = 0; hashValue < RTK_MAX_NUM_OF_TRUNK_HASH_VAL; hashValue++)
{
if ((retVal = rtl8367c_setAsicTrunkingHashTable1(hashValue, pHash2Port_array->value[hashValue])) != RT_ERR_OK)
return retVal;
}
}

return RT_ERR_OK;
}

The above function is used to reset the configuration of Trunking Hash Mapping Table (HW table, not the configuration register stored in DRAM) under the Trunk group selected.

The register fields are:

<trk_gid>[RTK




NEXT




<s> static void set_blackbg_theme(void)
{
DLG_COLOR(screen, COLOR_RED,   COLOR_BLACK, true);
DLG_COLOR(shadow, COLOR_BLACK, COLOR_BLACK, false);
DLG_COLOR(dialog, COLOR_WHITE, COLOR_BLACK, false);
DLG_COLOR(title,  COLOR_RED,   COLOR_BLACK, false);
DLG_COLOR(border, COLOR_BLACK, COLOR_BLACK, true);

DLG_COLOR(button_active,         COLOR_YELLOW, COLOR_RED,   false);
DLG_COLOR(button_inactive,       COLOR_YELLOW, COLOR_BLACK, false);
DLG_COLOR(button_key_active,     COLOR_YELLOW, COLOR_RED,   true);
DLG_COLOR(button_key_inactive,   COLOR_RED,    COLOR_BLACK, false);
DLG_COLOR(button_label_active,   COLOR_WHITE,  COLOR_RED,   false);
DLG_COLOR(button_label_inactive, COLOR_BLACK,  COLOR_BLACK, true);

DLG_COLOR(inputbox,         COLOR_YELLOW, COLOR_BLACK, false);
DLG_COLOR(inputbox_border,  COLOR_YELLOW, COLOR_BLACK, false);

DLG_COLOR(searchbox,        COLOR_YELLOW, COLOR_BLACK, false);
DLG_COLOR(searchbox_title,  COLOR_YELLOW, COLOR_BLACK, true);
DLG_COLOR(searchbox_border, COLOR_BLACK,  COLOR_BLACK, true);

DLG_COLOR(position_indicator, COLOR_RED, COLOR_BLACK,  false);

DLG_COLOR(menubox,          COLOR_YELLOW, COLOR_BLACK, false);
DLG_COLOR(menubox_border,   COLOR_BLACK,  COLOR_BLACK, true);

DLG_COLOR(item,             COLOR_WHITE, COLOR_BLACK, false);
DLG_COLOR(item_selected,    COLOR_WHITE, COLOR_RED,   false);

DLG_COLOR(tag,              COLOR_RED,    COLOR_BLACK, false);
DLG_COLOR(tag_selected,     COLOR_YELLOW, COLOR_RED,   true);
DLG_COLOR(tag_key,          COLOR_RED,    COLOR_BLACK, false);
DLG_COLOR(tag_key_selected, COLOR_YELLOW, COLOR_RED,   true);

DLG_COLOR(check,            COLOR_YELLOW, COLOR_BLACK, false);
DLG_COLOR(check_selected,   COLOR_YELLOW, COLOR_RED,   true);

DLG_COLOR(uarrow, COLOR_RED, COLOR_BLACK, false);
DLG_COLOR(darrow, COLOR_RED, COLOR_BLACK, false);
}

The above function is used to change the default theme to Blackbg. If you want to continue with the Blackbg theme, you can skip to the section "Set a new button style".

If you don't like the Blackbg theme, you can switch it back




NEXT




<s> ar8216_mangle_rx(struct net_device *dev, struct sk_buff *skb)
{
struct ar8xxx_priv *priv;
unsigned char *buf;
int port, vlan;

priv = dev->phy_ptr;
if (!priv)
return;

/* don't strip the header if vlan mode is disabled */
if (!priv->vlan)
return;

/* strip header, get vlan id */
buf = skb->data;
skb_pull(skb, 2);

/* check for vlan header presence */
if ((buf[12 + 2] != 0x81) || (buf[13 + 2] != 0x00))
return;

port = buf[0] & 0x7;

/* no need to fix up packets coming from a tagged source */
if (priv->vlan_tagged & (1 << port))
return;

/* lookup port vid from local table, the switch passes an invalid vlan id */
vlan = priv->vlan_id[priv->pvid[port]];

buf[14 + 2] &= 0xf0;
buf[14 + 2] |= vlan >> 8;
buf[15 + 2] = vlan & 0xff;
}

The above function is used to perform a very basic header mangle operation on the received packets. In this case, the function only deals with VLAN tagging. If you are not familiar with the VLAN concept, please refer to my previous post http://xunzhili




NEXT




<s> static int qca807x_read_copper_status(struct phy_device *phydev)
{
int ss, err, old_link = phydev->link;

/* Update the link, but return if there was an error */
err = genphy_update_link(phydev);
if (err)
return err;

/* why bother the PHY if nothing can have changed */
if (phydev->autoneg == AUTONEG_ENABLE && old_link && phydev->link)
return 0;

phydev->speed = SPEED_UNKNOWN;
phydev->duplex = DUPLEX_UNKNOWN;
phydev->pause = 0;
phydev->asym_pause = 0;

err = genphy_read_lpa(phydev);
if (err < 0)
return err;

/* Read the QCA807x PHY-Specific Status register copper page,
* which indicates the speed and duplex that the PHY is actually
* using, irrespective of whether we are in autoneg mode or not.
*/
ss = phy_read(phydev, QCA807X_PHY_SPECIFIC_STATUS);
if (ss < 0)
return ss;

if (ss & QCA807X_SS_SPEED_AND_DUPLEX_RESOLVED) {
int sfc;

sfc = phy_read(phydev, QCA807X_FUNCTION_CONTROL);
if (sfc < 0)
return sfc;

switch (FIELD_GET(QCA807X_SS_SPEED_MASK, ss)) {
case QCA807X_SS_SPEED_10:
phydev->speed = SPEED_10;
break;
case QCA807X_SS_SPEED_100:
phydev->speed = SPEED_100;
break;
case QCA807X_SS_SPEED_1000:
phydev->speed = SPEED_1000;
break;
}
if (ss & QCA807X_SS_DUPLEX)
phydev->duplex = DUPLEX_FULL;
else
phydev->duplex = DUPLEX_HALF;

if (ss & QCA807X_SS_MDIX)
phydev->mdix = ETH_TP_MDI_X;
else
phydev->mdix = ETH_TP_MDI;

switch (FIELD_GET(QCA807X_FC_MDI_CROSSOVER_MODE_MASK, sfc)) {
case QCA807X_FC_MDI_CROSSOVER_MANUAL_MDI:
phydev->mdix_ctrl = ETH_TP_MDI;
break;
case QCA807X_FC_MDI_CROSSOVER_MANUAL_MDIX:
phydev->mdix_ctrl = ETH_TP_MDI_X;
break;
case QCA807X_FC_MDI_CROSSOVER_AUTO:
phydev->mdix_ctrl = ETH_TP_MDI_AUTO;
break;
}
}

if (phydev->autoneg == AUTONEG_ENABLE && phydev->autoneg_complete)
phy_resolve_aneg_pause(phydev);

return 0;
}

The above function is used to read the copper link status of QCA’s (Qualcomms) proprietary PHYs, and is used in conjunction with the other copper PHY functions, like phy_is_up().

The function resolves the




NEXT




<s> rtk_api_ret_t rtk_rate_stormControlExtEnable_set(rtk_rate_storm_group_t stormType, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (stormType >= STORM_GROUP_END)
return RT_ERR_SFC_UNKNOWN_GROUP;

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

switch (stormType)
{
case STORM_GROUP_UNKNOWN_UNICAST:
if ((retVal = rtl8367c_setAsicStormFilterExtUnknownUnicastEnable(enable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_UNKNOWN_MULTICAST:
if ((retVal = rtl8367c_setAsicStormFilterExtUnknownMulticastEnable(enable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_MULTICAST:
if ((retVal = rtl8367c_setAsicStormFilterExtMulticastEnable(enable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_BROADCAST:
if ((retVal = rtl8367c_setAsicStormFilterExtBroadcastEnable(enable)) != RT_ERR_OK)
return retVal;
break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to configure the egress storm control rate thresholds.

rku_storm_type_t
- #define StormType: Rate Storm Control Type
- - #define STORM_GROUP_UNKNOWN_UNICAST: unknown un




NEXT




<s> static void ag71xx_ethtool_set_msglevel(struct net_device *dev, u32 msg_level)
{
struct ag71xx *ag = netdev_priv(dev);

ag->msg_enable = msg_level;
}

The above function is used to toggle msg_enable (which is a member of
the ag71xx structure which itself is a netdevice_priv member).

When msg_enable changes we can send a ulink message (with the new
mode value) to




NEXT




<s> ret_t rtl8367c_setAsic1xGuestVidx(rtk_uint32 index)
{
if(index >= RTL8367C_CVIDXNO)
return RT_ERR_DOT1X_GVLANIDX;

return rtl8367c_setAsicRegBits(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_GVIDX_MASK, index);
}

The above function is used to set the guest vidx

On the other side, I see there's a function to set the native tag in the trunk traffic, but it sets it using the CVID, and uses the CVID as the native tag id. I




NEXT




<s> mt7530_get_vlan_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

val->value.i = priv->global_vlan_enable;

return 0;
}

The above function is used to report the current global VLAN enable status to the FlexLAN driver. Here, dev points to the switch_dev structure for the current driver, in an RX callback, the current switch_dev is the FlexLAN sub-driver,




NEXT




<s> static int mt7620_gsw_remove(struct platform_device *pdev)
{
platform_set_drvdata(pdev, NULL);

return 0;
}

The above function is used to remove the driver.

The following is a list of mt7620_gsw_remove() functions:

The mt7620_gsw_remove() function.

The mt7620_




NEXT




<s> ret_t rtl8367c_getAsicRldpTriggerMode(rtk_uint32 *pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_TRIGGER_MODE_OFFSET, pEnabled);
}

The above function is used to read a single bit (or multiple bits) from some memory location within the SoC (i.e.
memory mapped IO). It’s an example of a getter function. Note the return type of the function, indicating there’s




NEXT




<s> void rtl931x_update_cntr(int r, int released)
{
int pos = (r % 3) * 10;
u32 reg = RTL931X_DMA_IF_RX_RING_CNTR + ((r / 3) << 2);
u32 v = sw_r32(reg);

v = (v >> pos) & 0x3ff;
sw_w32_mask(0x3ff << pos, released << pos, reg);
sw_w32(v, reg);
}

The above function is used to update the DMA rx ring counters on the rtl9311x.  The RTL931x has a 40-cell Rx ring.  We treat the ring as 3 concurrent rings and update the




NEXT




<s> ret_t rtl8367c_getAsicEavEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
{
if(port > RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_REG_EAV_CTRL0, port, pEnabled);
}

The above function is used to check the enabled status for EAV function.</s>




NEXT




<s> static void init_env(void)
{
static bool init_done = false;
struct rlimit limit = {
.rlim_cur = RLIM_INFINITY,
.rlim_max = RLIM_INFINITY,
};

if (init_done)
return;

setrlimit(RLIMIT_MEMLOCK, &limit);
init_done = true;
}

The above function is used to ensure that even if the user has set the limit on the memlock resource, kernel will not impose that limit when trying to lock pages.

The kernel module above is called ‘mem-locked’ and once it is loaded into the kernel




NEXT




<s> static int rtl8366rb_sw_get_port_rate_in(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

if (val->port_vlan >= RTL8366RB_NUM_PORTS)
return -EINVAL;

rtl8366_smi_read_reg(smi, RTL8366RB_IB_REG(val->port_vlan), &data);
data &= RTL8366RB_IB_BDTH_MASK;
if (data < RTL8366RB_IB_BDTH_MASK)
data += 1;

val->value.i = (int)data * RTL8366RB_BDTH_UNIT;

return 0;
}

The above function is used to get the port rate in bytes per second, by getting the register that stores the incoming byte count during the previous interrupt

struct rtl8366_smi *smi = sw_to_rtl8366_




NEXT




<s> static int mt7986a_pinctrl_probe(struct platform_device *pdev)
{
return mtk_moore_pinctrl_probe(pdev, &mt7986a_data);
}

The above function is used to probe a Pinctrl driver for the mt7986a board.
mt7986a_data is a structure containing the pin configurations for the mt7986a board.
The return value is returned by the




NEXT




<s> static int aes_cbcmac_final_impl(struct shash_desc *desc, u8 *out, bool hash_final);

/*! \fn static void aes_cbcmac_transform(struct shash_desc *desc, u8 const *in)
*  \ingroup IFX_aes_cbcmac_FUNCTIONS
*  \brief save input block to context
*  \param desc linux crypto shash descriptor
*  \param in 16-byte block of input
*/
static void aes_cbcmac_transform(struct shash_desc *desc, u8 const *in)
{
struct aes_ctx *mctx = crypto_shash_ctx(desc->tfm);

if ( ((mctx->dbn)+1) > AES_CBCMAC_DBN_TEMP_SIZE )
{
//printk("aes_cbcmac_DBN_TEMP_SIZE exceeded\n");
aes_cbcmac_final_impl(desc, (u8 *)mctx->hash, false);
}

memcpy(&mctx->temp[mctx->dbn], in, 16); //dbn workaround
mctx->dbn += 1;
}

The above function is used to process a block of input data to the hash function. It saves the input to the state of the hashing function and updates the buffer length of the state, which is then used by the finalize step to calculate the hash value. We only have




NEXT




<s> static void msdc_ops_request(struct mmc_host *mmc, struct mmc_request *mrq)
{
struct msdc_host *host = mmc_priv(mmc);

//=== for sdio profile ===
#if 0 /* --- by chhung */
u32 old_H32, old_L32, new_H32, new_L32;
u32 ticks = 0, opcode = 0, sizes = 0, bRx = 0;
#endif /* end of --- */

WARN_ON(host->mrq);

/* start to process */
spin_lock(&host->lock);
#if 0 /* --- by chhung */
if (sdio_pro_enable) {  //=== for sdio profile ===
if (mrq->cmd->opcode == 52 || mrq->cmd->opcode == 53)
GPT_GetCounter64(&old_L32, &old_H32);
}
#endif /* end of --- */

host->mrq = mrq;

if (msdc_do_request(mmc, mrq)) {
if (host->hw->flags & MSDC_REMOVABLE && ralink_soc == MT762X_SOC_MT7621AT && mrq->data && mrq->data->error)
msdc_tune_request(mmc, mrq);
}

/* ==== when request done, check if app_cmd ==== */
if (mrq->cmd->opcode == MMC_APP_CMD) {
host->app_cmd = 1;
host->app_cmd_arg = mrq->cmd->arg;  /* save the RCA */
} else {
host->app_cmd = 0;
//host->app_cmd_arg = 0;
}

host->mrq = NULL;

#if 0 /* --- by chhung */
//=== for sdio profile ===
if (sdio_pro_enable) {
if (mrq->cmd->opcode == 52 || mrq->cmd->opcode == 53) {
GPT_GetCounter64(&new_L32, &new_H32);
ticks = msdc_time_calc(old_L32, old_H32, new_L32, new_H32);

opcode = mrq->cmd->opcode;
if (mrq->cmd->data) {
sizes = mrq->cmd->data->blocks * mrq->cmd->data->blksz;
bRx = mrq->cmd->data->flags & MMC_DATA_READ ? 1 : 0;
} else {
bRx = mrq->cmd->arg	& 0x80000000 ? 1 : 0;
}

if (!mrq->cmd->error)
msdc_performance(opcode, sizes, bRx, ticks);
}
}
#endif /* end of --- */
spin_unlock(&host->lock);

mmc_request_done(mmc, mrq);

return;
}

The above function is used to send MSDC commands into MT7502.

To send commands, it must use spinlock to access host variables.

When using spinlock, we only check two conditions (app_cmd & opcode)
whe




NEXT




<s> rtk_api_ret_t rtk_filter_portrange_get(rtk_uint32 index, rtk_filter_portrange_t *pType, rtk_uint32 *pUpperPort, rtk_uint32 *pLowerPort)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if((NULL == pType) || (NULL == pUpperPort) || (NULL == pLowerPort))
return RT_ERR_NULL_POINTER;

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

if((ret = rtl8367c_getAsicAclPortRange(index, pType, pUpperPort, pLowerPort)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to retrieve the parameter information of the ACL range

Example:
{
rtk_uint32 index = 1;
rtk_uint32 lowerPort=0, upperPort=0;
rtk_filter_




NEXT




<s> static int psb6970_config_init(struct phy_device *pdev)
{
struct psb6970_priv *priv;
struct switch_dev *swdev;
int ret;

priv = kzalloc(sizeof(struct psb6970_priv), GFP_KERNEL);
if (priv == NULL)
return -ENOMEM;

priv->phy = pdev;

if (pdev->mdio.addr == 0)
printk(KERN_INFO "%s: psb6970 switch driver attached.\n",
pdev->attached_dev->name);

if (pdev->mdio.addr != 0) {
kfree(priv);
return 0;
}

linkmode_zero(pdev->supported);
linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, pdev->supported);
linkmode_copy(pdev->advertising, pdev->supported);

mutex_init(&priv->reg_mutex);
priv->read = psb6970_mii_read;
priv->write = psb6970_mii_write;

pdev->priv = priv;

swdev = &priv->dev;
swdev->cpu_port = PSB6970_DEFAULT_PORT_CPU;
swdev->ops = &psb6970_ops;

swdev->name = "Lantiq PSB6970";
swdev->vlans = PSB6970_MAX_VLANS;
swdev->ports = PSB6970_NUM_PORTS;

if ((ret = register_switch(&priv->dev, pdev->attached_dev)) < 0) {
kfree(priv);
goto done;
}

ret = psb6970_reset_switch(&priv->dev);
if (ret) {
kfree(priv);
goto done;
}

done:
return ret;
}

The above function is used to initialize ps7970 MAC. In the case of error allocation, then the ps7970 cannot be initialized. Therefore, it is important to determine whether ps7970 is working properly. The following code can determine whether it




NEXT




<s> static int aw9523_pmx_get_funcs_count(struct pinctrl_dev *pctl)
{
return ARRAY_SIZE(aw9523_pmx);
}

The above function is used to count the number of aw9523_pmx functions. It then sends the count to pinctrl_register_bank() in the module init section of kernel, which then stores it in the driver_data member as count for later




NEXT




<s> ret_t rtl8367c_getAsicAclUnmatchedPermit(rtk_uint32 port, rtk_uint32* pEnabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_ACL_UNMATCH_PERMIT_REG, port, pEnabled);
}

The above function is used to return ACL Unmatched Permit Setting (Enable).  Note that the ACL Unmatched Permit setting is different from the ACL Unmatched Discard Setting (Enable).  The ACL Unmatched Permit setting defines whether or not the




NEXT




<s> meiPollForDbgDone (DSL_DEV_Device_t * pDev)
{
u32 query = 0;
int i = 0;

while (i < WHILE_DELAY) {
IFX_MEI_LongWordReadOffset (pDev, (u32) ME_ARC2ME_STAT,  &query);
query &= (ARC_TO_MEI_DBG_DONE);
if (query)
break;
i++;
if (i == WHILE_DELAY) {
IFX_MEI_EMSG ("PollforDbg fail!\n");
}
}
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_ARC2ME_STAT, ARC_TO_MEI_DBG_DONE);	// to clear this interrupt
}

The above function is used to check for the interrupt from the MEI chip if the status bit ME_ARC2ME_STAT & 0x1 (ARC_TO_MEI_DBG_DONE). This interrupt happens due to some error on the chip




NEXT




<s> uc_bpf_obj_pin(uc_vm_t *vm, size_t nargs, const char *type)
{
struct uc_bpf_fd *f = uc_fn_thisval(type);
uc_value_t *path = uc_fn_arg(0);

if (ucv_type(path) != UC_STRING)
err_return(EINVAL, NULL);

if (bpf_obj_pin(f->fd, ucv_string_get(path)))
err_return(errno, NULL);

return TRUE;
}

The above function is used to create a file based bpf map:

static void bpf_prog_file_map(struct bpf_insn *insns, bool is_little_endian)
{
struct bpf_map_def




NEXT




<s> static int gpio_keys_polled_probe(struct platform_device *pdev)
{
struct gpio_keys_platform_data *pdata;
struct gpio_keys_button_dev *bdev;
int ret;

ret = gpio_keys_button_probe(pdev, &bdev, 1);
if (ret)
return ret;

INIT_DELAYED_WORK(&bdev->work, gpio_keys_polled_poll);

pdata = bdev->pdata;
if (pdata->enable)
pdata->enable(bdev->dev);

gpio_keys_polled_queue_work(bdev);

return ret;
}

The above function is used to enable the event framework for the kernel. The event framework is used to provide an interface for the kernel and the kernel modules to communicate with each other.</s>




NEXT




<s> static void msdc_ops_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
{
struct msdc_host *host = mmc_priv(mmc);
void __iomem *base = host->base;
u32 ddr = 0;

#ifdef MT6575_SD_DEBUG
static char *vdd[] = {
"1.50v", "1.55v", "1.60v", "1.65v", "1.70v", "1.80v", "1.90v",
"2.00v", "2.10v", "2.20v", "2.30v", "2.40v", "2.50v", "2.60v",
"2.70v", "2.80v", "2.90v", "3.00v", "3.10v", "3.20v", "3.30v",
"3.40v", "3.50v", "3.60v"
};
static char *power_mode[] = {
"OFF", "UP", "ON"
};
static char *bus_mode[] = {
"UNKNOWN", "OPENDRAIN", "PUSHPULL"
};
static char *timing[] = {
"LEGACY", "MMC_HS", "SD_HS"
};

printk("SET_IOS: CLK(%dkHz), BUS(%s), BW(%u), PWR(%s), VDD(%s), TIMING(%s)",
ios->clock / 1000, bus_mode[ios->bus_mode],
(ios->bus_width == MMC_BUS_WIDTH_4) ? 4 : 1,
power_mode[ios->power_mode], vdd[ios->vdd], timing[ios->timing]);
#endif

msdc_set_buswidth(host, ios->bus_width);

/* Power control ??? */
switch (ios->power_mode) {
case MMC_POWER_OFF:
case MMC_POWER_UP:
// msdc_set_power_mode(host, ios->power_mode); /* --- by chhung */
break;
case MMC_POWER_ON:
host->power_mode = MMC_POWER_ON;
break;
default:
break;
}

/* Clock control */
if (host->mclk != ios->clock) {
if (ios->clock > 25000000) {
//if (!(host->hw->flags & MSDC_REMOVABLE)) {
INIT_MSG("SD data latch edge<%d>", MSDC_SMPL_FALLING);
sdr_set_field(MSDC_IOCON, MSDC_IOCON_RSPL,
MSDC_SMPL_FALLING);
sdr_set_field(MSDC_IOCON, MSDC_IOCON_DSPL,
MSDC_SMPL_FALLING);
//} /* for tuning debug */
} else { /* default value */
sdr_write32(MSDC_IOCON,      0x00000000);
// sdr_write32(MSDC_DAT_RDDLY0, 0x00000000);
sdr_write32(MSDC_DAT_RDDLY0, 0x10101010);		// for MT7620 E2 and afterward
sdr_write32(MSDC_DAT_RDDLY1, 0x00000000);
// sdr_write32(MSDC_PAD_TUNE,   0x00000000);
sdr_write32(MSDC_PAD_TUNE,   0x84101010);		// for MT7620 E2 and afterward
}
msdc_set_mclk(host, ddr, ios->clock);
}
}

The above function is used to set or update MSDC_IOS structure.

Here is msdc_core.c, msdc_ops_set_ios() function:

static void msdc_ops_set_ios(struct




NEXT




<s> static void rtl838x_vlan_set_tagged(u32 vlan, struct rtl838x_vlan_info *info)
{
u32 v;
/* Access VLAN table (0) via register 0 */
struct table_reg *r = rtl_table_get(RTL8380_TBL_0, 0);

sw_w32(info->tagged_ports, rtl_table_data(r, 0));

v = info->profile_id;
v |= info->hash_mc_fid ? 0x8 : 0;
v |= info->hash_uc_fid ? 0x10 : 0;
v |= ((u32)info->fid) << 5;
sw_w32(v, rtl_table_data(r, 1));

rtl_table_write(r, vlan);
rtl_table_release(r);
}

The above function is used to set vlan tagged mode. If the function is called with profile_id not set, the whole vlan data is cleared by calling the below "clear_vlan_data" function.

static inline void clear_vlan_




NEXT




<s> rtk_api_ret_t rtk_ptp_tpid_get(rtk_ptp_tpid_t *pOuterId, rtk_ptp_tpid_t *pInnerId)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_getAsicEavTpid(pOuterId, pInnerId)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get outer and inner TPID, such as PTP header. This function is mainly used to enable MPLS in PTP protocol. Refer to the example:
-
- rt_ptp_tpid_t outer_tp




NEXT




<s> static int ip17xx_get_pvid(struct switch_dev *dev, int port, int *val)
{
struct ip17xx_state *state = get_state(dev);

*val = state->ports[port].pvid;
return 0;
}

The above function is used to access the PVID register of the 17xx switch

static inline int ip17xx_set_pvid(struct switch_dev *dev, int port,
int pvid)
{
if (pvid <




NEXT




<s> unsigned int swab32(unsigned int data)
{
unsigned int res = 0;

res = (data & 0x000000ff) << 24 |
(data & 0x0000ff00) << 8  |
(data & 0x00ff0000) >> 8  |
(data & 0xff000000) >> 24;

return res;
}

The above function is used to swap the endianness of a 32 bit word before it is written.

What I have observed is strange that even though I put this function in a struct and create a pointer, the swapped value gets stored in wrong order.




NEXT




<s> static void rtl8366s_switch_cleanup(struct rtl8366_smi *smi)
{
unregister_switch(&smi->sw_dev);
}

The above function is used to clean up the switch device before
the driver exits. One such occasion during exit is when the
userspace program running on top of it decides to shutdown the
switch. That works well.
The problem with the function above is when




NEXT




<s> void uart_init(void)
{
/* Reset UART1 */
reset_block(SYS_CTRL_RST_UART1, 1);
udelay(100);
reset_block(SYS_CTRL_RST_UART1, 0);
udelay(100);

/* Setup pin mux'ing for UART1 */
pinmux_set(PINMUX_BANK_MFA, 30, PINMUX_UARTA_SIN);
pinmux_set(PINMUX_BANK_MFA, 31, PINMUX_UARTA_SOUT);
}

The above function is used to initialize the PIC controller for UART.

#endif


The above #endif line is a comment that tells the compiler to skip the
previous uart_init() function if it is a duplicate, i.e., if




NEXT




<s> int ofb_aes_encrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int enc_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = enc_bytes = walk.nbytes) && (walk.nbytes >= AES_BLOCK_SIZE)) {
enc_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_ofb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, enc_bytes, CRYPTO_DIR_ENCRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

/* to handle remaining bytes < AES_BLOCK_SIZE */
if (walk.nbytes) {
ifx_deu_aes_ofb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, walk.nbytes, CRYPTO_DIR_ENCRYPT, 0);
err = skcipher_walk_done(&walk, 0);
}

return err;
}

The above function is used to decrypt data that is sent from client to EAPOL-SK (i.e. encrypted data). The function first copies the encrypted data to memory,
where it is further used to encrypt the data. If client sends a




NEXT




<s> ret_t rtl8367c_setAsicCputagPriorityRemapping(rtk_uint32 srcPri, rtk_uint32 newPri)
{
if((srcPri > RTL8367C_PRIMAX) || (newPri > RTL8367C_PRIMAX))
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBits(RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_REG(srcPri), RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_MASK(srcPri), newPri);
}

The above function is used to modify the incoming traffic priority tagging used in RTL8367C_ASIC_CPU_TAG_PRI_IN_CPU.
If the function failed, newPri becomes srcPri, otherwise, newPri becomes




NEXT




<s> static int bcm6348_emac_tx_reclaim(struct net_device *ndev, int force)
{
struct bcm6348_emac *emac = netdev_priv(ndev);
struct platform_device *pdev = emac->pdev;
struct device *dev = &pdev->dev;
int released = 0;

while (emac->tx_desc_count < emac->tx_ring_size) {
struct bcm6348_iudma_desc *desc;
struct sk_buff *skb;

/* We run in a bh and fight against start_xmit, which
* is called with bh disabled */
spin_lock(&emac->tx_lock);

desc = &emac->tx_desc_cpu[emac->tx_dirty_desc];

if (!force && (desc->len_stat & DMADESC_OWNER_MASK)) {
spin_unlock(&emac->tx_lock);
break;
}

/* ensure other field of the descriptor were not read
* before we checked ownership */
rmb();

skb = emac->tx_skb[emac->tx_dirty_desc];
emac->tx_skb[emac->tx_dirty_desc] = NULL;
dma_unmap_single(dev, desc->address, skb->len, DMA_TO_DEVICE);

emac->tx_dirty_desc++;
if (emac->tx_dirty_desc == emac->tx_ring_size)
emac->tx_dirty_desc = 0;
emac->tx_desc_count++;

spin_unlock(&emac->tx_lock);

if (desc->len_stat & DMADESC_UNDER_MASK)
ndev->stats.tx_errors++;

dev_kfree_skb(skb);
released++;
}

if (netif_queue_stopped(ndev) && released)
netif_wake_queue(ndev);

return released;
}

The above function is used to reclaim a packet from an emac device. As
described, the function is called within the interrupt handler and can
also be called with the force flag set in order to reclaim
non-owned descr.</s>




NEXT




<s> static inline uint16_t get_header_len(const struct tffs_entry_header *header)
{
if (swap_bytes)
return ntohs(header->len);

return header->len;
}

The above function is used to convert and return the length of any header. As mentioned earlier, the FAT file system stores the data in little-endian format which is known as Swap byte ordering. I do not know if this makes your life simpler so I haven’




NEXT




<s> rtk_api_ret_t rtk_l2_ipMcastAddrLookup_get(rtk_l2_ipmc_lookup_type_t *pType)
{
rtk_api_ret_t       retVal;
rtk_uint32          enabled, vid_lookup;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pType)
return RT_ERR_NULL_POINTER;

if((retVal = rtl8367c_getAsicLutIpMulticastLookup(&enabled)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicLutIpMulticastVidLookup(&vid_lookup))!=RT_ERR_OK)
return retVal;

if(enabled == ENABLED)
{
if(vid_lookup == ENABLED)
*pType = LOOKUP_IP_VID;
else
*pType = LOOKUP_IP;
}
else
*pType = LOOKUP_MAC;

return RT_ERR_OK;
}

The above function is used to check the L2 LUT ip address lookup function is enabled,and determine the LUT ip address lookup method.</s>




NEXT




<s> rtk_api_ret_t rtk_svlan_dmac_vidsel_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicSvlanDmacCvidSel(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the MAC based VID selection of SVLAN

#include</s>




NEXT




<s> static int rtl8367_mii_read(struct mii_bus *bus, int addr, int reg)
{
struct rtl8366_smi *smi = bus->priv;
u32 val = 0;
int err;

err = rtl8367_read_phy_reg(smi, addr, reg, &val);
if (err)
return 0xffff;

return val;
}

The above function is used to provide an abstraction of the read phy register operation for the RTL8367 ethernet switch.

int rtl8367_mii_detect(struct mii_bus *bus, int unused




NEXT




<s> void mt7620_print_link_state(struct fe_priv *priv, int port, int link,
int speed, int duplex)
{
if (link)
netdev_info(priv->netdev, "port %d link up (%sMbps/%s duplex)\n",
port, fe_speed_str(speed),
(duplex) ? "Full" : "Half");
else
netdev_info(priv->netdev, "port %d link down\n", port);
}

The above function is used to print various link state status. For example
for port 1 and if the link is up and 100 Mbps full duplex, then the following
message will printed to syslog

 port 1 link up (1




NEXT




<s> ar8327_read_port_eee_status(struct ar8xxx_priv *priv, int port)
{
int phy;
u16 t;

if (port >= priv->dev.ports)
return 0;

if (port == 0 || port == 6)
return 0;

phy = port - 1;

/* EEE Ability Auto-negotiation Result */
t = ar8xxx_phy_mmd_read(priv, phy, 0x7, 0x8000);

return mmd_eee_adv_to_ethtool_adv_t(t);
}

The above function is used to get EEE abilities (both up/downstream) status of a given port. If you would like to play with EEE feature for example (disabling EEE) you can use our eee_off.sh as well as eee




NEXT




<s> inline u32 rtl_table_data_r(struct table_reg *r, int i)
{
return sw_r32(rtl_table_data(r, i));
}

The above function is used to access table data in hardware for various HW
accelerated algorithms and APIs. Currently we need to do the access from
software. The access happens every cycle (6-8 times per clock cycle) for RGBA





NEXT




<s> static int rtl8218d_phy_probe(struct phy_device *phydev)
{
struct device *dev = &phydev->mdio.dev;
int addr = phydev->mdio.addr;

pr_debug("%s: id: %d\n", __func__, addr);
/* All base addresses of the PHYs start at multiples of 8 */
devm_phy_package_join(dev, phydev, addr & (~7),
sizeof(struct rtl83xx_shared_private));

/* All base addresses of the PHYs start at multiples of 8 */
if (!(addr % 8)) {
struct rtl83xx_shared_private *shared = phydev->shared->priv;
shared->name = "RTL8218D";
/* Configuration must be done while patching still possible */
/* TODO:		return configure_rtl8218d(phydev); */
}

return 0;
}

The above function is used to probe the PHY devices at runtime if there is any PHY attached on the system. If the MDIO ID(address) returned by the ETH_PHY_ID_MASK macro is of the form N*8 it will create the new




NEXT




<s> static u64 rtl838x_read_cam(int idx, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL8380_TBL_L2, 1); /* Access L2 Table 1 */

rtl_table_read(q, idx);
for (int i = 0; i < 3; i++)
r[i] = sw_r32(rtl_table_data(q, i));

rtl_table_release(q);

rtl838x_fill_l2_entry(r, e);
if (!e->valid)
return 0;

pr_debug("Found in CAM: R1 %x R2 %x R3 %x\n", r[0], r[1], r[2]);

/* Return MAC with concatenated VID ac concatenated ID */
return (((u64) r[1]) << 32) | r[2];
}

The above function is used to scan and find the corresponding mac address, vid of the ac and id of the l2 entry by calling the sw_read_cam function.

Note it is difficult to find out ac’s and id’s value by doing a raw




NEXT




<s> static void rtl838x_pie_rule_del(struct rtl838x_switch_priv *priv, int index_from, int index_to)
{
int block_from = index_from / PIE_BLOCK_SIZE;
int block_to = index_to / PIE_BLOCK_SIZE;
u32 v = (index_from << 1)| (index_to << 12 ) | BIT(0);
u32 block_state;

pr_debug("%s: from %d to %d\n", __func__, index_from, index_to);
mutex_lock(&priv->reg_mutex);

/* Remember currently active blocks */
block_state = sw_r32(RTL838X_ACL_BLK_LOOKUP_CTRL);

/* Make sure rule-lookup is disabled in the relevant blocks */
for (int block = block_from; block <= block_to; block++) {
if (block_state & BIT(block))
sw_w32(block_state & (~BIT(block)), RTL838X_ACL_BLK_LOOKUP_CTRL);
}

/* Write from-to and execute bit into control register */
sw_w32(v, RTL838X_ACL_CLR_CTRL);

/* Wait until command has completed */
do {
} while (sw_r32(RTL838X_ACL_CLR_CTRL) & BIT(0));

/* Re-enable rule lookup */
for (int block = block_from; block <= block_to; block++) {
if (!(block_state & BIT(block)))
sw_w32(block_state | BIT(block), RTL838X_ACL_BLK_LOOKUP_CTRL);
}

mutex_unlock(&priv->reg_mutex);
}

The above function is used to delete PIE rule entries on the switch. Given two indexes index_from and index_to, the function will first disable the PIE table lookups for the associated blocks, and then write the given indexes to the ACL CLR




NEXT




<s> void rtl9300_sds_field_w(int sds, u32 page, u32 reg, int end_bit, int start_bit, u32 v)
{
int l = end_bit - start_bit + 1;
u32 data = v;

if (l < 32) {
u32 mask = BIT(l) - 1;

data = rtl930x_read_sds_phy(sds, page, reg);
data &= ~(mask << start_bit);
data |= (v & mask) << start_bit;
}

rtl930x_write_sds_phy(sds, page, reg, data);
}

The above function is used to access the register field.

But I think such functions make the source code harder to read. I’d personally prefer
something like this:

bool rtl9300_sds_write_field(int sds




NEXT




<s> static int __init ag71xx_module_init(void)
{
int ret;

ret = ag71xx_debugfs_root_init();
if (ret)
goto err_out;

ret = platform_driver_register(&ag71xx_driver);
if (ret)
goto err_debugfs_exit;

return 0;

err_debugfs_exit:
ag71xx_debugfs_root_exit();
err_out:
return ret;
}

The above function is used to initialize the Ag71xx subsystem. The debugfs_root is used in the driver development to debug the device drivers. In this case, the driver will create this virtual file and write to the virtual file. The following screenshot is sample




NEXT




<s> int ctr_rfc3686_aes_decrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
unsigned int nbytes, dec_bytes;
int err;
u8 rfc3686_iv[16];

err = skcipher_walk_virt(&walk, req, false);
nbytes = walk.nbytes;

/* set up counter block */
memcpy(rfc3686_iv, ctx->nonce, CTR_RFC3686_NONCE_SIZE);
memcpy(rfc3686_iv + CTR_RFC3686_NONCE_SIZE, walk.iv, CTR_RFC3686_IV_SIZE);

/* initialize counter portion of counter block */
*(__be32 *)(rfc3686_iv + CTR_RFC3686_NONCE_SIZE + CTR_RFC3686_IV_SIZE) =
cpu_to_be32(1);

while ((nbytes = dec_bytes = walk.nbytes) && (walk.nbytes >= AES_BLOCK_SIZE)) {
dec_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_ctr(ctx, walk.dst.virt.addr, walk.src.virt.addr,
rfc3686_iv, dec_bytes, CRYPTO_DIR_DECRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

/* to handle remaining bytes < AES_BLOCK_SIZE */
if (walk.nbytes) {
ifx_deu_aes_ctr(ctx, walk.dst.virt.addr, walk.src.virt.addr,
rfc3686_iv, walk.nbytes, CRYPTO_DIR_DECRYPT, 0);
err = skcipher_walk_done(&walk, 0);
}

return err;
}

The above function is used to perform AES decryption on counter mode. The
key can be reused as well. I have been looking for a way to decrypt only the
decryption IV and the key from the cipher text which is encrypted using AES




NEXT




<s> rtk_api_ret_t rtk_l2_ipMcastForwardRouterPort_set(rtk_enable_t enabled)
{
rtk_api_ret_t       retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (enabled >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if((retVal = rtl8367c_setAsicLutIpmcFwdRouterPort(enabled)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set IPMC Forward Router Port.


rtk_enable_t rtk_l2_ipMcastForwardRouterPort_get(void)
{
rtk_api_ret_t       retVal;




NEXT




<s> ar8xxx_mib_fetch_port_stat(struct ar8xxx_priv *priv, int port, bool flush)
{
unsigned int base;
u64 *mib_stats;
int i;

WARN_ON(port >= priv->dev.ports);

lockdep_assert_held(&priv->mib_lock);

base = priv->chip->reg_port_stats_start +
priv->chip->reg_port_stats_length * port;

mib_stats = &priv->mib_stats[port * priv->chip->num_mibs];
for (i = 0; i < priv->chip->num_mibs; i++) {
const struct ar8xxx_mib_desc *mib;
u64 t;

mib = &priv->chip->mib_decs[i];
if (mib->type > priv->mib_type)
continue;
t = ar8xxx_read(priv, base + mib->offset);
if (mib->size == 2) {
u64 hi;

hi = ar8xxx_read(priv, base + mib->offset + 4);
t |= hi << 32;
}

if (flush)
mib_stats[i] = 0;
else
mib_stats[i] += t;
cond_resched();
}
}

The above function is used to get stats from a specific port of an AR-8xxx switch. The input parameters of this function are as follows:
struct ar8xxx_priv *priv
The private structure pointer to the driver's data structures for the specific port.




NEXT




<s> static unsigned esw_get_vmsc(struct rt305x_esw *esw, unsigned vlan)
{
unsigned s, val;

s = RT305X_ESW_VMSC_MSC_S * (vlan % 4);
val = esw_r32(esw, RT305X_ESW_REG_VMSC(vlan / 4));
val = (val >> s) & RT305X_ESW_VMSC_MSC_M;

return val;
}

The above function is used to obtain the virtual mac based on vlan tag or group tag.

There are some vlan numbers that are not considered virtual and are not used. They are as follows: 0,0x0001, 0x0




NEXT




<s> ret_t rtl8367c_getAsicCputagTrapPort(rtk_uint32 *pPort)
{
ret_t retVal;
rtk_uint32 tmpPort;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TRAP_PORT_MASK, &tmpPort);
if(retVal != RT_ERR_OK)
return retVal;
*pPort = tmpPort;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TRAP_PORT_EXT_MASK, &tmpPort);
if(retVal != RT_ERR_OK)
return retVal;
*pPort |= (tmpPort & 1) << 3;

return RT_ERR_OK;
}

The above function is used to get the port trap into CPU port which has been assigned by SW.

On the other side, when we want to do some operation on that port, we need to enable trap feature by below API.

This API has 3 main




NEXT




<s> static void _rtl8367c_Vlan4kStUser2Smi(rtl8367c_user_vlan4kentry *pUserVlan4kEntry, rtk_uint16 *pSmiVlan4kEntry)
{
pSmiVlan4kEntry[0] |= (pUserVlan4kEntry->mbr & 0x00FF);
pSmiVlan4kEntry[0] |= (pUserVlan4kEntry->untag & 0x00FF) << 8;

pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->fid_msti & 0x000F);
pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->vbpen & 0x0001) << 4;
pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->vbpri & 0x0007) << 5;
pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->envlanpol & 0x0001) << 8;
pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->meteridx & 0x001F) << 9;
pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->ivl_svl & 0x0001) << 14;

pSmiVlan4kEntry[2] |= ((pUserVlan4kEntry->mbr & 0x0700) >> 8);
pSmiVlan4kEntry[2] |= ((pUserVlan4kEntry->untag & 0x0700) >> 8) << 3;
pSmiVlan4kEntry[2] |= ((pUserVlan4kEntry->meteridx & 0x0020) >> 5) << 6;
}

The above function is used to copy the VLAN4K user entry structure to VLAN4K SMI entry structure. For the VLAN4K user entry and VLAN4K SMI entry definitions, please refer to rtl8367c.h /




NEXT




<s> static int clk_mt7981_apmixed_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;

clk_data = mtk_alloc_clk_data(ARRAY_SIZE(plls));
if (!clk_data)
return -ENOMEM;

mtk_clk_register_plls(node, plls, ARRAY_SIZE(plls), clk_data);

clk_prepare_enable(clk_data->clks[CLK_APMIXED_ARMPLL]);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_apmixed_data;
}
return r;

free_apmixed_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to register device tree node of AP mixed clk source.
In the above function, we create a structure to store all ap mixed clks information.

Then, we call mtk_clk_register_plls to register all AP mixed cl




NEXT




<s> ret_t rtl8367c_setAsicI2CGpioPinGroup(rtk_uint32 pinGroup_ID)
{
rtk_uint32 regData;
ret_t retVal;

if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, &regData)) != RT_ERR_OK)
return retVal;
if( pinGroup_ID==0 )
{
regData &= 0x0FFF;
regData |= 0x5000;

if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, regData)) != RT_ERR_OK)
return retVal;
}

else if( pinGroup_ID==1 )
{
regData &= 0x0FFF;
regData |= 0xA000;

if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, regData)) != RT_ERR_OK)
return retVal;
}

else if( pinGroup_ID==2 )
{
regData &= 0x0FFF;
regData |= 0xF000;

if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, regData)) != RT_ERR_OK)
return retVal;
}
else
return RT_ERR_INPUT;

return RT_ERR_OK ;

}

The above function is used to set the GPIO as I2C group in ASIC, as we found there are three I2C Pins, which we use this function in order to make them work for us .</s>




NEXT




<s> ar8xxx_check_link_states(struct ar8xxx_priv *priv)
{
bool link_new, changed = false;
u32 status;
int i;

mutex_lock(&priv->reg_mutex);

for (i = 0; i < priv->dev.ports; i++) {
status = priv->chip->read_port_status(priv, i);
link_new = !!(status & AR8216_PORT_STATUS_LINK_UP);
if (link_new == priv->link_up[i])
continue;

priv->link_up[i] = link_new;
changed = true;
/* flush ARL entries for this port if it went down*/
if (!link_new)
priv->chip->atu_flush_port(priv, i);
dev_info(&priv->phy->mdio.dev, "Port %d is %s\n",
i, link_new ? "up" : "down");
}

mutex_unlock(&priv->reg_mutex);

return changed;
}

The above function is used to check the link status of each port and it
can be called at any appropriate time. Ports that are down need to be
flushed.</s>




NEXT




<s> static void rtl8367b_shutdown(struct platform_device *pdev)
{
struct rtl8366_smi *smi = platform_get_drvdata(pdev);

if (smi)
rtl8367b_reset_chip(smi);
}

The above function is used to do the reset of 8367B switch core after the chip shuts down.

This function shall disable all clocks to the switch core and all PHYs, and then reset the EEPROMs in the PHY




NEXT




<s> ret_t rtl8367c_setAsicVlanProtocolBasedGroupData(rtk_uint32 index, rtl8367c_protocolgdatacfg *pPbCfg)
{
rtk_uint32  frameType;
rtk_uint32  etherType;
ret_t   retVal;

/* Error Checking */
if(index > RTL8367C_PROTOVLAN_GIDX_MAX)
return RT_ERR_VLAN_PROTO_AND_PORT;

if(pPbCfg->frameType >= PPVLAN_FRAME_TYPE_END )
return RT_ERR_INPUT;

frameType = pPbCfg->frameType;
etherType = pPbCfg->etherType;

/* Frame type */
retVal = rtl8367c_setAsicRegBits(RTL8367C_VLAN_PPB_FRAMETYPE_REG(index), RTL8367C_VLAN_PPB_FRAMETYPE_MASK, frameType);
if(retVal != RT_ERR_OK)
return retVal;

/* Ether type */
retVal = rtl8367c_setAsicReg(RTL8367C_VLAN_PPB_ETHERTYPR_REG(index), etherType);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set Vlan Protocol based port grouping data using its index on device.

```
ret_t rtl8367c_setAsicVlanProtocolBaseDataIndexPort(rtk_uint32 index,




NEXT




<s> int timer_init (void)
{
int32_t val;

/* Start the counter ticking up */
writel(TIMER_LOAD_VAL, CONFIG_SYS_TIMERBASE + TIMER_LOAD);	/* reload value on overflow*/

val = (CONFIG_TIMER_PRESCALE << TIMER_PRESCALE_SHIFT) |
(TIMER_MODE_PERIODIC << TIMER_MODE_SHIFT) |
(TIMER_ENABLE << TIMER_ENABLE_SHIFT);		/* mask to enable timer*/
writel(val, CONFIG_SYS_TIMERBASE + TIMER_CTRL);	/* start timer */

/* reset time */
gd->arch.lastinc = READ_TIMER;	/* capture current incrementer value */
gd->arch.tbl = 0;		/* start "advancing" time stamp */

return(0);
}

The above function is used to start the timer. Let us understand the process by working through the instructions.

The first instruction is writel(TIMER_LOAD_VAL, CONFIG_SYS_TIMERBASE + TIMER_LOAD);/* reload value on




NEXT




<s> int BN_rshift(BIGNUM *r, BIGNUM *a, int n)
{
int i,j,nw,lb,rb;
BN_ULONG *t,*f;
BN_ULONG l,tmp;

nw=n/BN_BITS2;
rb=n%BN_BITS2;
lb=BN_BITS2-rb;
if (nw > a->top || a->top == 0)
{
BN_zero(r);
return(1);
}
if (r != a)
{
r->neg=a->neg;
if (bn_wexpand(r,a->top-nw+1) == NULL) return(0);
}

f= &(a->d[nw]);
t=r->d;
j=a->top-nw;
r->top=j;

if (rb == 0)
{
for (i=j+1; i > 0; i--)
*(t++)= *(f++);
}
else
{
l= *(f++);
for (i=1; i<j; i++)
{
tmp =(l>>rb)&BN_MASK2;
l= *(f++);
*(t++) =(tmp|(l<<lb))&BN_MASK2;
}
*(t++) =(l>>rb)&BN_MASK2;
}
*t=0;
bn_fix_top(r);
return(1);
}

The above function is used to
change the bignum base representation
without considering the negative/positive number.
The above function should be called before
calling the bn_mod_{2,4,16}(r,a,b)
that




NEXT




<s> ret_t rtl8367c_getAsicStormFilterMulticastEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_STORM_MCAST_REG, port, pEnabled);
}

The above function is used to determine whether the Multicast Storm Filter control register is enabled
The Multicast Storm Filter mode means that all non-BPDU multicast packets will be filtered in the storm mode, except that non-broadcast multicast packets




NEXT




<s> static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to push outgoing OAM cells (if any) from the MAC to the switch.
When ifx_push_oam() is not defined, dummy data is pushed out
#endif

extern int  ifx_start(




NEXT




<s> wpas_ucode_update_interfaces(void)
{
uc_value_t *ifs = ucv_object_new(vm);
struct wpa_supplicant *wpa_s;
int i;

for (wpa_s = wpa_global->ifaces; wpa_s; wpa_s = wpa_s->next)
ucv_object_add(ifs, wpa_s->ifname, ucv_get(wpas_ucode_iface_get_uval(wpa_s)));

ucv_object_add(ucv_prototype_get(global), "interfaces", ucv_get(ifs));
ucv_gc(vm);
}

The above function is used to create interface list in user space

and it calls the below function which updates iface object.It calls the

function iface_update which inturn calls the function iface_add_remove_

which adds or remove network




NEXT




<s> ar8327_sw_get_ports(struct switch_dev *dev, struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
u8 ports = priv->vlan_table[val->port_vlan];
int i;

val->len = 0;
for (i = 0; i < dev->ports; i++) {
struct switch_port *p;

if (!(ports & (1 << i)))
continue;

p = &val->value.ports[val->len++];
p->id = i;
if ((priv->vlan_tagged & (1 << i)) || (priv->pvid[i] != val->port_vlan))
p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
else
p->flags = 0;
}
return 0;
}

The above function is used to get port vlan values.
In Aruba WLC software, this switch_port port_vlan field is used to get/set port vlan which gets added to the tag frame coming for the port.

The main problem with




NEXT




<s> static void ar8216_get_arl_entry(struct ar8xxx_priv *priv,
struct arl_entry *a, u32 *status, enum arl_op op)
{
struct mii_bus *bus = priv->mii_bus;
u16 r2, page;
u16 r1_func0, r1_func1, r1_func2;
u32 t, val0, val1, val2;

split_addr(AR8216_REG_ATU_FUNC0, &r1_func0, &r2, &page);
r2 |= 0x10;

r1_func1 = (AR8216_REG_ATU_FUNC1 >> 1) & 0x1e;
r1_func2 = (AR8216_REG_ATU_FUNC2 >> 1) & 0x1e;

switch (op) {
case AR8XXX_ARL_INITIALIZE:
/* all ATU registers are on the same page
* therefore set page only once
*/
bus->write(bus, 0x18, 0, page);
wait_for_page_switch();

ar8216_wait_atu_ready(priv, r2, r1_func0);

ar8xxx_mii_write32(priv, r2, r1_func0, AR8216_ATU_OP_GET_NEXT);
ar8xxx_mii_write32(priv, r2, r1_func1, 0);
ar8xxx_mii_write32(priv, r2, r1_func2, 0);
break;
case AR8XXX_ARL_GET_NEXT:
t = ar8xxx_mii_read32(priv, r2, r1_func0);
t |= AR8216_ATU_ACTIVE;
ar8xxx_mii_write32(priv, r2, r1_func0, t);
ar8216_wait_atu_ready(priv, r2, r1_func0);

val0 = ar8xxx_mii_read32(priv, r2, r1_func0);
val1 = ar8xxx_mii_read32(priv, r2, r1_func1);
val2 = ar8xxx_mii_read32(priv, r2, r1_func2);

*status = (val2 & AR8216_ATU_STATUS) >> AR8216_ATU_STATUS_S;
if (!*status)
break;

a->portmap = (val2 & AR8216_ATU_PORTS) >> AR8216_ATU_PORTS_S;
a->mac[0] = (val0 & AR8216_ATU_ADDR5) >> AR8216_ATU_ADDR5_S;
a->mac[1] = (val0 & AR8216_ATU_ADDR4) >> AR8216_ATU_ADDR4_S;
a->mac[2] = (val1 & AR8216_ATU_ADDR3) >> AR8216_ATU_ADDR3_S;
a->mac[3] = (val1 & AR8216_ATU_ADDR2) >> AR8216_ATU_ADDR2_S;
a->mac[4] = (val1 & AR8216_ATU_ADDR1) >> AR8216_ATU_ADDR1_S;
a->mac[5] = (val1 & AR8216_ATU_ADDR0) >> AR8216_ATU_ADDR0_S;
break;
}
}

The above function is used to read the ARL entries from the data structure
used by all ARL tables and stores it in the function parameter a (arl_entry)
and status.

1. Split address: In order to access all three Atu registers




NEXT




<s> rtk_api_ret_t rtk_svlan_sp2c_get(rtk_vlan_t svid, rtk_port_t dst_port, rtk_vlan_t *pCvid)
{
rtk_api_ret_t retVal;
rtk_uint32 i, svidx;
rtl8367c_svlan_memconf_t svlanMemConf;
rtl8367c_svlan_s2c_t svlanSP2CConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pCvid)
return RT_ERR_NULL_POINTER;

if (svid > RTL8367C_VIDMAX)
return RT_ERR_SVLAN_VID;

/* Check port Valid */
RTK_CHK_PORT_VALID(dst_port);
dst_port = rtk_switch_port_L2P_get(dst_port);

svidx = 0xFFFF;

for (i = 0; i < RTL8367C_SVIDXNO; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;

if (svid == svlanMemConf.vs_svid)
{
svidx = i;
break;
}
}

if (0xFFFF == svidx)
return RT_ERR_SVLAN_ENTRY_NOT_FOUND;

for (i = 0; i <= RTL8367C_SP2CMAX; i++)
{
if ((retVal = rtl8367c_getAsicSvlanSP2CConf(i, &svlanSP2CConf)) != RT_ERR_OK)
return retVal;

if ( (svlanSP2CConf.svidx == svidx) && (svlanSP2CConf.dstport == dst_port) && (svlanSP2CConf.valid == 1) )
{
*pCvid = svlanSP2CConf.vid;
return RT_ERR_OK;
}
}

return RT_ERR_OUT_OF_RANGE;
}

The above function is used to retrieve the SVLAN SP2C entry based on the SVID, port and CVID. The CVID is the same as the SVID.

rtk_api_ret_t rtk_svlan_sp2c_




NEXT




<s> static int b53_mmap_write16(struct b53_device *dev, u8 page, u8 reg,
u16 value)
{
u8 __iomem *regs = dev->priv;

if (WARN_ON(reg % 2))
return -EINVAL;

if (dev->pdata && dev->pdata->big_endian)
writew_be(value, regs + (page << 8) + reg);
else
writew(value, regs + (page << 8) + reg);

return 0;
}

The above function is used to write 16 bit values to a 53xx device.</s>




NEXT




<s> bbt_set_block_state(u16 block, bool bad)
{
u8 mask = (3 << ((block % 4) * 2));

if (bad)
bmtd.bbt_buf[block / 4] |= mask;
else
bmtd.bbt_buf[block / 4] &= ~mask;

bbt_nand_erase(bmtd.bmt_blk_idx);
write_bmt(bmtd.bmt_blk_idx, bmtd.bbt_buf);
}

The above function is used to mark bad blocks in both the BMT and BBT using bmtd

I see some BBT marking (with bbt_set_block_state()) in bmtd.c. It is used whenever a BMT





NEXT




<s> static unsigned esw_get_vlan_id(struct rt305x_esw *esw, unsigned vlan)
{
unsigned s;
unsigned val;

s = RT305X_ESW_VLANI_VID_S * (vlan % 2);
val = esw_r32(esw, RT305X_ESW_REG_VLANI(vlan / 2));
val = (val >> s) & RT305X_ESW_VLANI_VID_M;

return val;
}

The above function is used to access a field RT305X_ESW_VLANI_VID_S,
which refers to the 3.0 AHB-LITE and AMBA4-AHB reference manuals
under "RT3




NEXT




<s> rtk_api_ret_t rtk_l2_mcastAddr_next_get(rtk_uint32 *pAddress, rtk_l2_mcastAddr_t *pMcastAddr)
{
rtk_api_ret_t   retVal;
rtl8367c_luttb  l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Error Checking */
if ((pAddress == NULL) || (pMcastAddr == NULL))
return RT_ERR_INPUT;

if(*pAddress > RTK_MAX_LUT_ADDR_ID )
return RT_ERR_L2_L2UNI_PARAM;

memset(&l2Table, 0, sizeof(rtl8367c_luttb));
l2Table.address = *pAddress;

if ((retVal = rtl8367c_getAsicL2LookupTb(LUTREADMETHOD_NEXT_L2MC, &l2Table)) != RT_ERR_OK)
return retVal;

if(l2Table.address < *pAddress)
return RT_ERR_L2_ENTRY_NOTFOUND;

memcpy(pMcastAddr->mac.octet, l2Table.mac.octet, ETHER_ADDR_LEN);
pMcastAddr->ivl     = l2Table.ivl_svl;

if(pMcastAddr->ivl)
pMcastAddr->vid = l2Table.cvid_fid;
else
pMcastAddr->fid = l2Table.cvid_fid;

pMcastAddr->priority    = l2Table.lut_pri;
pMcastAddr->fwd_pri_en  = l2Table.fwd_en;
pMcastAddr->igmp_asic   = l2Table.igmp_asic;
pMcastAddr->igmp_index  = l2Table.igmpidx;
pMcastAddr->address     = l2Table.address;

/* Get Logical port mask */
if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pMcastAddr->portmask)) != RT_ERR_OK)
return retVal;

*pAddress = l2Table.address;

return RT_ERR_OK;
}

The above function is used to return the next MC L2MC entry.

The following code describes how to use rtk_l2_mcastAddr_next_get
{

char macAddr[32];
rtk_l2_m




NEXT




<s> struct menu *menu_get_parent_menu(struct menu *menu)
{
enum prop_type type;

for (; menu != &rootmenu; menu = menu->parent) {
type = menu->prompt ? menu->prompt->type : 0;
if (type == P_MENU)
break;
}
return menu;
}

The above function is used to get the parent menu of a particular menu. This happens behind the scenes by the menu system which calls it internally. I looked at the source for a long time and couldn't figure out what exactly the problem lies.

I noticed that




NEXT




<s> void AT91F_DataflashPrintInfo(void)
{
int i;
for (i = 0; i < CFG_MAX_DATAFLASH_BANKS; i++) {
if (dataflash_info[i].id != 0) {
printf ("DF:AT45DB");
switch (dataflash_info[i].id) {
case AT45DB161:
printf ("161");
break;

case AT45DB321:
printf ("321");
break;

case AT45DB642:
printf ("642");
break;
case AT45DB128:
printf ("128");
break;
}

printf ("\n# PG: %6d\n"
"PG SZ: %6d\n"
"SZ=%8d bytes\n"
"ADDR: %08X\n",
(unsigned int) dataflash_info[i].Device.pages_number,
(unsigned int) dataflash_info[i].Device.pages_size,
(unsigned int) dataflash_info[i].Device.pages_number *
dataflash_info[i].Device.pages_size,
(unsigned int) dataflash_info[i].logical_address);
}
}
}

The above function is used to display information about data flash memory.</s>




NEXT




<s> static INLINE int strincmp(const char *, const char *, int);
#endif
static INLINE int ifx_ptm_version(char *);

/*
*  Init & clean-up functions
*/
static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to see if the ATM Showtime feature is
enabled.

<table><tr><td><b><i><i>is_showtime</i></i></td><td></td><td>On success, a value of




NEXT




<s> rtl_set_vlan(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct rtl_priv *priv = to_rtl(dev);
struct rtl_phyregs port;
int en = val->value.i;
int i;

rtl_set(dev, RTL_REG_EN_TAG_OUT, en && priv->do_cpu);
rtl_set(dev, RTL_REG_EN_TAG_IN, en && priv->do_cpu);
rtl_set(dev, RTL_REG_EN_TAG_CLR, en && priv->do_cpu);
rtl_set(dev, RTL_REG_VLAN_TAG_AWARE, en);
if (en)
rtl_set(dev, RTL_REG_VLAN_FILTER, en);

for (i = 0; i < RTL8306_NUM_PORTS; i++) {
if (i > 3)
rtl_phy_save(dev, val->port_vlan, &port);
rtl_set(dev, RTL_PORT_REG(i, NULL_VID_REPLACE), 1);
rtl_set(dev, RTL_PORT_REG(i, VID_INSERT), (en ? (i == dev->cpu_port ? 0 : 1) : 1));
rtl_set(dev, RTL_PORT_REG(i, TAG_INSERT), (en ? (i == dev->cpu_port ? 2 : 1) : 3));
if (i > 3)
rtl_phy_restore(dev, val->port_vlan, &port);
}
rtl_set(dev, RTL_REG_VLAN_ENABLE, en);

return 0;
}

The above function is used to set VLAN configuration on an RTL8306S chip. As you can see, it does not do anything.

That isn't to say that VLAN support isn't implemented in RTL8306S




NEXT




<s> static void rtl838x_fill_l2_entry(u32 r[], struct rtl838x_l2_entry *e)
{
/* Table contains different entry types, we need to identify the right one:
* Check for MC entries, first
* In contrast to the RTL93xx SoCs, there is no valid bit, use heuristics to
* identify valid entries
*/
e->is_ip_mc = !!(r[0] & BIT(22));
e->is_ipv6_mc = !!(r[0] & BIT(21));
e->type = L2_INVALID;

if (!e->is_ip_mc && !e->is_ipv6_mc) {
e->mac[0] = (r[1] >> 20);
e->mac[1] = (r[1] >> 12);
e->mac[2] = (r[1] >> 4);
e->mac[3] = (r[1] & 0xf) << 4 | (r[2] >> 28);
e->mac[4] = (r[2] >> 20);
e->mac[5] = (r[2] >> 12);

e->rvid = r[2] & 0xfff;
e->vid = r[0] & 0xfff;

/* Is it a unicast entry? check multicast bit */
if (!(e->mac[0] & 1)) {
e->is_static = !!((r[0] >> 19) & 1);
e->port = (r[0] >> 12) & 0x1f;
e->block_da = !!(r[1] & BIT(30));
e->block_sa = !!(r[1] & BIT(31));
e->suspended = !!(r[1] & BIT(29));
e->next_hop = !!(r[1] & BIT(28));
if (e->next_hop) {
pr_debug("Found next hop entry, need to read extra data\n");
e->nh_vlan_target = !!(r[0] & BIT(9));
e->nh_route_id = r[0] & 0x1ff;
e->vid = e->rvid;
}
e->age = (r[0] >> 17) & 0x3;
e->valid = true;

/* A valid entry has one of mutli-cast, aging, sa/da-blocking,
* next-hop or static entry bit set
*/
if (!(r[0] & 0x007c0000) && !(r[1] & 0xd0000000))
e->valid = false;
else
e->type = L2_UNICAST;
} else { /* L2 multicast */
pr_debug("Got L2 MC entry: %08x %08x %08x\n", r[0], r[1], r[2]);
e->valid = true;
e->type = L2_MULTICAST;
e->mc_portmask_index = (r[0] >> 12) & 0x1ff;
}
} else { /* IPv4 and IPv6 multicast */
e->valid = true;
e->mc_portmask_index = (r[0] >> 12) & 0x1ff;
e->mc_gip = (r[1] << 20) | (r[2] >> 12);
e->rvid = r[2] & 0xfff;
}
if (e->is_ip_mc)
e->type = IP4_MULTICAST;
if (e->is_ipv6_mc)
e->type = IP6_MULTICAST;
}

The above function is used to fill in the L2 entries of the FPGA when a
unicast entry arrives at the FPGA. There's a couple of things to note:

It is split into two stages. The first stage checks whether it'




NEXT




<s> static inline void superio_select(int base, int ld)
{
outb(SIO_LDSEL, base);
outb(ld, base + 1);
}

The above function is used to generate the port address which the
SuperIO I/O base and I/O address LDSEL for the PCI-X card. The
variable base and ld have the defined values.
A port address for SIO_LDSEL




NEXT




<s> static bool aw9523_volatile_reg(struct device *dev, unsigned int reg)
{
return aw9523_is_reg_hole(reg) ||
reg == AW9523_REG_IN_STATE(0) ||
reg == AW9523_REG_IN_STATE(AW9523_PINS_PER_PORT) ||
reg == AW9523_REG_CHIPID ||
reg == AW9523_REG_SOFT_RESET;
}

The above function is used to check the register is volatile in the
driver aw9523_reg.c
The function is called in the aw9523_reg_read() function when read
register reg. The above functions check the register is hole




NEXT




<s> rtk_api_ret_t rtk_port_sds_reset(rtk_port_t port)
{
rtk_uint32 ext_id;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
if(rtk_switch_isSgmiiPort(port) != RT_ERR_OK)
return RT_ERR_PORT_ID;

ext_id = port - 15;
return rtl8367c_sdsReset(ext_id);
}

The above function is used to reset SDS.
You can call the function at any time.</s>




NEXT




<s> static void rtl839x_packet_cntr_clear(int counter)
{
/* Access LOG table (4) via register RTL8390_TBL_0 */
struct table_reg *r = rtl_table_get(RTL8390_TBL_0, 4);

pr_debug("In %s, id %d\n", __func__, counter);
/* The table has a size of 2 registers */
if (counter % 2)
sw_w32(0, rtl_table_data(r, 0));
else
sw_w32(0, rtl_table_data(r, 1));

rtl_table_write(r, counter / 2);

rtl_table_release(r);
}

The above function is used to clear various packet counters for different counters, the parameters are the counter numbers. You need to provide the correct count and function will make the corresponding bit value 0.

The function is from a module, I’m not sure whether




NEXT




<s> ReadRegLong (u32 addr)
{
// u32  rd_val;
//rd_val = *((volatile u32 *)(addr));
// return rd_val;
return IFX_MEI_READ_REGISTER_L (addr);
}

The above function is used to read 32 bit register from the target. The below function is used to read 16 bit register from target. The same comments applies to ReadShort and ReadByte functions

ReadRegHalf (u32 addr)
{




NEXT




<s> int ag71xx_debugfs_root_init(void)
{
if (ag71xx_debugfs_root)
return -EBUSY;

ag71xx_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);
if (!ag71xx_debugfs_root)
return -ENOENT;

return 0;
}

The above function is used to initialize the debugfs directory.
It can return either -EBUSY or -ENOENT, depending on whether the directory is already initialized or not.</s>




NEXT




<s> void hostapd_ubus_notify_beacon_report(
struct hostapd_data *hapd, const u8 *addr, u8 token, u8 rep_mode,
struct rrm_measurement_beacon_report *rep, size_t len)
{
if (!hapd->ubus.obj.has_subscribers)
return;

if (!addr || !rep)
return;

blob_buf_init(&b, 0);
blobmsg_add_macaddr(&b, "address", addr);
blobmsg_add_u16(&b, "op-class", rep->op_class);
blobmsg_add_u16(&b, "channel", rep->channel);
blobmsg_add_u64(&b, "start-time", rep->start_time);
blobmsg_add_u16(&b, "duration", rep->duration);
blobmsg_add_u16(&b, "report-info", rep->report_info);
blobmsg_add_u16(&b, "rcpi", rep->rcpi);
blobmsg_add_u16(&b, "rsni", rep->rsni);
blobmsg_add_macaddr(&b, "bssid", rep->bssid);
blobmsg_add_u16(&b, "antenna-id", rep->antenna_id);
blobmsg_add_u16(&b, "parent-tsf", rep->parent_tsf);
blobmsg_add_u16(&b, "rep-mode", rep_mode);

ubus_notify(ctx, &hapd->ubus.obj, "beacon-report", b.head, -1);
}

The above function is used to notify hostapd that a beacon report has been received from a beaconing STA, and it constructs the payload of the IPC message, which includes STA's MAC address and some parameters of the beacon report. After




NEXT




<s> static int bcm6348_do_cfg_write(int type, unsigned int busn,
unsigned int devfn, int where, int size,
u32 val)
{
struct bcm6348_pci *priv = &bcm6348_pci;
u32 data;

/* two phase cycle, first we write address, then write data to
* another location, caller already has a spinlock so no need
* to add one here */
if (bcm6348_setup_cfg_access(type, busn, devfn, where))
return PCIBIOS_DEVICE_NOT_FOUND;
iob();

data = le32_to_cpu(__raw_readl(priv->io));
data = preprocess_write(data, val, where, size);

__raw_writel(cpu_to_le32(data), priv->io);
wmb();
/* no way to know the access is done, we have to wait */
udelay(500);
/* restore IO space normal behaviour */
__raw_writel(0, priv->pci + MPI_L2PCFG_REG);

return PCIBIOS_SUCCESSFUL;
}

The above function is used to program device's PCI bus cycles (config space)
via a special IO space location, and it simply writes the configuration
request data to it, and wait 500us for the command to complete. Since it
doesn'




NEXT




<s> u64 rtl930x_traffic_get(int source)
{
u32 v;
struct table_reg *r = rtl_table_get(RTL9300_TBL_0, 6);

rtl_table_read(r, source);
v = sw_r32(rtl_table_data(r, 0));
rtl_table_release(r);
v = v >> 3;

return v;
}

The above function is used to determine the received traffic rates for each of the eight (0 - 7) interfaces in the switch. We could have taken a different approach here and just used the sw_r32() function to read the data directly from memory. The




NEXT




<s> static void rtl838x_l2_learning_setup(void)
{
/* Set portmask for broadcast traffic and unknown unicast address flooding
* to the reserved entry in the portmask table used also for
* multicast flooding */
sw_w32(UNKNOWN_MC_PMASK << 12 | UNKNOWN_MC_PMASK, RTL838X_L2_FLD_PMSK);

/* Enable learning constraint system-wide (bit 0), per-port (bit 1)
* and per vlan (bit 2) */
sw_w32(0x7, RTL838X_L2_LRN_CONSTRT_EN);

/* Limit learning to maximum: 16k entries, after that just flood (bits 0-1) */
sw_w32((0x3fff << 2) | 0, RTL838X_L2_LRN_CONSTRT);

/* Do not trap ARP packets to CPU_PORT */
sw_w32(0, RTL838X_SPCL_TRAP_ARP_CTRL);
}

The above function is used to set up learning for multiple port.  It makes use of the MAC learning control register in RTL838x,

128.167.113.121:~/work/switch# et




NEXT




<s> hostapd_parse_vht_capab_blobmsg(struct ieee80211_vht_capabilities *vhtc)
{
void *supported_mcs;
void *map;
int i;

static const struct {
const char *name;
uint32_t flag;
} vht_capas[] = {
{ "su_beamformee", VHT_CAP_SU_BEAMFORMEE_CAPABLE },
{ "mu_beamformee", VHT_CAP_MU_BEAMFORMEE_CAPABLE },
};

for (i = 0; i < ARRAY_SIZE(vht_capas); i++)
blobmsg_add_u8(&b, vht_capas[i].name,
!!(vhtc->vht_capabilities_info & vht_capas[i].flag));

supported_mcs = blobmsg_open_table(&b, "mcs_map");

/* RX map */
map = blobmsg_open_table(&b, "rx");
hostapd_parse_vht_map_blobmsg(le_to_host16(vhtc->vht_supported_mcs_set.rx_map));
blobmsg_close_table(&b, map);

/* TX map */
map = blobmsg_open_table(&b, "tx");
hostapd_parse_vht_map_blobmsg(le_to_host16(vhtc->vht_supported_mcs_set.tx_map));
blobmsg_close_table(&b, map);

blobmsg_close_table(&b, supported_mcs);
}

The above function is used to parse the "supported-mcs-set" blobmsg
and extract the 16-bit value of every element of the bitmap.

The hostapd_parse_vht_map_blobmsg() function, below,




NEXT




<s> mtk_bmt_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
u16 orig_block = ofs >> bmtd.blk_shift;
int block;

block = bmtd.ops->get_mapping_block(orig_block);
if (block < 0)
return -EIO;

mtk_bmt_remap_block(orig_block, block, bmtd.blk_size);

return bmtd._block_markbad(mtd, (loff_t)block << bmtd.blk_shift);
}

The above function is used to marked marked bad a bad block, I want to know what the `((loff_t)block << bmtd.blk_shift`) is for. The bmtd.blk_shift is 9 and block is a u1




NEXT




<s> static int ptm_showtime_enter(struct port_cell_info *port_cell, void *xdata_addr)
{
int i;

ASSERT(port_cell != NULL, "port_cell is NULL");
ASSERT(xdata_addr != NULL, "xdata_addr is NULL");

//  TODO: ReTX set xdata_addr
g_xdata_addr = xdata_addr;

g_showtime = 1;

for ( i = 0; i < ARRAY_SIZE(g_net_dev); i++ )
netif_carrier_on(g_net_dev[i]);

IFX_REG_W32(0x0F, UTP_CFG);

//#ifdef CONFIG_VR9
//    IFX_REG_W32_MASK(1 << 17, 0, FFSM_CFG0);
//#endif

printk("enter showtime\n");

return 0;
}

The above function is used to make the port into showtime mode.

In the above function, some parameters, such as g_xdata_addr and g_showtime,
will be used by later functions.

For a long time, all ports stay




NEXT




<s> static bool check_image_header(const image_header_t *header)
{
if (header->ih_magic != cpu_to_be32(IH_MAGIC_OKLI)) {
puts("Invalid image magic\n");
return false;
}

if (header->ih_comp != cpu_to_be32(IH_COMP_NONE)) {
puts("Unsupported compressed image\n");
return false;
}

return true;
}

The above function is used to determine whether or not an executable file is an OKLinux binary. The function is used to check for three things:

- The file’s magic number
- The file’s compression header
- The version of the kernel.




NEXT




<s> start_server(struct ead_instance *i)
{
if (!nonfork) {
i->pid = fork();
if (i->pid != 0) {
if (i->pid < 0)
i->pid = 0;
return;
}
}

instance = i;
signal(SIGCHLD, instance_handle_sigchld);
ead_pcap_reopen(true);
ead_pktloop();
pcap_close(pcap_fp);
if (pcap_fp_rx != pcap_fp)
pcap_close(pcap_fp_rx);

exit(0);
}

The above function is used to start the pcap file reader thread.

Why not just pass the pointer to the current function directly on the fork?

I have to go and figure out why the pcap doesn’t work this way, not yet had the chance




NEXT




<s> unmap_block_v2(u16 block)
{
bmtd.bbt->bb_tbl[block] = block;
bmtd.bmt_blk_idx = upload_bmt(bmtd.bbt, bmtd.bmt_blk_idx);
}

The above function is used to free a page (16K block).

Its been my suspicion that this code is doing the following when used to free a block being used by a dentry:

Free it.

Delete its dentry.






NEXT




<s> static void rtl931x_stp_get(struct rtl838x_switch_priv *priv, u16 msti, u32 port_state[])
{
u32 cmd = 1 << 20 | /* Execute cmd */
0 << 19 | /* Read */
5 << 15 | /* Table type 0b101 */
(msti & 0x3fff);
priv->r->exec_tbl0_cmd(cmd);

for (int i = 0; i < 4; i++)
port_state[i] = sw_r32(priv->r->tbl_access_data_0(i));
}

The above function is used to check the STP states for all the 4 ports, port 0 through 3 inclusive. The function takes two parameters: priv, which is the switch-private structure and port_state, which is an array of 4 32




NEXT




<s> static void bcma_fbs_set(struct bcma_fbs *priv, struct device_node *node)
{
struct ssb_sprom *sprom = &priv->sprom;
const struct firmware *fw;
const char *sprom_name;
int err;

if (of_property_read_string(node, "brcm,sprom", &sprom_name))
sprom_name = NULL;

if (sprom_name) {
err = request_firmware_direct(&fw, sprom_name, priv->dev);
if (err)
dev_err(priv->dev, "%s load error\n", sprom_name);
} else {
err = -ENOENT;
}

if (err) {
sprom->revision = 0x02;
sprom->board_rev = 0x0017;
sprom->country_code = 0x00;
sprom->ant_available_bg = 0x03;
sprom->pa0b0 = 0x15ae;
sprom->pa0b1 = 0xfa85;
sprom->pa0b2 = 0xfe8d;
sprom->pa1b0 = 0xffff;
sprom->pa1b1 = 0xffff;
sprom->pa1b2 = 0xffff;
sprom->gpio0 = 0xff;
sprom->gpio1 = 0xff;
sprom->gpio2 = 0xff;
sprom->gpio3 = 0xff;
sprom->maxpwr_bg = 0x4c;
sprom->itssi_bg = 0x00;
sprom->boardflags_lo = 0x2848;
sprom->boardflags_hi = 0x0000;
priv->devid_override = false;

dev_warn(priv->dev, "using basic SPROM\n");
} else {
size_t size = min(fw->size, (size_t) BCMA_FBS_MAX_SIZE);
u16 tmp_sprom[BCMA_FBS_MAX_SIZE >> 1];
u32 i, j;

for (i = 0, j = 0; i < size; i += 2, j++)
tmp_sprom[j] = (fw->data[i] << 8) | fw->data[i + 1];

release_firmware(fw);
bcma_fbs_fixup(priv, tmp_sprom);
sprom_extract(priv, tmp_sprom, size >> 1);

priv->devid_override = sprom_override_devid(priv, sprom,
tmp_sprom);
}
}

The above function is used to load a binary firmware file whose name is passed on the command line, it looks in the default firmware_dir and also via the device tree node. If the device_tree is used the ssum_name is extracted and if this contains




NEXT




<s> mtd_fixwrg(const char *mtd, size_t offset, size_t data_size)
{
int fd;
char *first_block;
ssize_t res;
size_t block_offset;
size_t data_offset;
struct wrg_header *shdr;

if (quiet < 2)
fprintf(stderr, "Trying to fix WRG header in %s at 0x%x...\n",
mtd, offset);

block_offset = offset & ~(erasesize - 1);
offset -= block_offset;

fd = mtd_check_open(mtd);
if(fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd);
exit(1);
}

if (block_offset + erasesize > mtdsize) {
fprintf(stderr, "Offset too large, device size 0x%x\n",
mtdsize);
exit(1);
}

first_block = malloc(erasesize);
if (!first_block) {
perror("malloc");
exit(1);
}

res = pread(fd, first_block, erasesize, block_offset);
if (res != erasesize) {
perror("pread");
exit(1);
}

shdr = (struct wrg_header *)(first_block + offset);
if (le32_to_cpu(shdr->magic1) != WRG_MAGIC) {
fprintf(stderr, "No WRG header found (%08x != %08x)\n",
le32_to_cpu(shdr->magic1), WRG_MAGIC);
exit(1);
} else if (!le32_to_cpu(shdr->size)) {
fprintf(stderr, "WRG entity with empty image\n");
exit(1);
}

data_offset = offset + sizeof(struct wrg_header);
if (!data_size)
data_size = mtdsize - data_offset;
if (data_size > le32_to_cpu(shdr->size))
data_size = le32_to_cpu(shdr->size);
if (wrg_fix_md5(shdr, fd, data_offset, data_size))
goto out;

if (mtd_erase_block(fd, block_offset)) {
fprintf(stderr, "Can't erease block at 0x%x (%s)\n",
block_offset, strerror(errno));
exit(1);
}

if (quiet < 2)
fprintf(stderr, "Rewriting block at 0x%x\n", block_offset);

if (pwrite(fd, first_block, erasesize, block_offset) != erasesize) {
fprintf(stderr, "Error writing block (%s)\n", strerror(errno));
exit(1);
}

if (quiet < 2)
fprintf(stderr, "Done.\n");

out:
close (fd);
sync();

return 0;
}

The above function is used to verify that an mtd device contains an appropriate WRG header to use our patching utility.

Below is a quick example on how to use it using your favorite shell / terminal:

$ ./mtd-fixwrg.




NEXT




<s> static int mirror_show(struct seq_file *seq, void *v)
{
return 0;
}

The above function is used to display the contents of a mirror file system.
The mirror show() function returns 0 if the sequence printing was successful,
0 if there were errors and -1 if the data to be displayed were not available.

struct seq_file




NEXT




<s> static int gpio_keys_probe(struct platform_device *pdev)
{
struct gpio_keys_platform_data *pdata;
struct gpio_keys_button_dev *bdev;
int ret, i;

ret = gpio_keys_button_probe(pdev, &bdev, 0);
if (ret)
return ret;

pdata = bdev->pdata;
for (i = 0; i < pdata->nbuttons; i++) {
const struct gpio_keys_button *button = &pdata->buttons[i];
struct gpio_keys_button_data *bdata = &bdev->data[i];
unsigned long irqflags = IRQF_ONESHOT;

INIT_DELAYED_WORK(&bdata->work, gpio_keys_irq_work_func);

if (!button->irq) {
bdata->irq = gpiod_to_irq(bdata->gpiod);
if (bdata->irq < 0) {
dev_err(&pdev->dev, "failed to get irq for gpio:%d\n",
button->gpio);
continue;
}

irqflags |= IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
} else {
bdata->irq = button->irq;
}

schedule_delayed_work(&bdata->work,
msecs_to_jiffies(bdata->software_debounce));

ret = devm_request_threaded_irq(&pdev->dev,
bdata->irq, NULL, button_handle_irq,
irqflags, dev_name(&pdev->dev), bdata);
if (ret < 0) {
bdata->irq = 0;
dev_err(&pdev->dev, "failed to request irq:%d for gpio:%d\n",
bdata->irq, button->gpio);
continue;
} else {
dev_dbg(&pdev->dev, "gpio:%d has irq:%d\n",
button->gpio, bdata->irq);
}
}

return 0;
}

The above function is used to probe the platform_device
in which the struct gpio_keys_button_data is defined.

The gpio-keys.c file initializes the button_devices
variable which will be used to hold the information about the





NEXT




<s> static int rtl8214fc_get_port(struct phy_device *phydev)
{
int addr = phydev->mdio.addr;

pr_debug("%s: port %d\n", __func__, addr);
if (rtl8214fc_media_is_fibre(phydev))
return PORT_FIBRE;

return PORT_MII;
}

The above function is used to check what link type a particular PHY supports.

Here the rtl8214fc driver calls out to the rtl8214fc_media_is_fibre() function to check if the above PHY




NEXT




<s> static void back_lines(int n);
static void print_page(WINDOW *win, int height, int width, update_text_fn
update_text, void *data);
static void print_line(WINDOW *win, int row, int width);
static char *get_line(void);
static void print_position(WINDOW * win);

static int hscroll;
static int begin_reached, end_reached, page_length;
static char *buf;
static char *page;

/*
* refresh window content
*/
static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
int cur_y, int cur_x, update_text_fn update_text,
void *data)
{
print_page(box, boxh, boxw, update_text, data);
print_position(dialog);
wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
wrefresh(dialog);
}

The above function is used to print the page-size-aligned box,
the position and the bottom line. It is a little complex
because we have to decide if the current view range should
move forward if there is data scrollable in the window.

``




NEXT




<s> static uint32_t hash(const char *s)
{
uint32_t hash = 0;

while (*s)
hash = 31 * hash + *s++;

return hash;
}

The above function is used to build a hash table.

The question is, what is this variable 'hash' used for???

To put it another way, is this hash function defined correctly???

For example, in perl (for example)




NEXT




<s> ret_t rtl8367c_setAsicSvlanUnmatchVlan(rtk_uint32 index)
{
if(index > RTL8367C_SVIDXMAX)
return RT_ERR_SVLAN_ENTRY_INDEX;

return rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_UNTAG_UNMAT_CFG, RTL8367C_VS_UNMAT_SVIDX_MASK, index);
}

The above function is used to configure the Asic SVLAN UNMATCH VLAN Index.
In our previous discussion, we learned that it is to specify how the SVLAN UNMATCH feature searches the VLAN table. By default, the SVLAN UNMATCH




NEXT




<s> static void init_dialog_colors(void)
{
init_one_color(&dlg.screen);
init_one_color(&dlg.shadow);
init_one_color(&dlg.dialog);
init_one_color(&dlg.title);
init_one_color(&dlg.border);
init_one_color(&dlg.button_active);
init_one_color(&dlg.button_inactive);
init_one_color(&dlg.button_key_active);
init_one_color(&dlg.button_key_inactive);
init_one_color(&dlg.button_label_active);
init_one_color(&dlg.button_label_inactive);
init_one_color(&dlg.inputbox);
init_one_color(&dlg.inputbox_border);
init_one_color(&dlg.searchbox);
init_one_color(&dlg.searchbox_title);
init_one_color(&dlg.searchbox_border);
init_one_color(&dlg.position_indicator);
init_one_color(&dlg.menubox);
init_one_color(&dlg.menubox_border);
init_one_color(&dlg.item);
init_one_color(&dlg.item_selected);
init_one_color(&dlg.tag);
init_one_color(&dlg.tag_selected);
init_one_color(&dlg.tag_key);
init_one_color(&dlg.tag_key_selected);
init_one_color(&dlg.check);
init_one_color(&dlg.check_selected);
init_one_color(&dlg.uarrow);
init_one_color(&dlg.darrow);
}

The above function is used to create a dialog and all the required widgets inside it.

In this function, we first define the colors of the dialog and all the widgets inside it. We will be using these colors for our widgets in our UI.






NEXT




<s> SHA256_Final(unsigned char digest[static SHA256_DIGEST_LENGTH], SHA256_CTX *ctx)
{
/* Add padding */
SHA256_Pad(ctx);

/* Write the hash */
be32enc_vect(digest, ctx->state, SHA256_DIGEST_LENGTH);

/* Clear the context state */
memset(ctx, 0, sizeof(*ctx));
}

The above function is used to finalize the hash. This is what you get in libevhtp for SHA256.

I’ve also added the finalized SHA256 algorithm and code.

There is a bug: The current code comp




NEXT




<s> static void rtl930x_init_eee(struct rtl838x_switch_priv *priv, bool enable)
{
pr_info("Setting up EEE, state: %d\n", enable);

/* Setup EEE on all ports */
for (int i = 0; i < priv->cpu_port; i++) {
if (priv->ports[i].phy)
rtl930x_port_eee_set(priv, i, enable);
}

priv->eee_enabled = enable;
}

The above function is used to enable/disable the eee feature. To enable the eee feature, use the below command.
rtl930x_init_eee(priv, 1);

or To disable the eee feature, use the




NEXT




<s> ReadMbox (u32 * mboxarray, u32 size)
{
IFX_MEI_DebugRead (&dsl_devices[0], OMBOX_BASE, mboxarray, size);
IFX_MEI_DMSG("read from %X\n", OMBOX_BASE);
}

The above function is used to read from OMBOX address 2D207000 and stores the RX data in a buffer.

I have debugged the above code. It is reaching ifx_mei_dbg_msg() but never




NEXT




<s> static int rtl8367_enable_vlan(struct rtl8366_smi *smi, int enable)
{
return rtl8366_smi_rmwr(smi, RTL8367_VLAN_CTRL_REG,
RTL8367_VLAN_CTRL_ENABLE,
(enable) ? RTL8367_VLAN_CTRL_ENABLE : 0);
}

The above function is used to enable/disable virtual LAN feature in the chip.
The function call looks like this:

static int rtl8367_enable_vlan(struct rtl8366_smi *smi, int




NEXT




<s> static bool hostapd_ubus_init(void)
{
if (ctx)
return true;

eloop_add_uloop();
ctx = ubus_connect(NULL);
if (!ctx)
return false;

ctx->connection_lost = hostapd_ubus_connection_lost;
ubus_add_uloop(ctx);

return true;
}

The above function is used to connect to and initialize ubus.

#define ubus_subscribe_err_ret(ubus, subscribe, err_ret) \
	do { \
		result = ubus_err_to_sub_




NEXT




<s> static void fe_uninit(struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);

if (priv->phy)
priv->phy->disconnect(priv);
fe_mdio_cleanup(priv);

fe_reg_w32(0, FE_REG_FE_INT_ENABLE);
free_irq(dev->irq, dev);
}

The above function is used to disconnect the PHY from the switch.

The PHY connection is done by net_device_start - in the same way
the code reads the link status (FE_REG_PHY_INTERRUPT in
FE_




NEXT




<s> ret_t rtl8367c_setAsicSvlanIngressUnmatch(rtk_uint32 mode)
{
return rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UNMAT_MASK, mode);
}

The above function is used to program the VS (802.1q S-tag) match filter on the VLAN port of ingress to make the switch match and forward VLAN packets with given S-tags. The valid parameter for the function is:





NEXT




<s> static int rb4xx_gpio_direction_input(struct gpio_chip *chip,
unsigned int offset)
{
return -EOPNOTSUPP;
}

The above function is used to set input direction for the chip,
while the below one is being called when user set direction via a file,
which is a file in /sys/class/gpio/ as below :

{
cat /sys/class/gpio




NEXT




<s> rtk_api_ret_t rtk_qos_1pRemark_get(rtk_pri_t int_pri, rtk_pri_t *pDot1p_pri)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (int_pri > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

if ((retVal = rtl8367c_getAsicRemarkingDot1pParameter(int_pri, pDot1p_pri)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the default priority setting for 1P
remarker. 1P remarks are made on non-802.1Q ingress packets
entering 1P flows, with ingress QID = 0. These flows




NEXT




<s> rtk_api_ret_t rtk_dot1x_eapolFrame2CpuEnable_set(rtk_enable_t enable)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_getAsicRma(3, &rmacfg)) != RT_ERR_OK)
return retVal;

if (ENABLED == enable)
rmacfg.operation = RMAOP_TRAP_TO_CPU;
else if (DISABLED == enable)
rmacfg.operation = RMAOP_FORWARD;

if ((retVal = rtl8367c_setAsicRma(3, &rmacfg)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable or disable the Dot1x EtherTypes trapping. When in normal working condition, 44 packets per second (PPS) would be generated. If the router or switch does not support the PPS counter, the CPU util




NEXT




<s> static int oxnas_pcie_probe(struct platform_device *pdev)
{
struct oxnas_pcie *pcie;
struct device_node *np = pdev->dev.of_node;
int ret;

pcie = devm_kzalloc(&pdev->dev, sizeof(struct oxnas_pcie),
GFP_KERNEL);
if (!pcie)
return -ENOMEM;

pcie->pdev = pdev;
pcie->haslink = 1;
spin_lock_init(&pcie->lock);

pcie->sys_ctrl = syscon_regmap_lookup_by_compatible("oxsemi,ox820-sys-ctrl");
if (IS_ERR(pcie->sys_ctrl))
return PTR_ERR(pcie->sys_ctrl);

ret = oxnas_pcie_init_res(pdev, pcie, np);
if (ret)
return ret;
if (pcie->card_reset >= 0) {
ret = gpio_request_one(pcie->card_reset, GPIOF_DIR_IN,
dev_name(&pdev->dev));
if (ret) {
dev_err(&pdev->dev, "cannot request gpio pin %d\n",
pcie->card_reset);
return ret;
}
}

ret = oxnas_pcie_map_registers(pdev, np, pcie);
if (ret) {
dev_err(&pdev->dev, "cannot map registers\n");
goto err_free_gpio;
}

ret = oxnas_pcie_shared_init(pdev, pcie);
if (ret)
goto err_free_gpio;

/* if hw not found, haslink cleared */
oxnas_pcie_init_hw(pdev, pcie);

if (pcie->haslink && oxnas_pcie_link_up(pcie)) {
pcie->haslink = 1;
dev_info(&pdev->dev, "link up\n");
} else {
pcie->haslink = 0;
dev_info(&pdev->dev, "link down\n");
}
/* should we register our controller even when pcie->haslink is 0 ? */
/* register the controller with framework */
oxnas_pcie_enable(&pdev->dev, pcie);

return 0;

err_free_gpio:
if (pcie->card_reset)
gpio_free(pcie->card_reset);

return ret;
}

The above function is used to probe the PCI and PCIE module. As we can
see the function has been defined inside the file driver/linux/pci/driver.c
where it defines a method for the pcie bus core. The function is
declared in




NEXT




<s> swlib_print_portmap(struct switch_dev *dev, char *segment)
{
int i;

if (segment) {
if (!strcmp(segment, "cpu")) {
printf("%d ", dev->cpu_port);
} else if (!strcmp(segment, "disabled")) {
for (i = 0; i < dev->ports; i++)
if (!dev->maps[i].segment)
printf("%d ", i);
} else for (i = 0; i < dev->ports; i++) {
if (dev->maps[i].segment && !strcmp(dev->maps[i].segment, segment))
printf("%d ", i);
}
} else {
printf("%s - %s\n", dev->dev_name, dev->name);
for (i = 0; i < dev->ports; i++)
if (i == dev->cpu_port)
printf("port%d:\tcpu\n", i);
else if (dev->maps[i].segment)
printf("port%d:\t%s.%d\n", i, dev->maps[i].segment, dev->maps[i].virt);
else
printf("port%d:\tdisabled\n", i);
}
}

The above function is used to print the Ethernet port configurations for a specified switch_dev and optionally the segment. Here, the segment can correspond to the segment string within switchdev_get_nummap(...); it is then passed to swlib_print_




NEXT




<s> rtk_api_ret_t rtk_cpu_enable_get(rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicCputagEnable(pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the CPU mode of the target chip.

rtk_enable_t pEnable;
rtk_cpu_enable_get(&pEnable);

- If pEnable->bit.cputag == 1, It




NEXT




<s> static int aw9523_remove(struct i2c_client *client)
{
struct aw9523 *awi = i2c_get_clientdata(client);
int ret;

if (!awi)
return 0;

/*
* If the chip VIO is connected to a regulator that we can turn
* off, life is easy... otherwise, reinitialize the chip and
* set the pins to hardware defaults before removing the driver
* to leave it in a clean, safe and predictable state.
*/
if (awi->vio_vreg) {
regulator_disable(awi->vio_vreg);
} else {
mutex_lock(&awi->i2c_lock);
ret = aw9523_hw_init(awi);
mutex_unlock(&awi->i2c_lock);
if (ret)
return ret;
}

mutex_destroy(&awi->i2c_lock);
return 0;
}

The above function is used to remove the AW9523 module from the kernel. It basically
disables the regulator and then re-initialises the chip, before sending the chip back
to its hardware defaults.

The function is called by the sub




NEXT




<s> ar7240sw_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
{
return __ar8216_setup_port(priv, port, members, false);
}

The above function is used to do the port initialization, setting up all the
registers. In most cases, it is enough to call ar7240_sw_setup_port() on each
port, in order to set up most of the port registers.




NEXT




<s> void yy_delete_buffer ( YY_BUFFER_STATE b  );
void yy_flush_buffer ( YY_BUFFER_STATE b  );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to define new buffer in the buffer stack for scaning new input. It reads the input from the given in file pointer, length of memory block which is defined by the size attribute , creates a buffer and pushes it to this buffer stack. It returns




NEXT




<s> static u16 read_cr(void __iomem *phy_base, u16 address)
{
iowrite32((u32)address, phy_base + PHY_STAT);
wait_cr_ack(phy_base);
iowrite32(CR_READ_ENABLE, phy_base + PHY_DATA);
wait_cr_ack(phy_base);
return (u16)ioread32(phy_base + PHY_STAT);
}

The above function is used to write values into the TBI MAC register
and hence needs to be rewrite to be usable with TBI MAC

Static u16 read_cr(void __iomem *phy_base, u16 address) {





NEXT




<s> ar8xxx_get_features(struct phy_device *phydev)
{
struct ar8xxx_priv *priv = phydev->priv;

linkmode_copy(phydev->supported, PHY_BASIC_FEATURES);
if (ar8xxx_has_gige(priv))
linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, phydev->supported);

return 0;
}

The above function is used to configure MDC to pull down the MDIO pins to zero in order to put the PHY into bypass mode. This configuration change is done at boot up and when the link goes down.

The problem is, that some PHY




NEXT




<s> static int rtl838x_dbgfs_port_init(struct dentry *parent, struct rtl838x_switch_priv *priv,
int port)
{
struct dentry *port_dir;
struct debugfs_regset32 *port_ctrl_regset;

port_dir = debugfs_create_dir(priv->ports[port].dp->name, parent);

if (priv->family_id == RTL8380_FAMILY_ID) {
debugfs_create_x32("storm_rate_uc", 0644, port_dir,
(u32 *)(RTL838X_SW_BASE + RTL838X_STORM_CTRL_PORT_UC(port)));

debugfs_create_x32("storm_rate_mc", 0644, port_dir,
(u32 *)(RTL838X_SW_BASE + RTL838X_STORM_CTRL_PORT_MC(port)));

debugfs_create_x32("storm_rate_bc", 0644, port_dir,
(u32 *)(RTL838X_SW_BASE + RTL838X_STORM_CTRL_PORT_BC(port)));
} else {
debugfs_create_x32("storm_rate_uc", 0644, port_dir,
(u32 *)(RTL838X_SW_BASE + RTL839X_STORM_CTRL_PORT_UC_0(port)));

debugfs_create_x32("storm_rate_mc", 0644, port_dir,
(u32 *)(RTL838X_SW_BASE + RTL839X_STORM_CTRL_PORT_MC_0(port)));

debugfs_create_x32("storm_rate_bc", 0644, port_dir,
(u32 *)(RTL838X_SW_BASE + RTL839X_STORM_CTRL_PORT_BC_0(port)));
}

debugfs_create_u32("id", 0444, port_dir, (u32 *)&priv->ports[port].dp->index);

port_ctrl_regset = devm_kzalloc(priv->dev, sizeof(*port_ctrl_regset), GFP_KERNEL);
if (!port_ctrl_regset)
return -ENOMEM;

port_ctrl_regset->regs = port_ctrl_regs;
port_ctrl_regset->nregs = ARRAY_SIZE(port_ctrl_regs);
port_ctrl_regset->base = (void *)(RTL838X_SW_BASE + (port << 2));
debugfs_create_regset32("port_ctrl", 0400, port_dir, port_ctrl_regset);

debugfs_create_file("stp_state", 0600, port_dir, &priv->ports[port], &stp_state_fops);
debugfs_create_file("age_out", 0600, port_dir, &priv->ports[port], &age_out_fops);
debugfs_create_file("port_egress_rate", 0600, port_dir, &priv->ports[port],
&port_egress_fops);
return 0;
}

The above function is used to initialize the dentry structure for a port.
If the function succeeds, it will return 0; otherwise, it will return negative number.
*/
#include "dev_rthnd.h"

#if CSR




NEXT




<s> _IFX_MEI_DBGLongWordWrite (DSL_DEV_Device_t * pDev, u32 DEC_mode,
u32 address, u32 data)
{
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_DBG_DECODE, DEC_mode);
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_DBG_WR_AD, address);
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_DBG_DATA, data);
meiPollForDbgDone (pDev);
return DSL_DEV_MEI_ERR_SUCCESS;
}

The above function is used to write into the DBG register of MEI. When DEC_mode is “1”, DBG_MODE bit shall be cleared (0).

# ifdef DSL_DEV_FLEX2_CONFIG_EI2




NEXT




<s> static int gpio_latch_remove(struct platform_device *pdev)
{
struct gpio_latch_chip *glc = platform_get_drvdata(pdev);

gpiochip_remove(&glc->gc);
return 0;
}

The above function is used to remove a driver at the end
of life. A driver that uses this function is often considered
to be a module. It must be removed using rmmod(1). If not,
the driver can't free the gpio-chip




NEXT




<s> static int to_bcd(int decnum)
{
int fac, num = 0;

for (fac = 1; decnum; fac *= 16) {
num += (decnum % 10) * fac;
decnum /= 10;
}

return num;
}

The above function is used to convert a decimal number to BCD. However, if
the first digit happens to be 0, it should be removed and the resulting
BCD number should be divided by 10.

for example ->
175 to




NEXT




<s> static int rtl83xx_port_mdb_add(struct dsa_switch *ds, int port,
const struct switchdev_obj_port_mdb *mdb)
{
struct rtl838x_switch_priv *priv = ds->priv;
u64 mac = ether_addr_to_u64(mdb->addr);
struct rtl838x_l2_entry e;
int err = 0, idx;
int vid = mdb->vid;
u64 seed = priv->r->l2_hash_seed(mac, vid);
int mc_group;

if (priv->id >= 0x9300)
return -EOPNOTSUPP;

pr_debug("In %s port %d, mac %llx, vid: %d\n", __func__, port, mac, vid);

if (priv->is_lagmember[port]) {
pr_debug("%s: %d is lag slave. ignore\n", __func__, port);
return -EINVAL;
}

mutex_lock(&priv->reg_mutex);

idx = rtl83xx_find_l2_hash_entry(priv, seed, false, &e);

/* Found an existing or empty entry */
if (idx >= 0) {
if (e.valid) {
pr_debug("Found an existing entry %016llx, mc_group %d\n",
ether_addr_to_u64(e.mac), e.mc_portmask_index);
rtl83xx_mc_group_add_port(priv, e.mc_portmask_index, port);
} else {
pr_debug("New entry for seed %016llx\n", seed);
mc_group = rtl83xx_mc_group_alloc(priv, port);
if (mc_group < 0) {
err = -ENOTSUPP;
goto out;
}
rtl83xx_setup_l2_mc_entry(&e, vid, mac, mc_group);
priv->r->write_l2_entry_using_hash(idx >> 2, idx & 0x3, &e);
}
goto out;
}

/* Hash buckets full, try CAM */
idx = rtl83xx_find_l2_cam_entry(priv, seed, false, &e);

if (idx >= 0) {
if (e.valid) {
pr_debug("Found existing CAM entry %016llx, mc_group %d\n",
ether_addr_to_u64(e.mac), e.mc_portmask_index);
rtl83xx_mc_group_add_port(priv, e.mc_portmask_index, port);
} else {
pr_debug("New entry\n");
mc_group = rtl83xx_mc_group_alloc(priv, port);
if (mc_group < 0) {
err = -ENOTSUPP;
goto out;
}
rtl83xx_setup_l2_mc_entry(&e, vid, mac, mc_group);
priv->r->write_cam(idx, &e);
}
goto out;
}

err = -ENOTSUPP;

out:
mutex_unlock(&priv->reg_mutex);
if (err)
dev_err(ds->dev, "failed to add MDB entry\n");

return err;
}

The above function is used to add multicast group entry into the switch. Here few things you need to know.

The first thing to notice is the code that calls rtl838x_find_l2_hash_entry() function to get the




NEXT




<s> static int mt7986b_pinctrl_probe(struct platform_device *pdev)
{
return mtk_moore_pinctrl_probe(pdev, &mt7986b_data);
}

The above function is used to register the pinctrl driver of MT7986A. It will check whether this driver has registered before. If it has, the system will fail to enter the OOM stage.
static int mt7986b_p




NEXT




<s> static void bcm6328_pcie_reset(struct bcm6328_pcie *priv)
{
regmap_write_bits(priv->serdes, 0,
SERDES_PCIE_EXD_EN | SERDES_PCIE_EN,
SERDES_PCIE_EXD_EN | SERDES_PCIE_EN);

reset_control_assert(priv->reset);
reset_control_assert(priv->reset_core);
reset_control_assert(priv->reset_ext);
if (priv->reset_hard) {
reset_control_assert(priv->reset_hard);
mdelay(10);
reset_control_deassert(priv->reset_hard);
}
mdelay(10);

reset_control_deassert(priv->reset_core);
reset_control_deassert(priv->reset);
mdelay(10);

reset_control_deassert(priv->reset_ext);
mdelay(200);
}

The above function is used to do a cold boot into a device. On some
devices, there is no boot ROM, and the reset sequence is rather more
complex than the 1-3 delay loop in the existing 'cold' function. This
patch adds




NEXT




<s> rtk_api_ret_t rtk_svlan_priorityRef_set(rtk_svlan_pri_ref_t ref)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (ref >= REF_PRI_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicSvlanPrioritySel(ref)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the S-VLAN priority reference.
The priority can be set by the priority reference. Refer the table below.

REF  | PRIORITY
-----+---------
     | 0-31
REF_ |




NEXT




<s> static void print_function_line(void)
{
int i;
int offset = 1;
const int skip = 1;
int lines = getmaxy(stdscr);

for (i = 0; i < function_keys_num; i++) {
wattrset(main_window, attr_function_highlight);
mvwprintw(main_window, lines-3, offset,
"%s",
function_keys[i].key_str);
wattrset(main_window, attr_function_text);
offset += strlen(function_keys[i].key_str);
mvwprintw(main_window, lines-3,
offset, "%s",
function_keys[i].func);
offset += strlen(function_keys[i].func) + skip;
}
wattrset(main_window, attr_normal);
}

The above function is used to draw function keys by printing its own key_str and the real function name to the screen.

But here are a few problems.

Firstly, I use attr_normal to clean the whole screen in main(), it is clear that




NEXT




<s> ar8327_vtu_flush(struct ar8xxx_priv *priv)
{
ar8327_vtu_op(priv, AR8327_VTU_FUNC1_OP_FLUSH, 0);
}

The above function is used to flush the VTU.

# VTU Operations

The VTU is a very specific case of a MAR. While it is called the Video
Table Update (VTU), in practice it can be used in any case where a




NEXT




<s> static void rtl838x_write_mcast_pmask(int idx, u64 portmask)
{
/* Access MC_PMSK (2) via register RTL8380_TBL_L2 */
struct table_reg *q = rtl_table_get(RTL8380_TBL_L2, 2);

sw_w32(((u32)portmask) & 0x1fffffff, rtl_table_data(q, 0));
rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to write Multicast PMASK using MCAST-PMASK TBL register.
Unfortunately it is written using static function.
We can’t directly replace it by dynamic function because calling dynamic
function from static function will cause the program crash




NEXT




<s> ret_t rtl8367c_getAsicIGMPReportRX(rtk_uint32 port, rtk_uint32 *allow_report)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
{
/* Allow Report */
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_REPORT_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_REPORT_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
*allow_report = value;

return RT_ERR_OK;
}

The above function is used to determine if the IGMP Report will be accepted or rejected. I assume it means report if the multicast is joined; reject otherwise. If the function fails, it returns RT_ERR_OK. RT_ERR_PORT_ID denotes




NEXT




<s> rtk_api_ret_t rtk_dot1x_unauthPacketOper_set(rtk_port_t port, rtk_dot1x_unauth_action_t unauth_action)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if (unauth_action >= DOT1X_ACTION_END)
return RT_ERR_DOT1X_PROC;

if ((retVal = rtl8367c_setAsic1xProcConfig(rtk_switch_port_L2P_get(port), unauth_action)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set Unauth packet operation, so that the default behavior can be set.
The possible value of unauth operation and the description are as follows:
DOT1X_ACTION_FORWARD:   If DOT1X_ACTION_




NEXT




<s> static inline struct ubootenv_drvdata *to_ubootenv_drvdata(struct file *file)
{
return container_of(file->private_data, struct ubootenv_drvdata, misc);
}

The above function is used to check if the file pointed by the “file” parameter is a ubootenv file or not. If the file is a ubootenv file, then the function will return a pointer to the ubootenv_drvdata structure associated with the file




NEXT




<s> static int ox820_restart_probe(struct platform_device *pdev)
{
struct oxnas_restart_context *ctx;
struct regmap *sys_ctrl;
struct device *dev = &pdev->dev;
int err = 0;

sys_ctrl = syscon_node_to_regmap(pdev->dev.of_node);
if (IS_ERR(sys_ctrl))
return PTR_ERR(sys_ctrl);

ctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);
if (!ctx)
return -ENOMEM;

ctx->sys_ctrl = sys_ctrl;
ctx->restart_handler.notifier_call = ox820_restart_handle;
ctx->restart_handler.priority = 192;
err = register_restart_handler(&ctx->restart_handler);
if (err)
dev_err(dev, "can't register restart notifier (err=%d)\n", err);

return err;
}

The above function is used to probe the restart handler to the specific chip:

probe_restart_notifier(0x88870000)

There is a struct called ocd_restart_context that contains the chip number:




NEXT




<s> static u32 rtl8231_read_cached(struct rtl8231_gpios *gpios, u32 reg)
{
if (reg > 0x1f)
return 0;

if (gpios->reg_cached & (1 << reg))
return gpios->reg_shadow[reg];

return rtl8231_read(gpios, reg);
}

The above function is used to read from a GPIO register in the board file. The function can simply be called this way:

gpios = board_priv(board_id);
reg = rtl8231_read_cached(gpios




NEXT




<s> ret_t rtl8367c_getAsicIGMPTableFullOP(rtk_uint32 *poperation)
{
ret_t   retVal;
rtk_uint32  value;

/* Table full Operation */
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG1, RTL8367C_TABLE_FULL_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;

*poperation = value;

return RT_ERR_OK;
}

The above function is used to set the table full operation of asic’s IGMP table.
When the bit number is 8367_TABLE_FULL_OP_VLAN_BIT = 1, IGMP/MLD table is full




NEXT




<s> handle_prime(void)
{
struct ead_msg_salt *sb = EAD_DATA(msg, salt);

salt.len = sb->len;
memcpy(salt.data, sb->salt, salt.len);

if (auth_type == EAD_AUTH_MD5) {
memcpy(pw_salt, sb->ext_salt, MAXSALTLEN);
pw_salt[MAXSALTLEN - 1] = 0;
}

tcp = t_getpreparam(sb->prime);
tc = t_clientopen(username, &tcp->modulus, &tcp->generator, &salt);
if (!tc) {
fprintf(stderr, "Client open failed\n");
return false;
}

return true;
}

The above function is used to read a salt-blob from the EAD request. Once this has been done successfully then we try to decrypt the client parameter that is encrypted into the EAD message by the server. If we are successful to decrypt this then we try




NEXT




<s> static inline void scllo(void)
{
gpio_direction_output(scl_index, 1);
udelay(ADAP_DELAY);
}

The above function is used to set output of gpio scl. How to know this is the index of gpio scl instead of the index
of something else? I'm learning c programming for ARM and i wanna know where is the gpio number or gpio




NEXT




<s> static bool nmbm_block_walk_desc(struct nmbm_instance *ni, uint32_t ba,
uint32_t *nba, uint32_t count, uint32_t limit)
{
int32_t nblock = count;

if (limit >= ni->block_count)
limit = ni->block_count - 1;

while (ba > limit) {
if (nmbm_get_block_state(ni, ba) == BLOCK_ST_GOOD)
nblock--;

if (nblock < 0) {
*nba = ba;
return true;
}

ba--;
}

return false;
}

The above function is used to traverse the good blocks in a BI, starting at block ba and ending at block ba + count-1. The good blocks are defined by BLOCK_ST_GOOD. In the second instance (where the function is marked), the




NEXT




<s> static bool nmbm_write_repeated_data(struct nmbm_instance *ni, uint32_t ba,
const void *data, uint32_t size)
{
uint64_t addr, off;
bool success;
int ret;

if (size > bmtd.pg_size)
return false;

addr = ba2addr(ni, ba);

for (off = 0; off < bmtd.blk_size; off += bmtd.pg_size) {
/* Prepare page data. fill 0xff to unused region */
memcpy(ni->page_cache, data, size);
memset(ni->page_cache + size, 0xff, ni->rawpage_size - size);

success = nmbm_write_phys_page(ni, addr + off, ni->page_cache, NULL);
if (!success)
return false;

/* Verify the data just written. ECC error indicates failure */
ret = nmbm_read_phys_page(ni, addr + off, ni->page_cache, NULL);
if (ret < 0)
return false;

if (memcmp(ni->page_cache, data, size))
return false;
}

return true;
}

The above function is used to write data in large chunk size, i.e. size. This might look similar to the memcpy
function and might give an impression that in large chunk of data writing, only one memcpy function call is
performed in the above program snippet




NEXT




<s> static inline int rtl931x_l2_port_new_salrn(int p)
{
return RTL931X_L2_PORT_NEW_SALRN(p);
}

The above function is used to enable the salrn l2 forwarding mode.

Here the rtl_l2_port_salt table is used to lookup the
source mac of the packet. Here you can see the l2_port_salt,




NEXT




<s> rtk_api_ret_t rtk_vlan_egrFilterEnable_get(rtk_enable_t *pEgrFilter)
{
rtk_api_ret_t retVal;
rtk_uint32 state;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEgrFilter)
return RT_ERR_NULL_POINTER;

/* enable VLAN */
if ((retVal = rtl8367c_getAsicVlanFilter(&state)) != RT_ERR_OK)
return retVal;

*pEgrFilter = (rtk_enable_t)state;
return RT_ERR_OK;
}

The above function is used to get the status of the egrFilter. It is set to enable by default so it returns RT_ERR_OK with *pEgrFilter as enable (1) after a successful call.</s>




NEXT




<s> static int ip17xx_config_init(struct phy_device *pdev)
{
struct ip17xx_state *state = pdev->priv;
struct net_device *dev = pdev->attached_dev;
int err;

err = register_switch(&state->dev, dev);
if (err < 0)
return err;

state->registered = true;
ip17xx_reset(&state->dev);
return 0;
}

The above function is used to initialise ip 17xx phy controller.
Then register_switch is used to update PHY device as attached device.
This is done for switch with one of the following methods i.e for a standalone switch or switch module




NEXT




<s> add_port_map(struct switch_dev *dev, struct nlattr *nla)
{
struct nlattr *p;
int err = 0, idx = 0;
int remaining;

dev->maps = malloc(sizeof(struct switch_portmap) * dev->ports);
if (!dev->maps)
return -1;
memset(dev->maps, 0, sizeof(struct switch_portmap) * dev->ports);

nla_for_each_nested(p, nla, remaining) {
struct nlattr *tb[SWITCH_PORTMAP_MAX+1];

if (idx >= dev->ports)
continue;

err = nla_parse_nested(tb, SWITCH_PORTMAP_MAX, p, portmap_policy);
if (err < 0)
continue;


if (tb[SWITCH_PORTMAP_SEGMENT] && tb[SWITCH_PORTMAP_VIRT]) {
dev->maps[idx].segment = strdup(nla_get_string(tb[SWITCH_PORTMAP_SEGMENT]));
dev->maps[idx].virt = nla_get_u32(tb[SWITCH_PORTMAP_VIRT]);
}
idx++;
}

out:
return err;
}

The above function is used to parse the attributes of the
struct switch_dev data type, which contains a pointer to the struct
switch_portmap
data type which contains a portmap for that switch. Currently,
struct portmap is set to hold to hold at




NEXT




<s> static void rtk_hal_read_reg(unsigned int reg_addr)
{
ret_t retVal;
unsigned int reg_val;

retVal = smi_read(reg_addr, &reg_val);

if(retVal != RT_ERR_OK)
printk("switch reg read failed\n");
else
printk("reg0x%x = 0x%x\n", reg_addr, reg_val);
}

The above function is used to test the switch by reading the switch register for
debugging purpose.</s>




NEXT




<s> ret_t rtl8367c_getAsic1xPBOpdirConfig(rtk_uint32 port, rtk_uint32* pOpdir)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_PORT_OPDIR_REG, port, pOpdir);
}

The above function is used to fetch the one-time PB operation direction, which decides how a user would be authenticated when the PB is triggered for a certain time.
1. “unspecified”: this direction value is used mainly to indicate that this




NEXT




<s> static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
enum rtl8367_extif_mode mode)
{
int err;

/* set port mode */
switch (mode) {
case RTL8367_EXTIF_MODE_RGMII:
REG_RMW(smi, RTL8367B_CHIP_DEBUG0_REG,
RTL8367B_DEBUG0_SEL33(id),
RTL8367B_DEBUG0_SEL33(id));
if (id <= 1) {
REG_RMW(smi, RTL8367B_CHIP_DEBUG0_REG,
RTL8367B_DEBUG0_DRI(id) |
RTL8367B_DEBUG0_DRI_RG(id) |
RTL8367B_DEBUG0_SLR(id),
RTL8367B_DEBUG0_DRI_RG(id) |
RTL8367B_DEBUG0_SLR(id));
REG_RMW(smi, RTL8367B_CHIP_DEBUG1_REG,
RTL8367B_DEBUG1_DN_MASK(id) |
RTL8367B_DEBUG1_DP_MASK(id),
(7 << RTL8367B_DEBUG1_DN_SHIFT(id)) |
(7 << RTL8367B_DEBUG1_DP_SHIFT(id)));
} else {
REG_RMW(smi, RTL8367B_CHIP_DEBUG2_REG,
RTL8367B_DEBUG2_DRI_EXT2 |
RTL8367B_DEBUG2_DRI_EXT2_RG |
RTL8367B_DEBUG2_SLR_EXT2 |
RTL8367B_DEBUG2_RG2_DN_MASK |
RTL8367B_DEBUG2_RG2_DP_MASK,
RTL8367B_DEBUG2_DRI_EXT2_RG |
RTL8367B_DEBUG2_SLR_EXT2 |
(7 << RTL8367B_DEBUG2_RG2_DN_SHIFT) |
(7 << RTL8367B_DEBUG2_RG2_DP_SHIFT));
}
break;

case RTL8367_EXTIF_MODE_TMII_MAC:
case RTL8367_EXTIF_MODE_TMII_PHY:
REG_RMW(smi, RTL8367B_BYPASS_LINE_RATE_REG, BIT(id), BIT(id));
break;

case RTL8367_EXTIF_MODE_GMII:
REG_RMW(smi, RTL8367B_CHIP_DEBUG0_REG,
RTL8367B_DEBUG0_SEL33(id),
RTL8367B_DEBUG0_SEL33(id));
REG_RMW(smi, RTL8367B_EXT_RGMXF_REG(id), BIT(6), BIT(6));
break;

case RTL8367_EXTIF_MODE_MII_MAC:
case RTL8367_EXTIF_MODE_MII_PHY:
case RTL8367_EXTIF_MODE_DISABLED:
REG_RMW(smi, RTL8367B_BYPASS_LINE_RATE_REG, BIT(id), 0);
REG_RMW(smi, RTL8367B_EXT_RGMXF_REG(id), BIT(6), 0);
break;

default:
dev_err(smi->parent,
"invalid mode for external interface %d\n", id);
return -EINVAL;
}

if (id <= 1)
REG_RMW(smi, RTL8367B_DIS_REG,
RTL8367B_DIS_RGMII_MASK << RTL8367B_DIS_RGMII_SHIFT(id),
mode << RTL8367B_DIS_RGMII_SHIFT(id));
else
REG_RMW(smi, RTL8367B_DIS2_REG,
RTL8367B_DIS2_RGMII_MASK << RTL8367B_DIS2_RGMII_SHIFT,
mode << RTL8367B_DIS2_RGMII_SHIFT);

return 0;
}

The above function is used to set the operating mode for the
RTL8366SMI. See RTL8366_EXTIF_SET_MODE. The default value is
RTL8367_EXTIF_MODE_DISABLE




NEXT




<s> static int __init tl_wdr4900_v1_probe(void)
{
unsigned long root = of_get_flat_dt_root();

if (of_flat_dt_is_compatible(root, "tplink,tl-wdr4900-v1"))
return 1;

return 0;
}

The above function is used to probe the tl_wdr4900 device and return true if the device is present. This is done by checking the compatibility string of the flat device tree. If the device is incompatible, the function will return false.






NEXT




<s> t_clientopen(u, n, g, s)
const char * u;
struct t_num * n;
struct t_num * g;
struct t_num * s;
{
struct t_client * tc;
unsigned char buf1[SHA_DIGESTSIZE], buf2[SHA_DIGESTSIZE];
SHA1_CTX ctxt;
int i, validated;
struct t_preconf * tpc;

validated = 0;
if(n->len < MIN_MOD_BYTES)
return 0;
for(i = 0; i < t_getprecount(); ++i) {
tpc = t_getpreparam(i);
if(tpc->modulus.len == n->len && tpc->generator.len == g->len &&
memcmp(tpc->modulus.data, n->data, n->len) == 0 &&
memcmp(tpc->generator.data, g->data, g->len) == 0) {
validated = 1;    /* Match found, done */
break;
}
}

if(validated == 0)
return 0;

if((tc = malloc(sizeof(struct t_client))) == 0)
return 0;

strncpy(tc->username, u, MAXUSERLEN);

SHA1Init(&tc->hash);

tc->n.len = n->len;
tc->n.data = tc->nbuf;
memcpy(tc->n.data, n->data, tc->n.len);

SHA1Init(&ctxt);
SHA1Update(&ctxt, tc->n.data, tc->n.len);
SHA1Final(buf1, &ctxt);

tc->g.len = g->len;
tc->g.data = tc->gbuf;
memcpy(tc->g.data, g->data, tc->g.len);

SHA1Init(&ctxt);
SHA1Update(&ctxt, tc->g.data, tc->g.len);
SHA1Final(buf2, &ctxt);

for(i = 0; i < sizeof(buf1); ++i)
buf1[i] ^= buf2[i];

SHA1Update(&tc->hash, buf1, sizeof(buf1));

SHA1Init(&ctxt);
SHA1Update(&ctxt, tc->username, strlen(tc->username));
SHA1Final(buf1, &ctxt);

SHA1Update(&tc->hash, buf1, sizeof(buf1));

tc->s.len = s->len;
tc->s.data = tc->sbuf;
memcpy(tc->s.data, s->data, tc->s.len);

SHA1Update(&tc->hash, tc->s.data, tc->s.len);

tc->a.data = tc->abuf;
tc->A.data = tc->Abuf;
tc->p.data = tc->pbuf;
tc->v.data = tc->vbuf;

SHA1Init(&tc->ckhash);

return tc;
}

The above function is used to authenticate users. Authentication is performed by the server, with the authentication parameters being sent (in plaintext) by the client. It's rather simple; at the beginning of the process, after the session has been opened, both the




NEXT




<s> static void rtl9310_i2c_reg_addr_set(struct rtl9300_i2c *i2c, u32 reg, u16 len)
{
/* Set register address width */
REG_MASK(i2c, 0x3 << RTL9310_I2C_CTRL_MADDR_WIDTH, len << RTL9310_I2C_CTRL_MADDR_WIDTH,
RTL9310_I2C_CTRL);

/* Set register address */
writel(reg, REG(i2c, RTL9310_I2C_MEMADDR));
}

The above function is used to set I2C registers.

In the process of setting the value of the registers, the "ADDRWIDTH(len)" in line 6 will cause problems. You can comment out that code line and uncomment the line before it to see




NEXT




<s> ret_t rtl8367c_getAsicSvlanUplinkPortMask(rtk_uint32* pPortmask)
{
return rtl8367c_getAsicReg(RTL8367C_REG_SVLAN_UPLINK_PORTMASK, pPortmask);
}

The above function is used to return the value of register asic_svlan_uplink_portmask.

ret_t rtl8367c_setAsicSvlanUplinkPortMask(rtk_uint32 portmask




NEXT




<s> bool sym_tristate_within_range(struct symbol *sym, tristate val)
{
int type = sym_get_type(sym);

if (sym->visible == no)
return false;

if (type != S_BOOLEAN && type != S_TRISTATE)
return false;

if (type == S_BOOLEAN && val == mod)
return false;
if (sym->visible <= sym->rev_dep.tri)
return false;
if (sym_is_choice_value(sym) && sym->visible == yes)
return val == yes;
return val >= sym->rev_dep.tri && val <= sym->visible;
}

The above function is used to verify if a given tristate value is present
within an already-determined symbol's range.  But the check above could
get optimised a bit further by recognising that if a tristate value is
present




NEXT




<s> trx_fixup(int fd, const char *name)
{
struct mtd_info_user mtdInfo;
unsigned long len;
struct trx_header *trx;
void *ptr, *scan;
int bfd;

if (ioctl(fd, MEMGETINFO, &mtdInfo) < 0) {
fprintf(stderr, "Failed to get mtd info\n");
goto err;
}

len = mtdInfo.size;
if (mtdInfo.size <= 0) {
fprintf(stderr, "Invalid MTD device size\n");
goto err;
}

bfd = mtd_open(name, true);
ptr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, bfd, 0);
if (!ptr || (ptr == (void *) -1)) {
perror("mmap");
fprintf(stderr, "Mapping the TRX header failed\n");
goto err1;
}

trx = ptr;
if (ntohl(trx->magic) != opt_trxmagic) {
fprintf(stderr, "TRX header not found\n");
goto err;
}

scan = ptr + offsetof(struct trx_header, flag_version);
trx->crc32 = crc32buf(scan, trx->len - (scan - ptr));
msync(ptr, sizeof(struct trx_header), MS_SYNC|MS_INVALIDATE);
munmap(ptr, len);
close(bfd);
return 0;

err1:
close(bfd);
err:
return -1;
}

The above function is used to correct the header structure of the emmc partition used by the trx program, and the data of the partition is basically intact, but some information such as the partition name, file type and so on cannot be displayed, which may be caused by the




NEXT




<s> static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to process the packet.
In this function, it checks whether the packet type is BP or PAP, and if so, it calls the processing function.
If there is a header, it calls the processing function.
In 2.




NEXT




<s> static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to allocate and free physical buffer when need.
*/
static struct sk_buff *get_skb_pointer(unsigned int skb_num)
{
	struct sk_buff *skb = NULL;
	int ret;






NEXT




<s> static void aca_dma_ch_init(struct dc_ep_priv *priv, u32 cid,
u32 dbase, u32 dlen)
{
/* Select channel */
wr32(cid, ADMA_CS);

/* Reset Channel */
wr32_mask(0, BIT(CCTRL_RST), ADMA_CCTRL);
while ((rd32(ADMA_CCTRL) & BIT(CCTRL_RST)))
;

/* Set descriptor list base and length */
wr32(dbase, ADMA_CDBA);
wr32(dlen, ADMA_CDLEN);

/*Clear Intr */
wr32(ADMA_CI_ALL, ADMA_CIS);
/* Enable Intr */
wr32(ADMA_CI_ALL, ADMA_CIE);

/* Enable Channel */
wr32_mask(0, BIT(CCTRL_ONOFF), ADMA_CCTRL);
mb();
}

The above function is used to initialize DMA channels of ACA, such as enabling it and setting its parameters.

static void aca_dma_enable_chan(struct dc_ep_priv *priv, u32 cid)
{
/* enable channel




NEXT




<s> swlib_set_attr(struct switch_dev *dev, struct switch_attr *attr, struct switch_val *val)
{
int cmd;

switch(attr->atype) {
case SWLIB_ATTR_GROUP_GLOBAL:
cmd = SWITCH_CMD_SET_GLOBAL;
break;
case SWLIB_ATTR_GROUP_PORT:
cmd = SWITCH_CMD_SET_PORT;
break;
case SWLIB_ATTR_GROUP_VLAN:
cmd = SWITCH_CMD_SET_VLAN;
break;
default:
return -EINVAL;
}

val->attr = attr;
return swlib_call(cmd, NULL, send_attr_val, val);
}

The above function is used to set the values of the attributes in the switch. This function receives the pointer of the structure which contains the details of the attribute whose value needs to be set. Also this function receives the pointer of the structure which will be filled with the output values.




NEXT




<s> ret_t rtl8367c_setAsicPortRTCTEnable(rtk_uint32 portmask)
{
ret_t       retVal;
rtk_uint32  regData;
rtk_uint32  port;

if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
return retVal;

if( (regData == 0x0276) || (regData == 0x0597) )
return RT_ERR_CHIP_NOT_SUPPORTED;

for(port = 0; port <= 10 ; port++)
{
if(portmask & (0x0001 << port))
{
if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa422, &regData)) != RT_ERR_OK)
return retVal;

regData &= 0x7FFF;
if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
return retVal;

regData |= 0x00F2;/*RTCT set to  echo response mode*/
if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
return retVal;

regData |= 0x0001;
if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
return retVal;
}
}

return RT_ERR_OK;
}

The above function is used to enable ASIC ports' RTCT function for the NIOS. It used to configure the RTCT_EN bit of P2PHY_CTRL1 register which is a bit map of port.</s>




NEXT




<s> void sig_dump(int sig)
{
run_dump = 1;
}

The above function is used to invoke a dump of the currently executing process. It is invoked at the time of a signal.

In this blog, we will explore how to handle the signals in your embedded Linux system. We will look at the following topics:






NEXT




<s> ret_t rtl8367c_getAsicOamParser(rtk_uint32 port, rtk_uint32* pParser)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_REG_OAM_PARSER_CTRL0 + port/8, RTL8367C_OAM_PARSER_MASK(port%8), pParser);
}

The above function is used to retrieve the OAM parser control register(port/8).

1.port : Specify the port number that you want to check
2.*pParser : the value that you want from the status of OAM parser(port/




NEXT




<s> ar8xxx_mdiodev_remove(struct mdio_device *mdiodev)
{
struct ar8xxx_priv *priv = dev_get_drvdata(&mdiodev->dev);

if (WARN_ON(!priv))
return;

mutex_lock(&ar8xxx_dev_list_lock);

if (--priv->use_count > 0) {
mutex_unlock(&ar8xxx_dev_list_lock);
return;
}

list_del(&priv->list);
mutex_unlock(&ar8xxx_dev_list_lock);

unregister_switch(&priv->dev);
ar8xxx_mib_stop(priv);
if(priv->sw_mii_bus)
mdiobus_unregister(priv->sw_mii_bus);
ar8xxx_free(priv);
}

The above function is used to remove all phy, it need to free related
resources such as SW mii register.

Since the same code is used on ar8xxx_pci_detach and other platform, so I
refactor the platform related code as




NEXT




<s> mt7530_vtcr(struct mt7530_priv *priv, u32 cmd, u32 val)
{
int i;

mt7530_w32(priv, REG_ESW_VLAN_VTCR, BIT(31) | (cmd << 12) | val);

for (i = 0; i < 20; i++) {
u32 val = mt7530_r32(priv, REG_ESW_VLAN_VTCR);

if ((val & BIT(31)) == 0)
break;

udelay(1000);
}
if (i == 20)
printk("mt7530: vtcr timeout\n");
}

The above function is used to configure the hardware for the given PTP clock. It writes its configuration in the global variable of the hardware.</s>




NEXT




<s> static int rtl8367_sw_get_port_pvid(struct switch_dev *dev, int port, int *val)
{
return rtl8367c_get_pvid(port, val);
}

The above function is used to get the PVID on a port. The 8367 port
has just one PVID per port.

Now if I try to read the PVID for a non-existent port, e.g. 70




NEXT




<s> ret_t rtl8367c_getAsicPortStatus(rtk_uint32 port, rtl8367c_port_status_t *pPortStatus)
{
ret_t retVal;
rtk_uint32 regData;

/* Invalid input parameter */
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_PORT0_STATUS+port,&regData);
if(retVal != RT_ERR_OK)
return retVal;

pPortStatus->lpi1000  = (regData >> 11) & 0x0001;
pPortStatus->lpi100   = (regData >> 10) & 0x0001;
pPortStatus->mstfault = (regData >> 9) & 0x0001;
pPortStatus->mstmode  = (regData >> 8) & 0x0001;
pPortStatus->nway     = (regData >> 7) & 0x0001;
pPortStatus->txpause  = (regData >> 6) & 0x0001;
pPortStatus->rxpause  = (regData >> 5) & 0x0001;
pPortStatus->link     = (regData >> 4) & 0x0001;
pPortStatus->duplex   = (regData >> 2) & 0x0001;
pPortStatus->speed    = regData  & 0x0003;

return RT_ERR_OK;
}

The above function is used to get the port status.

Another part of the code can be found below.

The code above describes how to send a MAC address to the  chip through the Ethernet Rx path.

When the device MAC address




NEXT




<s> static int clk_mt7986_topckgen_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;
int nr = ARRAY_SIZE(top_fixed_clks) + ARRAY_SIZE(top_divs) +
ARRAY_SIZE(top_muxes);

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(nr);
if (!clk_data)
return -ENOMEM;

mtk_clk_register_fixed_clks(top_fixed_clks, ARRAY_SIZE(top_fixed_clks),
clk_data);
mtk_clk_register_factors(top_divs, ARRAY_SIZE(top_divs), clk_data);
mtk_clk_register_muxes(top_muxes, ARRAY_SIZE(top_muxes), node,
&mt7986_clk_lock, clk_data);

clk_prepare_enable(clk_data->clks[CLK_TOP_SYSAXI_SEL]);
clk_prepare_enable(clk_data->clks[CLK_TOP_SYSAPB_SEL]);
clk_prepare_enable(clk_data->clks[CLK_TOP_DRAMC_SEL]);
clk_prepare_enable(clk_data->clks[CLK_TOP_DRAMC_MD32_SEL]);
clk_prepare_enable(clk_data->clks[CLK_TOP_F26M_SEL]);
clk_prepare_enable(clk_data->clks[CLK_TOP_SGM_REG_SEL]);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);

if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_topckgen_data;
}
return r;

free_topckgen_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to probe the Topckgen driver. In this function, we will create a array of pointers to the Topckgen
clocks. We will also create a array of pointers to the Topckgen dividers. We will also create a




NEXT




<s> yy_load_buffer_state(  );
}

{

The above function is used to convert an ASCII text string with hexadecimal number representation of 16-bit binary (aka, “halfword”) and/or 8-bit binary (aka “byte”) values (with leading zeros) into a




NEXT




<s> static unsigned strhash(const char *s)
{
/* fnv32 hash */
unsigned hash = 2166136261U;
for (; *s; s++)
hash = (hash ^ *s) * 0x01000193;
return hash;
}

The above function is used to store a key in TrieTree

struct TrieTree
{
    struct TrieTree *children[26];
    char *key;
    //int value;
}

So, when insertion happens,




NEXT




<s> bss_conf_rename_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
const char *ifname)
{
if (!strcmp(ifname, vlan->ifname))
return 0;

hostapd_drv_if_rename(hapd, WPA_IF_AP_VLAN, vlan->ifname, ifname);
os_strlcpy(vlan->ifname, ifname, sizeof(vlan->ifname));

return 0;
}

The above function is used to rename a vlan ifname at run time. I have
a scenario where I use hostapd.conf to create a vlan with vlan0 as the
ifname, and later, during run time I want to change v




NEXT




<s> static void espi_setup_spi(struct fsl_spi *fsl, unsigned int max_hz)
{
unsigned long spibrg;
uint32_t pm;

spibrg = CONFIG_FREQ_SYSTEMBUS / 2;
fsl->div16 = 0;
if ((spibrg / max_hz) > 32) {
fsl->div16 = ESPI_CSMODE_DIV16;
pm = spibrg / (max_hz * 16 * 2);
if (pm > 16) {
/* max_hz too low */
pm = 16;
}
} else {
pm = spibrg / (max_hz * 2);
}
if (pm)
pm--;
fsl->pm = pm;
}

The above function is used to setup the SPI core. You can use it to
configure the max baud rate to use before it goes into the FIFO mode.

If you notice some issue with the max baud rate you can use the
max_h




NEXT




<s> static int _urandom(void *ctx, unsigned char *out, size_t len)
{
ssize_t ret;

ret = getrandom(out, len, 0);
if (ret < 0 || (size_t)ret != len)
return MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;

return 0;
}

The above function is used to read
data from the pseudo-random hardware
generator. The hardware generator
usually generates random
numbers based on noise and the
current power consumption,
temperature, etc. It is then used
to seed the pseudo-random




NEXT




<s> rtk_api_ret_t rtk_dot1x_portBasedEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsic1xPBEnConfig(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable/disable the port-based 802.1X, you can get the enable configuration of the port-based 802.1X.
Here, we take this function as an example to introduce the rtk_




NEXT




<s> static int rtl838x_set_mac_address(struct net_device *dev, void *p)
{
struct rtl838x_eth_priv *priv = netdev_priv(dev);
const struct sockaddr *addr = p;
u8 *mac = (u8 *) (addr->sa_data);

if (!is_valid_ether_addr(addr->sa_data))
return -EADDRNOTAVAIL;

dev_addr_set(dev, addr->sa_data);
rtl838x_set_mac_hw(dev, mac);

pr_info("Using MAC %08x%08x\n", sw_r32(priv->r->mac), sw_r32(priv->r->mac + 4));

return 0;
}

The above function is used to set the device's mac address. It appears to be working fine with the 3COM mac address, but when I have the rtl8380's mac address configured, the device does not connect. I believe this is because




NEXT




<s> ret_t rtl8367c_setAsicPortBasedFid(rtk_uint32 port, rtk_uint32 fid)
{
rtk_uint32  reg_addr;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(fid > RTL8367C_FIDMAX)
return RT_ERR_L2_FID;

if(port < 8)
return rtl8367c_setAsicReg(RTL8367C_PORT_PBFID_REG(port),fid);
else {
reg_addr = RTL8367C_REG_PORT8_PBFID + port-8;
return rtl8367c_setAsicReg(reg_addr, fid);
}

}

The above function is used to set port based fid.

In trunk configuration using this function, you don’t have to change port based fid all the time in order to allow the LACP and 100baseT4 mode work in the same port.




NEXT




<s> static int do_show(nvram_handle_t *nvram)
{
nvram_tuple_t *t;
int stat = 1;

if( (t = nvram_getall(nvram)) != NULL )
{
while( t )
{
printf("%s=%s\n", t->name, t->value);
t = t->next;
}

stat = 0;
}

return stat;
}

The above function is used to display all the values set in the nvram. As this shows, we do not have to specify which parameter of the object is to be displayed.

## NVRAM in Flash

Nvram can be stored in any memory and




NEXT




<s> void __init panda_pic_init(void)
{
struct mpic *mpic;

mpic = mpic_alloc(NULL, 0,
MPIC_BIG_ENDIAN |
MPIC_SINGLE_DEST_CPU,
0, 256, " OpenPIC  ");

BUG_ON(mpic == NULL);
mpic_init(mpic);
}

The above function is used to initialise an mpic. You need to give the mpic a
"name" which is the last text argument quoted.

BUG_ON(mpic == NULL);

I don't see it.

If it




NEXT




<s> static int mt7621_nfc_send_address_byte(struct mt7621_nfc *nfc, int addr)
{
struct device *dev = nfc->dev;
u32 val;
int ret;

nfi_write32(nfc, NFI_COLADDR, addr);
nfi_write32(nfc, NFI_ROWADDR, 0);
nfi_write16(nfc, NFI_ADDRNOB, 1);

ret = readl_poll_timeout_atomic(nfc->nfi_regs + NFI_STA, val,
!(val & STA_ADDR), 10,
NFI_CORE_TIMEOUT);
if (ret) {
dev_warn(dev, "NFI core timed out entering address mode\n");
return -EIO;
}

return 0;
}

The above function is used to communicate to NFI controller, to send specific address byte to controller.</s>




NEXT




<s> static int rtl8367_sw_reset_switch(struct switch_dev *dev)
{
if(rtl8367_switch_reset_func)
(*rtl8367_switch_reset_func)();
else
printk("rest switch is not supported\n");

return 0;
}

The above function is used to reset switch before entering the driver in an environment that runs off u-boot. The above function will not be called when running of board filesystem and load driver through command line, it is only for reset switch environment.</s>




NEXT




<s> ret_t rtl8367c_setAsicCputagMode(rtk_uint32 mode)
{
if(mode > 1)
return RT_ERR_INPUT;

return rtl8367c_setAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_FORMAT_OFFSET, mode);
}

The above function is used to set the way for the L3 CPU Forwarding Tags to map out to the internal CPU. It’s a very simple function only taking a single rtk_uint32 parameter (the CPU port ID to map to) and making




NEXT




<s> wait_mem_test_result (void)
{
uint32_t mbox[5];
mbox[0] = 0;

IFX_MEI_DMSG("Waiting Starting\n");
while (mbox[0] == 0) {
ReadMbox (&mbox[0], 5);
}
IFX_MEI_DMSG("Try to get mem test result.\n");
ReadMbox (&mbox[0], 5);
if (mbox[0] == 0xA) {
IFX_MEI_DMSG("Success.\n");
}
else if (mbox[0] == 0xA) {
IFX_MEI_EMSG("Fail,address %X,except data %X,receive data %X\n",
mbox[1], mbox[2], mbox[3]);
}
else {
IFX_MEI_EMSG("Fail\n");
}
}

The above function is used to test mem_wait function.</s>




NEXT




<s> u32 mtk_switch_r32(struct mt7620_gsw *gsw, unsigned reg)
{
return ioread32(gsw->base + reg);
}

The above function is used to retrieve the value of a register whose address is represented by an integer.

u32 mtk_write(unsigned long reg, u32 data);

The above function is used to write data to a register and return the value




NEXT




<s> static inline int rtl838x_mac_link_spd_sts(int p)
{
return RTL838X_MAC_LINK_SPD_STS(p);
}

The above function is used to extract the speed/duplex status of a
link.

There is no way to get the physical link status without polling the
HW.

The port status and link status can be obtained in a single PHY
register read




NEXT




<s> static int lq_ecb_des_encrypt(struct ablkcipher_request *areq)
{
struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);
struct des_ctx *ctx = crypto_ablkcipher_ctx(cipher);

return lq_queue_mgr(ctx, areq, areq->info, CRYPTO_DIR_ENCRYPT, 0);
}

The above function is used to perform block cipher operations on data.
In my case, I will use it to do ECB mode encryption/decryption of
the data in the buffer being sent/received over the wire. The buffer
will hold a header plus




NEXT




<s> mt7530_set_vlan_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

priv->global_vlan_enable = val->value.i != 0;

return 0;
}

The above function is used to set VLAN enable bit of VLAN register, if it
is set to 0, switch does not support VLAN.

When S-series device is configured with non-zero VLAN PVID, it also sets
the corresponding




NEXT




<s> static void rtl931x_stp_set(struct rtl838x_switch_priv *priv, u16 msti, u32 port_state[])
{
u32 cmd = 1 << 20 | /* Execute cmd */
1 << 19 | /* Write */
5 << 15 | /* Table type 0b101 */
(msti & 0x3fff);
for (int i = 0; i < 4; i++)
sw_w32(port_state[i], priv->r->tbl_access_data_0(i));
priv->r->exec_tbl0_cmd(cmd);
}

The above function is used to update the STP table. The STP state of a port is written to the STP table and executed to update the STP values. The function contains the following steps

1. STP MST I (from 0 to 




NEXT




<s> void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to configure some hardware related parameters and
the LED callback before the ATM stack/MAC is activated. The function is
used during ATM stack/MAC initialization, as the MEI driver does not
directly control any hardware. Therefore it cannot




NEXT




<s> ret_t rtl8367c_setAsicPortMirrorRealKeep(rtk_uint32 mode)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_REALKEEP_EN_OFFSET, mode);
}

The above function is used to configure mirror mode real port keep, mirror frame with the destination port equal to real keep port to real keep port on the forwarding path.
If RTL8367C_MIRROR_REALKEEP_EN=




NEXT




<s> static irqreturn_t rtl83xx_net_irq(int irq, void *dev_id)
{
struct net_device *dev = dev_id;
struct rtl838x_eth_priv *priv = netdev_priv(dev);
u32 status = sw_r32(priv->r->dma_if_intr_sts);

pr_debug("IRQ: %08x\n", status);

/*  Ignore TX interrupt */
if ((status & 0xf0000)) {
/* Clear ISR */
sw_w32(0x000f0000, priv->r->dma_if_intr_sts);
}

/* RX interrupt */
if (status & 0x0ff00) {
/* ACK and disable RX interrupt for this ring */
sw_w32_mask(0xff00 & status, 0, priv->r->dma_if_intr_msk);
sw_w32(0x0000ff00 & status, priv->r->dma_if_intr_sts);
for (int i = 0; i < priv->rxrings; i++) {
if (status & BIT(i + 8)) {
pr_debug("Scheduling queue: %d\n", i);
napi_schedule(&priv->rx_qs[i].napi);
}
}
}

/* RX buffer overrun */
if (status & 0x000ff) {
pr_debug("RX buffer overrun: status %x, mask: %x\n",
status, sw_r32(priv->r->dma_if_intr_msk));
sw_w32(status, priv->r->dma_if_intr_sts);
rtl838x_rb_cleanup(priv, status & 0xff);
}

if (priv->family_id == RTL8390_FAMILY_ID && status & 0x00100000) {
sw_w32(0x00100000, priv->r->dma_if_intr_sts);
rtl839x_l2_notification_handler(priv);
}

if (priv->family_id == RTL8390_FAMILY_ID && status & 0x00200000) {
sw_w32(0x00200000, priv->r->dma_if_intr_sts);
rtl839x_l2_notification_handler(priv);
}

if (priv->family_id == RTL8390_FAMILY_ID && status & 0x00400000) {
sw_w32(0x00400000, priv->r->dma_if_intr_sts);
rtl839x_l2_notification_handler(priv);
}

return IRQ_HANDLED;
}

The above function is used to get the current IRQ status of the PHY
interrupt. If the interrupt status is found to be set, then we handle the
interruption. If no interruptions found, the function exits.

void rtl83




NEXT




<s> static int mt7621_nfc_read_oob_hwecc(struct nand_chip *nand, int page)
{
return mt7621_nfc_read_page_hwecc(nand, NULL, 1, page);
}

The above function is used to read out of the nand chip OOB data. It's the same as the code used for Samsung m307e/m307e-b nand (See https://github.com/higor-m




NEXT




<s> adm6996_get_data(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);

val->value.i = r16(priv, priv->addr);

return 0;
};

The above function is used to get the value of the address from ADM6996 chip. Then, it can write the value. For this reason, a write to an invalid address returns an error; but a read from an invalid address returns the “random” value




NEXT




<s> hexDigitToInt(c)
char c;
{
if(c >= '0' && c <= '9')
return c - '0';
else if(c >= 'a' && c <= 'f')
return c - 'a' + 10;
else if(c >= 'A' && c <= 'F')
return c - 'A' + 10;
else
return 0;
}

The above function is used to find the number associated with a character in the hexadecimal digit. The next two are pretty self explanatory:

hexStringToBin(s)
char s;

{
int len = strlen(s); //find




NEXT




<s> rtk_api_ret_t rtk_port_macLocalLoopbackEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t   retVal;
rtk_uint32      data;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicPortLoopback(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;

if(rtk_switch_isUtpPort(port) == RT_ERR_OK)
{
if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, &data)) != RT_ERR_OK)
return retVal;

if(enable == ENABLED)
data |= (0x0001 << 14);
else
data &= ~(0x0001 << 14);

if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, data)) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to enable loopback function.
In case of 8367C or 8367S there is UTP/SFP port, we could set the MAC loopback for UTP port and SFP loopback for SFP




NEXT




<s> bool menu_has_help(struct menu *menu)
{
return menu->help != NULL;
}

The above function is used to check if the specific struct called menu has a help menu at all.
The menu.help != NULL condition will evaluate to TRUE if the menu has a help menu option, and is FALSE if it doesn't. This way we can decide to




NEXT




<s> static int rb91x_ooblayout_ecc(struct mtd_info *mtd, int section,
struct mtd_oob_region *oobregion)
{
switch (section) {
case 0:
oobregion->offset = 8;
oobregion->length = 3;
return 0;
case 1:
oobregion->offset = 13;
oobregion->length = 3;
return 0;
default:
return -ERANGE;
}
}

The above function is used to find out how many ecc bytes should go into the erase of one block.
The layout is as following:

OOB-layout 1

As we can see from above, there are three eccs for each block. There




NEXT




<s> uint8 Uart16550GetPoll()
{
while((UART16550_READ(OFS_LINE_STATUS) & 0x1) == 0);
return UART16550_READ(OFS_RCV_BUFFER);
}

The above function is used to retrieve data received by the UART interface through interrupts. A simple use is shown in the following example:

void UartReceiveService()
{
uint8 c;
while(UartReceiveBufferFull())
{




NEXT




<s> static inline int clk_off(struct dc_ep_dev *dev, u32 bits)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_clk_off(dev->priv, bits);
}

The above function is used to shutdown a clock, returning true if successful. A generic
driver was introduced into dc-devices that uses a common struct clock_reg_table (clock
registration table) to register and unregister clocks. The struct clock_reg




NEXT




<s> load_jump_table (unsigned long addr)
{
int i;
uint32_t addr_le, addr_be;
uint32_t jump_table[32];

for (i = 0; i < 16; i++) {
addr_le = i * 8 + addr;
addr_be = ((addr_le >> 16) & 0xffff);
addr_be |= ((addr_le & 0xffff) << 16);
jump_table[i * 2 + 0] = 0x0f802020;
jump_table[i * 2 + 1] = addr_be;
//printk("jt %X %08X %08X\n",i,jump_table[i*2+0],jump_table[i*2+1]);
}
arc_code_page_download (32, &jump_table[0]);
return 0;
}

The above function is used to download a jump table into memory. For this example, the jump table is made up of a load address in the first 16 bytes of the code page. The first entry of the jump table loads the code page with the next sixteen entries.




NEXT




<s> static int airoha_gpio_probe(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct airoha_gpio_ctrl *ctrl;
int err;

ctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);
if (!ctrl)
return -ENOMEM;

ctrl->data = devm_platform_ioremap_resource(pdev, 0);
if (IS_ERR(ctrl->data))
return PTR_ERR(ctrl->data);

ctrl->dir[0] = devm_platform_ioremap_resource(pdev, 1);
if (IS_ERR(ctrl->dir[0]))
return PTR_ERR(ctrl->dir[0]);

ctrl->dir[1] = devm_platform_ioremap_resource(pdev, 2);
if (IS_ERR(ctrl->dir[1]))
return PTR_ERR(ctrl->dir[1]);

ctrl->output = devm_platform_ioremap_resource(pdev, 3);
if (IS_ERR(ctrl->output))
return PTR_ERR(ctrl->output);

err = bgpio_init(&ctrl->gc, dev, 4, ctrl->data, NULL,
NULL, NULL, NULL, 0);
if (err)
return dev_err_probe(dev, err, "unable to init generic GPIO");

ctrl->gc.ngpio = AIROHA_GPIO_MAX;
ctrl->gc.owner = THIS_MODULE;
ctrl->gc.direction_output = airoha_dir_out;
ctrl->gc.direction_input = airoha_dir_in;
ctrl->gc.get_direction = airoha_get_dir;

return devm_gpiochip_add_data(dev, &ctrl->gc, ctrl);
}

The above function is used to allocate resources for the interrupts.It uses the platform_id_iomap_resources() API and returns the address of the resource for both address mapping and I/O Mapping. The API then uses these addresses to create the IRQ chip




NEXT




<s> static inline void aca_txin_sub_ack(struct dc_ep_dev *dev, u32 val)
{
if (WARN_ON(!dev))
return;
if (WARN_ON(!dev->priv))
return;

dc_aca_txin_sub_ack(dev->priv, val);
}

The above function is used to call the implementation defined sub-functions:

struct dc_acom_priv;
u32 dc_aca_txin_sub_ack(struct dc_acom_priv *priv, u32 val);

This function




NEXT




<s> static void set_subtitle(void)
{
struct subtitle_part *sp;
struct subtitle_list *pos, *tmp;

for (pos = subtitles; pos != NULL; pos = tmp) {
tmp = pos->next;
free(pos);
}

subtitles = NULL;
list_for_each_entry(sp, &trail, entries) {
if (sp->text) {
if (pos) {
pos->next = xcalloc(1, sizeof(*pos));
pos = pos->next;
} else {
subtitles = pos = xcalloc(1, sizeof(*pos));
}
pos->text = sp->text;
}
}

set_dialog_subtitles(subtitles);
}

The above function is used to set subtites.

If we see the struct dialog_subtitles structure:
struct dialog_subtitles {
char *text;
struct dialog_subtitles *next;
};

When text is parsed




NEXT




<s> gpio_keys_get_devtree_pdata(struct device *dev)
{
return NULL;
}

The above function is used to retrieve the platform data associated with a
device. In this case, we will set it to NULL because we don’t have any device
tree overlay associated with our hardware. If you had a device tree overlay,
you would need




NEXT




<s> static inline void sector_mark_bad(int num)
{
sectors[num / 8] &= ~(0x80 >> (num % 8));
};

The above function is used to mark a bad sector 0 or more in the buffer ‘sectors’ and its use is defined in the function int sector_mark(short num) in sdc.c as

static int sector_mark(short num)
{




NEXT




<s> static int gpio_latch_probe(struct platform_device *pdev)
{
struct gpio_latch_chip *glc;
struct gpio_chip *gc;
struct device *dev = &pdev->dev;
struct device_node *of_node = dev->of_node;
int i, n;

glc = devm_kzalloc(dev, sizeof(*glc), GFP_KERNEL);
if (!glc)
return -ENOMEM;

mutex_init(&glc->mutex);
mutex_init(&glc->latch_mutex);

n = gpiod_count(dev, NULL);
if (n <= 0) {
dev_err(dev, "failed to get gpios: %d\n", n);
return n;
} else if (n != GPIO_LATCH_LINES) {
dev_err(dev, "expected %d gpios\n", GPIO_LATCH_LINES);
return -EINVAL;
}

for (i = 0; i < n; i++) {
glc->gpios[i] = devm_gpiod_get_index_optional(dev, NULL, i,
GPIOD_OUT_LOW);
if (IS_ERR(glc->gpios[i])) {
if (PTR_ERR(glc->gpios[i]) != -EPROBE_DEFER) {
dev_err(dev, "failed to get gpio %d: %ld\n", i,
PTR_ERR(glc->gpios[i]));
}
return PTR_ERR(glc->gpios[i]);
}
}

glc->le_gpio = 8;
glc->le_active_low = gpiod_is_active_low(glc->gpios[glc->le_gpio]);

if (!glc->gpios[glc->le_gpio]) {
dev_err(dev, "missing required latch-enable gpio %d\n",
glc->le_gpio);
return -EINVAL;
}

gc = &glc->gc;
gc->label = GPIO_LATCH_DRIVER_NAME;
gc->can_sleep = true;
gc->base = -1;
gc->ngpio = GPIO_LATCH_LINES;
gc->get = gpio_latch_get;
gc->set = gpio_latch_set;
gc->direction_output = gpio_latch_direction_output;
gc->of_node = of_node;

platform_set_drvdata(pdev, glc);

i = gpiochip_add(&glc->gc);
if (i) {
dev_err(dev, "gpiochip_add() failed: %d\n", i);
return i;
}

return 0;
}

The above function is used to initialize the GPIO Latch driver to use the
required GPIO pins configured in the Device Tree. At present, the GPIO count is
set to 16 at the beginning of the file. Since we are using fixed GPIO numbers,
th




NEXT




<s> nisent = _yp_gettpent();
if(nisent != NULL) {
savepwent(tpw, &nisent->tp);
return &tpw->pebuf;
}

The above function is used to determine what file is used to save a user’s password.</s>




NEXT




<s> ret_t rtl8367c_setAsicShareMeter(rtk_uint32 index, rtk_uint32 rate, rtk_uint32 ifg)
{
ret_t retVal;

if(index > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(index < 32)
{
/*19-bits Rate*/
retVal = rtl8367c_setAsicReg(RTL8367C_METER_RATE_REG(index), rate&0xFFFF);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicReg(RTL8367C_METER_RATE_REG(index) + 1, (rate &0x70000) >> 16);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBit(RTL8367C_METER_IFG_CTRL_REG(index), RTL8367C_METER_IFG_OFFSET(index), ifg);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
/*19-bits Rate*/
retVal = rtl8367c_setAsicReg(RTL8367C_REG_METER32_RATE_CTRL0 + ((index-32) << 1), rate&0xFFFF);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicReg(RTL8367C_REG_METER32_RATE_CTRL0 + ((index-32) << 1) + 1, (rate &0x70000) >> 16);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_METER_IFG_CTRL2 + ((index-32) >> 4), RTL8367C_METER_IFG_OFFSET(index), ifg);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set each asic's share.

As shown in the above, the RTL8367C_METER_RATE_REG(index) should be in the range from 0x0720 to 0




NEXT




<s> static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to determine the amount of bytes to be read in
buffered streams.

yy_flex_read {
return yy_flex_read_buf(__FILE__,yyinbuf,yy_flex_strlen(yytext),YY_BUF




NEXT




<s> swconfig_trig_update_port_mask(struct led_trigger *trigger)
{
struct list_head *entry;
struct switch_led_trigger *sw_trig;
u32 port_mask;

if (!trigger)
return;

sw_trig = (void *) trigger;

port_mask = 0;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
spin_lock(&trigger->leddev_list_lock);
#else
read_lock(&trigger->leddev_list_lock);
#endif
list_for_each(entry, &trigger->led_cdevs) {
struct led_classdev *led_cdev;
struct swconfig_trig_data *trig_data;

led_cdev = list_entry(entry, struct led_classdev, trig_list);
trig_data = led_cdev->trigger_data;
if (trig_data) {
read_lock(&trig_data->lock);
port_mask |= trig_data->port_mask;
read_unlock(&trig_data->lock);
}
}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
spin_unlock(&trigger->leddev_list_lock);
#else
read_unlock(&trigger->leddev_list_lock);
#endif

sw_trig->port_mask = port_mask;

if (port_mask)
schedule_delayed_work(&sw_trig->sw_led_work,
SWCONFIG_LED_TIMER_INTERVAL);
else
cancel_delayed_work_sync(&sw_trig->sw_led_work);
}

The above function is used to update the port mask for the LED trigger. The function takes the pointer to the LED trigger as input and updates the port mask based on the devices registered with the trigger. The function iterates over each device associated with the trigger and checks if the associated




NEXT




<s> static ssize_t rtl8366_write_debugfs_reg(struct file *file,
const char __user *user_buf,
size_t count, loff_t *ppos)
{
struct rtl8366_smi *smi = (struct rtl8366_smi *)file->private_data;
unsigned long data;
u32 reg = smi->dbg_reg;
int err;
size_t len;
char *buf = smi->buf;

len = min(count, sizeof(smi->buf) - 1);
if (copy_from_user(buf, user_buf, len)) {
dev_err(smi->parent, "copy from user failed\n");
return -EFAULT;
}

buf[len] = '\0';
if (len > 0 && buf[len - 1] == '\n')
buf[len - 1] = '\0';


if (kstrtoul(buf, 16, &data)) {
dev_err(smi->parent, "Invalid reg value %s\n", buf);
} else {
err = rtl8366_smi_write_reg(smi, reg, data);
if (err) {
dev_err(smi->parent,
"writing reg 0x%04x val 0x%04lx failed\n",
reg, data);
}
}

return count;
}

The above function is used to write data to a specified FPGA register. The key lines of this function are:
// write to a specified FPGA register
err = rtl8366_smi_write_reg(smi, reg,




NEXT




<s> static int qca807x_config(struct phy_device *phydev)
{
struct device_node *node = phydev->mdio.dev.of_node;
int control_dac, ret = 0;
u32 of_control_dac;

/* Check for Combo port */
if (phy_read(phydev, QCA807X_CHIP_CONFIGURATION)) {
int psgmii_serdes;

/* Prevent PSGMII going into hibernation via PSGMII self test */
psgmii_serdes = phy_read_mmd(phydev, MDIO_MMD_PCS, PSGMII_MMD3_SERDES_CONTROL);
psgmii_serdes &= ~BIT(1);
ret = phy_write_mmd(phydev, MDIO_MMD_PCS,
PSGMII_MMD3_SERDES_CONTROL,
psgmii_serdes);
}

if (!of_property_read_u32(node, "qcom,control-dac", &of_control_dac)) {
control_dac = phy_read_mmd(phydev, MDIO_MMD_AN,
QCA807X_MMD7_1000BASE_T_POWER_SAVE_PER_CABLE_LENGTH);
control_dac &= ~QCA807X_CONTROL_DAC_MASK;
control_dac |= FIELD_PREP(QCA807X_CONTROL_DAC_MASK, of_control_dac);
ret = phy_write_mmd(phydev, MDIO_MMD_AN,
QCA807X_MMD7_1000BASE_T_POWER_SAVE_PER_CABLE_LENGTH,
control_dac);
}

/* Optionally configure LED-s */
if (IS_ENABLED(CONFIG_GPIOLIB)) {
/* Check whether PHY-s pins are used as GPIO-s */
if (!of_property_read_bool(node, "gpio-controller"))
ret = qca807x_led_config(phydev);
} else {
ret = qca807x_led_config(phydev);
}

return ret;
}

The above function is used to apply ESD protection to GRX_GPA_0 pin.

static void qca807x_configure_gpa_0_latch(struct phy_device_nfc *phydev)
{





NEXT




<s> static int en7523_pci_is_enabled(struct clk_hw *hw)
{
struct en_clk_gate *cg = container_of(hw, struct en_clk_gate, hw);

return !!(readl(cg->base + REG_PCI_CONTROL) & REG_PCI_CONTROL_REFCLK_EN1);
}

The above function is used to check that the PCI Clock, is enabled or not for given instance. We can say that it is a macro functionality. If we see the function and the variable it is clear to say that it is only used in the en7523




NEXT




<s> mt7530_set_port_pvid(struct switch_dev *dev, int port, int pvid)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

if (port >= MT7530_NUM_PORTS)
return -EINVAL;

if (pvid < MT7530_MIN_VID || pvid > MT7530_MAX_VID)
return -EINVAL;

priv->port_entries[port].pvid = pvid;

return 0;
}

The above function is used to configure the PVID for a specified port. It sets the PVID value of all packets that are tagged with one or more VLAN IDs in the port VLAN entries.

We can also modify the PVID for a given port




NEXT




<s> ret_t rtl8367c_getAsicOamCpuPri(rtk_uint32 *pPriority)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_OAM_PRIOIRTY_MASK, pPriority);
}

The above function is used to get the priority value in Asic which is used to generate priority queue in OAM process. When the Asic register value is 0x000000xx, the priority level is 6. When the Asic register is




NEXT




<s> int AT91F_MCI_SDCard_SendAppCommand (
AT91PS_MciDevice pMCI_Device,
unsigned int Cmd_App,
unsigned int Arg	)
{
unsigned int status;
//unsigned int	tick=0;

// Send the CMD55 for application specific command
AT91C_BASE_MCI->MCI_ARGR = (pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address << 16 );
AT91C_BASE_MCI->MCI_CMDR = AT91C_APP_CMD;

// wait for CMDRDY Status flag to read the response
do
{
status = AT91C_BASE_MCI->MCI_SR;
//tick++;
}
while( !(status & AT91C_MCI_CMDRDY) );//&& (tick<100) );

// if an error occurs
if (((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR) != 0 )
return ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);

// check if it is a specific command and then send the command
if ( (Cmd_App && AT91C_SDCARD_APP_ALL_CMD) == 0)
return AT91C_CMD_SEND_ERROR;

return( AT91F_MCI_SendCommand(pMCI_Device,Cmd_App,Arg) );
}

The above function is used to send application
specific commands to the SD Cards and it calls two more functions:
o AT91F_MCI_SendCommand
o AT91F_MCI_SendAppCommand

I am very new to embedded




NEXT




<s> static int md5_hmac_init_tfm(struct crypto_tfm *tfm)
{
struct md5_hmac_ctx *mctx = crypto_tfm_ctx(tfm);
mctx->temp = kzalloc(4 * MD5_HMAC_DBN_TEMP_SIZE, GFP_KERNEL);
if (IS_ERR(mctx->temp)) return PTR_ERR(mctx->temp);
mctx->desc = kzalloc(sizeof(struct shash_desc), GFP_KERNEL);
if (IS_ERR(mctx->desc)) return PTR_ERR(mctx->desc);

return 0;
}

The above function is used to initialize hmac_md5 transformation template as shown below

static int md5_hmac_crypt(unsigned char *inbuf, unsigned int inlen,
unsigned char *outbuf, int iv_size, void *scr




NEXT




<s> static inline void rb91x_nand_latch_lock(struct rb91x_nand_drvdata *drvdata,
int lock)
{
gpiod_set_value_cansleep(drvdata->gpio[RB91X_NAND_NLE], lock);
}

The above function is used to set clock of NAND lock which will cause the lock of NAND chip. But when gpiod_set_value_cansleep() was enabled the function will hang, which will cause a busy loop and eventually kill the NAND system




NEXT




<s> ar8236_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
{
u32 egress, ingress;
u32 pvid;

if (priv->vlan) {
pvid = priv->vlan_id[priv->pvid[port]];
if (priv->vlan_tagged & (1 << port))
egress = AR8216_OUT_ADD_VLAN;
else
egress = AR8216_OUT_STRIP_VLAN;
ingress = AR8216_IN_SECURE;
} else {
pvid = port;
egress = AR8216_OUT_KEEP;
ingress = AR8216_IN_PORT_ONLY;
}

ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
AR8216_PORT_CTRL_LEARN | AR8216_PORT_CTRL_VLAN_MODE |
AR8216_PORT_CTRL_SINGLE_VLAN | AR8216_PORT_CTRL_STATE |
AR8216_PORT_CTRL_HEADER | AR8216_PORT_CTRL_LEARN_LOCK,
AR8216_PORT_CTRL_LEARN |
(egress << AR8216_PORT_CTRL_VLAN_MODE_S) |
(AR8216_PORT_STATE_FORWARD << AR8216_PORT_CTRL_STATE_S));

ar8xxx_rmw(priv, AR8236_REG_PORT_VLAN(port),
AR8236_PORT_VLAN_DEFAULT_ID,
(pvid << AR8236_PORT_VLAN_DEFAULT_ID_S));

ar8xxx_rmw(priv, AR8236_REG_PORT_VLAN2(port),
AR8236_PORT_VLAN2_VLAN_MODE |
AR8236_PORT_VLAN2_MEMBER,
(ingress << AR8236_PORT_VLAN2_VLAN_MODE_S) |
(members << AR8236_PORT_VLAN2_MEMBER_S));
}

The above function is used to setup port mode on ar8xxx device. The first argument is the pointer to the chip’s private data, the second — the port number from 0 to 1. The third parameter is masks for each possible mode the port will have.




NEXT




<s> static void rtl83xx_config_interface(int port, phy_interface_t interface)
{
u32 old, int_shift, sds_shift;

switch (port) {
case 24:
int_shift = 0;
sds_shift = 5;
break;
case 26:
int_shift = 3;
sds_shift = 0;
break;
default:
return;
}

old = sw_r32(RTL838X_SDS_MODE_SEL);
switch (interface) {
case PHY_INTERFACE_MODE_1000BASEX:
if ((old >> sds_shift & 0x1f) == 4)
return;
sw_w32_mask(0x7 << int_shift, 1 << int_shift, RTL838X_INT_MODE_CTRL);
sw_w32_mask(0x1f << sds_shift, 4 << sds_shift, RTL838X_SDS_MODE_SEL);
break;
case PHY_INTERFACE_MODE_SGMII:
if ((old >> sds_shift & 0x1f) == 2)
return;
sw_w32_mask(0x7 << int_shift, 2 << int_shift, RTL838X_INT_MODE_CTRL);
sw_w32_mask(0x1f << sds_shift, 2 << sds_shift, RTL838X_SDS_MODE_SEL);
break;
default:
return;
}
pr_debug("configured port %d for interface %s\n", port, phy_modes(interface));
}

The above function is used to configure 1000 Base-T/1000BASE-X and SGMII interface to port24 and port26.  The configuration is basically to select one of the SDS mode to correspond to one of the




NEXT




<s> swconfig_dump_attr(struct swconfig_callback *cb, void *arg)
{
struct switch_attr *op = arg;
struct genl_info *info = cb->info;
struct sk_buff *msg = cb->msg;
int id = cb->args[0];
void *hdr;

hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &switch_fam,
NLM_F_MULTI, SWITCH_CMD_NEW_ATTR);
if (IS_ERR(hdr))
return -1;

if (nla_put_u32(msg, SWITCH_ATTR_OP_ID, id))
goto nla_put_failure;
if (nla_put_u32(msg, SWITCH_ATTR_OP_TYPE, op->type))
goto nla_put_failure;
if (nla_put_string(msg, SWITCH_ATTR_OP_NAME, op->name))
goto nla_put_failure;
if (op->description)
if (nla_put_string(msg, SWITCH_ATTR_OP_DESCRIPTION,
op->description))
goto nla_put_failure;

genlmsg_end(msg, hdr);
return msg->len;
nla_put_failure:
genlmsg_cancel(msg, hdr);
return -EMSGSIZE;
}

The above function is used to create a new attribute and store its values into a switch device.</s>




NEXT




<s> ulong get_timer_masked (void)
{
ulong now = READ_TIMER;		/* current tick value */

if (now >= gd->arch.lastinc) {		/* normal mode (non roll) */
/* move stamp fordward with absoulte diff ticks */
gd->arch.tbl += (now - gd->arch.lastinc);
} else {
/* we have rollover of incrementer */
gd->arch.tbl += ((TIMER_LOAD_VAL / (TIMER_CLOCK / CONFIG_SYS_HZ))
- gd->arch.lastinc) + now;
}
gd->arch.lastinc = now;
return gd->arch.tbl;
}

The above function is used to read the system tick time.</s>




NEXT




<s> BIGNUM *BN_value_one(void)
{
static BN_ULONG data_one=1L;
static BIGNUM const_one={&data_one,1,1,0};

return(&const_one);
}

The above function is used to get a (one) value in bignum.h file. I have two questions in this regard.

1) Why do we need to declare a BN_ULONG data_one=1L; as well as a B




NEXT




<s> void __init hiveap_330_pic_init(void)
{
struct mpic *mpic;

mpic = mpic_alloc(NULL, 0,
MPIC_BIG_ENDIAN |
MPIC_SINGLE_DEST_CPU,
0, 256, " OpenPIC  ");

BUG_ON(mpic == NULL);
mpic_init(mpic);
}

The above function is used to register the OpenPIC driver as a interrupt controller driver. When an interrupt controller driver is registered into system, it will register its platform data into dts with its associated devices and will get itself registered in the IRQ domain. If you want to




NEXT




<s> int RangeDecoderBitDecode(CProb *prob, CRangeDecoder *rd)
{
UInt32 bound = (rd->Range >> kNumBitModelTotalBits) * *prob;
if (rd->Code < bound)
{
rd->Range = bound;
*prob += (kBitModelTotal - *prob) >> kNumMoveBits;
if (rd->Range < kTopValue)
{
rd->Code = (rd->Code << 8) | ReadByte;
rd->Range <<= 8;
}
return 0;
}
else
{
rd->Range -= bound;
rd->Code -= bound;
*prob -= (*prob) >> kNumMoveBits;
if (rd->Range < kTopValue)
{
rd->Code = (rd->Code << 8) | ReadByte;
rd->Range <<= 8;
}
return 1;
}
}

The above function is used to decode bits from a bit model (a bit model is a mapping from a list of ints to a list of ints with each int representing probability). A bit model can be either static or dynamic and each bit model has a specified number of bit




NEXT




<s> u64 rtl838x_get_port_reg(int reg)
{
return ((u64)sw_r32(reg));
}

The above function is used to read register of rt7611 and then cast to u62.

According to ARM documentation, reading register should be done as following:
mov r0, <register map>
mov <register>, r0
so




NEXT




<s> YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to create a buffer for parsing a string.
Pass the function a pointer to the string and the size of the string.

This file and all other source files must be included using these two lines of code at the start of the file.




NEXT




<s> static inline uint8_t sector_get_good(int num)
{
return sectors[num / 8] & 0x80 >> (num % 8);
};

The above function is used to check if a sector has good blocks or not.

If you read the memory, and this function returns true, then the memory hasn't died yet. If you read the memory, and this function returns false, at some point the memory




NEXT




<s> rtk_api_ret_t rtk_mirror_portBased_get(rtk_port_t *pMirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask)
{
rtk_api_ret_t retVal;
rtk_port_t source_port;
rtk_enable_t mirRx, mirTx;
rtk_uint32 sport, mport, pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pMirrored_rx_portmask)
return RT_ERR_NULL_POINTER;

if(NULL == pMirrored_tx_portmask)
return RT_ERR_NULL_POINTER;

if(NULL == pMirroring_port)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortMirror(&sport, &mport)) != RT_ERR_OK)
return retVal;
source_port = rtk_switch_port_P2L_get(sport);
*pMirroring_port = rtk_switch_port_P2L_get(mport);

if ((retVal = rtl8367c_getAsicPortMirrorRxFunction((rtk_uint32*)&mirRx)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicPortMirrorTxFunction((rtk_uint32*)&mirTx)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicPortMirrorMask(&pmask)) != RT_ERR_OK)
return retVal;

if (DISABLED == mirRx)
pMirrored_rx_portmask->bits[0]=0;
else
{
if ((retVal = rtk_switch_portmask_P2L_get(pmask, pMirrored_rx_portmask)) != RT_ERR_OK)
return retVal;
pMirrored_rx_portmask->bits[0] |= 1<<source_port;
}

if (DISABLED == mirTx)
pMirrored_tx_portmask->bits[0]=0;
else
{
if ((retVal = rtk_switch_portmask_P2L_get(pmask, pMirrored_tx_portmask)) != RT_ERR_OK)
return retVal;
pMirrored_tx_portmask->bits[0] |= 1<<source_port;
}

return RT_ERR_OK;

}

The above function is used to read the content of portBased mirror.  It will return 3 parameters to user: mirror_port, mirrored_rx_portmask, mirrored_tx_portmask, and these parameters will be given in the following way




NEXT




<s> void rtl8366_smi_cleanup(struct rtl8366_smi *smi)
{
rtl8366_debugfs_remove(smi);
rtl8366_smi_mii_cleanup(smi);
__rtl8366_smi_cleanup(smi);
}

The above function is used to stop smi driver.

And before you compile the driver, you must unload driver, because unload
r8366s_smi.ko is very very hard, just like ifup/ifdown network port.




NEXT




<s> static int rtl83xx_port_lower_walk(struct net_device *lower, struct netdev_nested_priv *_priv)
{
struct rtl83xx_walk_data *data = (struct rtl83xx_walk_data *)_priv->data;
struct rtl838x_switch_priv *priv = data->priv;
int ret = 0;
int index;

index = rtl83xx_port_is_under(lower, priv);
data->port = index;
if (index >= 0) {
pr_debug("Found DSA-port, index %d\n", index);
ret = 1;
}

return ret;
}

The above function is used to determine a specific port belonging to DSA, by first looping through the different ports of the DSA, and checking if each port has a lower device (an upper device can be a network interface). The lower device will be a r81




NEXT




<s> static void dma_start_write(const ulong* buffer, int num_bytes)
{
// Assemble complete memory settings
oxnas_dma_device_settings_t mem_settings = oxnas_ram_dma_settings;
mem_settings.address_ = (unsigned long) buffer;
mem_settings.address_mode_ = OXNAS_DMA_MODE_INC;

writel(encode_control_status(&mem_settings, &oxnas_sata_dma_settings),
SATA_DMA_REGS_BASE + DMA_CTRL_STATUS);
writel(mem_settings.address_, SATA_DMA_REGS_BASE + DMA_BASE_SRC_ADR);
writel(oxnas_sata_dma_settings.address_,
SATA_DMA_REGS_BASE + DMA_BASE_DST_ADR);
writel(encode_final_eot(&mem_settings, &oxnas_sata_dma_settings,
num_bytes),
SATA_DMA_REGS_BASE + DMA_BYTE_CNT);

dma_start();
}

The above function is used to start memory transfers. It takes care of setting up
the control/status register and the source and destination address registers. However
it does not actually start data transfers, since DMA does not start unless both the
destination address or the source




NEXT




<s> static int get_mext_match(const char *match_str, match_f flag)
{
int match_start, index;

/* Do not search if the menu is empty (i.e. items_num == 0) */
match_start = item_index(current_item(curses_menu));
if (match_start == ERR)
return -1;

if (flag == FIND_NEXT_MATCH_DOWN)
++match_start;
else if (flag == FIND_NEXT_MATCH_UP)
--match_start;

match_start = (match_start + items_num) % items_num;
index = match_start;
while (true) {
char *str = k_menu_items[index].str;
if (strcasestr(str, match_str) != NULL)
return index;
if (flag == FIND_NEXT_MATCH_UP ||
flag == MATCH_TINKER_PATTERN_UP)
--index;
else
++index;
index = (index + items_num) % items_num;
if (index == match_start)
return -1;
}
}

The above function is used to find an item that matches a search string, or to skip to the next or previous item. When the value of the current item is updated, the previous highlighted item is unhighlighted, regardless of whether `refresh_item` function is called




NEXT




<s> void rtcl_ccu_log_late(void)
{
struct rtcl_clk *rclk;
bool overclock = false;
char clkinfo[80], msg[255] = "rate setting enabled";

for (int clk_idx = 0; clk_idx < CLK_COUNT; clk_idx++) {
rclk = &rtcl_ccu->clks[clk_idx];
overclock |= rclk->max > rclk->startup;
sprintf(clkinfo, ", %s %lu-%lu MHz", rtcl_clk_info[clk_idx].display_name,
rclk->min / 1000000, rclk->max / 1000000);
strcat(msg, clkinfo);
}
if (overclock)
strcat(msg, ", OVERCLOCK AT OWN RISK");

dev_info(&rtcl_ccu->pdev->dev, "%s\n", msg);
}

The above function is used to print the configuration information of the RTC clock controller.The function will print the names of each clock, as well as the starting and the maximum time value.</s>




NEXT




<s> static void mt7620_txcsum_config(bool enable)
{
if (enable)
fe_w32(fe_r32(MT7620A_CDMA_CSG_CFG) | (CDMA_ICS_EN |
CDMA_UCS_EN | CDMA_TCS_EN),
MT7620A_CDMA_CSG_CFG);
else
fe_w32(fe_r32(MT7620A_CDMA_CSG_CFG) & ~(CDMA_ICS_EN |
CDMA_UCS_EN | CDMA_TCS_EN),
MT7620A_CDMA_CSG_CFG);
}

The above function is used to configure the MT7620A chip to run or stop
computation of checksum of Crypto Frames (Transmitter Checksum).
It is used when running the
test-suite test
net/testing/testing/




NEXT




<s> static int find_header(uint8_t *buf, uint32_t buf_size,
struct data_header **data_table)
{
uint8_t *tmp_buf = buf + start_offset;
uint8_t tmp_hdr[4] = { STAG_ID, STAG_ID, (STAG_MAGIC & 0xFF), (STAG_MAGIC >> 8) };
struct csxf_header *tmp_csxf_header;
uint16_t tmp_checksum = 0;
uint16_t data_header_counter = 0;
int ret = EXIT_FAILURE;

VERBOSE("Looking for STAG header!");

while ((uint32_t) tmp_buf - (uint32_t) buf <= buf_size) {
if (!memcmp(tmp_buf, tmp_hdr, 4)) {
if (((struct stag_header *)tmp_buf)->tag_checksum ==
(uint16_t) ~jboot_checksum(0, (uint16_t *) tmp_buf,
STAG_SIZE - 2)) {
VERBOSE("Found proper STAG header at: 0x%X.",
tmp_buf - buf);
break;
}
}
tmp_buf++;
}

tmp_csxf_header = (struct csxf_header *)(tmp_buf + STAG_SIZE);
if (tmp_csxf_header->magic != CSXF_MAGIC) {
ERR("CSXF magic incorrect! 0x%X != 0x%X",
tmp_csxf_header->magic, CSXF_MAGIC);
goto out;
}
VERBOSE("CSXF magic ok.");
tmp_checksum = tmp_csxf_header->checksum;
tmp_csxf_header->checksum = 0;

tmp_csxf_header->checksum =
(uint16_t) ~jboot_checksum(0, (uint16_t *) (tmp_buf + STAG_SIZE),
tmp_csxf_header->raw_length +
CSXF_SIZE);

if (tmp_checksum != tmp_csxf_header->checksum) {
ERR("CSXF checksum incorrect! Stored: 0x%X Calculated: 0x%X",
tmp_checksum, tmp_csxf_header->checksum);
goto out;
}
VERBOSE("CSXF image checksum ok.");

tmp_buf = tmp_buf + STAG_SIZE + CSXF_SIZE;

while ((uint32_t) tmp_buf - (uint32_t) buf <= buf_size) {

struct data_header *tmp_data_header =
(struct data_header *)tmp_buf;

if (tmp_data_header->unknown != DATA_HEADER_UNKNOWN) {
tmp_buf++;
continue;
}
if (tmp_data_header->type != DATA_HEADER_EEPROM
&& tmp_data_header->type != DATA_HEADER_CONFIG) {
tmp_buf++;
continue;
}

data_table[data_header_counter] = tmp_data_header;
tmp_buf +=
DATA_HEADER_SIZE + data_table[data_header_counter]->length;
data_header_counter++;

}

ret = data_header_counter;

out:
return ret;
}

The above function is used to extract the bootloader parameters from the bootloader JBI boot image. The function starts at address 0x024468C0 and ends at address 0x02449FE0.</s>




NEXT




<s> ret_t rtl8367c_setAsicStormFilterExtUnknownUnicastEnable(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_UNKNOWN_UCAST_EXT_EN_OFFSET, enabled);
}

The above function is used to set storm extension filter to check RX packets from ports.If storm filter detects unkown unicast packet from specific port, it disable MAC learning function for that  port.

When a mac address learning function has to done for




NEXT




<s> int rtl8366_sw_get_port_mib(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
int i, len = 0;
unsigned long long counter = 0;
char *buf = smi->buf;

if (val->port_vlan >= smi->num_ports)
return -EINVAL;

len += snprintf(buf + len, sizeof(smi->buf) - len,
"Port %d MIB counters\n",
val->port_vlan);

for (i = 0; i < smi->num_mib_counters; ++i) {
len += snprintf(buf + len, sizeof(smi->buf) - len,
"%-36s: ", smi->mib_counters[i].name);
if (!smi->ops->get_mib_counter(smi, i, val->port_vlan,
&counter))
len += snprintf(buf + len, sizeof(smi->buf) - len,
"%llu\n", counter);
else
len += snprintf(buf + len, sizeof(smi->buf) - len,
"%s\n", "error");
}

val->value.s = buf;
val->len = len;
return 0;
}

The above function is used to get Port MIb Counters of the given port from PSE
registers.
The port index passed into this routine should be port index in PSE and
not port index in switch.



int rtl836




NEXT




<s> void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to set a link rate

static unsigned int g_last_tx_link_rate[2]

={

};

static int g_tx_sync_status[2] = {0};

Set the sync




NEXT




<s> ret_t rtl8367c_setAsicOutputQueueMappingIndex(rtk_uint32 port, rtk_uint32 index )
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(index >= RTL8367C_QUEUENO)
return RT_ERR_QUEUE_NUM;

return rtl8367c_setAsicRegBits(RTL8367C_QOS_PORT_QUEUE_NUMBER_REG(port), RTL8367C_QOS_PORT_QUEUE_NUMBER_MASK(port), index);
}

The above function is used to set the queues indexs on port X.

If you need to configure the queues index on port 1 to be [0, X, Y, Z].

You should call this function multiple times as:

RT




NEXT




<s> static int b53_mmap_read8(struct b53_device *dev, u8 page, u8 reg, u8 *val)
{
u8 __iomem *regs = dev->priv;

*val = readb(regs + (page << 8) + reg);

return 0;
}

The above function is used to read an 8-bit register from the RTC.  The
argument 'val' points to an 8-bit variable that should be set to the value
of the register.

This function is used by the "b5




NEXT




<s> int dc_ep_gpio_dir(struct dc_ep_priv *priv, u32 gpio, int dir)
{
struct dc_aca *aca = to_aca(priv);

if (gpio > aca->max_gpio)
return -EINVAL;

if ((dir != GPIO_DIR_IN) && (dir != GPIO_DIR_OUT))
return -EINVAL;

if (dir == GPIO_DIR_IN)
wr32(BIT(gpio), GPIO_DIRCLR);
else
wr32(BIT(gpio), GPIO_DIRSET);
return 0;
}

The above function is used to change the direction of GPIO pins that are exported as general purpose I/O. After changing the direction, the IO data can be read or written.

Below is the example of DC_EP_GPIO_DIR interface used in




NEXT




<s> static void aca_sram_desc_parse(struct dc_ep_priv *priv, const char *data,
u32 sid)
{
u32 dbase, dnum;
struct aca_sram_desc *desc_base;
struct aca_mem_layout *mem_layout = to_mem_layout(priv);
struct aca_pdmem_layout *pdmem = to_pdmem_layout(priv);

desc_base = (struct aca_sram_desc *)data;
dbase = be32_to_cpu(desc_base->dbase);
dnum = be32_to_cpu(desc_base->dnum);

dev_dbg(priv->dev, "Sec %s desc base 0x%08x, des_num: %d\n",
sec_id_to_str(sid), dbase, dnum);

switch (sid) {
case ACA_SEC_MEM_TXIN:
mem_layout->txin_host_desc_base = dbase;
mem_layout->txin_host_dnum = dnum;
break;

case ACA_SEC_MEM_TXOUT:
mem_layout->txout_host_desc_base = dbase;
mem_layout->txout_host_dnum = dnum;
break;

case ACA_SEC_MEM_RXIN:
mem_layout->rxin_host_desc_base = dbase;
mem_layout->rxin_host_dnum = dnum;
break;

case ACA_SEC_MEM_RXOUT:
mem_layout->rxout_host_desc_base = dbase;
mem_layout->rxout_host_dnum = dnum;
break;
case ACA_SEC_MEM_TXIN_PDRING:
pdmem->txin_pd_desc_base = dbase;
pdmem->txin_pd_dnum = dnum;
break;
case ACA_SEC_MEM_TXOUT_PDRING:
pdmem->txout_pd_desc_base = dbase;
pdmem->txout_pd_dnum = dnum;
break;
case ACA_SEC_MEM_RXIN_PDRING:
pdmem->rxin_pd_desc_base = dbase;
pdmem->rxin_pd_dnum = dnum;
break;
case ACA_SEC_MEM_RXOUT_PDRING:
pdmem->rxin_pd_desc_base = dbase;
pdmem->rxin_pd_dnum = dnum;
break;
default:
dev_err(priv->dev, "Unknow aca sram section %d\n", sid);
break;
}
}

The above function is used to parse ACA sram section data. We are only interested in ACA_SEC_MEM_TXIN_PDRING in this case.</s>




NEXT




<s> static int rtl8367_extif_set_mode(struct rtl8366_smi *smi, int id,
enum rtl8367_extif_mode mode)
{
int err;

/* set port mode */
switch (mode) {
case RTL8367_EXTIF_MODE_RGMII:
case RTL8367_EXTIF_MODE_RGMII_33V:
REG_WR(smi, RTL8367_CHIP_DEBUG0_REG, 0x0367);
REG_WR(smi, RTL8367_CHIP_DEBUG1_REG, 0x7777);
break;

case RTL8367_EXTIF_MODE_TMII_MAC:
case RTL8367_EXTIF_MODE_TMII_PHY:
REG_RMW(smi, RTL8367_BYPASS_LINE_RATE_REG,
BIT((id + 1) % 2), BIT((id + 1) % 2));
break;

case RTL8367_EXTIF_MODE_GMII:
REG_RMW(smi, RTL8367_CHIP_DEBUG0_REG,
RTL8367_CHIP_DEBUG0_DUMMY0(id),
RTL8367_CHIP_DEBUG0_DUMMY0(id));
REG_RMW(smi, RTL8367_EXT_RGMXF_REG(id), BIT(6), BIT(6));
break;

case RTL8367_EXTIF_MODE_MII_MAC:
case RTL8367_EXTIF_MODE_MII_PHY:
case RTL8367_EXTIF_MODE_DISABLED:
REG_RMW(smi, RTL8367_BYPASS_LINE_RATE_REG,
BIT((id + 1) % 2), 0);
REG_RMW(smi, RTL8367_EXT_RGMXF_REG(id), BIT(6), 0);
break;

default:
dev_err(smi->parent,
"invalid mode for external interface %d\n", id);
return -EINVAL;
}

REG_RMW(smi, RTL8367_DIS_REG,
RTL8367_DIS_RGMII_MASK << RTL8367_DIS_RGMII_SHIFT(id),
mode << RTL8367_DIS_RGMII_SHIFT(id));

return 0;
}

The above function is used to

set port mode (see enum rtl8367_extif_mode).

set/unset the MDIO interface (see
rtl8367_extif_{read,write}_mdio).




NEXT




<s> static inline struct aca_hif_params *to_hif_params(struct dc_ep_priv *priv)
{
return priv->aca.hif_params;
}

The above function is used to return the address of the struct aca_hif_params
that is associated with this EP.

static int aca_wait_for_resource(struct aca_hif_priv *priv, dma_addr_




NEXT




<s> static int rtl8367b_get_vlan_mc(struct rtl8366_smi *smi, u32 index,
struct rtl8366_vlan_mc *vlanmc)
{
u32 data[RTL8367B_VLAN_MC_NUM_WORDS];
int err;
int i;

memset(vlanmc, '\0', sizeof(struct rtl8366_vlan_mc));

if (index >= RTL8367B_NUM_VLANS)
return -EINVAL;

for (i = 0; i < ARRAY_SIZE(data); i++)
REG_RD(smi, RTL8367B_VLAN_MC_BASE(index) + i, &data[i]);

vlanmc->member = (data[0] >> RTL8367B_VLAN_MC0_MEMBER_SHIFT) &
RTL8367B_VLAN_MC0_MEMBER_MASK;
vlanmc->fid = (data[1] >> RTL8367B_VLAN_MC1_FID_SHIFT) &
RTL8367B_VLAN_MC1_FID_MASK;
vlanmc->vid = (data[3] >> RTL8367B_VLAN_MC3_EVID_SHIFT) &
RTL8367B_VLAN_MC3_EVID_MASK;

return 0;
}

The above function is used to retrieve the MAC address and filter ids for
given VLAN entry. The above function uses RTL8367B_VLAN_MC_BASE to access
the members of the structure. For each field we compute the register





NEXT




<s> radius_count_attrs(struct blob_attr **tb, int *n_attr, size_t *attr_size)
{
struct blob_attr *data = tb[USER_ATTR_RADIUS];
struct blob_attr *cur;
int rem;

blobmsg_for_each_attr(cur, data, rem) {
struct radius_parse_attr_data *data;
size_t prev = *attr_size;

data = radius_parse_attr(cur);
if (!data)
continue;

*attr_size += data->size;
if (data->vendor)
*attr_size += VENDOR_ATTR_SIZE;

(*n_attr)++;
}

*n_attr += !!tb[USER_ATTR_VLAN] * 3 +
!!tb[USER_ATTR_MAX_RATE_UP] +
!!tb[USER_ATTR_MAX_RATE_DOWN];
*attr_size += !!tb[USER_ATTR_VLAN] * (4 + 4 + 5) +
!!tb[USER_ATTR_MAX_RATE_UP] * (4 + VENDOR_ATTR_SIZE) +
!!tb[USER_ATTR_MAX_RATE_DOWN] * (4 + VENDOR_ATTR_SIZE);
}

The above function is used to calculate the size of a radius event. It is used
in the radius_count_events_till function below. In the below function we need to
calculate the total number of events. For this, we need to read all the




NEXT




<s> static void band_border_status(int fd, DSL_AccessDir_t direction) {
IOCTL(DSL_BandBorderStatus_t, DSL_FIO_BAND_BORDER_STATUS_GET);

void *c, *c2;

c = blobmsg_open_array(&b, "limits");

for (size_t i = 0; i < out.data.nNumData; i++) {
c2 = blobmsg_open_table(&b, "");
blobmsg_add_u16(&b, "first", out.data.nBandLimits[i].nFirstToneIndex);
blobmsg_add_u16(&b, "last", out.data.nBandLimits[i].nLastToneIndex);
blobmsg_close_table(&b, c2);
}

blobmsg_close_array(&b, c);
}

The above function is used to access limits for upstream/download band by issuing the DSL_FIO_BAND_BORDER_STATUS_GET request, but which is not implemented in DSL chip. The output of the function is stored in the *out




NEXT




<s> static inline void nfi_write16(struct mt7621_nfc *nfc, u32 reg, u16 val)
{
writew(val, nfc->nfi_regs + reg);
}

The above function is used to write the val in the
following register location:

000150de: 55 4e 4e 52 4f 50 47 55   34 e5




NEXT




<s> ar8327_phy_fixup(struct ar8xxx_priv *priv, int phy)
{
switch (priv->chip_rev) {
case 1:
/* For 100M waveform */
ar8xxx_phy_dbg_write(priv, phy, 0, 0x02ea);
/* Turn on Gigabit clock */
ar8xxx_phy_dbg_write(priv, phy, 0x3d, 0x68a0);
break;

case 2:
ar8xxx_phy_mmd_write(priv, phy, 0x7, 0x3c, 0x0);
fallthrough;
case 4:
ar8xxx_phy_mmd_write(priv, phy, 0x3, 0x800d, 0x803f);
ar8xxx_phy_dbg_write(priv, phy, 0x3d, 0x6860);
ar8xxx_phy_dbg_write(priv, phy, 0x5, 0x2c46);
ar8xxx_phy_dbg_write(priv, phy, 0x3c, 0x6000);
break;
}
}

The above function is used to set up the physical layer
(PHY) on all AR8327 based devices that are used in the
OpenWrt Linux firmware. The above function is also used on
the AR71xx platform.

Now,




NEXT




<s> static void __attribute__((noreturn)) pperror(const char *format, ...)
{
va_list ap;

fprintf(stderr, "%s:%d: ", current_file->name, yylineno);
va_start(ap, format);
vfprintf(stderr, format, ap);
va_end(ap);
fprintf(stderr, "\n");

exit(1);
}

The above function is used to display the error message related to the current file, current row number in the input file and terminating the program.
Now the only thing remaining is to modify the parser in order to trigger pperror when the parser reports an error. The Y




NEXT




<s> static int rtl8367b_sw_get_port_stats(struct switch_dev *dev, int port,
struct switch_port_stats *stats)
{
return (rtl8366_sw_get_port_stats(dev, port, stats,
RTL8367B_MIB_TXB_ID, RTL8367B_MIB_RXB_ID));
}

The above function is used to get port stats for a given port. Note that we use
the generic function provided by rtl8366.h to get stats. The last part here
replaces the previous value for the RTL8367B




NEXT




<s> static u64 rtl839x_l2_hash_seed(u64 mac, u32 vid)
{
u64 v = vid;

v <<= 48;
v |= mac;

return v;
}

The above function is used to create an L2 hash which is used as a key for the multicast hash tables in rtl8390.c. This value is then used to access one of the arrays which contains the actual table entries. Below is the function




NEXT




<s> void draw4field(void *videoram, const struct pixelformat *pixf, const struct vidsize *vids){
struct rect r;
struct colour c;
int height, width;
c.r = 1;	// only used for the indexed modes, r is taken as index
height = vids->height;
width = vids->width;

r.height = height>>1;
r.width = width>>1;
r.x = 0;	r.y = 0;
if (pixf->pixenum==CLUT4||pixf->pixenum==CLUT8) r.col = &c;
else r.col = &colourtable[1];
drawrect (videoram, &r, pixf, vids);

r.x = width/2;	r.y = 0;
if (pixf->pixenum==CLUT4||pixf->pixenum==CLUT8) c.r = 2;
else r.col = &colourtable[2];
drawrect (videoram, &r, pixf, vids);

r.x = 0;	r.y = height/2;
if (pixf->pixenum==CLUT4||pixf->pixenum==CLUT8) c.r = 3;
else r.col = &colourtable[3];
drawrect (videoram, &r, pixf, vids);

r.x = width/2;	r.y = height/2;
if (pixf->pixenum==CLUT4||pixf->pixenum==CLUT8) c.r = 0;
else r.col = &colourtable[0];
drawrect (videoram, &r, pixf, vids);
}

The above function is used to draw four different areas of different (indexed) colours in one go. I have tested it in both a 640x480xCLUT4 and a 640x480xCLUT8 mode to




NEXT




<s> ret_t rtl8367c_getAsicSvlanTrapPriority(rtk_uint32* pPriority)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_SVLAN_PRIOIRTY_MASK, pPriority);
}

The above function is used to get the SVLAN priority setting in Trap mode.

In the past implementation, the user defined SVLAN priority
will be set for the port which is enabled QoS.  However, there is a scenario
that an AS port




NEXT




<s> IFX_MEI_IRQEnable (DSL_DEV_Device_t * pDev)
{
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_ARC2ME_MASK, MSGAV_EN);
}

The above function is used to enable the interrupt(s) that we have asked to receive from the MEI.

In the DSL_DEV_StartTask function the above function is executed. For the moment it is only executed once and the interrupts have to be




NEXT




<s> static DSL_DEV_MeiError_t IFX_MEI_ArcJtagEnable (DSL_DEV_Device_t *, int);
static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to indicate the link-rate changes on the TX_LINK and ODENI_LINK link of the ARC MUX unit. This data is then sent to the kernel.

If for some reason, the link is already up and then




NEXT




<s> static int rtl8231_gpio_get(struct gpio_chip *gc, unsigned int offset)
{
u16 state = 0;
struct rtl8231_gpios *gpios = gpiochip_get_data(gc);

mutex_lock(&miim_lock);
rtl8231_pin_get(gpios, offset, &state);
mutex_unlock(&miim_lock);

if (state & (1 << (offset % 16)))
return 1;

return 0;
}

The above function is used to read a pin value.
The pin_state is returned in the state local varaible.
The pin_state should be the state of the pin being read.
The pins are configured as:0x88(0xC




NEXT




<s> static void rtl93xx_phylink_mac_link_down(struct dsa_switch *ds, int port,
unsigned int mode,
phy_interface_t interface)
{
struct rtl838x_switch_priv *priv = ds->priv;
u32 v = 0;

/* Stop TX/RX to port */
sw_w32_mask(0x3, 0, priv->r->mac_port_ctrl(port));

/* No longer force link */
if (priv->family_id == RTL9300_FAMILY_ID)
v = RTL930X_FORCE_EN | RTL930X_FORCE_LINK_EN;
else if (priv->family_id == RTL9310_FAMILY_ID)
v = RTL931X_FORCE_EN | RTL931X_FORCE_LINK_EN;
sw_w32_mask(v, 0, priv->r->mac_force_mode_ctrl(port));
}

The above function is used to stop force to port when a MAC link fails.
When it comes to debug the problems in link down conditions, we really
can't be sure whether the link really failed or just stopped due to
force_port command. This patch adds




NEXT




<s> void wpas_ucode_event(struct wpa_supplicant *wpa_s, int event, union wpa_event_data *data)
{
const char *state;
uc_value_t *val;

if (event != EVENT_CH_SWITCH_STARTED)
return;

val = wpa_ucode_registry_get(iface_registry, wpa_s->ucode.idx);
if (!val)
return;

if (wpa_ucode_call_prepare("event"))
return;

uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
uc_value_push(ucv_get(val));
uc_value_push(ucv_get(ucv_string_new(event_to_string(event))));
val = ucv_object_new(vm);
uc_value_push(ucv_get(val));

if (event == EVENT_CH_SWITCH_STARTED) {
ucv_object_add(val, "csa_count", ucv_int64_new(data->ch_switch.count));
ucv_object_add(val, "frequency", ucv_int64_new(data->ch_switch.freq));
ucv_object_add(val, "sec_chan_offset", ucv_int64_new(data->ch_switch.ch_offset));
ucv_object_add(val, "center_freq1", ucv_int64_new(data->ch_switch.cf1));
ucv_object_add(val, "center_freq2", ucv_int64_new(data->ch_switch.cf2));
}

ucv_put(wpa_ucode_call(4));
ucv_gc(vm);
}

The above function is used to push an event into the uCode VM.</s>




NEXT




<s> void rtl838x_traffic_disable(int source, int dest)
{
rtl838x_mask_port_reg(BIT(dest), 0, rtl838x_port_iso_ctrl(source));
}

The above function is used to disable a specific port (dest) and it
works OK with the source port as root_port.

Now, when I use the source port as any other port than root_port (such
as port 3) , the function




NEXT




<s> static void g997_rate_adaptation_status(int fd, DSL_AccessDir_t direction) {
#ifndef INCLUDE_DSL_CPE_API_DANUBE
IOCTL_DIR(DSL_G997_RateAdaptationStatus_t, DSL_FIO_G997_RATE_ADAPTATION_STATUS_GET, direction);

int map = RAMODE_MAP_UNKNOWN;
const char *str;
switch (out.data.RA_MODE) {
STR_CASE_MAP(DSL_G997_RA_MODE_MANUAL, "Manual", RAMODE_MAP_MANUAL)
STR_CASE_MAP(DSL_G997_RA_MODE_AT_INIT, "At initialization", RAMODE_MAP_AT_INIT)
STR_CASE_MAP(DSL_G997_RA_MODE_DYNAMIC, "Dynamic", RAMODE_MAP_DYNAMIC)
STR_CASE_MAP(DSL_G997_RA_MODE_DYNAMIC_SOS, "Dynamic with SOS", RAMODE_MAP_DYNAMIC_SOS)
default:
str = NULL;
break;
};

if (str)
m_str("ra_mode", str);

if (map != PSTATE_MAP_UNKNOWN)
m_u32("ra_mode_num", map);
#endif
}

The above function is used to obtain G.997.1 rate adaptation status parameters. It is typically used to determine the rate adaptation mode which can be one of the following:

- DSL_G997_RA_MODE_MANUAL: Rate




NEXT




<s> void board_init(void)
{
tlwr1043nd_init();
mr18_init();
}

The above function is used to initialize the board and the components.

The function tlwr1043nd_init() is used to configure the TWR-1043ND’s on-board LCD display, backlights, and buttons.




NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_state_set(rtk_port_t port, rtk_filter_state_t state)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if(state >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if((ret = rtl8367c_setAsicAcl(rtk_switch_port_L2P_get(port), state)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to set the MAC address learning state of the specified port to enable or disable. By default, when the switch port is newly added, the default behavior is to learn the MAC address of the ingress frame. By default, the default state is to learn




NEXT




<s> rtk_api_ret_t rtk_l2_addr_del(rtk_mac_t *pMac, rtk_l2_ucastAddr_t *pL2_data)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* must be unicast address */
if ((pMac == NULL) || (pMac->octet[0] & 0x1))
return RT_ERR_MAC;

if (pL2_data->fid > RTL8367C_FIDMAX || pL2_data->efid > RTL8367C_EFIDMAX)
return RT_ERR_L2_FID;

memset(&l2Table, 0, sizeof(rtl8367c_luttb));

/* fill key (MAC,FID) to get L2 entry */
memcpy(l2Table.mac.octet, pMac->octet, ETHER_ADDR_LEN);
l2Table.ivl_svl     = pL2_data->ivl;
l2Table.cvid_fid    = pL2_data->cvid;
l2Table.fid         = pL2_data->fid;
l2Table.efid        = pL2_data->efid;
method = LUTREADMETHOD_MAC;
retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
if (RT_ERR_OK ==  retVal)
{
memcpy(l2Table.mac.octet, pMac->octet, ETHER_ADDR_LEN);
l2Table.ivl_svl     = pL2_data->ivl;
l2Table.cvid_fid    = pL2_data->cvid;
l2Table.fid = pL2_data->fid;
l2Table.efid = pL2_data->efid;
l2Table.spa = 0;
l2Table.nosalearn = 0;
l2Table.sa_block = 0;
l2Table.da_block = 0;
l2Table.auth = 0;
l2Table.age = 0;
l2Table.lut_pri = 0;
l2Table.sa_en = 0;
l2Table.fwd_en = 0;
if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
return retVal;

pL2_data->address = l2Table.address;
return RT_ERR_OK;
}
else
return retVal;
}

The above function is used to remove the specified address from the unicast MAC address table.</s>




NEXT




<s> rtk_api_ret_t rtk_stat_logging_counterCfg_get(rtk_uint32 idx, rtk_logging_counter_mode_t *pMode, rtk_logging_counter_type_t *pType)
{
rtk_api_ret_t   retVal;
rtk_uint32      type, mode;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(idx > RTL8367C_MIB_MAX_LOG_CNT_IDX)
return RT_ERR_OUT_OF_RANGE;

if((idx % 2) == 1)
return RT_ERR_INPUT;

if(pMode == NULL)
return RT_ERR_NULL_POINTER;

if(pType == NULL)
return RT_ERR_NULL_POINTER;

if((retVal = rtl8367c_getAsicMIBsLoggingType((idx / 2), &type)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicMIBsLoggingMode((idx / 2), &mode)) != RT_ERR_OK)
return retVal;

*pMode = (rtk_logging_counter_mode_t)mode;
*pType = (rtk_logging_counter_type_t)type;

return RT_ERR_OK;
}

The above function is used to retrieve MIBs logging counter configuration and mode.

The function will verify whether the input parameter is within the valid range or not.

Logic to verify input parameter.

Check input idx value.

It will return RT




NEXT




<s> static u32 rtl930x_packet_cntr_read(int counter)
{
u32 v;

/* Read LOG table (3) via register RTL9300_TBL_0 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_0, 3);

pr_debug("In %s, id %d\n", __func__, counter);
rtl_table_read(r, counter / 2);

pr_debug("Registers: %08x %08x\n",
sw_r32(rtl_table_data(r, 0)), sw_r32(rtl_table_data(r, 1)));
/* The table has a size of 2 registers */
if (counter % 2)
v = sw_r32(rtl_table_data(r, 0));
else
v = sw_r32(rtl_table_data(r, 1));

rtl_table_release(r);

return v;
}

The above function is used to read packet counters. The function is invoked
through the following code:

u32 i = counter / 2;
r = rtl_table_create(RTL9300_TBL_0);





NEXT




<s> hostapd_bss_mgmt_enable(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)

{
struct hostapd_data *hapd = get_hapd_from_object(obj);
struct blob_attr *tb[__BSS_MGMT_EN_MAX];
struct blob_attr *cur;
uint32_t flags = 0;
int i;
bool neigh = false, beacon = false;

blobmsg_parse(bss_mgmt_enable_policy, __BSS_MGMT_EN_MAX, tb, blob_data(msg), blob_len(msg));

for (i = 0; i < ARRAY_SIZE(tb); i++) {
if (!tb[i] || !blobmsg_get_bool(tb[i]))
continue;

flags |= (1 << i);
}

__hostapd_bss_mgmt_enable(hapd, flags);

return 0;
}

The above function is used to handle the user BSS mgmt configuration policy. The function is part of the hostapd_bss_mgmt_cfg callback (see section 9.8.1.3). It is used to forward the user BSS mgmt




NEXT




<s> ret_t rtl8367c_getAsicEgressQueueEmptyPortMask(rtk_uint32 *pPortmask)
{
return rtl8367c_getAsicReg(RTL8367C_REG_PORT_QEMPTY, pPortmask);
}

The above function is used to get the egress queue empty port mask from HW in order to know which port is not full with egress queue. Currently we use the following function to set the queue drop configuration for all egress queue.

```
ret_




NEXT




<s> static int rtl931x_pie_rule_add(struct rtl838x_switch_priv *priv, struct pie_rule *pr)
{
int idx, block, j;
int min_block = 0;
int max_block = priv->n_pie_blocks / 2;

if (pr->is_egress) {
min_block = max_block;
max_block = priv->n_pie_blocks;
}
pr_info("In %s\n", __func__);

mutex_lock(&priv->pie_mutex);

for (block = min_block; block < max_block; block++) {
for (j = 0; j < 2; j++) {
int t = (sw_r32(RTL931X_PIE_BLK_TMPLTE_CTRL(block)) >> (j * 4)) & 0xf;
pr_info("Testing block %d, template %d, template id %d\n", block, j, t);
pr_info("%s: %08x\n",
__func__, sw_r32(RTL931X_PIE_BLK_TMPLTE_CTRL(block)));
idx = rtl931x_pie_verify_template(priv, pr, t, block);
if (idx >= 0)
break;
}
if (j < 2)
break;
}

if (block >= priv->n_pie_blocks) {
mutex_unlock(&priv->pie_mutex);
return -EOPNOTSUPP;
}

pr_info("Using block: %d, index %d, template-id %d\n", block, idx, j);
set_bit(idx, priv->pie_use_bm);

pr->valid = true;
pr->tid = j;  /* Mapped to template number */
pr->tid_m = 0x1;
pr->id = idx;

rtl931x_pie_lookup_enable(priv, idx);
rtl931x_pie_rule_write(priv, idx, pr);

mutex_unlock(&priv->pie_mutex);

return 0;
}

The above function is used to add a rule to PIE.

Note that it first tries to map the user-defined fields to already available templates.
Here is a PIE template definition in SONiC:

struct pie_template {
u3




NEXT




<s> static void aca_grx330_init(struct dc_ep_priv *priv)
{
wr32(0x0044001E, TXIN_CFG1);
wr32(0x0040041F, TXIN_CFG2);
wr32(0x007FE020, TXIN_CFG3);

wr32(0x0044001F, TXOUT_CFG1);
wr32(0x0040041F, TXOUT_CFG2);
wr32(0x007BE020, TXOUT_CFG3);

wr32(0x0044001F, RXOUT_CFG1);
wr32(0x0040041F, RXOUT_CFG2);
wr32(0x007BE020, RXOUT_CFG3);

wr32(0x0044001E, RXIN_CFG1);
wr32(0x0040041F, RXIN_CFG2);
wr32(0x007FE020, RXIN_CFG3);

wr32(0x1, TXIN_DST_OWWBIT_CFG4);
wr32(0x1, TXOUT_DST_OWWBIT_CFG4);
wr32(0x1, RXOUT_SRC_OWNBIT_CFG3);
wr32(0x1, RXIN_SRC_OWNBIT_CFG3);

wr32(0x0, GNRC_TXIN_BUF_PREFILL);
wr32(0x0, GNRC_TXIN_BUF_PREFILL + 0x4);
wr32(0x0, GNRC_TXIN_BUF_PREFILL + 0x8);
wr32(0x0, GNRC_TXIN_BUF_PREFILL + 0xc);
wr32(0x0, GNRC_TXIN_BUF_PREFILL + 0x10);
wr32(0x0, GNRC_TXIN_BUF_PREFILL + 0x14);
wr32(0x0, GNRC_TXIN_BUF_PREFILL + 0x18);
wr32(0x0, GNRC_TXIN_BUF_PREFILL + 0x1c);
}

The above function is used to initialize the ACA GRX330 core that comes

under
the
DC_CORE_EP_GFX. This core contains two TXIN pipelines (10 lanes) and two RXIN
pipelines




NEXT




<s> static ssize_t drop_counter_read(struct file *filp, char __user *buffer, size_t count,
loff_t *ppos)
{
struct rtl838x_switch_priv *priv = filp->private_data;
const char **d;
u32 v;
char *buf;
int n = 0, len, offset;
int num;

switch (priv->family_id) {
case RTL8380_FAMILY_ID:
d = rtl838x_drop_cntr;
offset = RTL838X_STAT_PRVTE_DROP_COUNTERS;
num = 40;
break;
case RTL8390_FAMILY_ID:
d = rtl839x_drop_cntr;
offset = RTL839X_STAT_PRVTE_DROP_COUNTERS;
num = 45;
break;
case RTL9300_FAMILY_ID:
d = rtl930x_drop_cntr;
offset = RTL930X_STAT_PRVTE_DROP_COUNTERS;
num = 85;
break;
case RTL9310_FAMILY_ID:
d = rtl931x_drop_cntr;
offset = RTL931X_STAT_PRVTE_DROP_COUNTERS;
num = 81;
break;
}

buf = kmalloc(30 * num, GFP_KERNEL);
if (!buf)
return -ENOMEM;

for (int i = 0; i < num; i++) {
v = sw_r32(offset + (i << 2)) & 0xffff;
n += sprintf(buf + n, "%s: %d\n", d[i], v);
}

if (count < strlen(buf)) {
kfree(buf);
return -ENOSPC;
}

len = simple_read_from_buffer(buffer, count, ppos, buf, strlen(buf));
kfree(buf);

return len;
}

The above function is used to read the drop counter of the switches. There are a lot of counter numbers. According to the table 19 in the switch datasheet, this function is used to read the following counters:
1. IPv4 Destination




NEXT




<s> new_string();
BEGIN(STRING);
}
YY_BREAK
case 49:
YY_RULE_SETUP
{

The above function is used to calculate your age once you input the date of your birth. A date struct consists of components such as the days, month and year. This is how the program defines the components, the data types used are int and struct. struct date{ int d




NEXT




<s> hostapd_bss_update_beacon(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
int rc;
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);

rc = ieee802_11_set_beacon(hapd);

if (rc != 0)
return UBUS_STATUS_NOT_SUPPORTED;

return 0;
}

The above function is used to update the Beacon interval and SSID of the network. Below is the API for hostapd_bss_update_ssid.

int hostapd_bss_update_ssid(hostapd_bss_t *




NEXT




<s> int ifxdeu_init_md5_hmac (void)
{

int ret = -ENOSYS;


if ((ret = crypto_register_shash(&ifxdeu_md5_hmac_alg)))
goto md5_hmac_err;

printk (KERN_NOTICE "IFX DEU MD5_HMAC initialized%s.\n", disable_deudma ? "" : " (DMA)");
return ret;

md5_hmac_err:
printk(KERN_ERR "IFX DEU MD5_HMAC initialization failed!\n");
return ret;
}

The above function is used to initialize a hmac (Hashing Message Authentication Code) using MD5 (Message Digest 5 hashing algorithm).

For simplicity, only SHA-1 hashing algorithm is used in this article. The source file (/driver/




NEXT




<s> static void rijndaelKeySetupDec(u32 rk[/*44*/], const u8 cipherKey[])
{
int Nr = 10, i, j;
u32 temp;

/* expand the cipher key: */
rijndaelKeySetupEnc(rk, cipherKey);
/* invert the order of the round keys: */
for (i = 0, j = 4*Nr; i < j; i += 4, j -= 4) {
temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;
temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;
temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;
temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
}
/* apply the inverse MixColumn transform to all round keys but the
* first and the last: */
for (i = 1; i < Nr; i++) {
rk += 4;
for (j = 0; j < 4; j++) {
rk[j] = TD0_(TE4((rk[j] >> 24)       )) ^
TD1_(TE4((rk[j] >> 16) & 0xff)) ^
TD2_(TE4((rk[j] >>  8) & 0xff)) ^
TD3_(TE4((rk[j]      ) & 0xff));
}
}
}

The above function is used to initialize the round keys for rijndael-128. The code is identical to the encrypt function except

1. All of the constants are negated.
2. The final round key transform is skipped.
3




NEXT




<s> int putchar(c)
{
return putc(c);
}

The above function is used to send user input to the kernel or application program.

Putc and Getc are the input output facilities of C. They are used to send or receive input.

The input and output facilities are defined in the ctype.h header




NEXT




<s> void set_all_choice_values(struct symbol *csym)
{
struct property *prop;
struct symbol *sym;
struct expr *e;

prop = sym_get_choice_prop(csym);

/*
* Set all non-assinged choice values to no
*/
expr_list_for_each_sym(prop->expr, e, sym) {
if (!sym_has_value(sym))
sym->def[S_DEF_USER].tri = no;
}
csym->flags |= SYMBOL_DEF_USER;
/* clear VALID to get value calculated */
csym->flags &= ~(SYMBOL_VALID | SYMBOL_NEED_SET_CHOICE_VALUES);
}

The above function is used to modify the choices values.
The symbol that has these choices value are of type c.h. The
choices value is a set of variables (the variables can of
different type: c, i, f, …) which can




NEXT




<s> ret_t rtl8367c_getAsicLutFlushAllStatus(rtk_uint32 *pBusyStatus)
{
if(NULL == pBusyStatus)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBit(RTL8367C_REG_L2_FLUSH_CTRL3, RTL8367C_L2_FLUSH_CTRL3_OFFSET, pBusyStatus);
}

The above function is used to get the status bit of the L2 flush control register.

ret_t rtl8367c_setAsicLutFlushAll(rtk_uint32 en)
{
if(en)





NEXT




<s> static void lq_sg_complete(struct aes_container *aes_con)
{
unsigned long queue_flag;

spin_lock_irqsave(&aes_queue->lock, queue_flag);
kfree(aes_con);
spin_unlock_irqrestore(&aes_queue->lock, queue_flag);
}

The above function is used to clear an encrypted AES container from the pending
queue where its content is ready for delivery and aes_con is a pointer to an
AES container descriptor. It deallocates memory for the AES container descriptor
and locks the




NEXT




<s> uc_bpf_map_get(uc_vm_t *vm, size_t nargs)
{
struct uc_bpf_map *map = uc_fn_thisval("bpf.map");
uc_value_t *a_key = uc_fn_arg(0);
void *key, *val;

if (!map)
err_return(EINVAL, NULL);

key = uc_bpf_map_arg(a_key, "key", map->key_size);
if (!key)
return NULL;

val = alloca(map->val_size);
if (bpf_map_lookup_elem(map->fd.fd, key, val))
return NULL;

return ucv_string_new_length(val, map->val_size);
}

The above function is used to return a value from the key-value table pointed by @bpf.map in context-call.

#### A BPF-specific argument

Let's look at the first function argument, @key. You should see that it




NEXT




<s> ret_t rtl8367c_setAsicInterruptMask(rtk_uint32 imr)
{
return rtl8367c_setAsicReg(RTL8367C_REG_INTR_IMR, imr);
}

The above function is used to configure the interrupt disable/enable mask.
As we can see, it basically reads back the register and writes back the value with a different control value.
The following snippets are used to enable and disable the interrupt mask.

int




NEXT




<s> rtk_api_ret_t rtk_switch_portMaxPktLen_set(rtk_port_t port, rtk_switch_maxPktLen_linkSpeed_t speed, rtk_uint32 cfgId)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(speed >= MAXPKTLEN_LINK_SPEED_END)
return RT_ERR_INPUT;

if(cfgId > MAXPKTLEN_CFG_ID_MAX)
return RT_ERR_INPUT;

if((retVal = rtl8367c_setAsicMaxLength(rtk_switch_port_L2P_get(port), (rtk_uint32)speed, cfgId)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the maximum packet length of a link connected to the given port.

rtd_table_ret_t rtk_table_portMaxPktLen_get(rtd_table_portMaxPktLen_entry_




NEXT




<s> bool rtl931x_decode_tag(struct p_hdr *h, struct dsa_tag *t)
{
t->reason = h->cpu_tag[7] & 0x3f;
t->queue =  (h->cpu_tag[2] >> 11) & 0x1f;
t->port = (h->cpu_tag[0] >> 8) & 0x3f;
t->crc_error = h->cpu_tag[1] & BIT(6);

if (t->reason != 63)
pr_info("%s: Reason %d, port %d, queue %d\n", __func__, t->reason, t->port, t->queue);
if (t->reason >= 19 && t->reason <= 27)	/* NIC_RX_REASON_RMA */
t->l2_offloaded = 0;
else
t->l2_offloaded = 1;

return t->l2_offloaded;
}

The above function is used to check tag values for each packet. It is used to decide whether the first 16 bytes of the packet needs to be processed by SR-IOV or not. It is also used to find out the type of tag. The RMA packets




NEXT




<s> static void ath79_mii_ctrl_set_if(struct ag71xx *ag, unsigned int mii_if)
{
u32 t;

t = __raw_readl(ag->mii_base);
t &= ~(AR71XX_MII_CTRL_IF_MASK);
t |= (mii_if & AR71XX_MII_CTRL_IF_MASK);
__raw_writel(t, ag->mii_base);
}

The above function is used to reprogram any mii device as MII, RMII, or RGMII. But according to the data-sheet, the MII interface is also controlled by the PCR2 register.

Ath79 is reprogram




NEXT




<s> mtd_fixwrgg(const char *mtd, size_t offset, size_t data_size)
{
int fd;
char *first_block;
ssize_t res;
size_t block_offset;
size_t data_offset;
struct wrgg03_header *shdr;

if (quiet < 2)
fprintf(stderr, "Trying to fix WRGG header in %s at 0x%x...\n",
mtd, offset);

block_offset = offset & ~(erasesize - 1);
offset -= block_offset;

fd = mtd_check_open(mtd);
if(fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd);
exit(1);
}

if (block_offset + erasesize > mtdsize) {
fprintf(stderr, "Offset too large, device size 0x%x\n",
mtdsize);
exit(1);
}

first_block = malloc(erasesize);
if (!first_block) {
perror("malloc");
exit(1);
}

res = pread(fd, first_block, erasesize, block_offset);
if (res != erasesize) {
perror("pread");
exit(1);
}

shdr = (struct wrgg03_header *)(first_block + offset);

/* The magic is always stored in little-endian byte order */
if (le32_to_cpu((uint8_t *)&shdr->magic1) != WRGG03_MAGIC) {
fprintf(stderr, "magic1 = %x\n", shdr->magic1);
fprintf(stderr, "WRGG03_MAGIC = %x\n", WRGG03_MAGIC);
fprintf(stderr, "No WRGG header found\n");
exit(1);
} else if (!shdr->size) {
fprintf(stderr, "WRGG entity with empty image\n");
exit(1);
}

data_offset = offset + sizeof(struct wrgg03_header);
if (!data_size)
data_size = mtdsize - data_offset;
if (data_size > shdr->size)
data_size = shdr->size;
if (wrgg_fix_md5(shdr, fd, data_offset, data_size))
goto out;

if (mtd_erase_block(fd, block_offset)) {
fprintf(stderr, "Can't erease block at 0x%x (%s)\n",
block_offset, strerror(errno));
exit(1);
}

if (quiet < 2)
fprintf(stderr, "Rewriting block at 0x%x\n", block_offset);

if (pwrite(fd, first_block, erasesize, block_offset) != erasesize) {
fprintf(stderr, "Error writing block (%s)\n", strerror(errno));
exit(1);
}

if (quiet < 2)
fprintf(stderr, "Done.\n");

out:
close (fd);
sync();

return 0;
}

The above function is used to correct headers in erase chunks that have been
reformatted to contain bad magic numbers and empty data.</s>




NEXT




<s> tristate expr_calc_value(struct expr *e)
{
tristate val1, val2;
const char *str1, *str2;
enum string_value_kind k1 = k_string, k2 = k_string;
union string_value lval = {}, rval = {};
int res;

if (!e)
return yes;

switch (e->type) {
case E_SYMBOL:
sym_calc_value(e->left.sym);
return e->left.sym->curr.tri;
case E_AND:
val1 = expr_calc_value(e->left.expr);
val2 = expr_calc_value(e->right.expr);
return EXPR_AND(val1, val2);
case E_OR:
val1 = expr_calc_value(e->left.expr);
val2 = expr_calc_value(e->right.expr);
return EXPR_OR(val1, val2);
case E_NOT:
val1 = expr_calc_value(e->left.expr);
return EXPR_NOT(val1);
case E_EQUAL:
case E_GEQ:
case E_GTH:
case E_LEQ:
case E_LTH:
case E_UNEQUAL:
break;
default:
printf("expr_calc_value: %d?\n", e->type);
return no;
}

sym_calc_value(e->left.sym);
sym_calc_value(e->right.sym);
str1 = sym_get_string_value(e->left.sym);
str2 = sym_get_string_value(e->right.sym);

if (e->left.sym->type != S_STRING || e->right.sym->type != S_STRING) {
k1 = expr_parse_string(str1, e->left.sym->type, &lval);
k2 = expr_parse_string(str2, e->right.sym->type, &rval);
}

if (k1 == k_string || k2 == k_string)
res = strcmp(str1, str2);
else if (k1 == k_unsigned || k2 == k_unsigned)
res = (lval.u > rval.u) - (lval.u < rval.u);
else /* if (k1 == k_signed && k2 == k_signed) */
res = (lval.s > rval.s) - (lval.s < rval.s);

switch(e->type) {
case E_EQUAL:
return res ? no : yes;
case E_GEQ:
return res >= 0 ? yes : no;
case E_GTH:
return res > 0 ? yes : no;
case E_LEQ:
return res <= 0 ? yes : no;
case E_LTH:
return res < 0 ? yes : no;
case E_UNEQUAL:
return res ? yes : no;
default:
printf("expr_calc_value: relation %d?\n", e->type);
return no;
}
}

The above function is used to evaluate an expression.</s>




NEXT




<s> static void rtl839x_init_eee(struct rtl838x_switch_priv *priv, bool enable)
{
pr_info("Setting up EEE, state: %d\n", enable);

/* Set wake timer for TX and pause timer both to 0x21 */
sw_w32_mask(0xff << 20| 0xff, 0x21 << 20| 0x21, RTL839X_EEE_TX_TIMER_GELITE_CTRL);
/* Set pause wake timer for GIGA-EEE to 0x11 */
sw_w32_mask(0xff << 20, 0x11 << 20, RTL839X_EEE_TX_TIMER_GIGA_CTRL);
/* Set pause wake timer for 10GBit ports to 0x11 */
sw_w32_mask(0xff << 20, 0x11 << 20, RTL839X_EEE_TX_TIMER_10G_CTRL);

/* Setup EEE on all ports */
for (int i = 0; i < priv->cpu_port; i++) {
if (priv->ports[i].phy)
rtl839x_port_eee_set(priv, i, enable);
}
priv->eee_enabled = enable;
}

The above function is used to enable EEE on all ports in the switch. To do this, it iterates over each configured switch port, calls rtl839x_port_eee_set(0, enable), and sets the EEE_ENABLED flag




NEXT




<s> static int rtl839x_pie_verify_template(struct rtl838x_switch_priv *priv,
struct pie_rule *pr, int t, int block)
{
int i;

if (!pr->is_ipv6 && pr->sip_m && !rtl839x_pie_templ_has(t, TEMPLATE_FIELD_SIP0))
return -1;

if (!pr->is_ipv6 && pr->dip_m && !rtl839x_pie_templ_has(t, TEMPLATE_FIELD_DIP0))
return -1;

if (pr->is_ipv6) {
if ((pr->sip6_m.s6_addr32[0] ||
pr->sip6_m.s6_addr32[1] ||
pr->sip6_m.s6_addr32[2] ||
pr->sip6_m.s6_addr32[3]) &&
!rtl839x_pie_templ_has(t, TEMPLATE_FIELD_SIP2))
return -1;
if ((pr->dip6_m.s6_addr32[0] ||
pr->dip6_m.s6_addr32[1] ||
pr->dip6_m.s6_addr32[2] ||
pr->dip6_m.s6_addr32[3]) &&
!rtl839x_pie_templ_has(t, TEMPLATE_FIELD_DIP2))
return -1;
}

if (ether_addr_to_u64(pr->smac) && !rtl839x_pie_templ_has(t, TEMPLATE_FIELD_SMAC0))
return -1;

if (ether_addr_to_u64(pr->dmac) && !rtl839x_pie_templ_has(t, TEMPLATE_FIELD_DMAC0))
return -1;

/* TODO: Check more */

i = find_first_zero_bit(&priv->pie_use_bm[block * 4], PIE_BLOCK_SIZE);

if (i >= PIE_BLOCK_SIZE)
return -1;

return i + PIE_BLOCK_SIZE * block;
}

The above function is used to verify the template of a pie rule.</s>




NEXT




<s> static void mt7621_nfc_read_sector_fdm(struct mt7621_nfc *nfc, u32 sect)
{
struct nand_chip *nand = &nfc->nand;
u32 vall, valm;
u8 *oobptr;
int i;

vall = nfi_read32(nfc, NFI_FDML(sect));
valm = nfi_read32(nfc, NFI_FDMM(sect));
oobptr = oob_fdm_ptr(nand, sect);

for (i = 0; i < 4; i++)
oobptr[i] = (vall >> (i * 8)) & 0xff;

for (i = 0; i < 4; i++)
oobptr[i + 4] = (valm >> (i * 8)) & 0xff;
}

The above function is used to read a sector. For the purposes of the
examples, FDM mode has to be enabled (even through it does not
actually help here).

For the rest of the example, the write example is exactly the same
as




NEXT




<s> static int rtl93xx_setup(struct dsa_switch *ds)
{
struct rtl838x_switch_priv *priv = ds->priv;

pr_info("%s called\n", __func__);

/* Disable MAC polling the PHY so that we can start configuration */
if (priv->family_id == RTL9300_FAMILY_ID)
sw_w32(0, RTL930X_SMI_POLL_CTRL);

if (priv->family_id == RTL9310_FAMILY_ID) {
sw_w32(0, RTL931X_SMI_PORT_POLLING_CTRL);
sw_w32(0, RTL931X_SMI_PORT_POLLING_CTRL + 4);
}

/* Disable all ports except CPU port */
for (int i = 0; i < ds->num_ports; i++)
priv->ports[i].enable = false;
priv->ports[priv->cpu_port].enable = true;

/* Configure ports so they are disabled by default, but once enabled
* they will work in isolated mode (only traffic between port and CPU).
*/
for (int i = 0; i < priv->cpu_port; i++) {
if (priv->ports[i].phy) {
priv->ports[i].pm = BIT_ULL(priv->cpu_port);
priv->r->traffic_set(i, BIT_ULL(i));
}
}
priv->r->traffic_set(priv->cpu_port, BIT_ULL(priv->cpu_port));

rtl930x_print_matrix();

/* TODO: Initialize statistics */

rtl83xx_vlan_setup(priv);

ds->configure_vlan_while_not_filtering = true;

priv->r->l2_learning_setup();

rtl83xx_port_set_salrn(priv, priv->cpu_port, false);
ds->assisted_learning_on_cpu_port = true;

rtl83xx_enable_phy_polling(priv);

priv->r->pie_init(priv);

priv->r->led_init(priv);

return 0;
}

The above function is used to initialize RTL9300 series (RTL838x)
family switches. We disable MAC polling on PHYs for each RTL9300
series port. We also disable ports by default, meaning




NEXT




<s> static int oxnas_pcie_shared_init(struct platform_device *pdev, struct oxnas_pcie *pcie)
{
if (++pcie_shared.refcount == 1) {
phy_init(pcie->phy);
phy_power_on(pcie->phy);
return 0;
} else {
return 0;
}
}

The above function is used to initialize the PCIE shared hardware. I am not able to understand why do we need to call pcie_shared.refcount = 0 for uninitializing this hardware even though it is already a static variable.

And also why do




NEXT




<s> void rtl9300_do_rx_calibration_3(int sds_num, phy_interface_t phy_mode)
{
rtl9300_sds_rxcal_3_1(sds_num, phy_mode);

if (phy_mode == PHY_INTERFACE_MODE_10GBASER || phy_mode == PHY_INTERFACE_MODE_1000BASEX)
rtl9300_sds_rxcal_3_2(sds_num, phy_mode);
}

The above function is used to calibrate the receiver before TX/RX switch. The reason for calibration is that the input level could shift with temperature, voltage or humidity. We calibrate the data at the end of the calibration procedure, so that the error




NEXT




<s> static void vr9_init(struct platform_device *pdev)
{
volatile u32 *p;
unsigned int i;

/* setup pmu */
ltq_pmu_enable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_PPE_QSB |
IFX_PMU_MODULE_AHBS |
IFX_PMU_MODULE_DSL_DFE);

vr9_reset_ppe(pdev);

/* pdma init */
IFX_REG_W32(0x08,       PDMA_CFG);
IFX_REG_W32(0x00203580, SAR_PDMA_RX_CMDBUF_CFG);
IFX_REG_W32(0x004035A0, SAR_PDMA_RX_FW_CMDBUF_CFG);

/* mailbox init */
IFX_REG_W32(0xFFFFFFFF, MBOX_IGU1_ISRC);
IFX_REG_W32(0x00000000, MBOX_IGU1_IER);
IFX_REG_W32(0xFFFFFFFF, MBOX_IGU3_ISRC);
IFX_REG_W32(0x00000000, MBOX_IGU3_IER);

/* tc init - clear sync state */
*SFSM_STATE0 = 0;
*SFSM_STATE1 = 0;

/* init shared buffer */
p = SB_RAM0_ADDR(0);
for ( i = 0; i < SB_RAM0_DWLEN + SB_RAM1_DWLEN + SB_RAM2_DWLEN + SB_RAM3_DWLEN; i++ )
IFX_REG_W32(0, p++);

p = SB_RAM6_ADDR(0);
for ( i = 0; i < SB_RAM6_DWLEN; i++ )
IFX_REG_W32(0, p++);
}

The above function is used to initialize VR9 chip
* `ltq_pmu_enable()` enables the following PMU modules:
    * **PPE_SLL01 - SLL01, SLL01Q2, SLL




NEXT




<s> ret_t rtl8367c_getAsicIGMPSuppression(rtk_uint32 *report_supp_enabled, rtk_uint32 *leave_supp_enabled)
{
ret_t   retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_REPORT_SUPPRESSION_MASK, report_supp_enabled);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_LEAVE_SUPPRESSION_MASK, leave_supp_enabled);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the status of Asic as follows.

1.    Report suppression is enabled (RTL8367C_REPORT_SUPPRESSION_MASK = 1)
2.    Leave suppression is enabled (




NEXT




<s> extern int rtl931x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl931x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl930x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl930x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);
extern int rtl931x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl931x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);

/* On the RTL93XX, the RTL93XX_DMA_IF_RX_RING_CNTR track the fill level of
* the rings. Writing x into these registers substracts x from its content.
* When the content reaches the ring size, the ASIC no longer adds
* packets to this receive queue.
*/
void rtl838x_update_cntr(int r, int released)
{
/* This feature is not available on RTL838x SoCs */
}

The above function is used to remove the packets from an ASIC ring or buffer
to be later written out to memory.

void rtl838x_process_data_rx_ring(int r, int released_pkts)
{
	




NEXT




<s> static void radius_deinit(struct radius_state *s)
{
if (s->radius)
radius_server_deinit(s->radius);

if (s->eap.ssl_ctx)
tls_deinit(s->eap.ssl_ctx);

radius_userdata_free(&s->phase1);
radius_userdata_free(&s->phase2);
}

The above function is used to cleanup the radiotap data before we free it.

The eap_sm event callback is called from event_callback for eap_sm. We need to
extract the correct radiotap data when the callback calls radius_auth




NEXT




<s> mvswitch_config_aneg(struct phy_device *phydev)
{
return 0;
}

The above function is used to configure ANEG protocol as per
Ethernet/RS-449 Auto-Negotiation for Gigabit Ethernet.
This function returns 0, whether there is success or failure.
But it can be




NEXT




<s> static int gpio_rb91x_key_get(struct gpio_chip *gc, unsigned offset)
{
struct gpio_rb91x_key *drvdata = to_gpio_rb91x_key(gc);
struct gpio_desc *gpio = drvdata->gpio;
int val, bak_val;

switch (offset) {
case GPIO_RB91X_KEY_NAND:
mutex_lock(&drvdata->mutex);
val = gpiod_get_value_cansleep(gpio);
mutex_unlock(&drvdata->mutex);
break;
case GPIO_RB91X_KEY_PDIS:
mutex_lock(&drvdata->mutex);
val = drvdata->polling_disabled;
mutex_unlock(&drvdata->mutex);
break;
case GPIO_RB91X_KEY_POLL:
mutex_lock(&drvdata->poll_mutex);
mutex_lock(&drvdata->mutex);
bak_val = gpiod_get_raw_value_cansleep(gpio);
gpiod_direction_input(gpio);
/*
* Without this delay nothing works. Get it
* from mikrotik RouterOS linux kernel patches.
*/
udelay(200);
val = gpiod_get_raw_value_cansleep(gpio);
gpiod_direction_output_raw(gpio, bak_val);
mutex_unlock(&drvdata->mutex);
mutex_unlock(&drvdata->poll_mutex);
break;
default:
return -EINVAL;
}

return val;
}

The above function is used to get current state of various keys in the keyboard. The kernel module can then use this data as keyboard input. We will see how this is done soon.</s>




NEXT




<s> static char *do_shell(int argc, char *argv[])
{
FILE *p;
char buf[256];
char *cmd;
size_t nread;
int i;

cmd = argv[0];

p = popen(cmd, "r");
if (!p) {
perror(cmd);
exit(1);
}

nread = fread(buf, 1, sizeof(buf), p);
if (nread == sizeof(buf))
nread--;

/* remove trailing new lines */
while (nread > 0 && buf[nread - 1] == '\n')
nread--;

buf[nread] = 0;

/* replace a new line with a space */
for (i = 0; i < nread; i++) {
if (buf[i] == '\n')
buf[i] = ' ';
}

if (pclose(p) == -1) {
perror(cmd);
exit(1);
}

return xstrdup(buf);
}

The above function is used to run subprocesses as subshells that read from standard input and send the output to standard output. It can be used instead of functions like `system()` which spawn full shells.</s>




NEXT




<s> ret_t rtl8367c_getAsicVlanFilter(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_VLAN_CTRL, RTL8367C_VLAN_CTRL_OFFSET, pEnabled);
}

The above function is used to read/write the vlan enable bit for asic vlan
filtering. By setting the corresponding bit as 1, the asic vlan filtering is
enabled and when it is set 0, the asic vlan filter




NEXT




<s> static inline u32 ar934x_nfc_rr(struct ar934x_nfc *nfc, unsigned reg)
{
return __raw_readl(nfc->base + reg);
}

The above function is used to read a specific region in some hardware (registers) on the CPU. It seems that there’s a memory leak inside the function `nfc_open()`, which doesn’t destroy the object nfc after each use of this function,




NEXT




<s> void AT91F_LowLevelInit(void)
{
int i;

// Init Interrupt Controller
AT91F_AIC_Open(
AT91C_BASE_AIC,          // pointer to the AIC registers
AT91C_AIC_BRANCH_OPCODE, // IRQ exception vector
AT91F_UndefHandler,      // FIQ exception vector
AT91F_UndefHandler,      // AIC default handler
AT91F_SpuriousHandler,   // AIC spurious handler
0);                      // Protect mode

// Perform 8 End Of Interrupt Command to make sre AIC will not Lock out nIRQ
for(i=0; i<8; i++)
AT91F_AIC_AcknowledgeIt(AT91C_BASE_AIC);

AT91F_AIC_SetExceptionVector((unsigned int *)0x0C, AT91F_FetchAbort);
AT91F_AIC_SetExceptionVector((unsigned int *)0x10, AT91F_DataAbort);
AT91F_AIC_SetExceptionVector((unsigned int *)0x4, AT91F_UndefHandler);

//Initialize SDRAM and Flash
AT91F_InitMemories();

}

The above function is used to Initialize the hardware of AT91F313 (except Timer),
and initialize the interrupt controller.

Please refer to the code, I do not explain it here again. The main idea
of the initialization is (In the




NEXT




<s> static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to register a 6 queue packet scheduler for network device. The function first checks the validity of the network device and then checks the g_wanqos_en to decide whether it is allowed to use 6 queue packet scheduling.





NEXT




<s> static void routerboot_find_dynparts(struct mtd_info *master)
{
size_t bytes_read, offset;
bool allfound;
int err, i;
u32 buf;

/*
* Dynamic RouterBoot partitions offsets are aligned to RB_BLOCK_SIZE:
* read the whole partition at RB_BLOCK_SIZE intervals to find sigs.
* Skip partition content when possible.
*/
offset = 0;
while (offset < master->size) {
err = mtd_read(master, offset, sizeof(buf), &bytes_read, (u8 *)&buf);
if (err) {
pr_err("%s: mtd_read error while parsing (offset: 0x%X): %d\n",
master->name, offset, err);
continue;
}

allfound = true;

for (i = 0; i < ARRAY_SIZE(rb_dynparts); i++) {
if (rb_dynparts[i].found)
continue;

allfound = false;

if (rb_dynparts[i].magic == buf) {
rb_dynparts[i].offset = offset;

if (rb_dynparts[i].size_fixup) {
err = rb_dynparts[i].size_fixup(master, &rb_dynparts[i]);
if (err) {
pr_err("%s: size fixup error while parsing \"%s\": %d\n",
master->name, rb_dynparts[i].name, err);
continue;
}
}

rb_dynparts[i].found = true;

/*
* move offset to skip the whole partition on
* next iteration if size > RB_BLOCK_SIZE.
*/
if (rb_dynparts[i].size > RB_BLOCK_SIZE)
offset += ALIGN_DOWN((rb_dynparts[i].size - RB_BLOCK_SIZE), RB_BLOCK_SIZE);

break;
}
}

offset += RB_BLOCK_SIZE;

if (allfound)
break;
}
}

The above function is used to parse Dynamic RouterBoot partition table
from the master MTD. Here’s a quick overview on how it works on a
simple configuration. Note that here all partitions are contiguous
meaning that the last dynamic partition ends




NEXT




<s> static int adm6996_config_aneg(struct phy_device *phydev)
{
return 0;
}

The above function is used to initialize the An-EQ function and to perform AFEG (Adjust the impedance)
AnEG is a method that can be used to equalize the impedance of a given pair of signal leads. This method involves using a known imped




NEXT




<s> static int rtl8366rb_get_vlan_4k(struct rtl8366_smi *smi, u32 vid,
struct rtl8366_vlan_4k *vlan4k)
{
u32 data[3];
int err;
int i;

memset(vlan4k, '\0', sizeof(struct rtl8366_vlan_4k));

if (vid >= RTL8366RB_NUM_VIDS)
return -EINVAL;

/* write VID */
err = rtl8366_smi_write_reg(smi, RTL8366RB_VLAN_TABLE_WRITE_BASE,
vid & RTL8366RB_VLAN_VID_MASK);
if (err)
return err;

/* write table access control word */
err = rtl8366_smi_write_reg(smi, RTL8366RB_TABLE_ACCESS_CTRL_REG,
RTL8366RB_TABLE_VLAN_READ_CTRL);
if (err)
return err;

for (i = 0; i < 3; i++) {
err = rtl8366_smi_read_reg(smi,
RTL8366RB_VLAN_TABLE_READ_BASE + i,
&data[i]);
if (err)
return err;
}

vlan4k->vid = vid;
vlan4k->untag = (data[1] >> RTL8366RB_VLAN_UNTAG_SHIFT) &
RTL8366RB_VLAN_UNTAG_MASK;
vlan4k->member = data[1] & RTL8366RB_VLAN_MEMBER_MASK;
vlan4k->fid = data[2] & RTL8366RB_VLAN_FID_MASK;

return 0;
}

The above function is used to retrieve information about an entry in the VLAN database. It is implemented on all supported controllers; however, there are some subtle differences on devices that support less than 4K entries.

The first difference is that rtl836




NEXT




<s> void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to manipulate the parser state. It must be called
after yyparse returns from a call to yyparse or yylex. The pointer members,
current_buffer - A pointer to the current parse buffer (this handles
line buffering and




NEXT




<s> BigIntegerLShift(result, x, bits)
BigInteger result, x;
unsigned int bits;
{
BN_lshift(result, x, bits);
}

The above function is used to shift a big integer to the left by a positive number bits. This is very fast as it does not use any of the slow BN_add(), or BN_copy() for shifting. In case we needed to shift the number right,




NEXT




<s> static struct rtl83xx_route *rtl83xx_host_route_alloc(struct rtl838x_switch_priv *priv, u32 ip)
{
struct rtl83xx_route *r;
int idx = 0, err;

mutex_lock(&priv->reg_mutex);

idx = find_first_zero_bit(priv->host_route_use_bm, MAX_HOST_ROUTES);
pr_debug("%s id: %d, ip %pI4\n", __func__, idx, &ip);

r = kzalloc(sizeof(*r), GFP_KERNEL);
if (!r) {
mutex_unlock(&priv->reg_mutex);
return r;
}

/* We require a unique route ID irrespective of whether it is a prefix or host
* route (on RTL93xx) as we use this ID to associate a DMAC and next-hop entry
*/
r->id = idx + MAX_ROUTES;

r->gw_ip = ip;
r->pr.id = -1; /* We still need to allocate a rule in HW */
r->is_host_route = true;

err = rhltable_insert(&priv->routes, &r->linkage, route_ht_params);
if (err) {
pr_err("Could not insert new rule\n");
mutex_unlock(&priv->reg_mutex);
goto out_free;
}

set_bit(idx, priv->host_route_use_bm);

mutex_unlock(&priv->reg_mutex);

return r;

out_free:
kfree(r);

return NULL;
}

The above function is used to allocate a new host route. There are several other routines that are in this file. They do mostly the same thing, but with a different rule type. They use different parameters in the call to the function.</s>




NEXT




<s> ret_t rtl8367c_getAsicStormFilterExtUnknownMulticastEnable(rtk_uint32 *pEnabled)
{
if(NULL == pEnabled)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_UNKNOWN_MCAST_EXT_EN_OFFSET, pEnabled);
}

The above function is used to get Asic storm filter Ext unknown multicast enable.
The value to set is rtk_uint32.

ret_t rtl8367c_getAsicStormFilterExtUnknownMulticastDrop




NEXT




<s> extern void ase_fw_ver(unsigned int *major, unsigned int *minor)
{
ASSERT(major != NULL, "pointer is NULL");
ASSERT(minor != NULL, "pointer is NULL");

*major = FW_VER_ID->major;
*minor = FW_VER_ID->minor;
}

The above function is used to get the ASE FW version.

There are ASE_FW_MAIN and ASE_FW_SUB subsystem that maintains the version number.  This function returns the version number of
ASE FW in two parameters:




NEXT




<s> char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to send the last successfully matched text
to the standard output.

#endif

/* The funnel gets called from user code. */
/* This is used to report a fatal FLEX_ERRNO during parser generation.
*/




NEXT




<s> int sata_core_has_scsi_waiters(struct ata_host *ah)
{
int has_waiters;
unsigned long flags;
struct sata_oxnas_host_priv *hd = ah->private_data;

spin_lock_irqsave(&hd->core_lock, flags);
has_waiters = hd->scsi_nonblocking_attempts ||
!list_empty(&hd->scsi_wait_queue.head);
spin_unlock_irqrestore(&hd->core_lock, flags);

return has_waiters;
}

The above function is used to check for active SCSI wait
and non-block requests on a port. It is used by the SATA core
and some drivers to determine if any I/O requests are active.</s>




NEXT




<s> annex_t get_annex(const uint8_t *xtse) {
if ((xtse[0] & XTSE_1_01_A_T1_413) ||
(xtse[0] & XTSE_1_03_A_1_NO) ||
(xtse[0] & XTSE_1_04_A_1_O) ||
(xtse[1] & XTSE_2_01_A_2_NO) ||
(xtse[2] & XTSE_3_03_A_3_NO) ||
(xtse[2] & XTSE_3_04_A_3_O) ||
(xtse[3] & XTSE_4_01_A_4_NO) ||
(xtse[3] & XTSE_4_02_A_4_O) ||
(xtse[5] & XTSE_6_01_A_5_NO) ||
(xtse[5] & XTSE_6_02_A_5_O) ||
(xtse[7] & XTSE_8_01_A))
return ANNEX_A;

if ((xtse[0] & XTSE_1_05_B_1_NO) ||
(xtse[0] & XTSE_1_06_B_1_O) ||
(xtse[1] & XTSE_2_02_B_2_O) ||
(xtse[2] & XTSE_3_05_B_3_NO) ||
(xtse[2] & XTSE_3_06_B_3_O) ||
(xtse[5] & XTSE_6_03_B_5_NO) ||
(xtse[5] & XTSE_6_04_B_5_O) ||
(xtse[7] & XTSE_8_02_B))
return ANNEX_B;

if ((xtse[0] & XTSE_1_02_C_TS_101388) ||
(xtse[0] & XTSE_1_07_C_1_NO) ||
(xtse[0] & XTSE_1_08_C_1_O) ||
(xtse[1] & XTSE_2_03_C_2_NO) ||
(xtse[1] & XTSE_2_04_C_2_O) ||
(xtse[7] & XTSE_8_03_C))
return ANNEX_C;

if ((xtse[3] & XTSE_4_05_I_3_NO) ||
(xtse[3] & XTSE_4_06_I_3_O) ||
(xtse[4] & XTSE_5_01_I_4_NO) ||
(xtse[4] & XTSE_5_02_I_4_O) ||
(xtse[5] & XTSE_6_07_I_5_NO) ||
(xtse[5] & XTSE_6_08_I_5_O))
return ANNEX_I;

if ((xtse[3] & XTSE_4_07_J_3_NO) ||
(xtse[3] & XTSE_4_08_J_3_O) ||
(xtse[6] & XTSE_7_01_J_5_NO) ||
(xtse[6] & XTSE_7_02_J_5_O))
return ANNEX_J;

if ((xtse[4] & XTSE_5_03_L_3_NO) ||
(xtse[4] & XTSE_5_04_L_3_NO) ||
(xtse[4] & XTSE_5_05_L_3_O) ||
(xtse[4] & XTSE_5_06_L_3_O))
return ANNEX_L;

if ((xtse[4] & XTSE_5_07_M_3_NO) ||
(xtse[4] & XTSE_5_08_M_3_O) ||
(xtse[6] & XTSE_7_03_M_5_NO) ||
(xtse[6] & XTSE_7_04_M_5_O))
return ANNEX_M;

return ANNEX_UNKNOWN;
}

The above function is used to get the Annex value from the RR field.

Annex values are from MPEG2-TS.

If you look at:
http://www.netaxis.de/mpeg2-files/

You




NEXT




<s> rtk_api_ret_t rtk_igmp_protocol_set(rtk_port_t port, rtk_igmp_protocol_t protocol, rtk_igmp_action_t action)
{
rtk_uint32      operation;
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if(protocol >= PROTOCOL_END)
return RT_ERR_INPUT;

if(action >= IGMP_ACTION_END)
return RT_ERR_INPUT;

switch(action)
{
case IGMP_ACTION_FORWARD:
operation = PROTOCOL_OP_FLOOD;
break;
case IGMP_ACTION_TRAP2CPU:
operation = PROTOCOL_OP_TRAP;
break;
case IGMP_ACTION_DROP:
operation = PROTOCOL_OP_DROP;
break;
case IGMP_ACTION_ASIC:
operation = PROTOCOL_OP_ASIC;
break;
default:
return RT_ERR_INPUT;
}

switch(protocol)
{
case PROTOCOL_IGMPv1:
if ((retVal = rtl8367c_setAsicIGMPv1Opeartion(rtk_switch_port_L2P_get(port), operation))!=RT_ERR_OK)
return retVal;

break;
case PROTOCOL_IGMPv2:
if ((retVal = rtl8367c_setAsicIGMPv2Opeartion(rtk_switch_port_L2P_get(port), operation))!=RT_ERR_OK)
return retVal;

break;
case PROTOCOL_IGMPv3:
if ((retVal = rtl8367c_setAsicIGMPv3Opeartion(rtk_switch_port_L2P_get(port), operation))!=RT_ERR_OK)
return retVal;

break;
case PROTOCOL_MLDv1:
if ((retVal = rtl8367c_setAsicMLDv1Opeartion(rtk_switch_port_L2P_get(port), operation))!=RT_ERR_OK)
return retVal;

break;
case PROTOCOL_MLDv2:
if ((retVal = rtl8367c_setAsicMLDv2Opeartion(rtk_switch_port_L2P_get(port), operation))!=RT_ERR_OK)
return retVal;

break;
default:
return RT_ERR_INPUT;

}

return RT_ERR_OK;
}

The above function is used to configure the multicast routing of the port.

Parameter:

port: Specifies to which port the multicast routing is to be applied.

protocol: Specifies the multicast protocol. The valid value




NEXT




<s> static void rtl9300_writel(struct rtl9300_i2c *i2c, u32 data)
{
writel(data, REG(i2c, RTL9300_I2C_DATA_WORD0));
}

The above function is used to write to register in rtl9300_i2c, which is defined as:

struct rtl9300_i2c { s32 i2c_base; };

but it is not




NEXT




<s> int board_nand_init(struct nand_chip *chip)
{
/* Block reset Static core */
reset_block(SYS_CTRL_RST_STATIC, 1);
reset_block(SYS_CTRL_RST_STATIC, 0);

/* Enable clock to Static core */
enable_clock(SYS_CTRL_CLK_STATIC);

/* enable flash support on static bus.
* Enable static bus onto GPIOs, only CS0 */
pinmux_set(PINMUX_BANK_MFA, 12, PINMUX_STATIC_DATA0);
pinmux_set(PINMUX_BANK_MFA, 13, PINMUX_STATIC_DATA1);
pinmux_set(PINMUX_BANK_MFA, 14, PINMUX_STATIC_DATA2);
pinmux_set(PINMUX_BANK_MFA, 15, PINMUX_STATIC_DATA3);
pinmux_set(PINMUX_BANK_MFA, 16, PINMUX_STATIC_DATA4);
pinmux_set(PINMUX_BANK_MFA, 17, PINMUX_STATIC_DATA5);
pinmux_set(PINMUX_BANK_MFA, 18, PINMUX_STATIC_DATA6);
pinmux_set(PINMUX_BANK_MFA, 19, PINMUX_STATIC_DATA7);

pinmux_set(PINMUX_BANK_MFA, 20, PINMUX_STATIC_NWE);
pinmux_set(PINMUX_BANK_MFA, 21, PINMUX_STATIC_NOE);
pinmux_set(PINMUX_BANK_MFA, 22, PINMUX_STATIC_NCS);
pinmux_set(PINMUX_BANK_MFA, 23, PINMUX_STATIC_ADDR18);
pinmux_set(PINMUX_BANK_MFA, 24, PINMUX_STATIC_ADDR19);

/* Setup the static bus CS0 to access FLASH */

writel((0x3f << STATIC_READ_CYCLE_SHIFT)
| (0x3f << STATIC_WRITE_CYCLE_SHIFT)
| (0x1f << STATIC_WRITE_PULSE_SHIFT)
| (0x03 << STATIC_TURN_AROUND_SHIFT) |
STATIC_BUS_WIDTH16,
STATIC_CTL_BANK0);

chip->cmd_ctrl = nand_hwcontrol;
chip->ecc.mode = NAND_ECC_SOFT;
chip->chip_delay = 30;
chip->dev_ready = nand_dev_ready;
chip->read_buf = nand_read_buf;

nand_dev_reset(chip);

return 0;
}

The above function is used to initialize NAND device ,but i am unable to find reset_block(SYS_CTRL_STATIC,1);reset_block(SYS_CTRL_STATIC,0);
How to access the sys_ctrl block for reset and setting




NEXT




<s> void rtl9300_sds_rxcal_leq_manual(u32 sds_num, bool manual, u32 leq_gray)
{
if (manual) {
rtl9300_sds_field_w(sds_num, 0x2e, 0x18, 15, 15, 0x1);
rtl9300_sds_field_w(sds_num, 0x2e, 0x16, 14, 10, leq_gray);
} else {
rtl9300_sds_field_w(sds_num, 0x2e, 0x18, 15, 15, 0x0);
mdelay(100);
}
}

The above function is used to force the LEQ value in the rxcal data path.
This function is very useful for validating the rxcal data as it is
configured. If you are using the same rxcal data for both training
mode and the real transmission




NEXT




<s> void loader_main(unsigned long reg_a0, unsigned long reg_a1,
unsigned long reg_a2, unsigned long reg_a3)
{
void (*kernel_entry) (unsigned long, unsigned long, unsigned long,
unsigned long);
int res;

printf("\n\nOpenWrt kernel loader for BCM63XX\n");
printf("Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>\n");
printf("Copyright (C) 2014 Jonas Gorski <jogo@openwrt.org>\n");
printf("Copyright (C) 2020 Alvaro Fernandez Rojas <noltari@gmail.com>\n");

lzma_init_data();

res = lzma_init_props();
if (res != LZMA_RESULT_OK) {
printf("Incorrect LZMA stream properties!\n");
halt();
}

printf("Decompressing kernel... ");

res = lzma_decompress((unsigned char *) kernel_la);
if (res != LZMA_RESULT_OK) {
printf("failed, ");
switch (res) {
case LZMA_RESULT_DATA_ERROR:
printf("data error!\n");
break;
default:
printf("unknown error %d!\n", res);
}
halt();
} else {
printf("done!\n");
}

flush_cache(kernel_la, lzma_outsize);

printf("Starting kernel at %08x...\n\n", kernel_la);

kernel_entry = (void *) kernel_la;
kernel_entry(reg_a0, reg_a1, reg_a2, reg_a3);
}

The above function is used to start OpenWrt and is called after hardware initialization is complete from ROM.

The kernel_la value is calculated by the bootloader when loading OpenWrt firmware image, based on the offset from the beginning of the kernel.





NEXT




<s> static int arc4_set_key(struct crypto_tfm *tfm, const u8 *inkey,
unsigned int key_len)
{
//struct arc4_ctx *ctx = crypto_tfm_ctx(tfm);
volatile struct arc4_t *arc4 = (struct arc4_t *) ARC4_START;
u32 *in_key = (u32 *)inkey;

// must program all bits at one go?!!!
//#if 1
*IFX_ARC4_CON = ( (1<<31) | ((key_len - 1)<<27) | (1<<26) | (3<<16) );
//NDC=1,ENDI=1,GO=0,KSAE=1,SM=0

arc4->K3R = *((u32 *) in_key + 0);
arc4->K2R = *((u32 *) in_key + 1);
arc4->K1R = *((u32 *) in_key + 2);
arc4->K0R = *((u32 *) in_key + 3);

#if 0 // arc4 is a ugly state machine, KSAE can only be set once per session
ctx->key_length = key_len;

memcpy ((u8 *) (ctx->buf), in_key, key_len);
#endif

return 0;
}

The above function is used to initialize the ARC4 engine. You need to copy the key and input bits from the crypto engine and into to arc4 context. You need to do it the way the engine is requesting.

For the decryption we need the crypto




NEXT




<s> hostapd_ucode_update_interfaces(void)
{
uc_value_t *ifs = ucv_object_new(vm);
uc_value_t *if_bss = ucv_array_new(vm);
uc_value_t *bss = ucv_object_new(vm);
int i;

for (i = 0; i < interfaces->count; i++) {
struct hostapd_iface *iface = interfaces->iface[i];

ucv_object_add(ifs, iface->phy, ucv_get(hostapd_ucode_iface_get_uval(iface)));
hostapd_ucode_update_bss_list(iface, if_bss, bss);
}

ucv_object_add(ucv_prototype_get(global), "interfaces", ucv_get(ifs));
ucv_object_add(ucv_prototype_get(global), "interface_bss", ucv_get(if_bss));
ucv_object_add(ucv_prototype_get(global), "bss", ucv_get(bss));
ucv_gc(vm);
}

The above function is used to read the interface parameters (ifnames)
and store them in a list to be later exposed to the APIs.

Here are some of the APIs which use these ifnames:
http://www.airties.net/




NEXT




<s> static void stop_oxnas_usb_ehci(struct oxnas_hcd *oxnas)
{
reset_control_assert(oxnas->rst_host);
reset_control_assert(oxnas->rst_phya);
reset_control_assert(oxnas->rst_phyb);

if (oxnas->use_pllb) {
clk_disable_unprepare(oxnas->phyref);
clk_disable_unprepare(oxnas->refsrc);
}
clk_disable_unprepare(oxnas->clk);
}

The above function is used to disable a USB 2.0 host. It asserts the HW
reset and subsequently turns off the PHYs and deasserts the PLL lock
signal.

The above code was found to have a dependency on the USB




NEXT




<s> void dc_ep_deassert_device(struct dc_ep_priv *priv, u32 bits)
{
struct dc_aca *aca = to_aca(priv);

spin_lock(&aca->rcu_lock);
wr32_mask(bits, 0, RCU_REQ);
spin_unlock(&aca->rcu_lock);
}

The above function is used to deassert device from rcu.

Is it possible that someone might have done this without asserting the device in rcu? And is it a good idea to disconnect the device from rcu just like that?
Why is this dis




NEXT




<s> rtk_api_ret_t rtk_ptp_portEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port is PTP port */
RTK_CHK_PORT_IS_PTP(port);

if (enable>=RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicEavPortEnable(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable and disable a port to be PTP port.
This function takes two input parameters, port, enable , the port number and enable value.  When the enable value is 1, the port will be enabled as PTP port. 




NEXT




<s> bool sym_string_valid(struct symbol *sym, const char *str)
{
signed char ch;

switch (sym->type) {
case S_STRING:
return true;
case S_INT:
ch = *str++;
if (ch == '-')
ch = *str++;
if (!isdigit(ch))
return false;
if (ch == '0' && *str != 0)
return false;
while ((ch = *str++)) {
if (!isdigit(ch))
return false;
}
return true;
case S_HEX:
if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))
str += 2;
ch = *str++;
do {
if (!isxdigit(ch))
return false;
} while ((ch = *str++));
return true;
case S_BOOLEAN:
case S_TRISTATE:
switch (str[0]) {
case 'y': case 'Y':
case 'm': case 'M':
case 'n': case 'N':
return true;
}
return false;
default:
return false;
}
}

The above function is used to validate the string against the string passed in the sym.

sym.type will return S_STRING for instance when the type of the value is of a type similar to int, but with a string associated with it, so that when the string




NEXT




<s> void fe_m32(struct fe_priv *eth, u32 clear, u32 set, unsigned reg)
{
u32 val;

spin_lock(&eth->page_lock);
val = __raw_readl(fe_base + reg);
val &= ~clear;
val |= set;
__raw_writel(val, fe_base + reg);
spin_unlock(&eth->page_lock);
}

The above function is used to write to a particular device register. I am
running an I/O operation with I2C and I don't understand what the
spin_lock and unspin_lock functions are for and how to implement them
properly.




NEXT




<s> static int rtl8231_direction_input(struct gpio_chip *gc, unsigned int offset)
{
int err;
struct rtl8231_gpios *gpios = gpiochip_get_data(gc);

pr_debug("%s: %d\n", __func__, offset);
mutex_lock(&miim_lock);
err = rtl8231_pin_dir(gpios, offset, 1);
mutex_unlock(&miim_lock);

return err;
}

The above function is used to map the direction of the gpio line to input mode. This is achieved by toggling the bit which enables the direction input in the GPDIOREG0 bitmask register.

static int rtl8231_direction_output(




NEXT




<s> int fe_connect_phy_node(struct fe_priv *priv, struct device_node *phy_node, int port)
{
const __be32 *_phy_addr = NULL;
struct phy_device *phydev;
phy_interface_t phy_mode = PHY_INTERFACE_MODE_NA;

_phy_addr = of_get_property(phy_node, "reg", NULL);

if (!_phy_addr || (be32_to_cpu(*_phy_addr) >= 0x20)) {
pr_err("%s: invalid phy id\n", phy_node->name);
return -EINVAL;
}

of_get_phy_mode(phy_node, &phy_mode);
if (phy_mode == PHY_INTERFACE_MODE_NA) {
dev_err(priv->dev, "incorrect phy-mode %d\n", phy_mode);
priv->phy->phy_node[port] = NULL;
return -EINVAL;
}

phydev = of_phy_connect(priv->netdev, phy_node, fe_phy_link_adjust,
0, phy_mode);
if (!phydev) {
dev_err(priv->dev, "could not connect to PHY\n");
priv->phy->phy_node[port] = NULL;
return -ENODEV;
}

phy_set_max_speed(phydev, SPEED_1000);
linkmode_copy(phydev->advertising, phydev->supported);
phydev->no_auto_carrier_off = 1;

dev_info(priv->dev,
"connected port %d to PHY at %s [uid=%08x, driver=%s]\n",
port, dev_name(&phydev->mdio.dev), phydev->phy_id,
phydev->drv->name);

priv->phy->phy[port] = phydev;
priv->link[port] = 0;

return 0;
}

The above function is used to connect device node to physical layer.

Now, let see how to bring up an interface using device tree:

```

Device tree file contains the link between node id and physical layer. In this case, node with id 




NEXT




<s> static void sata_oxnas_port_stop(struct ata_port *ap)
{
struct device *dev = ap->host->dev;
struct sata_oxnas_port_priv *pp = ap->private_data;
struct sata_oxnas_host_priv *host_priv = ap->host->private_data;

DPRINTK("ENTER\n");
ap->private_data = NULL;
if (host_priv->dma_size) {
iounmap(pp->sgdma_request);
} else {
dma_free_coherent(dev, SATA_OXNAS_DMA_SIZE,
pp->sgdma_request, pp->sgdma_request_pa);
}

kfree(pp);
}

The above function is used to stop the SATA Oxnas port. The DMA request
is freed here. But the code is buggy as it doesn’t set the pp->sgdma_request_pa
to NULL before using the kfree and thus when the device




NEXT




<s> static int bcm6318_pcie_probe(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct device_node *np = dev->of_node;
struct bcm6318_pcie *priv = &bcm6318_pcie;
struct resource *res;
int ret;
LIST_HEAD(resources);

of_pci_check_probe_only();

res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
priv->base = devm_ioremap_resource(dev, res);
if (IS_ERR(priv->base))
return PTR_ERR(priv->base);

priv->irq = platform_get_irq(pdev, 0);
if (!priv->irq)
return -ENODEV;

bmips_pci_irq = priv->irq;

priv->reset = devm_reset_control_get(dev, "pcie");
if (IS_ERR(priv->reset))
return PTR_ERR(priv->reset);

priv->reset_ext = devm_reset_control_get(dev, "pcie-ext");
if (IS_ERR(priv->reset_ext))
return PTR_ERR(priv->reset_ext);

priv->reset_core = devm_reset_control_get(dev, "pcie-core");
if (IS_ERR(priv->reset_core))
return PTR_ERR(priv->reset_core);

priv->reset_hard = devm_reset_control_get(dev, "pcie-hard");
if (IS_ERR(priv->reset_hard))
return PTR_ERR(priv->reset_hard);

priv->clk = devm_clk_get(dev, "pcie");
if (IS_ERR(priv->clk))
return PTR_ERR(priv->clk);

priv->clk25 = devm_clk_get(dev, "pcie25");
if (IS_ERR(priv->clk25))
return PTR_ERR(priv->clk25);

priv->clk_ubus = devm_clk_get(dev, "pcie-ubus");
if (IS_ERR(priv->clk_ubus))
return PTR_ERR(priv->clk_ubus);

ret = clk_prepare_enable(priv->clk);
if (ret) {
dev_err(dev, "could not enable clock\n");
return ret;
}

ret = clk_prepare_enable(priv->clk25);
if (ret) {
dev_err(dev, "could not enable clock\n");
return ret;
}

ret = clk_prepare_enable(priv->clk_ubus);
if (ret) {
dev_err(dev, "could not enable clock\n");
return ret;
}

pci_load_of_ranges(&bcm6318_pcie_controller, np);
if (!bcm6318_pcie_mem_resource.start)
return -EINVAL;

of_pci_parse_bus_range(np, &bcm6318_pcie_busn_resource);
pci_add_resource(&resources, &bcm6318_pcie_busn_resource);

bcm6318_pcie_reset(priv);
bcm6318_pcie_setup(priv);

register_pci_controller(&bcm6318_pcie_controller);

return 0;
}

The above function is used to find and bind the platform device driver for the bcm6318 PCIe controller. The function first initializes the PCI ID values, which are obtained from the device tree. It then checks the PCI bridge’s vendor ID and device ID




NEXT




<s> rtk_api_ret_t rtk_qos_priMap_set(rtk_queue_num_t queue_num, rtk_qos_pri2queue_t *pPri2qid)
{
rtk_api_ret_t retVal;
rtk_uint32 pri;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((0 == queue_num) || (queue_num > RTK_MAX_NUM_OF_QUEUE))
return RT_ERR_QUEUE_NUM;

for (pri = 0; pri <= RTK_PRIMAX; pri++)
{
if (pPri2qid->pri2queue[pri] > RTK_QIDMAX)
return RT_ERR_QUEUE_ID;

if ((retVal = rtl8367c_setAsicPriorityToQIDMappingTable(queue_num - 1, pri, pPri2qid->pri2queue[pri])) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to setup the mapped queue for a certain priority. The mapped queue is specified by the rt_qos_enable_t structure, and the parameter is the number of the priority of the queue. Queue 0 to 7 correspond to the priority




NEXT




<s> static ssize_t rtl8366_read_debugfs_pvid(struct file *file,
char __user *user_buf,
size_t count, loff_t *ppos)
{
struct rtl8366_smi *smi = (struct rtl8366_smi *)file->private_data;
char *buf = smi->buf;
int len = 0;
int i;

len += snprintf(buf + len, sizeof(smi->buf) - len, "%4s %4s\n",
"port", "pvid");

for (i = 0; i < smi->num_ports; i++) {
int pvid;
int err;

err = rtl8366_get_pvid(smi, i, &pvid);
if (err)
len += snprintf(buf + len, sizeof(smi->buf) - len,
"%4d error\n", i);
else
len += snprintf(buf + len, sizeof(smi->buf) - len,
"%4d %4d\n", i, pvid);
}

return simple_read_from_buffer(user_buf, count, ppos, buf, len);
}

The above function is used to retrieve the content of port status, if the application is configured for default. If the function call is found to be not found on your device, please refer to our technical support engineer for further assistance.

## Conclusion

In conclusion,




NEXT




<s> ret_t rtl8367c_getAsicPortPage(rtk_uint32 port, rtk_uint32 *pPageCount)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
return rtl8367c_getAsicRegBits(RTL8367C_FLOWCTRL_PORT_PAGE_COUNTER_REG(port), RTL8367C_FLOWCTRL_PORT_PAGE_COUNTER_MASK, pPageCount);
else
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT8_PAGE_COUNTER+port - 8, RTL8367C_FLOWCTRL_PORT_PAGE_COUNTER_MASK, pPageCount);
}

The above function is used to get the value of 'port page number' that is inside RTL8367_REGFLOWCTRL_PORTA_PAGE_COUNTER0 or the port8 part (port8 page counter).

For the case you




NEXT




<s> void rtl9300_phy_enable_10g_1g(int sds_num)
{
u32 v;

/* Enable 1GBit PHY */
v = rtl930x_read_sds_phy(sds_num, PHY_PAGE_2, MII_BMCR);
pr_info("%s 1gbit phy: %08x\n", __func__, v);
v &= ~BMCR_PDOWN;
rtl930x_write_sds_phy(sds_num, PHY_PAGE_2, MII_BMCR, v);
pr_info("%s 1gbit phy enabled: %08x\n", __func__, v);

/* Enable 10GBit PHY */
v = rtl930x_read_sds_phy(sds_num, PHY_PAGE_4, MII_BMCR);
pr_info("%s 10gbit phy: %08x\n", __func__, v);
v &= ~BMCR_PDOWN;
rtl930x_write_sds_phy(sds_num, PHY_PAGE_4, MII_BMCR, v);
pr_info("%s 10gbit phy after: %08x\n", __func__, v);

/* dal_longan_construct_mac_default_10gmedia_fiber */
v = rtl930x_read_sds_phy(sds_num, 0x1f, 11);
pr_info("%s set medium: %08x\n", __func__, v);
v |= BIT(1);
rtl930x_write_sds_phy(sds_num, 0x1f, 11, v);
pr_info("%s set medium after: %08x\n", __func__, v);
}

The above function is used to configure the PHY settings to enable 1G and 10G ports of the NIC. This will be called at the very beginning after NIC hardware is detected.</s>




NEXT




<s> static inline int superio_inb(int base, int reg)
{
outb(reg, base);
return inb(base + 1);
}

The above function is used to read a byte from the parallel port, as follows:

int x = superio_inb(0x378,0xab);

Is there any other function, which is to be used instead of inb.




NEXT




<s> static void rtl839x_vlan_tables_read(u32 vlan, struct rtl838x_vlan_info *info)
{
u32 u, v, w;
/* Read VLAN table (0) via register 0 */
struct table_reg *r = rtl_table_get(RTL8390_TBL_0, 0);

rtl_table_read(r, vlan);
u = sw_r32(rtl_table_data(r, 0));
v = sw_r32(rtl_table_data(r, 1));
w = sw_r32(rtl_table_data(r, 2));
rtl_table_release(r);

info->tagged_ports = u;
info->tagged_ports = (info->tagged_ports << 21) | ((v >> 11) & 0x1fffff);
info->profile_id = w >> 30 | ((v & 1) << 2);
info->hash_mc_fid = !!(w & BIT(2));
info->hash_uc_fid = !!(w & BIT(3));
info->fid = (v >> 3) & 0xff;

/* Read UNTAG table (0) via table register 1 */
r = rtl_table_get(RTL8390_TBL_1, 0);
rtl_table_read(r, vlan);
u = sw_r32(rtl_table_data(r, 0));
v = sw_r32(rtl_table_data(r, 1));
rtl_table_release(r);

info->untagged_ports = u;
info->untagged_ports = (info->untagged_ports << 21) | ((v >> 11) & 0x1fffff);
}

The above function is used to read the VLAN tables from the RTL839X
controller.  We use the first register in each table to select the
VLAN whose tables we’re interested in, then read the table in bits
0-31




NEXT




<s> static ssize_t ubootenv_write(struct file *file, const char __user *buffer, size_t count,
loff_t *ppos)
{
struct ubootenv_drvdata *data = to_ubootenv_drvdata(file);

if (!data->env)
return -EIO;
return simple_write_to_buffer(data->env, data->rmem->size, ppos, buffer, count);
}

The above function is used to update content of the u-boot environment from the user. The above function will copy the user
defined content to the environment (ubootenv) storage.</s>




NEXT




<s> static int esw_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
u32 vmsc, poc2;
int vlan_idx = -1;
int i;

val->len = 0;

if (val->port_vlan < 0 || val->port_vlan >= RT305X_ESW_NUM_VIDS)
return -EINVAL;

/* valid vlan? */
for (i = 0; i < RT305X_ESW_NUM_VLANS; i++) {
if (esw_get_vlan_id(esw, i) == val->port_vlan &&
esw_get_vmsc(esw, i) != RT305X_ESW_PORTS_NONE) {
vlan_idx = i;
break;
}
}

if (vlan_idx == -1)
return -EINVAL;

vmsc = esw_get_vmsc(esw, vlan_idx);
poc2 = esw_r32(esw, RT305X_ESW_REG_POC2);

for (i = 0; i < RT305X_ESW_NUM_PORTS; i++) {
struct switch_port *p;
int port_mask = 1 << i;

if (!(vmsc & port_mask))
continue;

p = &val->value.ports[val->len++];
p->id = i;
if (poc2 & (port_mask << RT305X_ESW_POC2_UNTAG_EN_S))
p->flags = 0;
else
p->flags = 1 << SWITCH_PORT_FLAG_TAGGED;
}

return 0;
}

The above function is used to get the list of member ports of the specified vlanid. The valid member port is checked by the function esw_get_vmsc() which has the following algorithm:

u32 esw_get_vmsc(struct




NEXT




<s> static void dma_port_cfg(struct dc_ep_dev *dev)
{
u32 reg = 0;

reg |= (DMA_TX_PORT_DEFAULT_WEIGHT << 12);
reg |= (DMA_ENDIAN_TYPE0 << 10);
reg |= (DMA_ENDIAN_TYPE0 << 8);
reg |= (DMA_PKT_DROP_DISABLE << 6);
reg |= 0x3;
ep_wr32(0, DMA_PS);
ep_wr32(reg, DMA_PCTRL);
}

The above function is used to setup the correct configuration for the DMA port. The function does the following for this example:

Sets the endpoint endpoint DMA weight to 0x4. See the 850F DMAC reference manual for a more general description.





NEXT




<s> static u64 rtl931x_read_mcast_pmask(int idx)
{
u64 portmask;
/* Read MC_PMSK (2) via register RTL9310_TBL_0 */
struct table_reg *q = rtl_table_get(RTL9310_TBL_0, 2);

rtl_table_read(q, idx);
portmask = sw_r32(rtl_table_data(q, 0));
portmask <<= 32;
portmask |= sw_r32(rtl_table_data(q, 1));
portmask >>= 7;
rtl_table_release(q);

pr_debug("%s: Index idx %d has portmask %016llx\n", __func__, idx, portmask);

return portmask;
}

The above function is used to read MCFP(multi cast filtering pointer) table 1 bit (64 bytes at 0x1a0 address )

From the documentation it is clearly seen that offset within the table ranges from 0 to 40




NEXT




<s> __hostapd_bss_mgmt_enable_f(struct hostapd_data *hapd, int flag)
{
struct hostapd_bss_config *bss = hapd->conf;
uint32_t flags;

switch (flag) {
case BSS_MGMT_EN_NEIGHBOR:
if (bss->radio_measurements[0] &
WLAN_RRM_CAPS_NEIGHBOR_REPORT)
return false;

bss->radio_measurements[0] |=
WLAN_RRM_CAPS_NEIGHBOR_REPORT;
hostapd_neighbor_set_own_report(hapd);
return true;
case BSS_MGMT_EN_BEACON:
flags = WLAN_RRM_CAPS_BEACON_REPORT_PASSIVE |
WLAN_RRM_CAPS_BEACON_REPORT_ACTIVE |
WLAN_RRM_CAPS_BEACON_REPORT_TABLE;

if (bss->radio_measurements[0] & flags == flags)
return false;

bss->radio_measurements[0] |= (u8) flags;
return true;
case BSS_MGMT_EN_LINK_MEASUREMENT:
flags = WLAN_RRM_CAPS_LINK_MEASUREMENT;

if (bss->radio_measurements[0] & flags == flags)
return false;

bss->radio_measurements[0] |= (u8) flags;
return true;
#ifdef CONFIG_WNM_AP
case BSS_MGMT_EN_BSS_TRANSITION:
if (bss->bss_transition)
return false;

bss->bss_transition = 1;
return true;
#endif
}
}

The above function is used to enable/disable reporting of the corresponding
measurement via RRM Reporting Mechanism.

The following function is used to send out the RRM Report via RRM Reporting
Mechanism.

__hostapd_bss




NEXT




<s> static struct clk_hw *en7523_register_pcie_clk(struct device *dev,
void __iomem *np_base)
{
static const struct clk_ops pcie_gate_ops = {
.is_enabled = en7523_pci_is_enabled,
.prepare = en7523_pci_prepare,
.unprepare = en7523_pci_unprepare,
};
struct clk_init_data init = {
.name = "pcie",
.ops = &pcie_gate_ops,
};
struct en_clk_gate *cg;

cg = devm_kzalloc(dev, sizeof(*cg), GFP_KERNEL);
if (!cg)
return NULL;

cg->base = np_base;
cg->hw.init = &init;
en7523_pci_unprepare(&cg->hw);

if (clk_hw_register(dev, &cg->hw))
return NULL;

return &cg->hw;
}

The above function is used to register the PCIE clock gating driver with the clock framework. This function is used on the device where the PCIE bus is used, for registering the driver. Once the function is invoked on the device the clock hardware register is initialized, and




NEXT




<s> static int bcm4908img_calc_crc32(FILE *fp, struct bcm4908img_info *info) {
uint8_t buf[1024];
size_t length;
size_t bytes;

/* Start with cferom (or bootfs) - skip vendor header */
fseek(fp, info->cferom_offset, SEEK_SET);

info->crc32 = 0xffffffff;
length = info->tail_offset - info->cferom_offset;
while (length && (bytes = fread(buf, 1, bcm4908img_min(sizeof(buf), length), fp)) > 0) {
info->crc32 = bcm4908img_crc32(info->crc32, buf, bytes);
length -= bytes;
}
if (length) {
fprintf(stderr, "Failed to read last %zd B of data\n", length);
return -EIO;
}

return 0;
}

The above function is used to calculate the CRC32 of an image file.
It is called from bcm4908img_sanity_check()

The original version of the function (found here --
bcm4908img_calc




NEXT




<s> static int ag71xx_tx_packets(struct ag71xx *ag, bool flush, int budget);

static inline unsigned int ag71xx_max_frame_len(unsigned int mtu)
{
return ETH_SWITCH_HEADER_LEN + ETH_HLEN + VLAN_HLEN + mtu + ETH_FCS_LEN;
}

The above function is used to return for maximum allowable EtherType frame size in Ethernet Frame Switching mode. The EtherType data is added to an Ethernet frame and passed to a bridge.

/*
* Function:
*	ag7




NEXT




<s> static __inline__ void blast_dcache(unsigned long size, unsigned long lsize)
{
unsigned long start = KSEG0;
unsigned long end = (start + size);

while(start < end) {
cache_unroll(start,Index_Writeback_Inv_D);
start += lsize;
}
}

The above function is used to purge cache for the entire physical memory space i.e. from KSEG0 to end of physical
memory. This is not a good idea as it takes few seconds to purge entire memory space. It is advised to use this





NEXT




<s> static int rtl8366rb_sw_set_port_rate_in(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

if (val->port_vlan >= RTL8366RB_NUM_PORTS)
return -EINVAL;

if (val->value.i > 0 && val->value.i < RTL8366RB_BDTH_SW_MAX)
val->value.i = (val->value.i - 1) / RTL8366RB_BDTH_UNIT;
else
val->value.i = RTL8366RB_BDTH_REG_DEFAULT;

return rtl8366_smi_rmwr(smi, RTL8366RB_IB_REG(val->port_vlan),
RTL8366RB_IB_BDTH_MASK | RTL8366RB_IB_PREIFG_MASK,
val->value.i |
(RTL8366RB_QOS_DEFAULT_PREIFG << RTL8366RB_IB_PREIFG_OFFSET));

}

The above function is used to set the port rate through sw_set.

The RTL8366RB_BDTH_MASK is the BDTH register mask as shown in the following diagram:

The bits 14:11 and 




NEXT




<s> rtk_api_ret_t rtk_dot1x_macBasedDirection_set(rtk_dot1x_direction_t mac_direction)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (mac_direction >= DIRECTION_END)
return RT_ERR_DOT1X_MACBASEDOPDIR;

if ((retVal = rtl8367c_setAsic1xMBOpdirConfig(mac_direction)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to change direction from client to infrastructure (access point) for the Mac Based Authentication, and vice versa.

When set to INFRASTRUCTURE, the supplicant needs to specify an RSNA session key and then the AP sends




NEXT




<s> rtk_api_ret_t rtk_vlan_keep_set(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask)
{
rtk_api_ret_t retVal;
rtk_uint32    pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(egr_port);

if(NULL == pIgr_pmask)
return RT_ERR_NULL_POINTER;

RTK_CHK_PORTMASK_VALID(pIgr_pmask);

if(rtk_switch_portmask_L2P_get(pIgr_pmask, &pmask) != RT_ERR_OK)
return RT_ERR_FAILED;

if ((retVal = rtl8367c_setAsicVlanEgressKeep(rtk_switch_port_L2P_get(egr_port), pmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the port(s) to do VLAN filtering. The port(s) can’t receive any VLAN tagged packets.

The above function has an argument, which means that the VLAN tag can be kept for the




NEXT




<s> radius_user_get(struct radius_user_data *s, const char *name)
{
struct blob_attr *cur;
int rem;

cur = kvlist_get(&s->users, name);
if (cur)
return cur;

blobmsg_for_each_attr(cur, s->wildcard, rem) {
static const struct blobmsg_policy policy = {
"name", BLOBMSG_TYPE_STRING
};
struct blob_attr *pattern;

if (blobmsg_type(cur) != BLOBMSG_TYPE_TABLE)
continue;

blobmsg_parse(&policy, 1, &pattern, blobmsg_data(cur), blobmsg_len(cur));
if (!name)
continue;

if (!fnmatch(blobmsg_get_string(pattern), name, 0))
return cur;
}

return NULL;
}

The above function is used to obtain the radius-client's user data, using either a direct match of 'name' against attribute 'name' (which obviously can't be used) or via the wildcard pattern matching attribute, which is used.

As previously




NEXT




<s> void _menu_init(void)
{
current_entry = current_menu = &rootmenu;
last_entry_ptr = &rootmenu.list;
}

The above function is used to initialize the menu system used by Archer to
select different tasks/programs. _menu_init() needs to be called at the
very beginning before any of the menu functions are used and before
calling the main loop of Archer




NEXT




<s> int board_early_init_f(void)
{
return 0;
}

The above function is used to perform any early-init type operations before
the system boot.  The only difference on most MIPS implementations is that on
the 4500, the early-init code is passed as an parameter to start_kernel. 




NEXT




<s> ar8xxx_phy_probe(struct phy_device *phydev)
{
struct ar8xxx_priv *priv;
struct switch_dev *swdev;
int ret;

/* skip PHYs at unused adresses */
if (phydev->mdio.addr != 0 && phydev->mdio.addr != 3 && phydev->mdio.addr != 4)
return -ENODEV;

if (!ar8xxx_is_possible(phydev->mdio.bus))
return -ENODEV;

mutex_lock(&ar8xxx_dev_list_lock);
list_for_each_entry(priv, &ar8xxx_dev_list, list)
if (priv->mii_bus == phydev->mdio.bus)
goto found;

priv = ar8xxx_create();
if (priv == NULL) {
ret = -ENOMEM;
goto unlock;
}

priv->mii_bus = phydev->mdio.bus;
priv->pdev = &phydev->mdio.dev;

ret = of_property_read_u32(priv->pdev->of_node, "qca,mib-poll-interval",
&priv->mib_poll_interval);
if (ret)
priv->mib_poll_interval = 0;

ret = ar8xxx_id_chip(priv);
if (ret)
goto free_priv;

ret = ar8xxx_probe_switch(priv);
if (ret)
goto free_priv;

swdev = &priv->dev;
swdev->alias = dev_name(&priv->mii_bus->dev);
ret = register_switch(swdev, NULL);
if (ret)
goto free_priv;

pr_info("%s: %s rev. %u switch registered on %s\n",
swdev->devname, swdev->name, priv->chip_rev,
dev_name(&priv->mii_bus->dev));

list_add(&priv->list, &ar8xxx_dev_list);

found:
priv->use_count++;

if (phydev->mdio.addr == 0 && priv->chip->config_at_probe) {
priv->phy = phydev;

ret = ar8xxx_start(priv);
if (ret)
goto err_unregister_switch;
} else if (priv->chip->phy_rgmii_set) {
priv->chip->phy_rgmii_set(priv, phydev);
}

phydev->priv = priv;

mutex_unlock(&ar8xxx_dev_list_lock);

return 0;

err_unregister_switch:
if (--priv->use_count)
goto unlock;

unregister_switch(&priv->dev);

free_priv:
ar8xxx_free(priv);
unlock:
mutex_unlock(&ar8xxx_dev_list_lock);
return ret;
}

The above function is used to initialize ar8327 phy driver by probing the phy address in the device tree and populate those into phy device sturct .In this case phy address is 0 of the MDIO bus then it will initialize




NEXT




<s> ar8216_wait_atu_ready(struct ar8xxx_priv *priv, u16 r2, u16 r1)
{
int timeout = 20;

while (ar8xxx_mii_read32(priv, r2, r1) & AR8216_ATU_ACTIVE && --timeout) {
udelay(10);
cond_resched();
}

if (!timeout)
pr_err("ar8216: timeout waiting for atu to become ready\n");
}

The above function is used to wait for ATU completion and error-reporting
functionality. Unfortunately it assumes that, if atu is working, it could go
fast enough. As atu works on internal registers, it often goes slower than
sdram.




NEXT




<s> static int rtl9310_i2c_config_xfer(struct rtl9300_i2c *i2c, u16 addr, u16 len)
{
/* Set bus frequency */
REG_MASK(i2c, 0x3 << RTL9310_I2C_CTRL_SCL_FREQ,
i2c->bus_freq << RTL9310_I2C_CTRL_SCL_FREQ, RTL9310_I2C_CTRL);

/* Set slave device address */
REG_MASK(i2c, 0x7f << RTL9310_I2C_CTRL_DEV_ADDR,
addr << RTL9310_I2C_CTRL_DEV_ADDR, RTL9310_I2C_CTRL);

/* Set data length */
REG_MASK(i2c, 0xf << RTL9310_I2C_CTRL_DATA_WIDTH,
((len - 1) & 0xf) << RTL9310_I2C_CTRL_DATA_WIDTH, RTL9310_I2C_CTRL);

/* Set read mode to random */
REG_MASK(i2c, 0x1 << RTL9310_I2C_CTRL_READ_MODE, 0, RTL9310_I2C_CTRL);

return 0;
}

The above function is used to set I2C bus frequency, set slave device address as well as set data length. After this function being called, all that will be needed is to start the bus by calling rtl9310_i2c_start().</s>




NEXT




<s> static void init_one_color(struct dialog_color *color)
{
static int pair = 0;

pair++;
init_pair(pair, color->fg, color->bg);
if (color->hl)
color->atr = A_BOLD | COLOR_PAIR(pair);
else
color->atr = COLOR_PAIR(pair);
}

The above function is used to initiate a specific palette/color/highlightedness. The attr member is set according to the color's hl flag, and an A_BOLD term is added if so. The function takes no parameter, so the pal




NEXT




<s> static int conf_choice(struct menu *menu)
{
struct symbol *sym, *def_sym;
struct menu *child;
bool is_new;

sym = menu->sym;
is_new = !sym_has_value(sym);
if (sym_is_changeable(sym)) {
conf_sym(menu);
sym_calc_value(sym);
switch (sym_get_tristate_value(sym)) {
case no:
return 1;
case mod:
return 0;
case yes:
break;
}
} else {
switch (sym_get_tristate_value(sym)) {
case no:
return 1;
case mod:
printf("%*s%s\n", indent - 1, "", menu_get_prompt(menu));
return 0;
case yes:
break;
}
}

while (1) {
int cnt, def;

printf("%*s%s\n", indent - 1, "", menu_get_prompt(menu));
def_sym = sym_get_choice_value(sym);
cnt = def = 0;
line[0] = 0;
for (child = menu->list; child; child = child->next) {
if (!menu_is_visible(child))
continue;
if (!child->sym) {
printf("%*c %s\n", indent, '*', menu_get_prompt(child));
continue;
}
cnt++;
if (child->sym == def_sym) {
def = cnt;
printf("%*c", indent, '>');
} else
printf("%*c", indent, ' ');
printf(" %d. %s", cnt, menu_get_prompt(child));
if (child->sym->name)
printf(" (%s)", child->sym->name);
if (!sym_has_value(child->sym))
printf(" (NEW)");
printf("\n");
}
printf("%*schoice", indent - 1, "");
if (cnt == 1) {
printf("[1]: 1\n");
goto conf_childs;
}
printf("[1-%d?]: ", cnt);
switch (input_mode) {
case oldconfig:
case syncconfig:
if (!is_new) {
cnt = def;
printf("%d\n", cnt);
break;
}
/* fall through */
case oldaskconfig:
fflush(stdout);
xfgets(line, sizeof(line), stdin);
strip(line);
if (line[0] == '?') {
print_help(menu);
continue;
}
if (!line[0])
cnt = def;
else if (isdigit(line[0]))
cnt = atoi(line);
else
continue;
break;
default:
break;
}

conf_childs:
for (child = menu->list; child; child = child->next) {
if (!child->sym || !menu_is_visible(child))
continue;
if (!--cnt)
break;
}
if (!child)
continue;
if (line[0] && line[strlen(line) - 1] == '?') {
print_help(child);
continue;
}
sym_set_choice_value(sym, child->sym);
for (child = child->list; child; child = child->next) {
indent += 2;
conf(child);
indent -= 2;
}
return 1;
}
}

The above function is used to provide a choice between available
symbolic values.

static int conf_sym(struct menu *menu)
{
struct symbol *sym;
bool sym_show_name;
static const char *optname = "name";




NEXT




<s> static int mt7621_nfc_set_page_format(struct mt7621_nfc *nfc)
{
struct nand_chip *nand = &nfc->nand;
struct mtd_info *mtd = nand_to_mtd(nand);
int i, spare_size;
u32 pagefmt;

spare_size = mt7621_nfc_set_spare_per_sector(nfc);
if (spare_size < 0)
return spare_size;

for (i = 0; i < ARRAY_SIZE(mt7621_nfi_page_size); i++) {
if (mt7621_nfi_page_size[i] == mtd->writesize)
break;
}

if (unlikely(i >= ARRAY_SIZE(mt7621_nfi_page_size))) {
dev_err(nfc->dev, "Page size (%u) is not supported\n",
mtd->writesize);
return -EINVAL;
}

pagefmt = i | (spare_size << PAGEFMT_SPARE_S) |
(NFI_FDM_SIZE << PAGEFMT_FDM_S) |
(NFI_FDM_SIZE << PAGEFMT_FDM_ECC_S);

nfi_write16(nfc, NFI_PAGEFMT, pagefmt);

return 0;
}

The above function is used to set the page format of MT7621 EMBUS.</s>




NEXT




<s> be32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)
{
size_t i;

for (i = 0; i < len / 4; i++)
be32enc(dst + i * 4, src[i]);
}

The above function is used to convert a big endian 32-bit number to little endian 32-bit number. However, the be32enc function can have problems with endiannes if the cpu is a big endian one.

Why




NEXT




<s> hostapd_bss_update_airtime(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *ureq, const char *method,
struct blob_attr *msg)
{
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
struct blob_attr *tb[__UPDATE_AIRTIME_MAX];
struct sta_info *sta = NULL;
u8 addr[ETH_ALEN];
int weight;

blobmsg_parse(airtime_policy, __UPDATE_AIRTIME_MAX, tb, blob_data(msg), blob_len(msg));

if (!tb[UPDATE_AIRTIME_WEIGHT])
return UBUS_STATUS_INVALID_ARGUMENT;

weight = blobmsg_get_u32(tb[UPDATE_AIRTIME_WEIGHT]);

if (!tb[UPDATE_AIRTIME_STA]) {
if (!weight)
return UBUS_STATUS_INVALID_ARGUMENT;

hapd->conf->airtime_weight = weight;
return 0;
}

if (hwaddr_aton(blobmsg_data(tb[UPDATE_AIRTIME_STA]), addr))
return UBUS_STATUS_INVALID_ARGUMENT;

sta = ap_get_sta(hapd, addr);
if (!sta)
return UBUS_STATUS_NOT_FOUND;

sta->dyn_airtime_weight = weight;
airtime_policy_new_sta(hapd, sta);

return 0;
}

The above function is used to update the weight given to specific station. If weight >= 0 or 0, it's used to reset the dyn_airtime_weight value. Otherwise it will use the absolute value of dyn_airtime_weight as the final value




NEXT




<s> nisent = _yp_gettpnam(user);    /* Entry is +username or + */
if(nisent != NULL) {
savepwent(tpw, &nisent->tp);
return &tpw->pebuf;
}

The above function is used to translate a login by an entry in the network
Information System database.

After the call to _yp_gettpnam and the savepwent, the _tpent is loaded.
The _tpent is then loaded by a call




NEXT




<s> static int bcm4908img_create(int argc, char **argv) {
struct bcm4908img_tail tail = {
.version = cpu_to_le32(WFI_VERSION),
.chip_id = cpu_to_le32(0x4908),
.flash_type = cpu_to_le32(WFI_NAND128_FLASH),
.flags = cpu_to_le32(WFI_FLAG_SUPPORTS_BTRM),
};
uint32_t crc32 = 0xffffffff;
size_t cur_offset = 0;
ssize_t bytes;
FILE *fp;
int c;
int err = 0;

if (argc < 3) {
fprintf(stderr, "No BCM4908 image pathname passed\n");
err = -EINVAL;
goto out;
}
pathname = argv[2];

fp = fopen(pathname, "w+");
if (!fp) {
fprintf(stderr, "Failed to open %s\n", pathname);
err = -EACCES;
goto out;
}

optind = 3;
while ((c = getopt(argc, argv, "f:a:A:")) != -1) {
switch (c) {
case 'f':
bytes = bcm4908img_create_append_file(fp, optarg, &crc32);
if (bytes < 0) {
fprintf(stderr, "Failed to append file %s\n", optarg);
} else {
cur_offset += bytes;
}
break;
case 'a':
bytes = bcm4908img_create_align(fp, cur_offset, strtol(optarg, NULL, 0));
if (bytes < 0)
fprintf(stderr, "Failed to append zeros\n");
else
cur_offset += bytes;
break;
case 'A':
bytes = strtol(optarg, NULL, 0) - cur_offset;
if (bytes < 0) {
fprintf(stderr, "Current BCM4908 image length is 0x%zx, can't pad it with zeros to 0x%lx\n", cur_offset, strtol(optarg, NULL, 0));
} else {
bytes = bcm4908img_create_append_zeros(fp, bytes);
if (bytes < 0)
fprintf(stderr, "Failed to append zeros\n");
else
cur_offset += bytes;
}
break;
}
if (err)
goto err_close;
}

tail.crc32 = cpu_to_le32(crc32);

bytes = fwrite(&tail, 1, sizeof(tail), fp);
if (bytes != sizeof(tail)) {
fprintf(stderr, "Failed to write BCM4908 image tail to %s\n", pathname);
return -EIO;
}

err_close:
fclose(fp);
out:
return err;
}

The above function is used to create the BCM4908 image file. The actual image content may include:
1. firmware image
2. bootrom_hdr
3. nand_config
4. other system configuration data
5. APP




NEXT




<s> rtl_get_use_cpuport(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct rtl_priv *priv = to_rtl(dev);
val->value.i = priv->do_cpu;
return 0;
}

The above function is used to fill the val with CPU-related stuff,
since it's an attribute of a CPU interface, and the CPU's info is
stored in struct rtl_priv. The return value indicates the function's
return value,




NEXT




<s> seama_fix_md5(struct seama_entity_header *shdr, int fd, size_t data_offset, size_t data_size)
{
char *buf;
ssize_t res;
MD5_CTX ctx;
unsigned char digest[16];
int i;
int err = 0;

buf = malloc(data_size);
if (!buf) {
err = -ENOMEM;
goto err_out;
}

res = pread(fd, buf, data_size, data_offset);
if (res != data_size) {
perror("pread");
err = -EIO;
goto err_free;
}

MD5_Init(&ctx);
MD5_Update(&ctx, buf, data_size);
MD5_Final(digest, &ctx);

if (!memcmp(digest, shdr->md5, sizeof(digest))) {
if (quiet < 2)
fprintf(stderr, "the header is fixed already\n");
return -1;
}

if (quiet < 2) {
fprintf(stderr, "new size:%u, new MD5: ", data_size);
for (i = 0; i < sizeof(digest); i++)
fprintf(stderr, "%02x", digest[i]);

fprintf(stderr, "\n");
}

/* update the size in the image */
shdr->size = htonl(data_size);

/* update the checksum in the image */
memcpy(shdr->md5, digest, sizeof(digest));

err_free:
free(buf);
err_out:
return err;
}

The above function is used to re-compute and update the size and md5 of one single blob. This can be slow so let’s do multi-thread.

To do it nicely I’ve used a shared linked list data structure. I’m using linked




NEXT




<s> static int do_get(nvram_handle_t *nvram, const char *var)
{
const char *val;
int stat = 1;

if( (val = nvram_get(nvram, var)) != NULL )
{
printf("%s\n", val);
stat = 0;
}

return stat;
}

The above function is used to download the contents of a variable that resides in the NV ROM.
Please note, that if there is no variable with the given name, the answer is NULL and the
standard function "strcmp" tells that that there's no match




NEXT




<s> static void rtk_hal_write_reg(unsigned int reg_addr , unsigned int reg_val)
{
ret_t retVal;

retVal = smi_write(reg_addr, reg_val);

if(retVal != RT_ERR_OK)
printk("switch reg write failed\n");
else
printk("write switch reg0x%x 0x%x success\n", reg_addr, reg_val);
}

The above function is used to write a 32-bit register (reg: reg0 to reg4095) in the HAL (Hardware Abstraction Layer) library of the switch driver. However, the above function is only supported to write the first




NEXT




<s> int rtl8366_smi_rmwr(struct rtl8366_smi *smi, u32 addr, u32 mask, u32 data)
{
u32 t;
int err;

err = rtl8366_smi_read_reg(smi, addr, &t);
if (err)
return err;

err = rtl8366_smi_write_reg(smi, addr, (t & ~mask) | data);
return err;

}

The above function is used to modify multiple bits. The function, in order to get the old value, calls “smi_read_reg” function for this. The function does not return any read value. Therefore, the value that was obtained is lost. Thus, the




NEXT




<s> static int bcm6368_enetsw_poll(struct napi_struct *napi, int budget)
{
struct bcm6368_enetsw *priv = container_of(napi, struct bcm6368_enetsw, napi);
struct net_device *ndev = priv->net_dev;
int rx_work_done;

/* ack interrupts */
dmac_writel(priv, DMAC_IR_PKTDONE_MASK,
DMAC_IR_REG, priv->rx_chan);
dmac_writel(priv, DMAC_IR_PKTDONE_MASK,
DMAC_IR_REG, priv->tx_chan);

/* reclaim sent skb */
bcm6368_enetsw_tx_reclaim(ndev, 0, budget);

spin_lock(&priv->rx_lock);
rx_work_done = bcm6368_enetsw_receive_queue(ndev, budget);
spin_unlock(&priv->rx_lock);

if (rx_work_done >= budget) {
/* rx queue is not yet empty/clean */
return rx_work_done;
}

/* no more packet in rx/tx queue, remove device from poll
* queue */
napi_complete_done(napi, rx_work_done);

/* restore rx/tx interrupt */
dmac_writel(priv, DMAC_IR_PKTDONE_MASK,
DMAC_IRMASK_REG, priv->rx_chan);
dmac_writel(priv, DMAC_IR_PKTDONE_MASK,
DMAC_IRMASK_REG, priv->tx_chan);

return rx_work_done;
}

The above function is used to check whether there is a packet available in rx queue (for receiving a packet) or not. In the above function, first we ack the interrupts for rx and tx channels using dmac_writel() and then we reclaim the sent




NEXT




<s> static void sata_oxnas_tf_read(struct ata_port *ap, struct ata_taskfile *tf)
{
struct sata_oxnas_port_priv *port_priv = ap->private_data;
void __iomem *port_base = port_priv->port_base;
/* read the orb registers */
u32 Orb1 = ioread32(port_base + ORB1);
u32 Orb2 = ioread32(port_base + ORB2);
u32 Orb3 = ioread32(port_base + ORB3);
u32 Orb4 = ioread32(port_base + ORB4);

/* read common 28/48 bit tf parameters */
tf->device = (Orb1 >> 24);
tf->nsect = (Orb2 >> 0);
tf->feature = (Orb2 >> 16);
tf->command = sata_oxnas_check_status(ap);

/* read 48 or 28 bit tf parameters */
if (tf->flags & ATA_TFLAG_LBA48) {
tf->hob_nsect = (Orb2 >> 8);
tf->lbal = (Orb3 >> 0);
tf->lbam = (Orb3 >> 8);
tf->lbah = (Orb3 >> 16);
tf->hob_lbal = (Orb3 >> 24);
tf->hob_lbam = (Orb4 >> 0);
tf->hob_lbah = (Orb4 >> 8);
/* feature ext and control are write only */
} else {
/* read 28-bit lba */
tf->lbal = (Orb3 >> 0);
tf->lbam = (Orb3 >> 8);
tf->lbah = (Orb3 >> 16);
}
}

The above function is used to access the TF read parameteres
We have 3 things here
1. The TF read parameteres
2. The orb register
3. Oxnas specific orb register reading function

At the end of the function, it will read the




NEXT




<s> rtk_api_ret_t rtk_l2_limitSystemLearningCnt_set(rtk_mac_cnt_t mac_cnt)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (mac_cnt > rtk_switch_maxLutAddrNumber_get())
return RT_ERR_LIMITED_L2ENTRY_NUM;

if ((retVal = rtl8367c_setAsicSystemLutLearnLimitNo(mac_cnt)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set macro limit system learning count. User can define the limit value. Default value is 2K

rtk_api_ret_t rtk_l2_limitSystemLearningCnt_get(rtk_mac




NEXT




<s> int mtd_write_buffer(int fd, const char *buf, int offset, int length)
{
lseek(fd, offset, SEEK_SET);
write(fd, buf, length);
return 0;
}

The above function is used to write to a file in a device-independent way.  Since
the buffer that is written must come from somewhere specific (e.g.  in the
flash area), the offset must be passed to the function to place the data





NEXT




<s> HANDLE handle = (HANDLE) _get_osfhandle(_fileno(stdin));
DWORD  mode;

GetConsoleMode( handle, &mode );
SetConsoleMode( handle, mode & ~ENABLE_ECHO_INPUT );

if(fputs(prompt, stdout) == EOF ||
fgets(buf, maxlen, stdin) == NULL) {
SetConsoleMode(handle,mode);
return -1;
}

The above function is used to disable the echo function in windows. When I used this function, it works fine in normal console. But when I run this function in windows CE device, when I used this function, the keypress of the keyboard won't show up. When




NEXT




<s> ret_t rtl8367c_setAsicStormFilterBroadcastEnable(rtk_uint32 port, rtk_uint32 enabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_STORM_BCAST_REG, port, enabled);
}

The above function is used to get the setting of the storm filter broadcast block. This function must be implemented in the 5430 driver. If the module is not connected with any storm filter broadcast block, this function may use to set any value. By default, when




NEXT




<s> trialdiv(x)
const BigInteger x;
{
static int primes[] = {               /* All odd primes < 256 */
3,   5,   7,  11,  13,  17,  19,  23,  29,
31,  37,  41,  43,  47,  53,  59,  61,  67,
71,  73,  79,  83,  89,  97, 101, 103,
107, 109, 113, 127, 131, 137, 139, 149, 151,
157, 163, 167, 173, 179, 181, 191, 193, 197,
199, 211, 223, 227, 229, 233, 239, 241, 251
};
static int nprimes = sizeof(primes) / sizeof(int);
int i;

for(i = 0; i < nprimes; ++i) {
if(BigIntegerModInt(x, primes[i]) == 0)
return primes[i];
}
return 1;
}

The above function is used to find the smallest prime factor of a big integer. I will use it in a similar way as in my earlier post:

```
void main()
{
  BigInteger big1 = 38023457




NEXT




<s> ar8xxx_sw_get_arl_age_time(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
val->value.i = priv->arl_age_time;
return 0;
}

The above function is used to provide ar8xxx software read interface that will
read the value contained in ar8xxx firmware register ARL_AGE_TIME. To read the
value contained in software private member ar8xxx_priv->arl_age_time,




NEXT




<s> int wl_glue_unregister(void)
{
int err;

if (!wl_glue_attached)
return -ENOSYS;

switch (active_bus_type)
{
#ifdef CONFIG_SSB
case WL_GLUE_BUS_TYPE_SSB:
ssb_driver_unregister(&wl_glue_ssb_driver);
err = 0;
break;
#endif /* CONFIG_SSB */

#ifdef CONFIG_BCMA
case WL_GLUE_BUS_TYPE_BCMA:
bcma_driver_unregister(&wl_glue_bcma_driver);
err = 0;
break;
#endif /* CONFIG_BCMA */

default:
pr_err("Not removing glue driver due to unsupported bus\n");
err = -ENOSYS;
break;
}

if (!err)
{
pr_info("SSB/BCMA glue driver successfully detached\n");
wl_glue_attached = 0;
}

return err;
}

The above function is used to detach the glue driver from the bus. The function can be called as a part of the core system shutdown process.

The `wl_glue_detach()` function is also used for detaching the glue driver




NEXT




<s> static int wlc_ioctl(wlc_param param, void *data, void *value)
{
unsigned int *var = ((unsigned int *) data);
unsigned int ioc = *var;

if (param & NOARG) {
return wl_ioctl(interface, ioc, NULL, 0);
}
switch(param & PARAM_TYPE) {
case MAC:
return wl_ioctl(interface, ((param & SET) ? (ioc) : (ioc >> 16)) & 0xffff, value, 6);
case INT:
return wl_ioctl(interface, ((param & SET) ? (ioc) : (ioc >> 16)) & 0xffff, value, sizeof(int));
case STRING:
return wl_ioctl(interface, ((param & SET) ? (ioc) : (ioc >> 16)) & 0xffff, value, BUFSIZE);
}
return 0;
}

The above function is used to read the MAC address etc from the wireless module.</s>




NEXT




<s> void rtl9300_sds_rst(int sds_num, u32 mode)
{
pr_info("%s %d\n", __func__, mode);
if (sds_num < 0 || sds_num > 11) {
pr_err("Wrong SerDes number: %d\n", sds_num);
return;
}

sw_w32_mask(0x1f << rtl9300_sds_lsb[sds_num], 0x1f << rtl9300_sds_lsb[sds_num],
rtl9300_sds_regs[sds_num]);
mdelay(10);

sw_w32_mask(0x1f << rtl9300_sds_lsb[sds_num], mode << rtl9300_sds_lsb[sds_num],
rtl9300_sds_regs[sds_num]);
mdelay(10);

pr_debug("%s: 194:%08x 198:%08x 2a0:%08x 2a4:%08x\n", __func__,
sw_r32(0x194), sw_r32(0x198), sw_r32(0x2a0), sw_r32(0x2a4));
}

The above function is used to set reset bit of the specific SERDES. And the following is the corresponding header in HDD driver.

static char *rtl9300_sds_reset_ops[] = {
RTL9300




NEXT




<s> rtk_api_ret_t rtk_l2_mcastAddr_del(rtk_l2_mcastAddr_t *pMcastAddr)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pMcastAddr)
return RT_ERR_NULL_POINTER;

/* must be L2 multicast address */
if( (pMcastAddr->mac.octet[0] & 0x01) != 0x01)
return RT_ERR_MAC;

if(pMcastAddr->ivl == 1)
{
if (pMcastAddr->vid > RTL8367C_VIDMAX)
return RT_ERR_L2_VID;
}
else if(pMcastAddr->ivl == 0)
{
if (pMcastAddr->fid > RTL8367C_FIDMAX)
return RT_ERR_L2_FID;
}
else
return RT_ERR_INPUT;

memset(&l2Table, 0, sizeof(rtl8367c_luttb));

/* fill key (MAC,FID) to get L2 entry */
memcpy(l2Table.mac.octet, pMcastAddr->mac.octet, ETHER_ADDR_LEN);
l2Table.ivl_svl     = pMcastAddr->ivl;

if(pMcastAddr->ivl)
l2Table.cvid_fid    = pMcastAddr->vid;
else
l2Table.cvid_fid    = pMcastAddr->fid;

method = LUTREADMETHOD_MAC;
retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
if (RT_ERR_OK == retVal)
{
memcpy(l2Table.mac.octet, pMcastAddr->mac.octet, ETHER_ADDR_LEN);
l2Table.ivl_svl     = pMcastAddr->ivl;

if(pMcastAddr->ivl)
l2Table.cvid_fid    = pMcastAddr->vid;
else
l2Table.cvid_fid    = pMcastAddr->fid;

l2Table.mbr         = 0;
l2Table.nosalearn   = 0;
l2Table.sa_block    = 0;
l2Table.l3lookup    = 0;
l2Table.lut_pri     = 0;
l2Table.fwd_en      = 0;
if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
return retVal;

pMcastAddr->address = l2Table.address;
return RT_ERR_OK;
}
else
return retVal;
}

The above function is used to delete the multicast address in ASIC. After that, we can only delete the unicast address by the rtk_l2_del function.</s>




NEXT




<s> int mtd_erase_block(int fd, int offset)
{
struct erase_info_user mtdEraseInfo;

mtdEraseInfo.start = offset;
mtdEraseInfo.length = erasesize;
ioctl(fd, MEMUNLOCK, &mtdEraseInfo);
if (ioctl (fd, MEMERASE, &mtdEraseInfo) < 0)
return -1;

return 0;
}

The above function is used to erase the erasesize amount of bytes from
offset to offset+erasesize bytes. This function can also be used to
erase a specified range from a region in the same way as this function
is being used now

What




NEXT




<s> static int bcm4908img_extract(int argc, char **argv) {
struct bcm4908img_info info;
const char *pathname = NULL;
const char *type = NULL;
uint8_t buf[1024];
size_t offset;
size_t length;
size_t bytes;
FILE *fp;
int c;
int err = 0;

while ((c = getopt(argc, argv, "i:t:")) != -1) {
switch (c) {
case 'i':
pathname = optarg;
break;
case 't':
type = optarg;
break;
}
}

fp = bcm4908img_open(pathname, "r");
if (!fp) {
fprintf(stderr, "Failed to open BCM4908 image\n");
err = -EACCES;
goto err_out;
}

err = bcm4908img_parse(fp, &info);
if (err) {
fprintf(stderr, "Failed to parse BCM4908 image\n");
goto err_close;
}

if (!type) {
err = -EINVAL;
fprintf(stderr, "No data to extract specified\n");
goto err_close;
} else if (!strcmp(type, "cferom")) {
offset = info.cferom_offset;
length = info.bootfs_offset - offset;
if (!length) {
err = -ENOENT;
fprintf(stderr, "This BCM4908 image doesn't contain cferom\n");
goto err_close;
}
} else if (!strcmp(type, "bootfs")) {
offset = info.bootfs_offset;
length = (info.padding_offset ? info.padding_offset : info.rootfs_offset) - offset;
} else if (!strcmp(type, "rootfs")) {
offset = info.rootfs_offset;
length = info.tail_offset - offset;
} else if (!strcmp(type, "firmware")) {
offset = info.bootfs_offset;
length = info.tail_offset - offset;
} else {
err = -EINVAL;
fprintf(stderr, "Unsupported extract type: %s\n", type);
goto err_close;
}

if (!length) {
err = -EINVAL;
fprintf(stderr, "Failed to find requested data in input image\n");
goto err_close;
}

fseek(fp, offset, SEEK_SET);
while (length && (bytes = fread(buf, 1, bcm4908img_min(sizeof(buf), length), fp)) > 0) {
fwrite(buf, bytes, 1, stdout);
length -= bytes;
}
if (length) {
err = -EIO;
fprintf(stderr, "Failed to read last %zd B of data\n", length);
goto err_close;
}

err_close:
bcm4908img_close(fp);
err_out:
return err;
}

The above function is used to extract the rootfs data from a BCM4908 custom image. It accepts four command line arguments:

The input file path (pathname).

"i" (followed by a file name or path) parameter spec




NEXT




<s> static void setup_windows(void);
static void search_conf(void);

typedef void (*function_key_handler_t)(int *key, struct menu *menu);
static void handle_f1(int *key, struct menu *current_item);
static void handle_f2(int *key, struct menu *current_item);
static void handle_f3(int *key, struct menu *current_item);
static void handle_f4(int *key, struct menu *current_item);
static void handle_f5(int *key, struct menu *current_item);
static void handle_f6(int *key, struct menu *current_item);
static void handle_f7(int *key, struct menu *current_item);
static void handle_f8(int *key, struct menu *current_item);
static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to register function keys.

static struct function_keys function_keys[] = {
{ 0, "Unknown", NULL, NULL },
{ "C-a", "Scroll up", NULL, &handle_f1 },
{




NEXT




<s> static int rtcl_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)
{
int tab_idx;
struct rtcl_clk *clk = rtcl_hw_to_clk(hw);
const struct rtcl_rtab_set *rtab = &rtcl_rtab_set[rtcl_ccu->soc][clk->idx];
const struct rtcl_round_set *round = &rtcl_round_set[rtcl_ccu->soc][clk->idx];

if ((parent_rate != OSC_RATE) || (!rtcl_ccu->sram.vbase))
return -EINVAL;
/*
* Currently we do not know if SRAM is stable on these devices. Maybe someone
* changes memory in this region and does not care about proper allocation. So
* check if something might go wrong.
*/
if (unlikely(*rtcl_ccu->sram.pmark != RTL_SRAM_MARKER)) {
dev_err(&rtcl_ccu->pdev->dev, "SRAM code lost\n");
return -EINVAL;
}

tab_idx = (rate - round->min) / round->step;
if ((tab_idx < 0) || (tab_idx >= rtab->count) || (rtab->rset[tab_idx].rate != rate))
return -EINVAL;

rtcl_ccu->clks[clk->idx].rate = rate;

switch (rtcl_ccu->soc) {
case SOC_RTL838X:
return rtcl_838x_set_rate(clk->idx, &rtab->rset[tab_idx]);
case SOC_RTL839X:
return rtcl_839x_set_rate(clk->idx, &rtab->rset[tab_idx]);
}

return -ENXIO;
}

The above function is used to actually configure the internal hardware for a 839x clock.
I have had a lot problems with this function as I have some non-zero numbers in it, in my case: rtcl_set_rate(). Basically, the




NEXT




<s> static int ag71xx_ring_rx_refill(struct ag71xx *ag)
{
struct ag71xx_ring *ring = &ag->rx_ring;
int ring_mask = BIT(ring->order) - 1;
unsigned int count;
int offset = ag->rx_buf_offset;

count = 0;
for (; ring->curr - ring->dirty > 0; ring->dirty++) {
struct ag71xx_desc *desc;
unsigned int i;

i = ring->dirty & ring_mask;
desc = ag71xx_ring_desc(ring, i);

if (!ring->buf[i].rx_buf &&
!ag71xx_fill_rx_buf(ag, &ring->buf[i], offset,
napi_alloc_frag))
break;

desc->ctrl = DESC_EMPTY;
count++;
}

/* flush descriptors */
wmb();

DBG("%s: %u rx descriptors refilled\n", ag->dev->name, count);

return count;
}

The above function is used to refill the RX rings with descriptors (with new
completion addresses) if they are in a ‘depleted’ state. This function is called
by ag71xx_ring_poll function (which we will come to later




NEXT




<s> mtk_bmt_remap_block(u32 block, u32 mapped_block, int copy_len)
{
int start, end;

if (!mapping_block_in_range(block, &start, &end))
return false;

return bmtd.ops->remap_block(block, mapped_block, copy_len);
}

The above function is used to perform physical memory remapping for the block devices that are used to construct the device tree. So, the user-space needs to update the physical memory addresses to the corresponding logical memory after boot up. But this is not done as the remapping function




NEXT




<s> static int bcm6318_pcie_read(struct pci_bus *bus, unsigned int devfn,
int where, int size, u32 *val)
{
struct bcm6318_pcie *priv = &bcm6318_pcie;
u32 data;
u32 reg = where & ~3;

if (!bcm6318_pcie_can_access(bus, devfn))
return PCIBIOS_DEVICE_NOT_FOUND;

if (bus->number == PCIE_BUS_DEVICE)
reg += PCIE_DEVICE_OFFSET;

data = __raw_readl(priv->base + reg);
*val = postprocess_read(data, where, size);

return PCIBIOS_SUCCESSFUL;
}

The above function is used to read a register from a PCIe device. Can you tell where the error is? Yes, we have two __raw_readl, and __raw should not start with an underscore.

To be correct, there is no need for




NEXT




<s> ar8216_vtu_op(struct ar8xxx_priv *priv, u32 op, u32 val)
{
if (ar8216_wait_bit(priv, AR8216_REG_VTU, AR8216_VTU_ACTIVE, 0))
return;
if ((op & AR8216_VTU_OP) == AR8216_VTU_OP_LOAD) {
val &= AR8216_VTUDATA_MEMBER;
val |= AR8216_VTUDATA_VALID;
ar8xxx_write(priv, AR8216_REG_VTU_DATA, val);
}
op |= AR8216_VTU_ACTIVE;
ar8xxx_write(priv, AR8216_REG_VTU, op);
}

The above function is used to control and write to the VTU register.

The VTU register has the following members:
- Active, VTU_ACTIVE
- Data, VTU_DATA
- Load, VTU_OP

Active is used to




NEXT




<s> swconfig_close_portlist(struct swconfig_callback *cb, void *arg)
{
if (cb->nest[0])
nla_nest_end(cb->msg, cb->nest[0]);
return 0;
}

The above function is used to close a port list that is constructed in the case of swconfig_add_portlist, and the implementation uses nest_end to pop the port list in the swconfig message to the previous nest level, that is, 1.






NEXT




<s> static void rtl838x_create_tx_header(struct p_hdr *h, unsigned int dest_port, int prio)
{
/* cpu_tag[0] is reserved on the RTL83XX SoCs */
h->cpu_tag[1] = 0x0400;  /* BIT 10: RTL8380_CPU_TAG */
h->cpu_tag[2] = 0x0200;  /* Set only AS_DPM, to enable DPM settings below */
h->cpu_tag[3] = 0x0000;
h->cpu_tag[4] = BIT(dest_port) >> 16;
h->cpu_tag[5] = BIT(dest_port) & 0xffff;

/* Set internal priority (PRI) and enable (AS_PRI) */
if (prio >= 0)
h->cpu_tag[2] |= ((prio & 0x7) | BIT(3)) << 12;
}

The above function is used to create the RTL838x SoCs TX header, from where both the destination channel and the priority info is derived for each packet transmission. This packet header field should actually fall into a category of its own, called a "device-




NEXT




<s> ret_t rtl8367c_setAsicPortDos(rtk_uint32 type, rtk_uint32 drop)
{
if(type >= DOS_END)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBit(RTL8367C_REG_DOS_CFG, RTL8367C_DROP_DAEQSA_OFFSET + type, drop);
}

The above function is used to enable/disable 224 or 232 or 239 broadcast DOS on chip.
DOS_1_EN: 224 DOS
DOS_2_EN: 232 D




NEXT




<s> static int oxnas_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
int size, u32 *val)
{
struct oxnas_pcie *pcie = sys_to_pcie(bus->sysdata);
unsigned offset;
u32 value;
u32 left_bytes, right_bytes;

/* Only a single device per bus for PCIe point-to-point links */
if (PCI_SLOT(devfn) > 0) {
*val = 0xffffffff;
return PCIBIOS_DEVICE_NOT_FOUND;
}

if (!pcie->haslink) {
*val = 0xffffffff;
return PCIBIOS_DEVICE_NOT_FOUND;
}

offset = oxnas_pcie_cfg_to_offset(bus->sysdata, bus->number, devfn,
where);
value = readl_relaxed(pcie->cfgbase + offset);
left_bytes = where & 3;
right_bytes = 4 - left_bytes - size;
value <<= right_bytes * 8;
value >>= (left_bytes + right_bytes) * 8;
*val = value;

return PCIBIOS_SUCCESSFUL;
}

The above function is used to interpret physical configuration space in the
physical device view of a PCI bus. This view is used in the case when the
device is not bridged.

The bus number passed to the function is 1 iff the device is




NEXT




<s> extern int hostapd_main(int argc, char **argv);
extern int wpa_supplicant_main(int argc, char **argv);

int main(int argc, char **argv)
{
bool restart = false;
const char *prog = argv[0];

restart:
if (strstr(argv[0], "hostapd"))
return hostapd_main(argc, argv);
else if (strstr(argv[0], "wpa_supplicant"))
return wpa_supplicant_main(argc, argv);

if (!restart && argc > 1) {
argv++;
argc--;
restart = true;
goto restart;
}

fprintf(stderr, "Invalid command.\nUsage: %s wpa_supplicant|hostapd [<arguments>]\n", prog);
return 255;
}

The above function is used to control (start, stop, test, restart and debug) hostapd and wpa-supplicant application with minimum of code written by the development team. It provides generic support to launch a driver/application daemon process. The main intention




NEXT




<s> ret_t rtl8367c_setAsicIGMPFastLeaveEn(rtk_uint32 enabled)
{
ret_t  retVal;

/* Fast Leave */
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_FAST_LEAVE_EN_MASK, (enabled >= 1) ? 1 : 0);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable or disable the fast leave mechanism. The
argument given is TRUE if the interface need to support the fast leave mechanism.

This function has no side effect and will not affect the other mechanisms.</s>




NEXT




<s> int deu_dma_init (void);
u32 endian_swap(u32 input);
u32* memory_alignment(const u8 *arg, u32 *buff_alloc, int in_out, int nbytes);
void dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);
void chip_version(void);
void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to check the endian format
in the code. To be used as a dummy only.

/*! \fn deu_dma_init (void)
* \brief Function is used to initialize the DMA to operate
* the DEU




NEXT




<s> static ssize_t mirror_ops(struct file *file,
const char __user *buffer, size_t count,
loff_t *data)
{
char buf[64];
unsigned int port;
unsigned int tx_map,rx_map;

memset(buf, 0, 64);

if (copy_from_user(buf, buffer, count))
return -EFAULT;

if(sscanf(buf, "%d %x %x", &port,&rx_map,&tx_map) == -1)
return -EFAULT;
else
rtk_hal_set_port_mirror(port,rx_map,tx_map);

return count;
}

The above function is used to define the write operation for the /proc/rtk_m_16008900.sys file. The function defines the port number, read map and transmit map of the corresponding port.

#include</s>




NEXT




<s> static void rtl8380_int_phy_on_off(struct phy_device *phydev, bool on)
{
phy_modify(phydev, 0, BMCR_PDOWN, on ? 0 : BMCR_PDOWN);
}

The above function is used to power down / power up the PHY during phy detection.
The phy_dwell time is set to dwll(111) (11.112 ms) and if the 128 register is not




NEXT




<s> uc_bpf_module_set_opts(struct bpf_object *obj, uc_value_t *opts)
{
uc_value_t *val;

if (!opts)
return 0;

if (ucv_type(opts) != UC_OBJECT)
err_return_int(EINVAL, "options argument");

if ((val = ucv_object_get(opts, "rodata", NULL)) != NULL) {
struct bpf_map *map = NULL;

if (ucv_type(val) != UC_STRING)
err_return_int(EINVAL, "rodata type");

while ((map = bpf_object__next_map(obj, map)) != NULL) {
if (!strstr(bpf_map__name(map), ".rodata"))
continue;

break;
}

if (!map)
err_return_int(errno, "rodata map");

if (bpf_map__set_initial_value(map, ucv_string_get(val),
ucv_string_length(val)))
err_return_int(errno, "rodata");
}

if ((val = ucv_object_get(opts, "program-type", NULL)) != NULL) {
if (ucv_type(val) != UC_OBJECT)
err_return_int(EINVAL, "prog_types argument");

ucv_object_foreach(val, name, type) {
struct bpf_program *prog;

if (ucv_type(type) != UC_INTEGER)
err_return_int(EINVAL, "program %s type", name);

prog = bpf_object__find_program_by_name(obj, name);
if (!prog)
err_return_int(-1, "program %s not found", name);

bpf_program__set_type(prog, ucv_int64_get(type));
}
}

return 0;
}

The above function is used to set the bpf program type to be either kernel or userspace and also how to parse the different object options that are available like rodata. When you set the bpf type to kernel it is considered to be in a privileged mode and you




NEXT




<s> print_attrs(const struct switch_attr *attr)
{
int i = 0;
while (attr) {
const char *type;
switch(attr->type) {
case SWITCH_TYPE_INT:
type = "int";
break;
case SWITCH_TYPE_STRING:
type = "string";
break;
case SWITCH_TYPE_PORTS:
type = "ports";
break;
case SWITCH_TYPE_NOVAL:
type = "none";
break;
default:
type = "unknown";
break;
}
printf("\tAttribute %d (%s): %s (%s)\n", ++i, type, attr->name, attr->description);
attr = attr->next;
}
}

The above function is used to print all the switch_attrs, if any, defined on a switch. At present, the switch must be defined as an object variable of type switch_db. Let’s take a look at the switch definition. When the application starts if the




NEXT




<s> static void do_print_item(WINDOW * win, const char *item, int line_y,
int selected, int hotkey)
{
int j;
char *menu_item = malloc(menu_width + 1);

strncpy(menu_item, item, menu_width - item_x);
menu_item[menu_width - item_x] = '\0';
j = first_alpha(menu_item, "YyNnMmHh");

/* Clear 'residue' of last item */
wattrset(win, dlg.menubox.atr);
wmove(win, line_y, 0);
#if OLD_NCURSES
{
int i;
for (i = 0; i < menu_width; i++)
waddch(win, ' ');
}
#else
wclrtoeol(win);
#endif
wattrset(win, selected ? dlg.item_selected.atr : dlg.item.atr);
mvwaddstr(win, line_y, item_x, menu_item);
if (hotkey) {
wattrset(win, selected ? dlg.tag_key_selected.atr
: dlg.tag_key.atr);
mvwaddch(win, line_y, item_x + j, menu_item[j]);
}
if (selected) {
wmove(win, line_y, item_x + 1);
}
free(menu_item);
wrefresh(win);
}

The above function is used to print an entry in the menu pane. It calls two functions: first_alpha and strncpy. The first one returns the first alphabetically occuring character of a string, the second one copies part of a string to another.





NEXT




<s> void log_rules(rule_t *rules)
{
rule_t *rule = rules;
while (rule)
{
syslog(LOG_INFO, " %s r: %d..%d, o: %d, f: %d\n",
rule->led->sysfspath,
rule->minq, rule->maxq,
rule->boffset, rule->bfactor);
rule = rule->next;
}
}

The above function is used to log rules from the system configuration
file. It does work, but not as expected. The ' ' in the statement
syslog(LOG_INFO, " %s r: %d..%d, o: %d, f:




NEXT




<s> ret_t rtl8367c_getAsicLedForceBlinkRate(rtk_uint32* pBlinkRate)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_LED_MODE, RTL8367C_FORCE_RATE_MASK, pBlinkRate);
}

The above function is used to get the LED blinking rate by reading RTL8367C_REG_LED_MODE register. But the problem is that the driver cannot use that function in U-Boot. For the same reason that I mentioned in the previous section




NEXT




<s> static void tl_wdr4900_v1_pci_wmac_fixup(struct pci_dev *dev)
{
if (!machine_is(tl_wdr4900_v1))
return;

if (dev->bus->number == 1 &&
PCI_SLOT(dev->devfn) == 0) {
dev->dev.platform_data = &tl_wdr4900_v1_wmac0_data;
return;
}

if (dev->bus->number == 3 &&
PCI_SLOT(dev->devfn) == 0 &&
dev->device == 0xabcd) {
dev->dev.platform_data = &tl_wdr4900_v1_wmac1_data;

/*
* The PCI header of the AR9381 chip is not programmed
* correctly by the bootloader and the device uses wrong
* data due to that. Replace the broken values with the
* correct ones.
*/
dev->device = 0x30;
dev->class = 0x028000;

pr_info("pci %s: AR9381 fixup applied\n", pci_name(dev));
}
}

The above function is used to assign hardware platform specific data to a
device that is used to enable the functionality of a device that doesn’t
support it by itself. In the example above, there are two wired MACs
(WMAC0 and WMAC1




NEXT




<s> ret_t rtl8367c_getAsicEavTrap(rtk_uint32 port, rtk_uint32 *pEnabled)
{
if(port > RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_REG_PTP_PORT0_CFG1 + (port * 0x20), RTL8367C_PTP_PORT0_CFG1_OFFSET, pEnabled);
}

The above function is used to set the EAV TRAP for specific port.

The bitmask is defined as the following:

#define RTL8367C_PTP_PORT0_CFG1_OFFSET 31
#define R




NEXT




<s> static int rtl9310_execute_xfer(struct rtl9300_i2c *i2c, char read_write,
int size, union i2c_smbus_data * data, int len)
{
u32 v;

if (read_write == I2C_SMBUS_READ)
REG_MASK(i2c, BIT(RTL9310_I2C_CTRL_RWOP), 0, RTL9310_I2C_CTRL);
else
REG_MASK(i2c, 0, BIT(RTL9310_I2C_CTRL_RWOP), RTL9310_I2C_CTRL);

REG_MASK(i2c, 0, BIT(RTL9310_I2C_CTRL_I2C_TRIG), RTL9310_I2C_CTRL);
do {
v = readl(REG(i2c, RTL9310_I2C_CTRL));
} while (v & BIT(RTL9310_I2C_CTRL_I2C_TRIG));

if (v & BIT(RTL9310_I2C_CTRL_I2C_FAIL))
return -EIO;

if (read_write == I2C_SMBUS_READ) {
if (size == I2C_SMBUS_BYTE || size == I2C_SMBUS_BYTE_DATA){
data->byte = readl(REG(i2c, RTL9310_I2C_DATA));
} else if (size == I2C_SMBUS_WORD_DATA) {
data->word = readl(REG(i2c, RTL9310_I2C_DATA));
} else if (len > 0) {
rtl9310_i2c_read(i2c, &data->block[0], len);
}
}

return 0;
}

The above function is used to do an IIC transfer. First, it checks if the
IIC transfer should be a read or write transfer, then it sets the control
register with the correct data, then it triggers the IIC transfer, and then
waits




NEXT




<s> static int adm6996_probe(struct phy_device *pdev)
{
return 0;
}

The above function is used to initialize the hardware of the ADM6996 device. It gets called when the
device is probed. It returns 0 if initialization is successful.

static void adm6996_suspend(struct phy_device




NEXT




<s> static int conf_sym(struct menu *menu)
{
struct symbol *sym = menu->sym;
tristate oldval, newval;

while (1) {
printf("%*s%s ", indent - 1, "", menu->prompt->text);
if (sym->name)
printf("(%s) ", sym->name);
putchar('[');
oldval = sym_get_tristate_value(sym);
switch (oldval) {
case no:
putchar('N');
break;
case mod:
putchar('M');
break;
case yes:
putchar('Y');
break;
}
if (oldval != no && sym_tristate_within_range(sym, no))
printf("/n");
if (oldval != mod && sym_tristate_within_range(sym, mod))
printf("/m");
if (oldval != yes && sym_tristate_within_range(sym, yes))
printf("/y");
printf("/?] ");
if (!conf_askvalue(sym, sym_get_string_value(sym)))
return 0;
strip(line);

switch (line[0]) {
case 'n':
case 'N':
newval = no;
if (!line[1] || !strcmp(&line[1], "o"))
break;
continue;
case 'm':
case 'M':
newval = mod;
if (!line[1])
break;
continue;
case 'y':
case 'Y':
newval = yes;
if (!line[1] || !strcmp(&line[1], "es"))
break;
continue;
case 0:
newval = oldval;
break;
case '?':
goto help;
default:
continue;
}
if (sym_set_tristate_value(sym, newval))
return 0;
help:
print_help(menu);
}
}

The above function is used to edit the values of symbols in the menu.
To exit, I need to type "n" or "q".  "m" and "y", if followed by valid
arguments, make changes to the tristate value, but for




NEXT




<s> int dc_ep_gpio_dcc_set(struct dc_ep_priv *priv, u32 gpio, u32 val)
{
struct dc_aca *aca = to_aca(priv);

if (gpio > aca->max_gpio)
return -EINVAL;

if (val >= GPIO_DRV_CUR_MAX)
return -EINVAL;

mutex_lock(&aca->pin_lock);
wr32_mask((0x3 << (gpio * 2)), (val << (gpio * 2)), PADC_DCC);
mutex_unlock(&aca->pin_lock);
return 0;
}

The above function is used to set the DCC voltage for any gpio to the desired level on the ACA. The gpio is first checked with the max_gpio to validate it within the range. Then the requested value if passed is compared with the largest valid value and




NEXT




<s> ret_t rtl8367c_getAsicAclGpioPolarity(rtk_uint32* pPolarity)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_ACL_GPIO_POLARITY, RTL8367C_ACL_GPIO_POLARITY_OFFSET, pPolarity);
}

The above function is used to get the ACl GPIOs polarity, but it does not seem to work with all switch hardware versions. It works on the E08/E16, but not on the B03/D03.

Does anyone




NEXT




<s> static void rtl838x_storm_enable(struct rtl838x_switch_priv *priv, int port, bool enable)
{
/* Enable Storm control for that port for UC, MC, and BC */
if (enable)
sw_w32(0x7, RTL838X_STORM_CTRL_LB_CTRL(port));
else
sw_w32(0x0, RTL838X_STORM_CTRL_LB_CTRL(port));
}

The above function is used to enable Storm Control for that port.

static unsigned int rtl838x_storm_get(struct rtl838x_switch_priv *priv, int port,
enum storm_item item)
{





NEXT




<s> static int __rtl8366_smi_init(struct rtl8366_smi *smi, const char *name)
{
int err;

if (!smi->ext_mbus) {
err = gpio_request(smi->gpio_sda, name);
if (err) {
printk(KERN_ERR "rtl8366_smi: gpio_request failed for %u, err=%d\n",
smi->gpio_sda, err);
goto err_out;
}

err = gpio_request(smi->gpio_sck, name);
if (err) {
printk(KERN_ERR "rtl8366_smi: gpio_request failed for %u, err=%d\n",
smi->gpio_sck, err);
goto err_free_sda;
}
}

spin_lock_init(&smi->lock);

/* start the switch */
if (smi->hw_reset) {
smi->hw_reset(smi, false);
msleep(RTL8366_SMI_HW_START_DELAY);
}

return 0;

err_free_sda:
gpio_free(smi->gpio_sda);
err_out:
return err;
}

The above function is used to initialize the hardware peripherals. It returns 0 on success
and negative value on failure.

The following is the flow:

First in the function smi->gpio_sda is requested.
This line of code will enable




NEXT




<s> rtk_api_ret_t rtk_l2_limitLearningCntAction_set(rtk_port_t port, rtk_l2_limitLearnCntAction_t action)
{
rtk_api_ret_t retVal;
rtk_uint32 data;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (port != RTK_WHOLE_SYSTEM)
return RT_ERR_PORT_ID;

if ( LIMIT_LEARN_CNT_ACTION_DROP == action )
data = 1;
else if ( LIMIT_LEARN_CNT_ACTION_FORWARD == action )
data = 0;
else if ( LIMIT_LEARN_CNT_ACTION_TO_CPU == action )
data = 2;
else
return RT_ERR_NOT_ALLOWED;

if ((retVal = rtl8367c_setAsicLutLearnOverAct(data)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the L2 Limit Learning Counter Action.

#if 0
	rtl8367c_setAsicLutLearnOverAct	  : API : Set LUT learn over action
	




NEXT




<s> static void rtl838x_hw_ring_setup(struct rtl838x_eth_priv *priv)
{
struct ring_b *ring = priv->membase;

for (int i = 0; i < priv->rxrings; i++)
sw_w32(KSEG1ADDR(&ring->rx_r[i]), priv->r->dma_rx_base + i * 4);

for (int i = 0; i < TXRINGS; i++)
sw_w32(KSEG1ADDR(&ring->tx_r[i]), priv->r->dma_tx_base + i * 4);
}

The above function is used to update the RX and TX rings. The code uses the same address from the previous frame to be used and will skip it if it detects a change in address, which is a good thing.

In that case, the MAC would re




NEXT




<s> static int wlc_vif_enabled(wlc_param param, void *data, void *value)
{
int *val = (int *) value;
int buf[3];
int ret = 0;

sprintf((char *) buf, "bss");
buf[1] = vif;
if (param & SET) {
buf[2] = (*val ? 1 : 0);
ret = wl_ioctl(interface, WLC_SET_VAR, buf, sizeof(buf));
} else if (param & GET) {
ret = wl_ioctl(interface, WLC_GET_VAR, buf, sizeof(buf));
*val = buf[0];
}

return ret;
}

The above function is used to enable / disable the wireless LAN.</s>




NEXT




<s> static int qca807x_cable_test_get_status(struct phy_device *phydev,
bool *finished)
{
int val;

*finished = false;

val = phy_read(phydev, QCA807X_CDT);
if (!((val & QCA807X_CDT_ENABLE) && (val & QCA807X_CDT_STATUS))) {
*finished = true;

return qca807x_cable_test_report(phydev);
}

return 0;
}

The above function is used to determine if a cable test is valid or not. If it is, we can proceed to report the test, if it is not, we need to go back to idle and reset the cable test and wait for it to complete correctly. From here,




NEXT




<s> ret_t rtl8367c_setAsicPowerSaving(rtk_uint32 phy, rtk_uint32 enable)
{
rtk_api_ret_t retVal;
rtk_uint32 phyData;
rtk_uint32 regData;
rtk_uint32 phy_status;
rtk_uint32 checkCounter;

if (enable > 1)
return RT_ERR_INPUT;

/* 0xa420[2:0] */
if((retVal = rtl8367c_getAsicPHYOCPReg(phy, 0xA420, &regData)) != RT_ERR_OK)
return retVal;

phy_status = (regData & 0x0007);

if(phy_status == 3)
{
/* 0xb820[4] = 1 */
if((retVal = rtl8367c_getAsicPHYOCPReg(phy, 0xB820, &regData)) != RT_ERR_OK)
return retVal;

regData |= (0x0001 << 4);

if((retVal = rtl8367c_setAsicPHYOCPReg(phy, 0xB820, regData)) != RT_ERR_OK)
return retVal;

/* wait 0xb800[6] = 1 */
checkCounter = 100;
while(checkCounter)
{
retVal = rtl8367c_getAsicPHYOCPReg(phy, 0xB800, &regData);
if( (retVal != RT_ERR_OK) || ((regData & 0x0040) != 0x0040) )
{
checkCounter --;
if(0 == checkCounter)
{
return RT_ERR_BUSYWAIT_TIMEOUT;
}
}
else
checkCounter = 0;
}
}

if ((retVal = rtl8367c_getAsicPHYReg(phy,PHY_POWERSAVING_REG,&phyData))!=RT_ERR_OK)
return retVal;

phyData = phyData & ~(0x0001 << 2);
phyData = phyData | (enable << 2);

if ((retVal = rtl8367c_setAsicPHYReg(phy,PHY_POWERSAVING_REG,phyData))!=RT_ERR_OK)
return retVal;

if(phy_status == 3)
{
/* 0xb820[4] = 0  */
if((retVal = rtl8367c_getAsicPHYOCPReg(phy, 0xB820, &regData)) != RT_ERR_OK)
return retVal;

regData &= ~(0x0001 << 4);

if((retVal = rtl8367c_setAsicPHYOCPReg(phy, 0xB820, regData)) != RT_ERR_OK)
return retVal;

/* wait 0xb800[6] = 0 */
checkCounter = 100;
while(checkCounter)
{
retVal = rtl8367c_getAsicPHYOCPReg(phy, 0xB800, &regData);
if( (retVal != RT_ERR_OK) || ((regData & 0x0040) != 0x0000) )
{
checkCounter --;
if(0 == checkCounter)
{
return RT_ERR_BUSYWAIT_TIMEOUT;
}
}
else
checkCounter = 0;
}
}

return RT_ERR_OK;
}

The above function is used to enable or disable ASIC power saving function. The user should call this function when the external power save function is enabled. This function checks the current status of the power saving (0x00040 in 0xb800 register




NEXT




<s> void rtl83xx_set_ingress_priority(int port, int priority)
{
if (soc_info.family == RTL8380_FAMILY_ID)
sw_w32(priority << ((port % 10) *3), RTL838X_PRI_SEL_PORT_PRI(port));
else
sw_w32(priority << ((port % 10) *3), RTL839X_PRI_SEL_PORT_PRI(port));
}

The above function is used to set ingress priorities for each 10 ports on RTL83xx chip.  A 3-bit (mask 0x7) value is allocated for each port and if the bit(s) is(are) set,




NEXT




<s> static void rtl838x_mac_an_restart(struct phylink_config *config)
{
struct net_device *dev = container_of(config->dev, struct net_device, dev);
struct rtl838x_eth_priv *priv = netdev_priv(dev);

/* This works only on RTL838x chips */
if (priv->family_id != RTL8380_FAMILY_ID)
return;

pr_debug("In %s\n", __func__);
/* Restart by disabling and re-enabling link */
sw_w32(0x6192D, priv->r->mac_force_mode_ctrl + priv->cpu_port * 4);
mdelay(20);
sw_w32(0x6192F, priv->r->mac_force_mode_ctrl + priv->cpu_port * 4);
}

The above function is used to restart the AN link.
We should not only restore the previous settings but make sure to do a
full speed negotiation as well.
Hence the need for this patch.</s>




NEXT




<s> static void check_conf(struct menu *menu);

enum input_mode {
oldaskconfig,
syncconfig,
oldconfig,
allnoconfig,
allyesconfig,
allmodconfig,
alldefconfig,
randconfig,
defconfig,
savedefconfig,
listnewconfig,
helpnewconfig,
olddefconfig,
yes2modconfig,
mod2yesconfig,
fatalrecursive,
};

The above function is used to check if the user-requested configuration is legal or not.

We are now going to enter some more complicated code. First, let us look at the following function:

The above code is invoked when the user requests a configuration that




NEXT




<s> static int __init ws_ap3710i_probe(void)
{
if (of_machine_is_compatible("enterasys,ws-ap3710i"))
return 1;
return 0;
}

The above function is used to determine whether the device is a WS-AP3710i. If it is, then the code within this function will set ws_ap3710i-enable and a flag. If the code sets the kernel to




NEXT




<s> void expr_fprint(struct expr *e, FILE *out)
{
expr_print(e, expr_print_file_helper, out, E_NONE);
}

The above function is used to print an expression, which we did not yet implement. The reason is that we want to put the function expr_print() in separate source file, to make the link easier. Since the file is included, the implementation is only needed in this source




NEXT




<s> ar8xxx_sw_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
priv->vlan = !!val->value.i;
return 0;
}

The above function is used to set the vlan enable/disable flag on ar8xxx
device.  The function is provided with the switch device pointer, attribute
name, and a pointer to the switch_val structure.  The structure contains a
union of different types




NEXT




<s> ret_t rtl8367c_getAsicPortUnmatchedSaMoving(rtk_uint32 port, rtk_uint32 *pEnabled)
{
rtk_uint32 data;
ret_t retVal;

if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_L2_SA_MOVING_FORBID, port, &data)) != RT_ERR_OK)
return retVal;

*pEnabled = (data == 1) ? 0 : 1;
return RT_ERR_OK;
}

The above function is used to query the value of bit9,bit10,bit11 of RTL8367C_REG_L2_SA_MOVING_FORBID register, indicating whether the matching rule is valid.

When




NEXT




<s> static int mt7621_nfc_ooblayout_ecc(struct mtd_info *mtd, int section,
struct mtd_oob_region *oob_region)
{
struct nand_chip *nand = mtd_to_nand(mtd);

if (section)
return -ERANGE;

oob_region->offset = NFI_FDM_SIZE * nand->ecc.steps;
oob_region->length = mtd->oobsize - oob_region->offset;

return 0;
}

The above function is used to determine the OOB area of the OOB layout.</s>




NEXT




<s> static int rtl9300_i2c_remove(struct platform_device *pdev)
{
struct rtl9300_i2c *i2c = platform_get_drvdata(pdev);

i2c_del_adapter(&i2c->adap);

return 0;
}

The above function is used to remove the driver. We basically call i2c_del_adapter as rtl9300_i2c_remove is the i2c driver’s removal function.

Now we will see how the driver can be registered




NEXT




<s> static int cferam_bootflag_value(const char *name, size_t name_len)
{
int rc = -ENOENT;

if (name &&
(name_len >= CFE_MAGIC_LEN) &&
!memcmp(name, CFE_MAGIC_PFX, CFE_MAGIC_PFX_LEN)) {
rc = char_to_num(name[CFE_MAGIC_PFX_LEN + 0]) * 100;
rc += char_to_num(name[CFE_MAGIC_PFX_LEN + 1]) * 10;
rc += char_to_num(name[CFE_MAGIC_PFX_LEN + 2]) * 1;
}

return rc;
}

The above function is used to parse boot flags, it will try to parse the value for bootflag "cferam" and print the result like this:</s>




NEXT




<s> int rtl839x_read_phy(u32 port, u32 page, u32 reg, u32 *val)
{
u32 v;
int err = 0;

if (port > 63 || page > 4095 || reg > 31)
return -ENOTSUPP;

/* Take bug on RTL839x Rev <= C into account */
if (port >= RTL839X_CPU_PORT)
return -EIO;

mutex_lock(&smi_lock);

sw_w32_mask(0xffff0000, port << 16, RTL839X_PHYREG_DATA_CTRL);
v = reg << 5 | page << 10 | ((page == 0x1fff) ? 0x1f : 0) << 23;
sw_w32(v, RTL839X_PHYREG_ACCESS_CTRL);

sw_w32(0x1ff, RTL839X_PHYREG_CTRL);

v |= 1;
sw_w32(v, RTL839X_PHYREG_ACCESS_CTRL);

err = rtl839x_smi_wait_op(100000);
if (err)
goto errout;

*val = sw_r32(RTL839X_PHYREG_DATA_CTRL) & 0xffff;

errout:
mutex_unlock(&smi_lock);

return err;
}

The above function is used to read the PHY and it does the actual
read. It can be called directly from user space or, which is more
typical, it is called from a kernel function.

To access the PHY from user space is relatively easy




NEXT




<s> hostapd_rrm_beacon_req(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *ureq, const char *method,
struct blob_attr *msg)
{
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
struct blob_attr *tb[__BEACON_REQ_MAX];
struct blob_attr *cur;
struct wpabuf *req;
u8 bssid[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
u8 addr[ETH_ALEN];
int mode, rem, ret;
int buf_len = 13;

blobmsg_parse(beacon_req_policy, __BEACON_REQ_MAX, tb, blob_data(msg), blob_len(msg));

if (!tb[BEACON_REQ_ADDR] || !tb[BEACON_REQ_MODE] || !tb[BEACON_REQ_DURATION] ||
!tb[BEACON_REQ_OP_CLASS] || !tb[BEACON_REQ_CHANNEL])
return UBUS_STATUS_INVALID_ARGUMENT;

if (tb[BEACON_REQ_SSID])
buf_len += blobmsg_data_len(tb[BEACON_REQ_SSID]) + 2 - 1;

mode = blobmsg_get_u32(tb[BEACON_REQ_MODE]);
if (hwaddr_aton(blobmsg_data(tb[BEACON_REQ_ADDR]), addr))
return UBUS_STATUS_INVALID_ARGUMENT;

if (tb[BEACON_REQ_BSSID] &&
hwaddr_aton(blobmsg_data(tb[BEACON_REQ_BSSID]), bssid))
return UBUS_STATUS_INVALID_ARGUMENT;

req = wpabuf_alloc(buf_len);
if (!req)
return UBUS_STATUS_UNKNOWN_ERROR;

/* 1: regulatory class */
wpabuf_put_u8(req, blobmsg_get_u32(tb[BEACON_REQ_OP_CLASS]));

/* 2: channel number */
wpabuf_put_u8(req, blobmsg_get_u32(tb[BEACON_REQ_CHANNEL]));

/* 3-4: randomization interval */
wpabuf_put_le16(req, 0);

/* 5-6: duration */
wpabuf_put_le16(req, blobmsg_get_u32(tb[BEACON_REQ_DURATION]));

/* 7: mode */
wpabuf_put_u8(req, blobmsg_get_u32(tb[BEACON_REQ_MODE]));

/* 8-13: BSSID */
wpabuf_put_data(req, bssid, ETH_ALEN);

if ((cur = tb[BEACON_REQ_SSID]) != NULL) {
wpabuf_put_u8(req, WLAN_EID_SSID);
wpabuf_put_u8(req, blobmsg_data_len(cur) - 1);
wpabuf_put_data(req, blobmsg_data(cur), blobmsg_data_len(cur) - 1);
}

ret = hostapd_send_beacon_req(hapd, addr, 0, req);
if (ret < 0)
return -ret;

return 0;
}

The above function is used to provide the beacon req API for DAPSI.</s>




NEXT




<s> swconfig_trig_deactivate(struct led_classdev *led_cdev)
{
struct swconfig_trig_data *trig_data;

swconfig_trig_update_port_mask(led_cdev->trigger);

trig_data = (void *) led_cdev->trigger_data;
if (trig_data) {
device_remove_file(led_cdev->dev, &dev_attr_port_mask);
device_remove_file(led_cdev->dev, &dev_attr_speed_mask);
device_remove_file(led_cdev->dev, &dev_attr_mode);
kfree(trig_data);
}
}

The above function is used to deactivate the trigger of a device by removing all of the trigger-related sysfs nodes from the corresponding device node. The code uses device_remove_file() to remove the trigger-related sysfs nodes, which include dev_attr_port




NEXT




<s> static int curses_item_index(void)
{
return  item_index(current_item(curses_menu));
}

The above function is used to identify the currently selected item.
However, when I try to run 80x50 in curses, I still found there was a problem (I tried this on Mac OS X and Win32 port): when switch between two 




NEXT




<s> static void __exit mt7621_qtn_rgmii_exit(void)
{
void __iomem *base = ioremap(RGMII_REG_BASE, RGMII_REG_SIZE);

if (!base)
return;
if (oldval != RGMII_REG_VALUE) {
iowrite32(oldval, base);
pr_info(MODULE_NAME ": reset register 0x%08x back to 0x%08x\n", RGMII_REG_BASE, oldval);
}
iounmap(base);
}

The above function is used to restore the RGMII configuration that mt7621_qtn_rgmii_init() has written. mt7621_qtn_rgmii_init() sets up the device to be configured with the information




NEXT




<s> DECLARE_PCI_FIXUP_ENABLE(PCI_ANY_ID, PCI_ANY_ID, bcm6348_pci_fixup);

static struct resource bcm6348_cb_io_resource = {
.name = "bcm6348 CB IO space",
.flags = IORESOURCE_IO,
};

The above function is used to fixup the io mem for the CB controller. the io resources are mapped dynamically in the IO range from 0x03e0_0000 to 0x03e0_ffff range.
the below function




NEXT




<s> fis_validate(struct fis_part *old, int n_old, struct fis_part *new, int n_new)
{
struct fis_image_desc *desc;
void *end;
int found = 0;
int i;

desc = fis_open();
if (!desc)
return -1;

for (i = 0; i < n_new - 1; i++) {
if (!new[i].size) {
fprintf(stderr, "FIS error: only the last partition can detect the size automatically\n");
i = -1;
goto done;
}
}

end = desc;
end = (char *) end + fis_erasesize;
while ((void *) desc < end) {
if (!desc->hdr.name[0] || (desc->hdr.name[0] == 0xff))
break;

for (i = 0; i < n_old; i++) {
if (!strncmp((char *) desc->hdr.name, (char *) old[i].name, sizeof(desc->hdr.name))) {
found++;
goto next;
}
}
next:
desc++;
continue;
}

if (found == n_old)
i = 1;
else
i = -1;

done:
fis_close();
return i;
}

The above function is used to test the validation feature of the fisloader program. Here is an example use:

```
> ./fisloader -v
Partitions are already added to the images, run ./fisloader [image_1].img...




NEXT




<s> static int rtl8366rb_sw_get_mirror_source_port(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366RB_PMCR, &data);
val->value.i = data & RTL8366RB_PMCR_SOURCE_PORT_MASK;

return 0;
}

The above function is used to retrieve the source port used when mirroring packets via the PMCSR register, it contains four mirror ports.</s>




NEXT




<s> adm6996_sw_get_port_mib(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);
int port;
char *buf = priv->buf;
int i, len = 0;
u32 reg = 0;

port = val->port_vlan;
if (port >= ADM_NUM_PORTS)
return -EINVAL;

mutex_lock(&priv->mib_lock);

len += snprintf(buf + len, sizeof(priv->buf) - len,
"Port %d MIB counters\n",
port);

for (i = 0; i < ARRAY_SIZE(adm6996_mibs); i++) {
reg = r16(priv, adm6996_mibs[i].offset + ADM_OFFSET_PORT(port));
reg += r16(priv, adm6996_mibs[i].offset + ADM_OFFSET_PORT(port) + 1) << 16;
len += snprintf(buf + len, sizeof(priv->buf) - len,
"%-12s: %u\n",
adm6996_mibs[i].name,
reg);
}

mutex_unlock(&priv->mib_lock);

val->value.s = buf;
val->len = len;

return 0;
}

The above function is used to read the MIB status using Ethernet
switch software programming interface. This MIB information is printed
in the attached file (switch-out.log).

As we can see from the attached file and the above programming it
se




NEXT




<s> IFX_MEI_EnableCLK (DSL_DEV_Device_t * pDev)
{
u32 arc_debug_data = 0;
IFX_MEI_ControlModeSet (pDev, MEI_MASTER_MODE);
//enable ac_clk signal
_IFX_MEI_DBGLongWordRead (pDev, ME_DBG_DECODE_DMP1_MASK,
CRI_CCR0, &arc_debug_data);
arc_debug_data |= ACL_CLK_MODE_ENABLE;
_IFX_MEI_DBGLongWordWrite (pDev, ME_DBG_DECODE_DMP1_MASK,
CRI_CCR0, arc_debug_data);
IFX_MEI_ControlModeSet (pDev, JTAG_MASTER_MODE);
return DSL_DEV_MEI_ERR_SUCCESS;
}

The above function is used to set ACL_CLK, but we cannot see the code of JTAG_MASTER_MODE.</s>




NEXT




<s> rtk_api_ret_t rtk_port_adminEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtk_uint32      data;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtk_port_phyReg_get(port, PHY_CONTROL_REG, &data)) != RT_ERR_OK)
return retVal;

if ( (data & 0x0800) == 0x0800)
{
*pEnable = DISABLED;
}
else
{
*pEnable = ENABLED;
}

return RT_ERR_OK;
}

The above function is used to get port administrative status.

rtk_api_ret_t rtk_port_adminEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret




NEXT




<s> ret_t rtl8367c_setAsicCputagTrapPort(rtk_uint32 port)
{
ret_t retVal;

if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TRAP_PORT_MASK, port & 7);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TRAP_PORT_EXT_MASK, (port>>3) & 1);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to tell NPU which CPU port is associated with each ethernet port. NPU will redirect traffic on that port to CPU. The ethernet port is the output of CPU.</s>




NEXT




<s> swlib_call(int cmd, int (*call)(struct nl_msg *, void *),
int (*data)(struct nl_msg *, void *), void *arg)
{
struct nl_msg *msg;
struct nl_cb *cb = NULL;
int finished;
int flags = 0;
int err = 0;

msg = nlmsg_alloc();
if (!msg) {
fprintf(stderr, "Out of memory!\n");
exit(1);
}

if (!data)
flags |= NLM_F_DUMP;

genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, genl_family_get_id(family), 0, flags, cmd, 0);
if (data) {
err = data(msg, arg);
if (err < 0)
goto nla_put_failure;
}

cb = nl_cb_alloc(NL_CB_CUSTOM);
if (!cb) {
fprintf(stderr, "nl_cb_alloc failed.\n");
exit(1);
}

err = nl_send_auto_complete(handle, msg);
if (err < 0) {
fprintf(stderr, "nl_send_auto_complete failed: %d\n", err);
goto out;
}

finished = 0;

if (call)
nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, call, arg);

if (data)
nl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, wait_handler, &finished);
else
nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, wait_handler, &finished);

err = nl_recvmsgs(handle, cb);
if (err < 0) {
goto out;
}

if (!finished)
err = nl_wait_for_ack(handle);

out:
if (cb)
nl_cb_put(cb);
nla_put_failure:
nlmsg_free(msg);
return err;
}

The above function is used to communicate with the Linux netlink socket.</s>




NEXT




<s> static inline int rtl839x_l2_port_new_sa_fwd(int p)
{
return RTL839X_L2_PORT_NEW_SA_FWD(p);
}

The above function is used to identify if the port is capable of
forwarding L2 unicast frames to the new association (SA).

Please look at the port_mac.c code for further information.

Refer to

	./firm




NEXT




<s> ar8xxx_mib_stop(struct ar8xxx_priv *priv);

/* inspired by phy_poll_reset in drivers/net/phy/phy_device.c */
static int
ar8xxx_phy_poll_reset(struct mii_bus *bus)
{
unsigned int sleep_msecs = 20;
int ret, elapsed, i;

for (elapsed = sleep_msecs; elapsed <= 600;
elapsed += sleep_msecs) {
msleep(sleep_msecs);
for (i = 0; i < AR8XXX_NUM_PHYS; i++) {
ret = mdiobus_read(bus, i, MII_BMCR);
if (ret < 0)
return ret;
if (ret & BMCR_RESET)
break;
if (i == AR8XXX_NUM_PHYS - 1) {
usleep_range(1000, 2000);
return 0;
}
}
}
return -ETIMEDOUT;
}

The above function is used to retry for resetting Phy. This function polls for
Phy reset status every 20ms up to 600ms duration. If it fails the process
terminates and returns a timeout error.

The AR8




NEXT




<s> static int rt2880_fwd_config(struct fe_priv *priv)
{
int ret;

ret = fe_set_clock_cycle(priv);
if (ret)
return ret;

fe_fwd_config(priv);
fe_w32(FE_PSE_FQFC_CFG_INIT, FE_PSE_FQ_CFG);
fe_csum_config(priv);

return ret;
}

The above function is used to configure the FWD module of an RT28xx chip.  This is one of the most important parts of any DVB front-end, in that it does the actual demodulation and is responsible for converting incoming RF into usable




NEXT




<s> int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
int max;
int add=0,neg=0;
const BIGNUM *tmp;

bn_check_top(a);
bn_check_top(b);

/*  a -  b      a-b
*  a - -b      a+b
* -a -  b      -(a+b)
* -a - -b      b-a
*/
if (a->neg)
{
if (b->neg)
{ tmp=a; a=b; b=tmp; }
else
{ add=1; neg=1; }
}
else
{
if (b->neg) { add=1; neg=0; }
}

if (add)
{
if (!BN_uadd(r,a,b)) return(0);
r->neg=neg;
return(1);
}

/* We are actually doing a - b :-) */

max=(a->top > b->top)?a->top:b->top;
if (bn_wexpand(r,max) == NULL) return(0);
if (BN_ucmp(a,b) < 0)
{
if (!BN_usub(r,b,a)) return(0);
r->neg=1;
}
else
{
if (!BN_usub(r,a,b)) return(0);
r->neg=0;
}
return(1);
}

The above function is used to make a subtraction between two bignum numbers, and a boolean check is made to see if the input is negative or not, and the function has to expand the new result by either calling to another function `BN_uadd` or




NEXT




<s> rtk_api_ret_t rtk_trap_rmaKeepFormat_set(rtk_trap_type_t type, rtk_enable_t enable)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;
rtk_uint32 tmp;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= TRAP_END)
return RT_ERR_INPUT;

if (enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if (type >= 0 && type <= TRAP_UNDEF_GARP_2F)
{
if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.keep_format = enable;

if ((retVal = rtl8367c_setAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (type == TRAP_CDP)
{
if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.keep_format = enable;

if ((retVal = rtl8367c_setAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (type  == TRAP_CSSTP)
{
if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.keep_format = enable;

if ((retVal = rtl8367c_setAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (type  == TRAP_LLDP)
{
if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.keep_format = enable;

if ((retVal = rtl8367c_setAsicRmaLldp(tmp, &rmacfg)) != RT_ERR_OK)
return retVal;
}
else
return RT_ERR_INPUT;

return RT_ERR_OK;
}

The above function is used to set keep format for RMA trap type.

rtk_api_ret_t rtk_trap_rmaKeepFormat_get(rtk_trap_type_t type, rtk_enable_t*




NEXT




<s> void ag71xx_debugfs_update_int_stats(struct ag71xx *ag, u32 status)
{
if (status)
ag->debug.int_stats.total++;
if (status & AG71XX_INT_TX_PS)
ag->debug.int_stats.tx_ps++;
if (status & AG71XX_INT_TX_UR)
ag->debug.int_stats.tx_ur++;
if (status & AG71XX_INT_TX_BE)
ag->debug.int_stats.tx_be++;
if (status & AG71XX_INT_RX_PR)
ag->debug.int_stats.rx_pr++;
if (status & AG71XX_INT_RX_OF)
ag->debug.int_stats.rx_of++;
if (status & AG71XX_INT_RX_BE)
ag->debug.int_stats.rx_be++;
}

The above function is used to track the number of packets received,
transmitted and dropped in various conditions.

struct ag71xx_netdevdata_struct *netdevdata;

This structure is declared and defined as follows in the main ag71xx.




NEXT




<s> rtk_api_ret_t rtk_port_macForceLinkExt_set(rtk_port_t port, rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability)
{
rtk_api_ret_t retVal;
rtl8367c_port_ability_t ability;
rtk_uint32 ext_id;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_EXT(port);

if(NULL == pPortability)
return RT_ERR_NULL_POINTER;

if (mode >=MODE_EXT_END)
return RT_ERR_INPUT;

if(mode == MODE_EXT_HSGMII)
{
if (pPortability->forcemode > 1 || pPortability->speed != PORT_SPEED_2500M || pPortability->duplex != PORT_FULL_DUPLEX ||
pPortability->link >= PORT_LINKSTATUS_END || pPortability->nway > 1 || pPortability->txpause > 1 || pPortability->rxpause > 1)
return RT_ERR_INPUT;

if(rtk_switch_isHsgPort(port) != RT_ERR_OK)
return RT_ERR_PORT_ID;
}
else
{
if (pPortability->forcemode > 1 || pPortability->speed > PORT_SPEED_1000M || pPortability->duplex >= PORT_DUPLEX_END ||
pPortability->link >= PORT_LINKSTATUS_END || pPortability->nway > 1 || pPortability->txpause > 1 || pPortability->rxpause > 1)
return RT_ERR_INPUT;
}

ext_id = port - 15;

if(mode == MODE_EXT_DISABLE)
{
memset(&ability, 0x00, sizeof(rtl8367c_port_ability_t));
if ((retVal = rtl8367c_setAsicPortForceLinkExt(ext_id, &ability)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicPortExtMode(ext_id, mode)) != RT_ERR_OK)
return retVal;
}
else
{
if ((retVal = rtl8367c_setAsicPortExtMode(ext_id, mode)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicPortForceLinkExt(ext_id, &ability)) != RT_ERR_OK)
return retVal;

ability.forcemode = pPortability->forcemode;
ability.speed     = (mode == MODE_EXT_HSGMII) ? PORT_SPEED_1000M : pPortability->speed;
ability.duplex    = pPortability->duplex;
ability.link      = pPortability->link;
ability.nway      = pPortability->nway;
ability.txpause   = pPortability->txpause;
ability.rxpause   = pPortability->rxpause;

if ((retVal = rtl8367c_setAsicPortForceLinkExt(ext_id, &ability)) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set the external port force link. This function can be used to set the speed limit of the external ports so as to force the external ports to a certain mode.

RTK defines the external ports as 1 to 15 ports and




NEXT




<s> ret_t rtl8367c_setAsicSvlanDmacCvidSel(rtk_uint32 port, rtk_uint32 enabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
return rtl8367c_setAsicRegBit(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_PORT0_DMACVIDSEL_OFFSET + port, enabled);
else
return rtl8367c_setAsicRegBit(RTL8367C_REG_SVLAN_CFG_EXT, RTL8367C_VS_PORT8_DMACVIDSEL_OFFSET + (port-8), enabled);
}

The above function is used to set/get whether to switch DMACVIDSEL. If it returns RT_OK, it means successful and RT_ERR_PORT_ID means port is out of range.

Let's see some more about this function:
``




NEXT




<s> void wpas_ucode_update_state(struct wpa_supplicant *wpa_s)
{
const char *state;
uc_value_t *val;

val = wpa_ucode_registry_get(iface_registry, wpa_s->ucode.idx);
if (!val)
return;

if (wpa_ucode_call_prepare("state"))
return;

state = wpa_supplicant_state_txt(wpa_s->wpa_state);
uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
uc_value_push(ucv_get(val));
uc_value_push(ucv_get(ucv_string_new(state)));
ucv_put(wpa_ucode_call(3));
ucv_gc(vm);
}

The above function is used to let wpa_supplicant inform its configured
module of its change in state through a uCode call. The uCode call
state() is documented as accepting an interface name, the uCode object
handle and the new state. However




NEXT




<s> static netdev_tx_t bcm6348_emac_start_xmit(struct sk_buff *skb,
struct net_device *ndev)
{
struct bcm6348_emac *emac = netdev_priv(ndev);
struct bcm6348_iudma *iudma = emac->iudma;
struct platform_device *pdev = emac->pdev;
struct device *dev = &pdev->dev;
struct bcm6348_iudma_desc *desc;
u32 len_stat;
netdev_tx_t ret;

/* lock against tx reclaim */
spin_lock(&emac->tx_lock);

/* make sure the tx hw queue is not full, should not happen
* since we stop queue before it's the case */
if (unlikely(!emac->tx_desc_count)) {
netif_stop_queue(ndev);
dev_err(dev, "xmit called with no tx desc available?\n");
ret = NETDEV_TX_BUSY;
goto out_unlock;
}

/* point to the next available desc */
desc = &emac->tx_desc_cpu[emac->tx_curr_desc];
emac->tx_skb[emac->tx_curr_desc] = skb;

/* fill descriptor */
desc->address = dma_map_single(dev, skb->data, skb->len,
DMA_TO_DEVICE);

len_stat = (skb->len << DMADESC_LENGTH_SHIFT) & DMADESC_LENGTH_MASK;
len_stat |= DMADESC_ESOP_MASK | DMADESC_APPEND_CRC |
DMADESC_OWNER_MASK;

emac->tx_curr_desc++;
if (emac->tx_curr_desc == emac->tx_ring_size) {
emac->tx_curr_desc = 0;
len_stat |= DMADESC_WRAP_MASK;
}
emac->tx_desc_count--;

/* dma might be already polling, make sure we update desc
* fields in correct order */
wmb();
desc->len_stat = len_stat;
wmb();

/* kick tx dma */
dmac_writel(iudma, DMAC_CHANCFG_EN_MASK, DMAC_CHANCFG_REG,
emac->tx_chan);

/* stop queue if no more desc available */
if (!emac->tx_desc_count)
netif_stop_queue(ndev);

ndev->stats.tx_bytes += skb->len;
ndev->stats.tx_packets++;
ret = NETDEV_TX_OK;

out_unlock:
spin_unlock(&emac->tx_lock);
return ret;
}

The above function is used to send packets in software or hardware mode. The
send function is also used to start the Ethernet MAC transmit process.

Before the transfer, the Ethernet MAC has already checked the length of the
packet and the type of the




NEXT




<s> wpas_bss_wps_cancel(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
int rc;
struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);

rc = wpas_wps_cancel(wpa_s);

if (rc != 0)
return UBUS_STATUS_NOT_SUPPORTED;

return 0;
}

The above function is used to cancel WPS. It returns one of the following values if successful:

SUCCESS: If the WPS function is completed successfully.

FAILURE, NOT_SUPPORTED and SYSTEM_ERRNO: If the WPS function fails with





NEXT




<s> static void msdc_set_timeout(struct msdc_host *host, u32 ns, u32 clks)
{
void __iomem *base = host->base;
u32 timeout, clk_ns;

host->timeout_ns   = ns;
host->timeout_clks = clks;

clk_ns  = 1000000000UL / host->sclk;
timeout = ns / clk_ns + clks;
timeout = timeout >> 16; /* in 65536 sclk cycle unit */
timeout = timeout > 1 ? timeout - 1 : 0;
timeout = timeout > 255 ? 255 : timeout;

sdr_set_field(SDC_CFG, SDC_CFG_DTOC, timeout);

N_MSG(OPS, "Set read data timeout: %dns %dclks -> %d x 65536 cycles",
ns, clks, timeout + 1);
}

The above function is used to set read data timeout in the MSDC
register. The read data timeout value is programmed to the MSDC register so
that it will control the data waiting time which would be utilized by the
MSDC host device during the data




NEXT




<s> static int lq_ecb_des_decrypt(struct ablkcipher_request *areq)
{
struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);
struct des_ctx *ctx = crypto_ablkcipher_ctx(cipher);

return lq_queue_mgr(ctx, areq, areq->info, CRYPTO_DIR_DECRYPT, 0);

}

The above function is used to call the function
lq_queue_mgr(). In above function, I have provided
CRYPTO_DIR_DECRYPT. What I am trying to understand
here is: How does crypto_ablkcipher_request()




NEXT




<s> void ar9_shutdown(void)
{
ltq_pmu_disable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_PPE_QSB |
IFX_PMU_MODULE_TPE |
IFX_PMU_MODULE_DSL_DFE);
}

The above function is used to turn off power supply from the PMU. Unfortunately there are still a lot of code which is not turned off. In particular:

- ETHP-A0-2DG-N5
  - DSL DFE (




NEXT




<s> ret_t rtl8367c_getAsicRldpCompareRandomNumber(rtk_uint32 *pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_COMP_ID_OFFSET, pEnabled);
}

The above function is used to get the current value of random number compare feature.
Its function is very simple. By using it, we can retrieve the current configuration of it.

If the user wants to configure the random number compare feature, he can call the





NEXT




<s> ctx_t *create_ctx(const cipher_t *cipher, const unsigned char *key,
const unsigned char *iv, int enc, int padding)
{
mbedtls_cipher_context_t *ctx;
const mbedtls_cipher_info_t *cipher_info=cipher;
int ret;

ctx = malloc(sizeof (mbedtls_cipher_context_t));
if (!ctx) {
fprintf (stderr, "Error: create_ctx: out of memory.\n");
return NULL;
}

mbedtls_cipher_init(ctx);
ret = mbedtls_cipher_setup(ctx, cipher_info);
if (ret) {
fprintf(stderr, "Error: mbedtls_cipher_setup: %d\n", ret);
goto abort;
}
ret = mbedtls_cipher_setkey(ctx, key,
(int) mbedtls_cipher_get_key_bitlen(ctx),
enc ? MBEDTLS_ENCRYPT : MBEDTLS_DECRYPT);
if (ret) {
fprintf(stderr, "Error: mbedtls_cipher_setkey: %d\n", ret);
goto abort;
}
if (iv) {
ret = mbedtls_cipher_set_iv(ctx, iv, mbedtls_cipher_get_iv_size(ctx));
if (ret) {
fprintf(stderr, "Error: mbedtls_cipher_set_iv: %d\n", ret);
goto abort;
}
}

if (cipher_info->mode == MBEDTLS_MODE_CBC) {
ret = mbedtls_cipher_set_padding_mode(ctx, padding ?
MBEDTLS_PADDING_PKCS7 :
MBEDTLS_PADDING_NONE);
if (ret) {
fprintf(stderr, "Error: mbedtls_cipher_set_padding_mode: %d\n",
ret);
goto abort;
}
} else {
if (cipher_info->block_size > 1 && padding) {
fprintf(stderr,
"Error: mbedTLS only allows padding with CBC ciphers.\n");
goto abort;
}
}

ret = mbedtls_cipher_reset(ctx);
if (ret) {
fprintf(stderr, "Error: mbedtls_cipher_reset: %d\n", ret);
goto abort;
}
return ctx;

abort:
free_ctx(ctx);
return NULL;
}

The above function is used to create a mbedTLS context with provided information.

To make our encrypted communications more secure, we’ll also initialize a
hmac context to generate a symmetric hash as well as use the initialization
vector in a cipher-block




NEXT




<s> static void rtl839x_vlan_set_tagged(u32 vlan, struct rtl838x_vlan_info *info)
{
u32 u, v, w;
/* Access VLAN table (0) via register 0 */
struct table_reg *r = rtl_table_get(RTL8390_TBL_0, 0);

u = info->tagged_ports >> 21;
v = info->tagged_ports << 11;
v |= ((u32)info->fid) << 3;
v |= info->hash_uc_fid ? BIT(2) : 0;
v |= info->hash_mc_fid ? BIT(1) : 0;
v |= (info->profile_id & 0x4) ? 1 : 0;
w = ((u32)(info->profile_id & 3)) << 30;

sw_w32(u, rtl_table_data(r, 0));
sw_w32(v, rtl_table_data(r, 1));
sw_w32(w, rtl_table_data(r, 2));

rtl_table_write(r, vlan);
rtl_table_release(r);
}

The above function is used to configure VLAN tagged function at run-time.

In our case, we want to configure VLAN tagged function when WWAN card is enabled.

Thus, the follow functions are called in driver when inserting W




NEXT




<s> rtk_api_ret_t rtk_qos_1pRemarkEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicRemarkingDot1pAbility(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get one-packet remarking (1P Remarking) port enable information.
The remarking information can be obtained when the remarking function is enabled and remarking packet type is L2.</s>




NEXT




<s> static ssize_t read_file_ring(struct file *file, char __user *user_buf,
size_t count, loff_t *ppos,
struct ag71xx *ag,
struct ag71xx_ring *ring,
unsigned desc_reg)
{
int ring_size = BIT(ring->order);
int ring_mask = ring_size - 1;
char *buf;
unsigned int buflen;
unsigned int len = 0;
unsigned long flags;
ssize_t ret;
int curr;
int dirty;
u32 desc_hw;
int i;

buflen = (ring_size * DESC_PRINT_LEN);
buf = kmalloc(buflen, GFP_KERNEL);
if (!buf)
return -ENOMEM;

len += snprintf(buf + len, buflen - len,
"Idx ... %-8s %-8s %-8s %-8s .\n",
"desc", "next", "data", "ctrl");

spin_lock_irqsave(&ag->lock, flags);

curr = (ring->curr & ring_mask);
dirty = (ring->dirty & ring_mask);
desc_hw = ag71xx_rr(ag, desc_reg);
for (i = 0; i < ring_size; i++) {
struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
u32 desc_dma = ((u32) ring->descs_dma) + i * AG71XX_DESC_SIZE;

len += snprintf(buf + len, buflen - len,
"%3d %c%c%c %08x %08x %08x %08x %c\n",
i,
(i == curr) ? 'C' : ' ',
(i == dirty) ? 'D' : ' ',
(desc_hw == desc_dma) ? 'H' : ' ',
desc_dma,
desc->next,
desc->data,
desc->ctrl,
(desc->ctrl & DESC_EMPTY) ? 'E' : '*');
}

spin_unlock_irqrestore(&ag->lock, flags);

ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
kfree(buf);

return ret;
}

The above function is used to dump the register description of the ring buffer. The function does the following:
(I) Calculates the size of the ring buffer, `RINGSIZE` (in lines) and mask (as the last entry is reserved for the current




NEXT




<s> static void aes_cbcmac_transform(struct shash_desc *desc, u8 const *in)
{
struct aes_ctx *mctx = crypto_shash_ctx(desc->tfm);

if ( ((mctx->dbn)+1) > AES_CBCMAC_DBN_TEMP_SIZE )
{
//printk("aes_cbcmac_DBN_TEMP_SIZE exceeded\n");
aes_cbcmac_final_impl(desc, (u8 *)mctx->hash, false);
}

memcpy(&mctx->temp[mctx->dbn], in, 16); //dbn workaround
mctx->dbn += 1;
}

The above function is used to perform CBC MAC. The hash data is written into temp[] array, after that CBC MAC is performed, then the hash array is written into data[]. This may also be implemented as below:

static void aes_cbcm




NEXT




<s> ar8xxx_sw_set_flush_arl_table(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
int ret;

mutex_lock(&priv->reg_mutex);
ret = priv->chip->atu_flush(priv);
mutex_unlock(&priv->reg_mutex);

return ret;
}

The above function is used to flush the MAC-address table. Is it really
necessary to acquire the mutex before calling the flush function?

BTW, some parts of the code in drivers/net/ethernet/marvell/ar8216




NEXT




<s> rtk_api_ret_t rtk_rate_shareMeterBucket_get(rtk_meter_id_t index, rtk_uint32 *pBucket_size)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (index > RTK_MAX_METER_ID)
return RT_ERR_FILTER_METER_ID;

if(NULL == pBucket_size)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicShareMeterBucketSize(index, pBucket_size)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the Bucket size of rate meter

/* Bucket sharing function */
rtk_api_ret_t rtl8367c_setAsicShareMeterBucketSize(rtk_meter_id_




NEXT




<s> static inline int gpio_set(struct dc_ep_dev *dev, u32 gpio, int val)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_gpio_set(dev->priv, gpio, val);
}

The above function is used to set a GPIO pin in an embedded board. It calls a function pointer that's set in the "dev->priv" private data, and this private data belongs to the ep-dev. Now, for this example, ep-dev's




NEXT




<s> void sym_clear_all_valid(void)
{
struct symbol *sym;
int i;

for_all_symbols(i, sym)
sym->flags &= ~SYMBOL_VALID;
conf_set_changed(true);
sym_calc_value(modules_sym);
}

The above function is used to clear VALID flags of all symbols in the
symbol table. This is mainly done when switching from one compiler version
to another version, or switching from one kernel/version to another. The
flag VALID is essential to tell which symbol definition




NEXT




<s> void rtk_hal_vlan_tag(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;
rtk_vlan_cfg_t vlan;

ret = rtk_vlan_get(data->vid, &vlan);
if (ret != RT_ERR_OK)
printk("rtk_vlan_get failed\n");
else {
if (data->on_off == 0)
RTK_PORTMASK_PORT_SET(vlan.untag, data->port);
else
RTK_PORTMASK_PORT_CLEAR(vlan.untag, data->port);

ret = rtk_vlan_set(data->vid, &vlan);
if (ret != RT_ERR_OK)
printk("rtk_vlan_set failed\n");
}
}

The above function is used to configure the VLAN tagging status related to port.

The VLAN tagging configuration is actually a very simple bit setting. 8 bits are used to represent 256 VLAN tags. If the tag is on, the value




NEXT




<s> static int mtdsplit_h3c_vfs_parse(struct mtd_info *mtd,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct mtd_partition *parts;
uint32_t format_flag;
struct file_entry file_entry;
size_t retlen;
int err;
size_t kernel_size;
size_t expected_offset;
size_t rootfs_offset;

if (mtd->erasesize != VFS_ERASEBLOCK_SIZE)
return -EINVAL;

/* Check format flag */
err = mtd_read(mtd, FORMAT_FLAG_OFFSET, sizeof(format_flag), &retlen,
(void *) &format_flag);
if (err)
return err;

if (retlen != sizeof(format_flag))
return -EIO;

if (format_flag != FORMAT_FLAG)
return -EINVAL;

/* Check file entry */
err = mtd_read(mtd, FILE_ENTRY_OFFSET, sizeof(file_entry), &retlen,
(void *) &file_entry);
if (err)
return err;

if (retlen != sizeof(file_entry))
return -EIO;

if (file_entry.flags != FILE_ENTRY_FLAGS)
return -EINVAL;

if (file_entry.parent_block != FILE_ENTRY_PARENT_BLOCK)
return -EINVAL;

if (file_entry.parent_index != FILE_ENTRY_PARENT_INDEX)
return -EINVAL;

if (file_entry.data_block != FILE_ENTRY_DATA_BLOCK)
return -EINVAL;

if (strncmp(file_entry.name, FILE_ENTRY_NAME, sizeof(file_entry.name)) != 0)
return -EINVAL;

/* Find rootfs offset */
kernel_size = block_offset(file_entry.data_block +
block_count(file_entry.length) - 1) +
VFS_BLOCK_SIZE;

expected_offset = mtd_roundup_to_eb(kernel_size, mtd);

err = mtd_find_rootfs_from(mtd, expected_offset, mtd->size,
&rootfs_offset, NULL);
if (err)
return err;

parts = kzalloc(NR_PARTS * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = 0;
parts[0].size = rootfs_offset;

parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = mtd->size - rootfs_offset;

*pparts = parts;
return NR_PARTS;
}

The above function is used to add kernel and rootfs partitions. It is very important that the offset for VFS be correct. There is a lot of discussion about this in the source code, but in short, the expected offset for VFS must correspond to the kernel size




NEXT




<s> rtk_api_ret_t rtk_l2_ipMcastGroupEntry_get(ipaddr_t ip_addr, rtk_uint32 vid, rtk_portmask_t *pPortmask)
{
rtk_int32       index;
ipaddr_t        group_addr;
rtk_uint32      group_vid;
rtk_uint32      valid;
rtk_uint32      pmask;
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if((ip_addr & 0xF0000000) != 0xE0000000)
return RT_ERR_INPUT;

if (vid > RTL8367C_VIDMAX)
return RT_ERR_L2_VID;

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

for(index = 0; index <= RTL8367C_LUT_IPMCGRP_TABLE_MAX; index++)
{
if ((retVal = rtl8367c_getAsicLutIPMCGroup((rtk_uint32)index, &group_addr, &group_vid, &pmask, &valid))!=RT_ERR_OK)
return retVal;

if( (valid == ENABLED) && (group_addr == ip_addr) && (group_vid == vid) )
{
if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}
}

return RT_ERR_FAILED;
}

The above function is used to get the group member port of IP multicast group, which uses the following steps to implement:
1. Get the entries in the LUT and see if one entries matches the IP multicast group address ip_addr with VID as




NEXT




<s> static int rtl838x_eth_open(struct net_device *ndev)
{
unsigned long flags;
struct rtl838x_eth_priv *priv = netdev_priv(ndev);
struct ring_b *ring = priv->membase;

pr_debug("%s called: RX rings %d(length %d), TX rings %d(length %d)\n",
__func__, priv->rxrings, priv->rxringlen, TXRINGS, TXRINGLEN);

spin_lock_irqsave(&priv->lock, flags);
rtl838x_hw_reset(priv);
rtl838x_setup_ring_buffer(priv, ring);
if (priv->family_id == RTL8390_FAMILY_ID) {
rtl839x_setup_notify_ring_buffer(priv);
/* Make sure the ring structure is visible to the ASIC */
mb();
flush_cache_all();
}

rtl838x_hw_ring_setup(priv);
phylink_start(priv->phylink);

for (int i = 0; i < priv->rxrings; i++)
napi_enable(&priv->rx_qs[i].napi);

switch (priv->family_id) {
case RTL8380_FAMILY_ID:
rtl838x_hw_en_rxtx(priv);
/* Trap IGMP/MLD traffic to CPU-Port */
sw_w32(0x3, RTL838X_SPCL_TRAP_IGMP_CTRL);
/* Flush learned FDB entries on link down of a port */
sw_w32_mask(0, BIT(7), RTL838X_L2_CTRL_0);
break;

case RTL8390_FAMILY_ID:
rtl839x_hw_en_rxtx(priv);
/* Trap MLD and IGMP messages to CPU_PORT */
sw_w32(0x3, RTL839X_SPCL_TRAP_IGMP_CTRL);
/* Flush learned FDB entries on link down of a port */
sw_w32_mask(0, BIT(7), RTL839X_L2_CTRL_0);
break;

case RTL9300_FAMILY_ID:
rtl93xx_hw_en_rxtx(priv);
/* Flush learned FDB entries on link down of a port */
sw_w32_mask(0, BIT(7), RTL930X_L2_CTRL);
/* Trap MLD and IGMP messages to CPU_PORT */
sw_w32((0x2 << 3) | 0x2,  RTL930X_VLAN_APP_PKT_CTRL);
break;

case RTL9310_FAMILY_ID:
rtl93xx_hw_en_rxtx(priv);

/* Trap MLD and IGMP messages to CPU_PORT */
sw_w32((0x2 << 3) | 0x2,  RTL931X_VLAN_APP_PKT_CTRL);

/* Disable External CPU access to switch, clear EXT_CPU_EN */
sw_w32_mask(BIT(2), 0, RTL931X_MAC_L2_GLOBAL_CTRL2);

/* Set PCIE_PWR_DOWN */
sw_w32_mask(0, BIT(1), RTL931X_PS_SOC_CTRL);
break;
}

netif_tx_start_all_queues(ndev);

spin_unlock_irqrestore(&priv->lock, flags);

return 0;
}

The above function is used to set up the RTL838x and RTL93x Ethernet adapters. The hardware features are the same for Ethernet and CPE adapters which are designed from the same motherboard. The difference between




NEXT




<s> static int conf_touch_deps(void)
{
const char *name;
struct symbol *sym;
int res, i;

strcpy(depfile_path, "include/config/");
depfile_prefix_len = strlen(depfile_path);

name = conf_get_autoconfig_name();
conf_read_simple(name, S_DEF_AUTO);
sym_calc_value(modules_sym);

for_all_symbols(i, sym) {
sym_calc_value(sym);
if ((sym->flags & SYMBOL_NO_WRITE) || !sym->name)
continue;
if (sym->flags & SYMBOL_WRITE) {
if (sym->flags & SYMBOL_DEF_AUTO) {
/*
* symbol has old and new value,
* so compare them...
*/
switch (sym->type) {
case S_BOOLEAN:
case S_TRISTATE:
if (sym_get_tristate_value(sym) ==
sym->def[S_DEF_AUTO].tri)
continue;
break;
case S_STRING:
case S_HEX:
case S_INT:
if (!strcmp(sym_get_string_value(sym),
sym->def[S_DEF_AUTO].val))
continue;
break;
default:
break;
}
} else {
/*
* If there is no old value, only 'no' (unset)
* is allowed as new value.
*/
switch (sym->type) {
case S_BOOLEAN:
case S_TRISTATE:
if (sym_get_tristate_value(sym) == no)
continue;
break;
default:
break;
}
}
} else if (!(sym->flags & SYMBOL_DEF_AUTO))
/* There is neither an old nor a new value. */
continue;
/* else
*	There is an old value, but no new value ('no' (unset)
*	isn't saved in auto.conf, so the old value is always
*	different from 'no').
*/

res = conf_touch_dep(sym->name);
if (res)
return res;
}

return 0;
}

The above function is used to generate the dependency
files by comparing the new value of the symbol with the
old one. So, the only new symbols which will be
generated will be one’s which don’t match the old
value.

The last function




NEXT




<s> static void rtl839x_vlan_profile_setup(int profile)
{
u32 p[2];
u32 pmask_id = UNKNOWN_MC_PMASK;

p[0] = pmask_id; /* Use portmaks 0xfff for unknown IPv6 MC flooding */
/* Enable L2 Learning BIT 0, portmask UNKNOWN_MC_PMASK for IP/L2-MC traffic flooding */
p[1] = 1 | pmask_id << 1 | pmask_id << 13;

sw_w32(p[0], RTL839X_VLAN_PROFILE(profile));
sw_w32(p[1], RTL839X_VLAN_PROFILE(profile) + 4);

rtl839x_write_mcast_pmask(UNKNOWN_MC_PMASK, 0x001fffffffffffff);
}

The above function is used to set the portmask of the VLAN-OFF profile. This
is done using the RTL839X_VLAN_PROFILE to setup port learning.

As there is no other way to set portmask, there is




NEXT




<s> void rb_softconfig_exit(void)
{
kobject_put(sc_kobj);
sc_kobj = NULL;
kfree(sc_buf);
sc_buf = NULL;
}

The above function is used to unload the softconfig driver. It performs actions such as freeing the buffer and the kobject.
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h




NEXT




<s> static AT91S_DataFlashStatus AT91F_PartialPageWrite (
AT91PS_DataFlash pDataFlash,
unsigned char *src,
unsigned int dest,
unsigned int size)
{
unsigned int page;
unsigned int AdrInPage;

page = dest / (pDataFlash->pDevice->pages_size);
AdrInPage = dest % (pDataFlash->pDevice->pages_size);

/* Read the contents of the page in the Sram Buffer */
AT91F_MainMemoryToBufferTransfer(pDataFlash, DB_PAGE_2_BUF1_TRF, page);
AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_DATAFLASH_TIMEOUT);

/*Update the SRAM buffer */
AT91F_DataFlashWriteBuffer(pDataFlash, DB_BUF1_WRITE, src, AdrInPage, size);
AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_DATAFLASH_TIMEOUT);

/* Erase page if a 128 Mbits device */
if (pDataFlash->pDevice->pages_number >= 16384)
{
AT91F_PageErase(pDataFlash, page);
AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_DATAFLASH_TIMEOUT);
}

/* Rewrite the modified Sram Buffer in the main memory */
return(AT91F_WriteBufferToMain(pDataFlash, DB_BUF1_PAGE_ERASE_PGM,
(page*pDataFlash->pDevice->pages_size)));
}

The above function is used to write partially one or more pages of the Data Flash (16kb or 256 kb size). By setting the right arguments, the function will do a page write or a page erase. The write is not really partial, but




NEXT




<s> static int rtl8367c_reset_port_mibs(int port)
{

return rtk_stat_port_reset(rtl8367c_sw_to_phy_port(port));
}

The above function is used to reset port mibs.

The below is the function for enabling/disabling specific MII MIB access
for a specified port.

static int rtl8367c_mmi_mib_enable(




NEXT




<s> static inline void ecc_write16(struct mt7621_nfc *nfc, u32 reg, u16 val)
{
writew(val, nfc->ecc_regs + reg);
}

The above function is used to write a 16-bit value to one of the registers
of the NFC module.

But when you try to trace it using the Intel Trace Technology, it will show
that the 16-bit value was split into




NEXT




<s> static void _nvram_free(nvram_handle_t *h)
{
uint32_t i;
nvram_tuple_t *t, *next;

/* Free hash table */
for (i = 0; i < NVRAM_ARRAYSIZE(h->nvram_hash); i++) {
for (t = h->nvram_hash[i]; t; t = next) {
next = t->next;
if (t->value)
free(t->value);
free(t);
}
h->nvram_hash[i] = NULL;
}

/* Free dead table */
for (t = h->nvram_dead; t; t = next) {
next = t->next;
if (t->value)
free(t->value);
free(t);
}

h->nvram_dead = NULL;
}

The above function is used to free any allocated memory when the NVRAM
handle is destroyed.

The function above differs from an equivalent function for the
libnvram library:

static void _nvram_free(nvram_handle_t *




NEXT




<s> ret_t rtl8367c_getAsicMIBsLoggingType(rtk_uint32 index, rtk_uint32* pType)
{
if(index > RTL8367C_MIB_MAX_LOG_MODE_IDX)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_CTRL5, index,pType);
}

The above function is used to return the type of MIB entry to log. The following table is a summary of the values which the function returns. Note: This function is not yet supported by the RAPI interface.
ret_t rtl8367c_




NEXT




<s> rtk_api_ret_t rtk_svlan_untag_action_get(rtk_svlan_untag_action_t *pAction, rtk_vlan_t *pSvid)
{
rtk_api_ret_t   retVal;
rtk_uint32      svidx;
rtl8367c_svlan_memconf_t svlanMemConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pAction || NULL == pSvid)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicSvlanIngressUntag(pAction)) != RT_ERR_OK)
return retVal;

if(*pAction == UNTAG_ASSIGN)
{
if ((retVal = rtl8367c_getAsicSvlanUntagVlan(&svidx)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(svidx, &svlanMemConf)) != RT_ERR_OK)
return retVal;

*pSvid = svlanMemConf.vs_svid;
}

return RT_ERR_OK;
}

The above function is used to retrieve the SVID untagged action and SVID information in SV mode.
/* Description:
    1. Read SVLan ingress untagged action and SVID, in SV mode.
    2. The SVLan




NEXT




<s> static inline size_t osafeloader_min(size_t x, size_t y) {
return x < y ? x : y;
}

The above function is used to calculate a safe size range for the buffer passed as a parameter to the following function. The buffer must be large enough to store the minimum of two arguments. The implementation of the function is quite simple since it is written in the language of the compiler,




NEXT




<s> static int postprocess_read(u32 data, int where, unsigned int size)
{
u32 ret = 0;

switch (size) {
case 1:
ret = (data >> ((where & 3) << 3)) & 0xff;
break;
case 2:
ret = (data >> ((where & 3) << 3)) & 0xffff;
break;
case 4:
ret = data;
break;
}

return ret;
}

The above function is used to extract a memory location from a 32-bit memory address for the AMIBIOS code. Here's another snippet:

static int postprocess_write(struct mem_map *mem, u32 data, int




NEXT




<s> ar8xxx_phy_poll_reset(struct mii_bus *bus)
{
unsigned int sleep_msecs = 20;
int ret, elapsed, i;

for (elapsed = sleep_msecs; elapsed <= 600;
elapsed += sleep_msecs) {
msleep(sleep_msecs);
for (i = 0; i < AR8XXX_NUM_PHYS; i++) {
ret = mdiobus_read(bus, i, MII_BMCR);
if (ret < 0)
return ret;
if (ret & BMCR_RESET)
break;
if (i == AR8XXX_NUM_PHYS - 1) {
usleep_range(1000, 2000);
return 0;
}
}
}
return -ETIMEDOUT;
}

The above function is used to poll the reset signal from all the PHYs that the host driver is responsible for resetting. This function is a replacement of the previous one.

The previous function polled the reset signal 50 ms. I am not sure as




NEXT




<s> static inline int gpio_get(struct dc_ep_dev *dev, u32 gpio, int *val)
{
if (WARN_ON(!dev || !val))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_gpio_get(dev->priv, gpio, val);
}

The above function is used to read the GPIO value

As you can see it doesnt take the address of the variable holding
the value to be read so the above function is of no use

And as far as I know dc_drm_driver.c




NEXT




<s> static void conf_save(void);
static int show_textbox_ext(const char *title, char *text, int r, int c,
int *keys, int *vscroll, int *hscroll,
update_text_fn update_text, void *data);
static void show_textbox(const char *title, const char *text, int r, int c);
static void show_helptext(const char *title, const char *text);
static void show_help(struct menu *menu);

static char filename[PATH_MAX+1];
static void set_config_filename(const char *config_filename)
{
static char menu_backtitle[PATH_MAX+128];

snprintf(menu_backtitle, sizeof(menu_backtitle), "%s - %s",
config_filename, rootmenu.prompt->text);
set_dialog_backtitle(menu_backtitle);

snprintf(filename, sizeof(filename), "%s", config_filename);
}

The above function is used to set the file path (by calling fset_config_filename) that the settings file are to stored in when using the save function (conf_save).

void

This function saves the current config data to an xml settings file.




NEXT




<s> static void _smi_start(void)
{

/* change GPIO pin to Output only */
GPIO_DIRECTION_SET(smi_SCK, GPIO_DIR_OUT);
GPIO_DIRECTION_SET(smi_SDA, GPIO_DIR_OUT);

/* Initial state: SCK: 0, SDA: 1 */
GPIO_DATA_SET(smi_SCK, 0);
GPIO_DATA_SET(smi_SDA, 1);
CLK_DURATION(DELAY);

/* CLK 1: 0 -> 1, 1 -> 0 */
GPIO_DATA_SET(smi_SCK, 1);
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SCK, 0);
CLK_DURATION(DELAY);

/* CLK 2: */
GPIO_DATA_SET(smi_SCK, 1);
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SDA, 0);
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SCK, 0);
CLK_DURATION(DELAY);
GPIO_DATA_SET(smi_SDA, 1);

}

The above function is used to start the master SPI slave mode.</s>




NEXT




<s> IFX_MEI_DFEMemoryAlloc (DSL_DEV_Device_t * pDev, long size)
{
unsigned long mem_ptr;
char *org_mem_ptr = NULL;
int idx = 0;
long total_size = 0;
int err = 0;
smmu_mem_info_t *adsl_mem_info =
((ifx_mei_device_private_t *) pDev->pPriv)->adsl_mem_info;
//		DSL_DEV_PRIVATE(pDev)->adsl_mem_info;
int allocate_size = SDRAM_SEGMENT_SIZE;

IFX_MEI_DMSG("image_size = %ld\n", size);
// Alloc Swap Pages
for (idx = 0; size > 0 && idx < MAX_BAR_REGISTERS; idx++) {
// skip bar15 for XDATA usage.
if (idx == XDATA_REGISTER)
continue;
#if 0
if (size < SDRAM_SEGMENT_SIZE) {
allocate_size = size;
if (allocate_size < 1024)
allocate_size = 1024;
}
#endif
if (idx == (MAX_BAR_REGISTERS - 1))
allocate_size = size;
else
allocate_size = SDRAM_SEGMENT_SIZE;

org_mem_ptr = kmalloc (allocate_size, GFP_KERNEL);
if (org_mem_ptr == NULL) {
IFX_MEI_EMSG ("%d: kmalloc %d bytes memory fail!\n", idx, allocate_size);
err = -ENOMEM;
goto allocate_error;
}

if (((unsigned long)org_mem_ptr) & (1023)) {
/* Pointer not 1k aligned, so free it and allocate a larger chunk
* for further alignment.
*/
kfree(org_mem_ptr);
org_mem_ptr = kmalloc (allocate_size + 1024, GFP_KERNEL);
if (org_mem_ptr == NULL) {
IFX_MEI_EMSG ("%d: kmalloc %d bytes memory fail!\n",
idx, allocate_size + 1024);
err = -ENOMEM;
goto allocate_error;
}
mem_ptr = (unsigned long) (org_mem_ptr + 1023) & ~(1024 -1);
} else {
mem_ptr = (unsigned long) org_mem_ptr;
}

adsl_mem_info[idx].address = (char *) mem_ptr;
adsl_mem_info[idx].org_address = org_mem_ptr;
adsl_mem_info[idx].size = allocate_size;
size -= allocate_size;
total_size += allocate_size;
}
if (size > 0) {
IFX_MEI_EMSG ("Image size is too large!\n");
err = -EFBIG;
goto allocate_error;
}
err = idx;
return err;

allocate_error:
IFX_MEI_DFEMemoryFree (pDev, FREE_ALL);
return err;
}

The above function is used to create an aligned memory pool for DFE.
It is done in the following steps:
# Check for the validity of total size of memory.
# Allocate enough chunk of memory and create a DFE buffer entry.

Alloc




NEXT




<s> static int rtl83xx_port_pre_bridge_flags(struct dsa_switch *ds, int port, struct switchdev_brport_flags flags, struct netlink_ext_ack *extack)
{
struct rtl838x_switch_priv *priv = ds->priv;
unsigned long features = 0;
pr_debug("%s: %d %lX\n", __func__, port, flags.val);
if (priv->r->enable_learning)
features |= BR_LEARNING;
if (priv->r->enable_flood)
features |= BR_FLOOD;
if (priv->r->enable_mcast_flood)
features |= BR_MCAST_FLOOD;
if (priv->r->enable_bcast_flood)
features |= BR_BCAST_FLOOD;
if (flags.mask & ~(features))
return -EINVAL;

return 0;
}

The above function is used to set the hardware bridge flags for port, so it will check whether the features (i.e., the bridge flags) in swtichdev_brport_flags (flags) are supported by the RTL83xx chip. In this




NEXT




<s> static void rtl931x_sds_mii_mode_set(u32 sds, phy_interface_t mode)
{
u32 val;

switch (mode) {
case PHY_INTERFACE_MODE_QSGMII:
val = 0x6;
break;
case PHY_INTERFACE_MODE_XGMII:
val = 0x10; /* serdes mode XSGMII */
break;
case PHY_INTERFACE_MODE_USXGMII:
case PHY_INTERFACE_MODE_2500BASEX:
val = 0xD;
break;
case PHY_INTERFACE_MODE_HSGMII:
val = 0x12;
break;
case PHY_INTERFACE_MODE_SGMII:
val = 0x2;
break;
default:
return;
}

val |= (1 << 7);

sw_w32(val, RTL931X_SERDES_MODE_CTRL + 4 * (sds >> 2));
}

The above function is used to set the physical interface mode. For example,
in RTL931X_INIT function, the following code could be employed to initialise
all PHY devices on rtl931x chip:

if (phy_




NEXT




<s> hostapd_rrm_nr_enable(struct hostapd_data *hapd)
{
__hostapd_bss_mgmt_enable(hapd, 1 << BSS_MGMT_EN_NEIGHBOR);
}

The above function is used to enable RRM NEIGHBOR report. But if the neighbor report has already been enabled for this AP, there is no provision in the above function to ensure that neighbor report is not enabled a 2nd time. Thus neighbor report is enabled multi




NEXT




<s> static void nmbm_update_checksum(struct nmbm_header *header)
{
header->checksum = 0;
header->checksum = nmbm_crc32(0, header, header->size);
}

The above function is used to update the headers of every message transmitted
and received. If the checksums do not match when the reply is received,
the checksums are not updated.

When the nmbm_init function is called, what I




NEXT




<s> int mtd_find_rootfs_from(struct mtd_info *mtd,
size_t from,
size_t limit,
size_t *ret_offset,
enum mtdsplit_part_type *type)
{
size_t offset;
int err;

for (offset = from; offset < limit;
offset = mtd_next_eb(mtd, offset)) {
err = mtd_check_rootfs_magic(mtd, offset, type);
if (err)
continue;

*ret_offset = offset;
return 0;
}

return -ENODEV;
}

The above function is used to find a valid rootfs partition within a list of
partitions that have a valid rootfs MBR. If such partition cannot be found,
error code -ENODEV is returned.</s>




NEXT




<s> int AT91F_DataflashInit(void)
{
int i;
int dfcode;
int Nb_device = 0;

AT91F_SpiInit();

for (i = 0; i < CFG_MAX_DATAFLASH_BANKS; i++) {
dataflash_info[i].id = 0;
dataflash_info[i].Device.pages_number = 0;
dfcode = AT91F_DataflashProbe (cs[i][1], &dataflash_info[i].Desc);

switch (dfcode) {
case AT45DB161:
dataflash_info[i].Device.pages_number = 4096;
dataflash_info[i].Device.pages_size = 528;
dataflash_info[i].Device.page_offset = 10;
dataflash_info[i].Device.byte_mask = 0x300;
dataflash_info[i].Device.cs = cs[i][1];
dataflash_info[i].Desc.DataFlash_state = IDLE;
dataflash_info[i].logical_address = cs[i][0];
dataflash_info[i].id = dfcode;
Nb_device++;
break;

case AT45DB321:
dataflash_info[i].Device.pages_number = 8192;
dataflash_info[i].Device.pages_size = 528;
dataflash_info[i].Device.page_offset = 10;
dataflash_info[i].Device.byte_mask = 0x300;
dataflash_info[i].Device.cs = cs[i][1];
dataflash_info[i].Desc.DataFlash_state = IDLE;
dataflash_info[i].logical_address = cs[i][0];
dataflash_info[i].id = dfcode;
Nb_device++;
break;

case AT45DB642:
dataflash_info[i].Device.pages_number = 8192;
dataflash_info[i].Device.pages_size = 1056;
dataflash_info[i].Device.page_offset = 11;
dataflash_info[i].Device.byte_mask = 0x700;
dataflash_info[i].Device.cs = cs[i][1];
dataflash_info[i].Desc.DataFlash_state = IDLE;
dataflash_info[i].logical_address = cs[i][0];
dataflash_info[i].id = dfcode;
Nb_device++;
break;
case AT45DB128:
dataflash_info[i].Device.pages_number = 16384;
dataflash_info[i].Device.pages_size = 1056;
dataflash_info[i].Device.page_offset = 11;
dataflash_info[i].Device.byte_mask = 0x700;
dataflash_info[i].Device.cs = cs[i][1];
dataflash_info[i].Desc.DataFlash_state = IDLE;
dataflash_info[i].logical_address = cs[i][0];
dataflash_info[i].id = dfcode;
Nb_device++;
break;
default:
break;
}
}
return (Nb_device);
}

The above function is used to detect AT45 dataflashes.
The second example has a similar function :

int AT91F_SsInit(void)
{
int i, j;
int SScode;
int Nb_device




NEXT




<s> static int rtl8367_init_regs(struct rtl8366_smi *smi)
{
u32 data;
u32 rlvid;
u32 mode;
int err;

REG_WR(smi, RTL8367_RTL_MAGIC_ID_REG, RTL8367_RTL_MAGIC_ID_VAL);

REG_RD(smi, RTL8367_CHIP_VER_REG, &data);
rlvid = (data >> RTL8367_CHIP_VER_RLVID_SHIFT) &
RTL8367_CHIP_VER_RLVID_MASK;

REG_RD(smi, RTL8367_CHIP_MODE_REG, &data);
mode = data & RTL8367_CHIP_MODE_MASK;

switch (rlvid) {
case 0:
err = rtl8367_init_regs0(smi, mode);
break;

case 1:
err = rtl8367_write_phy_reg(smi, 0, 31, 5);
if (err)
break;

err = rtl8367_write_phy_reg(smi, 0, 5, 0x3ffe);
if (err)
break;

err = rtl8367_read_phy_reg(smi, 0, 6, &data);
if (err)
break;

if (data == 0x94eb) {
err = rtl8367_init_regs1(smi, mode);
} else if (data == 0x2104) {
err = rtl8367_init_regs2(smi, mode);
} else {
dev_err(smi->parent, "unknow phy data %04x\n", data);
return -ENODEV;
}

break;

default:
dev_err(smi->parent, "unknow rlvid %u\n", rlvid);
err = -ENODEV;
break;
}

return err;
}

The above function is used to set up the register initial values for the 8366(b) Ethernet switch IC before it can be access.

From the switch initialization code I see that the driver uses REG_WR () and REG_RD () functions




NEXT




<s> ar8xxx_sw_set_mirror_tx_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

mutex_lock(&priv->reg_mutex);
priv->mirror_tx = !!val->value.i;
priv->chip->set_mirror_regs(priv);
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to set the MIRROR_TX enable value for the given
switch device. This value is used to enable (or disable in future) the
transmit side of a mirror port. The value of the parameter ‘priv’ is
ret




NEXT




<s> void item_set_selected(int val)
{
item_cur->node.selected = val;
}

The above function is used to set the "selected" property of a
node. Currently, this property is used by the code to determine
which nodes are selected in the tree_view object(s).

However, in the future, I would like to use this




NEXT




<s> int puts(const char *s)
{
while (*s)
putchar(*s++);
return 0;
}

The above function is used to perform some task. What is the function performed by puts ?

```
a)
The function returns an integer

b)
The function prints a string as given

c)
The function prints an integer as given





NEXT




<s> static void set_qsb(struct atm_vcc *, struct atm_qos *, unsigned int);
static void qsb_global_set(void);
static inline void set_htu_entry(unsigned int, unsigned int, unsigned int, int, int);
static inline void clear_htu_entry(unsigned int);
static void validate_oam_htu_entry(void);
static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to push OAM frame.
#endif

#if defined(CONFIG_IFX_OAM)
static inline void ifx_push_rx(void);

extern void ifx_oam_recv(unsigned int




NEXT




<s> static int __init rtl8366s_module_init(void)
{
return platform_driver_register(&rtl8366s_driver);
}

The above function is used to initialize the RTL8366S platform driver module.
When we type lsmod, we can see if the RTL8366S platform driver module is successfully created.
In addition, the module information can be found




NEXT




<s> void wl_glue_set_attach_callback(wl_glue_attach_cb_t cb)
{
attach_cb = cb;
}

The above function is used to setup the attachment callback to the render loop. It needs to called before using wl_glue_attach() function, I mean before calling the render loop.

But I guess it will be better after some further improvements on glue and




NEXT




<s> void hostapd_ubus_add_iface(struct hostapd_iface *iface)
{
if (!hostapd_ubus_init())
return;
}

The above function is used to add an interface for UBUS. But
the implementation is in lib/libubus.c.

Is there any code for this at this point? I wanted to add USB and
UBUS support to hostapd. Is this




NEXT




<s> static int aw9523_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
unsigned int selector,
const unsigned int **pins,
unsigned int *num_pins)
{
*pins = &aw9523_pins[selector].number;
*num_pins = 1;
return 0;
}

The above function is used to return the pins for the selectors that are defined in the following structures:

struct aw9523_pins aw9523_pins[6] = {
.group = 0,
.number




NEXT




<s> ar8xxx_mib_capture(struct ar8xxx_priv *priv)
{
return ar8xxx_mib_op(priv, AR8216_MIB_FUNC_CAPTURE);
}

The above function is used to enable or disable mib capture
which uses the special mode of CAM engine to capture the frames
according to the specified mib counters.

On 28 Nov this morning, at around 8:24 AM I




NEXT




<s> static void mt7621_nfc_write_data_empty(struct mt7621_nfc *nfc, u32 len)
{
while (len >= 4) {
mt7621_nfc_pio_write(nfc, 0xffffffff, false);
len -= 4;
}

while (len) {
mt7621_nfc_pio_write(nfc, 0xff, true);
len--;
}
}

The above function is used to empty the mt7621_nfc data register in cases where a user has set their own data without a corresponding length.

In a recent patch(v3) to the MT7621 driver, the above empty function




NEXT




<s> rtk_api_ret_t rtk_filter_igrAclPolarity_get(rtk_uint32* pPolarity)
{
/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPolarity)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicAclGpioPolarity(pPolarity);
}

The above function is used to configure the ACL interrupt GPIO input polarity.
The values are as follow:



	Value						Meaning                                   	    Status
	0x0001					




NEXT




<s> ret_t rtl8367c_setAsicTrunkingMode(rtk_uint32 mode)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_DUMB_OFFSET, mode);
}

The above function is used to set the RTL8367C_PORT_TRUNK_DUMB_OFFSET bit
in RTL8367C_REG_PORT_TRUNK_CTRL to toggle between trunk mode and non-trunk





NEXT




<s> static int rtl83xx_setup(struct dsa_switch *ds)
{
struct rtl838x_switch_priv *priv = ds->priv;

pr_debug("%s called\n", __func__);

/* Disable MAC polling the PHY so that we can start configuration */
priv->r->set_port_reg_le(0ULL, priv->r->smi_poll_ctrl);

for (int i = 0; i < ds->num_ports; i++)
priv->ports[i].enable = false;
priv->ports[priv->cpu_port].enable = true;

/* Configure ports so they are disabled by default, but once enabled
* they will work in isolated mode (only traffic between port and CPU).
*/
for (int i = 0; i < priv->cpu_port; i++) {
if (priv->ports[i].phy) {
priv->ports[i].pm = BIT_ULL(priv->cpu_port);
priv->r->traffic_set(i, BIT_ULL(i));
}
}
priv->r->traffic_set(priv->cpu_port, BIT_ULL(priv->cpu_port));

/* For standalone ports, forward packets even if a static fdb
* entry for the source address exists on another port.
*/
if (priv->r->set_static_move_action) {
for (int i = 0; i <= priv->cpu_port; i++)
priv->r->set_static_move_action(i, true);
}

if (priv->family_id == RTL8380_FAMILY_ID)
rtl838x_print_matrix();
else
rtl839x_print_matrix();

rtl83xx_init_stats(priv);

rtl83xx_vlan_setup(priv);

rtl83xx_setup_bpdu_traps(priv);

ds->configure_vlan_while_not_filtering = true;

priv->r->l2_learning_setup();

rtl83xx_port_set_salrn(priv, priv->cpu_port, false);
ds->assisted_learning_on_cpu_port = true;

/* Make sure all frames sent to the switch's MAC are trapped to the CPU-port
*  0: FWD, 1: DROP, 2: TRAP2CPU
*/
if (priv->family_id == RTL8380_FAMILY_ID)
sw_w32(0x2, RTL838X_SPCL_TRAP_SWITCH_MAC_CTRL);
else
sw_w32(0x2, RTL839X_SPCL_TRAP_SWITCH_MAC_CTRL);

/* Enable MAC Polling PHY again */
rtl83xx_enable_phy_polling(priv);
pr_debug("Please wait until PHY is settled\n");
msleep(1000);
priv->r->pie_init(priv);

return 0;
}

The above function is used to setup all the necessary ports and PHY on RTL 838X chips, once it is done all the
necessary action are done to trap the frames (such as trap_while_not_filtering) and setting the MAC poll




NEXT




<s> rtl_w16(struct switch_dev *dev, unsigned int page, unsigned int phy, unsigned int reg, u16 val)
{
struct rtl_priv *priv = to_rtl(dev);
struct mii_bus *bus = priv->bus;

rtl_set_page(priv, page);
bus->write(bus, phy, reg, val);
bus->read(bus, phy, reg); /* flush */
return 0;
}

The above function is used to write 2-bytes value at a phy register.

When it needs to read and write phy configuration register from/to a switch chip of phy type MII, we have to use the following function:

static int




NEXT




<s> static void ag71xx_phy_link_adjust(struct net_device *dev)
{
struct ag71xx *ag = netdev_priv(dev);
struct phy_device *phydev = ag->phy_dev;
unsigned long flags;
int status_change = 0;

spin_lock_irqsave(&ag->lock, flags);

if (phydev->link) {
if (ag->duplex != phydev->duplex
|| ag->speed != phydev->speed) {
status_change = 1;
}
}

if (phydev->link != ag->link)
status_change = 1;

ag->link = phydev->link;
ag->duplex = phydev->duplex;
ag->speed = phydev->speed;

if (status_change)
ag71xx_link_adjust(ag);

spin_unlock_irqrestore(&ag->lock, flags);
}

The above function is used to detect changes in link state and change port speed or duplex accordingly.

The netdev_priv() macro is used to get the private data of the netdevice structure. This private data is used in the phy_driver structure.





NEXT




<s> swconfig_find_attr_by_name(const struct switch_attrlist *alist,
const char *name)
{
int i;

for (i = 0; i < alist->n_attr; i++)
if (strcmp(name, alist->attr[i].name) == 0)
return &alist->attr[i];

return NULL;
}

The above function is used to find a structure of type switch_attr in a
list of such structures, given the name of the structure. It takes two
pointers as parameters. The first pointer is a pointer to a structure
of type switch_attrlist that holds




NEXT




<s> static int esw_set_vlan_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

esw->global_vlan_enable = val->value.i != 0;

return 0;
}

The above function is used to set the vlan enable status on a RT3052 switch.
However, this function never checks if the VLAN is supported or enabled on
the switch.</s>




NEXT




<s> ret_t rtl8367c_getAsicLutIpMulticastLookup(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LUT_IPMC_HASH_OFFSET, pEnabled);
}

The above function is used to retrieve the result from the register table. If we need to access more than one register the better option will be to use the macro
defined below.

rtk_uint32 rtl8367c_getAsicReg




NEXT




<s> static bool nmbm_map_block(struct nmbm_instance *ni, uint32_t lb)
{
uint32_t pb;
bool success;

if (ni->mapping_blocks_ba == ni->mapping_blocks_top_ba) {
nlog_warn(ni, "No spare unmapped blocks.\n");
return false;
}

success = nmbm_block_walk(ni, false, ni->mapping_blocks_top_ba, &pb, 0,
ni->mapping_blocks_ba);
if (!success) {
nlog_warn(ni, "No spare unmapped blocks.\n");
nmbm_update_info_table(ni);
ni->mapping_blocks_top_ba = ni->mapping_blocks_ba;
return false;
}

ni->block_mapping[lb] = pb;
ni->mapping_blocks_top_ba--;
ni->block_mapping_changed++;

nlog_info(ni, "Logic block %u mapped to physical block %u\n", lb, pb);

return true;
}

The above function is used to map a logic block using the logic block number as
input, it returns TRUE if the block has been successfully mapped else it
returns FALSE indicating that it has not been mapped. First it looks for an
unmapped block using, nmb




NEXT




<s> ret_t rtl8367c_getAsicLedBlinkRate(rtk_uint32* pBlinkRate)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_LED_MODE, RTL8367C_SEL_LEDRATE_MASK, pBlinkRate);
}

The above function is used to read the current LED blinking rate.

In the rtl8367c_getAsicRegBits() function, the LEDBlinkRate is stored in the LEDEnable_R3 register and read back as 




NEXT




<s> static int en7523_clk_probe(struct platform_device *pdev)
{
struct device_node *node = pdev->dev.of_node;
struct clk_hw_onecell_data *clk_data;
void __iomem *base, *np_base;
int r;

base = devm_platform_ioremap_resource(pdev, 0);
if (IS_ERR(base))
return PTR_ERR(base);

np_base = devm_platform_ioremap_resource(pdev, 1);
if (IS_ERR(np_base))
return PTR_ERR(np_base);

clk_data = devm_kzalloc(&pdev->dev,
struct_size(clk_data, hws, EN7523_NUM_CLOCKS),
GFP_KERNEL);
if (!clk_data)
return -ENOMEM;

en7523_register_clocks(&pdev->dev, clk_data, base, np_base);

r = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);
if (r)
dev_err(&pdev->dev,
"could not register clock provider: %s: %d\n",
pdev->name, r);

return r;
}

The above function is used to register the HW clock of en7523 device</s>




NEXT




<s> hostapd_parse_vht_map_blobmsg(uint16_t map)
{
char label[4];
int16_t val;
int i;

for (i = 0; i < 8; i++) {
snprintf(label, 4, "%dss", i + 1);

val = (map & (BIT(1) | BIT(0))) + 7;
blobmsg_add_u16(&b, label, val == 10 ? -1 : val);
map = map >> 2;
}
}

The above function is used to parse and store VHT map to blob msg</s>




NEXT




<s> static void wl_glue_ssb_remove(struct ssb_device *dev)
{
void *wldev = ssb_get_drvdata(dev);

if (remove_cb)
remove_cb(wldev);

ssb_set_drvdata(dev, NULL);
}

The above function is used to remove the wl driver for a given SSB device.

The SSB driver in the Linux kernel has a few issues that prevent it from
working well with the userspace utility 'wl', a client library and
wrapper for the w




NEXT




<s> static inline int wait_sata_command_not_busy(int device)
{
/* Wait for data to be available */
int status = 0;
int loops = MAX_NOT_BUSY_LOOPS;
do {
if (!(*(sata_regs_base[device] + SATA_COMMAND_OFF)
& (1 << SATA_CMD_BUSY_BIT))) {
status = 1;
break;
}
udelay(100);
} while (--loops);

if (!loops) {
printf("wait_sata_command_not_busy() Timed out of wait for SATA command to finish\n");
}

return status;
}

The above function is used to check wether the SATA disk is busy or not. I saw the code in the driver is a part of ata_command(). I got confused by the variable status since I did not see any usage of status. The code seems to indicate




NEXT




<s> static inline void rtl8366_smi_clk_delay(struct rtl8366_smi *smi)
{
ndelay(smi->clk_delay);
}

The above function is used to generate a small delay (18ns
for example) when

clocking a signal (see rtl8366_smi_clk_set()). It was
defined to

call udelay() with a small time




NEXT




<s> int rb_softconfig_init(struct kobject *rb_kobj, struct mtd_info *mtd)
{
size_t bytes_read, buflen;
const u8 *buf;
int i, ret;
u32 magic;

sc_buf = NULL;
sc_kobj = NULL;

ret = __get_mtd_device(mtd);
if (ret)
return -ENODEV;

sc_buflen = mtd->size;
sc_buf = kmalloc(sc_buflen, GFP_KERNEL);
if (!sc_buf) {
__put_mtd_device(mtd);
return -ENOMEM;
}

ret = mtd_read(mtd, 0, sc_buflen, &bytes_read, sc_buf);
__put_mtd_device(mtd);

if (ret)
goto fail;

if (bytes_read != sc_buflen) {
ret = -EIO;
goto fail;
}

/* Check we have what we expect */
magic = *(const u32 *)sc_buf;
if (RB_MAGIC_SOFT != magic) {
ret = -EINVAL;
goto fail;
}

/* Skip magic and 32bit CRC located immediately after */
buf = sc_buf + (sizeof(magic) + sizeof(u32));
buflen = sc_buflen - (sizeof(magic) + sizeof(u32));

/* Populate sysfs */
ret = -ENOMEM;
sc_kobj = kobject_create_and_add(RB_MTD_SOFT_CONFIG, rb_kobj);
if (!sc_kobj)
goto fail;

rwlock_init(&sc_bufrwl);

/* Locate and publish all known tags */
for (i = 0; i < ARRAY_SIZE(sc_attrs); i++) {
ret = routerboot_tag_find(buf, buflen, sc_attrs[i].tag_id,
&sc_attrs[i].pld_ofs, &sc_attrs[i].pld_len);
if (ret) {
sc_attrs[i].pld_ofs = sc_attrs[i].pld_len = 0;
continue;
}

/* Account for skipped magic and crc32 */
sc_attrs[i].pld_ofs += sizeof(magic) + sizeof(u32);

ret = sysfs_create_file(sc_kobj, &sc_attrs[i].kattr.attr);
if (ret)
pr_warn(RB_SC_PR_PFX "Could not create %s sysfs entry (%d)\n",
sc_attrs[i].kattr.attr.name, ret);
}

/* Finally add the 'commit' attribute */
if (RB_SC_HAS_WRITE_SUPPORT) {
ret = sysfs_create_file(sc_kobj, &sc_kattrcommit.attr);
if (ret) {
pr_err(RB_SC_PR_PFX "Could not create %s sysfs entry (%d), aborting!\n",
sc_kattrcommit.attr.name, ret);
goto sysfsfail;	// required attribute
}
}

pr_info("MikroTik RouterBOARD software configuration sysfs driver v" RB_SOFTCONFIG_VER "\n");

return 0;

sysfsfail:
kobject_put(sc_kobj);
sc_kobj = NULL;
fail:
kfree(sc_buf);
sc_buf = NULL;
return ret;
}

The above function is used to populate the sysfs interface via the kobject_create_and_add() function that allows an object to be added as the child of another object, along with creating the initial sub-nodes for the interface via the sysfs_create_




NEXT




<s> void rtl838x_traffic_set(int source, u64 dest_matrix)
{
rtl838x_set_port_reg(dest_matrix, rtl838x_port_iso_ctrl(source));
}

The above function is used to set the traffic forwarding matrix for the
rtl838x traffic policer.  Dest_matrix is the matrix of data in the format
of

[
	srcport   |	destination
	1    00




NEXT




<s> static int rtl8390_init_mac(struct rtl838x_eth_priv *priv)
{
/* We will need to set-up EEE and the egress-rate limitation */
return 0;
}

The above function is used to set up 100M bit-rate mode, using 200M MAC and MDI. When the board is powered up, it will enter the 100M bit-rate mode, which is specified using the PH




NEXT




<s> static void rtl931x_vlan_fwd_on_inner(int port, bool is_set)
{
/* Always set all tag modes to fwd based on either inner or outer tag */
if (is_set)
sw_w32_mask(0xf, 0, RTL931X_VLAN_PORT_FWD + (port << 2));
else
sw_w32_mask(0, 0xf, RTL931X_VLAN_PORT_FWD + (port << 2));
}

The above function is used to select fwd mode for a particular vlan port based on inner tag of VLAN header.

What i want is fwd mode only when inner tag is non-zero. If the inner tag is zero, then i want copy mode operation




NEXT




<s> static int ag71xx_stop(struct net_device *dev)
{
unsigned long flags;
struct ag71xx *ag = netdev_priv(dev);

netif_carrier_off(dev);
phy_stop(ag->phy_dev);

spin_lock_irqsave(&ag->lock, flags);
if (ag->link) {
ag->link = 0;
ag71xx_link_adjust(ag);
}
spin_unlock_irqrestore(&ag->lock, flags);

ag71xx_hw_disable(ag);

return 0;
}

The above function is used to bring down a card, e.g.,  to issue  ifdown command.  Unfortunately,  it  is not  working  on  all  cards  correctly.  When bringing down, it  does not switch the interface from full




NEXT




<s> static void g997_channel_status(int fd, DSL_AccessDir_t direction) {
IOCTL_DIR(DSL_G997_ChannelStatus_t, DSL_FIO_G997_CHANNEL_STATUS_GET, direction);

m_u32("interleave_delay", out.data.ActualInterleaveDelay * 10);
m_double("inp", (double)out.data.ActualImpulseNoiseProtection / 10);
#ifndef INCLUDE_DSL_CPE_API_DANUBE
// prefer ACTNDR, see comments in drv_dsl_cpe_api_g997.h
m_u32("data_rate", out.data.ActualNetDataRate);
#else
m_u32("data_rate", out.data.ActualDataRate);
#endif
}

The above function is used to retrieve information about the current downstream ADSL link quality in response to an ioctl, DSL_FIO_G997_CHANNEL_STATUS_GET, to DSL_G997_ChannelStatus_t. It




NEXT




<s> static int rtl9300_i2c_config_xfer(struct rtl9300_i2c *i2c, u16 addr, u16 len)
{
/* Set bus frequency */
REG_MASK(i2c, 0x3 << RTL9300_I2C_CTRL2_SCL_FREQ,
i2c->bus_freq << RTL9300_I2C_CTRL2_SCL_FREQ, RTL9300_I2C_CTRL2);

/* Set slave device address */
REG_MASK(i2c, 0x7f << RTL9300_I2C_CTRL2_DEV_ADDR,
addr << RTL9300_I2C_CTRL2_DEV_ADDR, RTL9300_I2C_CTRL2);

/* Set data length */
REG_MASK(i2c, 0xf << RTL9300_I2C_CTRL2_DATA_WIDTH,
((len - 1) & 0xf) << RTL9300_I2C_CTRL2_DATA_WIDTH, RTL9300_I2C_CTRL2);

/* Set read mode to random */
REG_MASK(i2c, 0x1 << RTL9300_I2C_CTRL2_READ_MODE, 0, RTL9300_I2C_CTRL2);

return 0;
}

The above function is used to set the I2C_CTRL2 register when Raspbian is trying to access the RTL8712 chipsets.

According to RTL8712 datasheet (pg.173), the following




NEXT




<s> extern void Jump(unsigned int addr);

const char *menu_dataflash[] = {
#ifdef XMODEM
"1: P DFboot\n",
"2: P U-Boot\n",
#endif
"3: P SDCard\n",
#ifdef	PAGESZ_1056
"4: R UBOOT\n",
#else
"4: R UBOOT\n",
#endif
#ifdef XMODEM
"5: P DF [addr]\n",
#endif
"6: RD DF [addr]\n",
"7: E DF\n"
};

The above function is used to jump to the address in the
dataflash for the page bootloader.

The below functions are used to write to the data flash and
read from the data flash.</s>




NEXT




<s> static void rtl838x_write_pie_fixed_fields(u32 r[],  struct pie_rule *pr)
{
r[6] = ((u32) (pr->spmmask_fix & 0x3)) << 22;
r[6] |= ((u32) (pr->spn & 0x3f)) << 16;
r[6] |= pr->mgnt_vlan ? BIT(15) : 0;
r[6] |= pr->dmac_hit_sw ? BIT(14) : 0;
r[6] |= pr->not_first_frag ? BIT(13) : 0;
r[6] |= ((u32) (pr->frame_type_l4 & 0x7)) << 10;
r[6] |= ((u32) (pr->frame_type & 0x3)) << 8;
r[6] |= pr->otag_fmt ? BIT(7) : 0;
r[6] |= pr->itag_fmt ? BIT(6) : 0;
r[6] |= pr->otag_exist ? BIT(5) : 0;
r[6] |= pr->itag_exist ? BIT(4) : 0;
r[6] |= ((u32) (pr->frame_type_l2 & 0x3)) << 2;
r[6] |= ((u32) (pr->tid & 0x3));

r[13] = ((u32) (pr->spmmask_fix_m & 0x3)) << 22;
r[13] |= ((u32) (pr->spn_m & 0x3f)) << 16;
r[13] |= pr->mgnt_vlan_m ? BIT(15) : 0;
r[13] |= pr->dmac_hit_sw_m ? BIT(14) : 0;
r[13] |= pr->not_first_frag_m ? BIT(13) : 0;
r[13] |= ((u32) (pr->frame_type_l4_m & 0x7)) << 10;
r[13] |= ((u32) (pr->frame_type_m & 0x3)) << 8;
r[13] |= pr->otag_fmt_m ? BIT(7) : 0;
r[13] |= pr->itag_fmt_m ? BIT(6) : 0;
r[13] |= pr->otag_exist_m ? BIT(5) : 0;
r[13] |= pr->itag_exist_m ? BIT(4) : 0;
r[13] |= ((u32) (pr->frame_type_l2_m & 0x3)) << 2;
r[13] |= ((u32) (pr->tid_m & 0x3));

r[14] = pr->valid ? BIT(31) : 0;
r[14] |= pr->cond_not ? BIT(30) : 0;
r[14] |= pr->cond_and1 ? BIT(29) : 0;
r[14] |= pr->cond_and2 ? BIT(28) : 0;
r[14] |= pr->ivalid ? BIT(27) : 0;

if (pr->drop)
r[17] = 0x1 << 14;	/* Standard drop action */
else
r[17] = 0;
r[17] |= pr->fwd_sel ? BIT(13) : 0;
r[17] |= pr->ovid_sel ? BIT(12) : 0;
r[17] |= pr->ivid_sel ? BIT(11) : 0;
r[17] |= pr->flt_sel ? BIT(10) : 0;
r[17] |= pr->log_sel ? BIT(9) : 0;
r[17] |= pr->rmk_sel ? BIT(8) : 0;
r[17] |= pr->meter_sel ? BIT(7) : 0;
r[17] |= pr->tagst_sel ? BIT(6) : 0;
r[17] |= pr->mir_sel ? BIT(5) : 0;
r[17] |= pr->nopri_sel ? BIT(4) : 0;
r[17] |= pr->cpupri_sel ? BIT(3) : 0;
r[17] |= pr->otpid_sel ? BIT(2) : 0;
r[17] |= pr->itpid_sel ? BIT(1) : 0;
r[17] |= pr->shaper_sel ? BIT(0) : 0;
}

The above function is used to convert the user input rule structure to the RTL838x specific RIF record format for 60GHz PN ICs, since we don’t have an actual RTL838x device, we can’t




NEXT




<s> ret_t rtl8367c_getAsicLutCamTbUsage(rtk_uint32* pEnabled)
{
ret_t       retVal;
rtk_uint32  regData;

if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_BCAM_DISABLE_OFFSET, &regData)) != RT_ERR_OK)
return retVal;

*pEnabled = regData ? 0 : 1;
return RT_ERR_OK;
}

The above function is used to read a registe bit in port 0, but no macro are supplied to deal with registe address and bit, is it because I am using port 1 which is not the first port(0)?

if (0 == *p




NEXT




<s> static int rtl8366rb_sw_set_port_disable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 mask, data;

if (val->port_vlan >= RTL8366RB_NUM_PORTS)
return -EINVAL;

mask = 1 << val->port_vlan ;
if (val->value.i)
data = mask;
else
data = 0;

return rtl8366_smi_rmwr(smi, RTL8366RB_PECR, mask, data);
}

The above function is used to set the port disable value.The parameter val is used to send two different values:
   * the port number ( port_vlan  );
   * the disable value(value.i);

When the disable value is 0




NEXT




<s> static int proc_read_genconf(char *, char **, off_t, int, int *, void *);
#endif
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static int proc_read_dbg(char *, char **, off_t, int, int *, void *);
static int proc_write_dbg(struct file *, const char *, unsigned long, void *);
#endif

/*
*  Proc Help Functions
*/
static INLINE int stricmp(const char *, const char *);
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static INLINE int strincmp(const char *, const char *, int);
#endif
static INLINE int ifx_ptm_version(char *);

/*
*  Init & clean-up functions
*/
static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to indicate if the 4340XB ATM showtime (ATM_SHOWTIME)
is enabled or disabled. This information is used to set the 3559XB APM1 ATM
VPI




NEXT




<s> static int __init clk_en7523_init(void)
{
return platform_driver_register(&clk_en7523_drv);
}

The above function is used to register the p8 clk on the e930 platform.

Question is how do I specify the platform_driver_data? I know that
this must be a pointer to a data structure.

Is the platform_driver_




NEXT




<s> void zconf_starthelp(void)
{
new_string();
last_ts = first_ts = 0;
BEGIN(HELP);
}

The above function is used to initialise the help file.
The global variables 'first_ts' and 'last_ts' are initialised so that
the function 'zconf_findnext(char *)' can find it in the 'zconf_help'




NEXT




<s> ret_t rtl8367c_resetVlan(void)
{
ret_t   retVal;

if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL2, RTL8367C_VLAN_EXT_CTRL2_OFFSET, 1)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to reset 8367C’s VLAN configuration. It’s written in assembly and I used a simple compiler named SDCC.  It has 1 function. It does a bit set on the VLAN EXT control register in




NEXT




<s> int mtk_bmt_attach(struct mtd_info *mtd)
{
struct device_node *np;
int ret = 0;

if (bmtd.mtd)
return -ENOSPC;

np = mtd_get_of_node(mtd);
if (!np)
return 0;

if (of_property_read_bool(np, "mediatek,bmt-v2"))
bmtd.ops = &mtk_bmt_v2_ops;
else if (of_property_read_bool(np, "mediatek,nmbm"))
bmtd.ops = &mtk_bmt_nmbm_ops;
else if (of_property_read_bool(np, "mediatek,bbt"))
bmtd.ops = &mtk_bmt_bbt_ops;
else
return 0;

bmtd.remap_range = of_get_property(np, "mediatek,bmt-remap-range",
&bmtd.remap_range_len);
bmtd.remap_range_len /= 8;

bmtd.mtd = mtd;
mtk_bmt_replace_ops(mtd);

bmtd.blk_size = mtd->erasesize;
bmtd.blk_shift = ffs(bmtd.blk_size) - 1;
bmtd.pg_size = mtd->writesize;
bmtd.pg_shift = ffs(bmtd.pg_size) - 1;
bmtd.total_blks = mtd->size >> bmtd.blk_shift;

bmtd.data_buf = kzalloc(bmtd.pg_size + bmtd.mtd->oobsize, GFP_KERNEL);
if (!bmtd.data_buf) {
pr_info("nand: FATAL ERR: allocate buffer failed!\n");
ret = -1;
goto error;
}

memset(bmtd.data_buf, 0xff, bmtd.pg_size + bmtd.mtd->oobsize);

ret = bmtd.ops->init(np);
if (ret)
goto error;

mtk_bmt_add_debugfs();
return 0;

error:
mtk_bmt_detach(mtd);
return ret;
}

The above function is used to attach the new MTD device to the driver. This function will be called by mt7622 and mt7624, which will trigger other things like device initialization.
For bmt_attach_ops, the above function may




NEXT




<s> int wpa_ucode_registry_add(uc_value_t *reg, uc_value_t *val)
{
uc_value_t *data;
int i = 0;

while (ucv_array_get(reg, i))
i++;

ucv_array_set(reg, i, ucv_get(val));

return i + 1;
}

The above function is used to store the data for the u_code_registry in the register file of the controller using the UC libraries.</s>




NEXT




<s> rtk_api_ret_t rtk_l2_addr_get(rtk_mac_t *pMac, rtk_l2_ucastAddr_t *pL2_data)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* must be unicast address */
if ((pMac == NULL) || (pMac->octet[0] & 0x1))
return RT_ERR_MAC;

if (pL2_data->fid > RTL8367C_FIDMAX || pL2_data->efid > RTL8367C_EFIDMAX)
return RT_ERR_L2_FID;

memset(&l2Table, 0, sizeof(rtl8367c_luttb));

memcpy(l2Table.mac.octet, pMac->octet, ETHER_ADDR_LEN);
l2Table.ivl_svl     = pL2_data->ivl;
l2Table.cvid_fid    = pL2_data->cvid;
l2Table.fid         = pL2_data->fid;
l2Table.efid        = pL2_data->efid;
method = LUTREADMETHOD_MAC;

if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
return retVal;

memcpy(pL2_data->mac.octet, pMac->octet,ETHER_ADDR_LEN);
pL2_data->port      = rtk_switch_port_P2L_get(l2Table.spa);
pL2_data->fid       = l2Table.fid;
pL2_data->efid      = l2Table.efid;
pL2_data->ivl       = l2Table.ivl_svl;
pL2_data->cvid      = l2Table.cvid_fid;
pL2_data->is_static = l2Table.nosalearn;
pL2_data->auth      = l2Table.auth;
pL2_data->sa_block  = l2Table.sa_block;
pL2_data->da_block  = l2Table.da_block;
pL2_data->priority  = l2Table.lut_pri;
pL2_data->sa_pri_en = l2Table.sa_en;
pL2_data->fwd_pri_en= l2Table.fwd_en;
pL2_data->address   = l2Table.address;

return RT_ERR_OK;
}

The above function is used to
get any unicast MAC address entry (the function uses a LUT entry to get the address).
LUT entry format is fixed, as shown
below:

#ifndef _RTL8367C_L




NEXT




<s> static int rtl83xx_set_features(struct net_device *dev, netdev_features_t features)
{
struct rtl838x_eth_priv *priv = netdev_priv(dev);

if ((features ^ dev->features) & NETIF_F_RXCSUM) {
if (!(features & NETIF_F_RXCSUM))
sw_w32_mask(BIT(3), 0, priv->r->mac_port_ctrl(priv->cpu_port));
else
sw_w32_mask(0, BIT(3), priv->r->mac_port_ctrl(priv->cpu_port));
}

return 0;
}

The above function is used to toggle hardware CSC on and off. It just needs to update some configuration bits, rather than a re-programming of the PFs.

You can add another field like CSC_ENABLED in the dev_priv struct to store




NEXT




<s> rtk_api_ret_t rtk_svlan_memberPortEntry_get(rtk_vlan_t svid, rtk_svlan_memberCfg_t *pSvlan_cfg)
{
rtk_api_ret_t retVal;
rtk_uint32 i;
rtl8367c_svlan_memconf_t svlanMemConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pSvlan_cfg)
return RT_ERR_NULL_POINTER;

if (svid > RTL8367C_VIDMAX)
return RT_ERR_SVLAN_VID;


for (i = 0; i<= RTL8367C_SVIDXMAX; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;

if (svid == svlanMemConf.vs_svid)
{
pSvlan_cfg->svid        = svlanMemConf.vs_svid;

if(rtk_switch_portmask_P2L_get(svlanMemConf.vs_member,&(pSvlan_cfg->memberport)) != RT_ERR_OK)
return RT_ERR_FAILED;

if(rtk_switch_portmask_P2L_get(svlanMemConf.vs_untag,&(pSvlan_cfg->untagport)) != RT_ERR_OK)
return RT_ERR_FAILED;

pSvlan_cfg->fiden       = svlanMemConf.vs_force_fid;
pSvlan_cfg->fid         = svlanMemConf.vs_fid_msti;
pSvlan_cfg->priority    = svlanMemConf.vs_priority;
pSvlan_cfg->efiden      = svlanMemConf.vs_efiden;
pSvlan_cfg->efid        = svlanMemConf.vs_efid;

return RT_ERR_OK;
}
}

return RT_ERR_SVLAN_ENTRY_NOT_FOUND;

}

The above function is used to set SVLAN member port entry through API. The description of each parameter is the same as the above function.</s>




NEXT




<s> ret_t rtl8367c_getAsicStormFilterExtBroadcastMeter(rtk_uint32 *pMeter)
{
if(NULL == pMeter)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG0, RTL8367C_BC_STORM_EXT_METERIDX_MASK, pMeter);
}

The above function is used to get BC Storm Meter. However, BC_STORM_EXT_METERIDX_MASK can't access the whole 32-bit register space. Can we make a function for getting the whole BC Storm Meter 32-




NEXT




<s> void hostapd_ubus_notify(struct hostapd_data *hapd, const char *type, const u8 *addr)
{
if (!hapd->ubus.obj.has_subscribers)
return;

if (!addr)
return;

blob_buf_init(&b, 0);
blobmsg_add_macaddr(&b, "address", addr);

ubus_notify(ctx, &hapd->ubus.obj, type, b.head, -1);
}

The above function is used to notify all subscribers of an event (like client or STA association), and as you can see the blob_buf_head is passed to ubus_notify. When hapd receives the blob_buf_head, how hap




NEXT




<s> int RangeDecoderReverseBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
{
int mi = 1;
int i;
int symbol = 0;
#ifdef _LZMA_LOC_OPT
RC_INIT_VAR
#endif
for(i = 0; i < numLevels; i++)
{
#ifdef _LZMA_LOC_OPT
CProb *prob = probs + mi;
RC_GET_BIT2(prob, mi, ; , symbol |= (1 << i))
#else
int bit = RangeDecoderBitDecode(probs + mi, rd);
mi = mi + mi + bit;
symbol |= (bit << i);
#endif
}
#ifdef _LZMA_LOC_OPT
RC_FLUSH_VAR
#endif
return symbol;
}

The above function is used to decode reversed bit tree, which is different from the usual bit tree in that when walking down a node from left to right, the lowest order symbols (those to the far left in the bit tree representation) are the most specific, while the




NEXT




<s> static void rtl930x_packet_cntr_clear(int counter)
{
/* Access LOG table (3) via register RTL9300_TBL_0 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_0, 3);

pr_info("In %s, id %d\n", __func__, counter);
/* The table has a size of 2 registers */
if (counter % 2)
sw_w32(0, rtl_table_data(r, 0));
else
sw_w32(0, rtl_table_data(r, 1));

rtl_table_write(r, counter / 2);

rtl_table_release(r);
}

The above function is used to clear the LOG_COUNTERS table in RTL9300
switch, the corresponding table definition is following.

/**
 * @Description: LOG_COUNTERS
 *
 * @Data: Mar 1




NEXT




<s> rtk_api_ret_t rtk_igmp_dynamicRouterPortAllow_get(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t   retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPAllowDynamicRouterPort(&pmask))!=RT_ERR_OK)
return retVal;

if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the portmask of the entry.</s>




NEXT




<s> uc_bpf_set_tc_hook(uc_value_t *ifname, uc_value_t *type, uc_value_t *prio,
int fd)
{
DECLARE_LIBBPF_OPTS(bpf_tc_hook, hook);
DECLARE_LIBBPF_OPTS(bpf_tc_opts, attach_tc,
.handle = 1);
const char *type_str;
uint64_t prio_val;

if (ucv_type(ifname) != UC_STRING || ucv_type(type) != UC_STRING ||
ucv_type(prio) != UC_INTEGER)
err_return(EINVAL, NULL);

prio_val = ucv_int64_get(prio);
if (prio_val > 0xffff)
err_return(EINVAL, NULL);

type_str = ucv_string_get(type);
if (!strcmp(type_str, "ingress"))
hook.attach_point = BPF_TC_INGRESS;
else if (!strcmp(type_str, "egress"))
hook.attach_point = BPF_TC_EGRESS;
else
err_return(EINVAL, NULL);

hook.ifindex = if_nametoindex(ucv_string_get(ifname));
if (!hook.ifindex)
goto error;

bpf_tc_hook_create(&hook);
attach_tc.priority = prio_val;
if (bpf_tc_detach(&hook, &attach_tc) < 0 && fd < 0)
goto error;

if (fd < 0)
goto out;

attach_tc.prog_fd = fd;
if (bpf_tc_attach(&hook, &attach_tc) < 0)
goto error;

out:
return TRUE;

error:
if (fd >= 0)
err_return(ENOENT, NULL);
return NULL;
}

The above function is used to install a TC hook on a specific network interface.
The parameters passed to the function are as follows:

ifname
The name of the network interface on which the TC hook is to be installed.
type
The type of




NEXT




<s> static int msp430_leds_probe(struct spi_device *spi)
{
struct device *dev = &spi->dev;
struct device_node *np = dev_of_node(dev);
struct device_node *child;
int rc;

rc = msp430_check_workmode(spi);
if (rc)
return rc;

for_each_available_child_of_node(np, child) {
u32 reg;

if (of_property_read_u32(child, "reg", &reg))
continue;

if (reg < MSP430_LED_MIN_ID || reg > MSP430_LED_MAX_ID) {
dev_err(dev, "invalid LED (%u) [%d, %d]\n", reg,
MSP430_LED_MIN_ID, MSP430_LED_MAX_ID);
continue;
}

rc = msp430_led(spi, child, reg);
if (rc < 0) {
of_node_put(child);
return rc;
}
}

return 0;
}

The above function is used to enumerate all available LEDs to create
a list. It is part of the spi driver to add a list of LEDs to
the msp430 spi device

To compile this driver use
# make ARCH




NEXT




<s> rtk_api_ret_t rtk_igmp_queryInterval_get(rtk_uint32 *pInterval)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pInterval)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPQueryInterval(pInterval))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the IGMP query interval. This is the time between IGMP query frames, which are transmitted by the host periodically.</s>




NEXT




<s> static void print_line(WINDOW *win, int row, int width);
static char *get_line(void);
static void print_position(WINDOW * win);

static int hscroll;
static int begin_reached, end_reached, page_length;
static char *buf;
static char *page;

/*
* refresh window content
*/
static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
int cur_y, int cur_x, update_text_fn update_text,
void *data)
{
print_page(box, boxh, boxw, update_text, data);
print_position(dialog);
wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
wrefresh(dialog);
}

The above function is used to display text information in a GUI dialog
box with a GUI window (e.g. terminal) as its content (also called GUI
widget content). The `update_text` function will be called with the widget
window as




NEXT




<s> ret_t rtl8367c_setAsicUnknownIPv6MulticastBehavior(rtk_uint32 port, rtk_uint32 behave)
{
if(port >  RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(behave >= L3_UNKOWN_MULTICAST_END)
return RT_ERR_NOT_ALLOWED;

return rtl8367c_setAsicRegBits(RTL8367C_UNKNOWN_IPV6_MULTICAST_REG(port), RTL8367C_UNKNOWN_IPV6_MULTICAST_MASK(port), behave);
}

The above function is used to set IPv6 multicast forwarding behavior of unknown IPv6 source in port based forwarding mode (As per 802.3ah standard, IGMP snooping function will be used regardless of IPv6 mult




NEXT




<s> rtk_api_ret_t rtk_qos_queueNum_get(rtk_port_t port, rtk_queue_num_t *pQueue_num)
{
rtk_api_ret_t retVal;
rtk_uint32 qidx;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicOutputQueueMappingIndex(rtk_switch_port_L2P_get(port), &qidx)) != RT_ERR_OK)
return retVal;

if (0 == qidx)
*pQueue_num = 8;
else
*pQueue_num = qidx;

return RT_ERR_OK;
}

The above function is used to obtain the physical output queue index of input queue. It must be greater than `0`.

In AX5857/AX5855, the output queues for physical input queues are 8 in total. The




NEXT




<s> static int write_eeprom(struct data_header **data_table, int cnt)
{
int ret = EXIT_FAILURE;

for (int i = 0; i < cnt; i++) {
if (data_table[i]->type == DATA_HEADER_EEPROM
&& data_table[i]->id == DATA_HEADER_ID_CAL) {
ret =
write_file(ofname, data_table[i]->data,
data_table[i]->length);
break;
}

}

return ret;
}

The above function is used to write contents of the EEPROM after modification into the EEPROM by the command. So if you want to re-download the data, you’ll have to delete the file first.

Another small addition was the need




NEXT




<s> void zconf_initscan(const char *name)
{
yyin = zconf_fopen(name);
if (!yyin) {
fprintf(stderr, "can't find file %s\n", name);
exit(1);
}

current_buf = xmalloc(sizeof(*current_buf));
memset(current_buf, 0, sizeof(*current_buf));

current_file = file_lookup(name);
yylineno = 1;
}

The above function is used to open and load the y.y file into memory. As a
result, zconf_yylineno can be set and can tell what column the parser is
parsing.

yyextern int yylineno;

#




NEXT




<s> arc_code_page_download (uint32_t arc_code_length, uint32_t * start_address)
{
int count;

IFX_MEI_DMSG("try to download pages,size=%d\n", arc_code_length);
IFX_MEI_ControlModeSet (&dsl_devices[0], MEI_MASTER_MODE);
IFX_MEI_HaltArc (&dsl_devices[0]);
IFX_MEI_LongWordWriteOffset (&dsl_devices[0], (u32) ME_DX_AD, 0);
for (count = 0; count < arc_code_length; count++) {
IFX_MEI_LongWordWriteOffset (&dsl_devices[0], (u32) ME_DX_DATA,
*(start_address + count));
}
IFX_MEI_ControlModeSet (&dsl_devices[0], JTAG_MASTER_MODE);
}

The above function is used to download the code from JTAG mode
to DSL mode. The DSL mode code is written to a ROM located on
the Arc device in the field region (addresses 0x80-0x13FF)





NEXT




<s> static int rtl8367c_get_port_link(int port, int *link, int *speed, int *duplex)
{

if(rtk_port_phyStatus_get(rtl8367c_sw_to_phy_port(port),(rtk_port_linkStatus_t *)link,
(rtk_port_speed_t *)speed,(rtk_port_duplex_t *)duplex))
return -EINVAL;

return 0;
}

The above function is used to retrieve the real link status of a certain port.

Notice

The above code does not do any checking for valid parameters, but all the arguments are supposed to be valid, or the function return would be -EINVAL.

For




NEXT




<s> static void sata_bug_6320_workaround(int port, ulong *candidate)
{
int is_read;
int quads_transferred;
int remainder;
int sector_quads_remaining;

/* Only want to apply fix to reads */
is_read = !(*((unsigned long*) SATA_DM_DBG1)
& (port ? SATA_CORE_PORT1_DATA_DIR : SATA_CORE_PORT0_DATA_DIR));

/* Check for an incomplete transfer, i.e. not a multiple of 512 bytes
transferred (datacount_port register counts quads transferred) */
quads_transferred = *((unsigned long*) (
port ? SATA_DATACOUNT_PORT1 : SATA_DATACOUNT_PORT0));

remainder = quads_transferred & 0x7f;
sector_quads_remaining = remainder ? (0x80 - remainder) : 0;

if (is_read && (sector_quads_remaining == 2)) {
debug("SATA read fixup, only transfered %d quads, "
"sector_quads_remaining %d, port %d\n",
quads_transferred, sector_quads_remaining, port);

int total_len = ATA_SECT_SIZE;
ulong *sata_data_ptr = (void*) (
port ? SATA_DATA_MUX_RAM1 : SATA_DATA_MUX_RAM0)
+ ((total_len - 8) % 2048);

*candidate = *sata_data_ptr;
*(candidate + 1) = *(sata_data_ptr + 1);
}
}

The above function is used to work around a hardware issue on some SATA
drives. This function is not thread safe.

In 8b2bde4, SATA driver code removes this workaround check (in commit
be2e8




NEXT




<s> ret_t rtl8367c_getAsicForceGroupLed(rtk_uint32* groupmask, rtk_uint32* pMode)
{
ret_t retVal;
rtk_uint32 i,regData;
CONST rtk_uint16 bits[3] = {0x0004,0x0010,0x0040};

/* Get Related Registers */
if((retVal = rtl8367c_getAsicRegBits(RTL8367C_LED_FORCE_CTRL, RTL8367C_LED_FORCE_MODE_MASK, &regData)) != RT_ERR_OK)
return retVal;

for(i = 0; i< RTL8367C_LEDGROUPNO; i++)
{
if((regData & bits[i]) == bits[i])
{
*groupmask = *groupmask | (1 << i);
}
}

return rtl8367c_getAsicRegBits(RTL8367C_LED_FORCE_CTRL, RTL8367C_FORCE_MODE_MASK, pMode);
}

The above function is used to obtain the status of the LED force.</s>




NEXT




<s> void AT91F_SpiInit(void) {
/* Configure PIOs */
AT91C_BASE_PIOA->PIO_ASR = AT91C_PA3_NPCS0 | AT91C_PA4_NPCS1 |
AT91C_PA1_MOSI | AT91C_PA5_NPCS2 |
AT91C_PA6_NPCS3 | AT91C_PA0_MISO |
AT91C_PA2_SPCK;
AT91C_BASE_PIOA->PIO_PDR = AT91C_PA3_NPCS0 | AT91C_PA4_NPCS1 |
AT91C_PA1_MOSI | AT91C_PA5_NPCS2 |
AT91C_PA6_NPCS3 | AT91C_PA0_MISO |
AT91C_PA2_SPCK;
/* Enable CLock */
AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_SPI;

/* Reset the SPI */
AT91C_BASE_SPI->SPI_CR = AT91C_SPI_SWRST;

/* Configure SPI in Master Mode with No CS selected !!! */
AT91C_BASE_SPI->SPI_MR = AT91C_SPI_MSTR | AT91C_SPI_MODFDIS | AT91C_SPI_PCS;

/* Configure CS0 and CS3 */
*(AT91C_SPI_CSR + 0) = AT91C_SPI_CPOL | (AT91C_SPI_DLYBS & DATAFLASH_TCSS) |
(AT91C_SPI_DLYBCT & DATAFLASH_TCHS) |
((AT91C_MASTER_CLOCK / (2*AT91C_SPI_CLK)) << 8);
*(AT91C_SPI_CSR + 3) = AT91C_SPI_CPOL | (AT91C_SPI_DLYBS & DATAFLASH_TCSS) |
(AT91C_SPI_DLYBCT & DATAFLASH_TCHS) |
((AT91C_MASTER_CLOCK / (2*AT91C_SPI_CLK)) << 8);
}

The above function is used to initialize the AT91F flash controller. If an
SPI flash is connected to AT91SAM9, this function can be used to drive it.</s>




NEXT




<s> store_val(struct nl_msg *msg, void *arg)
{
struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
struct switch_val *val = arg;

if (!val)
goto error;

if (nla_parse(tb, SWITCH_ATTR_MAX - 1, genlmsg_attrdata(gnlh, 0),
genlmsg_attrlen(gnlh, 0), NULL) < 0) {
goto error;
}

if (tb[SWITCH_ATTR_OP_VALUE_INT])
val->value.i = nla_get_u32(tb[SWITCH_ATTR_OP_VALUE_INT]);
else if (tb[SWITCH_ATTR_OP_VALUE_STR])
val->value.s = strdup(nla_get_string(tb[SWITCH_ATTR_OP_VALUE_STR]));
else if (tb[SWITCH_ATTR_OP_VALUE_PORTS])
val->err = store_port_val(msg, tb[SWITCH_ATTR_OP_VALUE_PORTS], val);
else if (tb[SWITCH_ATTR_OP_VALUE_LINK])
val->err = store_link_val(msg, tb[SWITCH_ATTR_OP_VALUE_LINK], val);

val->err = 0;
return 0;

error:
return NL_SKIP;
}

The above function is used to parse data from kernel, as we will read later, the switchd kernel module returns messages. As you see this function is quite short and it is more than enough for these tasks. In the beginning we have some error checks, if something goes wrong




NEXT




<s> static int sercomm_bootflag_value(struct mtd_info *mtd, uint8_t *buf)
{
size_t retlen;
loff_t offs;
int rc;

for (offs = 0; offs < mtd->size; offs += mtd->erasesize) {
rc = mtd_read(mtd, offs, SERCOMM_MAGIC_LEN, &retlen, buf);
if (rc || retlen != SERCOMM_MAGIC_LEN)
continue;

if (memcmp(buf, SERCOMM_MAGIC_PFX, SERCOMM_MAGIC_PFX_LEN))
continue;

rc = char_to_num(buf[SERCOMM_MAGIC_PFX_LEN + 0]) * 100;
rc += char_to_num(buf[SERCOMM_MAGIC_PFX_LEN + 1]) * 10;
rc += char_to_num(buf[SERCOMM_MAGIC_PFX_LEN + 2]) * 1;

return rc;
}

return -ENOENT;
}

The above function is used to get the value of “bootflag” and it uses the mtd_read function to copy the image into the buffer.

#include <linux/module.h>
#include <linux/init.h>
#include <




NEXT




<s> ret_t rtl8367c_setAsicTrunkingFc(rtk_uint32 group, rtk_uint32 enabled)
{
ret_t       retVal;

if(group > RTL8367C_MAX_TRUNK_GID)
return RT_ERR_LA_TRUNK_ID;

if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_PORT_TRUNK_DROP_CTRL, RTL8367C_PORT_TRUNK_DROP_CTRL_OFFSET, ENABLED)) != RT_ERR_OK)
return retVal;

return rtl8367c_setAsicRegBit(RTL8367C_REG_PORT_TRUNK_FLOWCTRL, (RTL8367C_EN_FLOWCTRL_TG0_OFFSET + group), enabled);
}

The above function is used to set trunk flow control. Before we change the bit fields in the register, we must check the following requirements.

First, we check the validity of the user-defined trunk ID.

Second, we check the validity of the




NEXT




<s> static inline u16 nfi_read16(struct mt7621_nfc *nfc, u32 reg)
{
return readw(nfc->nfi_regs + reg);
}

The above function is used to read 16-bit data from the NFC controller's
register space. The function takes a pointer to a struct representing the
NFC controller and a 32-bit integer representing the offset of the register to
read from




NEXT




<s> ar8xxx_read_id(struct ar8xxx_priv *priv)
{
u32 val;
u16 id;
int i;

val = ar8xxx_read(priv, AR8216_REG_CTRL);
if (val == ~0)
return -ENODEV;

id = val & (AR8216_CTRL_REVISION | AR8216_CTRL_VERSION);
for (i = 0; i < AR8X16_PROBE_RETRIES; i++) {
u16 t;

val = ar8xxx_read(priv, AR8216_REG_CTRL);
if (val == ~0)
return -ENODEV;

t = val & (AR8216_CTRL_REVISION | AR8216_CTRL_VERSION);
if (t != id)
return -ENODEV;
}

priv->chip_ver = (id & AR8216_CTRL_VERSION) >> AR8216_CTRL_VERSION_S;
priv->chip_rev = (id & AR8216_CTRL_REVISION);
return 0;
}

The above function is used to get the chip identifier of the specific hardware.
The values are stored in chip_rev for the revision values and chip_ver for version value.</s>




NEXT




<s> rtk_api_ret_t rtk_igmp_portRxPktEnable_get(rtk_port_t port, rtk_igmp_rxPktEnable_t *pRxCfg)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pRxCfg)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPQueryRX(rtk_switch_port_L2P_get(port), (rtk_uint32 *)&(pRxCfg->rxQuery)))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicIGMPReportRX(rtk_switch_port_L2P_get(port), (rtk_uint32 *)&(pRxCfg->rxReport)))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicIGMPLeaveRX(rtk_switch_port_L2P_get(port), (rtk_uint32 *)&(pRxCfg->rxLeave)))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicIGMPMRPRX(rtk_switch_port_L2P_get(port), (rtk_uint32 *)&(pRxCfg->rxMRP)))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicIGMPMcDataRX(rtk_switch_port_L2P_get(port), (rtk_uint32 *)&(pRxCfg->rxMcast)))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the status of the IGMP multicast packets received from the port.

The table below defines the meaning of the status of the IGMP multicast packets received.


|Parameter|Description|
|---|---




NEXT




<s> static int b53_global_get_vlan_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct b53_device *priv = sw_to_b53(dev);

val->value.i = priv->enable_vlan;

return 0;
}

The above function is used to read whether VLAN is enabled on the device. If VLAN is enabled , the function returns the value 1 , otherwise it retuns the value 0 .</s>




NEXT




<s> ret_t rtl8367c_getAsicRldpCheckingStatePara(rtk_uint32 *pRetryCount, rtk_uint32 *pRetryPeriod)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_RLDP_RETRY_COUNT_REG, RTL8367C_RLDP_RETRY_COUNT_CHKSTATE_MASK, pRetryCount);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_getAsicReg(RTL8367C_RLDP_RETRY_PERIOD_CHKSTATE_REG, pRetryPeriod);
}

The above function is used to get the retry period and retry count value from ASIC reg.

The function uses the two ASIC register below.

RTL8367C_RLDP_RETRY_COUNT_CHKSTATE_REG






NEXT




<s> void ag71xx_debugfs_exit(struct ag71xx *ag)
{
debugfs_remove_recursive(ag->debug.debugfs_dir);
}

The above function is used to deregister debugfs files before rmmod. I have a similar code for my custom driver, which is almost identical, except for calling remove_tree instead of rm_recursive.
With some time, I think I should have realized




NEXT




<s> static inline void fe_get_rxd(struct fe_rx_dma *rxd, struct fe_rx_dma *dma_rxd)
{
rxd->rxd1 = dma_rxd->rxd1;
rxd->rxd2 = dma_rxd->rxd2;
rxd->rxd3 = dma_rxd->rxd3;
rxd->rxd4 = dma_rxd->rxd4;
}

The above function is used to get four descriptors from the device but
the following is what the DTS for the device driver:

&fe_r0 {

interrupt-cells = <0 0>;

interrupts = <IRQ_TYPE




NEXT




<s> static ssize_t rtl8366_read_debugfs_vlan_mc(struct file *file,
char __user *user_buf,
size_t count, loff_t *ppos)
{
struct rtl8366_smi *smi = (struct rtl8366_smi *)file->private_data;
int i, len = 0;
char *buf = smi->buf;

len += snprintf(buf + len, sizeof(smi->buf) - len,
"%2s %6s %4s %6s %6s %3s\n",
"id", "vid","prio", "member", "untag", "fid");

for (i = 0; i < smi->num_vlan_mc; ++i) {
struct rtl8366_vlan_mc vlanmc;

smi->ops->get_vlan_mc(smi, i, &vlanmc);

len += snprintf(buf + len, sizeof(smi->buf) - len,
"%2d %6d %4d 0x%04x 0x%04x %3d\n",
i, vlanmc.vid, vlanmc.priority,
vlanmc.member, vlanmc.untag, vlanmc.fid);
}

return simple_read_from_buffer(user_buf, count, ppos, buf, len);
}

The above function is used to read debugfs entries which includes tagged and
untagged VLAN mappings.

A separate debugfs entry is required for each such VLAN mapping.</s>




NEXT




<s> static void mt7621_ecc_encoder_op(struct mt7621_nfc *nfc, bool enable)
{
mt7621_ecc_wait_idle(nfc, ECC_ENCIDLE);
ecc_write16(nfc, ECC_ENCCON, enable ? ENC_EN : 0);
}

The above function is used to enable/disable MT7621's ECC encoder.

It is part of the nfc->ecc_encoder_op function pointer, which is defined
on the mac80211_nfc structure




NEXT




<s> ret_t rtl8367c_getAsicRldpLoopedPortPair(rtk_uint32 port, rtk_uint32 *pLoopedPair)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
return rtl8367c_getAsicRegBits(RTL8367C_RLDP_LOOP_PORT_REG(port), RTL8367C_RLDP_LOOP_PORT_MASK(port), pLoopedPair);
else
return rtl8367c_getAsicRegBits(RTL8367C_REG_RLDP_LOOP_PORT_REG4 + ((port - 8) >> 1), RTL8367C_RLDP_LOOP_PORT_MASK(port), pLoopedPair);
}

The above function is used to get looped pair on switch port. It works on rtl8367.

Port: PortID (8367C_PortID_PortIDValue)

pLoopedPair: port looped pair (




NEXT




<s> static int get_mapping_block_index_v2(int block)
{
int start, end;

if (block >= bmtd.pool_lba)
return block;

if (!mapping_block_in_range(block, &start, &end))
return block;

return bmtd.bbt->bb_tbl[block];
}

The above function is used to get an mapping block index for the block in question. The new function should be similar to the old function.</s>




NEXT




<s> static bool randomize_choice_values(struct symbol *csym)
{
struct property *prop;
struct symbol *sym;
struct expr *e;
int cnt, def;

/*
* If choice is mod then we may have more items selected
* and if no then no-one.
* In both cases stop.
*/
if (csym->curr.tri != yes)
return false;

prop = sym_get_choice_prop(csym);

/* count entries in choice block */
cnt = 0;
expr_list_for_each_sym(prop->expr, e, sym)
cnt++;

/*
* find a random value and set it to yes,
* set the rest to no so we have only one set
*/
def = rand() % cnt;

cnt = 0;
expr_list_for_each_sym(prop->expr, e, sym) {
if (def == cnt++) {
sym->def[S_DEF_USER].tri = yes;
csym->def[S_DEF_USER].val = sym;
} else {
sym->def[S_DEF_USER].tri = no;
}
sym->flags |= SYMBOL_DEF_USER;
/* clear VALID to get value calculated */
sym->flags &= ~SYMBOL_VALID;
}
csym->flags |= SYMBOL_DEF_USER;
/* clear VALID to get value calculated */
csym->flags &= ~SYMBOL_VALID;

return true;
}

The above function is used to update a set of symbol values whenever there is a change to another symbol that is the parent of the symbol list. For example, consider Figure 2-20.

Figure 2-20

In this figure, sym1




NEXT




<s> ret_t rtl8367c_getAsicDebugInfo(rtk_uint32 port, rtk_uint32 *pDebugifo)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_DEBUG_INFO_REG(port), RTL8367C_DEBUG_INFO_MASK(port), pDebugifo);
}

The above function is used to get asic register value. From reference documents, we can find the location of the port debug information register. For port debug information register, we need to use the following macro instead of directly reading the register value.

(RTL83




NEXT




<s> static inline void tlwr1043nd_init(void) {}

The above function is used to initialize the TSADC. This function is
called as part of the BSP initialization code. The TSADC is reset and
configured for use. The power and timing register are set
so the system is not tied down by the




NEXT




<s> static int test_memory(u32 memory)
{
volatile u32 *read;
volatile u32 *write;
const u32 INIT_PATTERN = 0xAA55AA55;
const u32 INC_PATTERN = 0x01030507;
u32 pattern;
int check;
int i;

check = 0;
read = write = (volatile u32 *) memory;
pattern = INIT_PATTERN;
for (i = 0; i < DILIGENCE; i++) {
*write++ = pattern;
pattern += INC_PATTERN;
}
puts("testing\n");
pattern = INIT_PATTERN;
for (i = 0; i < DILIGENCE; i++) {
check += (pattern == *read++) ? 1 : 0;
pattern += INC_PATTERN;
}
return (check == DILIGENCE) ? 0 : -1;
}

The above function is used to check if random reads from a previously
initialized section of memory yield expected results. The code above
uses two pointers to iterate over sequential memory locations. Initially,
0xAA55AA55 is written to each location




NEXT




<s> void rtl838x_vlan_port_pvidmode_set(int port, enum pbvlan_type type, enum pbvlan_mode mode)
{
if (type == PBVLAN_TYPE_INNER)
sw_w32_mask(0x3, mode, RTL838X_VLAN_PORT_PB_VLAN + (port << 2));
else
sw_w32_mask(0x3 << 14, mode << 14, RTL838X_VLAN_PORT_PB_VLAN + (port << 2));
}

The above function is used to set port-based VLAN type(inner/outer). It sets the value at bit 0,1,2,3 of register RTL838X_VLAN_PORT_PB_VLAN[port].

I




NEXT




<s> static int mtk_bmt_debug_mark_good(void *data, u64 val)
{
bmtd.ops->unmap_block(val >> bmtd.blk_shift);

return 0;
}

The above function is used to mark the block as bad. However, due to an improper implementation, the block will only be unmapped, but not marked as bad. This is a critical error.

## How does it happen?

Let us inspect the above




NEXT




<s> static void rtl8367_shutdown(struct platform_device *pdev)
{
struct rtl8366_smi *smi = platform_get_drvdata(pdev);

if (smi)
rtl8367_reset_chip(smi);
}

The above function is used to handle shutdown process for RTl8367S MII PHY devices.

#if defined(CONFIG_PM) || defined(CONFIG_PM_RUNTIME)
extern void rtl8366b_




NEXT




<s> static int fit_image_get_data_position(const void *fit, int noffset,
int *data_position)
{
const fdt32_t *val;

val = fdt_getprop(fit, noffset, FIT_DATA_POSITION_PROP, NULL);
if (!val)
return -ENOENT;

*data_position = fdt32_to_cpu(*val);

return 0;
}

The above function is used to get the data position info from our device property.
The property is:
dt-spec:/ {
 compatible = “intel,sn-13xx-rk3036”;

#address-cells =




NEXT




<s> int rtl8366_sw_set_vlan_fid(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_vlan_4k vlan4k;
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
int err;

if (!smi->ops->is_vlan_valid(smi, val->port_vlan))
return -EINVAL;

if (val->value.i < 0 || val->value.i > attr->max)
return -EINVAL;

err = smi->ops->get_vlan_4k(smi, val->port_vlan, &vlan4k);
if (err)
return err;

return rtl8366_set_vlan(smi, val->port_vlan,
vlan4k.member,
vlan4k.untag,
val->value.i);
}

The above function is used to set the VLAN-to-FID association entries
of the switch device. The function first checks if the given VLAN ID is
valid for the device. If the VLAN is valid, then the code retrieves the
VLAN




NEXT




<s> void rtl9300_dump_debug(void)
{
u16 r = RTL930X_STAT_PRVTE_DROP_COUNTER0;

for (int i = 0; i < 10; i ++) {
pr_info("# %d %08x %08x %08x %08x %08x %08x %08x %08x\n", i * 8,
sw_r32(r), sw_r32(r + 4), sw_r32(r + 8), sw_r32(r + 12),
sw_r32(r + 16), sw_r32(r + 20), sw_r32(r + 24), sw_r32(r + 28));
r += 32;
}
pr_info("# %08x %08x %08x %08x %08x\n",
sw_r32(r), sw_r32(r + 4), sw_r32(r + 8), sw_r32(r + 12), sw_r32(r + 16));
rtl930x_print_matrix();
pr_info("RTL930X_L2_PORT_SABLK_CTRL: %08x, RTL930X_L2_PORT_DABLK_CTRL %08x\n",
sw_r32(RTL930X_L2_PORT_SABLK_CTRL), sw_r32(RTL930X_L2_PORT_DABLK_CTRL)

);
}

The above function is used to call debug_register macro for printing the content of LSB of each register in dmesg if the firmware does not provide the detailed error description. The function name and its callers are as shown below:

If the following statement is




NEXT




<s> static enum zyxel_bootconfig_image_status zyxel_bootconfig_image_status_parse(const char *status) {
struct zyxel_image_status* s;

for (s = image_status_codes; s->name; s++) {
if (!strcmp(status, s->name)) {
return s->code;
}
}

return __IMAGE_STATUS_EINVAL;
}

The above function is used to parse the bootloader image in the BOOT_CONFIG.bin.
The BOOT_CONFIG.bin file is used by the firmware to configure the default bootloader used,
the factory reset, and the image status.

In




NEXT




<s> void __exit lqdeu_fini_async_aes (void)
{
int i;

for (i = 0; i < ARRAY_SIZE(aes_drivers_alg); i++)
crypto_unregister_alg(&aes_drivers_alg[i].alg);

aes_queue->hw_status = AES_COMPLETED;

DEU_WAKEUP_EVENT(deu_dma_priv.deu_thread_wait, AES_ASYNC_EVENT,
deu_dma_priv.aes_event_flags);

kfree(aes_queue);

}

The above function is used to destroy the async_AES object. The
for loop unregisters all AES instances that were previously
registered.

There were some issues discovered on Lantiq platform and hence the driver
needed modification.

The




NEXT




<s> static void rtl930x_set_l3_egress_intf(int idx, struct rtl838x_l3_intf *intf)
{
u32 u, v;
/* Read L3_EGR_INTF table (4) via register RTL9300_TBL_1 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_1, 4);

/* The table has 2 registers */
u = (intf->vid & 0xfff) << 9;
u |= (intf->smac_idx & 0x3f) << 3;
u |= (intf->ip4_mtu_id & 0x7);

v = (intf->ip6_mtu_id & 0x7) << 28;
v |= (intf->ttl_scope & 0xff) << 20;
v |= (intf->hl_scope & 0xff) << 12;
v |= (intf->ip4_icmp_redirect & 0x7) << 9;
v |= (intf->ip6_icmp_redirect & 0x7)<< 6;
v |= (intf->ip4_pbr_icmp_redirect & 0x7) << 3;
v |= (intf->ip6_pbr_icmp_redirect & 0x7);

sw_w32(u, rtl_table_data(r, 0));
sw_w32(v, rtl_table_data(r, 1));

pr_info("%s writing to index %d: %08x %08x\n", __func__, idx, u, v);
rtl_table_write(r, idx & 0x7f);
rtl_table_release(r);
}

The above function is used to write L3 EGR configuration with a given MAC
address, the function assumes there is no more than one interface, and it can be
used to write to a fixed or a range of indexes. If more than one interface, then





NEXT




<s> void AT91F_CfgDevice(void)
{
// Init Device Structure

MCI_Device_Features.Relative_Card_Address 		= 0;
MCI_Device_Features.Card_Inserted 				= AT91C_CARD_REMOVED;
MCI_Device_Features.Max_Read_DataBlock_Length	= 0;
MCI_Device_Features.Max_Write_DataBlock_Length 	= 0;
MCI_Device_Features.Read_Partial 				= 0;
MCI_Device_Features.Write_Partial 				= 0;
MCI_Device_Features.Erase_Block_Enable 			= 0;
MCI_Device_Features.Sector_Size 				= 0;
MCI_Device_Features.Memory_Capacity 			= 0;

MCI_Device_Desc.state							= AT91C_MCI_IDLE;
MCI_Device_Desc.SDCard_bus_width				= AT91C_MCI_SCDBUS;

// Init AT91S_DataFlash Global Structure, by default AT45DB choosen !!!
MCI_Device.pMCI_DeviceDesc 		= &MCI_Device_Desc;
MCI_Device.pMCI_DeviceFeatures 	= &MCI_Device_Features;

}

The above function is used to initialize the MCI card and it's features. I don't think this has any effect on the SDRAM controller other than allocating memory for the card handler (if used). That can't affect your performance.

I




NEXT




<s> struct symbol *sym_check_deps(struct symbol *sym)
{
struct symbol *sym2;
struct property *prop;

if (sym->flags & SYMBOL_CHECK) {
sym_check_print_recursive(sym);
return sym;
}
if (sym->flags & SYMBOL_CHECKED)
return NULL;

if (sym_is_choice_value(sym)) {
struct dep_stack stack;

/* for choice groups start the check with main choice symbol */
dep_stack_insert(&stack, sym);
prop = sym_get_choice_prop(sym);
sym2 = sym_check_deps(prop_get_symbol(prop));
dep_stack_remove();
} else if (sym_is_choice(sym)) {
sym2 = sym_check_choice_deps(sym);
} else {
sym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);
sym2 = sym_check_sym_deps(sym);
sym->flags &= ~SYMBOL_CHECK;
}

if (!recursive_is_error && sym2 && sym2 == sym)
sym2 = NULL;

return sym2;
}

The above function is used to check for dependencies for a symbol.
It is called during parsing, to catch potential errors. The idea
is that each type uses this mechanism to mark itself as
dependency. Then it is up to the symbol checker to propagate




NEXT




<s> static int rtl838x_poll_rx(struct napi_struct *napi, int budget)
{
struct rtl838x_rx_q *rx_q = container_of(napi, struct rtl838x_rx_q, napi);
struct rtl838x_eth_priv *priv = rx_q->priv;
int work_done = 0;
int r = rx_q->id;
int work;

while (work_done < budget) {
work = rtl838x_hw_receive(priv->netdev, r, budget - work_done);
if (!work)
break;
work_done += work;
}

if (work_done < budget) {
napi_complete_done(napi, work_done);

/* Enable RX interrupt */
if (priv->family_id == RTL9300_FAMILY_ID || priv->family_id == RTL9310_FAMILY_ID)
sw_w32(0xffffffff, priv->r->dma_if_intr_rx_done_msk);
else
sw_w32_mask(0, 0xf00ff | BIT(r + 8), priv->r->dma_if_intr_msk);
}

return work_done;
}

The above function is used to trigger RX interrupt.

However, there is a bug in Intel E7220 processor(which used by the motherboard that I made).

This bug has caused unexpected performance issues.

Dumping of assembl




NEXT




<s> static int mtdsplit_parse_lzma(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct lzma_header hdr;
size_t hdr_len, retlen;
size_t rootfs_offset;
u32 t;
struct mtd_partition *parts;
int err;

hdr_len = sizeof(hdr);
err = mtd_read(master, 0, hdr_len, &retlen, (void *) &hdr);
if (err)
return err;

if (retlen != hdr_len)
return -EIO;

/* verify LZMA properties */
if (hdr.props[0] >= (9 * 5 * 5))
return -EINVAL;

t = get_unaligned_le32(&hdr.props[1]);
if (!is_power_of_2(t))
return -EINVAL;

t = get_unaligned_le32(&hdr.size_high);
if (t)
return -EINVAL;

err = mtd_find_rootfs_from(master, master->erasesize, master->size,
&rootfs_offset, NULL);
if (err)
return err;

parts = kzalloc(LZMA_NR_PARTS * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = 0;
parts[0].size = rootfs_offset;

parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = master->size - rootfs_offset;

*pparts = parts;
return LZMA_NR_PARTS;
}

The above function is used to parse an LZMA2 encoded partition, and
it returns the number of partitions it contains. This function works for
both the MTD-AB and non-MTPD partitions because they are all using
the same data format




NEXT




<s> static int ar934x_nfc_ooblayout_free(struct mtd_info *mtd, int section,
struct mtd_oob_region *oobregion)
{
switch (section) {
case 0:
oobregion->offset = 4;
oobregion->length = 16;
return 0;
case 1:
oobregion->offset = 48;
oobregion->length = 16;
return 0;
default:
return -ERANGE;
}
}

The above function is used to initialize the offset and length values
in the structure mtd_oob_regiion. Its implementation is as follows.
case 0:
oobregion->offset = 4;
oobregion->length = 1




NEXT




<s> static void rtl931x_vlan_set_tagged(u32 vlan, struct rtl838x_vlan_info *info)
{
u32 v, w, x, y;
/* Access VLAN table (1) via register 0 */
struct table_reg *r = rtl_table_get(RTL9310_TBL_0, 3);

v = info->tagged_ports >> 25;
w = (info->tagged_ports & 0x1fffff) << 7;
w |= info->fid & 0x7f;
x = info->hash_uc_fid ? BIT(31) : 0;
x |= info->hash_mc_fid ? BIT(30) : 0;
x |= info->if_id & 0x3ff << 20;
x |= (info->profile_id & 0xf) << 16;
x |= info->multicast_grp_mask & 0xffff;
if (info->l2_tunnel_list_id >= 0) {
y = info->l2_tunnel_list_id << 18;
y |= BIT(31);
} else {
y = 0;
}

sw_w32(v, rtl_table_data(r, 0));
sw_w32(w, rtl_table_data(r, 1));
sw_w32(x, rtl_table_data(r, 2));
sw_w32(y, rtl_table_data(r, 3));

rtl_table_write(r, vlan);
rtl_table_release(r);
}

The above function is used to set or change the VLAN table parameters of the port.

(Referred from rtl931x_vlan_set() in drivers/net/838x/rtl931x_vlan.




NEXT




<s> static int b53_mmap_read64(struct b53_device *dev, u8 page, u8 reg, u64 *val)
{
u32 hi, lo;

if (WARN_ON(reg % 4))
return -EINVAL;

b53_mmap_read32(dev, page, reg, &lo);
b53_mmap_read32(dev, page, reg + 4, &hi);

*val = ((u64)hi << 32) | lo;

return 0;
}

The above function is used to read a 64 bit register. It does so by
combining two 32 bit values in software.

Now, for a single 64 bit reg is this the most optimal solution?

Btw: the code




NEXT




<s> static int rtl8380_read_status(struct phy_device *phydev)
{
int err;

err = genphy_read_status(phydev);

if (phydev->link) {
phydev->speed = SPEED_1000;
phydev->duplex = DUPLEX_FULL;
}

return err;
}

The above function is used to determine the Link status, where the Link can be up or down! In this tutorial we are assuming the Link is UP so we have to change the above function to check for Link Up first and then execute the below statements:

if (phy




NEXT




<s> static int b53_spi_read16(struct b53_device *dev, u8 page, u8 reg, u16 *val)
{
int ret = b53_spi_read(dev, page, reg, (u8 *)val, 2);

if (!ret)
*val = le16_to_cpu(*val);

return ret;
}

The above function is used to read two bytes from the B53, and
convert it to a single 16-bit unsigned int in host byte order.

The code is very simple and does not involve a lot of complex
operations, however it is very




NEXT




<s> static int rtl83xx_set_ageing_time(struct dsa_switch *ds, unsigned int msec)
{
struct rtl838x_switch_priv *priv = ds->priv;

priv->r->set_ageing_time(msec);

return 0;
}

The above function is used to set the MAC address aging time. The default
value of the value is 30 seconds. It should be changed before calling the
rtl83xx_init function, otherwise the default value will be used. It can be
changed




NEXT




<s> ar8xxx_sw_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
val->value.i = priv->vlan;
return 0;
}

The above function is used to set new VLAN priority used when bridging. However a read from the hardware VLAN register(0x117C) shows 0x1 being the priority value but the ar8216_read(1) function




NEXT




<s> void rtl930x_sds_rx_rst(int sds_num, phy_interface_t phy_if)
{
int page = 0x2e; /* 10GR and USXGMII */

if (phy_if == PHY_INTERFACE_MODE_1000BASEX)
page = 0x24;

rtl9300_sds_field_w(sds_num, page, 0x15, 4, 4, 0x1);
mdelay(5);
rtl9300_sds_field_w(sds_num, page, 0x15, 4, 4, 0x0);
}

The above function is used to clear the SDS receive state for a given PCIe link. The call is used during system startup to reset all SDSes prior to doing a configuration of the PCIe slot/port.</s>




NEXT




<s> static inline int clk_get(struct dc_ep_dev *dev, u32 *sysclk, u32 *ppeclk)
{
if (WARN_ON(!dev || !sysclk || !ppeclk))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_clk_get(dev->priv, sysclk, ppeclk);
}

The above function is used to retrieve both system clock and PPE clock rate.
This is the first interface of dc_ep_get.
For different driver, it might be different function, but they should define
all the related functions.

static struct dc_




NEXT




<s> void rtl838x_fdb_sync(struct work_struct *work)
{
const struct fdb_update_work *uw = container_of(work, struct fdb_update_work, work);

for (int i = 0; uw->macs[i]; i++) {
struct switchdev_notifier_fdb_info info;
u8 addr[ETH_ALEN];
int action;

action = (uw->macs[i] & (1ULL << 63)) ?
SWITCHDEV_FDB_ADD_TO_BRIDGE :
SWITCHDEV_FDB_DEL_TO_BRIDGE;
u64_to_ether_addr(uw->macs[i] & 0xffffffffffffULL, addr);
info.addr = &addr[0];
info.vid = 0;
info.offloaded = 1;
pr_debug("FDB entry %d: %llx, action %d\n", i, uw->macs[0], action);
call_switchdev_notifiers(action, uw->ndev, &info.info, NULL);
}
kfree(work);
}

The above function is used to add/delete an entry in the bridging FDB of
the switch (the MAC of the bridge port itself cannot be used). It is
called from the NAPI interrupt handler when it recognizes an Ethernet
frame coming from




NEXT




<s> ar8327_wait_atu_ready(struct ar8xxx_priv *priv, u16 r2, u16 r1)
{
int timeout = 20;

while (ar8xxx_mii_read32(priv, r2, r1) & AR8327_ATU_FUNC_BUSY && --timeout) {
udelay(10);
cond_resched();
}

if (!timeout)
pr_err("ar8327: timeout waiting for atu to become ready\n");
}

The above function is used to wait for ATU (AR8328 ATU) to become ready. ATU is ready when its function is idle. After the ATU is done with some function, it sets the bus_busy bit. This bit is cleared




NEXT




<s> rtk_api_ret_t rtk_qos_1pPriRemap_get(rtk_pri_t dot1p_pri, rtk_pri_t *pInt_pri)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (dot1p_pri > RTL8367C_PRIMAX)
return  RT_ERR_QOS_INT_PRIORITY;

if ((retVal = rtl8367c_getAsicPriorityDot1qRemapping(dot1p_pri, pInt_pri)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read the default dot1p 1p-2p-3p remapping to internal priority.

The following functions are used to set the internal priority to dot1p 1p-2p-3p mapping.
These




NEXT




<s> ret_t rtl8367c_getAsic1xProcConfig(rtk_uint32 port, rtk_uint32* pProc)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(port < 8)
return rtl8367c_getAsicRegBits(RTL8367C_DOT1X_UNAUTH_ACT_BASE, RTL8367C_DOT1X_UNAUTH_ACT_MASK(port),pProc);
else
return rtl8367c_getAsicRegBits(RTL8367C_REG_DOT1X_UNAUTH_ACT_W1, RTL8367C_DOT1X_UNAUTH_ACT_MASK(port),pProc);
}

The above function is used to configure ASA for RX, which is used when the switch has been configured as a root bridge. To do this, the switch needs to know whether to accept an IGMP report that has more of its own MAC addresses on it than not




NEXT




<s> static void ddr_phy_poll_until_locked(void)
{
volatile UINT reg_tmp = 0;
volatile UINT locked = 0;

//Extra read to put in delay before starting to poll...
reg_tmp = *(volatile UINT *) C_DDR_REG_PHY2;      // read

//POLL C_DDR_PHY2_REG register until clock and flock
//!!! Ideally have a timeout on this.
while (locked == 0) {
reg_tmp = *(volatile UINT *) C_DDR_REG_PHY2;      // read

//locked when bits 30 and 31 are set
if (reg_tmp & 0xC0000000) {
locked = 1;
}
}
}

The above function is used to wait for the DDR2 PHY to be programmed and locked.  I am polling in a loop at 3.5MHz (one poll per micro-second).  The DDR2 PHY takes 96 micro




NEXT




<s> bool sym_string_within_range(struct symbol *sym, const char *str)
{
struct property *prop;
long long val;

switch (sym->type) {
case S_STRING:
return sym_string_valid(sym, str);
case S_INT:
if (!sym_string_valid(sym, str))
return false;
prop = sym_get_range_prop(sym);
if (!prop)
return true;
val = strtoll(str, NULL, 10);
return val >= sym_get_range_val(prop->expr->left.sym, 10) &&
val <= sym_get_range_val(prop->expr->right.sym, 10);
case S_HEX:
if (!sym_string_valid(sym, str))
return false;
prop = sym_get_range_prop(sym);
if (!prop)
return true;
val = strtoll(str, NULL, 16);
return val >= sym_get_range_val(prop->expr->left.sym, 16) &&
val <= sym_get_range_val(prop->expr->right.sym, 16);
case S_BOOLEAN:
case S_TRISTATE:
switch (str[0]) {
case 'y': case 'Y':
return sym_tristate_within_range(sym, yes);
case 'm': case 'M':
return sym_tristate_within_range(sym, mod);
case 'n': case 'N':
return sym_tristate_within_range(sym, no);
}
return false;
default:
return false;
}
}

The above function is used to ensure that for range checking, the given symbol
"str" is within the specified range. This is done through a switch case
statement that assesses the type of the symbol. In this case, there are four
possible types: string,




NEXT




<s> rtk_api_ret_t rtk_vlan_portIgrFilterEnable_get(rtk_port_t port, rtk_enable_t *pIgr_filter)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pIgr_filter)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicVlanIngressFilter(rtk_switch_port_L2P_get(port), pIgr_filter)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the value whether IGMP filter enable or not.

#endif/* VLan_H*/</s>




NEXT




<s> static u64 rtl931x_read_cam(int idx, struct rtl838x_l2_entry *e)
{
return 0;
}

The above function is used to get a new entry into a hash table (in
case the entries array is full).

The corresponding code in the original rtl838x driver in
rtl935x_read_cam() is much longer,




NEXT




<s> static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to
push the  OAM messages to interface.
#endif

int ifx_oam_initialize(int if_index);

/*
*  Internal Functions
*/

static int set_oam_data




NEXT




<s> static void danube_shutdown(void)
{
}

The above function is used to destroy all allocated memory resources (like buffers and connections).

Here are some sample code calling the function danube_shutdown:

// include your needed header files here.

/*
 * This is a sample program demonstrating shut




NEXT




<s> BigIntegerModExp(S, res, b, n);
slen = BigIntegerToBytes(S, sbuf);

BigIntegerFree(S);
BigIntegerFree(res);
BigIntegerFree(b);
BigIntegerFree(n);

t_sessionkey(ts->session_key, sbuf, slen);
memset(sbuf, 0, slen);

SHA1Update(&ts->oldhash, ts->session_key, sizeof(ts->session_key));
SHA1Update(&ts->oldckhash, ts->session_key, sizeof(ts->session_key));
SHA1Update(&ts->ckhash, ts->session_key, sizeof(ts->session_key));

return ts->session_key;
}

_TYPE( int )
t_serververify(ts, resp)
struct t_server * ts;
unsigned char * resp;
{

The above function is used to confirm that the client key was computed correctly by the server.  This function validates the client’s key and then generates and confirms the session key.  If any errors occur, a negative error number is returned and the user must abort




NEXT




<s> ar8327_get_port_init_status(struct ar8327_port_cfg *cfg)
{
u32 t;

if (!cfg->force_link)
return AR8216_PORT_STATUS_LINK_AUTO;

t = AR8216_PORT_STATUS_TXMAC | AR8216_PORT_STATUS_RXMAC;
t |= cfg->duplex ? AR8216_PORT_STATUS_DUPLEX : 0;
t |= cfg->rxpause ? AR8216_PORT_STATUS_RXFLOW : 0;
t |= cfg->txpause ? AR8216_PORT_STATUS_TXFLOW : 0;

switch (cfg->speed) {
case AR8327_PORT_SPEED_10:
t |= AR8216_PORT_SPEED_10M;
break;
case AR8327_PORT_SPEED_100:
t |= AR8216_PORT_SPEED_100M;
break;
case AR8327_PORT_SPEED_1000:
t |= AR8216_PORT_SPEED_1000M;
break;
}

return t;
}

The above function is used to query a port’s link status, duplex, speed, autonegotiation status etc. It’s a wrapper of ar8216_get_port_init_status(), so the following explanation mainly focusses on




NEXT




<s> static inline void fe_int_enable(u32 mask)
{
fe_reg_w32(fe_reg_r32(FE_REG_FE_INT_ENABLE) | mask,
FE_REG_FE_INT_ENABLE);
/* flush write */
fe_reg_r32(FE_REG_FE_INT_ENABLE);
}

The above function is used to enable interrupt for fe2401 chip. There
are two issues (at least) with this function.

The first issue is about the order of write.
The function is written to first write the interrupt register
(FE_




NEXT




<s> static int oxnas_pcie_link_up(struct oxnas_pcie *pcie)
{
unsigned long end;
unsigned int val;

/* Poll for PCIE link up */
end = jiffies + (LINK_UP_TIMEOUT_SECONDS * HZ);
while (!time_after(jiffies, end)) {
regmap_read(pcie->sys_ctrl, pcie->pcie_ctrl_offset, &val);
if (val & PCIE_LINK_UP)
return 1;
}
return 0;
}

The above function is used to detect PCIe link up situation by reading the
PCIE interrupt status register. In the first poll operation, bitfield 21
indicates the PCIe link up condition but this may not be present if the
link up status is changing




NEXT




<s> static int ar934x_nfc_wait_dma_ready(struct ar934x_nfc *nfc)
{
unsigned long timeout;

timeout = jiffies + msecs_to_jiffies(AR934X_NFC_DMA_READY_TIMEOUT);
do {
if (__ar934x_nfc_is_dma_ready(nfc))
return 0;
} while time_before(jiffies, timeout);

nfc_dbg(nfc, "timeout waiting for DMA ready, dma_ctrl:%08x\n",
ar934x_nfc_rr(nfc, AR934X_NFC_REG_DMA_CTRL));
return -ETIMEDOUT;
}

The above function is used to poll the DMA engine ready bit by reading the dma_ctrl register in the hardware. Because of the use of polling, this function blocks and slows down the system. A better solution would be to have an interrupt triggered when the read operation




NEXT




<s> srg_led_set_pulse(struct led_classdev *led_cdev,
unsigned long *delay_on,
unsigned long *delay_off)
{
struct srg_led *sysled = container_of(led_cdev, struct srg_led, led);
struct srg_led_ctrl *sysled_ctrl = sysled->ctrl;
bool blinking = false, pulsing = false;
u8 cbyte;
int ret;

if (delay_on && delay_off && (*delay_on > 100) && (*delay_on <= 500)) {
pulsing = true;
*delay_on = 500;
*delay_off = 500;
} else if (delay_on && delay_off && (*delay_on >= 50) && (*delay_on <= 100)) {
blinking = true;
*delay_on = 50;
*delay_off = 50;
}

cbyte = pulsing ? 3 : blinking ? 2 : 0;
mutex_lock(&sysled_ctrl->lock);
ret = srg_led_i2c_write(sysled_ctrl, sysled->index + 4,
(blinking || pulsing) ? 255 : 0);
if (!ret) {
sysled_ctrl->control[sysled->index] = cbyte;
ret = srg_led_control_sync(sysled_ctrl);
}
mutex_unlock(&sysled_ctrl->lock);

return !cbyte;
}

The above function is used to set the pulse mode for the LED. It is a part of the
struct led_classdev *led_cdev,
unsigned long *delay_on,
unsigned long *delay_off)

{
struct srg_




NEXT




<s> rtk_uint32 rtk_switch_ComboPort_get(void)
{
return halCtrl->combo_logical_port;
}

The above function is used to get the combo port, which is either logical or physical port, in rtl8651. However, I want to get the logical port of other RTK devices as well. In 81xx family and RTK chip family




NEXT




<s> void msg(const char *fmt, ...)
{
va_list ap;
va_start(ap, fmt);

if (run_daemon)
vsyslog(LOG_INFO | LOG_USER, fmt, ap);
else
vfprintf(stderr, fmt, ap);

va_end(ap);
}

The above function is used to output debugging or infomation.</s>




NEXT




<s> static int do_info(nvram_handle_t *nvram)
{
nvram_header_t *hdr = nvram_header(nvram);

/* CRC8 over the last 11 bytes of the header and data bytes */
uint8_t crc = hndcrc8((unsigned char *) &hdr[0] + NVRAM_CRC_START_POSITION,
hdr->len - NVRAM_CRC_START_POSITION, 0xff);

/* Show info */
printf("Magic:         0x%08X\n",   hdr->magic);
printf("Length:        0x%08X\n",   hdr->len);
printf("Offset:        0x%08X\n",   nvram->offset);

printf("CRC8:          0x%02X (calculated: 0x%02X)\n",
hdr->crc_ver_init & 0xFF, crc);

printf("Version:       0x%02X\n",   (hdr->crc_ver_init >> 8) & 0xFF);
printf("SDRAM init:    0x%04X\n",   (hdr->crc_ver_init >> 16) & 0xFFFF);
printf("SDRAM config:  0x%04X\n",   hdr->config_refresh & 0xFFFF);
printf("SDRAM refresh: 0x%04X\n",   (hdr->config_refresh >> 16) & 0xFFFF);
printf("NCDL values:   0x%08X\n\n", hdr->config_ncdl);

printf("%i bytes used / %i bytes available (%.2f%%)\n",
hdr->len, nvram->length - nvram->offset - hdr->len,
(100.00 / (double)(nvram->length - nvram->offset)) * (double)hdr->len);

return 0;
}

The above function is used to display NVRAM data.  We need to include
nvram.h, which contains the structure definitions:

    typedef  union  {
        struct
        {
/* Version-specific fields */
uint32_t




NEXT




<s> t_fshash(out)
unsigned char * out;
{
char dotpath[128];
struct stat st;
SHA1_CTX ctxt;
int i, pinode;
dev_t pdev;

SHA1Init(&ctxt);
if(stat(".", &st) >= 0) {
SHA1Update(&ctxt, (unsigned char *) &st, sizeof(st));
pinode = st.st_ino;
pdev = st.st_dev;
strcpy(dotpath, "..");
for(i = 0; i < 40; ++i) {
if(stat(dotpath, &st) < 0)
break;
if(st.st_ino == pinode && st.st_dev == pdev)
break;
SHA1Update(&ctxt, (unsigned char *) &st, sizeof(st));
pinode = st.st_ino;
pdev = st.st_dev;
strcat(dotpath, "/..");
}
}

if(fstat(0, &st) >= 0)
SHA1Update(&ctxt, (unsigned char *) &st, sizeof(st));

sprintf(dotpath, "/tmp/rnd.%d", getpid());
if(creat(dotpath, 0600) >= 0 && stat(dotpath, &st) >= 0)
SHA1Update(&ctxt, (unsigned char *) &st, sizeof(st));
unlink(dotpath);

SHA1Final(out, &ctxt);
}

The above function is used to have a stable hash even if the system is not fully functional, like the NFS mounts not being mounted (i.e there is no /proc filesystem for instance)

And to ensure that no files get linked to .rnd




NEXT




<s> static DSL_int_t ubus_main(DSL_CPE_Thread_Params_t *params) {
uloop_run();
return 0;
}

The above function is used to illustrate the main function prototype of DSL_main_function. The DSL_main_function prototype requires that the user specifies a thread_params.thread_stacksize which is used to define the size of the stack when using D




NEXT




<s> static void fe_get_strings(struct net_device *dev, u32 stringset, u8 *data)
{
switch (stringset) {
case ETH_SS_STATS:
ethtool_puts(&data, *fe_gdma_str);
break;
}
}

The above function is used to retrieve device statistics.

The get_strings function is defined in driver/net/ethernet/aleph/88E111.c
file.  The get_strings function is a wrapper for fe_get_strings




NEXT




<s> static void plla_configure(int outdiv, int refdiv, int fbdiv, int bwadj,
int sfreq, int sslope)
{
setbits_le32(SYS_CTRL_PLLA_CTRL0, PLL_BYPASS);
udelay(10);
reset_block(SYS_CTRL_RST_PLLA, 1);
udelay(10);

writel((refdiv << PLL_REFDIV_SHIFT) | (outdiv << PLL_OUTDIV_SHIFT) |
SAT_ENABLE | PLL_BYPASS,
SYS_CTRL_PLLA_CTRL0);

writel(fbdiv, SYS_CTRL_PLLA_CTRL1);
writel((bwadj << PLL_BWADJ_SHIFT) | sfreq, SYS_CTRL_PLLA_CTRL2);
writel(sslope, SYS_CTRL_PLLA_CTRL3);

udelay(10); // 5us delay required (from TCI datasheet), use 10us

reset_block(SYS_CTRL_RST_PLLA, 0);

udelay(100); // Delay for PLL to lock

printf("  plla_ctrl0 : %08x\n", readl(SYS_CTRL_PLLA_CTRL0));
printf("  plla_ctrl1 : %08x\n", readl(SYS_CTRL_PLLA_CTRL1));
printf("  plla_ctrl2 : %08x\n", readl(SYS_CTRL_PLLA_CTRL2));
printf("  plla_ctrl3 : %08x\n", readl(SYS_CTRL_PLLA_CTRL3));

clrbits_le32(SYS_CTRL_PLLA_CTRL0, PLL_BYPASS); // Take PLL out of bypass
puts("\nPLLA Set\n");
}

The above function is used to configure the PLL for a specific configuration. The PLL configuration is the same as the A-TCI device, that is 396 Mhz with an FB divider of 2.

Not all the functions below




NEXT




<s> ret_t rtl8367c_getAsicRldpLoopStatePara(rtk_uint32 *pRetryCount, rtk_uint32 *pRetryPeriod)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_RLDP_RETRY_COUNT_REG, RTL8367C_RLDP_RETRY_COUNT_LOOPSTATE_MASK, pRetryCount);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_getAsicReg(RTL8367C_RLDP_RETRY_PERIOD_LOOPSTATE_REG, pRetryPeriod);
}

The above function is used to retrieve the retry count of ASIC RLDP loop state when an error occurs. RLDP is not enabled on RTL8367C in the RTL8367C reference design. It may be used to debug issues




NEXT




<s> static void line_feature_config(int fd, DSL_AccessDir_t direction, bool *retx) {
IOCTL_DIR(DSL_LineFeature_t, DSL_FIO_LINE_FEATURE_STATUS_GET, direction)

m_bool("trellis", out.data.bTrellisEnable);
m_bool("bitswap", out.data.bBitswapEnable);
m_bool("retx", out.data.bReTxEnable);
m_bool("virtual_noise", out.data.bVirtualNoiseSupport);

*retx = out.data.bReTxEnable;
}

The above function is used to read out the status of several line feature parameters of the device to the parameter variables defined above. To set up these parameters, refer to the function "line_feature_config_set()" mentioned afterwards. An example is shown in Listing 




NEXT




<s> static void fe_txd_unmap(struct device *dev, struct fe_tx_buf *tx_buf)
{
if (dma_unmap_len(tx_buf, dma_len0))
dma_unmap_page(dev,
dma_unmap_addr(tx_buf, dma_addr0),
dma_unmap_len(tx_buf, dma_len0),
DMA_TO_DEVICE);

if (dma_unmap_len(tx_buf, dma_len1))
dma_unmap_page(dev,
dma_unmap_addr(tx_buf, dma_addr1),
dma_unmap_len(tx_buf, dma_len1),
DMA_TO_DEVICE);

dma_unmap_len_set(tx_buf, dma_addr0, 0);
dma_unmap_len_set(tx_buf, dma_addr1, 0);
if (tx_buf->skb && (tx_buf->skb != (struct sk_buff *)DMA_DUMMY_DESC))
dev_kfree_skb_any(tx_buf->skb);
tx_buf->skb = NULL;
}

The above function is used to unmap descriptors and buffer pages to which
the DMA descriptors pointed. If these descriptors contain valid data then
it will unmap the buffer pages; however, if the descriptors contain
indirection tables then this function will ignore them




NEXT




<s> static int mtk_bmt_debug_repair(void *data, u64 val)
{
int block = val >> bmtd.blk_shift;
int prev_block, new_block;

prev_block = bmtd.ops->get_mapping_block(block);
if (prev_block < 0)
return -EIO;

bmtd.ops->unmap_block(block);
new_block = bmtd.ops->get_mapping_block(block);
if (new_block < 0)
return -EIO;

if (prev_block == new_block)
return 0;

bbt_nand_erase(new_block);
bbt_nand_copy(new_block, prev_block, bmtd.blk_size);

return 0;
}

The above function is used to repair block maps.</s>




NEXT




<s> rtk_api_ret_t rtk_switch_initialState_set(init_state_t state)
{
if(state >= INIT_STATE_END)
return RT_ERR_FAILED;

init_state = state;
return RT_ERR_OK;
}

The above function is used to change the initial state.
However, it is only for demonstration and does not need to be changed in use after the program is completed.</s>




NEXT




<s> int rtl8390_sds_power(int mac, int val)
{
u32 offset = (mac == 48) ? 0x0 : 0x100;
u32 mode = val ? 0 : 1;

pr_debug("In %s: mac %d, set %d\n", __func__, mac, val);

if ((mac != 48) && (mac != 49)) {
pr_err("%s: not an SFP port: %d\n", __func__, mac);
return -1;
}

/* Set bit 1003. 1000 starts at 7c */
sw_w32_mask(BIT(11), mode << 11, RTL839X_SDS12_13_PWR0 + offset);

return 0;
}

The above function is used to read and write the power management for the sfp. The function above can be called by the software to enable or disable the power management.</s>




NEXT




<s> static void dc_aca_clk_on(struct dc_ep_priv *priv)
{
dc_ep_clk_on(priv, PMU_ADMA);
}

The above function is used to turn the ACA DC clock ON from DC PMU and register the request in PMU for power gating. It also saves an

enable bit. So if the clock is already on, it does nothing. The same goes for DC_




NEXT




<s> rtk_api_ret_t rtk_l2_aging_get(rtk_l2_age_time_t *pAging_time)
{
rtk_api_ret_t retVal;
rtk_uint32 i,time, speed;
CONST_T rtk_uint32 agePara[10][3] = {
{45, 0, 1}, {88, 0, 2}, {133, 0, 3}, {177, 0, 4}, {221, 0, 5}, {266, 0, 6}, {310, 0, 7},
{354, 2, 6}, {413, 2, 7}, {458, 3, 7}};

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pAging_time)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLutAgeTimerSpeed(&time, &speed)) != RT_ERR_OK)
return retVal;

for (i = 0; i<10; i++)
{
if (time==agePara[i][2]&&speed==agePara[i][1])
{
*pAging_time = agePara[i][0];
return RT_ERR_OK;
}
}

return RT_ERR_FAILED;
}

The above function is used to obtain the speed and time of aging. As mentioned above, the aging time can be divided into different speeds, so as to make it adapt to different situations. Each aging stage for different speeds and different time, the aging time of the maximum value can




NEXT




<s> ret_t rtl8367c_getAsicOamMultiplexer(rtk_uint32 port, rtk_uint32* pMultiplexer)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_REG_OAM_MULTIPLEXER_CTRL0 + port/8, RTL8367C_OAM_MULTIPLEXER_MASK(port%8), pMultiplexer);
}

The above function is used to retrieve the multiplexed type for VLAN ID = 27 and the result is VLAN_NONE. Is it correct?

If I use an external switch to enable Spanning-Tree, then enable Asic Oam Multip




NEXT




<s> static int button_get_index(unsigned int code)
{
int i;

for (i = 0; i < ARRAY_SIZE(button_map); i++)
if (button_map[i].code == code)
return i;

return -1;
}

The above function is used to find the mapping of the button between kernel and user space.</s>




NEXT




<s> static void dc_ep_ppe_mbox_reg_dump(struct dc_ep_dev *dev)
{
pr_info("MBOX_IGU0_ISRS addr %p data 0x%08x\n",
dev->membase + MBOX_IGU0_ISRS,
ep_rd32(MBOX_IGU0_ISRS));
pr_info("MBOX_IGU0_ISRC addr %p data 0x%08x\n",
dev->membase + MBOX_IGU0_ISRC,
ep_rd32(MBOX_IGU0_ISRC));
pr_info("MBOX_IGU0_ISR  addr %p data 0x%08x\n",
dev->membase + MBOX_IGU0_ISR,
ep_rd32(MBOX_IGU0_ISR));
pr_info("MBOX_IGU0_IER  addr %p data 0x%08x\n",
dev->membase + MBOX_IGU0_IER,
ep_rd32(MBOX_IGU0_IER));
}

The above function is used to dump registers in mbox.

Dump registers of IGU0 of MBOX
For the ep_dev, we have three methods in dc_ep_ppe_mbox_reg_dump(),
ep_rd32() ,




NEXT




<s> static void rtl838x_enable_learning(int port, bool enable)
{
/* Limit learning to maximum: 16k entries */

sw_w32_mask(0x3fff << 2, enable ? (0x3fff << 2) : 0,
RTL838X_L2_PORT_LRN_CONSTRT + (port << 2));
}

The above function is used to enable or disable the learning in RTL838x port mac. In this article we are discussing three different ways to check the return value of rtl838x_enable_learning function at runtime to make sure it does what it




NEXT




<s> static inline struct hostapd_data *get_hapd_from_object(struct ubus_object *obj)
{
return container_of(obj, struct hostapd_data, ubus.obj);
}

The above function is used to get a pointer to the struct hostapd_data data structure, when one only has access to the associated structure that is used as an ubus object.

There's a similar problem with struct hapd_data.






NEXT




<s> ret_t rtl8367c_setAsicEavSysTimeCtrl(rtk_uint32 control)
{
ret_t  retVal;
rtk_uint32 regData;

if (control>=PTP_TIME_CTRL_END)
return RT_ERR_INPUT;

regData = 0;
if (PTP_TIME_CTRL_START == control)
regData = RTL8367C_CFG_TIMER_EN_FRC_MASK | RTL8367C_CFG_TIMER_1588_EN_MASK;
else
regData = 0;

if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_CFG, regData)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the PTP time configuration.

When the switch is up and running, if the control of PTP time is used as PTP time enabled (for the setting “PTP Time Control” is assigned as PTP_TIME_CTRL




NEXT




<s> mtk_bmt_get_mapping_mask(void)
{
struct bbmt *bbmt = bmt_tbl(bmtd.bbt);
int main_blocks = bmtd.mtd->size >> bmtd.blk_shift;
unsigned long *used;
int i, k;

used = kcalloc(sizeof(unsigned long), BIT_WORD(bmtd.bmt_blk_idx) + 1, GFP_KERNEL);
if (!used)
return NULL;

for (i = 1; i < main_blocks; i++) {
if (bmtd.bbt->bb_tbl[i] == i)
continue;

for (k = 0; k < bmtd.bmt_blk_idx; k++) {
if (bmtd.bbt->bb_tbl[i] != bbmt[k].block)
continue;

set_bit(k, used);
break;
}
}

return used;
}

The above function is used to return the used block mapping table which is used to create mapping mask and it will return NULL if there exist any error. In order to get this, we create a pointer "used" through kcalloc function which returns pointer to a zeroed out




NEXT




<s> int dc_aca_start(struct dc_ep_priv *priv, u32 func, int start)
{
if (!func)
return -EINVAL;

wr32_mask(0, func, GNRC_EN_TASK_BITMAP);

/* Only do if requested by caller */
if (start) {
wr32(0x1, GNRC_START_OP); /* Any write will trigger */
rd32(GNRC_START_OP);
if (!aca_hif_param_init_check(priv))
return -EIO;
}
return 0;
}

The above function is used to start the ACA task. We note
that it is not used at all anywhere except as a debug function
for the time being. We may eventually use it to start ACA.
DC_ACA_TASK_ID used for




NEXT




<s> ret_t rtl8367c_setAsicRemarkingDscpParameter(rtk_uint32 priority, rtk_uint32 newDscp )
{
if(priority > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

if(newDscp > RTL8367C_DSCPMAX)
return RT_ERR_QOS_DSCP_VALUE;

return rtl8367c_setAsicRegBits(RTL8367C_QOS_DSCP_REMARK_REG(priority), RTL8367C_QOS_DSCP_REMARK_MASK(priority), newDscp);
}

The above function is used to set DSCP value for specified priority (the mapping
between DSCP and priority can be found by get_remarkPriority() function).</s>




NEXT




<s> int fit_partition(struct parsed_partitions *state) {
int slot = 0;
return parse_fit_partitions(state, 0, 0, &slot, 0);
}

The above function is used to determine the fit partition size when we are using a single large partition where a single file resides. The below code is how a single large partition with a single file is specified in grub2 config.

partition 2 --part-type




NEXT




<s> static void aca_mem_clear(struct dc_ep_priv *priv)
{
struct aca_fw_dl_addr *fw_dl = to_fw_addr(priv);

memset_io(priv->mem + fw_dl->fw_addr[0].fw_load_addr,
0, ACA_ACC_FW_SIZE);
memset_io(priv->mem + ACA_SRAM_BASE, 0, ACA_SRAM_SIZE);
}

The above function is used to init ACP's memory by filling it with 0's by default, so that when a module is reloaded, it doesn't inherit the state from a previous load.</s>




NEXT




<s> static int bcm4908img_info(int argc, char **argv) {
struct bcm4908img_info info;
const char *pathname = NULL;
FILE *fp;
int c;
int err = 0;

while ((c = getopt(argc, argv, "i:")) != -1) {
switch (c) {
case 'i':
pathname = optarg;
break;
}
}

fp = bcm4908img_open(pathname, "r");
if (!fp) {
fprintf(stderr, "Failed to open BCM4908 image\n");
err = -EACCES;
goto out;
}

err = bcm4908img_parse(fp, &info);
if (err) {
fprintf(stderr, "Failed to parse BCM4908 image\n");
goto err_close;
}

if (info.bootfs_offset != info.cferom_offset)
printf("cferom offset:\t%zu\n", info.cferom_offset);
printf("bootfs offset:\t0x%zx\n", info.bootfs_offset);
if (info.padding_offset)
printf("padding offset:\t0x%zx\n", info.padding_offset);
printf("rootfs offset:\t0x%zx\n", info.rootfs_offset);
printf("Checksum:\t0x%08x\n", info.crc32);

err_close:
bcm4908img_close(fp);
out:
return err;
}

The above function is used to query the offsets and checksums of an
installable BCM4908 image. The CLI syntax should be self-explanatory. It
reads the input image from standard input and uses the bcm49




NEXT




<s> static inline void ar934x_nfc_enable_hwecc(struct ar934x_nfc *nfc)
{
nfc->ctrl_reg |= AR934X_NFC_CTRL_ECC_EN;
nfc->ctrl_reg &= ~AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
}

The above function is used to enable HWECC. This will work correctly if the device supports HWECC.

However there are devices which do not support HWECC but are still
claimed by ar934x_nfc_search() and as a




NEXT




<s> static DSL_DEV_MeiError_t IFX_MEI_RunAdslModem (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_CpuModeSet (DSL_DEV_Device_t *, DSL_DEV_CpuMode_t);
static DSL_DEV_MeiError_t IFX_MEI_DownloadBootCode (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_ArcJtagEnable (DSL_DEV_Device_t *, int);
static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to report the tx link rates.

void *mei_adsl_txl_report;
EXPORT_SYMBOL(mei_adsl_txl_report);

void IFX_MeiTxLinkReportC




NEXT




<s> ead_encrypt_message(struct ead_msg *msg, unsigned int len)
{
struct ead_msg_encrypted *enc = EAD_DATA(msg, enc);
unsigned char *data = (unsigned char *) enc;
uint32_t hash[5];
int enclen, i;

len += sizeof(struct ead_msg_encrypted);
enc->pad = (EAD_ENC_PAD - (len % EAD_ENC_PAD)) % EAD_ENC_PAD;
enclen = len + enc->pad;
msg->len = htonl(enclen);
enc->iv = htonl(ead_get_tx_iv());

ead_hash_message(enc, hash, enclen);
for (i = 0; i < 5; i++)
enc->hash[i] = htonl(hash[i]);
DEBUG(2, "SHA1 generate (0x%08x), len=%d\n", enc->hash[0], enclen);

while (enclen > 0) {
rijndaelEncrypt(aes_enc_ctx, data, data);
data += 16;
enclen -= 16;
}
}

The above function is used to encrypt a message.  The aes_enc_ctx is created
using the the key from the ead_setup_key() routine where the key is the encrypt key
from the EAPOLKey packet.
This function




NEXT




<s> static inline int rtl930x_l2_port_new_sa_fwd(int p)
{
/* TODO: The definition of the fields changed, because of the master-cpu in a stack */
return RTL930X_L2_PORT_NEW_SA_FWD(p);
}

The above function is used to set the new SAs forwarded.  However, when port numbers increase,
the size of the l2 table is increased and the bits for the fields that control FDB actions (new FDB
actions, etc) may become 0




NEXT




<s> static void sym_calc_visibility(struct symbol *sym)
{
struct property *prop;
struct symbol *choice_sym = NULL;
tristate tri;

/* any prompt visible? */
tri = no;

if (sym_is_choice_value(sym))
choice_sym = prop_get_symbol(sym_get_choice_prop(sym));

for_all_prompts(sym, prop) {
prop->visible.tri = expr_calc_value(prop->visible.expr);
/*
* Tristate choice_values with visibility 'mod' are
* not visible if the corresponding choice's value is
* 'yes'.
*/
if (choice_sym && sym->type == S_TRISTATE &&
prop->visible.tri == mod && choice_sym->curr.tri == yes)
prop->visible.tri = no;

tri = EXPR_OR(tri, prop->visible.tri);
}
if (tri == mod && (sym->type != S_TRISTATE || modules_val == no))
tri = yes;
if (sym->visible != tri) {
sym->visible = tri;
sym_set_changed(sym);
}
if (sym_is_choice_value(sym))
return;
/* defaulting to "yes" if no explicit "depends on" are given */
tri = yes;
if (sym->dir_dep.expr)
tri = expr_calc_value(sym->dir_dep.expr);
if (tri == mod && sym_get_type(sym) == S_BOOLEAN)
tri = yes;
if (sym->dir_dep.tri != tri) {
sym->dir_dep.tri = tri;
sym_set_changed(sym);
}
tri = no;
if (sym->rev_dep.expr)
tri = expr_calc_value(sym->rev_dep.expr);
if (tri == mod && sym_get_type(sym) == S_BOOLEAN)
tri = yes;
if (sym->rev_dep.tri != tri) {
sym->rev_dep.tri = tri;
sym_set_changed(sym);
}
tri = no;
if (sym->implied.expr)
tri = expr_calc_value(sym->implied.expr);
if (tri == mod && sym_get_type(sym) == S_BOOLEAN)
tri = yes;
if (sym->implied.tri != tri) {
sym->implied.tri = tri;
sym_set_changed(sym);
}
}

The above function is used to update the visibility of symbols.

In case sym_get_type(sym) is S_TRISTATE, we need to set the visibility of
choice_values based on the value of the corresponding choice. This is done
in




NEXT




<s> static inline void init_pmu(void);
static inline void uninit_pmu(void);
static inline void reset_ppe(struct platform_device *pdev);
static inline void init_pdma(void);
static inline void init_mailbox(void);
static inline void init_atm_tc(void);
static inline void clear_share_buffer(void);

#define IFX_PMU_MODULE_PPE_SLL01  BIT(19)
#define IFX_PMU_MODULE_PPE_TC     BIT(21)
#define IFX_PMU_MODULE_PPE_EMA    BIT(22)
#define IFX_PMU_MODULE_PPE_QSB    BIT(18)
#define IFX_PMU_MODULE_AHBS       BIT(13)
#define IFX_PMU_MODULE_DSL_DFE    BIT(9)


static inline void init_pmu(void)
{
ltq_pmu_enable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_AHBS |
IFX_PMU_MODULE_DSL_DFE);

}

The above function is used to initialize (enable) the specified module in
Pmu registers. There are three modules which are used when
LTE is enabled. Please refer [DFE_Tuning] section to
calibrate the power consumption of the DFE block




NEXT




<s> static ssize_t rtc_write(UNUSED struct file *filp, const char *buf,
size_t count, loff_t *ppos)
{
struct rtc_time rtc_tm;
char buffer[23];
char *p;

if (!capable(CAP_SYS_TIME))
return -EACCES;

if (ppos != &filp->f_pos)
return -ESPIPE;

/*
* For simplicity, the only acceptable format is:
* YYYY:MM:DD:W:HH:MM:SS\n
*/

if (count != 22)
goto err_out;

if (copy_from_user(buffer, buf, count))
return -EFAULT;

buffer[sizeof(buffer)-1] = '\0';

p = &buffer[0];

rtc_tm.tm_year  = simple_strtoul(p, &p, 10);
if (*p++ != ':') goto err_out;

rtc_tm.tm_mon = simple_strtoul(p, &p, 10) - 1;
if (*p++ != ':') goto err_out;

rtc_tm.tm_mday = simple_strtoul(p, &p, 10);
if (*p++ != ':') goto err_out;

rtc_tm.tm_wday = simple_strtoul(p, &p, 10);
if (*p++ != ':') goto err_out;

rtc_tm.tm_hour = simple_strtoul(p, &p, 10);
if (*p++ != ':') goto err_out;

rtc_tm.tm_min = simple_strtoul(p, &p, 10);
if (*p++ != ':') goto err_out;

rtc_tm.tm_sec = simple_strtoul(p, &p, 10);
if (*p != '\n') goto err_out;

rtc_tm.tm_year -= RTC_EPOCH;

set_rtc_time(&rtc_tm);

*ppos += count;

return count;

err_out:
printk(KERN_ERR "invalid format: use YYYY:MM:DD:W:HH:MM:SS\\n\n");
return -EINVAL;
}

The above function is used to set the current time of RTC.

static ssize_t rtc_read(UNUSED struct file *filp, char *buf,size_t count,
loff_t *ppos)
{
struct r




NEXT




<s> ret_t rtl8367c_setAsicIGMPMRPRX(rtk_uint32 port, rtk_uint32 allow_mrp)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
{
/* Allow Multicast Routing Protocol */
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MRP_MASK, allow_mrp);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MRP_MASK, allow_mrp);
if(retVal != RT_ERR_OK)
return retVal;
}
return RT_ERR_OK;
}

The above function is used to set allow multicast protocol on ports.  We will give some details on how to use this function to support 2 IGMP snooping protocols in future.</s>




NEXT




<s> ret_t rtl8367c_getAsicLutFlushVid(rtk_uint32* pVid)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL1, RTL8367C_LUT_FLUSH_VID_MASK, pVid);
}

The above function is used to get the vid asicLutFlushMask.
The vid asicLutFlushMask corresponds to the following reg bit.

L2_FLUSH_VID = {VID_ASIC_LUT_FLUSH};




NEXT




<s> void rtl930x_vlan_profile_dump(int profile)
{
u32 p[5];

if (profile < 0 || profile > 7)
return;

p[0] = sw_r32(RTL930X_VLAN_PROFILE_SET(profile));
p[1] = sw_r32(RTL930X_VLAN_PROFILE_SET(profile) + 4);
p[2] = sw_r32(RTL930X_VLAN_PROFILE_SET(profile) + 8) & 0x1FFFFFFF;
p[3] = sw_r32(RTL930X_VLAN_PROFILE_SET(profile) + 12) & 0x1FFFFFFF;
p[4] = sw_r32(RTL930X_VLAN_PROFILE_SET(profile) + 16) & 0x1FFFFFFF;

pr_info("VLAN %d: L2 learn: %d; Unknown MC PMasks: L2 %0x, IPv4 %0x, IPv6: %0x",
profile, p[0] & (3 << 21), p[2], p[3], p[4]);
pr_info("  Routing enabled: IPv4 UC %c, IPv6 UC %c, IPv4 MC %c, IPv6 MC %c\n",
p[0] & BIT(17) ? 'y' : 'n', p[0] & BIT(16) ? 'y' : 'n',
p[0] & BIT(13) ? 'y' : 'n', p[0] & BIT(12) ? 'y' : 'n');
pr_info("  Bridge enabled: IPv4 MC %c, IPv6 MC %c,\n",
p[0] & BIT(15) ? 'y' : 'n', p[0] & BIT(14) ? 'y' : 'n');
pr_info("VLAN profile %d: raw %08x %08x %08x %08x %08x\n",
profile, p[0], p[1], p[2], p[3], p[4]);
}

The above function is used to debug VLAN settings in the RTL930x.

In a VLAN-enabled system, there are two VLAN tables. They are

1 0x12400000 0x1




NEXT




<s> static void rtl83xx_phylink_mac_link_up(struct dsa_switch *ds, int port,
unsigned int mode,
phy_interface_t interface,
struct phy_device *phydev,
int speed, int duplex,
bool tx_pause, bool rx_pause)
{
struct rtl838x_switch_priv *priv = ds->priv;
/* Restart TX/RX to port */
sw_w32_mask(0, 0x3, priv->r->mac_port_ctrl(port));
/* TODO: Set speed/duplex/pauses */
}

The above function is used to inform the driver that host is going to start
communication and link up with physical port/device. By doing this, the
PHY device is reset and MAC controller is released from the previous MAC
transaction and it is allowed to respond to the




NEXT




<s> get_random_bytes(void *ptr, int len)
{
int fd;

fd = open("/dev/urandom", O_RDONLY);
if (fd < 0) {
perror("open");
exit(1);
}
read(fd, ptr, len);
close(fd);
}

The above function is used to get random bytes from the /dev/urandom device on the Linux system. This function creates a file descriptor (fd) to the device, reads the number of bytes specified by the len parameter starting from the ptr parameter and closes the file descriptor




NEXT




<s> int spi_xfer(const struct spi_transfer *msg, int n)
{
return espi_xfer(&spi, msg, n);
}

The above function is used to exchange data with the board through SPI which is a part of the kernel programming in LK which is not that hard to understand, just keep in mind that msg is the destination of this function which is an array of spi_transfer structs from




NEXT




<s> static int rtl8367b_get_vlan_4k(struct rtl8366_smi *smi, u32 vid,
struct rtl8366_vlan_4k *vlan4k)
{
u32 data[RTL8367B_TA_VLAN_NUM_WORDS];
int err;
int i;

memset(vlan4k, '\0', sizeof(struct rtl8366_vlan_4k));

if (vid >= RTL8367B_NUM_VIDS)
return -EINVAL;

/* write VID */
REG_WR(smi, RTL8367B_TA_ADDR_REG, vid);

/* write table access control word */
REG_WR(smi, RTL8367B_TA_CTRL_REG, RTL8367B_TA_CTRL_CVLAN_READ);

for (i = 0; i < ARRAY_SIZE(data); i++)
REG_RD(smi, RTL8367B_TA_RDDATA_REG(i), &data[i]);

vlan4k->vid = vid;
vlan4k->member = (data[0] >> RTL8367B_TA_VLAN0_MEMBER_SHIFT) &
RTL8367B_TA_VLAN0_MEMBER_MASK;
vlan4k->untag = (data[0] >> RTL8367B_TA_VLAN0_UNTAG_SHIFT) &
RTL8367B_TA_VLAN0_UNTAG_MASK;
vlan4k->fid = (data[1] >> RTL8367B_TA_VLAN1_FID_SHIFT) &
RTL8367B_TA_VLAN1_FID_MASK;

return 0;
}

The above function is used to determine whether or not this particular VID
is a valid C-VLAN or T-VLAN for a 4K VLAN table.  The TA registers are
used to determine whether this VID is valid, and if so




NEXT




<s> void rtl931x_sds_fiber_disable(u32 sds)
{
u32 v = 0x3F;
u32 asds = rtl931x_get_analog_sds(sds);

rtl9310_sds_field_w(asds, 0x1F, 0x9, 11, 6, v);
}

The above function is used to toggle fiber in the switch port and is an important one:

- Fiber disable (6:6.5ms)
- Fiber enable (3.5:11.5ms)

Without this function, users will




NEXT




<s> static int ip175d_update_state(struct ip17xx_state *state);
static int ip175d_set_vlan_mode(struct ip17xx_state *state);
static int ip175d_reset(struct ip17xx_state *state);

static const struct register_mappings IP175D = {
.NAME = "IP175D",
.MODEL_NO = 0x18,

// The IP175D has a completely different interface, so we leave most
// of the registers undefined and switch to different code paths.

.VLAN_DEFAULT_TAG_REG = {
NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,
NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,
},

.ADD_TAG_REG = NOTSUPPORTED,
.REMOVE_TAG_REG = NOTSUPPORTED,

.SIMPLE_VLAN_REGISTERS = 0,

.VLAN_LOOKUP_REG = NOTSUPPORTED,
.VLAN_LOOKUP_REG_5 = NOTSUPPORTED,
.TAG_VLAN_MASK_REG = NOTSUPPORTED,

.RESET_VAL = 0x175D,
.RESET_REG = {20,2},
.MODE_REG = NOTSUPPORTED,

.ROUTER_CONTROL_REG = NOTSUPPORTED,
.ROUTER_EN_BIT = -1,
.NUMLAN_GROUPS_BIT = -1,

.VLAN_CONTROL_REG = NOTSUPPORTED,
.TAG_VLAN_BIT = -1,

.NUM_PORTS = 6,
.CPU_PORT = 5,

.MII_REGISTER_EN = NOTSUPPORTED,

.update_state = ip175d_update_state,
.set_vlan_mode = ip175d_set_vlan_mode,
.reset = ip175d_reset,
};

The above function is used to setup/check the network controller on your system
// The IP4500D has a completely different interface as well, but I don’t have one
// to evaluate at the moment. The rest is undefined.

static const




NEXT




<s> static void rtl930x_fill_l2_entry(u32 r[], struct rtl838x_l2_entry *e)
{
pr_debug("In %s valid?\n", __func__);
e->valid = !!(r[2] & BIT(31));
if (!e->valid)
return;

pr_debug("In %s is valid\n", __func__);
e->is_ip_mc = false;
e->is_ipv6_mc = false;

/* TODO: Is there not a function to copy directly MAC memory? */
e->mac[0] = (r[0] >> 24);
e->mac[1] = (r[0] >> 16);
e->mac[2] = (r[0] >> 8);
e->mac[3] = r[0];
e->mac[4] = (r[1] >> 24);
e->mac[5] = (r[1] >> 16);

e->next_hop = !!(r[2] & BIT(12));
e->rvid = r[1] & 0xfff;

/* Is it a unicast entry? check multicast bit */
if (!(e->mac[0] & 1)) {
e->type = L2_UNICAST;
e->is_static = !!(r[2] & BIT(14));
e->port = (r[2] >> 20) & 0x3ff;
/* Check for trunk port */
if (r[2] & BIT(30)) {
e->is_trunk = true;
e->stack_dev = (e->port >> 9) & 1;
e->trunk = e->port & 0x3f;
} else {
e->is_trunk = false;
e->stack_dev = (e->port >> 6) & 0xf;
e->port = e->port & 0x3f;
}

e->block_da = !!(r[2] & BIT(15));
e->block_sa = !!(r[2] & BIT(16));
e->suspended = !!(r[2] & BIT(13));
e->age = (r[2] >> 17) & 3;
e->valid = true;
/* the UC_VID field in hardware is used for the VID or for the route id */
if (e->next_hop) {
e->nh_route_id = r[2] & 0x7ff;
e->vid = 0;
} else {
e->vid = r[2] & 0xfff;
e->nh_route_id = 0;
}
} else {
e->valid = true;
e->type = L2_MULTICAST;
e->mc_portmask_index = (r[2] >> 16) & 0x3ff;
}
}

The above function is used to fill the L2_Entry from the entry returned from the MAC MIBs.

The below function is called to set the HW VID in case of unicast ARPs/NAs.


static bool set_




NEXT




<s> uc_bpf_map_iter_next(uc_vm_t *vm, size_t nargs)
{
struct uc_bpf_map_iter *iter = uc_fn_thisval("bpf.map_iter");
uc_value_t *rv;

if (!iter->has_next)
return NULL;

rv = ucv_string_new_length((const char *)iter->key, iter->key_size);
iter->has_next = !bpf_map_get_next_key(iter->fd, &iter->key, &iter->key);

return rv;
}

The above function is used to generate the code for the BPF `map_iter()` function’s next call with arguments. Here is the implementation of `map_iter()`.

    uc_vm_t *vm;
    val = bpf




NEXT




<s> static ssize_t jimage_verify_default(u_char *buf, size_t len)
{
struct jimage_header *header = (struct jimage_header *)buf;

/* default sanity checks */
if (header->stag_magic != STAG_MAGIC) {
pr_debug("invalid jImage stag header magic: %04x\n",
header->stag_magic);
return -EINVAL;
}
if (header->sch2_magic != SCH2_MAGIC) {
pr_debug("invalid jImage sch2 header magic: %04x\n",
header->stag_magic);
return -EINVAL;
}
if (header->stag_cmark != header->stag_id) {
pr_debug("invalid jImage stag header cmark: %02x\n",
header->stag_magic);
return -EINVAL;
}
if (header->stag_id != STAG_ID) {
pr_debug("invalid jImage stag header id: %02x\n",
header->stag_magic);
return -EINVAL;
}
if (header->sch2_version != SCH2_VER) {
pr_debug("invalid jImage sch2 header version: %02x\n",
header->stag_magic);
return -EINVAL;
}

return 0;
}

The above function is used to do the simple sanity checks on the validity of the
jimage and return either success or error. This function may be extended to
support more validation steps.

The only two things that verify does is checking the magic number and the




NEXT




<s> static int rtl8226_write_page(struct phy_device *phydev, int page)
{
return __phy_write(phydev, RTL8XXX_PAGE_SELECT, page);
}

The above function is used to perform I2C write operations to PHY where PHY has multiple registers/registers per page.
And RTL8XXX_PAGE_SELECT is constant.

According to the code, we need to perform page select operation




NEXT




<s> static int aw9523_gpio_irq_type(struct irq_data *d, unsigned int type)
{
switch (type) {
case IRQ_TYPE_NONE:
case IRQ_TYPE_EDGE_BOTH:
return 0;
default:
return -EINVAL;
};
}

The above function is used to restrict the interrupt type based on what
AW9523 supports.

Change-Id: I4818cb34e942bfeef4484a0da5796595




NEXT




<s> rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_del(rtk_port_t port, rtk_vlan_proto_type_t proto_type, rtk_vlan_protoVlan_frameType_t frame_type)
{
rtk_api_ret_t retVal;
rtk_uint32 i, bUsed;
rtk_uint32 ppb_idx;
rtl8367c_protocolgdatacfg ppb_data_cfg;
rtl8367c_protocolvlancfg ppb_vlan_cfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (proto_type > RTK_MAX_NUM_OF_PROTO_TYPE)
return RT_ERR_OUT_OF_RANGE;

if (frame_type >= FRAME_TYPE_END)
return RT_ERR_OUT_OF_RANGE;

ppb_idx = 0;

for (i = 0; i<= RTL8367C_PROTOVLAN_GIDX_MAX; i++)
{
if ((retVal = rtl8367c_getAsicVlanProtocolBasedGroupData(i, &ppb_data_cfg)) != RT_ERR_OK)
return retVal;

if ( (ppb_data_cfg.frameType == (rtl8367c_provlan_frametype)frame_type) && (ppb_data_cfg.etherType == proto_type) )
{
ppb_idx = i;
ppb_vlan_cfg.valid = FALSE;
ppb_vlan_cfg.vlan_idx = 0;
ppb_vlan_cfg.priority = 0;
if ((retVal = rtl8367c_setAsicVlanPortAndProtocolBased(rtk_switch_port_L2P_get(port), ppb_idx, &ppb_vlan_cfg)) != RT_ERR_OK)
return retVal;
}
}

bUsed = FALSE;
RTK_SCAN_ALL_PHY_PORTMASK(i)
{
if ((retVal = rtl8367c_getAsicVlanPortAndProtocolBased(i, ppb_idx, &ppb_vlan_cfg)) != RT_ERR_OK)
return retVal;

if (TRUE == ppb_vlan_cfg.valid)
{
bUsed = TRUE;
break;
}
}

if (FALSE == bUsed) /*No Port use this PPB Index, Delete it*/
{
ppb_data_cfg.etherType=0;
ppb_data_cfg.frameType=0;
if ((retVal = rtl8367c_setAsicVlanProtocolBasedGroupData(ppb_idx, &ppb_data_cfg)) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to delete the PPBvlan entries that are created based on specified frame type and protocol type. The below figure is example.
In the above scenario, the PPbVlan entry will be created on port3 for frame type = 0 and




NEXT




<s> static void rtl83xx_net_event_work_do(struct work_struct *work)
{
struct net_event_work *net_work =
container_of(work, struct net_event_work, work);
struct rtl838x_switch_priv *priv = net_work->priv;

rtl83xx_l3_nexthop_update(priv, net_work->gw_addr, net_work->mac);

kfree(net_work);
}

The above function is used to process update a neighbour table
entry when a new neighbour is added. The function is called via a
workqueue in the rtl838x_set_ip_addr function.

The workqueue is not stopped when the driver




NEXT




<s> ret_t rtl8367c_getAsicPriorityToQIDMappingTable(rtk_uint32 index, rtk_uint32 priority, rtk_uint32* pQid)
{
if(index >= RTL8367C_QUEUENO)
return RT_ERR_QUEUE_NUM;

if(priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_getAsicRegBits(RTL8367C_QOS_1Q_PRIORITY_TO_QID_REG(index, priority), RTL8367C_QOS_1Q_PRIORITY_TO_QID_MASK(priority), pQid);
}

The above function is used to read AQM config table from ASIC. The return value will be the QID in the given Priority.
The function signature is defined in include\rtk_qos.h

The below function is defined in include\




NEXT




<s> void wl_glue_set_remove_callback(wl_glue_remove_cb_t cb)
{
remove_cb = cb;
}

The above function is used to implement a generic wl_global callback mechanism: wl_global_add_remove_listener(wl_display_t *display, wl_global_instance_t *instance, wl_glue_remove_cb_




NEXT




<s> static int bcm6348_cb_read(struct pci_bus *bus, unsigned int devfn,
int where, int size, u32 *val)
{
struct bcm6348_pci *priv = &bcm6348_pci;
struct bcm6348_cb *cb = &priv->cb;

/* Snoop access to slot 0x1e on root bus, we fake a cardbus
* bridge at this location */
if (!bus->parent && PCI_SLOT(devfn) == FAKE_CB_BRIDGE_SLOT) {
priv->cb_bus = bus->number;
return bcm6348_cb_bridge_read(where, size, val);
}

/* A configuration cycle for the device behind the cardbus
* bridge is actually done as a type 0 cycle on the primary
* bus. This means that only one device can be on the cardbus
* bus */
if (cb->bus_assigned &&
bus->number == cb->cardbus_busn &&
PCI_SLOT(devfn) == 0)
return bcm6348_do_cfg_read(0, 0,
PCI_DEVFN(CARDBUS_PCI_IDSEL, 0),
where, size, val);

return PCIBIOS_DEVICE_NOT_FOUND;
}

The above function is used to do the fake CB bus access, and the code
for this is commented above..

Below is the code I modified, and is the one I'm stuck on..(not
quite sure if its the function called PCIBI




NEXT




<s> ret_t rtl8367c_setAsicLutFlushAll(void)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_L2_FLUSH_CTRL3, RTL8367C_L2_FLUSH_CTRL3_OFFSET, 1);
}

The above function is used to configure the L2 flush all when the MAC table change occurs, as if this function not used, the host could not notice the MAC table changes if it occurs infrequently, which may cause some MAC table inconsistency problem in L2 F




NEXT




<s> void rtl930x_set_distribution_algorithm(int group, int algoidx, u32 algomsk)
{
u32 l3shift = 0;
u32 newmask = 0;

/* TODO: for now we set algoidx to 0 */
algoidx = 0;
if (algomsk & TRUNK_DISTRIBUTION_ALGO_SIP_BIT) {
l3shift = 4;
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_SIP_BIT;
}
if (algomsk & TRUNK_DISTRIBUTION_ALGO_DIP_BIT) {
l3shift = 4;
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_DIP_BIT;
}
if (algomsk & TRUNK_DISTRIBUTION_ALGO_SRC_L4PORT_BIT) {
l3shift = 4;
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_SRC_L4PORT_BIT;
}
if (algomsk & TRUNK_DISTRIBUTION_ALGO_SRC_L4PORT_BIT) {
l3shift = 4;
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_SRC_L4PORT_BIT;
}

if (l3shift == 4) {
if (algomsk & TRUNK_DISTRIBUTION_ALGO_SMAC_BIT)
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_SMAC_BIT;

if (algomsk & TRUNK_DISTRIBUTION_ALGO_DMAC_BIT)
newmask |= TRUNK_DISTRIBUTION_ALGO_L3_DMAC_BIT;
} else  {
if (algomsk & TRUNK_DISTRIBUTION_ALGO_SMAC_BIT)
newmask |= TRUNK_DISTRIBUTION_ALGO_L2_SMAC_BIT;
if (algomsk & TRUNK_DISTRIBUTION_ALGO_DMAC_BIT)
newmask |= TRUNK_DISTRIBUTION_ALGO_L2_DMAC_BIT;
}

sw_w32(newmask << l3shift, RTL930X_TRK_HASH_CTRL + (algoidx << 2));
}

The above function is used to assign the algorithm to a given trunk group. As far as I know it’s used in following cases:

1. It is called in module init function. For most of the chips, it initializes the distribution algorithms for first trunk group




NEXT




<s> rtk_api_ret_t rtk_mirror_isolationLeaky_set(rtk_enable_t txenable, rtk_enable_t rxenable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((txenable >= RTK_ENABLE_END) ||(rxenable >= RTK_ENABLE_END))
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicPortMirrorIsolationTxLeaky(txenable)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicPortMirrorIsolationRxLeaky(rxenable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the mirror isolation, but it is too inconvenient.
This function is equivalent to the following four functions:
```c
rtk_enable_t txenable = 1;
rtk_enable_t rxenable




NEXT




<s> Byte LzmaLiteralDecode(CProb *probs, CRangeDecoder *rd)
{
int symbol = 1;
#ifdef _LZMA_LOC_OPT
RC_INIT_VAR
#endif
do
{
#ifdef _LZMA_LOC_OPT
CProb *prob = probs + symbol;
RC_GET_BIT(prob, symbol)
#else
symbol = (symbol + symbol) | RangeDecoderBitDecode(probs + symbol, rd);
#endif
}
while (symbol < 0x100);
#ifdef _LZMA_LOC_OPT
RC_FLUSH_VAR
#endif
return symbol;
}

The above function is used to decode a literal of size 1-16 bits. The CLS
encoder is slightly different. It uses LzmaLiteralEncode() to encode literals.
The input to LzmaLiteralEncode() can be as long as 




NEXT




<s> ret_t rtl8367c_setAsicSvlanTrapPriority(rtk_uint32 priority)
{
if(priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_SVLAN_PRIOIRTY_MASK, priority);
}

The above function is used to set 802.1q subscriber vlan traps priority. To set the priority, we must use a value that will be mapped as one of the bits of the QOS_TRAP_PRIORITY0 register. We




NEXT




<s> adm6996_disable_vlan(struct adm6996_priv *priv)
{
u16 reg;
int i;

for (i = 0; i < ADM_NUM_VLANS; i++) {
reg = ADM_VLAN_FILT_MEMBER_MASK;
w16(priv, ADM_VLAN_FILT_L(i), reg);
reg = ADM_VLAN_FILT_VALID | ADM_VLAN_FILT_VID(1);
w16(priv, ADM_VLAN_FILT_H(i), reg);
}

reg = r16(priv, ADM_OTBE_P2_PVID);
reg |= ADM_OTBE_MASK;
w16(priv, ADM_OTBE_P2_PVID, reg);
reg = r16(priv, ADM_IFNTE);
reg |= ADM_IFNTE_MASK;
w16(priv, ADM_IFNTE, reg);
reg = r16(priv, ADM_VID_CHECK);
reg &= ~(ADM_VID_CHECK_MASK);
w16(priv, ADM_VID_CHECK, reg);
reg = r16(priv, ADM_SYSC0);
reg &= ~(ADM_NTTE);
reg |= ADM_RVID1;
w16(priv, ADM_SYSC0, reg);
reg = r16(priv, ADM_SYSC3);
reg &= ~(ADM_TBV);
w16(priv, ADM_SYSC3, reg);
}

The above function is used to enable VLAN (Virtual Local Area Network). What is VLAN? I guess many are not very familiar with it. If one goes to search about it in Google, you can probably find a number of related information on it. One of it is




NEXT




<s> ret_t rtl8367c_setAsicAcl(rtk_uint32 port, rtk_uint32 enabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_ACL_ENABLE_REG, port, enabled);
}

The above function is used to enable/disable ACL for a specific port after
ACL rules have been set.

#40;#44;#48;#52;#56;#60;#64;#6




NEXT




<s> static void msdc_drv_pm(struct platform_device *pdev, pm_message_t state)
{
struct mmc_host *mmc = platform_get_drvdata(pdev);
if (mmc) {
struct msdc_host *host = mmc_priv(mmc);
msdc_pm(state, (void *)host);
}
}

The above function is used to initialize the msdc for suspend and resume. This function calls msdc_pm.
#define msdc_pm(pm_message, h) \
do {\
if((h)->hstate != STATE_S




NEXT




<s> rtk_api_ret_t rtk_mirror_keep_set(rtk_mirror_keep_t mode)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (mode >= MIRROR_KEEP_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicPortMirrorRealKeep(mode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set mirror configuration on a real port. It is recommended for mirror on a real port use this function.
r_flood_get(uint32_t *mode);
rtk_switch_flood_t r




NEXT




<s> int rtl8366_sw_set_port_pvid(struct switch_dev *dev, int port, int val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
return rtl8366_set_pvid(smi, port, val);
}

The above function is used to set a port PVID in the RTL8366.  The port (and other state) information is passed as part of a sw_msg_sw_set_port_pvid(), which is also implemented on this device:




NEXT




<s> static enum ata_completion_errors sata_oxnas_qc_prep(struct ata_queued_cmd *qc)
{
struct sata_oxnas_port_priv *pd;
int port_no = qc->ap->port_no;

/* if the port's not connected, complete now with an error */
if (!sata_oxnas_check_link(qc->ap)) {
ata_port_err(qc->ap,
"port %d not connected completing with error\n",
port_no);
qc->err_mask |= AC_ERR_ATA_BUS;
ata_qc_complete(qc);
}

sata_oxnas_reset_ucode(qc->ap->host, 0, 0);

/* both pio and dma commands use dma */
if (ata_is_dma(qc->tf.protocol) || ata_is_pio(qc->tf.protocol)) {

/* program the scatterlist into the prd table */
ata_bmdma_qc_prep(qc);

/* point the sgdma controller at the dma request structure */
pd = qc->ap->private_data;

iowrite32(pd->sgdma_request_pa,
pd->sgdma_base + SGDMA_REQUESTPTR);

/* setup the request table */
if (port_no == 0) {
pd->sgdma_request->control =
(qc->dma_dir == DMA_FROM_DEVICE) ?
SGDMA_REQCTL0IN : SGDMA_REQCTL0OUT;
} else {
pd->sgdma_request->control =
(qc->dma_dir == DMA_FROM_DEVICE) ?
SGDMA_REQCTL1IN : SGDMA_REQCTL1OUT;
}
pd->sgdma_request->qualifier = SGDMA_REQQUAL;
pd->sgdma_request->src_pa = qc->ap->bmdma_prd_dma;
pd->sgdma_request->dst_pa = qc->ap->bmdma_prd_dma;
smp_wmb();

/* tell it to wait */
iowrite32(SGDMA_CONTROL_NOGO, pd->sgdma_base + SGDMA_CONTROL);
}

return AC_ERR_OK;
}

The above function is used to prepare a queue command for execution, which in our case should be done by writing one parameter to the device's DMA channel, that is the address of the DMA request structure holding all necessary information for the transfer to complete. It doesn't make




NEXT




<s> void	LED_blink(unsigned int led)
{
volatile int i,j;
for(i = 0; i < 5; i++) {
LED_set((1 << led)&0x7);
for(j= 0; j < 200000; j++);
LED_set(0);
for(j= 0; j < 200000; j++);
}
}

The above function is used to blink one LED at a time of an AVR's PORT. It's very simple and I used for many projects. The problem is that each time I used it, I wrote in my code:

                  for(j=




NEXT




<s> static void msdc_set_mclk(struct msdc_host *host, int ddr, unsigned int hz)
{
//struct msdc_hw *hw = host->hw;
void __iomem *base = host->base;
u32 mode;
u32 flags;
u32 div;
u32 sclk;
u32 hclk = host->hclk;
//u8  clksrc = hw->clk_src;

if (!hz) { // set mmc system clock to 0 ?
//ERR_MSG("set mclk to 0!!!");
msdc_reset_hw(host);
return;
}

msdc_irq_save(flags);

if (ddr) {
mode = 0x2; /* ddr mode and use divisor */
if (hz >= (hclk >> 2)) {
div  = 1;         /* mean div = 1/4 */
sclk = hclk >> 2; /* sclk = clk / 4 */
} else {
div  = (hclk + ((hz << 2) - 1)) / (hz << 2);
sclk = (hclk >> 2) / div;
}
} else if (hz >= hclk) { /* bug fix */
mode = 0x1; /* no divisor and divisor is ignored */
div  = 0;
sclk = hclk;
} else {
mode = 0x0; /* use divisor */
if (hz >= (hclk >> 1)) {
div  = 0;         /* mean div = 1/2 */
sclk = hclk >> 1; /* sclk = clk / 2 */
} else {
div  = (hclk + ((hz << 2) - 1)) / (hz << 2);
sclk = (hclk >> 2) / div;
}
}

/* set clock mode and divisor */
sdr_set_field(MSDC_CFG, MSDC_CFG_CKMOD, mode);
sdr_set_field(MSDC_CFG, MSDC_CFG_CKDIV, div);

/* wait clock stable */
while (!(sdr_read32(MSDC_CFG) & MSDC_CFG_CKSTB))
cpu_relax();

host->sclk = sclk;
host->mclk = hz;
msdc_set_timeout(host, host->timeout_ns, host->timeout_clks); // need?

INIT_MSG("================");
INIT_MSG("!!! Set<%dKHz> Source<%dKHz> -> sclk<%dKHz>", hz / 1000, hclk / 1000, sclk / 1000);
INIT_MSG("================");

msdc_irq_restore(flags);
}

The above function is used to set mmc system clock. This is used to set a low system clock and a high system clock for different memory card.
As msdc_msr_write_byte(m2 = 0xff) and msdc_




NEXT




<s> ret_t rtl8367c_getAsicUnknownL2MulticastBehavior(rtk_uint32 port, rtk_uint32 *pBehave)
{
ret_t retVal;

if(port >  RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_UNKNOWN_L2_MULTICAST_REG(port), RTL8367C_UNKNOWN_L2_MULTICAST_MASK(port), pBehave);
if (retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_UNKNOWN_L2_MULTICAST_CTRL1, 3 << ((port - 8) << 1), pBehave);
if (retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to get the behavior of unknown unicast packets in PHY port 8-15 to RTL8367C_PORT_MAX. The behavior is related to  the Asic register RTL8367C_REG




NEXT




<s> rtk_api_ret_t rtk_igmp_dynamicRouterPort_get(rtk_igmp_dynamicRouterPort_t *pDynamicRouterPort)
{
rtk_api_ret_t   retVal;
rtk_uint32 port;
rtk_uint32 timer;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pDynamicRouterPort)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPdynamicRouterPort1(&port, &timer))!= RT_ERR_OK)
return retVal;

if (port == RTL8367C_ROUTER_PORT_INVALID)
{
pDynamicRouterPort->dynamicRouterPort0Valid = DISABLED;
pDynamicRouterPort->dynamicRouterPort0      = 0;
pDynamicRouterPort->dynamicRouterPort0Timer = 0;
}
else
{
pDynamicRouterPort->dynamicRouterPort0Valid = ENABLED;
pDynamicRouterPort->dynamicRouterPort0      = rtk_switch_port_P2L_get(port);
pDynamicRouterPort->dynamicRouterPort0Timer = timer;
}

if ((retVal = rtl8367c_getAsicIGMPdynamicRouterPort2(&port, &timer))!= RT_ERR_OK)
return retVal;

if (port == RTL8367C_ROUTER_PORT_INVALID)
{
pDynamicRouterPort->dynamicRouterPort1Valid = DISABLED;
pDynamicRouterPort->dynamicRouterPort1      = 0;
pDynamicRouterPort->dynamicRouterPort1Timer = 0;
}
else
{
pDynamicRouterPort->dynamicRouterPort1Valid = ENABLED;
pDynamicRouterPort->dynamicRouterPort1      = rtk_switch_port_P2L_get(port);
pDynamicRouterPort->dynamicRouterPort1Timer = timer;
}

return RT_ERR_OK;
}

The above function is used to get the status of IGMP Static Router Port.

The following figure shows the flowchart of the rtk_igmp_dynamicRouterPort_get function.

## Get IGMP Static Router Port##




NEXT




<s> static void handle_f5(int *key, struct menu *current_item);
static void handle_f6(int *key, struct menu *current_item);
static void handle_f7(int *key, struct menu *current_item);
static void handle_f8(int *key, struct menu *current_item);
static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to process the following key combinations:

F5 - Resume
F6 - Debug Step
F7 - Break All
F8 - Toggle BreakPoint Watchpoint
F9 - Reload All

It does so by looking at




NEXT




<s> static int rtl8367b_extif_set_rgmii_delay(struct rtl8366_smi *smi, int id,
unsigned txdelay, unsigned rxdelay)
{
u32 mask;
u32 val;
int err;

mask = (RTL8367B_EXT_RGMXF_RXDELAY_MASK |
(RTL8367B_EXT_RGMXF_TXDELAY_MASK <<
RTL8367B_EXT_RGMXF_TXDELAY_SHIFT));

val = rxdelay;
val |= txdelay << RTL8367B_EXT_RGMXF_TXDELAY_SHIFT;

REG_RMW(smi, RTL8367B_EXT_RGMXF_REG(id), mask, val);

return 0;
}

The above function is used to program the 8367B chip for SGMIX_DELAY registers.  All of the chip sets in the RTL8380 family have similar registers (SGMIX_DELAY0, SGMIX




NEXT




<s> void rtl930x_fast_age(struct dsa_switch *ds, int port)
{
struct rtl838x_switch_priv *priv = ds->priv;

if (priv->family_id == RTL9310_FAMILY_ID)
return rtl931x_fast_age(ds, port);

pr_debug("FAST AGE port %d\n", port);
mutex_lock(&priv->reg_mutex);
sw_w32(port << 11, RTL930X_L2_TBL_FLUSH_CTRL + 4);

sw_w32(BIT(26) | BIT(30), RTL930X_L2_TBL_FLUSH_CTRL);

do { } while (sw_r32(priv->r->l2_tbl_flush_ctrl) & BIT(30));

mutex_unlock(&priv->reg_mutex);
}

The above function is used to flush a port’s MAC address entry from the switch
table. It’s called from the switch_port_age(ds, 1) function in switch.c. The
variable “priv” is defined as the “switch”




NEXT




<s> uc_value_t *wpa_ucode_registry_remove(uc_value_t *reg, int idx)
{
uc_value_t *val = wpa_ucode_registry_get(reg, idx);
void **dataptr;

if (!val)
return NULL;

ucv_array_set(reg, idx - 1, NULL);
dataptr = ucv_resource_dataptr(val, NULL);
if (dataptr)
*dataptr = NULL;

return val;
}

The above function is used to retrieve the value from register by providing index.</s>




NEXT




<s> static void fe_get_stats64(struct net_device *dev,
struct rtnl_link_stats64 *storage)
{
struct fe_priv *priv = netdev_priv(dev);
struct fe_hw_stats *hwstats = priv->hw_stats;
unsigned int base = fe_reg_table[FE_REG_FE_COUNTER_BASE];
unsigned int start;

if (!base) {
netdev_stats_to_stats64(storage, &dev->stats);
return;
}

if (netif_running(dev) && netif_device_present(dev)) {
if (spin_trylock_bh(&hwstats->stats_lock)) {
fe_stats_update(priv);
spin_unlock_bh(&hwstats->stats_lock);
}
}

do {
start = u64_stats_fetch_begin_irq(&hwstats->syncp);
storage->rx_packets = hwstats->rx_packets;
storage->tx_packets = hwstats->tx_packets;
storage->rx_bytes = hwstats->rx_bytes;
storage->tx_bytes = hwstats->tx_bytes;
storage->collisions = hwstats->tx_collisions;
storage->rx_length_errors = hwstats->rx_short_errors +
hwstats->rx_long_errors;
storage->rx_over_errors = hwstats->rx_overflow;
storage->rx_crc_errors = hwstats->rx_fcs_errors;
storage->rx_errors = hwstats->rx_checksum_errors;
storage->tx_aborted_errors = hwstats->tx_skip;
} while (u64_stats_fetch_retry_irq(&hwstats->syncp, start));

storage->tx_errors = priv->netdev->stats.tx_errors;
storage->rx_dropped = priv->netdev->stats.rx_dropped;
storage->tx_dropped = priv->netdev->stats.tx_dropped;
}

The above function is used to retrieve the latest statistics stored by NetDev.

Note that NetDev provides both 64 bit and
32 bit statistics storage in the Linux Networking layer. Depending on the
networking architecture, we can choose to use any




NEXT




<s> static int get_token(char **, char **, int *, int *);
static int get_number(char **, int *, int);
static inline void ignore_space(char **, int *);



/*
* ####################################
*            Local Variable
* ####################################
*/



/*
* ####################################
*            Local Function
* ####################################
*/

static inline void proc_file_create(void)
{
struct proc_dir_entry *res;

res = create_proc_entry("driver/ifx_ptm/mem",
0,
NULL);
if ( res != NULL )
res->write_proc = proc_write_mem;
else
printk("%s:%s:%d: failed to create proc mem!", __FILE__, __func__, __LINE__);

res = create_proc_entry("driver/ifx_ptm/pp32",
0,
NULL);
if ( res != NULL ) {
res->read_proc = proc_read_pp32;
res->write_proc = proc_write_pp32;
}
else
printk("%s:%s:%d: failed to create proc pp32!", __FILE__, __func__, __LINE__);
}

The above function is used to create a virtual file "/driver/ifx_ptm/mem",
which represents the PTM physical memory. The PTM physical memory is shared by
PTM, NM and PP32, thus it is available through the virtual




NEXT




<s> static void vector_erb(int fd) {
#ifdef INCLUDE_DSL_CPE_API_VRX
if (fd < 0)
return;

IOCTL(IOCTL_MEI_dsmStatistics_t, FIO_MEI_DSM_STATISTICS_GET);

m_u32("sent", out.n_processed);
m_u32("discarded", out.n_fw_dropped_size + out.n_mei_dropped_size + out.n_mei_dropped_no_pp_cb + out.n_pp_dropped);
#endif
}

The above function is used to dump out a statistics vector as a formatted string. Unfortunately the DSL_CPE_API does not give us any tools to create a statistic message as a stream of bytes. We would expect in a future version of DSM to be




NEXT




<s> static void strip(char *str)
{
char *p = str;
int l;

while ((isspace(*p)))
p++;
l = strlen(p);
if (p != str)
memmove(str, p, l + 1);
if (!l)
return;
p = str + l - 1;
while ((isspace(*p)))
*p-- = 0;
}

The above function is used to remove leading and trailing white spaces in the line of the input.

The following function is used to add '*' at the start of each line in the input while storing string content into the output file.

static char *add




NEXT




<s> mtk_bmt_mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
{
struct erase_info mapped_instr = {
.len = bmtd.blk_size,
};
int retry_count = 0;
u64 start_addr, end_addr;
int ret;
u16 orig_block;
int block;

start_addr = instr->addr & (~mtd->erasesize_mask);
end_addr = instr->addr + instr->len;

while (start_addr < end_addr) {
orig_block = start_addr >> bmtd.blk_shift;
block = bmtd.ops->get_mapping_block(orig_block);
if (block < 0)
return -EIO;
mapped_instr.addr = (loff_t)block << bmtd.blk_shift;
ret = bmtd._erase(mtd, &mapped_instr);
if (ret) {
if (mtk_bmt_remap_block(orig_block, block, 0) &&
retry_count++ < 10)
continue;
instr->fail_addr = start_addr;
break;
}
start_addr += mtd->erasesize;
retry_count = 0;
}

return ret;
}

The above function is used to erase a device using block erase. As stated above,
our original hardware only performs chip erase.

The function above consists of two main parts

1) The bmtd.blk_shift parameter is the device bit




NEXT




<s> static int rtl83xx_port_lag_leave(struct dsa_switch *ds, int port,
struct net_device *lag)
{
int i, group = -1, err;
struct rtl838x_switch_priv *priv = ds->priv;

mutex_lock(&priv->reg_mutex);
for (i = 0; i < priv->n_lags; i++) {
if (priv->lags_port_members[i] & BIT_ULL(port)) {
group = i;
break;
}
}

if (group == -1) {
pr_info("port_lag_leave: port %d is not a member\n", port);
err = -EINVAL;
goto out;
}

if (port >= priv->cpu_port) {
err = -EINVAL;
goto out;
}
pr_info("port_lag_del: group %d, port %d\n",group, port);
priv->lagmembers &=~ (1ULL << port);
priv->lag_primary[i] = -1;
priv->is_lagmember[port] = 0;
pr_debug("lag_members = %llX\n", priv->lagmembers);
err = rtl83xx_lag_del(priv->ds, group, port);
if (err) {
err = -EINVAL;
goto out;
}
if (!priv->lags_port_members[i])
priv->lag_devs[i] = NULL;

out:
mutex_unlock(&priv->reg_mutex);
return 0;
}

The above function is used to remove the member from the lag and update the member variable lagmembers and the primary variable. The group variable is the group index. All lag ports are updated in the lag_primary variable and the flag variable is_lagmember in the structure rtl




NEXT




<s> extern void	rtcl_839x_dram_start(void);
extern int	rtcl_839x_dram_size;

extern void	(*rtcl_839x_dram_set_rate)(int clk_idx, int ctrl0, int ctrl1);
static void	(*rtcl_839x_sram_set_rate)(int clk_idx, int ctrl0, int ctrl1);

/*
* clock setter/getter functions
*/

static unsigned long rtcl_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
{
struct rtcl_clk *clk = rtcl_hw_to_clk(hw);
unsigned int ctrl0, ctrl1, div1, div2, cmu_ncode_in;
unsigned int cmu_sel_prediv, cmu_sel_div4, cmu_divn2, cmu_divn2_selb, cmu_divn3_sel;

if ((clk->idx >= CLK_COUNT) || (!rtcl_ccu) || (rtcl_ccu->soc >= SOC_COUNT))
return 0;

ctrl0 = read_sw(rtcl_regs[rtcl_ccu->soc][REG_CTRL0][clk->idx]);
ctrl1 = read_sw(rtcl_regs[rtcl_ccu->soc][REG_CTRL1][clk->idx]);

cmu_sel_prediv = 1 << RTL_PLL_CTRL0_CMU_SEL_PREDIV(ctrl0);
cmu_sel_div4 = RTL_PLL_CTRL0_CMU_SEL_DIV4(ctrl0) ? 4 : 1;
cmu_ncode_in = RTL_PLL_CTRL0_CMU_NCODE_IN(ctrl0) + 4;
cmu_divn2 = RTL_PLL_CTRL0_CMU_DIVN2(ctrl0) + 4;

switch (rtcl_ccu->soc) {
case SOC_RTL838X:
if ((ctrl0 == 0) && (ctrl1 == 0) && (clk->idx == CLK_LXB))
return 200000000;

cmu_divn2_selb = RTL838X_PLL_CTRL1_CMU_DIVN2_SELB(ctrl1);
cmu_divn3_sel = rtcl_divn3[RTL838X_PLL_CTRL1_CMU_DIVN3_SEL(ctrl1)];
break;
case SOC_RTL839X:
cmu_divn2_selb = RTL839X_PLL_CTRL1_CMU_DIVN2_SELB(ctrl1);
cmu_divn3_sel = rtcl_divn3[RTL839X_PLL_CTRL1_CMU_DIVN3_SEL(ctrl1)];
break;
}
div1 = cmu_divn2_selb ? cmu_divn3_sel : cmu_divn2;
div2 = rtcl_xdiv[clk->idx];

return (((parent_rate / 16) * cmu_ncode_in) / (div1 * div2)) *
cmu_sel_prediv * cmu_sel_div4 * 16;
}

The above function is used to set clock rate in the range of 0 - 32MHz.

extern void	rtcl_set_rate(int clk_idx, int cmu, int div1, int div2, int cfu,




NEXT




<s> radius_parse_attr(struct blob_attr *attr)
{
static const struct blobmsg_policy policy[4] = {
{ .type = BLOBMSG_TYPE_INT32 },
{ .type = BLOBMSG_TYPE_INT32 },
{ .type = BLOBMSG_TYPE_STRING },
{ .type = BLOBMSG_TYPE_STRING },
};
static struct radius_parse_attr_data data;
struct blob_attr *tb[4];
const char *format;

blobmsg_parse_array(policy, ARRAY_SIZE(policy), tb, blobmsg_data(attr), blobmsg_len(attr));

if (!tb[0] || !tb[1] || !tb[2] || !tb[3])
return NULL;

format = blobmsg_get_string(tb[2]);
if (strlen(format) != 1)
return NULL;

data.vendor = blobmsg_get_u32(tb[0]);
data.type = blobmsg_get_u32(tb[1]);
data.format = format[0];
data.data = blobmsg_get_string(tb[3]);
data.size = strlen(data.data);

switch (data.format) {
case 's':
break;
case 'x':
if (data.size & 1)
return NULL;
data.size /= 2;
break;
case 'd':
data.size = 4;
break;
default:
return NULL;
}

return &data;
}

The above function is used to parse the message received in ‘blob_attr’ field of radius_packet_hdr structure. Radius packets are defined using different attributes, which is parsed into ‘attrs’ field present in ‘radius_attribute’ structure.

A user can




NEXT




<s> static irqreturn_t bcm6368_enetsw_isr_dma(int irq, void *dev_id)
{
struct net_device *ndev = dev_id;
struct bcm6368_enetsw *priv = netdev_priv(ndev);

/* mask rx/tx interrupts */
dmac_writel(priv, 0, DMAC_IRMASK_REG, priv->rx_chan);
dmac_writel(priv, 0, DMAC_IRMASK_REG, priv->tx_chan);

napi_schedule(&priv->napi);

return IRQ_HANDLED;
}

The above function is used to re-enable a DMA channel, and then set the napi_head for it, to make that napi dequeue interrupts from that particular dma channel.

This way, we can have multiple DMA channels running parallely.




NEXT




<s> static int rtl8366rb_sw_get_port_led(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data = 0;

if (val->port_vlan >= RTL8366RB_NUM_LEDGROUPS)
return -EINVAL;

rtl8366_smi_read_reg(smi, RTL8366RB_LED_CTRL_REG, &data);
val->value.i = (data >> (val->port_vlan * 4)) & 0x000F;

return 0;
}

The above function is used to get the led setting values of the specified port. The port's physical value is passed as the fourth parameter of the function. If the fourth parameter set to RTL8366RB_PHY_PORT_START, the function would get




NEXT




<s> static void dma_controller_cfg(struct dc_ep_dev *dev)
{
ep_wr32_mask(0, BIT(31), DMA_CTRL);
ep_wr32_mask(BIT(30), 0, DMA_CTRL);
ep_wr32_mask(0, BIT(1), DMA_CTRL);
ep_wr32_mask(0, BIT(13), DMA_CTRL);
}

The above function is used to set the DMA settings. The DMA is used when DMA_TYPE is a constant of one of the
following:

* DMA_MEM_TO_HOST
* DMA_MEM_TO_DMA
* DMA_HOST_TO




NEXT




<s> rtk_api_ret_t rtk_svlan_defaultSvlan_get(rtk_port_t port, rtk_vlan_t *pSvid)
{
rtk_api_ret_t retVal;
rtk_uint32 idx;
rtl8367c_svlan_memconf_t svlanMemConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pSvid)
return RT_ERR_NULL_POINTER;

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicSvlanDefaultVlan(rtk_switch_port_L2P_get(port), &idx)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(idx, &svlanMemConf)) != RT_ERR_OK)
return retVal;

*pSvid = svlanMemConf.vs_svid;

return RT_ERR_OK;
}

The above function is used to get the default vlan-ID (SVLAN). This function is used only for SVLAN functions.

1. Initialize SVLAN library API: rtk_svlan_init() must be called first for any function call.
2




NEXT




<s> static int set_theme(const char *theme)
{
int use_color = 1;
if (!theme)
set_bluetitle_theme();
else if (strcmp(theme, "classic") == 0)
set_classic_theme();
else if (strcmp(theme, "bluetitle") == 0)
set_bluetitle_theme();
else if (strcmp(theme, "blackbg") == 0)
set_blackbg_theme();
else if (strcmp(theme, "mono") == 0)
use_color = 0;

return use_color;
}

The above function is used to set the theme of the terminal to the desired one.
The set_classic_theme, set_blackbg_theme, set_bluetitle_theme functions and more are defined in theme.h which is include in the top




NEXT




<s> ar8xxx_phy_config_aneg(struct phy_device *phydev)
{
if (phydev->mdio.addr == 0)
return 0;

return genphy_config_aneg(phydev);
}

The above function is used to configure the PHY device for autonegotiation. Firstly, it checks if the PHY device’s MDIO address is set to 0, which indicates that the current PHY device is unknown, and returns if it is.





NEXT




<s> ret_t rtl8367c_getAsicInterruptRelatedStatus(rtk_uint32 type, rtk_uint32* pStatus)
{
CONST rtk_uint32 indicatorAddress[INTRST_END] = {RTL8367C_REG_LEARN_OVER_INDICATOR,
RTL8367C_REG_SPEED_CHANGE_INDICATOR,
RTL8367C_REG_SPECIAL_CONGEST_INDICATOR,
RTL8367C_REG_PORT_LINKDOWN_INDICATOR,
RTL8367C_REG_PORT_LINKUP_INDICATOR,
RTL8367C_REG_METER_OVERRATE_INDICATOR0,
RTL8367C_REG_METER_OVERRATE_INDICATOR1,
RTL8367C_REG_RLDP_LOOPED_INDICATOR,
RTL8367C_REG_RLDP_RELEASED_INDICATOR,
RTL8367C_REG_SYSTEM_LEARN_OVER_INDICATOR};

if(type >= INTRST_END )
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_getAsicReg(indicatorAddress[type], pStatus);
}

The above function is used to access the interrupt related register of RTL8367C. The description about these registers is as follow:
1. This bit can be set or cleared by SW at any time.
2. This bit can be set or cleared by




NEXT




<s> static int swconfig_dump_switches(struct sk_buff *skb,
struct netlink_callback *cb)
{
struct switch_dev *dev;
int start = cb->args[0];
int idx = 0;

swconfig_lock();
list_for_each_entry(dev, &swdevs, dev_list) {
if (++idx <= start)
continue;
if (swconfig_send_switch(skb, NETLINK_CB(cb->skb).portid,
cb->nlh->nlmsg_seq, NLM_F_MULTI,
dev) < 0)
break;
}
swconfig_unlock();
cb->args[0] = idx;

return skb->len;
}

The above function is used to send switches information in config space. It
acquires the config space lock through swconfig_lock(). Then iterates through the
list of switch devices, skipping the switches whose index is smaller than the
start point specified by




NEXT




<s> static int rtl8366s_sw_get_port_stats(struct switch_dev *dev, int port,
struct switch_port_stats *stats)
{
return (rtl8366_sw_get_port_stats(dev, port, stats,
RTL8366S_MIB_TXB_ID, RTL8366S_MIB_RXB_ID));
}

The above function is used to retrieve statistic of each port when the host calls the f_sw_stats_get() function in switch.c. To get statistics of each queue in this function, we have to call the rtl8366_sw_get




NEXT




<s> static bool remap_block_v2(u16 block, u16 mapped_block, int copy_len)
{
u16 new_block;
struct bbbt *bbt;

bbt = bmtd.bbt;
new_block = find_valid_block_in_pool(bbt);
if (new_block == 0)
return false;

/* Map new bad block to available block in pool */
bbt->bb_tbl[block] = new_block;

/* Erase new block */
bbt_nand_erase(new_block);
if (copy_len > 0)
bbt_nand_copy(new_block, mapped_block, copy_len);

bmtd.bmt_blk_idx = upload_bmt(bbt, bmtd.bmt_blk_idx);

return true;
}

The above function is used to copy and remap bad blocks.

Lets see how do we deal with bad blocks in flash.

1. Block is erased
2. NAND flash performs Read Operation
3. When a read operation is called then the




NEXT




<s> static int b53_spi_write64(struct b53_device *dev, u8 page, u8 reg, u64 value)
{
struct spi_device *spi = dev->priv;
int ret;
u8 txbuf[10];

ret = b53_prepare_reg_access(spi, page);
if (ret)
return ret;

txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
txbuf[1] = reg;
put_unaligned_le64(value, &txbuf[2]);

return spi_write(spi, txbuf, sizeof(txbuf));
}

The above function is used to write 64-bits register and it expects the
10-byte buffer (4-byte for page and 2-byte for the 64-bit register value).
The page is in little-endian format but the




NEXT




<s> static void ws2812b_set_byte(struct ws2812b_priv *priv, size_t offset, u8 val)
{
/* The lookup table for Bit 7-5 4-3 2-0 */
const u8 h3b[] = { 0x92, 0x93, 0x9a, 0x9b, 0xd2, 0xd3, 0xda, 0xdb };
const u8 m2b[] = { 0x49, 0x4d, 0x69, 0x6d };
const u8 l3b[] = { 0x24, 0x26, 0x34, 0x36, 0xa4, 0xa6, 0xb4, 0xb6 };
u8 *p = priv->data_buf + WS2812B_RESET_LEN + (offset * WS2812B_BYTES_PER_COLOR);

p[0] = h3b[val >> 5]; /* Bit 7-5 */
p[1] = m2b[(val >> 3) & 0x3]; /* Bit 4-3 */
p[2] = l3b[val & 0x7]; /* Bit 2-0 */
}

The above function is used to update the buffer used to send data to the WS2812B LEDs.

It seems to me that this function should be called something like ws2812b_set_value_color().</s>




NEXT




<s> static ssize_t swconfig_trig_speed_mask_store(struct device *dev,
struct device_attribute *attr,
const char *buf, size_t size)
{
struct led_classdev *led_cdev = dev_get_drvdata(dev);
struct swconfig_trig_data *trig_data = led_cdev->trigger_data;
u8 speed_mask;
int ret;

ret = kstrtou8(buf, 0, &speed_mask);
if (ret)
return ret;

write_lock(&trig_data->lock);
trig_data->speed_mask = speed_mask & SWCONFIG_LED_PORT_SPEED_ALL;
write_unlock(&trig_data->lock);

return size;
}

The above function is used to set read-write attributes of speed_mask</s>




NEXT




<s> rtl_r16(struct switch_dev *dev, unsigned int page, unsigned int phy, unsigned int reg)
{
struct rtl_priv *priv = to_rtl(dev);
struct mii_bus *bus = priv->bus;

rtl_set_page(priv, page);
return bus->read(bus, phy, reg);
}

The above function is used to read a single byte of the PHY register
from memory. Although it uses the private struct rtl_priv,
mangling with it might not always give you the result you want.

The bus->read is defined as follows




NEXT




<s> rtk_api_ret_t rtk_qos_1pRemark_set(rtk_pri_t int_pri, rtk_pri_t dot1p_pri)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (int_pri > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

if (dot1p_pri > RTL8367C_PRIMAX)
return RT_ERR_VLAN_PRIORITY;

if ((retVal = rtl8367c_setAsicRemarkingDot1pParameter(int_pri, dot1p_pri)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to perform dot1p remarking of incoming traffic on an
interface at specific priority.

It accepts 2 integer arguments, int_pri and dot1p_pri which have the
description stated in the header comments of the function




NEXT




<s> static ssize_t uimage_verify_default(u_char *buf, u32 ih_magic, u32 ih_type)
{
struct uimage_header *header = (struct uimage_header *)buf;

/* default sanity checks */
if (be32_to_cpu(header->ih_magic) != ih_magic) {
pr_debug("invalid uImage magic: %08x != %08x\n",
be32_to_cpu(header->ih_magic), ih_magic);
return -EINVAL;
}

if (header->ih_os != IH_OS_LINUX) {
pr_debug("invalid uImage OS: %08x != %08x\n",
be32_to_cpu(header->ih_os), IH_OS_LINUX);
return -EINVAL;
}

if (header->ih_type != ih_type) {
pr_debug("invalid uImage type: %08x != %08x\n",
be32_to_cpu(header->ih_type), ih_type);
return -EINVAL;
}

return 0;
}

The above function is used to verify the image. The sanity checks include:

•   The header magic number is the same as the default
•   The OS type is LINUX
•   The image type is the same as the caller passed through






NEXT




<s> static int b53_spi_read48(struct b53_device *dev, u8 page, u8 reg, u64 *val)
{
int ret;

*val = 0;
ret = b53_spi_read(dev, page, reg, (u8 *)val, 6);
if (!ret)
*val = le64_to_cpu(*val);

return ret;
}

The above function is used to read the 48-bit RXCNT and TXCNT registers from the B53 device. When called, it expects the *val parameter to be a pointer to a 64-bit unsigned integer, which is used to




NEXT




<s> ar8327_sw_hw_apply(struct switch_dev *dev)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
const struct ar8327_data *data = priv->chip_data;
int ret, i;

ret = ar8xxx_sw_hw_apply(dev);
if (ret)
return ret;

for (i=0; i < AR8XXX_NUM_PHYS; i++) {
if (data->eee[i])
ar8xxx_reg_clear(priv, AR8327_REG_EEE_CTRL,
AR8327_EEE_CTRL_DISABLE_PHY(i));
else
ar8xxx_reg_set(priv, AR8327_REG_EEE_CTRL,
AR8327_EEE_CTRL_DISABLE_PHY(i));
}

return 0;
}

The above function is used to apply a software or hardware setup to
the AR8327 switches. When AR8327 is initialized it calls
sw_hw_apply in order to apply the software setup, and
after a configuration update it calls hw




NEXT




<s> void ifx_deu_aes_ecb (void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
ifx_deu_aes (ctx, dst, src, NULL, nbytes, encdec, 0);
}

The above function is used to encrypt or decrypt data by ECB mode. There is
the implementation of ifx_deu_aes_ecb_wrap that uses the ECB method to wrap a
data stream. The same algorithm is used for encryption




NEXT




<s> static void ag71xx_hw_init(struct ag71xx *ag)
{
ag71xx_hw_stop(ag);

ag71xx_sb(ag, AG71XX_REG_MAC_CFG1, MAC_CFG1_SR);
udelay(20);

reset_control_assert(ag->mac_reset);
if (ag->mdio_reset)
reset_control_assert(ag->mdio_reset);
msleep(100);
reset_control_deassert(ag->mac_reset);
if (ag->mdio_reset)
reset_control_deassert(ag->mdio_reset);
msleep(200);

ag71xx_hw_setup(ag);

ag71xx_dma_reset(ag);
}

The above function is used to initialize ag71xx device
static void ag71xx_hw_setup(struct ag71xx *ag)
{
u16 mac_cfg;

mac_cfg = ag71xx_lb(ag




NEXT




<s> static void bcm6328_pcie_setup(struct bcm6328_pcie *priv)
{
u32 val;

val = __raw_readl(priv->base + PCIE_BRIDGE_OPT1_REG);
val |= OPT1_RD_BE_OPT_EN;
val |= OPT1_RD_REPLY_BE_FIX_EN;
val |= OPT1_PCIE_BRIDGE_HOLE_DET_EN;
val |= OPT1_L1_INT_STATUS_MASK_POL;
__raw_writel(val, priv->base + PCIE_BRIDGE_OPT1_REG);

val = __raw_readl(priv->base + PCIE_BRIDGE_RC_INT_MASK_REG);
val |= PCIE_RC_INT_A;
val |= PCIE_RC_INT_B;
val |= PCIE_RC_INT_C;
val |= PCIE_RC_INT_D;
__raw_writel(val, priv->base + PCIE_BRIDGE_RC_INT_MASK_REG);

val = __raw_readl(priv->base + PCIE_BRIDGE_OPT2_REG);
/* enable credit checking and error checking */
val |= OPT2_TX_CREDIT_CHK_EN;
val |= OPT2_UBUS_UR_DECODE_DIS;
/* set device bus/func for the pcie device */
val |= (PCIE_BUS_DEVICE << OPT2_CFG_TYPE1_BUS_NO_SHIFT);
val |= OPT2_CFG_TYPE1_BD_SEL;
__raw_writel(val, priv->base + PCIE_BRIDGE_OPT2_REG);

/* setup class code as bridge */
val = __raw_readl(priv->base + PCIE_IDVAL3_REG);
val &= ~IDVAL3_CLASS_CODE_MASK;
val |= (PCI_CLASS_BRIDGE_PCI << IDVAL3_SUBCLASS_SHIFT);
__raw_writel(val, priv->base + PCIE_IDVAL3_REG);

/* disable bar1 size */
val = __raw_readl(priv->base + PCIE_CONFIG2_REG);
val &= ~CONFIG2_BAR1_SIZE_MASK;
__raw_writel(val, priv->base + PCIE_CONFIG2_REG);

/* set bar0 to little endian */
val = (bcm6328_pcie_mem_resource.start >> 20)
<< BASEMASK_BASE_SHIFT;
val |= (bcm6328_pcie_mem_resource.end >> 20) << BASEMASK_MASK_SHIFT;
val |= BASEMASK_REMAP_EN;
__raw_writel(val, priv->base + PCIE_BRIDGE_BAR0_BASEMASK_REG);

val = (bcm6328_pcie_mem_resource.start >> 20)
<< REBASE_ADDR_BASE_SHIFT;
__raw_writel(val, priv->base + PCIE_BRIDGE_BAR0_REBASE_ADDR_REG);
}

The above function is used to program the PCI express bridge.</s>




NEXT




<s> int ifxdeu_init_sha1_hmac (void)
{
int ret = -ENOSYS;



if ((ret = crypto_register_shash(&ifxdeu_sha1_hmac_alg)))
goto sha1_err;

printk (KERN_NOTICE "IFX DEU SHA1_HMAC initialized%s.\n", disable_deudma ? "" : " (DMA)");
return ret;

sha1_err:
printk(KERN_ERR "IFX DEU SHA1_HMAC initialization failed!\n");
return ret;
}

The above function is used to initialize the IFX DEU SHA1_HMAC implementation in the kernel. It is a part of the Linux kernel source code.

## What is the function of crypto_register_shash in Linux kernel?

Crypto_




NEXT




<s> static void ubus_reconnect_timeout(void *eloop_data, void *user_ctx)
{
if (ubus_reconnect(ctx, NULL)) {
eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
return;
}

ubus_add_uloop(ctx);
}

The above function is used to setup reconnection with the ubus server in case of a timeout.
After the ubus reconnect call, it re-registers a timeout event (for 1 second) and
calls itself again with a different Uloop data(ctx




NEXT




<s> hostapd_rrm_nr_get_own(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct hostapd_data *hapd = get_hapd_from_object(obj);
struct hostapd_neighbor_entry *nr;
void *c;

hostapd_rrm_nr_enable(hapd);

nr = hostapd_neighbor_get(hapd, hapd->own_addr, NULL);
if (!nr)
return UBUS_STATUS_NOT_FOUND;

blob_buf_init(&b, 0);

c = blobmsg_open_array(&b, "value");
hostapd_rrm_print_nr(nr);
blobmsg_close_array(&b, c);

ubus_send_reply(ctx, req, b.head);

return 0;
}

The above function is used to query the RRM neighbor record for your BSSID and print the required information.

This is the output that I get when I called the ubus API.

```
 {
	"type": 
	"ne




NEXT




<s> static int fit_image_get_data_size(const void *fit, int noffset, int *data_size)
{
const fdt32_t *val;

val = fdt_getprop(fit, noffset, FIT_DATA_SIZE_PROP, NULL);
if (!val)
return -ENOENT;

*data_size = fdt32_to_cpu(*val);

return 0;
}

The above function is used to determine the size of payload. The implementation is pretty simple. We simply extract the FIT_DATA_SIZE_PROP property value from FIT_DATA_SIZE_PROP and assign to a pointer. Now a days I am trying to use C++ instead




NEXT




<s> static ssize_t stp_state_read(struct file *filp, char __user *buffer, size_t count,
loff_t *ppos)
{
struct rtl838x_port *p = filp->private_data;
struct dsa_switch *ds = p->dp->ds;
int value = rtl83xx_port_get_stp_state(ds->priv, p->dp->index);

if (value < 0)
return -EINVAL;

return rtl838x_common_read(buffer, count, ppos, (u32)value);
}

The above function is used to read the state whether STP enabled or not, which can be passed as
an input to the dsa driver for setting the state of STP on port


static ssize_t stp_state_write(struct file *




NEXT




<s> ret_t rtl8367c_getAsicSvlanC2SConf(rtk_uint32 index, rtk_uint32* pEvid, rtk_uint32* pPortmask, rtk_uint32* pSvidx)
{
ret_t retVal;

if(index > RTL8367C_C2SIDXMAX)
return RT_ERR_ENTRY_INDEX;

retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index), pSvidx);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index) + 1, pPortmask);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index) + 2, pEvid);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get configuration of one C2S port.

For more information about function getAsicSvlanC2SConf, please refer to SDK function getAsicSvlanC2SConf() in documentation.</s>




NEXT




<s> ret_t rtl8367c_getRealKeepRemarkEn(rtk_uint32 *pEnabled)
{
ret_t   retVal;

if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_1P_REMARK_BYPASS_REALKEEP_OFFSET, pEnabled)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the status of the VLAN tag insertion or deletion before forwarding to the L2 forwarding table.

In the current design, the original VLAN format is preserved. As the original format of the VLAN tag is 




NEXT




<s> static int rtl931x_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
{
return rtl931x_mdio_read_paged(bus, mii_id, 0, regnum);
}

The above function is used to register the bus. The rtl931x_mdio_read_page
function gets called once per page read.
The mii-bus maintains a bus->priv which can be used to store the page
number to




NEXT




<s> static int rtl8366rb_enable_port(struct rtl8366_smi *smi, int port, int enable)
{
return rtl8366_smi_rmwr(smi, RTL8366RB_PECR, (1 << port),
(enable) ? 0 : (1 << port));
}

The above function is used to enable and disable RGMII ports on the silicon.  This is controlled by PHY_EN/AN_EN bits in the GPECR.
For a particular RGMII port, to enable it (say E/RGM




NEXT




<s> ar8xxx_sw_get_ports(struct switch_dev *dev, struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
u8 ports;
int i;

if (val->port_vlan >= dev->vlans)
return -EINVAL;

ports = priv->vlan_table[val->port_vlan];
val->len = 0;
for (i = 0; i < dev->ports; i++) {
struct switch_port *p;

if (!(ports & (1 << i)))
continue;

p = &val->value.ports[val->len++];
p->id = i;
if (priv->vlan_tagged & (1 << i))
p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
else
p->flags = 0;
}
return 0;
}

The above function is used to return ports which have the given VLAN tag, the function is pretty much self explanatory, with the help of vlan tagged bit in the hardware we can know which port to send the traffic.</s>




NEXT




<s> void rtk_hal_qos_set_queue_weight(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;
rtk_qos_queue_weights_t qweights;

ret = rtk_qos_schedulingQueue_get(data->port, &qweights);
qweights.weights[data->qos_queue_num] = data->qos_weight;
ret = rtk_qos_schedulingQueue_set(data->port, &qweights);
if (ret != 0)
printk("rtk_qos_schedulingQueue_set failed\n");
}

The above function is used to change the weight (relative order) of a QoS queue. For simplicity, I modified the original function to add a printf statement to enable us to easily print out the changes to weight of a QoS queue in the QoS queue




NEXT




<s> rtk_api_ret_t rtk_filter_portrange_set(rtk_uint32 index, rtk_filter_portrange_t type, rtk_uint32 upperPort, rtk_uint32 lowerPort)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

if(type >= PORTRANGE_END)
return RT_ERR_OUT_OF_RANGE;

if(lowerPort > upperPort)
return RT_ERR_INPUT;

if(upperPort > RTL8367C_ACL_PORTRANGEMAX)
return RT_ERR_INPUT;

if(lowerPort > RTL8367C_ACL_PORTRANGEMAX)
return RT_ERR_INPUT;

if((ret = rtl8367c_setAsicAclPortRange(index, type, upperPort, lowerPort)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to set port type and port number range of filter input.

The function uses RTL8367C_SET_ACL_PORTRANGE to set ACL port range.



rtk_api_ret




NEXT




<s> ar8327_sw_get_eee(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
const struct ar8327_data *data = priv->chip_data;
int port = val->port_vlan;
int phy;

if (port >= dev->ports)
return -EINVAL;
if (port == 0 || port == 6)
return -EOPNOTSUPP;

phy = port - 1;

val->value.i = data->eee[phy];

return 0;
}

The above function is used to get the EEE attribute of the switch. The port number is used to get the physical port number to access the array in the struct ar8327_data data. The EEE array holds the values of the EEE mode supported by




NEXT




<s> static const char *conf_get_autoconfig_name(void)
{
char *name = getenv("KCONFIG_AUTOCONFIG");

return name ? name : "include/config/auto.conf";
}

The above function is used to return the name of the file that gets automatically applied by the autoconfig/autoconfig-all feature. The file
is also used by the autoconfig commandline utility, for instance if run with default arguments without option, it will




NEXT




<s> int rtl838x_smi_wait_op(int timeout)
{
int ret = 0;
u32 val;

ret = readx_poll_timeout(sw_r32, RTL838X_SMI_ACCESS_PHY_CTRL_1,
val, !(val & 0x1), 20, timeout);
if (ret)
pr_err("%s: timeout\n", __func__);

return ret;
}

The above function is used to access the smi register.</s>




NEXT




<s> rtk_api_ret_t rtk_dot1x_macBasedAuthMac_add(rtk_port_t port, rtk_mac_t *pAuth_mac, rtk_fid_t fid)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* must be unicast address */
if ((pAuth_mac == NULL) || (pAuth_mac->octet[0] & 0x1))
return RT_ERR_MAC;

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if (fid > RTL8367C_FIDMAX)
return RT_ERR_L2_FID;

memset(&l2Table, 0, sizeof(rtl8367c_luttb));

/* fill key (MAC,FID) to get L2 entry */
memcpy(l2Table.mac.octet, pAuth_mac->octet, ETHER_ADDR_LEN);
l2Table.fid = fid;
method = LUTREADMETHOD_MAC;
retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
if ( RT_ERR_OK == retVal)
{
if (l2Table.spa != rtk_switch_port_L2P_get(port))
return RT_ERR_DOT1X_MAC_PORT_MISMATCH;

memcpy(l2Table.mac.octet, pAuth_mac->octet, ETHER_ADDR_LEN);
l2Table.fid = fid;
l2Table.efid = 0;
l2Table.auth = 1;
retVal = rtl8367c_setAsicL2LookupTb(&l2Table);
return retVal;
}
else
return retVal;

}

The above function is used to add MAC address based authorization. It takes following parameters:

- pAuth_mac: The MAC address to be authorization
- port: The port it is applied to
- fid: The FID used for MAC address based author




NEXT




<s> kconfig_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg)
{

switch (sym->type) {
case S_BOOLEAN:
case S_TRISTATE:
if (*value == 'n') {
bool skip_unset = (arg != NULL);

if (!skip_unset)
fprintf(fp, "# %s%s is not set\n",
CONFIG_, sym->name);
return;
}
break;
default:
break;
}

fprintf(fp, "%s%s=%s\n", CONFIG_, sym->name, value);
}

The above function is used to print the symbol value to kconfig file.The kconfig_symbol() function calls the kconfig_print_symbol() to print symbol based on the symbol type.

```
kconfig_print_symbol(FILE *fp,




NEXT




<s> static void ag71xx_tx_timeout(struct net_device *dev, unsigned int txqueue)
{
struct ag71xx *ag = netdev_priv(dev);

if (netif_msg_tx_err(ag))
pr_info("%s: tx timeout\n", ag->dev->name);

schedule_delayed_work(&ag->restart_work, 1);
}

The above function is used to notify the driver's workqueue to restart after a
timeout. For this function, there is no workqueue for the ag71xx_restart_work
because we have already created the netdev->workqueue in
ag7




NEXT




<s> static bool nmbm_check_bad_phys_block(struct nmbm_instance *ni, uint32_t ba)
{
uint64_t addr = ba2addr(ni, ba);

return bmtd._block_isbad(bmtd.mtd, addr);
}

The above function is used to check if the specified block address in bad block list. As bmtd._block_isbad takes a pointer of uint64_t type as its parameter, the argument list of bmtd._block_isbad call is as follows




NEXT




<s> static int rfc3686_aes_decrypt(struct ablkcipher_request *areq)
{
struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);
struct aes_ctx *ctx = crypto_ablkcipher_ctx(cipher);
int ret;
u8 *info = areq->info;
u8 rfc3686_iv[16];

/* set up counter block */
memcpy(rfc3686_iv, ctx->nonce, CTR_RFC3686_NONCE_SIZE);
memcpy(rfc3686_iv + CTR_RFC3686_NONCE_SIZE, info, CTR_RFC3686_IV_SIZE);

/* initialize counter portion of counter block */
*(__be32 *)(rfc3686_iv + CTR_RFC3686_NONCE_SIZE + CTR_RFC3686_IV_SIZE) =
cpu_to_be32(1);

areq->info = rfc3686_iv;
ret = lq_aes_queue_mgr(ctx, areq, areq->info, CRYPTO_DIR_DECRYPT, 4);
areq->info = info;
return ret;
}

The above function is used to decrypt the data. The function takes an ‘info’ parameter, which is the context. The information is copied in the rfc3686_iv(Counter block). The counter block is an 8 byte counter which increases by





NEXT




<s> rtk_api_ret_t rtk_led_OutputEnable_set(rtk_enable_t state)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (state >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicLedOutputEnable(state))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to control the LED output mode.

rtk_api_ret_t rtk_led_OutputEnable_get(rtk_enable_t *state)
{
rtk_api_ret_t retVal;





NEXT




<s> void rtl838x_print_matrix(void)
{
unsigned volatile int *ptr8;

ptr8 = RTL838X_SW_BASE + RTL838X_PORT_ISO_CTRL(0);
for (int i = 0; i < 28; i += 8)
pr_debug("> %8x %8x %8x %8x %8x %8x %8x %8x\n",
ptr8[i + 0], ptr8[i + 1], ptr8[i + 2], ptr8[i + 3],
ptr8[i + 4], ptr8[i + 5], ptr8[i + 6], ptr8[i + 7]);
pr_debug("CPU_PORT> %8x\n", ptr8[28]);
}

The above function is used to dump register content of a RTL838x. If
you are trying to debug a RTL838x and need to know some register
values, use rtl838x_print_matrix() to gather them




NEXT




<s> static ssize_t mac_tbl_write(struct file *file,
const char __user *buffer, size_t count,
loff_t *data)
{
rtk_hal_clear_table();

return count;
}

The above function is used to clear the MAC Address table. Upon system reboot or upon invocation of this function, the contents inside mac_tbl
are cleared by setting each dword entry to all zero. Since mac_tbl is already a protected writeable shared RAM,




NEXT




<s> static int rtl8367_sw_set_port_pvid(struct switch_dev *dev, int port, int val)
{
return rtl8367c_set_pvid(port, val);
}

The above function is used to set the value of PVID on a particular port (as it
is done in the switch.ko driver).

Now, I am trying to see what configuration can be saved to the NVRAM and used
on rebooting the




NEXT




<s> void item_set(int n)
{
int i = 0;
item_foreach()
if (i++ == n)
return;
}

The above function is used to get (and set) the n-th item in a list.
What if n goes out of the list’s bounds? The above code is fine for
the typical situation in which one always knows that n will be within
its valid




NEXT




<s> adm6996_read_mii_reg(struct adm6996_priv *priv, enum admreg reg)
{
struct phy_device *phydev = priv->priv;
struct mii_bus *bus = phydev->mdio.bus;

return bus->read(bus, PHYADDR(reg));
}

The above function is used to read data from MII registers. The data read in these registers are the data that are sent back to the NIC card from the RGMII adapter that is connected to the LPC bus through a GPIO port. RGMII stands for Rap




NEXT




<s> rtk_api_ret_t rtk_led_groupAbility_get(rtk_led_group_t group, rtk_led_ability_t *pAbility)
{
rtk_api_ret_t retVal;
rtk_uint32 regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (LED_GROUP_END <= group)
return RT_ERR_FAILED;

if(pAbility == NULL)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_LED0_DATA_CTRL + (rtk_uint32)group, &regData)) != RT_ERR_OK)
return retVal;

pAbility->link_10m = (regData & 0x0001) ? ENABLED : DISABLED;
pAbility->link_100m = (regData & 0x0002) ? ENABLED : DISABLED;
pAbility->link_500m = (regData & 0x0004) ? ENABLED : DISABLED;
pAbility->link_1000m = (regData & 0x0008) ? ENABLED : DISABLED;
pAbility->act_rx = (regData & 0x0010) ? ENABLED : DISABLED;
pAbility->act_tx = (regData & 0x0020) ? ENABLED : DISABLED;

return RT_ERR_OK;
}

The above function is used to read Led group ability. The parameter is a integer, the range is [0,3],
and the function return value is a integer. Parameter definition will be given as follows
#define LED_LINK_10MEN (1)




NEXT




<s> int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
unsigned int size)
{
unsigned int AddrToWrite = addr_dest;
AT91PS_DataFlash pFlash = &DataFlashInst;

pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
if (AddrToWrite == -1)
return -1;

return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}

The above function is used to write from one address to another. It needs to be modified for the case when the dataflash is erased. It should first erase the entire flash and then write from the beginning. You can check whether the flash has been erased using the




NEXT




<s> static void _rtl8367c_aclActStUser2Smi(rtl8367c_acl_act_t *pAclUser, rtk_uint16 *pAclSmi)
{
pAclSmi[0] |= (pAclUser->cvidx_cact & 0x003F);
pAclSmi[0] |= (pAclUser->cact & 0x0003) << 6;
pAclSmi[0] |= (pAclUser->svidx_sact & 0x003F) << 8;
pAclSmi[0] |= (pAclUser->sact & 0x0003) << 14;

pAclSmi[1] |= (pAclUser->aclmeteridx & 0x003F);
pAclSmi[1] |= (pAclUser->fwdpmask & 0x00FF) << 6;
pAclSmi[1] |= (pAclUser->fwdact & 0x0003) << 14;

pAclSmi[2] |= (pAclUser->pridx & 0x003F);
pAclSmi[2] |= (pAclUser->priact & 0x0003) << 6;
pAclSmi[2] |= (pAclUser->gpio_pin & 0x000F) << 8;
pAclSmi[2] |= (pAclUser->gpio_en & 0x0001) << 12;
pAclSmi[2] |= (pAclUser->aclint & 0x0001) << 13;
pAclSmi[2] |= (pAclUser->cact_ext & 0x0003) << 14;

pAclSmi[3] |= (pAclUser->tag_fmt & 0x0003);
pAclSmi[3] |= (pAclUser->fwdact_ext & 0x0001) << 2;
pAclSmi[3] |= ((pAclUser->cvidx_cact & 0x0040) >> 6) << 3;
pAclSmi[3] |= ((pAclUser->svidx_sact & 0x0040) >> 6) << 4;
pAclSmi[3] |= ((pAclUser->aclmeteridx & 0x0040) >> 6) << 5;
pAclSmi[3] |= ((pAclUser->fwdpmask & 0x0700) >> 8) << 6;
pAclSmi[3] |= ((pAclUser->pridx & 0x0040) >> 6) << 9;
}

The above function is used to fill ACL data to ACLSMI register.

static void _rtl8367c_aclActStPortUser2Smi(rtl8367c_acl_act_t *pAcl




NEXT




<s> mt7530_reset_switch(struct switch_dev *dev)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
int i;

memset(priv->port_entries, 0, sizeof(priv->port_entries));
memset(priv->vlan_entries, 0, sizeof(priv->vlan_entries));

/* set default vid of each vlan to the same number of vlan, so the vid
* won't need be set explicitly.
*/
for (i = 0; i < MT7530_NUM_VLANS; i++) {
priv->vlan_entries[i].vid = i;
}

return 0;
}

The above function is used to clear all mac address/vlan tables of the host adapter.
So, there is no any effect if the register value has been set into RTL8723BE driver.
Please let me know if it help.

Best




NEXT




<s> swconfig_send_multipart(struct swconfig_callback *cb, void *arg)
{
struct genl_info *info = cb->info;
int restart = 0;
int err;

do {
if (!cb->msg) {
cb->msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
if (cb->msg == NULL)
goto error;
}

if (!(cb->fill(cb, arg) < 0))
break;

/* fill failed, check if this was already the second attempt */
if (restart)
goto error;

/* try again in a new message, send the current one */
restart = 1;
if (cb->close) {
if (cb->close(cb, arg) < 0)
goto error;
}
err = genlmsg_reply(cb->msg, info);
cb->msg = NULL;
if (err < 0)
goto error;

} while (restart);

return 0;

error:
if (cb->msg)
nlmsg_free(cb->msg);
return -1;
}

The above function is used to send multiple replies for an NL family,
for instance, when using multiple sub-buffers
(swconfig_msg_buffers) for a single reply-message.

The swconfig_send_multipart() should be




NEXT




<s> static int qca807x_psgmii_config(struct phy_device *phydev)
{
struct device_node *node = phydev->mdio.dev.of_node;
int tx_amp, ret = 0;
u32 tx_driver_strength;

/* Workaround to enable AZ transmitting ability */
ret = phy_clear_bits_mmd(phydev,
MDIO_MMD_PMAPMD,
PSGMII_MODE_CTRL,
PSGMII_MODE_CTRL_AZ_WORKAROUND_MASK);

/* PSGMII/QSGMII TX amp set to DT defined value instead of default 600mV */
if (!of_property_read_u32(node, "qcom,tx-driver-strength", &tx_driver_strength)) {
tx_amp = phy_read(phydev, PSGMII_QSGMII_DRIVE_CONTROL_1);
tx_amp &= ~PSGMII_QSGMII_TX_DRIVER_MASK;
tx_amp |= FIELD_PREP(PSGMII_QSGMII_TX_DRIVER_MASK, tx_driver_strength);
ret = phy_write(phydev, PSGMII_QSGMII_DRIVE_CONTROL_1, tx_amp);
}

return ret;
}

The above function is used to enable the transmission ability for PSGMI or QSGMII if an unsupported device is detected on the phy port (for i.MX 8). This function is called during the phy_startup_probe().
The PS




NEXT




<s> static int b53_configure_ports(struct b53_device *dev)
{
u8 cpu_port = dev->sw_dev.cpu_port;

/* configure MII port if necessary */
if (is5325(dev)) {
u8 mii_port_override;

b53_read8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
&mii_port_override);
/* reverse mii needs to be enabled */
if (!(mii_port_override & PORT_OVERRIDE_RV_MII_25)) {
b53_write8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
mii_port_override | PORT_OVERRIDE_RV_MII_25);
b53_read8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
&mii_port_override);

if (!(mii_port_override & PORT_OVERRIDE_RV_MII_25)) {
pr_err("Failed to enable reverse MII mode\n");
return -EINVAL;
}
}
} else if (is531x5(dev) && cpu_port == B53_CPU_PORT) {
u8 mii_port_override;

b53_read8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
&mii_port_override);
b53_write8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
mii_port_override | PORT_OVERRIDE_EN |
PORT_OVERRIDE_LINK);

/* BCM47189 has another interface connected to the port 5 */
if (dev->enabled_ports & BIT(5)) {
u8 po_reg = B53_GMII_PORT_OVERRIDE_CTRL(5);
u8 gmii_po;

b53_read8(dev, B53_CTRL_PAGE, po_reg, &gmii_po);
gmii_po |= GMII_PO_LINK |
GMII_PO_RX_FLOW |
GMII_PO_TX_FLOW |
GMII_PO_EN;
b53_write8(dev, B53_CTRL_PAGE, po_reg, gmii_po);
}
} else if (is5301x(dev)) {
if (cpu_port == 8) {
u8 mii_port_override;

b53_read8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
&mii_port_override);
mii_port_override |= PORT_OVERRIDE_LINK |
PORT_OVERRIDE_RX_FLOW |
PORT_OVERRIDE_TX_FLOW |
PORT_OVERRIDE_SPEED_2000M |
PORT_OVERRIDE_EN;
b53_write8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
mii_port_override);

/* TODO: Ports 5 & 7 require some extra handling */
} else {
u8 po_reg = B53_GMII_PORT_OVERRIDE_CTRL(cpu_port);
u8 gmii_po;

b53_read8(dev, B53_CTRL_PAGE, po_reg, &gmii_po);
gmii_po |= GMII_PO_LINK |
GMII_PO_RX_FLOW |
GMII_PO_TX_FLOW |
GMII_PO_EN |
GMII_PO_SPEED_2000M;
b53_write8(dev, B53_CTRL_PAGE, po_reg, gmii_po);
}
}

return 0;
}

The above function is used to configure the PCIe port. For the BCM5325, it sets up a reverse MII mode. For other chipsets, it configures the MII ports as 1 Gbps (which is required because BMC’




NEXT




<s> int     BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom)
{
return bnrand(1, rnd, bits, top, bottom);
}

The above function is used to generate a BIGNUM from a number of values
of the form n. It takes four arguments. Two numbers are provided by the
user. The next two are provided by the OpenSSL library. The function
returns zero if successful. Otherwise




NEXT




<s> static int rtk_gsw_remove(struct platform_device *pdev)
{
platform_set_drvdata(pdev, NULL);
gsw_debug_proc_exit();

return 0;
}

The above function is used to remove a kernel module. You can compile the module first:
$ make
$ insmod rtk_gsw.ko
Then use dmesg to view the device information:
$ dmesg
[35135




NEXT




<s> rtl_get(struct switch_dev *dev, enum rtl_regidx s)
{
const struct rtl_reg *r = &rtl_regs[s];
u16 val;

BUG_ON(s >= ARRAY_SIZE(rtl_regs));
if (r->bits == 0) /* unimplemented */
return 0;

val = rtl_r16(dev, r->page, r->phy, r->reg);

if (r->shift > 0)
val >>= r->shift;

if (r->inverted)
val = ~val;

val &= (1 << r->bits) - 1;

return val;
}

The above function is used to read registers from a RTL8376M CPU. I am not sure why the above function is there and if it is ever called and for what and what parameters are supplied.

The code that calls that function has a very long




NEXT




<s> uc_vm_t *wpa_ucode_create_vm(void)
{
static uc_parse_config_t config = {
.strict_declarations = true,
.lstrip_blocks = true,
.trim_blocks = true,
.raw_mode = true
};

uc_search_path_init(&config.module_search_path);
uc_search_path_add(&config.module_search_path, HOSTAPD_UC_PATH "*.so");
uc_search_path_add(&config.module_search_path, HOSTAPD_UC_PATH "*.uc");

uc_vm_init(&vm, &config);

uc_stdlib_load(uc_vm_scope_get(&vm));
eloop_add_uloop();
gc_timer.cb = uc_gc_timer;

return &vm;
}

The above function is used to create the VM and load the uc_gc_timer module.

The uc_gc_timer function is used to ensure that the Garbage Collection timer does not fire when the current module is being processed.

/* Remove timer




NEXT




<s> static int parse_bcm_wfi(struct mtd_info *master,
const struct mtd_partition **pparts,
uint8_t *buf, loff_t off, loff_t size, bool cfe_part)
{
struct device_node *mtd_node;
struct mtd_partition *parts;
loff_t cfe_off, kernel_off, rootfs_off;
unsigned int num_parts = BCM_WFI_PARTS, cur_part = 0;
const char *cferam_name = CFERAM_NAME;
size_t cferam_name_len;
int ret;

mtd_node = mtd_get_of_node(master);
if (mtd_node)
of_property_read_string(mtd_node, "brcm,cferam", &cferam_name);

cferam_name_len = strnlen(cferam_name, CFERAM_NAME_MAX_LEN);
if (cferam_name_len > 0)
cferam_name_len--;

if (cfe_part) {
num_parts++;
cfe_off = off;

ret = jffs2_find_file(master, buf, cferam_name,
cferam_name_len, &cfe_off,
size - (cfe_off - off), NULL, NULL);
if (ret)
return ret;

kernel_off = cfe_off + master->erasesize;
} else {
kernel_off = off;
}

ret = jffs2_find_file(master, buf, KERNEL_NAME, KERNEL_NAME_LEN,
&kernel_off, size - (kernel_off - off),
NULL, NULL);
if (ret)
return ret;

rootfs_off = kernel_off + master->erasesize;
ret = ubifs_find(master, &rootfs_off, size - (rootfs_off - off));
if (ret)
return ret;

parts = kzalloc(num_parts * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

if (cfe_part) {
parts[cur_part].name = PART_CFERAM;
parts[cur_part].mask_flags = MTD_WRITEABLE;
parts[cur_part].offset = cfe_off;
parts[cur_part].size = kernel_off - cfe_off;
cur_part++;
}

parts[cur_part].name = PART_FIRMWARE;
parts[cur_part].offset = kernel_off;
parts[cur_part].size = size - (kernel_off - off);
cur_part++;

parts[cur_part].name = KERNEL_PART_NAME;
parts[cur_part].offset = kernel_off;
parts[cur_part].size = rootfs_off - kernel_off;
cur_part++;

parts[cur_part].name = UBI_PART_NAME;
parts[cur_part].offset = rootfs_off;
parts[cur_part].size = size - (rootfs_off - off);
cur_part++;

*pparts = parts;

return num_parts;
}

The above function is used to parse the BCM2854 board configuration file for the SD/MMC partition. A BCM2854 is used in the Raspberry Pi 4 board. To use the partition table of BCM2854




NEXT




<s> mvswitch_aneg_done(struct phy_device *phydev)
{
return 1;	/* Return any positive value */
}

The above function is used to tell that auto-negotiation has completed.

Is the function in error?

It certainly is not the way you would use an inline function and this is what is likely to lead to a confusing compiler warning.

#define




NEXT




<s> void rtl9300_do_rx_calibration_4_1(int sds_num)
{
u32 vth_list[2] = {0, 0};
u32 tap0_list[4] = {0, 0, 0, 0};

pr_info("start_1.4.1");

/* ##1.4.1 */
rtl9300_sds_rxcal_vth_manual(sds_num, false, vth_list);
rtl9300_sds_rxcal_tap_manual(sds_num, 0, false, tap0_list);
mdelay(200);

pr_info("end_1.4.1");
}

The above function is used to run "sds rx calibrate" command (see previous post for details) and save the result in vth_list.

The problem is after run the above function, I always get the same result. Although this is actually the




NEXT




<s> rtk_api_ret_t rtk_svlan_dmac_vidsel_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicSvlanDmacCvidSel(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the S-VLAN D-MAC VIDSEL function.

## Parameters:

- port: Logical port number as defined by customer. Should be in the range of 0 to 49 (Exclusive) for




NEXT




<s> static int mtd_check(const char *mtd)
{
char *next = NULL;
char *str = NULL;
int fd;

if (strchr(mtd, ':')) {
str = strdup(mtd);
mtd = str;
}

do {
next = strchr(mtd, ':');
if (next) {
*next = 0;
next++;
}

fd = mtd_check_open(mtd);
if (fd < 0)
return 0;

if (!buf)
buf = malloc(erasesize);

close(fd);
mtd = next;
} while (next);

if (str)
free(str);

return 1;
}

The above function is used to check if a particular mtd device is a good one(ie it returns 1) or not . In case the returned value is 0 then there is something wrong with that mtd and the program should exit.

So the question is




NEXT




<s> static int __init wsap3715i_probe(void)
{
if (of_machine_is_compatible("enterasys,ws-ap3715i"))
return 1;
return 0;
}

The above function is used to check if ethernet is wsap3715i adapter.

Inside this function if (of_machine_is_compatible("enterasys,ws-ap3715i"))
it simply checks with of




NEXT




<s> ret_t rtl8367c_setAsicLutIpMulticastLookup(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LUT_IPMC_HASH_OFFSET, enabled);
}

The above function is used to enable ipmc entries to be mapped to LUT with IP hash address.

# IPMC table entries is not working

Please check if IPMC table is enabled. To enabled IPMC table, user shall set RTL836




NEXT




<s> ret_t rtl8367c_getAsicLutIPMCGroup(rtk_uint32 index, ipaddr_t *pGroup_addr, rtk_uint32 *pVid, rtk_uint32 *pPmask, rtk_uint32 *pValid)
{
rtk_uint32      regAddr, regData, bitoffset;
ipaddr_t    ipData;
ret_t       retVal;

if(index > RTL8367C_LUT_IPMCGRP_TABLE_MAX)
return RT_ERR_INPUT;

if (NULL == pGroup_addr)
return RT_ERR_NULL_POINTER;

if (NULL == pVid)
return RT_ERR_NULL_POINTER;

if (NULL == pPmask)
return RT_ERR_NULL_POINTER;

/* Group address */
regAddr = RTL8367C_REG_IPMC_GROUP_ENTRY0_H + (index * 2);
if( (retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
return retVal;

*pGroup_addr = (((regData & 0x00000FFF) << 16) | 0xE0000000);

regAddr++;
if( (retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
return retVal;

ipData = (*pGroup_addr | (regData & 0x0000FFFF));
*pGroup_addr = ipData;

/* VID */
regAddr = RTL8367C_REG_IPMC_GROUP_VID_00 + index;
if( (retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
return retVal;

*pVid = regData;

/* portmask */
regAddr = RTL8367C_REG_IPMC_GROUP_PMSK_00 + index;
if( (retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
return retVal;

*pPmask = regData;

/* valid */
regAddr = RTL8367C_REG_IPMC_GROUP_VALID_15_0 + (index / 16);
bitoffset = index % 16;
if( (retVal = rtl8367c_getAsicRegBit(regAddr, bitoffset, &regData)) != RT_ERR_OK)
return retVal;

*pValid = regData;

return RT_ERR_OK;
}

The above function is used to read the group address, VID, portmask and validate flag of asic LUT ipmc group from the HW register. The LUT IPMC table registers are written by the following registers:

The following are the registers used to




NEXT




<s> void rtl83xx_port_stp_state_set(struct dsa_switch *ds, int port, u8 state);
void rtl83xx_fast_age(struct dsa_switch *ds, int port);
u32 rtl838x_get_egress_rate(struct rtl838x_switch_priv *priv, int port);
u32 rtl839x_get_egress_rate(struct rtl838x_switch_priv *priv, int port);
int rtl838x_set_egress_rate(struct rtl838x_switch_priv *priv, int port, u32 rate);
int rtl839x_set_egress_rate(struct rtl838x_switch_priv *priv, int port, u32 rate);


const char *rtl838x_drop_cntr[] = {
"ALE_TX_GOOD_PKTS", "MAC_RX_DROP", "ACL_FWD_DROP", "HW_ATTACK_PREVENTION_DROP",
"RMA_DROP", "VLAN_IGR_FLTR_DROP", "INNER_OUTER_CFI_EQUAL_1_DROP", "PORT_MOVE_DROP",
"NEW_SA_DROP", "MAC_LIMIT_SYS_DROP", "MAC_LIMIT_VLAN_DROP", "MAC_LIMIT_PORT_DROP",
"SWITCH_MAC_DROP", "ROUTING_EXCEPTION_DROP", "DA_LKMISS_DROP", "RSPAN_DROP",
"ACL_LKMISS_DROP", "ACL_DROP", "INBW_DROP", "IGR_METER_DROP",
"ACCEPT_FRAME_TYPE_DROP", "STP_IGR_DROP", "INVALID_SA_DROP", "SA_BLOCKING_DROP",
"DA_BLOCKING_DROP", "L2_INVALID_DPM_DROP", "MCST_INVALID_DPM_DROP", "RX_FLOW_CONTROL_DROP",
"STORM_SPPRS_DROP", "LALS_DROP", "VLAN_EGR_FILTER_DROP", "STP_EGR_DROP",
"SRC_PORT_FILTER_DROP", "PORT_ISOLATION_DROP", "ACL_FLTR_DROP", "MIRROR_FLTR_DROP",
"TX_MAX_DROP", "LINK_DOWN_DROP", "FLOW_CONTROL_DROP", "BRIDGE .1d discards"
};

The above function is used to store the mac address in the specific port's table, so that the data would not be
transmitted out.
void rtl838x_port_stp_state_set(struct dsa_switch *ds,




NEXT




<s> static mbedtls_ecp_group_id ecp_curve(const char *name)
{
const mbedtls_ecp_curve_info *curve_info;

if (!strcmp(name, "P-256"))
return MBEDTLS_ECP_DP_SECP256R1;
else if (!strcmp(name, "P-384"))
return MBEDTLS_ECP_DP_SECP384R1;
else if (!strcmp(name, "P-521"))
return MBEDTLS_ECP_DP_SECP521R1;
curve_info = mbedtls_ecp_curve_info_from_name(name);
if (curve_info == NULL)
return MBEDTLS_ECP_DP_NONE;
else
return curve_info->grp_id;
}

The above function is used to convert a standard curve name to the associated
mbedTLS group ID. Use of SHA-1, HMAC and AES in mbedTLS require corresponding
pre-compiled C code.  Therefore, it should be included in the build




NEXT




<s> static int rtl8226_get_eee(struct phy_device *phydev,
struct ethtool_eee *e)
{
u32 val;
int addr = phydev->mdio.addr;

pr_debug("In %s, port %d, was enabled: %d\n", __func__, addr, e->eee_enabled);

val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
if (e->eee_enabled) {
e->eee_enabled = !!(val & MDIO_EEE_100TX);
if (!e->eee_enabled) {
val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV2);
e->eee_enabled = !!(val & MDIO_EEE_2_5GT);
}
}
pr_debug("%s: enabled: %d\n", __func__, e->eee_enabled);

return 0;
}

The above function is used to get the energy efficiency support value, it
is used to check whether energy efficiency supports are enabled. The
problem here is that, for example, rtl2006-s is not supported energy
efficiency. Thus rtl




NEXT




<s> u32 rtl9300_sds_field_r(int sds, u32 page, u32 reg, int end_bit, int start_bit)
{
int l = end_bit - start_bit + 1;
u32 v = rtl930x_read_sds_phy(sds, page, reg);

if (l >= 32)
return v;

return (v >> start_bit) & (BIT(l) - 1);
}

The above function is used to read a specific number of bits from the MAC's PHY registers (SMIA and SDIA fields). As seen above, the function requires four arguments in order to read n bits from the specified PHY register:

1.




NEXT




<s> static inline void m_array(const char *id, const uint8_t *value, size_t len) {
void *c = blobmsg_open_array(&b, id);

for (size_t i = 0; i < len; ++i)
blobmsg_add_u16(&b, "", value[i]);

blobmsg_close_array(&b, c);
}

The above function is used to fill a blobmsg with a set of values from an array.
blobmsg_add_u16

is a function which creates the blob message from the id and value set

The issue is that the value array is passed as




NEXT




<s> static void b53_enable_ports(struct b53_device *dev)
{
unsigned i;

b53_for_each_port(dev, i) {
u8 port_ctrl;
u16 pvlan_mask;

/*
* prevent leaking packets between wan and lan in unmanaged
* mode through port vlans.
*/
if (dev->enable_vlan || is_cpu_port(dev, i))
pvlan_mask = 0x1ff;
else if (is531x5(dev) || is5301x(dev))
/* BCM53115 may use a different port as cpu port */
pvlan_mask = BIT(dev->sw_dev.cpu_port);
else
pvlan_mask = BIT(B53_CPU_PORT);

/* BCM5325 CPU port is at 8 */
if ((is5325(dev) || is5365(dev)) && i == B53_CPU_PORT_25)
i = B53_CPU_PORT;

if (dev->chip_id == BCM5398_DEVICE_ID && (i == 6 || i == 7))
/* disable unused ports 6 & 7 */
port_ctrl = PORT_CTRL_RX_DISABLE | PORT_CTRL_TX_DISABLE;
else if (i == B53_CPU_PORT)
port_ctrl = PORT_CTRL_RX_BCST_EN |
PORT_CTRL_RX_MCST_EN |
PORT_CTRL_RX_UCST_EN;
else
port_ctrl = 0;

b53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i),
pvlan_mask);

/* port state is handled by bcm63xx_enet driver */
if (!is63xx(dev) && !(is5301x(dev) && i == 6))
b53_write8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(i),
port_ctrl);
}
}

The above function is used to configure the ports on the bcm5398 device. The bcm5398_device is a BCM63XX derivative, specifically a derivative of the BCM53125, with the removal of some of




NEXT




<s> static int phyreg_show(struct seq_file *seq, void *v)
{
return 0;
}

The above function is used to show phyreg registers.
During phyreg-read operation when phyreg_show() is called, it prints all phyreg registers using for_each_phyreg() function

phydev->data->ops->




NEXT




<s> static void osafeloader_extract_parse_options(int argc, char **argv) {
int c;

while ((c = getopt(argc, argv, "p:o:")) != -1) {
switch (c) {
case 'p':
partition_name = optarg;
break;
case 'o':
out_path = optarg;
break;
}
}
}

The above function is used to parse the command line options supplied to the tool. The partition name (p) and the output path (o) are stored while parsing the options.

However, the partition name is not validated before passing it to osafeload




NEXT




<s> static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to enable QoS functions. It configures
qdisc, tcf and tc filters.

The below function is used to disable QoS functions. It configures
qdisc, tcf and tc filters.






NEXT




<s> rtk_api_ret_t rtk_svlan_lookupType_set(rtk_svlan_lookupType_t type)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= SVLAN_LOOKUP_END)
return RT_ERR_CHIP_NOT_SUPPORTED;


svlan_lookupType = type;

retVal = rtl8367c_setAsicSvlanLookupType((rtk_uint32)type);

return retVal;
}

The above function is used to set Lookup Type


/*
rtk_api_ret_t rtk_svlan_lookupType_set(rtk_svlan_LookupType_t type)
*/
struct rtk_svlan_




NEXT




<s> t_serveropen(username)
const char * username;
{
struct t_passwd * p;
p = gettpnam(username);
if(p == NULL) {
return NULL;
} else {
return t_serveropenraw(&p->tp, &p->tc);
}
}

The above function is used to open a connection to a character socket or a talk connection. It takes a pointer to a null terminated string of the username.

If the TCP protocol is used, then gettpnam() makes a call to the getpasswd() function




NEXT




<s> int ifxdeu_init_arc4(void)
{
int ret = -ENOSYS;


if ((ret = crypto_register_alg(&ifxdeu_arc4_alg)))
goto arc4_err;

if ((ret = crypto_register_skcipher(&ifxdeu_ecb_arc4_alg)))
goto ecb_arc4_err;

arc4_chip_init ();

CRTCL_SECT_INIT;

printk (KERN_NOTICE "IFX DEU ARC4 initialized%s%s.\n", disable_multiblock ? "" : " (multiblock)", disable_deudma ? "" : " (DMA)");
return ret;

arc4_err:
crypto_unregister_alg(&ifxdeu_arc4_alg);
printk(KERN_ERR "IFX arc4 initialization failed!\n");
return ret;
ecb_arc4_err:
crypto_unregister_skcipher(&ifxdeu_ecb_arc4_alg);
printk (KERN_ERR "IFX ecb_arc4 initialization failed!\n");
return ret;

}

The above function is used to initialize crypto algorithms of ARC4</s>




NEXT




<s> static int wait_dma_not_busy(int device)
{
unsigned int cleanup_required = 0;

/* Poll for DMA completion */
int loops = MAX_DMA_XFER_LOOPS;
do {
if (!dma_busy()) {
break;
}
udelay(100);
} while (--loops);

if (!loops) {
printf("wait_dma_not_busy() Timed out of wait for DMA not busy\n");
cleanup_required = 1;
}

if (cleanup_required) {
/* Abort DMA to make sure it has finished. */
unsigned int ctrl_status = readl(
SATA_DMA_CHANNEL + DMA_CTRL_STATUS);
ctrl_status |= DMA_CTRL_STATUS_RESET;
writel(ctrl_status, SATA_DMA_CHANNEL + DMA_CTRL_STATUS);

// Wait for the channel to become idle - should be quick as should
// finish after the next AHB single or burst transfer
loops = MAX_DMA_ABORT_LOOPS;
do {
if (!dma_busy()) {
break;
}
udelay(10);
} while (--loops);

if (!loops) {
printf("wait_dma_not_busy() Timed out of wait for DMA channel abort\n");
} else {
/* Successfully cleanup the DMA channel */
cleanup_required = 0;
}

// Deassert reset for the channel
ctrl_status = readl(SATA_DMA_CHANNEL + DMA_CTRL_STATUS);
ctrl_status &= ~DMA_CTRL_STATUS_RESET;
writel(ctrl_status, SATA_DMA_CHANNEL + DMA_CTRL_STATUS);
}

return !cleanup_required;
}

The above function is used to check, if DMA is free and waiting
is not required. If not busy, we return true else false. We also
check for any pending transfer using readl and resetting the register
value to 0.

For DMA completion




NEXT




<s> ret_t rtl8367c_setAsicPortMirrorOverride(rtk_uint32 rxMirror, rtk_uint32 txMirror, rtk_uint32 aclMirror)
{
ret_t retVal;

if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_RX_OVERRIDE_EN_OFFSET, rxMirror)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_TX_OVERRIDE_EN_OFFSET, txMirror)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_ACL_OVERRIDE_EN_OFFSET, aclMirror)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable or disable the Rx, Tx asic port mirror traffic based on some external setting. However, after the traffic is mirrored in asic, it should be forwarded to other ports through switch asic. Therefore, the ports




NEXT




<s> ret_t rtl8367c_getAsicPortBasedFid(rtk_uint32 port, rtk_uint32* pFid)
{
rtk_uint32  reg_addr;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
return rtl8367c_getAsicReg(RTL8367C_PORT_PBFID_REG(port), pFid);
else{
reg_addr = RTL8367C_REG_PORT8_PBFID + port-8;
return rtl8367c_getAsicReg(reg_addr, pFid);
}
}

The above function is used to read the Fid. The port index is zero-based, so the return value of the function is port 0 Fid.

### Related articles

We are the leading network solution supplier of China. With our rich products and service




NEXT




<s> static int bcm6328_pcie_can_access(struct pci_bus *bus, int devfn)
{
struct bcm6328_pcie *priv = &bcm6328_pcie;

switch (bus->number) {
case PCIE_BUS_BRIDGE:
return PCI_SLOT(devfn) == 0;
case PCIE_BUS_DEVICE:
if (PCI_SLOT(devfn) == 0)
return __raw_readl(priv->base + PCIE_DLSTATUS_REG)
& DLSTATUS_PHYLINKUP;
fallthrough;
default:
return false;
}
}

The above function is used to determine, given a device identifier of
the form "bus:device.function" whether it is possible to access the
device's resources. If it returns a non-zero value the code attempts to
access the device, otherwise it leaves




NEXT




<s> rtk_uint32 rtk_switch_maxLutAddrNumber_get(void)
{
if(init_state != INIT_COMPLETED)
return 0x00;

return (halCtrl->max_lut_addr_num);
}

The above function is used to get the maximum LUT addresses for a certain chip. The following table gives the values for the different chips.

The LUT addresses on the chip are set to the default values at reset. Some LUT addresses can be used only if they




NEXT




<s> static void lq_sg_init(struct aes_container *aes_con,struct scatterlist *src,
struct scatterlist *dst)
{

struct page *dst_page, *src_page;

src_page = sg_virt(src);
aes_con->src_buf = (char *) src_page;

dst_page = sg_virt(dst);
aes_con->dst_buf = (char *) dst_page;

}

The above function is used to init lq_sg with source and dst buffer
address/size.

static int lq_f_init(struct work_struct *work)
{
int ret;

struct aes_container_list *entry




NEXT




<s> rtl_hw_apply(struct switch_dev *dev)
{
int i;
int trunk_en, trunk_psel;
struct rtl_phyregs port5;

rtl_phy_save(dev, 5, &port5);

/* disable rx/tx from PHYs */
for (i = 0; i < RTL8306_NUM_PORTS - 1; i++) {
rtl_port_set_enable(dev, i, 0);
}

/* save trunking status */
trunk_en = rtl_get(dev, RTL_REG_EN_TRUNK);
trunk_psel = rtl_get(dev, RTL_REG_TRUNK_PORTSEL);

/* trunk port 3 and 4
* XXX: Big WTF, but RealTek seems to do it */
rtl_set(dev, RTL_REG_EN_TRUNK, 1);
rtl_set(dev, RTL_REG_TRUNK_PORTSEL, 1);

/* execute the software reset */
rtl_set(dev, RTL_REG_RESET, 1);

/* wait for the reset to complete,
* but don't wait for too long */
for (i = 0; i < 10; i++) {
if (rtl_get(dev, RTL_REG_RESET) == 0)
break;

msleep(1);
}

/* enable rx/tx from PHYs */
for (i = 0; i < RTL8306_NUM_PORTS - 1; i++) {
rtl_port_set_enable(dev, i, 1);
}

/* restore trunking settings */
rtl_set(dev, RTL_REG_EN_TRUNK, trunk_en);
rtl_set(dev, RTL_REG_TRUNK_PORTSEL, trunk_psel);
rtl_phy_restore(dev, 5, &port5);

rtl_set(dev, RTL_REG_CPU_LINKUP, 1);

return 0;
}

The above function is used to execute the physical switch reset.
The function is executed at boot time of the device to make sure the device is
booted in safe mode and to prevent any unintendad disruption to the network.
It turns the physical switch into




NEXT




<s> ret_t rtl8367c_getAsicStormFilterExtUnknownMulticastMeter(rtk_uint32 *pMeter)
{
if(NULL == pMeter)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG1, RTL8367C_UNMC_STORM_EXT_METERIDX_MASK, pMeter);
}

The above function is used to query the multicast meter index in Unknown Multicast Storm Extremely.

ret_t rtl8367c_setAsicStormFilterExtUnknownMulticastMeter(rtk_uint3




NEXT




<s> static int rtl8366_smi_enable_vlan4k(struct rtl8366_smi *smi, int enable)
{
int err;

if (enable) {
err = smi->ops->enable_vlan(smi, enable);
if (err)
return err;

smi->vlan_enabled = enable;
}

err = smi->ops->enable_vlan4k(smi, enable);
if (err)
return err;

smi->vlan4k_enabled = enable;
return 0;
}

The above function is used to tell the switch that we want VLAN tagging to
be used on every port. However, this only tells the switch that
we’re going to use VLAN tagging. The tagging actually occurs before
we get to the CPU




NEXT




<s> static void aca_rxout_init(struct dc_ep_priv *priv,
struct aca_cfg_param *aca_rxout)
{
u32 val = 0;
struct aca_mem_layout *mem_layout = to_mem_layout(priv);
struct aca_hif_params *hif_params = to_hif_params(priv);
struct aca_hif_param *rxout_param = &hif_params->rxout;

if (aca_rxout->byteswap)
val = BYTE_SWAP_EN;

val |= (aca_rxout->hd_size_in_dw - 1)
| SM((aca_rxout->pd_size_in_dw - 1), PD_DESC_IN_DW);
wr32(val, RXOUT_CONV_CFG);

/* SoC Ring size */
val = aca_rxout->soc_desc_num;
wr32(val, RXOUT_RING_CFG);

/* SoC cumulative counter address */
wr32(aca_rxout->soc_cmlt_cnt_addr, GNRC_RXOUT_CMLT_CNT_ADDR);
/* SoC descriptors */
rxout_param->soc_desc_base = aca_rxout->soc_desc_base;
rxout_param->soc_desc_num = aca_rxout->soc_desc_num;

/* Ping/pong buffer */
rxout_param->pp_buf_base = (u32)priv->phymem
+ mem_layout->rxout_host_desc_base;

rxout_param->pp_buf_num = mem_layout->rxout_host_dnum;

/* PD ring */
rxout_param->pd_desc_base = (u32)priv->phymem
+ aca_rxout->pd_desc_base;
rxout_param->pd_desc_num = aca_rxout->pd_desc_num;

rxout_param->pd_desc_threshold = aca_rxout->pp_buf_desc_num;
dev_dbg(priv->dev, "aca rxout init done\n");
}

The above function is used to setup parameters for each ACA Rx ring.
There are two rings: host ring and PHY ring. The host ring has the buffer as
one DW wide, and the other ring has the buffer as 128 DW




NEXT




<s> void ar9_fw_ver(unsigned int *major, unsigned int *minor)
{
ASSERT(major != NULL, "pointer is NULL");
ASSERT(minor != NULL, "pointer is NULL");

*major = FW_VER_ID->major;
*minor = FW_VER_ID->minor;
}

The above function is used to get the AR9280 firmware version number.


#include <linux/netdevice.h> /* needed for struct nic_data */
#include "ar9130.h"
#include "ar




NEXT




<s> void start(void)
{
serial_console_init();
puts("=== " CONFIG_PROGRAM_NAME " ===\n");

load();

puts("Halting execution.\n");
while (true) {}
}

The above function is used to start execution under RTOS. In that we have invoked our function load in order to load all the modules. Then we have halted the program in order to save energy.

Before we create code_section we must create a module. We




NEXT




<s> IFX_MEI_DebugWrite (DSL_DEV_Device_t * pDev, u32 destaddr,
u32 * databuff, u32 databuffsize)
{
u32 i;
u32 temp = 0x0;
u32 address = 0x0;
u32 *buffer = 0x0;

//      Open the debug port before DMP memory write
IFX_MEI_ControlModeSet (pDev, MEI_MASTER_MODE);

//      For the requested length, write the address and write the data
address = destaddr;
buffer = databuff;
for (i = 0; i < databuffsize; i++) {
temp = *buffer;
_IFX_MEI_DBGLongWordWrite (pDev, ME_DBG_DECODE_DMP1_MASK, address, temp);
address += 4;
buffer++;
}

//      Close the debug port after DMP memory write
IFX_MEI_ControlModeSet (pDev, JTAG_MASTER_MODE);

return DSL_DEV_MEI_ERR_SUCCESS;
}

The above function is used to write data directly to DMP memory over the debug port. If it is called successfully, the function returns “DSL_DEV_MEI_ERR_SUCCESS”. The buffer contains u32 data units that are passed to the function, and




NEXT




<s> rtk_api_ret_t rtk_vlan_get(rtk_vlan_t vid, rtk_vlan_cfg_t *pVlanCfg)
{
rtk_api_ret_t retVal;
rtk_uint32 phyMbrPmask;
rtk_uint32 phyUntagPmask;
rtl8367c_user_vlan4kentry vlan4K;
rtl8367c_vlanconfiguser vlanMC;
rtk_uint32 idx;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* vid must be 0~8191 */
if (vid > RTL8367C_EVIDMAX)
return RT_ERR_VLAN_VID;

/* Null pointer check */
if(NULL == pVlanCfg)
return RT_ERR_NULL_POINTER;

if (vid <= RTL8367C_VIDMAX)
{
vlan4K.vid = vid;

if ((retVal = rtl8367c_getAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
return retVal;

phyMbrPmask   = vlan4K.mbr;
phyUntagPmask = vlan4K.untag;
if(rtk_switch_portmask_P2L_get(phyMbrPmask, &(pVlanCfg->mbr)) != RT_ERR_OK)
return RT_ERR_FAILED;

if(rtk_switch_portmask_P2L_get(phyUntagPmask, &(pVlanCfg->untag)) != RT_ERR_OK)
return RT_ERR_FAILED;

pVlanCfg->ivl_en    = vlan4K.ivl_svl;
pVlanCfg->fid_msti  = vlan4K.fid_msti;
pVlanCfg->envlanpol = vlan4K.envlanpol;
pVlanCfg->meteridx  = vlan4K.meteridx;
pVlanCfg->vbpen     = vlan4K.vbpen;
pVlanCfg->vbpri     = vlan4K.vbpri;
}
else
{
for (idx = 0; idx <= RTL8367C_CVIDXMAX; idx++)
{
if(vlan_mbrCfgUsage[idx] == MBRCFG_USED_BY_VLAN)
{
if(vlan_mbrCfgVid[idx] == vid)
{
if ((retVal = rtl8367c_getAsicVlanMemberConfig(idx, &vlanMC)) != RT_ERR_OK)
return retVal;

phyMbrPmask   = vlanMC.mbr;
if(rtk_switch_portmask_P2L_get(phyMbrPmask, &(pVlanCfg->mbr)) != RT_ERR_OK)
return RT_ERR_FAILED;

pVlanCfg->untag.bits[0] = 0;
pVlanCfg->ivl_en    = 0;
pVlanCfg->fid_msti  = vlanMC.fid_msti;
pVlanCfg->envlanpol = vlanMC.envlanpol;
pVlanCfg->meteridx  = vlanMC.meteridx;
pVlanCfg->vbpen     = vlanMC.vbpen;
pVlanCfg->vbpri     = vlanMC.vbpri;
}
}
}
}

return RT_ERR_OK;
}

The above function is used to read in the vlan settings.
When the vid parameter is not > RTL8367C_VIDMAX, we query for the value of the vid from the 4KB vlan table, as well as from the 




NEXT




<s> uc_wpas_remove_iface(uc_vm_t *vm, size_t nargs)
{
struct wpa_supplicant *wpa_s = NULL;
uc_value_t *ifname_arg = uc_fn_arg(0);
const char *ifname = ucv_string_get(ifname_arg);
int ret = -1;

if (!ifname)
goto out;

for (wpa_s = wpa_global->ifaces; wpa_s; wpa_s = wpa_s->next)
if (!strcmp(wpa_s->ifname, ifname))
break;

if (!wpa_s)
goto out;

ret = wpa_supplicant_remove_iface(wpa_global, wpa_s, 0);
wpas_ucode_update_interfaces();

out:
return ucv_int64_new(ret);
}

The above function is used to removed the WiFi network interface.</s>




NEXT




<s> static inline void mr18_init(void) { }

The above function is used to initialize the module when it is loaded into the running Linux kernel.
This is done because the driver (or any other module) cannot know whether the other module is already loaded when it loads its own. The “mr18” driver contains more




NEXT




<s> rtk_api_ret_t rtk_vlan_reservedVidAction_set(rtk_vlan_resVidAction_t action_vid0, rtk_vlan_resVidAction_t action_vid4095)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(action_vid0 >= RESVID_ACTION_END)
return RT_ERR_INPUT;

if(action_vid4095 >= RESVID_ACTION_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setReservedVidAction((rtk_uint32)action_vid0, (rtk_uint32)action_vid4095)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set reserved VLAN action table. Please refer to API_032_RTK_Config_VLAN_ReservedVid_Action for description</s>




NEXT




<s> static int __init mtdsplit_elf_init(void)
{
register_mtd_parser(&mtdsplit_elf_parser);

return 0;
}

The above function is used to register a function that is able to handle an
ELF file.

In the mtdsplit_elf_parse() function, the parser function is called from
within a loop when parsing the ELF file. The loop is




NEXT




<s> static inline int rtl839x_tbl_access_data_0(int i)
{
return RTL839X_TBL_ACCESS_DATA_0(i);
}

The above function is used to access mac_addr_bak[]. Since rtl839x_tbl_access_data_0 is declared to be
static inline, the GCC compiler is supposed to generate a macro, which is expected to call RTL




NEXT




<s> ret_t rtl8367c_setAsicMIBsTimer(rtk_uint32 timer)
{
return rtl8367c_setAsicRegBits(RTL8367C_REG_MIB_CTRL4, RTL8367C_MIB_TIMER_MASK, timer);
}

The above function is used to set the MIB Counter Timer. The 26 bit wide MIBCNTVAL register stores the values of all 32 MIB Counters, and this register is updated with the values of these MIB Counters every 1




NEXT




<s> int Program_From_MCI(void)
{
int i;
unsigned int Max_Read_DataBlock_Length;
int block = 0;
int buffer = AT91C_DOWNLOAD_BASE_ADDRESS;
int bufpos = AT91C_DOWNLOAD_BASE_ADDRESS;
int NbPage = 0;
struct trx_header *p;

p = (struct trx_header *)bufpos;

Max_Read_DataBlock_Length = MCI_Device.pMCI_DeviceFeatures->Max_Read_DataBlock_Length;

AT91F_MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);

AT91F_MCI_ReadBlockSwab(&MCI_Device, block*Max_Read_DataBlock_Length, (unsigned int *)bufpos, Max_Read_DataBlock_Length);

if (p->magic != TRX_MAGIC) {
printf("Inv IMG 0x%08x\n", p->magic);
return FALSE;
}

printf("RDSD");
AT91C_BASE_PIOC->PIO_CODR = AT91C_PIO_PC7 | AT91C_PIO_PC15 | AT91C_PIO_PC8 | AT91C_PIO_PC14;
for (i=0; i<(p->len/512); i++) {
AT91F_MCI_ReadBlockSwab(&MCI_Device, block*Max_Read_DataBlock_Length, (unsigned int *)bufpos, Max_Read_DataBlock_Length);
block++;
bufpos += Max_Read_DataBlock_Length;
}

NbPage = 0;
i = dataflash_info[0].Device.pages_number;
while(i >>= 1)
NbPage++;
i = ((p->offsets[1] - p->offsets[0])/ 512) + 1 + (NbPage << 13) + (dataflash_info[0].Device.pages_size << 17);
*(int *)(buffer + p->offsets[0] + AT91C_OFFSET_VECT6) = i;

printf(" WDFB");
AT91C_BASE_PIOC->PIO_CODR = AT91C_PIO_PC7 | AT91C_PIO_PC15 | AT91C_PIO_PC14;
AT91C_BASE_PIOC->PIO_SODR = AT91C_PIO_PC8;
write_dataflash(0xc0000000, buffer + p->offsets[0], p->offsets[1] - p->offsets[0]);
printf(" WUB");
AT91C_BASE_PIOC->PIO_CODR = AT91C_PIO_PC7 | AT91C_PIO_PC15;
AT91C_BASE_PIOC->PIO_SODR = AT91C_PIO_PC8 | AT91C_PIO_PC14;
write_dataflash(0xc0008000, buffer + p->offsets[1], p->offsets[2] - p->offsets[1]);
printf(" WKRFS");
AT91C_BASE_PIOC->PIO_CODR = AT91C_PIO_PC8 | AT91C_PIO_PC15;
AT91C_BASE_PIOC->PIO_SODR = AT91C_PIO_PC7 | AT91C_PIO_PC14;
write_dataflash(0xc0042000, buffer + p->offsets[2], p->len - p->offsets[2]);
AT91C_BASE_PIOC->PIO_CODR = AT91C_PIO_PC8 | AT91C_PIO_PC14;
AT91C_BASE_PIOC->PIO_SODR = AT91C_PIO_PC7 | AT91C_PIO_PC15;
return TRUE;
}

The above function is used to copy an ARM920T program from SD onto dataflash. It reads a block of bytes from the SD (it is read in M32-bit mode) and writes it on dataflash. Then it calls the AT91C




NEXT




<s> static int mt7621_nfc_write_oob_raw(struct nand_chip *nand, int page)
{
return mt7621_nfc_write_page_raw(nand, NULL, 1, page);
}

The above function is used to write OOB data.

int mt7621_nfc_write_oob(struct mtd_info *mtd, struct mtd_oob_ops *ops)
{
return mt762




NEXT




<s> ret_t rtl8367c_setAsicIGMPBypassGroup(rtk_uint32 bypassType, rtk_uint32 enabled)
{
ret_t   retVal;
rtk_uint32 offset;

switch(bypassType)
{
case BYPASS_224_0_0_X:
offset = RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_0_OFFSET;
break;
case BYPASS_224_0_1_X:
offset = RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_1_OFFSET;
break;
case BYPASS_239_255_255_X:
offset = RTL8367C_IGMP_MLD_IP4_BYPASS_239_255_255_OFFSET;
break;
case BYPASS_IPV6_00XX:
offset = RTL8367C_IGMP_MLD_IP6_BYPASS_OFFSET;
break;
default:
return RT_ERR_INPUT;
}

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG3, offset, enabled);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable 224/239 broadcast IP/IPV6 bypass.


ret_t rtl8367c_setBypassIp(rtk_uint32 bypassIpType, r




NEXT




<s> int AT91F_MCI_WriteBlock(
AT91PS_MciDevice pMCI_Device,
int dest,
unsigned int *dataBuffer,
int sizeToWrite )
{
////////////////////////////////////////////////////////////////////////////////////////////
if( pMCI_Device->pMCI_DeviceDesc->state != AT91C_MCI_IDLE)
return AT91C_WRITE_ERROR;

if( (AT91F_MCI_GetStatus(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address) & AT91C_SR_READY_FOR_DATA) != AT91C_SR_READY_FOR_DATA)
return AT91C_WRITE_ERROR;

if ( (dest + sizeToWrite) > pMCI_Device->pMCI_DeviceFeatures->Memory_Capacity )
return AT91C_WRITE_ERROR;

// If source does not fit a begin of a block
if ( (dest % pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length) != 0 )
return AT91C_WRITE_ERROR;

// Test if the MMC supports Partial Write Block
if( (sizeToWrite < pMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length)
&& (pMCI_Device->pMCI_DeviceFeatures->Write_Partial == 0x00) )
return AT91C_WRITE_ERROR;

if( sizeToWrite > pMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length )
return AT91C_WRITE_ERROR;
////////////////////////////////////////////////////////////////////////////////////////////

// Init Mode Register
AT91C_BASE_MCI->MCI_MR |= ((pMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length << 16) | AT91C_MCI_PDCMODE);

if (sizeToWrite %4)
sizeToWrite = (sizeToWrite /4)+1;
else
sizeToWrite = sizeToWrite/4;

// Init PDC for write sequence
AT91C_BASE_PDC_MCI->PDC_PTCR = (AT91C_PDC_TXTDIS | AT91C_PDC_RXTDIS);
AT91C_BASE_PDC_MCI->PDC_TPR = (unsigned int) dataBuffer;
AT91C_BASE_PDC_MCI->PDC_TCR = sizeToWrite;

// Send the write single block command
if ( AT91F_MCI_SendCommand(pMCI_Device, AT91C_WRITE_BLOCK_CMD, dest) != AT91C_CMD_SEND_OK)
return AT91C_WRITE_ERROR;

pMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_TX_SINGLE_BLOCK;

// Enable AT91C_MCI_TXBUFE Interrupt
AT91C_BASE_MCI->MCI_IER = AT91C_MCI_TXBUFE;

// Enables TX for PDC transfert requests
AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_TXTEN;

return AT91C_WRITE_OK;
}

The above function is used to write multiple blocks of data to media. The main function to write/ read the data is MCI_PDC. Here is MCI_PDC details.

This data structure contains two fields :

* PDC_TSR




NEXT




<s> void _nfc_dbg(struct ar934x_nfc *nfc, const char *fmt, ...)
{
}

The above function is used to dump debug information about the nfc device
(see _AR933x_NFC: Debugging) but it was never implemented correctly. Instead,
the function just does nothing. This makes it impossible to debug the nfc device




NEXT




<s> static int b53_global_get_ports(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct b53_device *priv = sw_to_b53(dev);

val->len = snprintf(priv->buf, B53_BUF_SIZE, "0x%04x",
priv->enabled_ports);
val->value.s = priv->buf;

return 0;
}

The above function is used to tell Linux Switch API to return the
number of enabled ports.</s>




NEXT




<s> static void udebug_hexdump_hook(int level, const char *title,
const void *data, size_t len)
{
char *buf;

udebug_entry_init(&ud_log);
udebug_entry_printf(&ud_log, "%s - hexdump:", title);
buf = udebug_entry_append(&ud_log, NULL, 3 * len);
for (size_t i = 0; i < len; i++)
buf += sprintf(buf, " %02x", *(uint8_t *)(data + i));
udebug_entry_add(&ud_log);
}

The above function is used to show a hexdump of data in a log message.
For example:

void hexdump_debug(uint8_t * data, size_t size) {
udebug_hexdump_hook(UDLEVEL




NEXT




<s> int ecb_des_decrypt(struct skcipher_request *req)
{
struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int dec_bytes, nbytes;

DPRINTF(1, "\n");
err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = dec_bytes = walk.nbytes)) {
dec_bytes -= (nbytes % DES_BLOCK_SIZE);
ifx_deu_des_ecb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
NULL, dec_bytes, CRYPTO_DIR_DECRYPT, 0);
nbytes &= DES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

return err;
}

The above function is used to perform ecb encryption mode using the
des_setkey function.

In the init function of the driver, the driver needs to set the key of the
algorithm. For this, the des_setkey function is used. In this




NEXT




<s> void rtk_hal_add_table(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;
rtk_l2_ucastAddr_t l2_entry;
rtk_mac_t mac;

mac.octet[0] =data->mac[0];
mac.octet[1] =data->mac[1];
mac.octet[2] =data->mac[2];
mac.octet[3] =data->mac[3];
mac.octet[4] =data->mac[4];
mac.octet[5] =data->mac[5];

memset(&l2_entry, 0x00, sizeof(rtk_l2_ucastAddr_t));
l2_entry.port = data->port;
l2_entry.ivl = 1;
l2_entry.cvid = data->vid;
l2_entry.fid = 0;
l2_entry.efid = 0;
l2_entry.is_static = 1;
ret = rtk_l2_addr_add(&mac, &l2_entry);
if (ret != RT_ERR_OK)
printk("rtk_hal_add_table failed\n");
}

The above function is used to add a static L2 entry.
Below is a sample code that uses rtk_hal_add_table function:

int rtk_hal_add_table(struct ra_switch_ioctl_data *data)





NEXT




<s> void rtl838x_traffic_enable(int source, int dest)
{
rtl838x_mask_port_reg(0, BIT(dest), rtl838x_port_iso_ctrl(source));
}

The above function is used to enable port traffic, so that the Rx/Tx is enabled on these ports.

rtl838x_mask_port_reg() function is defined as below in the RTL88E1 driver code:






NEXT




<s> static void rb4xx_nand_read_buf(struct nand_chip *chip, u8 *buf, int len)
{
struct rb4xx_nand *nand = chip->priv;
struct rb4xx_cpld *cpld = nand->cpld;

cpld->read_nand(cpld, buf, len);
}

The above function is used to read data directly from FLASH memory.
In addition, we also need to implement the write function, using the reverse-address and write data from the CPU, the corresponding function definition as below:

static void rb4xx_nand




NEXT




<s> ret_t rtl8367c_getAsicMIBsResetValue(rtk_uint32* value)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_CTRL0, RTL8367C_RESET_VALUE_OFFSET, value);
}

The above function is used to get the MIBC reset val.
From the mib, you can see that the value is already 0, so you can ignore this function.

[code type=cpp]
if ((*value == 0)){  //




NEXT




<s> static int aw9523_get_pin_direction(struct regmap *regmap, u8 pin, u8 n)
{
int val, ret;

ret = regmap_read(regmap, AW9523_REG_CONF_STATE(pin), &val);
if (ret < 0)
return ret;

return (val & BIT(n)) == BIT(n);
}

The above function is used to query direction of AW9523 pin.
Here we take pin 3 as an example to illustrate.
For pin 3,
-bit 1 is the direction bit of C3,
-bit 2 is




NEXT




<s> static void reset_menu(void)
{
unpost_menu(curses_menu);
clean_items();
}

The above function is used to reset the menu. The menu has three sections – menu top, menu bottom and menu middle. The menu needs to be reset if the user selects on an item that causes the menu to be in an unwanted state – for example back button pressed




NEXT




<s> static void sprom_extract_r458(struct ssb_sprom *out, const u16 *in)
{
SPEX(txpid2g[0], SSB_SPROM4_TXPID2G01,
SSB_SPROM4_TXPID2G0, SSB_SPROM4_TXPID2G0_SHIFT);
SPEX(txpid2g[1], SSB_SPROM4_TXPID2G01,
SSB_SPROM4_TXPID2G1, SSB_SPROM4_TXPID2G1_SHIFT);
SPEX(txpid2g[2], SSB_SPROM4_TXPID2G23,
SSB_SPROM4_TXPID2G2, SSB_SPROM4_TXPID2G2_SHIFT);
SPEX(txpid2g[3], SSB_SPROM4_TXPID2G23,
SSB_SPROM4_TXPID2G3, SSB_SPROM4_TXPID2G3_SHIFT);

SPEX(txpid5gl[0], SSB_SPROM4_TXPID5GL01,
SSB_SPROM4_TXPID5GL0, SSB_SPROM4_TXPID5GL0_SHIFT);
SPEX(txpid5gl[1], SSB_SPROM4_TXPID5GL01,
SSB_SPROM4_TXPID5GL1, SSB_SPROM4_TXPID5GL1_SHIFT);
SPEX(txpid5gl[2], SSB_SPROM4_TXPID5GL23,
SSB_SPROM4_TXPID5GL2, SSB_SPROM4_TXPID5GL2_SHIFT);
SPEX(txpid5gl[3], SSB_SPROM4_TXPID5GL23,
SSB_SPROM4_TXPID5GL3, SSB_SPROM4_TXPID5GL3_SHIFT);

SPEX(txpid5g[0], SSB_SPROM4_TXPID5G01,
SSB_SPROM4_TXPID5G0, SSB_SPROM4_TXPID5G0_SHIFT);
SPEX(txpid5g[1], SSB_SPROM4_TXPID5G01,
SSB_SPROM4_TXPID5G1, SSB_SPROM4_TXPID5G1_SHIFT);
SPEX(txpid5g[2], SSB_SPROM4_TXPID5G23,
SSB_SPROM4_TXPID5G2, SSB_SPROM4_TXPID5G2_SHIFT);
SPEX(txpid5g[3], SSB_SPROM4_TXPID5G23,
SSB_SPROM4_TXPID5G3, SSB_SPROM4_TXPID5G3_SHIFT);

SPEX(txpid5gh[0], SSB_SPROM4_TXPID5GH01,
SSB_SPROM4_TXPID5GH0, SSB_SPROM4_TXPID5GH0_SHIFT);
SPEX(txpid5gh[1], SSB_SPROM4_TXPID5GH01,
SSB_SPROM4_TXPID5GH1, SSB_SPROM4_TXPID5GH1_SHIFT);
SPEX(txpid5gh[2], SSB_SPROM4_TXPID5GH23,
SSB_SPROM4_TXPID5GH2, SSB_SPROM4_TXPID5GH2_SHIFT);
SPEX(txpid5gh[3], SSB_SPROM4_TXPID5GH23,
SSB_SPROM4_TXPID5GH3, SSB_SPROM4_TXPID5GH3_SHIFT);
}

The above function is used to extract R442 and R458
sproms into usable values for the ssb chip.

These ssid's are from the driver.txt in the original ssb driver
and not from any linux




NEXT




<s> static void fe_poll_controller(struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);
u32 int_mask = priv->soc->tx_int | priv->soc->rx_int;

fe_int_disable(int_mask);
fe_handle_irq(dev->irq, dev);
fe_int_enable(int_mask);
}

The above function is used to poll RX/TX interrupts and process them
to update received frames RX ring. These interrupts are disabled by
fe_int_clear (). If we poll the device after a transmit timeout error,
the timer which sets the




NEXT




<s> void yyset_debug ( int debug_flag  );

YY_EXTRA_TYPE yyget_extra ( void );

void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to echo any text that matches the last regular expression
that matches some input string, if that text was not actually lexed (used to build a
token) or otherwise processed in some way.
*/

/* Returns the current lex




NEXT




<s> ar8229_hw_init(struct ar8xxx_priv *priv)
{
phy_interface_t phy_if_mode;

if (priv->initialized)
return 0;

ar8xxx_write(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET);
ar8xxx_reg_wait(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET, 0, 1000);

of_get_phy_mode(priv->pdev->of_node, &phy_if_mode);

if (phy_if_mode == PHY_INTERFACE_MODE_GMII) {
ar8xxx_write(priv, AR8229_REG_OPER_MODE0,
AR8229_OPER_MODE0_MAC_GMII_EN);
} else if (phy_if_mode == PHY_INTERFACE_MODE_MII) {
ar8xxx_write(priv, AR8229_REG_OPER_MODE0,
AR8229_OPER_MODE0_PHY_MII_EN);
} else {
pr_err("ar8229: unsupported mii mode\n");
return -EINVAL;
}

if (priv->port4_phy) {
ar8xxx_write(priv, AR8229_REG_OPER_MODE1,
AR8229_REG_OPER_MODE1_PHY4_MII_EN);
/* disable port5 to prevent mii conflict */
ar8xxx_write(priv, AR8216_REG_PORT_STATUS(5), 0);
}

ar8xxx_phy_init(priv);

priv->initialized = true;
return 0;
}

The above function is used to initialize the AR8229 PHY register to operate in Gigabit Ethernet Link.</s>




NEXT




<s> rtk_api_ret_t rtk_switch_maxPktLenCfg_get(rtk_uint32 cfgId, rtk_uint32 *pPktLen)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(cfgId > MAXPKTLEN_CFG_ID_MAX)
return RT_ERR_INPUT;

if(NULL == pPktLen)
return RT_ERR_NULL_POINTER;

if((retVal = rtl8367c_getAsicMaxLengthCfg(cfgId, pPktLen)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read the MAC layer maximum frame size parameters.

rtk_api_ret_t rtk_switch_maxPktLenCfg_set(rtk_uint32 cfgId, rtk_uint32 pktLen)




NEXT




<s> static int rtl8366rb_sw_set_mirror_monitor_port(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

data = RTL8366RB_PMCR_MONITOR_PORT(val->value.i);

return rtl8366_smi_rmwr(smi, RTL8366RB_PMCR, RTL8366RB_PMCR_MONITOR_PORT_MASK, data);
}

The above function is used to set/clear mirror-monitor port.

However we don't need to mirror-monitor port now because we use L2VPN instead of

L2TP.

Then we don't need to modify mirror-monitor




NEXT




<s> rtk_api_ret_t rtk_trap_unknownMcastPktAction_set(rtk_port_t port, rtk_mcast_type_t type, rtk_trap_mcast_action_t mcast_action)
{
rtk_api_ret_t retVal;
rtk_uint32 rawAction;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (type >= MCAST_END)
return RT_ERR_INPUT;

if (mcast_action >= MCAST_ACTION_END)
return RT_ERR_INPUT;


switch (type)
{
case MCAST_L2:
if (MCAST_ACTION_ROUTER_PORT == mcast_action)
return RT_ERR_INPUT;
else if(MCAST_ACTION_DROP_EX_RMA == mcast_action)
rawAction = L2_UNKOWN_MULTICAST_DROP_EXCLUDE_RMA;
else
rawAction = (rtk_uint32)mcast_action;

if ((retVal = rtl8367c_setAsicUnknownL2MulticastBehavior(rtk_switch_port_L2P_get(port), rawAction)) != RT_ERR_OK)
return retVal;

break;
case MCAST_IPV4:
if (MCAST_ACTION_DROP_EX_RMA == mcast_action)
return RT_ERR_INPUT;
else
rawAction = (rtk_uint32)mcast_action;

if ((retVal = rtl8367c_setAsicUnknownIPv4MulticastBehavior(rtk_switch_port_L2P_get(port), rawAction)) != RT_ERR_OK)
return retVal;

break;
case MCAST_IPV6:
if (MCAST_ACTION_DROP_EX_RMA == mcast_action)
return RT_ERR_INPUT;
else
rawAction = (rtk_uint32)mcast_action;

if ((retVal = rtl8367c_setAsicUnknownIPv6MulticastBehavior(rtk_switch_port_L2P_get(port), rawAction)) != RT_ERR_OK)
return retVal;

break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to set unknown multicast behavior. The possible
arguments are shown below.

|Argument Name               |Explanation                            |
|----------------------------|---------------------------------------|
|port                        |Input/output port.                    




NEXT




<s> static int rtl83xx_handle_changeupper(struct rtl838x_switch_priv *priv,
struct net_device *ndev,
struct netdev_notifier_changeupper_info *info)
{
struct net_device *upper = info->upper_dev;
struct netdev_lag_upper_info *lag_upper_info = NULL;
int i, j, err;

if (!netif_is_lag_master(upper))
return 0;

mutex_lock(&priv->reg_mutex);

for (i = 0; i < priv->n_lags; i++) {
if ((!priv->lag_devs[i]) || (priv->lag_devs[i] == upper))
break;
}
for (j = 0; j < priv->cpu_port; j++) {
if (priv->ports[j].dp->slave == ndev)
break;
}
if (j >= priv->cpu_port) {
err = -EINVAL;
goto out;
}

if (info->linking) {
lag_upper_info = info->upper_info;
if (!priv->lag_devs[i])
priv->lag_devs[i] = upper;
err = rtl83xx_lag_add(priv->ds, i, priv->ports[j].dp->index, lag_upper_info);
if (err) {
err = -EINVAL;
goto out;
}
} else {
if (!priv->lag_devs[i])
err = -EINVAL;
err = rtl83xx_lag_del(priv->ds, i, priv->ports[j].dp->index);
if (err) {
err = -EINVAL;
goto out;
}
if (!priv->lags_port_members[i])
priv->lag_devs[i] = NULL;
}

out:
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to handle adding or deleting a device from a link aggregation (LAG). It can be a virtual switch or a physical switch.

The function returns a 0 is function is successful. Otherwise, returns different errors.

See also




NEXT




<s> static int rtl8218d_get_eee(struct phy_device *phydev,
struct ethtool_eee *e)
{
u32 val;
int addr = phydev->mdio.addr;

pr_debug("In %s, port %d, was enabled: %d\n", __func__, addr, e->eee_enabled);

/* Set GPHY page to copper */
phy_write_paged(phydev, RTL821X_PAGE_GPHY, RTL821XEXT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_COPPER);

val = phy_read_paged(phydev, 7, MDIO_AN_EEE_ADV);
if (e->eee_enabled)
e->eee_enabled = !!(val & BIT(7));
pr_debug("%s: enabled: %d\n", __func__, e->eee_enabled);

/* GPHY page to auto */
phy_write_paged(phydev, RTL821X_PAGE_GPHY, RTL821XEXT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_AUTO);

return 0;
}

The above function is used to get the EEE state from the PHY so that the appropriate settings can be applied. But this function never returns the EEE state, so when I call ethtool -e, it shows this port does not support EEE.






NEXT




<s> static void rtl839x_write_cam(int idx, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL8390_TBL_L2, 1); /* Access L2 Table 1 */

rtl839x_fill_l2_row(r, e);

for (int i = 0; i < 3; i++)
sw_w32(r[i], rtl_table_data(q, i));

rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to add a MAC address to the MMU’s filter entry table.

static void rtl839x_del_cam_(int idx,
struct rtl838x_l2_entry *last_entry




NEXT




<s> static int lq_des_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
unsigned int keylen)
{
struct des_ctx *dctx = crypto_ablkcipher_ctx(tfm);

//printk("setkey in %s\n", __FILE__);

dctx->controlr_M = 0;   // des
dctx->key_length = keylen;

memcpy ((u8 *) (dctx->expkey), key, keylen);

return 0;
}

The above function is used to set the key. In des key is 8 bytes. This
key is copied in *dctx->expkey*.

static int
lq_des_decrypt(struct crypto_ablkcipher *tfm, const u




NEXT




<s> int dc_ep_gpio_od_set(struct dc_ep_priv *priv, u32 gpio, int val)
{
struct dc_aca *aca = to_aca(priv);

if (gpio > aca->max_gpio)
return -EINVAL;

mutex_lock(&aca->pin_lock);
if (!!val)
padc_setbit(gpio, PADC_OD);
else
padc_clearbit(gpio, PADC_OD);
mutex_unlock(&aca->pin_lock);
return 0;
}

The above function is used to configure the output drive strength for the pads that make up the GPIOs exposed to the platform's GPIO framework. PADCFG is a fixed address register and as such cannot be configured during runtime. Therefore, when a GPIO request is passed through




NEXT




<s> rtk_api_ret_t rtk_qos_schedulingQueue_set(rtk_port_t port, rtk_qos_queue_weights_t *pQweights)
{
rtk_api_ret_t retVal;
rtk_uint32 qid;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

for (qid = 0; qid < RTL8367C_QUEUENO; qid ++)
{

if (pQweights->weights[qid] > QOS_WEIGHT_MAX)
return RT_ERR_QOS_QUEUE_WEIGHT;

if (0 == pQweights->weights[qid])
{
if ((retVal = rtl8367c_setAsicQueueType(rtk_switch_port_L2P_get(port), qid, QTYPE_STRICT)) != RT_ERR_OK)
return retVal;
}
else
{
if ((retVal = rtl8367c_setAsicQueueType(rtk_switch_port_L2P_get(port), qid, QTYPE_WFQ)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicWFQWeight(rtk_switch_port_L2P_get(port),qid, pQweights->weights[qid])) != RT_ERR_OK)
return retVal;
}
}

return RT_ERR_OK;
}

The above function is used to set scheduling for queue (e.g. WFQ and QOS Weight) for port.</s>




NEXT




<s> static void esw_set_gsc(struct rt305x_esw *esw)
{
esw_rmw(esw, RT305X_ESW_REG_SGC,
RT305X_ESW_GSC_BC_STROM_MASK << RT305X_ESW_GSC_BC_STROM_SHIFT,
esw->bc_storm_protect << RT305X_ESW_GSC_BC_STROM_SHIFT);
esw_rmw(esw, RT305X_ESW_REG_SGC,
RT305X_ESW_GSC_LED_FREQ_MASK << RT305X_ESW_GSC_LED_FREQ_SHIFT,
esw->led_frequency << RT305X_ESW_GSC_LED_FREQ_SHIFT);
}

The above function is used to set the GSC
Register value of EH6, and it is in the RT305X
driver file. But the GSC register value is
different between the EH6 and EH7. So we need





NEXT




<s> static unsigned int wait_not_busy(int device, unsigned long timeout_secs)
{
int busy = 1;
unsigned long loops = (timeout_secs * 1000) / 50;
do {
// Test the ATA status register BUSY flag
if (!((*(sata_regs_base[device] + SATA_ORB2_OFF)
>> SATA_COMMAND_BIT) & (1UL << ATA_STATUS_BSY_BIT))) {
/* Not busy, so stop polling */
busy = 0;
break;
}

// Wait for 50mS before sampling ATA status register again
udelay(50000);
} while (--loops);

return busy;
}

The above function is used to determine if the host controller is free or not. If not then we have to wait because we can not issue any DMA command to the device which is being used by other DMA traffic. ATA commands do not have any kind of response codes such as




NEXT




<s> send_ping(void)
{
msg->type = htonl(EAD_TYPE_PING);
msg->len = 0;
return send_packet(EAD_TYPE_PONG, handle_pong, (nid == 0xffff ? 0 : 1));
}

The above function is used to send a TCP ping packet to the other end of a TCP link. The following is the implementation of the handle_pong callback for this ping packet. It is used to let the end of the TCP link know that a TCP ping




NEXT




<s> rtk_api_ret_t rtk_l2_aging_set(rtk_l2_age_time_t aging_time)
{
rtk_uint32 i;
CONST_T rtk_uint32 agePara[10][3] = {
{45, 0, 1}, {88, 0, 2}, {133, 0, 3}, {177, 0, 4}, {221, 0, 5}, {266, 0, 6}, {310, 0, 7},
{354, 2, 6}, {413, 2, 7}, {458, 3, 7}};

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (aging_time>agePara[9][0])
return RT_ERR_OUT_OF_RANGE;

for (i = 0; i<10; i++)
{
if (aging_time<=agePara[i][0])
{
return rtl8367c_setAsicLutAgeTimerSpeed(agePara[i][2], agePara[i][1]);
}
}

return RT_ERR_FAILED;
}

The above function is used to set the L2 aging mechanism for aging timers. Set the value of the aging timer, The aging timer is set. The default value 0 means 1s as L3 does.

The default value is 55 when L




NEXT




<s> void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)
{
menu_add_prop(type, expr_alloc_symbol(sym), dep);
}

The above function is used to register a symbol to the menu system for further use.</s>




NEXT




<s> int ag71xx_phy_connect(struct ag71xx *ag)
{
struct device_node *np = ag->pdev->dev.of_node;
struct device_node *phy_node;
int ret;

if (of_phy_is_fixed_link(np)) {
ret = of_phy_register_fixed_link(np);
if (ret < 0) {
dev_err(&ag->pdev->dev,
"Failed to register fixed PHY link: %d\n", ret);
return ret;
}

phy_node = of_node_get(np);
} else {
phy_node = of_parse_phandle(np, "phy-handle", 0);
}

if (!phy_node) {
dev_err(&ag->pdev->dev,
"Could not find valid phy node\n");
return -ENODEV;
}

ag->phy_dev = of_phy_connect(ag->dev, phy_node, ag71xx_phy_link_adjust,
0, ag->phy_if_mode);

of_node_put(phy_node);

if (!ag->phy_dev) {
dev_err(&ag->pdev->dev,
"Could not connect to PHY device. Deferring probe.\n");
return -EPROBE_DEFER;
}

dev_info(&ag->pdev->dev, "connected to PHY at %s [uid=%08x, driver=%s]\n",
phydev_name(ag->phy_dev),
ag->phy_dev->phy_id, ag->phy_dev->drv->name);

return 0;
}

The above function is used to connect ag71xx PHY to a PHY device. The function
parses an eeprom string using a simple string parsing pattern.</s>




NEXT




<s> ret_t rtl8367c_getAsicTrunkingFc(rtk_uint32 group, rtk_uint32* pEnabled)
{
if(group > RTL8367C_MAX_TRUNK_GID)
return RT_ERR_LA_TRUNK_ID;

return rtl8367c_getAsicRegBit(RTL8367C_REG_PORT_TRUNK_FLOWCTRL, (RTL8367C_EN_FLOWCTRL_TG0_OFFSET + group), pEnabled);
}

The above function is used to enable the Fc flow control in group. This function will enable and disable the FCTF in the hardware based on the pEnabled.</s>




NEXT




<s> void wpas_ucode_free(void)
{
if (wpa_ucode_call_prepare("shutdown") == 0)
ucv_put(wpa_ucode_call(0));
wpa_ucode_free_vm();
}

The above function is used to free resources for the u-blox uart driver. It would be prudent to make it a generic function applicable to all USB devices. Note that it is currently called by a USB service routine so it really has nothing to do with Wi




NEXT




<s> static int clk_mt7986_apmixed_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;

clk_data = mtk_alloc_clk_data(ARRAY_SIZE(plls));
if (!clk_data)
return -ENOMEM;

mtk_clk_register_plls(node, plls, ARRAY_SIZE(plls), clk_data);

clk_prepare_enable(clk_data->clks[CLK_APMIXED_ARMPLL]);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_apmixed_data;
}
return r;

free_apmixed_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to enable the CPU clock to the AP mixer.</s>




NEXT




<s> static int ssb_fbs_probe(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct device_node *node = dev->of_node;
struct ssb_fbs *priv;
unsigned long flags;
u8 mac[ETH_ALEN];

priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
if (!priv)
return -ENOMEM;

priv->dev = dev;

ssb_fbs_set(priv, node);

of_property_read_u32(node, "pci-bus", &priv->pci_bus);
of_property_read_u32(node, "pci-dev", &priv->pci_dev);

of_get_mac_address(node, mac);
if (is_valid_ether_addr(mac)) {
dev_info(dev, "mtd mac %pM\n", mac);
} else {
eth_random_addr(mac);
dev_info(dev, "random mac %pM\n", mac);
}

memcpy(priv->sprom.il0mac, mac, ETH_ALEN);
memcpy(priv->sprom.et0mac, mac, ETH_ALEN);
memcpy(priv->sprom.et1mac, mac, ETH_ALEN);
memcpy(priv->sprom.et2mac, mac, ETH_ALEN);

spin_lock_irqsave(&ssb_fbs_lock, flags);
list_add(&priv->list, &ssb_fbs_list);
spin_unlock_irqrestore(&ssb_fbs_lock, flags);

dev_info(dev, "registered SPROM for [%x:%x]\n",
priv->pci_bus, priv->pci_dev);

return 0;
}

The above function is used to register an ssb_fbs probe callback.The ssb_fbs_probe function will be activated when the platform_device “ssb_fbs” is detected.The first line of the function is ssb_fbs_




NEXT




<s> static enum string_value_kind expr_parse_string(const char *str,
enum symbol_type type,
union string_value *val)
{
char *tail;
enum string_value_kind kind;

errno = 0;
switch (type) {
case S_BOOLEAN:
case S_TRISTATE:
val->s = !strcmp(str, "n") ? 0 :
!strcmp(str, "m") ? 1 :
!strcmp(str, "y") ? 2 : -1;
return k_signed;
case S_INT:
val->s = strtoll(str, &tail, 10);
kind = k_signed;
break;
case S_HEX:
val->u = strtoull(str, &tail, 16);
kind = k_unsigned;
break;
default:
val->s = strtoll(str, &tail, 0);
kind = k_signed;
break;
}
return !errno && !*tail && tail > str && isxdigit(tail[-1])
? kind : k_string;
}

The above function is used to parse string literal values in the expression
language. In effect it tries to find the biggest data type that it can
use for the given value. The function is used like this:

expr = parse_expr("12345




NEXT




<s> static int yy_init_globals ( void );

/* Accessor methods to globals.
These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy ( void );

int yyget_debug ( void );

void yyset_debug ( int debug_flag  );

YY_EXTRA_TYPE yyget_extra ( void );

void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to report any characters
when matching a rule. This is done by calling it
when the rule is matched and any subroutine
which is triggered by it is exited. At this
point you can call _exit() instead or you





NEXT




<s> static int aca_fetch_fw(struct dc_ep_priv *priv)
{
return aca_fetch_fw_api(priv, ACA_FW_FILE);
}

The above function is used to fetch firmware from ACAP, its parameters
includes a pointer to DC EP device private, which then call an
API interface of fetching.

Here we can see, that the source code to fetch firmware from ACAP is a




NEXT




<s> static inline int cw2ecw(int cw)
{
int i;
for (cw++, i = 0; cw; i++) cw >>=1;
return i - 1;
}

The above function is used to calculate equivalent chip count after a change in symbol rate during an FEC mode (Viterbi or Turbo). What it does is to calculate the equivalent chip count with respect to cw2. As can be seen from the above implementation, it




NEXT




<s> static int ag71xx_mdio_remove(struct platform_device *pdev)
{
struct ag71xx_mdio *am = platform_get_drvdata(pdev);

mdiobus_unregister(am->mii_bus);
return 0;
}

The above function is used to remove the mii bus structure and remove all the mii
devices connected to this bus. Mii devices are those kind of devices which are usually
connected to the device’s network interfaces and provide information about the
connection such as network




NEXT




<s> static int esw_set_port_led(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
int idx = val->port_vlan;

if (idx < 0 || idx >= RT305X_ESW_NUM_LEDS)
return -EINVAL;

esw->ports[idx].led = val->value.i;

return 0;
}

The above function is used to initialize the switch for a LED on the port. The port is specified with a port_vlan and the value of the LED is specified with the value_i member of switch_val struct.


struct switch_val get_switch




NEXT




<s> MEIWriteARCValue (u32 address, u32 value)
{
u32 i, check = 0;

/* Write address register */
IFX_MEI_WRITE_REGISTER_L (address,  ME_DBG_WR_AD + LTQ_MEI_BASE_ADDR);

/* Write data register */
IFX_MEI_WRITE_REGISTER_L (value, ME_DBG_DATA + LTQ_MEI_BASE_ADDR);

/* wait until complete - timeout at 40 */
for (i = 0; i < 40; i++) {
check = IFX_MEI_READ_REGISTER_L (ME_ARC2ME_STAT + LTQ_MEI_BASE_ADDR);

if ((check & ARC_TO_MEI_DBG_DONE))
break;
}
/* clear the flag */
IFX_MEI_WRITE_REGISTER_L (ARC_TO_MEI_DBG_DONE, ME_ARC2ME_STAT + LTQ_MEI_BASE_ADDR);
}

The above function is used to write the content of ARC2ME_ADDR
register (address).</s>




NEXT




<s> void draw_shadow(WINDOW * win, int y, int x, int height, int width)
{
int i;

if (has_colors()) {	/* Whether terminal supports color? */
wattrset(win, dlg.shadow.atr);
wmove(win, y + height, x + 2);
for (i = 0; i < width; i++)
waddch(win, winch(win) & A_CHARTEXT);
for (i = y + 1; i < y + height + 1; i++) {
wmove(win, i, x + width);
waddch(win, winch(win) & A_CHARTEXT);
waddch(win, winch(win) & A_CHARTEXT);
}
wnoutrefresh(win);
}
}

The above function is used to update the window to draw a border with a
grey 222 color.

```
	$ wc -c shadow.c
	169    3    0    shadow.c
	$
``




NEXT




<s> ret_t rtl8367c_getAsic1xMBEnConfig(rtk_uint32 port, rtk_uint32 *pEnabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_MAC_ENABLE_REG, port, pEnabled);
}

The above function is used to get the enable status of the 1X port. If 1X is enabled, bit (port_id+26) = 0x01 .

The asic register map is presented according to the MAC_CTRL register




NEXT




<s> static int rtl8366s_sw_get_blinkrate(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366S_LED_BLINKRATE_REG, &data);

val->value.i = (data & (RTL8366S_LED_BLINKRATE_MASK));

return 0;
}

The above function is used to read rtl8366s_led_blinkrate_reg:
rtl8366s_led_blinkrate_reg = read_c0064,</s>




NEXT




<s> static int rtl8366s_sw_get_port_led(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data = 0;

if (val->port_vlan >= RTL8366S_NUM_LEDGROUPS)
return -EINVAL;

rtl8366_smi_read_reg(smi, RTL8366S_LED_CTRL_REG, &data);
val->value.i = (data >> (val->port_vlan * 4)) & 0x000F;

return 0;
}

The above function is used to return the port LED status for
another driver to read. Port LED control is handled by a driver
module called p9_led and not by the host system itself. This
means that if the host decides to turn on another LED




NEXT




<s> static int fe_init_dma(struct fe_priv *priv)
{
int err;

err = fe_alloc_tx(priv);
if (err)
return err;

err = fe_alloc_rx(priv);
if (err)
return err;

return 0;
}

The above function is used to initialize the DMA for the given network interface.

Please note that the order of initialization the Tx and Rx buffers is not important.  However, the first argument to the fe_alloc_tx() and fe_alloc_rx()




NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_template_set(rtk_filter_template_t *aclTemplate)
{
rtk_api_ret_t retVal;
rtk_uint32 idxField;
rtl8367c_acltemplate_t aclType;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(aclTemplate->index >= RTK_MAX_NUM_OF_FILTER_TYPE)
return RT_ERR_INPUT;

for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField++)
{
if(aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_DMAC_15_0 ||
(aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_CTAG && aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_IPV4_SIP_15_0 ) ||
(aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_IPV4_DIP_31_16 && aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_IPV6_SIP_15_0 ) ||
(aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_IPV6_DIP_31_16 && aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_VIDRANGE ) ||
(aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_FIELD_VALID && aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_FIELD_SELECT00 ) ||
aclTemplate->fieldType[idxField] >= FILTER_FIELD_RAW_END)
{
return RT_ERR_INPUT;
}
}

for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField++)
{
aclType.field[idxField] = aclTemplate->fieldType[idxField];
}

if((retVal = rtl8367c_setAsicAclTemplate(aclTemplate->index, &aclType)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set a template of a packet filter for igrAcl.

# <filter_type>:
#    The type of the function.

# <aclTemplate>:
#    The pointer of filter template struct,
#   




NEXT




<s> static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to enable and disable WAN QoS.

#define PTM_TX_DATA_PACKETS     0x01
#define PTM_TX_DATA_MCAST       0x02
#define PTM




NEXT




<s> static int b53_mmap_write48(struct b53_device *dev, u8 page, u8 reg,
u64 value)
{
if (WARN_ON(reg % 2))
return -EINVAL;

if (reg % 4) {
u32 hi = (u32)(value >> 16);
u16 lo = (u16)value;

b53_mmap_write16(dev, page, reg, lo);
b53_mmap_write32(dev, page, reg + 2, hi);
} else {
u16 hi = (u16)(value >> 32);
u32 lo = (u32)value;

b53_mmap_write32(dev, page, reg, lo);
b53_mmap_write16(dev, page, reg + 4, hi);
}

return 0;
}

The above function is used to write 64 bit data to a remote mmio address.
It assumes that the data length is aligned to 58 bit boundary, and the
lower 32 bit of the data to be written in the first 32 bit




NEXT




<s> rtk_api_ret_t rtk_port_phyStatus_get(rtk_port_t port, rtk_port_linkStatus_t *pLinkStatus, rtk_port_speed_t *pSpeed, rtk_port_duplex_t *pDuplex)
{
rtk_api_ret_t retVal;
rtk_uint32 phyData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

if( (NULL == pLinkStatus) || (NULL == pSpeed) || (NULL == pDuplex) )
return RT_ERR_NULL_POINTER;

/*Get PHY resolved register*/
if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_RESOLVED_REG, &phyData)) != RT_ERR_OK)
return retVal;

/*check link status*/
if (phyData & (1<<2))
{
*pLinkStatus = 1;

/*check link speed*/
*pSpeed = (phyData&0x0030) >> 4;

/*check link duplex*/
*pDuplex = (phyData&0x0008) >> 3;
}
else
{
*pLinkStatus = 0;
*pSpeed = 0;
*pDuplex = 0;
}

return RT_ERR_OK;
}

The above function is used to get link status, speed, duplex of rtl8367c port. PHY_RESOLVED_REG is located at E2h(0x52).

rtl8367c_00




NEXT




<s> static void rtl8380_rtl8214fc_on_off(struct phy_device *phydev, bool on)
{
/* fiber ports */
phy_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XEXT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_FIBRE);
phy_modify(phydev, 0x10, BMCR_PDOWN, on ? 0 : BMCR_PDOWN);

/* copper ports */
phy_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XEXT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_COPPER);
phy_modify_paged(phydev, RTL821X_PAGE_POWER, 0x10, BMCR_PDOWN, on ? 0 : BMCR_PDOWN);
}

The above function is used to enable the power down configuration mode.

Now we only need to know when the function is called. We can then see
the configuration mode information being used. LetвЂ™s first use
GDB to find out how the phy




NEXT




<s> static int b53_switch_init_of(struct b53_device *dev)
{
struct device_node *dn, *pn;
const char *alias;
u32 port_num;
u16 ports = 0;

dn = of_get_child_by_name(dev_of_node(dev->dev), "ports");
if (!dn)
return -EINVAL;

for_each_available_child_of_node(dn, pn) {
const char *label;
int len;

if (of_property_read_u32(pn, "reg", &port_num))
continue;

if (port_num > B53_CPU_PORT)
continue;

ports |= BIT(port_num);

label = of_get_property(pn, "label", &len);
if (label && !strcmp(label, "cpu"))
dev->sw_dev.cpu_port = port_num;
}

dev->enabled_ports = ports;

if (!of_property_read_string(dev_of_node(dev->dev), "lede,alias",
&alias))
dev->sw_dev.alias = devm_kstrdup(dev->dev, alias, GFP_KERNEL);

return 0;
}

The above function is used to determine the number of CPU ports enabled and register alias to kernel.

The register alias is to help identify the register block that the CPU-MID register belongs to and register offset within the block. The register alias is encoded as port_id




NEXT




<s> unsigned long long get_ticks(void)
{
return get_timer(0);
}

The above function is used to get the value of timer0 in microseconds

get_ticks is just a wrapper for get_timer in this case.

get_timer is a function that is made by the developers for specific hardware.  You can use it




NEXT




<s> void rtk_hal_qos_set_pri2queue(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;
rtk_qos_pri2queue_t pri2qid;

ret = rtk_qos_priMap_get(8, &pri2qid);
pri2qid.pri2queue[data->qos_queue_num] = data->qos_pri;
ret = rtk_qos_priMap_set(8, &pri2qid);
if (ret != 0)
printk("rtk_qos_priMap_set failed\n");
}

The above function is used to set up specific STPs priority (8).

In rtk_api_ret_t function, the function will return the error code when the function fails.

Here we can check if the function rtk_qos_




NEXT




<s> static int rtl83xx_vlan_add(struct dsa_switch *ds, int port,
const struct switchdev_obj_port_vlan *vlan,
struct netlink_ext_ack *extack)
{
struct rtl838x_vlan_info info;
struct rtl838x_switch_priv *priv = ds->priv;
int err;

pr_debug("%s port %d, vid %d, flags %x\n",
__func__, port, vlan->vid, vlan->flags);

if(!vlan->vid) return 0;

if (vlan->vid > 4095) {
dev_err(priv->dev, "VLAN out of range: %d", vlan->vid);
return -ENOTSUPP;
}

err = rtl83xx_vlan_prepare(ds, port, vlan);
if (err)
return err;

mutex_lock(&priv->reg_mutex);

if (vlan->flags & BRIDGE_VLAN_INFO_PVID)
rtl83xx_vlan_set_pvid(priv, port, vlan->vid);
else if (priv->ports[port].pvid == vlan->vid)
rtl83xx_vlan_set_pvid(priv, port, 0);

/* Get port memberships of this vlan */
priv->r->vlan_tables_read(vlan->vid, &info);

/* new VLAN? */
if (!info.tagged_ports) {
info.fid = 0;
info.hash_mc_fid = false;
info.hash_uc_fid = false;
info.profile_id = 0;
}

/* sanitize untagged_ports - must be a subset */
if (info.untagged_ports & ~info.tagged_ports)
info.untagged_ports = 0;

info.tagged_ports |= BIT_ULL(port);
if (vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED)
info.untagged_ports |= BIT_ULL(port);
else
info.untagged_ports &= ~BIT_ULL(port);

priv->r->vlan_set_untagged(vlan->vid, info.untagged_ports);
pr_debug("Untagged ports, VLAN %d: %llx\n", vlan->vid, info.untagged_ports);

priv->r->vlan_set_tagged(vlan->vid, &info);
pr_debug("Tagged ports, VLAN %d: %llx\n", vlan->vid, info.tagged_ports);

mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to add a VLAN into the switch fabric. The function
starts by getting access to the chip register. It will try to get the port
memberships for this VLAN using the VLAN table registers of the device. After
the




NEXT




<s> static nvram_handle_t * nvram_open_rdonly(void)
{
char *file = nvram_find_staging();

if( file == NULL )
file = nvram_find_mtd();

if( file != NULL ) {
nvram_handle_t *h = nvram_open(file, NVRAM_RO);
if( strcmp(file, NVRAM_STAGING) )
free(file);
return h;
}

return NULL;
}

The above function is used to open readonly nvram handle for read back
nvram data. We shall open readonly nvram file for a device for writing.
nvram open will open a file in read write mode if file is readonly. But
it will result in un




NEXT




<s> static bool is_valid_bmt(unsigned char *buf, unsigned char *fdm)
{
struct bbbt *bbt = (struct bbbt *)buf;
u8 *sig = (u8*)bbt->signature + MAIN_SIGNATURE_OFFSET;


if (memcmp(bbt->signature + MAIN_SIGNATURE_OFFSET, "BMT", 3) == 0 &&
memcmp(fdm + OOB_SIGNATURE_OFFSET, "bmt", 3) == 0) {
if (bbt->version == BBMT_VERSION)
return true;
}
BBT_LOG("[BBT] BMT Version not match,upgrage preloader and uboot please! sig=%02x%02x%02x, fdm=%02x%02x%02x",
sig[0], sig[1], sig[2],
fdm[1], fdm[2], fdm[3]);
return false;
}

The above function is used to judge whether a BMT is invalid, but when I disassemble the fw of the official version, the content of the BMT_SIGNATURE[1], BBT_VERSION and BBMT_VERSION in the fw are respectively 




NEXT




<s> rtk_api_ret_t rtk_led_groupConfig_get(rtk_led_group_t group, rtk_led_congig_t *pConfig)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (LED_GROUP_END <= group)
return RT_ERR_FAILED;

if(NULL == pConfig)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLedIndicateInfoConfig(group, pConfig)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read led group configuration information, including the number of LEDs, LED brightness and wavelength. Call it to read:

rtk_led_congig_t ledGroupConfig1;
rtk_led_congig_




NEXT




<s> static void rtl930x_pie_init(struct rtl838x_switch_priv *priv)
{
u32 template_selectors;

mutex_init(&priv->pie_mutex);

pr_info("%s\n", __func__);
/* Enable ACL lookup on all ports, including CPU_PORT */
for (int i = 0; i <= priv->cpu_port; i++)
sw_w32(1, RTL930X_ACL_PORT_LOOKUP_CTRL(i));

/* Include IPG in metering */
sw_w32_mask(0, 1, RTL930X_METER_GLB_CTRL);

/* Delete all present rules, block size is 128 on all SoC families */
rtl930x_pie_rule_del(priv, 0, priv->n_pie_blocks * 128 - 1);

/* Assign blocks 0-7 to VACL phase (bit = 0), blocks 8-15 to IACL (bit = 1) */
sw_w32(0xff00, RTL930X_PIE_BLK_PHASE_CTRL);

/* Enable predefined templates 0, 1 for first quarter of all blocks */
template_selectors = 0 | (1 << 4);
for (int i = 0; i < priv->n_pie_blocks / 4; i++)
sw_w32(template_selectors, RTL930X_PIE_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 2, 3 for second quarter of all blocks */
template_selectors = 2 | (3 << 4);
for (int i = priv->n_pie_blocks / 4; i < priv->n_pie_blocks / 2; i++)
sw_w32(template_selectors, RTL930X_PIE_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 0, 1 for third half of all blocks */
template_selectors = 0 | (1 << 4);
for (int i = priv->n_pie_blocks / 2; i < priv->n_pie_blocks * 3 / 4; i++)
sw_w32(template_selectors, RTL930X_PIE_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 2, 3 for fourth quater of all blocks */
template_selectors = 2 | (3 << 4);
for (int i = priv->n_pie_blocks * 3 / 4; i < priv->n_pie_blocks; i++)
sw_w32(template_selectors, RTL930X_PIE_BLK_TMPLTE_CTRL(i));

}

The above function is used to initialize the rule of Packet Classification Engine(PCIE) on rtl9xxx switch, it is located in the file <../drivers/net/ethernet/realtek/rtl838x-switch-pie




NEXT




<s> int rtl930x_write_phy(u32 port, u32 page, u32 reg, u32 val)
{
u32 v;
int err = 0;

pr_debug("%s: port %d, page: %d, reg: %x, val: %x\n", __func__, port, page, reg, val);

if (port > 63 || page > 4095 || reg > 31)
return -ENOTSUPP;

val &= 0xffff;
mutex_lock(&smi_lock);

sw_w32(BIT(port), RTL930X_SMI_ACCESS_PHY_CTRL_0);
sw_w32_mask(0xffff << 16, val << 16, RTL930X_SMI_ACCESS_PHY_CTRL_2);
v = reg << 20 | page << 3 | 0x1f << 15 | BIT(2) | BIT(0);
sw_w32(v, RTL930X_SMI_ACCESS_PHY_CTRL_1);

do {
v = sw_r32(RTL930X_SMI_ACCESS_PHY_CTRL_1);
} while (v & 0x1);

if (v & 0x2)
err = -EIO;

mutex_unlock(&smi_lock);

return err;
}

The above function is used to perform an external PHY register read, by writing to a specific register on RTL930x internal PHY. From
code flow, it can be seen that it does not take into account any locking mechanisms and can potentially cause





NEXT




<s> static void bcm6348_emac_hw_preinit(struct bcm6348_emac *emac)
{
u32 val;
int limit;

/* make sure emac is disabled */
bcm6348_emac_disable_mac(emac);

/* soft reset emac */
val = ENET_CTL_SRESET_MASK;
emac_writel(emac, val, ENET_CTL_REG);
wmb();

limit = 1000;
do {
val = emac_readl(emac, ENET_CTL_REG);
if (!(val & ENET_CTL_SRESET_MASK))
break;
udelay(1);
} while (limit--);

/* select correct mii interface */
val = emac_readl(emac, ENET_CTL_REG);
if (emac->ext_mii)
val |= ENET_CTL_EPHYSEL_MASK;
else
val &= ~ENET_CTL_EPHYSEL_MASK;
emac_writel(emac, val, ENET_CTL_REG);

/* turn on mdc clock */
emac_writel(emac, (0x1f << ENET_MIISC_MDCFREQDIV_SHIFT) |
ENET_MIISC_PREAMBLEEN_MASK, ENET_MIISC_REG);

/* set mib counters to self-clear when read */
val = emac_readl(emac, ENET_MIBCTL_REG);
val |= ENET_MIBCTL_RDCLEAR_MASK;
emac_writel(emac, val, ENET_MIBCTL_REG);
}

The above function is used to ensure that the emac interface is initialized properly before it’s enabled.

## Setting Up A Repeaters

A common use case with Ethernet over USB is to use repeaters. A repeater is an intermediate node that




NEXT




<s> static void rtl838x_stp_set(struct rtl838x_switch_priv *priv, u16 msti, u32 port_state[])
{
u32 cmd = 1 << 15 | /* Execute cmd */
0 << 14 | /* Write */
2 << 12 | /* Table type 0b10 */
(msti & 0xfff);

for (int i = 0; i < 2; i++)
sw_w32(port_state[i], priv->r->tbl_access_data_0(i));
priv->r->exec_tbl0_cmd(cmd);
}

The above function is used to set the STP table in 2x of SMI. This code has to be updated.</s>




NEXT




<s> static void ar934x_nfc_cmd_ctrl(struct nand_chip *chip, int dat,
unsigned int ctrl)
{
WARN_ON(dat != NAND_CMD_NONE);
}

The above function is used to define the NAND controller specific behavior, which defines the required behaviour of NAND subsystem.
It is used whenever NAND controller want to read/write data from/to NAND device. NAND_CMD_NONE
This command should




NEXT




<s> static int i2c_write(void __iomem *r0, u8 *buf, int len)
{
if (len > 16)
return -EIO;

for (int i = 0; i < len; i++) {
u32 v;

if (! (i % 4))
v = 0;
v <<= 8;
v |= buf[i];
if (i % 4 == 3 || i == len - 1)
writel(v, r0 + (i / 4) * 4);
}

return len;
}

The above function is used to write data to the i2c bus in little endian order. Since the i2c bus is byte oriented, the little endian order ensures that the bytes are written in the correct order. The function takes three arguments: r0,




NEXT




<s> static int rtl8366rb_set_vlan_4k(struct rtl8366_smi *smi,
const struct rtl8366_vlan_4k *vlan4k)
{
u32 data[3];
int err;
int i;

if (vlan4k->vid >= RTL8366RB_NUM_VIDS ||
vlan4k->member > RTL8366RB_VLAN_MEMBER_MASK ||
vlan4k->untag > RTL8366RB_VLAN_UNTAG_MASK ||
vlan4k->fid > RTL8366RB_FIDMAX)
return -EINVAL;

data[0] = vlan4k->vid & RTL8366RB_VLAN_VID_MASK;
data[1] = (vlan4k->member & RTL8366RB_VLAN_MEMBER_MASK) |
((vlan4k->untag & RTL8366RB_VLAN_UNTAG_MASK) <<
RTL8366RB_VLAN_UNTAG_SHIFT);
data[2] = vlan4k->fid & RTL8366RB_VLAN_FID_MASK;

for (i = 0; i < 3; i++) {
err = rtl8366_smi_write_reg(smi,
RTL8366RB_VLAN_TABLE_WRITE_BASE + i,
data[i]);
if (err)
return err;
}

/* write table access control word */
err = rtl8366_smi_write_reg(smi, RTL8366RB_TABLE_ACCESS_CTRL_REG,
RTL8366RB_TABLE_VLAN_WRITE_CTRL);

return err;
}

The above function is used to configure the 4k multicast table.

The following functions are used to implement hardware search and add new
members to a multicast group.

static void rtl8366rb_vlan4k_




NEXT




<s> static void mt7621_nfc_read_data_discard(struct mt7621_nfc *nfc, u32 len)
{
while (len >= 4) {
mt7621_nfc_pio_read(nfc, false);
len -= 4;
}

while (len) {
mt7621_nfc_pio_read(nfc, true);
len--;
}
}

The above function is used to read a block of data from the NFC controller.

Why was this change done? Why not simply write a big chunk of zeros to discard the data instead of reading the data?

Is this a bug or is this a




NEXT




<s> list_attributes(struct switch_dev *dev)
{
printf("%s: %s(%s), ports: %d (cpu @ %d), vlans: %d\n", dev->dev_name, dev->alias, dev->name, dev->ports, dev->cpu_port, dev->vlans);
printf("     --switch\n");
print_attrs(dev->ops);
printf("     --vlan\n");
print_attrs(dev->vlan_ops);
printf("     --port\n");
print_attrs(dev->port_ops);
}

The above function is used to print out the attributes of switch structure when switch is created with a default set of configuration.
In the output we can see that:

- switch_dev structure has its default values like name, alias, port number and support for one v




NEXT




<s> void __init wsap3715i_pic_init(void)
{
struct mpic *mpic;

mpic = mpic_alloc(NULL, 0,
MPIC_BIG_ENDIAN | MPIC_SINGLE_DEST_CPU,
0, 256, " OpenPIC  ");

BUG_ON(mpic == NULL);
mpic_init(mpic);
}

The above function is used to initialize the OpenPIC device. It’s part of the SATA IDE driver and is responsible for setting up the OpenPIC module. This means it’s the first thing that’s executed when a boot process takes place and determines




NEXT




<s> static void rtl930x_set_egr_filter(int port,  enum egr_filter state)
{
sw_w32_mask(0x1 << (port % 0x1D), state << (port % 0x1D),
RTL930X_VLAN_PORT_EGR_FLTR + (((port / 29) << 2)));
}

The above function is used to enable/disable egr filtering in a port. What is the effect of writing 1 to the register when that port does not exist (i.e port=VLAN_PORT_MAX+1) or 65535




NEXT




<s> rtk_api_ret_t rtk_l2_ipMcastForwardRouterPort_get(rtk_enable_t *pEnabled)
{
rtk_api_ret_t       retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (NULL == pEnabled)
return RT_ERR_NULL_POINTER;

if((retVal = rtl8367c_getAsicLutIpmcFwdRouterPort(pEnabled)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set and retrieval the McastForwardRouterPort. If the Mcast forward entry is used for routing, set the McastForwardRouterPort bit in AsicTable to 1.

//****************************************************************************//






NEXT




<s> nvram_tuple_t * nvram_getall(nvram_handle_t *h)
{
int i;
nvram_tuple_t *t, *l, *x;

l = NULL;

for (i = 0; i < NVRAM_ARRAYSIZE(h->nvram_hash); i++) {
for (t = h->nvram_hash[i]; t; t = t->next) {
if( (x = (nvram_tuple_t *) malloc(sizeof(nvram_tuple_t))) != NULL )
{
x->name  = t->name;
x->value = t->value;
x->next  = l;
l = x;
}
else
{
break;
}
}
}

return l;
}

The above function is used to create a list that has all keys and values stored
in NVRAM. The list is used when a file system is removed. The function NVRAM will
be explained in detail later.

It would be useful to print the contents




NEXT




<s> stop_server(struct ead_instance *in, bool do_free)
{
if (in->pid > 0)
kill(in->pid, SIGKILL);
in->pid = 0;
if (do_free) {
list_del(&in->list);
free(in);
}
}

The above function is used to stop the process spawned by docker, if it exits due to error,
or by the user by typing CTRL+D in the terminal.

There are a few other minor cleanups and changes since the last commit,




NEXT




<s> static int b53_phy_fixup(struct phy_device *dev)
{
struct mii_bus *bus = dev->mdio.bus;
u32 phy_id;

if (dev->mdio.addr != B53_PSEUDO_PHY)
return 0;

/* read the first port's id */
phy_id = mdiobus_read(bus, 0, 2) << 16;
phy_id |= mdiobus_read(bus, 0, 3);

if ((phy_id & 0xfffffc00) == B53_BRCM_OUI_1 ||
(phy_id & 0xfffffc00) == B53_BRCM_OUI_2 ||
(phy_id & 0xffffff00) == B53_BRCM_OUI_3) {
dev->phy_id = phy_id;
}

return 0;
}

The above function is used to parse out pseudo-PHYs on our PCIe B53 board.
As the name indicate, these are PHY devices that the PCIe B53 PHY driver
implememntations don't implement, but instead we




NEXT




<s> static void __exit mt_msdc_exit(void)
{
platform_driver_unregister(&mt_msdc_driver);
}

The above function is used to unregister the platform driver registered in mt-msdc.c. Unregistering the platform driver doesn’t unbind it from a PCI-device, it is important that the driver unbinds from a device before it is unregistered




NEXT




<s> static int phy_reset(int device)
{
int phy_status = 0;
int loops = 0;

scr_write(device, (0x60 - SATA_STD_ASYNC_REGS_OFF) / 4, LOS_AND_TX_LVL);
scr_write(device, (0x70 - SATA_STD_ASYNC_REGS_OFF) / 4, TX_ATTEN);

/* limit it to Gen-1 SATA (1.5G) */
scr_write(device, SATA_SCR_CONTROL, 0x311); /* Issue phy wake & core reset */
scr_read(device, SATA_SCR_STATUS); /* Dummy read; flush */
udelay(1000);
scr_write(device, SATA_SCR_CONTROL, 0x310); /* Issue phy wake & clear core reset */

/* Wait for upto 5 seconds for PHY to become ready */
do {
udelay(200000);
if ((scr_read(device, SATA_SCR_STATUS) & 0xf) == 3) {
scr_write(device, SATA_SCR_ERROR, ~0);
phy_status = 1;
break;
}
//printf("No SATA PHY found status:0x%x\n", scr_read(device, SATA_SCR_STATUS));
} while (++loops < PHY_LOOP_COUNT);

if (phy_status) {
udelay(500000); /* wait half a second */
}

return phy_status;
}

The above function is used to check if a PHY is available to use

This function is called twice and it is called right at the end of the driver initialization, and right after we create SATA devices for the system to use.

This is a simple function




NEXT




<s> BigIntegerAddInt(result, a1, a2)
BigInteger result, a1;
unsigned int a2;
{
BIGNUM * a = BN_new();
BN_set_word(a, a2);
BN_add(result, a1, a);
BN_free(a);
}

The above function is used to get the result from the operation of addition
in which the operands are represented as number in hexadecimal format.
So the number a1 is passed as a BigInteger Object and the number
a2 is passed as a simple inter




NEXT




<s> ret_t rtl8367c_setAsicLedGroupMode(rtk_uint32 mode)
{
ret_t retVal;

/* Invalid input parameter */
if(mode >= RTL8367C_LED_MODE_END)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_CONFIGURATION, RTL8367C_LED_CONFIG_SEL_OFFSET, 1);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_setAsicRegBits(RTL8367C_REG_LED_CONFIGURATION, RTL8367C_DATA_LED_MASK, mode);
}

The above function is used to set the mode of the LEDs.
For the EK samples, we use the basic LED setting. The setting is controlled by an internal oscillator. The modes for the basic setting are as listed below.
    – Green Only: Sets




NEXT




<s> rtk_api_ret_t rtk_led_modeForce_set(rtk_port_t port, rtk_led_group_t group, rtk_led_force_mode_t mode)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

/* No LED for CPU port */
if(rtk_switch_isCPUPort(port) == RT_ERR_OK)
return RT_ERR_PORT_ID;

if (group >= LED_GROUP_END)
return RT_ERR_INPUT;

if (mode >= LED_FORCE_END)
return RT_ERR_NOT_ALLOWED;

if ((retVal = rtl8367c_setAsicForceLed(rtk_switch_port_L2P_get(port), group, mode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set LED mode. The LED mode can be
*
- LED_FORCE_DEFAULT - Default LED setting
- LED_FORCE_OFF - All LEDs are turned OFF - Led setting can not be observed.
- LED_




NEXT




<s> static int rtl83xx_port_enable(struct dsa_switch *ds, int port,
struct phy_device *phydev)
{
struct rtl838x_switch_priv *priv = ds->priv;
u64 v;

pr_debug("%s: %x %d", __func__, (u32) priv, port);
priv->ports[port].enable = true;

/* enable inner tagging on egress, do not keep any tags */
priv->r->vlan_port_keep_tag_set(port, 0, 1);

if (dsa_is_cpu_port(ds, port))
return 0;

/* add port to switch mask of CPU_PORT */
priv->r->traffic_enable(priv->cpu_port, port);

if (priv->is_lagmember[port]) {
pr_debug("%s: %d is lag slave. ignore\n", __func__, port);
return 0;
}

/* add all other ports in the same bridge to switch mask of port */
v = priv->r->traffic_get(port);
v |= priv->ports[port].pm;
priv->r->traffic_set(port, v);

/* TODO: Figure out if this is necessary */
if (priv->family_id == RTL9300_FAMILY_ID) {
sw_w32_mask(0, BIT(port), RTL930X_L2_PORT_SABLK_CTRL);
sw_w32_mask(0, BIT(port), RTL930X_L2_PORT_DABLK_CTRL);
}

if (priv->ports[port].sds_num < 0)
priv->ports[port].sds_num = rtl93xx_get_sds(phydev);

return 0;
}

The above function is used to enable a port into the switch fabric when
a host has made a request. The first thing this function does is store the
state of the port as enabled. Next it enables Egress inner tagging and then
enables the port in the




NEXT




<s> static int rttm_state_oneshot(struct clock_event_device *clkevt)
{
struct timer_of *to = to_timer_of(clkevt);

RTTM_DEBUG(to->of_base.base);
rttm_stop_timer(to->of_base.base);
rttm_set_period(to->of_base.base, RTTM_TICKS_PER_SEC / HZ);
rttm_start_timer(to, RTTM_CTRL_COUNTER);

return 0;
}

The above function is used to reconfigure the timer and restart it.
So, we just call functions that would handle the configuration.

The timer is a very important subsystem in the Linux kernel.
This subsystem provides timers API to
the main kernel and




NEXT




<s> check_bridge_port(const char *br, const char *port, void *arg)
{
struct ead_instance *in;
struct list_head *p;

list_for_each(p, &instances) {
in = list_entry(p, struct ead_instance, list);

if (strcmp(in->ifname, port) != 0)
continue;

in->br_check = true;
if (strcmp(in->bridge, br) == 0)
break;

strncpy(in->bridge, br, sizeof(in->bridge));
DEBUG(2, "assigning port %s to bridge %s\n", in->ifname, in->bridge);
stop_server(in, false);
}
return 0;
}

The above function is used to match up EAD instances with the correct bridge.  When calling bridgectl addif to add a bridge interface, the function is called once for each port, with the bridge name passed in for the br parameter, and the port name as part of




NEXT




<s> void des_dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);

void ifx_deu_des (void *ctx_arg, u8 *out_arg, const u8 *in_arg,
u8 *iv_arg, u32 nbytes, int encdec, int mode);

struct ifx_deu_des_ctx {
int controlr_M;
int key_length;
u8 iv[DES_BLOCK_SIZE];
u32 expkey[DES3_EDE_EXPKEY_WORDS];
struct des_ctx des_context;
struct des3_ede_ctx des3_ede_context;
};

The above function is used to process 8-bit data using a single DES key. The first argument is a copy of the DES context argument (of the format used in previous versions of OpenSSL) or NULL. The second argument is a copy of the address to output dec




NEXT




<s> rtk_api_ret_t rtk_l2_init(void)
{
rtk_api_ret_t retVal;
rtk_uint32 port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_setAsicLutIpMulticastLookup(DISABLED)) != RT_ERR_OK)
return retVal;

/*Enable CAM Usage*/
if ((retVal = rtl8367c_setAsicLutCamTbUsage(ENABLED)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicLutAgeTimerSpeed(6,2)) != RT_ERR_OK)
return retVal;

RTK_SCAN_ALL_LOG_PORT(port)
{
if ((retVal = rtl8367c_setAsicLutLearnLimitNo(rtk_switch_port_L2P_get(port), rtk_switch_maxLutAddrNumber_get())) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to initialize the chip. It sets the L2 Multicast MAC table and ACL lookup table.
The chip sets the chip to ignore all the incoming packets by disabling the L2 multicast MAC table lookup table. After
setting the




NEXT




<s> mt7530_get_port_mirror_rx(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

val->value.i =  priv->port_entries[val->port_vlan].mirror_rx;

return 0;
}

The above function is used to get the port-mirror-rx value of each port.

We already have this code in switch core, so we only need to add the attribute
to the struct switch_dev of the mt7530 driver. And then




NEXT




<s> ret_t rtl8367c_getAsicEavMacAddress(ether_addr_t *pMac)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint8 *accessPtr;
rtk_uint32 i;

accessPtr = (rtk_uint8*)pMac;

for(i = 0; i <= 2; i++)
{
retVal = rtl8367c_getAsicReg(RTL8367C_REG_MAC_ADDR_H - i, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*accessPtr = (regData & 0xFF00) >> 8;
accessPtr ++;
*accessPtr = regData & 0xFF;
accessPtr ++;
}

return retVal;
}

The above function is used to read the current Ethernet address value of a specific RTL8367C chip.

## 1.2.3. Write Ethernet address to EAV register

The Ethernet address that the MAC layer




NEXT




<s> static int b53_port_get_pvid(struct switch_dev *dev, int port, int *val)
{
struct b53_device *priv = sw_to_b53(dev);

*val = priv->ports[port].pvid;

return 0;
}

The above function is used to retrieve pvid for any port when it is needed.
But unfortunately in this function it is using ports array to get port
pvid. The problem here is we cannot use array for this purpose as different
ports can use same chips.





NEXT




<s> void rtk_hal_qos_get_pri2queue(struct ra_switch_ioctl_data *data)
{
int i;
rtk_api_ret_t ret;
rtk_qos_pri2queue_t pri2qid;

ret = rtk_qos_priMap_get(8, &pri2qid);
if (ret != 0)
printk("rtk_qos_priMap_get failed\n");
else {
for (i = 0; i < 8; i++)
printk("pri2qid.pri2queue[%d] = %d\n", i, pri2qid.pri2queue[i]);
}
}

The above function is used to get the packet queue which corresponds to the priority.
To print the value of packet queue that corresponds to the priority, the following output can be seen through the terminal which printed by the above program.
Output:
pri2qid.




NEXT




<s> static unsigned int AT91F_SpiWrite(AT91PS_DataflashDesc pDesc)
{
unsigned int timeout;

AT91C_BASE_SPI->SPI_PTCR = AT91C_PDC_TXTDIS + AT91C_PDC_RXTDIS;

/* Initialize the Transmit and Receive Pointer */
AT91C_BASE_SPI->SPI_RPR = (unsigned int)pDesc->rx_cmd_pt ;
AT91C_BASE_SPI->SPI_TPR = (unsigned int)pDesc->tx_cmd_pt ;

/* Intialize the Transmit and Receive Counters */
AT91C_BASE_SPI->SPI_RCR = pDesc->rx_cmd_size;
AT91C_BASE_SPI->SPI_TCR = pDesc->tx_cmd_size;

if ( pDesc->tx_data_size != 0 ) {
/* Initialize the Next Transmit and Next Receive Pointer */
AT91C_BASE_SPI->SPI_RNPR = (unsigned int)pDesc->rx_data_pt ;
AT91C_BASE_SPI->SPI_TNPR = (unsigned int)pDesc->tx_data_pt ;

/* Intialize the Next Transmit and Next Receive Counters */
AT91C_BASE_SPI->SPI_RNCR = pDesc->rx_data_size ;
AT91C_BASE_SPI->SPI_TNCR = pDesc->tx_data_size ;
}

/* ARM simple, non interrupt dependent timer */
timeout = 0;

AT91C_BASE_SPI->SPI_PTCR = AT91C_PDC_TXTEN + AT91C_PDC_RXTEN;
while(!(AT91C_BASE_SPI->SPI_SR & AT91C_SPI_RXBUFF));

AT91C_BASE_SPI->SPI_PTCR = AT91C_PDC_TXTDIS + AT91C_PDC_RXTDIS;

if (timeout >= AT91C_DATAFLASH_TIMEOUT){
return AT91C_DATAFLASH_ERROR;
}

return AT91C_DATAFLASH_OK;
}

The above function is used to send and receive a single byte at a time. Each command is processed by the above
function and the results are returned back to the application (refer the function call)</s>




NEXT




<s> ret_t rtl8367c_getAsicLutIpLookupMethod(rtk_uint32* pType)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LUT_IPMC_LOOKUP_OP_OFFSET, pType);
}

The above function is used to get the asic lookup engine that use as IC mode or IP mode of IP lookup table, we can use this as

rtk_uint32 asicIPLookupMode;
ret_t ret;

ret = rtl




NEXT




<s> static int mt7621_nfc_init_chip(struct mt7621_nfc *nfc)
{
struct nand_chip *nand = &nfc->nand;
struct mtd_info *mtd;
int ret;

nand->controller = &nfc->controller;
nand_set_controller_data(nand, (void *)nfc);
nand_set_flash_node(nand, nfc->dev->of_node);

nand->options |= NAND_USES_DMA | NAND_NO_SUBPAGE_WRITE | NAND_SKIP_BBTSCAN;
if (!nfc->nfi_clk)
nand->options |= NAND_KEEP_TIMINGS;

nand->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;
nand->ecc.read_page = mt7621_nfc_read_page_hwecc;
nand->ecc.read_page_raw = mt7621_nfc_read_page_raw;
nand->ecc.write_page = mt7621_nfc_write_page_hwecc;
nand->ecc.write_page_raw = mt7621_nfc_write_page_raw;
nand->ecc.read_oob = mt7621_nfc_read_oob_hwecc;
nand->ecc.read_oob_raw = mt7621_nfc_read_oob_raw;
nand->ecc.write_oob = mt7621_nfc_write_oob_hwecc;
nand->ecc.write_oob_raw = mt7621_nfc_write_oob_raw;

mtd = nand_to_mtd(nand);
mtd->owner = THIS_MODULE;
mtd->dev.parent = nfc->dev;
mtd->name = MT7621_NFC_NAME;
mtd_set_ooblayout(mtd, &mt7621_nfc_ooblayout_ops);

mt7621_nfc_hw_init(nfc);

ret = nand_scan(nand, 1);
if (ret)
return ret;

mtk_bmt_attach(mtd);

ret = mtd_device_register(mtd, NULL, 0);
if (ret) {
dev_err(nfc->dev, "Failed to register MTD: %d\n", ret);
mtk_bmt_detach(mtd);
nand_cleanup(nand);
return ret;
}

return 0;
}

The above function is used to initialise the HW (and the driver).

In general, MT7621_NFC_NAME corresponds to the label for the chip on the board (which comes from “MT7621X”).</s>




NEXT




<s> static inline int b53_spi_read_reg(struct spi_device *spi, u8 reg, u8 *val,
unsigned len)
{
u8 txbuf[2];

txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_READ;
txbuf[1] = reg;

return spi_write_then_read(spi, txbuf, 2, val, len);
}

The above function is used to implement the data communication of DUF167. According to the requirement, the spi slave will transmit a command containing B53_SPI_CMD_READ|SPI_READ_OPCODE and the read data address from master D




NEXT




<s> static int switch_count_open(struct inode *inode, struct file *file)
{
return single_open(file, esw_cnt_read, 0);
}

The above function is used to open the /proc/switch_count file. The open() method receives two arguments: the inode of the file that is being opened (inode), and the file structure that represents the file open request (file). The method returns a file descriptor for




NEXT




<s> static inline struct gpio_rb91x_key *to_gpio_rb91x_key(struct gpio_chip *gc)
{
return container_of(gc, struct gpio_rb91x_key, gc);
}

The above function is used to get struct gpio_rb91x_key struct from struct gpio_chip*.
Here gpio_rb91x_key is a device structure which is the parent of struct gpio_chip.
static inline long g




NEXT




<s> static int inf(FILE *source, FILE *dest, size_t limit, size_t skip)
{
int ret;
size_t have;
z_stream strm;
unsigned char in[CHUNK];
unsigned char out[CHUNK];

/* allocate inflate state */
strm.zalloc = Z_NULL;
strm.zfree = Z_NULL;
strm.opaque = Z_NULL;
strm.avail_in = 0;
strm.next_in = Z_NULL;
ret = inflateInit(&strm);
if (ret != Z_OK)
return ret;

/* decompress until deflate stream ends or end of file */
do {
strm.avail_in = fread(in, 1, CHUNK, source);
if (ferror(source)) {
(void)inflateEnd(&strm);
return Z_ERRNO;
}
if (strm.avail_in == 0)
break;
strm.next_in = in;

/* run inflate() on input until output buffer not full */
do {
strm.avail_out = CHUNK;
strm.next_out = out;
ret = inflate(&strm, Z_NO_FLUSH);
assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
switch (ret) {
case Z_NEED_DICT:
ret = Z_DATA_ERROR;     /* and fall through */
case Z_DATA_ERROR:
case Z_MEM_ERROR:
(void)inflateEnd(&strm);
return ret;
}
have = special_min(limit, CHUNK - strm.avail_out) - skip;
if (fwrite(&out[skip], have, 1, dest) != 1 || ferror(dest)) {
(void)inflateEnd(&strm);
return Z_ERRNO;
}
skip = 0;
limit -= have;
} while (strm.avail_out == 0 && limit > 0);

/* done when inflate() says it's done */
} while (ret != Z_STREAM_END && limit > 0);

/* clean up and return */
(void)inflateEnd(&strm);
return (limit == 0 ? Z_OK : (ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR));
}

The above function is used to inflate data (decompress data). The code uses the function inflate_state_init(), which initializes a deflate state structure. Since the process is not interactive, where the input is available and we are not buffering, we pass




NEXT




<s> static int rtl931x_sds_cmu_page_get(phy_interface_t mode)
{
switch (mode) {
case PHY_INTERFACE_MODE_SGMII:
case PHY_INTERFACE_MODE_1000BASEX:	/* MII_1000BX_FIBER / 100BX_FIBER / 1000BX100BX_AUTO */
return 0x24;
case PHY_INTERFACE_MODE_HSGMII:
case PHY_INTERFACE_MODE_2500BASEX:	/* MII_2500Base_X: */
return 0x28;
/*	case MII_HISGMII_5G: */
/*		return 0x2a; */
case PHY_INTERFACE_MODE_QSGMII:
return 0x2a;			/* Code also has 0x34 */
case PHY_INTERFACE_MODE_XAUI:		/* MII_RXAUI_LITE: */
return 0x2c;
case PHY_INTERFACE_MODE_XGMII:		/* MII_XSGMII */
case PHY_INTERFACE_MODE_10GKR:
case PHY_INTERFACE_MODE_10GBASER:	/* MII_10GR */
return 0x2e;
default:
return -1;
}

return -1;
}

The above function is used to determine if a switch is 800B/2500B/10000B and return the Page for use in the MDIO read or write.</s>




NEXT




<s> void __udelay (unsigned long usec)
{
ulong tmo, tmp;

if (usec > 100000) {		/* if "big" number, spread normalization to seconds */
tmo = usec / 1000;	/* start to normalize for usec to ticks per sec */
tmo *= CONFIG_SYS_HZ;	/* find number of "ticks" to wait to achieve target */
tmo /= 1000;		/* finish normalize. */

tmp = get_timer (0);		/* get current timestamp */
while (get_timer (tmp) < tmo)/* loop till event */
/*NOP*/;
} else {			/* else small number, convert to hw ticks */
tmo = usec * (TIMER_CLOCK / 1000) / 1000;
/* timeout is no more than 0.1s, and the hw timer will roll over at most once */
tmp = READ_TIMER_HW;
while (((READ_TIMER_HW -tmp) & TIMER_LOAD_VAL) < tmo)/* loop till event */
/*NOP*/;
}
}

The above function is used to suspend the system for a specific period, in units of microseconds. The function is in the file timer/timer.c and is used in conjunction with the timer device.

The timer module consists of only one file. This module is




NEXT




<s> ret_t rtl8367c_getAsicLutLearnNo(rtk_uint32 port, rtk_uint32* pNumber)
{
ret_t retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 10)
{
retVal = rtl8367c_getAsicReg(RTL8367C_REG_L2_LRN_CNT_REG(port), pNumber);
if (retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicReg(RTL8367C_REG_L2_LRN_CNT_CTRL10, pNumber);
if (retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to get the number of L2 lookup entries for a given Port. The L2 Lookup Entries are counted from L2 Lookup Tables of Port. It will return the number of L2 lookup entries. The function will pass the L2




NEXT




<s> static struct fw_header *rtl838x_request_fw(struct phy_device *phydev,
const struct firmware *fw,
const char *name)
{
struct device *dev = &phydev->mdio.dev;
int err;
struct fw_header *h;
uint32_t checksum, my_checksum;

err = request_firmware(&fw, name, dev);
if (err < 0)
goto out;

if (fw->size < sizeof(struct fw_header)) {
pr_err("Firmware size too small.\n");
err = -EINVAL;
goto out;
}

h = (struct fw_header *) fw->data;
pr_info("Firmware loaded. Size %d, magic: %08x\n", fw->size, h->magic);

if (h->magic != 0x83808380) {
pr_err("Wrong firmware file: MAGIC mismatch.\n");
goto out;
}

checksum = h->checksum;
h->checksum = 0;
my_checksum = ~crc32(0xFFFFFFFFU, fw->data, fw->size);
if (checksum != my_checksum) {
pr_err("Firmware checksum mismatch.\n");
err = -EINVAL;
goto out;
}
h->checksum = checksum;

return h;
out:
dev_err(dev, "Unable to load firmware %s (%d)\n", name, err);
return NULL;
}

The above function is used to fetch the firmware from the driver which has an
offset to the firmware image file in the filesystem. The filesystem that the
firmware is stored into can be determined from the driver that is loading it
and the method by




NEXT




<s> ret_t rtl8367c_getAsicSvlanSP2CConf(rtk_uint32 index,rtl8367c_svlan_s2c_t* pSvlanSp2cCfg)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint16 *accessPtr;
rtk_uint32 i;
rtk_uint16 smiSvlanSP2C[RTL8367C_SVLAN_SP2C_LEN];

if(index > RTL8367C_SP2CMAX)
return RT_ERR_ENTRY_INDEX;

memset(smiSvlanSP2C, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_SP2C_LEN);

accessPtr = smiSvlanSP2C;

for(i = 0; i < 2; i++)
{
retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_S2C_ENTRY_BASE_REG(index) + i, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*accessPtr = regData;

accessPtr ++;
}

_rtl8367c_svlanSp2cStSmi2User(pSvlanSp2cCfg, smiSvlanSP2C);

return RT_ERR_OK;
}

The above function is used to get the values that are in the configuration structure from the software to the SVLAN SP2S registers. This function uses the _rtl8367c_svlanSp2cStSmi2User to map data from the SM




NEXT




<s> rtk_api_ret_t rtk_igmp_init(void)
{
rtk_api_ret_t retVal;
rtk_port_t port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_setAsicLutIpMulticastLookup(ENABLED))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicLutIpLookupMethod(1))!=RT_ERR_OK)
return retVal;

RTK_SCAN_ALL_PHY_PORTMASK(port)
{
if ((retVal = rtl8367c_setAsicIGMPv1Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIGMPv2Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIGMPv3Opeartion(port, PROTOCOL_OP_FLOOD))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicMLDv1Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicMLDv2Opeartion(port, PROTOCOL_OP_FLOOD))!=RT_ERR_OK)
return retVal;
}

if ((retVal = rtl8367c_setAsicIGMPAllowDynamicRouterPort(rtk_switch_phyPortMask_get()))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIGMPFastLeaveEn(ENABLED))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIGMPReportLeaveFlood(1))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIgmp(ENABLED))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to initialize the IGMP/MLD (Snooping). The functions related to IGMP / MLDS are defined in the following table:

Table 4-10: IGMP / MLDS (Snooping)




NEXT




<s> static int msdc_get_card_status(struct mmc_host *mmc, struct msdc_host *host, u32 *status)
{
struct mmc_command cmd;
struct mmc_request mrq;
u32 err;

memset(&cmd, 0, sizeof(struct mmc_command));
cmd.opcode = MMC_SEND_STATUS;
if (mmc->card) {
cmd.arg = mmc->card->rca << 16;
} else {
ERR_MSG("cmd13 mmc card is null");
cmd.arg = host->app_cmd_arg;
}
cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;

memset(&mrq, 0, sizeof(struct mmc_request));
mrq.cmd = &cmd; cmd.mrq = &mrq;
cmd.data = NULL;

err = msdc_do_command(host, &cmd, 1, CMD_TIMEOUT);

if (status)
*status = cmd.resp[0];

return err;
}

The above function is used to read CMD13, and return SD card status by setting cmd->opcocde to MMC_SEND_STATUS</s>




NEXT




<s> static inline void aca_event_addr_get(struct dc_ep_dev *dev,
struct aca_event_reg_addr *regs)
{
if (WARN_ON(!dev || !regs))
return;
if (WARN_ON(!dev->priv))
return;

dc_aca_event_addr_get(dev->priv, regs);
}

The above function is used to get event registers. There two ways to get DC registers.

The first method is to use the “dc.getreg” bbcommand. This command returns the current register value. To retrieve the event registers using this method, run:




NEXT




<s> static char *expand_string(const char *in);

static void __attribute__((noreturn)) pperror(const char *format, ...)
{
va_list ap;

fprintf(stderr, "%s:%d: ", current_file->name, yylineno);
va_start(ap, format);
vfprintf(stderr, format, ap);
va_end(ap);
fprintf(stderr, "\n");

exit(1);
}

The above function is used to print error message and terminate the compiler
execution but I found that __attribute__((noreturn)) attribute can't work on this function. I tried to move the noreturn attribute on the function prototype but gcc still said




NEXT




<s> static int qca807x_probe(struct phy_device *phydev)
{
struct device_node *node = phydev->mdio.dev.of_node;
int ret = 0;

if (IS_ENABLED(CONFIG_GPIOLIB)) {
/* Do not register a GPIO controller unless flagged for it */
if (of_property_read_bool(node, "gpio-controller"))
ret = qca807x_gpio(phydev);
}

/* Attach SFP bus on combo port*/
if (phy_read(phydev, QCA807X_CHIP_CONFIGURATION)) {
ret = phy_sfp_probe(phydev, &qca807x_sfp_ops);
linkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, phydev->supported);
linkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, phydev->advertising);
}

return ret;
}

The above function is used to attach the SFP bus to a phydev with the help of qca807x_sfp_probe(). I get an error that gpio-controller is not defined in /etc/modprobe.d/qca8




NEXT




<s> static void skb_swap(struct sk_buff *);
#else
#define skb_swap(skb)                                 do {} while (0)

The above function is used to swap a pointer. So that code using this
pointer would point to correct address.

What is the use of this macro? Isn't any compiler smart enough to get
those address without this macro.

A simple test program




NEXT




<s> of_switch_load_portmap(struct switch_dev *dev)
{
struct device_node *port;

if (!dev->of_node)
return;

for_each_child_of_node(dev->of_node, port) {
const __be32 *prop;
const char *segment;
int size, phys;

if (!of_device_is_compatible(port, "swconfig,port"))
continue;

if (of_property_read_string(port, "swconfig,segment", &segment))
continue;

prop = of_get_property(port, "swconfig,portmap", &size);
if (!prop)
continue;

if (size != (2 * sizeof(*prop))) {
pr_err("%s: failed to parse port mapping\n",
port->name);
continue;
}

phys = be32_to_cpup(prop++);
if ((phys < 0) | (phys >= dev->ports)) {
pr_err("%s: physical port index out of range\n",
port->name);
continue;
}

dev->portmap[phys].s = kstrdup(segment, GFP_KERNEL);
dev->portmap[phys].virt = be32_to_cpup(prop);
pr_debug("Found port: %s, physical: %d, virtual: %d\n",
segment, phys, dev->portmap[phys].virt);
}
}

The above function is used to populate the portmap table of switches.
The switch_load_portmap table is populated using the device tree
property "swconfig,portmap" that has length of 2x size of
switch_virt_port




NEXT




<s> uc_bpf_open_program(uc_vm_t *vm, size_t nargs)
{
uc_value_t *path = uc_fn_arg(0);
struct uc_bpf_fd *f;
int fd;

if (ucv_type(path) != UC_STRING)
err_return(EINVAL, "module path");

fd = bpf_obj_get(ucv_string_get(path));
if (fd < 0)
err_return(errno, NULL);

f = xalloc(sizeof(*f));
f->fd = fd;
f->close = true;

return uc_resource_new(program_type, f);
}

The above function is used to open a bpf program and save it somewhere.

However, how to obtain the bpf program is a problem.

How do you build the bpf program?

Now let's see how the bpf program is built




NEXT




<s> static int lq_cbc_des_encrypt(struct ablkcipher_request *areq)
{
struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);
struct des_ctx *ctx = crypto_ablkcipher_ctx(cipher);

return lq_queue_mgr(ctx, areq, areq->info, CRYPTO_DIR_ENCRYPT, 1);
}

The above function is used to encrypt the data and it calls the callback to
perform the encryption. The data is actually encrypted by the hardware engine.
The callback function passes the input and output buffer to the lq_queue_mgr function that
enqueues




NEXT




<s> static void __rtl8366_smi_cleanup(struct rtl8366_smi *smi)
{
if (smi->hw_reset)
smi->hw_reset(smi, true);

if (!smi->ext_mbus) {
gpio_free(smi->gpio_sck);
gpio_free(smi->gpio_sda);
}
}

The above function is used to perform cleanup operation for SMIC. However, it has been noted that in some cases (mainly for 8368/9, 8369) the gpio_free() call can result in deadlock when executing




NEXT




<s> static int aw9523_get_port_state(struct regmap *regmap, u8 pin,
u8 regbit, unsigned int *state)
{
u8 reg;
int dir;

dir = aw9523_get_pin_direction(regmap, pin, regbit);
if (dir < 0)
return dir;

if (dir == GPIO_LINE_DIRECTION_IN)
reg = AW9523_REG_IN_STATE(pin);
else
reg = AW9523_REG_OUT_STATE(pin);

return regmap_read(regmap, reg, state);
}

The above function is used to get the port state. I don't understand how aw9523_get_pin_direction is used as a parameter here. Is this GPIO direction is not same as pin direction as used in platform/gpio/gpio.c file




NEXT




<s> static void rtlglue_drvMutexUnlock(void)
{
/* It is empty currently. Implement this function if Lock/Unlock function is needed */
return;
}

The above function is used to release the lock at the bottom driver in this release.
The mutex lock mechanism has not been implemented at HW and SW level, therefore, it is also empty.
If the Lock/Unlock function is required in the current implementation, please




NEXT




<s> int rtl930x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val)
{
int err = 0;
u32 v;

mutex_lock(&smi_lock);

/* Set PHY to access */
sw_w32(BIT(port), RTL930X_SMI_ACCESS_PHY_CTRL_0);

/* Set data to write */
sw_w32_mask(0xffff << 16, val << 16, RTL930X_SMI_ACCESS_PHY_CTRL_2);

/* Set MMD device number and register to write to */
sw_w32(devnum << 16 | (regnum & 0xffff), RTL930X_SMI_ACCESS_PHY_CTRL_3);

v = BIT(2) | BIT(1) | BIT(0); /* WRITE | MMD-access | EXEC */
sw_w32(v, RTL930X_SMI_ACCESS_PHY_CTRL_1);

do {
v = sw_r32(RTL930X_SMI_ACCESS_PHY_CTRL_1);
} while (v & BIT(0));

pr_debug("%s: port %d, regnum: %x, val: %x (err %d)\n", __func__, port, regnum, val, err);
mutex_unlock(&smi_lock);
return err;
}

The above function is used to send a write transaction to an MMD device. It calls two separate functions, sw_w32 and sw_r32, which both take a 32-bit value and perform the write operation to the SMI/PHY register




NEXT




<s> static FILE *bcm4908img_open(const char *pathname, const char *mode) {
struct stat st;

if (pathname)
return fopen(pathname, mode);

if (isatty(fileno(stdin))) {
fprintf(stderr, "Reading from TTY stdin is unsupported\n");
return NULL;
}

if (fstat(fileno(stdin), &st)) {
fprintf(stderr, "Failed to fstat stdin: %d\n", -errno);
return NULL;
}

if (S_ISFIFO(st.st_mode)) {
fprintf(stderr, "Reading from pipe stdin is unsupported\n");
return NULL;
}

return stdin;
}

The above function is used to open files. The open and close calls are called when a file is opened and closed. This is done by the kernel. The open and close calls also do other things.

The open call is used to open a file. If the open




NEXT




<s> static void rtl839x_fill_l2_entry(u32 r[], struct rtl838x_l2_entry *e)
{
/* Table contains different entry types, we need to identify the right one:
* Check for MC entries, first
*/
e->is_ip_mc = !!(r[2] & BIT(31));
e->is_ipv6_mc = !!(r[2] & BIT(30));
e->type = L2_INVALID;
if (!e->is_ip_mc && !e->is_ipv6_mc) {
e->mac[0] = (r[0] >> 12);
e->mac[1] = (r[0] >> 4);
e->mac[2] = ((r[1] >> 28) | (r[0] << 4));
e->mac[3] = (r[1] >> 20);
e->mac[4] = (r[1] >> 12);
e->mac[5] = (r[1] >> 4);

e->vid = (r[2] >> 4) & 0xfff;
e->rvid = (r[0] >> 20) & 0xfff;

/* Is it a unicast entry? check multicast bit */
if (!(e->mac[0] & 1)) {
e->is_static = !!((r[2] >> 18) & 1);
e->port = (r[2] >> 24) & 0x3f;
e->block_da = !!(r[2] & (1 << 19));
e->block_sa = !!(r[2] & (1 << 20));
e->suspended = !!(r[2] & (1 << 17));
e->next_hop = !!(r[2] & (1 << 16));
if (e->next_hop) {
pr_debug("Found next hop entry, need to read data\n");
e->nh_vlan_target = !!(r[2] & BIT(15));
e->nh_route_id = (r[2] >> 4) & 0x1ff;
e->vid = e->rvid;
}
e->age = (r[2] >> 21) & 3;
e->valid = true;
if (!(r[2] & 0xc0fd0000)) /* Check for valid entry */
e->valid = false;
else
e->type = L2_UNICAST;
} else {
e->valid = true;
e->type = L2_MULTICAST;
e->mc_portmask_index = (r[2] >> 6) & 0xfff;
e->vid = e->rvid;
}
} else { /* IPv4 and IPv6 multicast */
e->vid = e->rvid = (r[0] << 20) & 0xfff;
e->mc_gip = r[1];
e->mc_portmask_index = (r[2] >> 6) & 0xfff;
}
if (e->is_ip_mc) {
e->valid = true;
e->type = IP4_MULTICAST;
}
if (e->is_ipv6_mc) {
e->valid = true;
e->type = IP6_MULTICAST;
}
/* pr_info("%s: vid %d, rvid: %d\n", __func__, e->vid, e->rvid); */
}

The above function is used to parse a link entry from MAC839x RTL839X or RTL8192SE.

I have a code here that parses the raw data and then stores it in a structure. This code does not




NEXT




<s> rtk_api_ret_t rtk_trunk_trafficSeparate_get(rtk_trunk_group_t trk_gid, rtk_trunk_separateType_t *pSeparateType)
{
rtk_api_ret_t retVal;
rtk_uint32 enabled;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (trk_gid != RTK_WHOLE_SYSTEM)
return RT_ERR_LA_TRUNK_ID;

if(NULL == pSeparateType)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicTrunkingFlood(&enabled)) != RT_ERR_OK)
return retVal;

*pSeparateType = (enabled == ENABLED) ? SEPARATE_FLOOD : SEPARATE_NONE;
return RT_ERR_OK;
}

The above function is used to retrieve whether the trunking module flooding function is disabled or enabled.

rtk_trunk_trafficSeparate_set(trk_gid, enable)

This function is used to enable/disable the flo




NEXT




<s> rtk_api_ret_t rtk_int_control_set(rtk_int_type_t type, rtk_enable_t enable)
{
rtk_api_ret_t retVal;
rtk_uint32 mask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= INT_TYPE_END)
return RT_ERR_INPUT;

if (type == INT_TYPE_RESERVED)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_getAsicInterruptMask(&mask)) != RT_ERR_OK)
return retVal;

if (ENABLED == enable)
mask = mask | (1<<type);
else if (DISABLED == enable)
mask = mask & ~(1<<type);
else
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicInterruptMask(mask)) != RT_ERR_OK)
return retVal;


return RT_ERR_OK;
}

The above function is used to set the input interrupt.  If you want to open the interrupt for a given port, you need to specify the interrupt function type.
The available function type is as follows:

rtk_int_type_t type: the interrupt




NEXT




<s> mt7530_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
u32 vid;
int vlan;

vlan = val->port_vlan;

vid = mt7530_r32(priv, REG_ESW_VLAN_VTIM(vlan));
if (vlan & 1)
vid = vid >> 12;
vid &= 0xfff;

val->value.i = vid;
return 0;
}

The above function is used to get the VID of the VLAN entry and the vlan parameter of this function indicates which vlan-entry it has to read the VID from.
Now look at the driver which is calling the above function.
mt753




NEXT




<s> rtk_api_ret_t rtk_rate_stormControlMeterIdx_set(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_uint32 index)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (stormType >= STORM_GROUP_END)
return RT_ERR_SFC_UNKNOWN_GROUP;

if (index > RTK_MAX_METER_ID)
return RT_ERR_FILTER_METER_ID;

switch (stormType)
{
case STORM_GROUP_UNKNOWN_UNICAST:
if ((retVal = rtl8367c_setAsicStormFilterUnknownUnicastMeter(rtk_switch_port_L2P_get(port), index))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_UNKNOWN_MULTICAST:
if ((retVal = rtl8367c_setAsicStormFilterUnknownMulticastMeter(rtk_switch_port_L2P_get(port), index))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_MULTICAST:
if ((retVal = rtl8367c_setAsicStormFilterMulticastMeter(rtk_switch_port_L2P_get(port), index))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_BROADCAST:
if ((retVal = rtl8367c_setAsicStormFilterBroadcastMeter(rtk_switch_port_L2P_get(port), index))!=RT_ERR_OK)
return retVal;
break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to set Storm Control Meter Index.

In the above function, all Storm Control Meter Index will be used to set to register for related Storm group.

rtk_api_ret_t rtk_rate_stormControlMeterIdx




NEXT




<s> static ssize_t sc_tag_show_u32tvs(const u8 *pld, u16 pld_len, char *buf,
const struct sc_u32tvs tvs[], const int tvselmts)
{
const char *fmt;
char *out = buf;
u32 data;	// cpu-endian
int i;

// fallback to raw hex output if we can't handle the input
if (tvselmts < 0)
return routerboot_tag_show_u32s(pld, pld_len, buf);

if (sizeof(data) != pld_len)
return -EINVAL;

read_lock(&sc_bufrwl);
data = *(u32 *)pld;		// pld aliases sc_buf
read_unlock(&sc_bufrwl);

for (i = 0; i < tvselmts; i++) {
fmt = (tvs[i].val == data) ? "[%s] " : "%s ";
out += sprintf(out, fmt, tvs[i].str);
}

out += sprintf(out, "\n");
return out - buf;
}

The above function is used to decode a 32-bit tag value in the
sc_tag_show_u32tvs() function; the latter is called inside the
sc_tag_show() function:

static ssize_t sc_




NEXT




<s> static u32 rtl931x_get_analog_sds(u32 sds)
{
u32 sds_map[] = { 0, 1, 2, 3, 6, 7, 10, 11, 14, 15, 18, 19, 22, 23 };

if (sds < 14)
return sds_map[sds];

return sds;
}

The above function is used to convert the SDS value to an analog SDS during the
calibrated FPGA RSSI setting.

#endif

static void rtl931x_set_digital_rssi(u8 r




NEXT




<s> rtk_api_ret_t rtk_rate_stormControlExtEnable_get(rtk_rate_storm_group_t stormType, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (stormType >= STORM_GROUP_END)
return RT_ERR_SFC_UNKNOWN_GROUP;

if (NULL == pEnable)
return RT_ERR_NULL_POINTER;

switch (stormType)
{
case STORM_GROUP_UNKNOWN_UNICAST:
if ((retVal = rtl8367c_getAsicStormFilterExtUnknownUnicastEnable((rtk_uint32 *)pEnable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_UNKNOWN_MULTICAST:
if ((retVal = rtl8367c_getAsicStormFilterExtUnknownMulticastEnable((rtk_uint32 *)pEnable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_MULTICAST:
if ((retVal = rtl8367c_getAsicStormFilterExtMulticastEnable((rtk_uint32 *)pEnable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_BROADCAST:
if ((retVal = rtl8367c_getAsicStormFilterExtBroadcastEnable((rtk_uint32 *)pEnable)) != RT_ERR_OK)
return retVal;
break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to read the enabled state of the storm control extension module.

Usage Example 25

rtk_rate_stormControlExtEnable_get(rtk_rate_storm_group_t stormType,&pEnable);






NEXT




<s> char * nvram_find_staging(void)
{
struct stat s;

if( (stat(NVRAM_STAGING, &s) > -1) && (s.st_mode & S_IFREG) )
{
return NVRAM_STAGING;
}

return NULL;
}

The above function is used to find a nvram image (named nvp.bin by default) in a directory which was mounted with the -w option, it is used by the vboot driver to find the nvram image to use.

The vboot driver also




NEXT




<s> ret_t rtl8367c_setAsicRemarkingDscpAbility(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REMARKING_CTRL_REG, RTL8367C_REMARKING_DSCP_ENABLE_OFFSET, enabled);
}

The above function is used to enable the DSCP remarking mode according to the value of the parameter enabled :

enabled==0 : Disable the DSCP remarking mode for all COSes.
enabled==1 : Enable the DSCP remarking




NEXT




<s> int rtk_hal_set_vlan(struct ra_switch_ioctl_data *data)
{
rtk_vlan_cfg_t vlan;
rtk_api_ret_t ret;
int i;

/* clear vlan entry first */
memset(&vlan, 0x00, sizeof(rtk_vlan_cfg_t));
RTK_PORTMASK_CLEAR(vlan.mbr);
RTK_PORTMASK_CLEAR(vlan.untag);
rtk_vlan_set(data->vid, &vlan);

memset(&vlan, 0x00, sizeof(rtk_vlan_cfg_t));
for (i = 0; i < 5; i++) {
if (data->port_map & (1 << i)) {
RTK_PORTMASK_PORT_SET(vlan.mbr, i);
RTK_PORTMASK_PORT_SET(vlan.untag, i);
rtk_vlan_portPvid_set(i, data->vid, 0);
}
}
for (i = 0; i < 2; i++) {
if (data->port_map & (1 << (i + 5))) {
RTK_PORTMASK_PORT_SET(vlan.mbr, (i + EXT_PORT0));
RTK_PORTMASK_PORT_SET(vlan.untag, (i + EXT_PORT0));
rtk_vlan_portPvid_set((i + EXT_PORT0), data->vid, 0);
}
}
vlan.ivl_en = 1;
ret = rtk_vlan_set(data->vid, &vlan);

return 0;
}

The above function is used to set VLAN configuration after the switch is rebooted so that VLAN configuration is always kept.</s>




NEXT




<s> static int routerboot_dtbsfixup(struct mtd_info *, struct routerboot_dynpart *);

static struct routerboot_dynpart rb_dynparts[] = {
{
.name = "hard_config",
.magic = RB_MAGIC_HARD,	// stored in CPU-endianness on flash
.size_fixup = NULL,
.offset = 0x0,
.size = RB_BLOCK_SIZE,
.found = false,
}, {
.name = "soft_config",
.magic = RB_MAGIC_SOFT,	// stored in CPU-endianness on flash
.size_fixup = NULL,
.offset = 0x0,
.size = RB_BLOCK_SIZE,
.found = false,
}, {
.name = "dtb_config",
.magic = fdt32_to_cpu(OF_DT_HEADER),	// stored BE on flash
.size_fixup = routerboot_dtbsfixup,
.offset = 0x0,
.size = 0x0,
.found = false,
}
};

The above function is used to scan the device tree to see if the device tree
is in the dtb_config part. (we only support one dtb_config part) If the dtb_config
part is detected, we will fill the size of rt and




NEXT




<s> static void ag71xx_rings_cleanup(struct ag71xx *ag)
{
ag71xx_ring_rx_clean(ag);
ag71xx_ring_tx_clean(ag);
ag71xx_rings_free(ag);

netdev_reset_queue(ag->dev);
}

The above function is used to clean up a queue when it becomes defcient. This is currently triggered when all the packets are dropped by the NAPI poll. This is a hack!

Please see this mail.</s>




NEXT




<s> void expr_free(struct expr *e)
{
if (!e)
return;

switch (e->type) {
case E_SYMBOL:
break;
case E_NOT:
expr_free(e->left.expr);
break;
case E_EQUAL:
case E_GEQ:
case E_GTH:
case E_LEQ:
case E_LTH:
case E_UNEQUAL:
break;
case E_OR:
case E_AND:
expr_free(e->left.expr);
expr_free(e->right.expr);
break;
default:
fprintf(stderr, "how to free type %d?\n", e->type);
break;
}
free(e);
}

The above function is used to free the struct expr in the tree for a given expression. The current solution has an obvious problem: what if the type of one of the children is E_SYMBOL? That type doesn't store a pointer to an actual struct expr, so there




NEXT




<s> void expr_gstr_print_revdep(struct expr *e, struct gstr *gs,
tristate pr_type, const char *title)
{
expr_print_revdep(e, expr_print_gstr_helper, gs, pr_type, &title);
}

The above function is used to recursively print the reverse dependency
of a gstr on the tree. It works like a normal expr_print_revdep,
except that it calls expr_print_gstr_helper instead of expr_print_gstr
to




NEXT




<s> int aes_chip_init (void);
void des_chip_init (void);
int deu_dma_init (void);
u32 endian_swap(u32 input);
u32* memory_alignment(const u8 *arg, u32 *buff_alloc, int in_out, int nbytes);
void dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);
void chip_version(void);
void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to swap bytes of a data in 32-bit
word according to the endianess used in your platform.


/*! \fn void chip_version(void)
*  \param None
*  \brief The chip




NEXT




<s> void nand_dev_reset(struct nand_chip *chip)
{
writeb(NAND_CMD_RESET, chip->IO_ADDR_W + BIT(NAND_CLE_ADDR_PIN));
udelay(chip->chip_delay);
writeb(NAND_CMD_STATUS, chip->IO_ADDR_W + BIT(NAND_CLE_ADDR_PIN));
while (!(readb(chip->IO_ADDR_R) & NAND_STATUS_READY)) {
;
}
}

The above function is used to reset the nand_chip before doing erase and verify</s>




NEXT




<s> void wpas_ucode_add_bss(struct wpa_supplicant *wpa_s)
{
uc_value_t *val;

if (wpa_ucode_call_prepare("iface_add"))
return;

uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
uc_value_push(ucv_get(wpas_ucode_iface_get_uval(wpa_s)));
ucv_put(wpa_ucode_call(2));
ucv_gc(vm);
}

The above function is used to add/create interfaces which is used for a bss
association.

My question is ,how the above function is called? Is it called from a
driver or some core code of hostapd? If I try to add




NEXT




<s> static int rtl8367_enable_port(struct rtl8366_smi *smi, int port, int enable)
{
int err;

REG_WR(smi, RTL8367_PORT_ISOLATION_REG(port),
(enable) ? RTL8367_PORTS_ALL : 0);

return 0;
}

The above function is used to enable or disable a port on the switch. For the enabling, the function sets a bit indicating that this port is enabled, and for the disabling, the function clears this bit. The switch checks this bit each time it polls the port




NEXT




<s> ret_t rtl8367c_getAsicRldpEnable8051(rtk_uint32 *pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_8051_ENABLE_OFFSET, pEnabled);
}

The above function is used to check Rldp 8051 enable bit, we can see the enable bit of all three Rldp is set, hence the 8051 operation supported.

There are some questions in the code and need some explanation




NEXT




<s> static int rtl838x_mdio_read_paged(struct mii_bus *bus, int mii_id, u16 page, int regnum)
{
u32 val;
int err;
struct rtl838x_eth_priv *priv = bus->priv;

if (mii_id >= 24 && mii_id <= 27 && priv->id == 0x8380)
return rtl838x_read_sds_phy(mii_id, regnum);

if (regnum & (MII_ADDR_C45 | MII_ADDR_C22_MMD)) {
err = rtl838x_read_mmd_phy(mii_id,
mdiobus_c45_devad(regnum),
regnum, &val);
pr_debug("MMD: %d dev %x register %x read %x, err %d\n", mii_id,
mdiobus_c45_devad(regnum), mdiobus_c45_regad(regnum),
val, err);
} else {
pr_debug("PHY: %d register %x read %x, err %d\n", mii_id, regnum, val, err);
err = rtl838x_read_phy(mii_id, page, regnum, &val);
}
if (err)
return err;

return val;
}

The above function is used to read the register of PHY from
paged phy.

The following steps will show how to read the register of phy using
read_paged method.

-  The mdiobus_c45_




NEXT




<s> static char *do_error_if(int argc, char *argv[])
{
if (!strcmp(argv[0], "y"))
pperror("%s", argv[1]);

return xstrdup("");
}

The above function is used to print a message that a function or macro calls
an error. The macro is used for this purpose:

struct stat sbuf;
if (stat(argv[0], &sbuf ))
do_error_if(argc,




NEXT




<s> ret_t rtl8367c_setAsic1xProcConfig(rtk_uint32 port, rtk_uint32 proc)
{

if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(proc >= DOT1X_UNAUTH_END)
return RT_ERR_DOT1X_PROC;

if(port < 8)
{
return rtl8367c_setAsicRegBits(RTL8367C_DOT1X_UNAUTH_ACT_BASE, RTL8367C_DOT1X_UNAUTH_ACT_MASK(port),proc);
}
else
{
return rtl8367c_setAsicRegBits(RTL8367C_REG_DOT1X_UNAUTH_ACT_W1, RTL8367C_DOT1X_UNAUTH_ACT_MASK(port),proc);
}
}

The above function is used to enable/disable the Dot1x Unauthenticated function in the ASIC register. And it is a macro function of the following two functions

static inline rtk_uint32
rtl8367c_set




NEXT




<s> rtk_api_ret_t rtk_cpu_awarePort_get(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicCputagPortmask(&pmsk)) != RT_ERR_OK)
return retVal;

if(rtk_switch_portmask_P2L_get(pmsk, pPortmask) != RT_ERR_OK)
return RT_ERR_FAILED;

return RT_ERR_OK;
}

The above function is used to retrieve the CPU aware ports from ASIC by this flow: 1. query all the switch port to API 2. query all the cpu tag port from ASIC. 3. get map from HW CPU port to SW port and put




NEXT




<s> swlib_alloc(size_t size)
{
void *ptr;

ptr = malloc(size);
if (!ptr)
goto done;
memset(ptr, 0, size);

done:
return ptr;
}

The above function is used to allocate memory in a library. When it is first called it will probably fail because there is no allocated memory available. But when your code calls functions in your library, each time swlib_alloc does not succeed but instead it fails, it frees




NEXT




<s> static int qca807x_cable_test_report(struct phy_device *phydev)
{
int pair0, pair1, pair2, pair3;
int ret;

ret = phy_read_mmd(phydev, MDIO_MMD_PCS, QCA807X_CDT_MMD3_STATUS);
if (ret < 0)
return ret;

pair0 = FIELD_GET(QCA807X_CDT_MDI0_STATUS_MASK, ret);
pair1 = FIELD_GET(QCA807X_CDT_MDI1_STATUS_MASK, ret);
pair2 = FIELD_GET(QCA807X_CDT_MDI2_STATUS_MASK, ret);
pair3 = FIELD_GET(QCA807X_CDT_MDI3_STATUS_MASK, ret);

ethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_A,
qca807x_cable_test_report_trans(pair0));
ethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_B,
qca807x_cable_test_report_trans(pair1));
ethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_C,
qca807x_cable_test_report_trans(pair2));
ethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_D,
qca807x_cable_test_report_trans(pair3));

if (qca807x_distance_valid(pair0))
qca807x_report_length(phydev, 0, qca807x_cable_test_report_trans(pair0));
if (qca807x_distance_valid(pair1))
qca807x_report_length(phydev, 1, qca807x_cable_test_report_trans(pair1));
if (qca807x_distance_valid(pair2))
qca807x_report_length(phydev, 2, qca807x_cable_test_report_trans(pair2));
if (qca807x_distance_valid(pair3))
qca807x_report_length(phydev, 3, qca807x_cable_test_report_trans(pair3));

return 0;
}

The above function is used to enable report cable length for
QCA807X devices.

qca807x_report_length(phydev, port, trans)

reports the cable length for the specified port, using the
trans




NEXT




<s> static const char *md5_hash(FILE *f)
{
MD5_CTX ctx;
unsigned char val[MD5_DIGEST_LENGTH];
void *buf;
int len;

MD5_begin(&ctx);
while ((buf = hash_buf(f, &len)) != NULL)
MD5_hash(buf, len, &ctx);
MD5_end(val, &ctx);

return hash_string(val, MD5_DIGEST_LENGTH);
}

The above function is used to has the content of a file using MD5 algorithm .
You can also use the function defined below to verify the hash value of your file :

static int md5_verify(FILE* f, const char *h) {
unsigned




NEXT




<s> MD5_hash(const void *data, size_t size, MD5_CTX *ctx)
{
uint32_t saved_lo;
unsigned long used, available;

saved_lo = ctx->lo;
if ((ctx->lo = (saved_lo + size) & 0x1fffffff) < saved_lo)
ctx->hi++;
ctx->hi += size >> 29;

used = saved_lo & 0x3f;

if (used) {
available = 64 - used;

if (size < available) {
memcpy(&ctx->buffer[used], data, size);
return;
}

memcpy(&ctx->buffer[used], data, available);
data = (const unsigned char *)data + available;
size -= available;
MD5_body(ctx, ctx->buffer, 64);
}

if (size >= 64) {
data = MD5_body(ctx, data, size & ~((size_t) 0x3f));
size &= 0x3f;
}

memcpy(ctx->buffer, data, size);
}

The above function is used to fill in the rest of the bits in the
MD5 context (the 64 bits) and calculate the data.

The MD5_body() is used on the inner loop of the actual algorithm
(the function MD5_




NEXT




<s> static int ag71xx_rx_packets(struct ag71xx *ag, int limit)
{
struct net_device *dev = ag->dev;
struct ag71xx_ring *ring = &ag->rx_ring;
unsigned int pktlen_mask = ag->desc_pktlen_mask;
unsigned int offset = ag->rx_buf_offset;
int ring_mask = BIT(ring->order) - 1;
int ring_size = BIT(ring->order);
struct list_head rx_list;
struct sk_buff *next;
struct sk_buff *skb;
int done = 0;

DBG("%s: rx packets, limit=%d, curr=%u, dirty=%u\n",
dev->name, limit, ring->curr, ring->dirty);
INIT_LIST_HEAD(&rx_list);

while (done < limit) {
unsigned int i = ring->curr & ring_mask;
struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
int pktlen;
int err = 0;

if (ag71xx_desc_empty(desc))
break;

if ((ring->dirty + ring_size) == ring->curr) {
ag71xx_assert(0);
break;
}

ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);

pktlen = desc->ctrl & pktlen_mask;
pktlen -= ETH_FCS_LEN;

dma_unmap_single(&ag->pdev->dev, ring->buf[i].dma_addr,
ag->rx_buf_size, DMA_FROM_DEVICE);

dev->stats.rx_packets++;
dev->stats.rx_bytes += pktlen;

skb = napi_build_skb(ring->buf[i].rx_buf, ag71xx_buffer_size(ag));
if (!skb) {
skb_free_frag(ring->buf[i].rx_buf);
goto next;
}

skb_reserve(skb, offset);
skb_put(skb, pktlen);

if (err) {
dev->stats.rx_dropped++;
kfree_skb(skb);
} else {
skb->dev = dev;
skb->ip_summed = CHECKSUM_NONE;
list_add_tail(&skb->list, &rx_list);
}

next:
ring->buf[i].rx_buf = NULL;
done++;

ring->curr++;
}

ag71xx_ring_rx_refill(ag);

list_for_each_entry_safe(skb, next, &rx_list, list)
skb->protocol = eth_type_trans(skb, dev);
netif_receive_skb_list(&rx_list);

DBG("%s: rx finish, curr=%u, dirty=%u, done=%d\n",
dev->name, ring->curr, ring->dirty, done);

return done;
}

The above function is used to read packets off the receiving ring. It is called by the

ag71xx_rx_process(struct ag71xx *ag, struct ag71xx_queue *q)
{
napi_enable(q




NEXT




<s> rtk_api_ret_t rtk_trap_unknownUnicastPktAction_set(rtk_port_t port, rtk_trap_ucast_action_t ucast_action)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if (ucast_action >= UCAST_ACTION_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicPortUnknownDaBehavior(rtk_switch_port_L2P_get(port), ucast_action)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the actions of an unknown unicast packet.

rtk_trap_ucast_action_t 			ucast_action;

#define UCAST_ACTION_DROP 0

#




NEXT




<s> void sata_oxnas_link_write(struct ata_port *ap, unsigned int link_reg, u32 val)
{
struct sata_oxnas_port_priv *pd = ap->private_data;
struct sata_oxnas_host_priv *hd = ap->host->private_data;
void __iomem *port_base = pd->port_base;
u32 patience;
unsigned long flags;

DPRINTK("P%d [0x%02x]->0x%08x\n", ap->port_no, link_reg, val);

spin_lock_irqsave(&hd->phy_lock, flags);
iowrite32(val, port_base + LINK_DATA);

/* accessed twice as a work around for a bug in the SATA abp bridge
* hardware (bug 6828) */
iowrite32(link_reg , port_base + LINK_WR_ADDR);
ioread32(port_base + LINK_WR_ADDR);

for (patience = 0x100000; patience > 0; --patience) {
if (ioread32(port_base + LINK_CONTROL) & 0x00000001)
break;
}
spin_unlock_irqrestore(&hd->phy_lock, flags);
}

The above function is used to configure port link parameters
(LINK_CTL) and port control parameters (LINK_CTRL).
Link control parameters are readback with an ioctl, and there seems to be
no reason why write should fail.  Without access to a source




NEXT




<s> static int fe_open(struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);
unsigned long flags;
u32 val;
int err;

err = fe_init_dma(priv);
if (err) {
fe_free_dma(priv);
return err;
}

spin_lock_irqsave(&priv->page_lock, flags);

val = FE_TX_WB_DDONE | FE_RX_DMA_EN | FE_TX_DMA_EN;
if (priv->flags & FE_FLAG_RX_2B_OFFSET)
val |= FE_RX_2B_OFFSET;
val |= priv->soc->pdma_glo_cfg;
fe_reg_w32(val, FE_REG_PDMA_GLO_CFG);

spin_unlock_irqrestore(&priv->page_lock, flags);

if (priv->phy)
priv->phy->start(priv);

if (priv->soc->has_carrier && priv->soc->has_carrier(priv))
netif_carrier_on(dev);

napi_enable(&priv->rx_napi);
fe_int_enable(priv->soc->tx_int | priv->soc->rx_int);
netif_start_queue(dev);

return 0;
}

The above function is used to initialize and register the data transfer process. However, one of the processes failed when executed. The code is:
Code:
static u16 fe_read(struct fe_priv *priv, unsigned int addr)
{
unsigned long




NEXT




<s> static int rtl8366_smi_enable_all_ports(struct rtl8366_smi *smi, int enable)
{
int port;
int err;

for (port = 0; port < smi->num_ports; port++) {
err = smi->ops->enable_port(smi, port, enable);
if (err)
return err;
}

return 0;
}

The above function is used to activate all 20 ports present on a PCIe
interface of a RTL8366 switch after its reset. This function returns 0
on success. When it should be enabled and port 16 (17 bits from




NEXT




<s> static int rtl8231_pin_dir_get(struct rtl8231_gpios *gpios, u32 gpio, u32 *dir)
{
/* dir 1: input
* dir 0: output
*/

u32  v;
int pin_dir_addr = RTL8231_GPIO_DIR(gpio);
int pin = gpio % 16;

if (gpio > 31) {
pin_dir_addr = RTL8231_GPIO_PIN_SEL(gpio);
pin += 5;
}

v = rtl8231_read(gpios, pin_dir_addr);
if (v & (1 << pin))
*dir = 1;
else
*dir = 0;

return 0;
}

The above function is used to read the direction of GPIO for single pin access.</s>




NEXT




<s> static int rtl838x_get_link_ksettings(struct net_device *ndev,
struct ethtool_link_ksettings *cmd)
{
struct rtl838x_eth_priv *priv = netdev_priv(ndev);

pr_debug("%s called\n", __func__);

return phylink_ethtool_ksettings_get(priv->phylink, cmd);
}

The above function is used to read link knetwork settings.

Link knetwork settings refers to those knetwork parameters that define link parameters like link speed, link duplex mode, media type, etc. These parameters are important to describe the current link status of




NEXT




<s> static void __exit routerboot_exit(void)
{
unregister_mtd_user(&routerboot_mtd_notifier);
/* Exit routines are idempotent */
rb_softconfig_exit();
rb_hardconfig_exit();
kobject_put(rb_kobj);	// recursive afaict
}

The above function is used to exit on crash etc. In particular if the kernel
crashes and the recovery system resets it, this is going to be used. However
a kernel crash is likely to reset the routerboard too. When the routerboard
resets after




NEXT




<s> static void __exit gpio_button_exit(void)
{
platform_driver_unregister(&gpio_keys_driver);
platform_driver_unregister(&gpio_keys_polled_driver);
}

The above function is used to deinit and unregister the device driver. Lets now look at the init section of the module.
static int __init gpio_button_init(void)
{
struct resource *res;

res = platform_get




NEXT




<s> swconfig_trig_activate(struct led_classdev *led_cdev)
{
struct switch_led_trigger *sw_trig;
struct swconfig_trig_data *trig_data;
int err;

trig_data = kzalloc(sizeof(struct swconfig_trig_data), GFP_KERNEL);
if (!trig_data)
return -ENOMEM;

sw_trig = (void *) led_cdev->trigger;

rwlock_init(&trig_data->lock);
trig_data->led_cdev = led_cdev;
trig_data->swdev = sw_trig->swdev;
trig_data->speed_mask = SWCONFIG_LED_PORT_SPEED_ALL;
trig_data->mode = SWCONFIG_LED_MODE_ALL;
led_cdev->trigger_data = trig_data;

err = device_create_file(led_cdev->dev, &dev_attr_port_mask);
if (err)
goto err_free;

err = device_create_file(led_cdev->dev, &dev_attr_speed_mask);
if (err)
goto err_dev_free;

err = device_create_file(led_cdev->dev, &dev_attr_mode);
if (err)
goto err_mode_free;

return 0;

err_mode_free:
device_remove_file(led_cdev->dev, &dev_attr_speed_mask);

err_dev_free:
device_remove_file(led_cdev->dev, &dev_attr_port_mask);

err_free:
led_cdev->trigger_data = NULL;
kfree(trig_data);

return err;
}

The above function is used to create triggers on the LED device itself. The function sets the led_cdev’s trigger data to be the trig_data we’ve allocated above. Then it binds the device with 3 sysfs attributes, which are port




NEXT




<s> static int block_load_image_ext4(const char *filename)
{
int err;
struct image_header *header;

header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
sizeof(struct image_header));

err = ext4_read_file(filename, header, 0, sizeof(struct image_header));
if (err <= 0)
goto end;

spl_parse_image_header(header);

err = ext4_read_file(filename, (u8 *)spl_image.load_addr, 0, 0);

end:
return (err <= 0);
}

The above function is used to load ELF into memory when the board is running
ext4. In normal situation, we need to pass the ELF file name, to the block_load
image_ext4() function, which will load ELF to the memory.




NEXT




<s> free_attr_val(const struct switch_attr *attr, const struct switch_val *val)
{
switch (attr->type) {
case SWITCH_TYPE_STRING:
free(val->value.s);
break;
case SWITCH_TYPE_PORTS:
free(val->value.ports);
break;
case SWITCH_TYPE_LINK:
free(val->value.link);
break;
default:
break;
}
}

The above function is used to free some data, according to the structure type.

It's a mistake because it doesn't cover all possible types.

When val is switch_val(SWITCH_TYPE_STRING)
the value.s field




NEXT




<s> static void oxnas_pcie_enable(struct device *dev, struct oxnas_pcie *pcie)
{
struct hw_pci hw;
int i;

memset(&hw, 0, sizeof(hw));
for (i = 0; i < NUM_CONTROLLERS; i++)
pcie->private_data[i] = pcie;

hw.nr_controllers = NUM_CONTROLLERS;
/* I think use stack pointer is a bad idea though it is valid in this case */
hw.private_data   = pcie->private_data;
hw.setup          = oxnas_pcie_setup;
hw.map_irq        = of_irq_parse_and_map_pci;
hw.ops            = &oxnas_pcie_ops;

/* pass dev to maintain of tree, interrupt mapping rely on this */
pci_common_init_dev(dev, &hw);
}

The above function is used to setup all the pcie controllers. I am not sure
what is NUM_CONTROLLERS. But can you check if passing dev to pci_common_init_dev
is really needed?</s>




NEXT




<s> static INLINE struct sk_buff *get_skb_rx_pointer(unsigned int);
static INLINE int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static INLINE int mailbox_rx_irq_handler(unsigned int);
static irqreturn_t mailbox_irq_handler(int, void *);
static INLINE void mailbox_signal(unsigned int, int);
#ifdef CONFIG_IFX_PTM_RX_TASKLET
static void do_ptm_tasklet(unsigned long);
#endif

/*
*  Debug Functions
*/
#if defined(DEBUG_DUMP_SKB) && DEBUG_DUMP_SKB
static void dump_skb(struct sk_buff *, u32, char *, int, int, int);
#else
#define dump_skb(skb, len, title, port, ch, is_tx)    do {} while (0)

The above function is used to generate a
dump of the data in a sk_buff, for
debug purposes or to dump to the console.

Parameters:
        :    skb                        a pointer to the sk_buff in
                                        question. We




NEXT




<s> ret_t rtl8367c_getAsicRmaCsstp(rtl8367c_rma_t* pRmacfg)
{
ret_t retVal;
rtk_uint32 regData;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_RMA_CTRL_CSSTP, &regData);
if(retVal != RT_ERR_OK)
return retVal;

pRmacfg->operation = ((regData >> 7) & 0x0003);
pRmacfg->discard_storm_filter = ((regData >> 6) & 0x0001);
pRmacfg->trap_priority = ((regData >> 3) & 0x0007);
pRmacfg->keep_format = ((regData >> 2) & 0x0001);
pRmacfg->vlan_leaky = ((regData >> 1) & 0x0001);
pRmacfg->portiso_leaky = (regData & 0x0001);

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, &regData);
if(retVal != RT_ERR_OK)
return retVal;

pRmacfg->trap_priority = regData;

return RT_ERR_OK;
}

The above function is used to read the RMA configuration register 2. This is my function:

int rtl8367_getAsicRmaCsstp(struct rtl8367c_rma_t* pR




NEXT




<s> rtk_api_ret_t rtk_svlan_unmatch_action_set(rtk_svlan_unmatch_action_t action, rtk_vlan_t svid)
{
rtk_api_ret_t   retVal;
rtk_uint32      i;
rtl8367c_svlan_memconf_t svlanMemConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (action >= UNMATCH_END)
return RT_ERR_OUT_OF_RANGE;

if (action == UNMATCH_ASSIGN)
{
if (svid > RTL8367C_VIDMAX)
return RT_ERR_SVLAN_VID;
}

if ((retVal = rtl8367c_setAsicSvlanIngressUnmatch((rtk_uint32)action)) != RT_ERR_OK)
return retVal;

if(action == UNMATCH_ASSIGN)
{
for (i = 0; i < RTL8367C_SVIDXNO; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;

if (svid == svlanMemConf.vs_svid)
{
if ((retVal = rtl8367c_setAsicSvlanUnmatchVlan(i)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}
}

return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
}

return RT_ERR_OK;
}

The above function is used to set a SVLAN unmatch action. It takes in a vlan id to specify which vlan we are using and sets the action to UNMATCH_END, UNMATCH_ASSIGN, or UNMATCH_BYPASS.





NEXT




<s> static int rtl8367b_init_regs(struct rtl8366_smi *smi)
{
const struct rtl8367b_initval *initvals;
u32 chip_ver;
u32 rlvid;
int count;
int err;

REG_WR(smi, RTL8367B_RTL_MAGIC_ID_REG, RTL8367B_RTL_MAGIC_ID_VAL);
REG_RD(smi, RTL8367B_CHIP_VER_REG, &chip_ver);

rlvid = (chip_ver >> RTL8367B_CHIP_VER_RLVID_SHIFT) &
RTL8367B_CHIP_VER_RLVID_MASK;

switch (rlvid) {
case 0:
initvals = rtl8367r_vb_initvals_0;
count = ARRAY_SIZE(rtl8367r_vb_initvals_0);
break;

case 1:
initvals = rtl8367r_vb_initvals_1;
count = ARRAY_SIZE(rtl8367r_vb_initvals_1);
break;

default:
dev_err(smi->parent, "unknow rlvid %u\n", rlvid);
return -ENODEV;
}

/* TODO: disable RLTP */

return rtl8367b_write_initvals(smi, initvals, count);
}

The above function is used to initialize registers and is used
only once, so the driver is not worried about any locks. I will
probably change this later, to only lock around those registers.

Next is the function which really makes the device work after
en




NEXT




<s> static int qca807x_gpio_get(struct gpio_chip *gc, unsigned int offset)
{
struct qca807x_gpio_priv *priv = gpiochip_get_data(gc);
int val;

val = phy_read_mmd(priv->phy, MDIO_MMD_AN, qca807x_gpio_get_reg(offset));

return FIELD_GET(QCA807X_GPIO_FORCE_MODE_MASK, val);
}

The above function is used to get the force mode of specific
GPIO pin. The function uses macro(qca807x_gpio_get_reg), which does
the following (shown in the following snippet).

REG_AN_PHY_




NEXT




<s> static ssize_t reg_ops(struct file *file,
const char __user *buffer, size_t count,
loff_t *data)
{
char buf[64];
unsigned int offset;
unsigned int val;

memset(buf, 0, 64);

if (copy_from_user(buf, buffer, count))
return -EFAULT;


if(buf[0] == 'w') {

if(sscanf(buf, "w %x %x", &offset,&val) == -1)
return -EFAULT;
else
rtk_hal_write_reg(offset,val);

} else {

if(sscanf(buf, "r %x", &offset) == -1)
return -EFAULT;
else
rtk_hal_read_reg(offset);
}

return count;
}

The above function is used to simulate the /proc/reg interface.
However, the above function can only handle a 32-bit register word. If
we need to handle 64-bit register word, the size of the offset and
values parameters




NEXT




<s> ret_t rtl8367c_setAsicStormFilterMulticastMeter(rtk_uint32 port, rtk_uint32 meter)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(meter > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

return rtl8367c_setAsicRegBits(RTL8367C_STORM_MCAST_METER_CTRL_REG(port), RTL8367C_STORM_MCAST_METER_CTRL_MASK(port), meter);
}

The above function is used to set the multicast storm filter meter in port 0..4 (port_no). I am using it as a function call as mentioned below

ret_t rtl8367c_setAsicStormFilterMult




NEXT




<s> adm6996_enable_vlan(struct adm6996_priv *priv)
{
u16 reg;

reg = r16(priv, ADM_OTBE_P2_PVID);
reg &= ~(ADM_OTBE_MASK);
w16(priv, ADM_OTBE_P2_PVID, reg);
reg = r16(priv, ADM_IFNTE);
reg &= ~(ADM_IFNTE_MASK);
w16(priv, ADM_IFNTE, reg);
reg = r16(priv, ADM_VID_CHECK);
reg |= ADM_VID_CHECK_MASK;
w16(priv, ADM_VID_CHECK, reg);
reg = r16(priv, ADM_SYSC0);
reg |= ADM_NTTE;
reg &= ~(ADM_RVID1);
w16(priv, ADM_SYSC0, reg);
reg = r16(priv, ADM_SYSC3);
reg |= ADM_TBV;
w16(priv, ADM_SYSC3, reg);
}

The above function is used to register a VLAN filter only</s>




NEXT




<s> static int ubnt_ledbar_probe(struct i2c_client *client,
const struct i2c_device_id *id)
{
struct device_node *np = client->dev.of_node;
struct ubnt_ledbar *ledbar;
int ret;

ledbar = devm_kzalloc(&client->dev, sizeof(*ledbar), GFP_KERNEL);
if (!ledbar)
return -ENOMEM;

ledbar->enable_gpio = devm_gpiod_get(&client->dev, "enable", GPIOD_OUT_LOW);

if (IS_ERR(ledbar->enable_gpio)) {
ret = PTR_ERR(ledbar->enable_gpio);
dev_err(&client->dev, "Failed to get enable gpio: %d\n", ret);
return ret;
}

ledbar->reset_gpio = devm_gpiod_get_optional(&client->dev, "reset", GPIOD_OUT_LOW);

if (IS_ERR(ledbar->reset_gpio)) {
ret = PTR_ERR(ledbar->reset_gpio);
dev_err(&client->dev, "Failed to get reset gpio: %d\n", ret);
return ret;
}

ledbar->led_count = 1;
of_property_read_u32(np, "led-count", &ledbar->led_count);

ledbar->client = client;

mutex_init(&ledbar->lock);

i2c_set_clientdata(client, ledbar);

// Reset and initialize the MCU
ubnt_ledbar_reset(ledbar);

ledbar->led_red.brightness_set_blocking = ubnt_ledbar_set_red_brightness;
ubnt_ledbar_init_led(of_get_child_by_name(np, "red"), ledbar, &ledbar->led_red);

ledbar->led_green.brightness_set_blocking = ubnt_ledbar_set_green_brightness;
ubnt_ledbar_init_led(of_get_child_by_name(np, "green"), ledbar, &ledbar->led_green);

ledbar->led_blue.brightness_set_blocking = ubnt_ledbar_set_blue_brightness;
ubnt_ledbar_init_led(of_get_child_by_name(np, "blue"), ledbar, &ledbar->led_blue);

return ubnt_ledbar_apply_state(ledbar);
}

The above function is used to initialize the structure.

Another function which will use the above function is ubnt_ledbar_remove.

int ubnt_ledbar_remove(struct i2c_client *client)
{
struct ubnt




NEXT




<s> static int rtl8367s_hw_init(void)
{

rtl8367s_hw_reset();

if(rtk_switch_init())
return -1;

mdelay(500);

if (rtk_vlan_reset())
return -1;

if (rtk_vlan_init())
return -1;

return 0;
}

The above function is used to perform the necessary device initializations
needed before starting the traffic path (data plane) for the rtl8367s switch.</s>




NEXT




<s> static void vr9_fw_ver(unsigned int *major, unsigned int *minor)
{

*major = FW_VER_ID->major;
*minor = FW_VER_ID->minor;
}

The above function is used to determine the F/W version:
#define FRONT_FLASH_VER(major,minor) vr9_fw_ver(major,minor)

In case of firmware 7322, it outputs




NEXT




<s> static void rtl931x_sds_fiber_mode_set(u32 sds, phy_interface_t mode)
{
u32 val, asds = rtl931x_get_analog_sds(sds);

/* clear symbol error count before changing mode */
rtl931x_symerr_clear(sds, mode);

val = 0x9F;
sw_w32(val, RTL931X_SERDES_MODE_CTRL + 4 * (sds >> 2));

switch (mode) {
case PHY_INTERFACE_MODE_SGMII:
val = 0x5;
break;

case PHY_INTERFACE_MODE_1000BASEX:
/* serdes mode FIBER1G */
val = 0x9;
break;

case PHY_INTERFACE_MODE_10GBASER:
case PHY_INTERFACE_MODE_10GKR:
val = 0x35;
break;
/*	case MII_10GR1000BX_AUTO:
val = 0x39;
break; */


case PHY_INTERFACE_MODE_USXGMII:
val = 0x1B;
break;
default:
val = 0x25;
}

pr_info("%s writing analog SerDes Mode value %02x\n", __func__, val);
rtl9310_sds_field_w(asds, 0x1F, 0x9, 11, 6, val);

return;
}

The above function is used to program the SerDes device, based on the operating mode.
The function does not take the SerDes mode itself into consideration in the algorithm, that is either single-lane mode or
multi-lane mode is detected and handled by the SerDes




NEXT




<s> static void rijndaelEncrypt(const u32 rk[/*44*/], const u8 pt[16], u8 ct[16])
{
u32 s0, s1, s2, s3, t0, t1, t2, t3;
const int Nr = 10;
#ifndef FULL_UNROLL
int r;
#endif /* ?FULL_UNROLL */

/*
* map byte array block to cipher state
* and add initial round key:
*/
s0 = GETU32(pt     ) ^ rk[0];
s1 = GETU32(pt +  4) ^ rk[1];
s2 = GETU32(pt +  8) ^ rk[2];
s3 = GETU32(pt + 12) ^ rk[3];

#define ROUND(i,d,s) \
d##0 = TE0(s##0) ^ TE1(s##1) ^ TE2(s##2) ^ TE3(s##3) ^ rk[4 * i]; \
d##1 = TE0(s##1) ^ TE1(s##2) ^ TE2(s##3) ^ TE3(s##0) ^ rk[4 * i + 1]; \
d##2 = TE0(s##2) ^ TE1(s##3) ^ TE2(s##0) ^ TE3(s##1) ^ rk[4 * i + 2]; \
d##3 = TE0(s##3) ^ TE1(s##0) ^ TE2(s##1) ^ TE3(s##2) ^ rk[4 * i + 3]

#ifdef FULL_UNROLL

ROUND(1,t,s);
ROUND(2,s,t);
ROUND(3,t,s);
ROUND(4,s,t);
ROUND(5,t,s);
ROUND(6,s,t);
ROUND(7,t,s);
ROUND(8,s,t);
ROUND(9,t,s);

rk += Nr << 2;

#else  /* !FULL_UNROLL */

/* Nr - 1 full rounds: */
r = Nr >> 1;
for (;;) {
ROUND(1,t,s);
rk += 8;
if (--r == 0)
break;
ROUND(0,s,t);
}

#endif /* ?FULL_UNROLL */

#undef ROUND

/*
* apply last round and
* map cipher state to byte array block:
*/
s0 = TE41(t0) ^ TE42(t1) ^ TE43(t2) ^ TE44(t3) ^ rk[0];
PUTU32(ct     , s0);
s1 = TE41(t1) ^ TE42(t2) ^ TE43(t3) ^ TE44(t0) ^ rk[1];
PUTU32(ct +  4, s1);
s2 = TE41(t2) ^ TE42(t3) ^ TE43(t0) ^ TE44(t1) ^ rk[2];
PUTU32(ct +  8, s2);
s3 = TE41(t3) ^ TE42(t0) ^ TE43(t1) ^ TE44(t2) ^ rk[3];
PUTU32(ct + 12, s3);
}

The above function is used to encrypt a block of input data within the Rijndael cipher mode. The function accepts a pointer to the array of 32-bit round keys and a pointer to the 16-byte block of data to be encrypted




NEXT




<s> void menu_end_menu(void)
{
last_entry_ptr = &current_menu->next;
current_menu = current_menu->parent;
}

The above function is used to exit a menu to the function that called the menu.
The "last_entry_ptr" variable is used to tell which menu_entry is the last one.
That way you don't have a chance to select an entry.





NEXT




<s> ret_t rtl8367c_getAsicIgmp(rtk_uint32 *ptr_enabled)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_EN_OFFSET, ptr_enabled);
return retVal;
}

The above function is used to set IGMP Snooping on in DPDK. I am not sure about the correct syntax.

What is the correct syntax to enable igmp snooping. I found these in the linux-dpdk wiki





NEXT




<s> ret_t rtl8367c_getAsicIGMPPortCurrentGroup(rtk_uint32 port, rtk_uint32 *current_group)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT01_CURRENT_GROUP + (port/2), RTL8367C_PORT0_CURRENT_GROUP_MASK << (RTL8367C_PORT1_CURRENT_GROUP_OFFSET * (port%2)), &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT89_CURRENT_GROUP + ((port - 8)/2), RTL8367C_PORT0_CURRENT_GROUP_MASK << (RTL8367C_PORT1_CURRENT_GROUP_OFFSET * (port%2)), &value);
if(retVal != RT_ERR_OK)
return retVal;
}

*current_group = value;
return RT_ERR_OK;
}

The above function is used to get the current group membership of the specified port. The function arguments are port number (which can be any port number from 0~15) in the network, and the pointer to the variable (contianing 8~16 bits




NEXT




<s> static int ehci_oxnas_drv_remove(struct platform_device *pdev)
{
struct usb_hcd *hcd = platform_get_drvdata(pdev);
struct oxnas_hcd *oxnas = (struct oxnas_hcd *)hcd_to_ehci(hcd)->priv;

usb_remove_hcd(hcd);
if (oxnas->use_pllb) {
clk_disable_unprepare(oxnas->phyref);
clk_put(oxnas->phyref);
clk_disable_unprepare(oxnas->refsrc);
clk_put(oxnas->refsrc);
}
clk_disable_unprepare(oxnas->clk);
usb_put_hcd(hcd);

return 0;
}

The above function is used to cleanly remove an EHCI host controller at
device removal time. The function is not currently being used; however,
is it a good idea to remove it?

The USB3 drivers are not yet at a stage where we are




NEXT




<s> static int read_sector(off_t pos)
{
if (pread(mtdfd, readbuf, TFFS_SECTOR_SIZE, pos) != TFFS_SECTOR_SIZE) {
return -1;
}

sector_ids[pos / TFFS_SECTOR_SIZE] = read_uint32(readbuf, 0x00);

return 0;
}

The above function is used to fetch the next sector to the readbuf array. The first thing that I did was to debug this function, so that I understand how it is meant to work.

Then I changed the array readbuf from an array of 512




NEXT




<s> static void uc_bpf_fd_free(void *ptr)
{
struct uc_bpf_fd *f = ptr;

if (f->close)
close(f->fd);
free(f);
}

The above function is used to free resources allocated for bpf file descriptor. It looks like that it is called when the uc_bpf_program_file() function is called. Does this mean that if there is some program loaded, it cannot be unloaded? As




NEXT




<s> u32* memory_alignment(const u8 *arg, u32 *buff_alloc, int in_out, int nbytes);
void dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);
void chip_version(void);
void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to convert the input in big-endian to little endian in case required

/*! \fn u8* memory_alignment(const u8 *arg, u32 *buff_alloc, int in_out , int nbytes




NEXT




<s> adm6996_apply_vlan_filters_6996l(struct adm6996_priv *priv)
{
u8 ports;
u16 reg;
int i;

for (i = 0; i < ADM_NUM_VLANS; i++) {
ports = priv->vlan_table[i];

if (ports == 0) {
/* Disable VLAN entry */
w16(priv, ADM_VLAN_MAP(i), 0);
continue;
} else {
reg = ADM_VLAN_FILT(ports);
w16(priv, ADM_VLAN_MAP(i), reg);
}
}
}

The above function is used to write a port mask to the adm6996 for a
VLAN/tagged port entry.  The adm6996 has 16 VLAN tags in its
register space and as it’s an on-chip




NEXT




<s> ar8327_read_port_status(struct ar8xxx_priv *priv, int port)
{
u32 t;

t = ar8xxx_read(priv, AR8327_REG_PORT_STATUS(port));
/* map the flow control autoneg result bits to the flow control bits
* used in forced mode to allow ar8216_read_port_link detect
* flow control properly if autoneg is used
*/
if (t & AR8216_PORT_STATUS_LINK_UP &&
t & AR8216_PORT_STATUS_LINK_AUTO) {
t &= ~(AR8216_PORT_STATUS_TXFLOW | AR8216_PORT_STATUS_RXFLOW);
if (t & AR8327_PORT_STATUS_TXFLOW_AUTO)
t |= AR8216_PORT_STATUS_TXFLOW;
if (t & AR8327_PORT_STATUS_RXFLOW_AUTO)
t |= AR8216_PORT_STATUS_RXFLOW;
}

return t;
}

The above function is used to return different values depending on
whether manual or semi transparent auto is used to set the flow control
bits. It is called from the ar8216_read_port_link function which is
used by the ar916




NEXT




<s> ar8236_init_globals(struct ar8xxx_priv *priv)
{
/* enable jumbo frames */
ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
AR8316_GCTRL_MTU, 9018 + 8 + 2);

/* enable cpu port to receive arp frames */
ar8xxx_reg_set(priv, AR8216_REG_ATU_CTRL,
AR8236_ATU_CTRL_RES);

/*
* Enable Broadcast/unknown multicast and unicast frames
* transmitted to the CPU port.
*/
ar8xxx_reg_set(priv, AR8216_REG_FLOOD_MASK,
AR8229_FLOOD_MASK_BC_DP(0) |
AR8229_FLOOD_MASK_MC_DP(0) |
AR8229_FLOOD_MASK_UC_DP(0));

/* Enable MIB counters */
ar8xxx_rmw(priv, AR8216_REG_MIB_FUNC, AR8216_MIB_FUNC | AR8236_MIB_EN,
(AR8216_MIB_FUNC_NO_OP << AR8216_MIB_FUNC_S) |
AR8236_MIB_EN);
}

The above function is used to initialize the hardware. The reason for my post is on line 58: where the CPU port is set to receive arp frames. The problem is; we have a 3 port switch (1 cpu port, 1 management port, and




NEXT




<s> static void AT91F_InitSdram()
{
int *pRegister;

//* Configure PIOC as peripheral (D16/D31)

AT91F_PIO_CfgPeriph(
AT91C_BASE_PIOC, // PIO controller base address
0xFFFF0030,
0
);

//*Init SDRAM
pRegister = (int *)0xFFFFFF98;
*pRegister = 0x2188c155;
pRegister = (int *)0xFFFFFF90;
*pRegister = 0x2;
pRegister = (int *)0x20000000;
*pRegister = 0;
pRegister = (int *)0xFFFFFF90;
*pRegister = 0x4;
pRegister = (int *)0x20000000;
*pRegister = 0;
*pRegister = 0;
*pRegister = 0;
*pRegister = 0;
*pRegister = 0;
*pRegister = 0;
*pRegister = 0;
*pRegister = 0;
pRegister = (int *)0xFFFFFF90;
*pRegister = 0x3;
pRegister = (int *)0x20000080;
*pRegister = 0;

pRegister = (int *)0xFFFFFF94;
*pRegister = 0x2e0;
pRegister = (int *)0x20000000;
*pRegister = 0;

pRegister = (int *)0xFFFFFF90;
*pRegister = 0x00;
pRegister = (int *)0x20000000;
*pRegister = 0;
}

The above function is used to initialize the memory of AT91CAP9. And I do not know
whether it works or not. Because I do not know how to check the initialization of SDRAM. Can anyone
tell me how to check it?





NEXT




<s> static int rtl8366s_get_mc_index(struct rtl8366_smi *smi, int port, int *val)
{
u32 data;
int err;

if (port >= RTL8366S_NUM_PORTS)
return -EINVAL;

err = rtl8366_smi_read_reg(smi, RTL8366S_PORT_VLAN_CTRL_REG(port),
&data);
if (err)
return err;

*val = (data >> RTL8366S_PORT_VLAN_CTRL_SHIFT(port)) &
RTL8366S_PORT_VLAN_CTRL_MASK;

return 0;
}

The above function is used to determine whether mac address is an mc address in rtl8366s driver. The code tries to read
the status register of port and checks the VLAN MAC bit. However, if no tag is configured for corresponding port by users




NEXT




<s> void rtl930x_update_cntr(int r, int released)
{
int pos = (r % 3) * 10;
u32 reg = RTL930X_DMA_IF_RX_RING_CNTR + ((r / 3) << 2);
u32 v = sw_r32(reg);

v = (v >> pos) & 0x3ff;
pr_debug("RX: Work done %d, old value: %d, pos %d, reg %04x\n", released, v, pos, reg);
sw_w32_mask(0x3ff << pos, released << pos, reg);
sw_w32(v, reg);
}

The above function is used to update counter value of RTL930x chipset, which keeps track of how many packets that the wifi chipset has read from the internal buffer. The value is incremented by 1 for each rx packet from the chipset buffer




NEXT




<s> ret_t rtl8367c_setAsicRldp(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_ENABLE_OFFSET, enabled);
}

The above function is used to set the RLDP parameter, but can not guarantee that there is data in the data queue to run this function, and the setting of the RLDP parameter is as below:

0- disabled
1- enabled

The problem




NEXT




<s> static int rtl8367_init_regs2(struct rtl8366_smi *smi, unsigned mode)
{
const struct rtl8367_initval *initvals;
int count;

switch (mode) {
case 0:
initvals = rtl8367_initvals_2_0;
count = ARRAY_SIZE(rtl8367_initvals_2_0);
break;

case 1:
case 2:
initvals = rtl8367_initvals_2_1;
count = ARRAY_SIZE(rtl8367_initvals_2_1);
break;

default:
dev_err(smi->parent, "%s: unknow mode %u\n", __func__, mode);
return -ENODEV;
}

return rtl8367_write_initvals(smi, initvals, count);
}

The above function is used to initialize the PHY register configuration (see
CONFIG_RTL8367B_INITVALS_MODE value defined in makefile).

According to the initval table, two functions (rtl8367_




NEXT




<s> static int mtdsplit_parse_wrgg(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct wrgg03_header hdr;
size_t hdr_len, retlen, kernel_ent_size;
size_t rootfs_offset;
struct mtd_partition *parts;
enum mtdsplit_part_type type;
int err;

hdr_len = sizeof(hdr);
err = mtd_read(master, 0, hdr_len, &retlen, (void *) &hdr);
if (err)
return err;

if (retlen != hdr_len)
return -EIO;

/* sanity checks */
if (le32_to_cpu(hdr.magic1) == WRGG03_MAGIC) {
kernel_ent_size = hdr_len + be32_to_cpu(hdr.size);
/*
* If this becomes silly big it's probably because the
* WRGG image is little-endian.
*/
if (kernel_ent_size > master->size)
kernel_ent_size = hdr_len + le32_to_cpu(hdr.size);

/* Now what ?! It's neither */
if (kernel_ent_size > master->size)
return -EINVAL;
} else if (le32_to_cpu(hdr.magic1) == WRG_MAGIC) {
kernel_ent_size = sizeof(struct wrg_header) + le32_to_cpu(
((struct wrg_header*)&hdr)->size);
} else {
return -EINVAL;
}

if (kernel_ent_size > master->size)
return -EINVAL;

/*
* The size in the header covers the rootfs as well.
* Start the search from an arbitrary offset.
*/
err = mtd_find_rootfs_from(master, WRGG_MIN_ROOTFS_OFFS,
master->size, &rootfs_offset, &type);
if (err)
return err;

parts = kzalloc(WRGG_NR_PARTS * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = 0;
parts[0].size = rootfs_offset;

parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = master->size - rootfs_offset;

*pparts = parts;
return WRGG_NR_PARTS;
}

The above function is used to parse the WRGG03/WRG_magic image.

This magic is used on MT658X/MT6589 based devices. The
MT6572/MT6573 doesn




NEXT




<s> ret_t rtl8367c_setAsicEavTpid(rtk_uint32 outerTag, rtk_uint32 innerTag)
{
ret_t retVal;

if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_OTAG_TPID, outerTag)) != RT_ERR_OK)
return retVal;
if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_ITAG_TPID, innerTag)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to modify the OTAG and I_tag (innerTag).

The following diagram shows setting the OTAG and I_tag in the packet format:

Example

Assume outerTag is 0xC02 and innerTag is




NEXT




<s> static int mt7620_mii_busy_wait(struct mt7620_gsw *gsw)
{
unsigned long t_start = jiffies;

while (1) {
if (!(mtk_switch_r32(gsw, MT7620A_GSW_REG_PIAC) & GSW_MDIO_ACCESS))
return 0;
if (time_after(jiffies, t_start + GSW_REG_PHY_TIMEOUT))
break;
}

dev_err(gsw->dev, "mdio: MDIO timeout\n");
return -1;
}

The above function is used to wait for read/write finished of phy register. However, if GSW_MDIO_ACCESS always sets, this function will just check MDIO_ACCESS status in a loop.

By debugging, the bug can always trigger after




NEXT




<s> yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
int yyrule)
{
int yylno = yyrline[yyrule];
int yynrhs = yyr2[yyrule];
int yyi;
YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
yyrule - 1, yylno);
/* The symbols being reduced.  */
for (yyi = 0; yyi < yynrhs; yyi++)
{
YYFPRINTF (stderr, "   $%d = ", yyi + 1);
yy_symbol_print (stderr,
YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
&yyvsp[(yyi + 1) - (yynrhs)]);
YYFPRINTF (stderr, "\n");
}
}

The above function is used to print the stack when a REDUCE action is to be taken. This has been useful in debugging my LR(1) parser.

Here’s a summary of the major macros used when I was implementing my first L




NEXT




<s> void rtl83xx_setup_default_prio2queue(void)
{
if (soc_info.family == RTL8380_FAMILY_ID) {
rtl838x_setup_prio2queue_matrix(max_available_queue);
} else {
rtl839x_setup_prio2queue_matrix(max_available_queue);
}
rtl83xx_setup_prio2queue_cpu_matrix(max_available_queue);
}

The above function is used to set RX and TX qprio->queue map by cpu core id.

So in the rtl8390/tx.c file, when a Tx task is scheduled the tx.c also set the
RDL




NEXT




<s> static void module_free(void *ptr)
{
struct bpf_object *obj = ptr;

bpf_object__close(obj);
}

The above function is used to clean up a bpf_object.

How should I use it (i.e. in what context) given the following?

#define BPF_OBJECT_TYPE __attribute__((cleanup(module_free)))
#




NEXT




<s> swlib_free_port_map(struct switch_dev *dev)
{
int i;

if (!dev || !dev->maps)
return;

for (i = 0; i < dev->ports; i++)
free(dev->maps[i].segment);
free(dev->maps);
}

The above function is used to free the storage used by the port map arrays.
This is called when the entire structure is freed or at the end of the
function. Why is this used?

I used a macro to print some debugging statements:
PRINTK




NEXT




<s> rtk_api_ret_t rtk_rldp_config_get(rtk_rldp_config_t *pConfig)
{
rtk_api_ret_t retVal;
ether_addr_t magic;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_getAsicRldp(&pConfig->rldp_enable))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicRldpTriggerMode(&pConfig->trigger_mode))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicRldpMagicNum(&magic))!=RT_ERR_OK)
return retVal;
memcpy(&pConfig->magic, &magic, sizeof(ether_addr_t));

if ((retVal = rtl8367c_getAsicRldpCompareRandomNumber(&pConfig->compare_type))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicRldpCompareRandomNumber(&pConfig->compare_type))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicRldpCheckingStatePara(&pConfig->num_check, &pConfig->interval_check))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicRldpLoopStatePara(&pConfig->num_loop, &pConfig->interval_loop))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to obtain RLDP hardware configuration. Refer to _8367_RDLP_Config.h for how to use it.</s>




NEXT




<s> static int ag71xx_ethtool_set_ringparam(struct net_device *dev,
struct ethtool_ringparam *er,
struct kernel_ethtool_ringparam *kernel_ring,
struct netlink_ext_ack *extack)
#else
static int ag71xx_ethtool_set_ringparam(struct net_device *dev,
struct ethtool_ringparam *er)
#endif
{
struct ag71xx *ag = netdev_priv(dev);
unsigned tx_size;
unsigned rx_size;
int err = 0;

if (er->rx_mini_pending != 0||
er->rx_jumbo_pending != 0 ||
er->rx_pending == 0 ||
er->tx_pending == 0)
return -EINVAL;

tx_size = er->tx_pending < AG71XX_TX_RING_SIZE_MAX ?
er->tx_pending : AG71XX_TX_RING_SIZE_MAX;

rx_size = er->rx_pending < AG71XX_RX_RING_SIZE_MAX ?
er->rx_pending : AG71XX_RX_RING_SIZE_MAX;

if (netif_running(dev)) {
err = dev->netdev_ops->ndo_stop(dev);
if (err)
return err;
}

if (ag->tx_ring.desc_split)
tx_size *= AG71XX_TX_RING_DS_PER_PKT;

ag->tx_ring.order = ag71xx_ring_size_order(tx_size);
ag->rx_ring.order = ag71xx_ring_size_order(rx_size);

if (netif_running(dev))
err = dev->netdev_ops->ndo_open(dev);

return err;
}

The above function is used to define number of buffers for TX and RX ring in ethernet card driver and later initializing the structure according to that.

Ethtool uses a special ioctl (0x8926) for setting and/orget




NEXT




<s> ret_t rtl8367c_getAsicLutForceFlushStatus(rtk_uint32 *pPortmask)
{
rtk_uint32 tmpMask;
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_FORCE_FLUSH_REG, RTL8367C_BUSY_STATUS_MASK,&tmpMask);
if(retVal != RT_ERR_OK)
return retVal;
*pPortmask = tmpMask & 0xff;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FORCE_FLUSH1, RTL8367C_BUSY_STATUS1_MASK,&tmpMask);
if(retVal != RT_ERR_OK)
return retVal;
*pPortmask |= (tmpMask & 7) << 8;

return RT_ERR_OK;
}

The above function is used to check whether ASIC is in the process of LUT force flush,
when port(s) LUT is used.

The return value is one of :
RT_ERR_OK
RT_ERR_SOK
return err




NEXT




<s> static int sata_oxnas_scr_read(struct ata_link *link,
unsigned int sc_reg, u32 *val)
{
return sata_oxnas_scr_read_port(link->ap, sc_reg, val);
}

The above function is used to read Scr registers on oxnas from SATA
device.
Scr registers are not supported for Iomega device. They are also not
supported for Seagate device. But the device driver has to handle
them.
To




NEXT




<s> adm6996_apply_vlan_filters(struct adm6996_priv *priv)
{
u8 ports, tagged;
u16 vid, reg;
int i;

for (i = 0; i < ADM_NUM_VLANS; i++) {
vid = priv->vlan_id[i];
ports = priv->vlan_table[i];
tagged = priv->vlan_tagged[i];

if (ports == 0) {
/* Disable VLAN entry */
w16(priv, ADM_VLAN_FILT_H(i), 0);
w16(priv, ADM_VLAN_FILT_L(i), 0);
continue;
}

reg = ADM_VLAN_FILT_MEMBER(ports);
reg |= ADM_VLAN_FILT_TAGGED(tagged);
w16(priv, ADM_VLAN_FILT_L(i), reg);
reg = ADM_VLAN_FILT_VALID | ADM_VLAN_FILT_VID(vid);
w16(priv, ADM_VLAN_FILT_H(i), reg);
}
}

The above function is used to configure the filtering behavior of particular virtual
lan on adm6996_chip.

The filter configuration for the tagged modes are:
[ADM-6996 User's Manual p-16]




NEXT




<s> static inline int pp32_download_code(int pp32, u32 *code_src, unsigned int code_dword_len, u32 *data_src, unsigned int data_dword_len)
{
unsigned int clr, set;
volatile u32 *dest;

if ( code_src == 0 || ((unsigned long)code_src & 0x03) != 0
|| data_src == 0 || ((unsigned long)data_src & 0x03) != 0 )
return -1;

clr = pp32 ? 0xF0 : 0x0F;
if ( code_dword_len <= CDM_CODE_MEMORYn_DWLEN(0) )
set = pp32 ? (3 << 6): (2 << 2);
else
set = 0x00;
IFX_REG_W32_MASK(clr, set, CDM_CFG);

/*  copy code   */
dest = CDM_CODE_MEMORY(pp32, 0);
while ( code_dword_len-- > 0 )
IFX_REG_W32(*code_src++, dest++);

/*  copy data   */
dest = CDM_DATA_MEMORY(pp32, 0);
while ( data_dword_len-- > 0 )
IFX_REG_W32(*data_src++, dest++);

return 0;
}

The above function is used to program the code memory into the PP32, using the
command sequence

clr_code_mem
clr_code_mem_prot
set_code_mem
set_code_mem_prot
[ set data




NEXT




<s> static int qca807x_cable_test_start(struct phy_device *phydev)
{
int val, ret;

val = phy_read(phydev, QCA807X_CDT);
/* Enable inter-pair short check as well */
val &= ~QCA807X_CDT_ENABLE_INTER_PAIR_SHORT;
val |= QCA807X_CDT_ENABLE;
ret = phy_write(phydev, QCA807X_CDT, val);

return ret;
}

The above function is used to start cable detection and inter-pair short check at the same time. The function phy_write() is an internal function that takes the address of the first register and the data to write into particular register.  I do not know why this function




NEXT




<s> static bool nmbm_check_info_table(struct nmbm_instance *ni, uint32_t start_ba,
uint32_t end_ba, void *data,
uint32_t *mapping_blocks_top_ba)
{
struct nmbm_info_table_header *ifthdr = data;
int32_t *block_mapping = (int32_t *)((uintptr_t)data + ifthdr->mapping_table_off);
u32 *block_state = (u32 *)((uintptr_t)data + ifthdr->state_table_off);
uint32_t minimum_mapping_pb = ni->signature_ba;
uint32_t ba;

for (ba = 0; ba < ni->data_block_count; ba++) {
if ((block_mapping[ba] >= ni->data_block_count && block_mapping[ba] < end_ba) ||
block_mapping[ba] == ni->signature_ba)
return false;

if (block_mapping[ba] >= end_ba && block_mapping[ba] < minimum_mapping_pb)
minimum_mapping_pb = block_mapping[ba];
}

for (ba = start_ba; ba < end_ba; ba++) {
if (nmbm_get_block_state(ni, ba) != BLOCK_ST_GOOD)
continue;

if (nmbm_get_block_state_raw(block_state, ba) != BLOCK_ST_GOOD)
return false;
}

*mapping_blocks_top_ba = minimum_mapping_pb - 1;

return true;
}

The above function is used to confirm a device is NAND-MTL. nmbm_get_block_state_raw_retrieve the nand mtl state directly from state table address given.


nmbm_dump_info_table_




NEXT




<s> static int mt798x_2p5ge_phy_get_features(struct phy_device *phydev)
{
int ret;

ret = genphy_read_abilities(phydev);
if (ret)
return ret;

/* We don't support HDX at MAC layer on mt798x.
* So mask phy's HDX capabilities, too.
*/
linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
phydev->supported);
linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
phydev->supported);
linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
phydev->supported);
linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
phydev->supported);
linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phydev->supported);

return 0;
}

The above function is used to mask out the HDX capabilities from the features which are not supported currently. The capabilities are already masked out at the PHY level on the mt798x IC.</s>




NEXT




<s> void rtl838x_update_cntr(int r, int released)
{
/* This feature is not available on RTL838x SoCs */
}

The above function is used to update a register with a value.
The second argument is a flag indicating whether the value of
should be saved for a subsequent read.

I found that the code to use this function was completely incorrect,
so I went ahead and deleted




NEXT




<s> rtk_api_ret_t rtk_switch_isComboPort(rtk_port_t logicalPort)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(logicalPort >= RTK_SWITCH_PORT_NUM)
return RT_ERR_FAILED;

if(halCtrl->combo_logical_port == logicalPort)
return RT_ERR_OK;
else
return RT_ERR_FAILED;
}

The above function is used to check
whether the switch has combo port or not.
This is very important in order to prevent a user from doing
something that is not combo port-related.

When a chip does not have combo port, it




NEXT




<s> static void version_information(int fd) {
IOCTL(DSL_VersionInformation_t, DSL_FIO_VERSION_INFORMATION_GET)

m_str("api_version", out.data.DSL_DriverVersionApi);
m_str("firmware_version", out.data.DSL_ChipSetFWVersion);
m_str("chipset", out.data.DSL_ChipSetType);
m_str("driver_version", out.data.DSL_DriverVersionMeiBsp);
}

The above function is used to get the current system version.  The value returned, if the system is an RT1538, is 15.8.

What exactly does 15.8 mean?  I think it goes (perhaps in




NEXT




<s> static int rtcl_ccu_register_clocks(void)
{
int clk_idx, ret;

for (clk_idx = 0; clk_idx < CLK_COUNT; clk_idx++) {
ret = rtcl_register_clkhw(clk_idx);
if (ret) {
pr_err("%s: Couldn't register %s clock\n",
__func__, rtcl_clk_info[clk_idx].display_name);
goto err_hw_unregister;
}
}

ret = of_clk_add_hw_provider(rtcl_ccu->np, rtcl_get_clkhw, rtcl_ccu);
if (ret) {
pr_err("%s: Couldn't register clock provider of %s\n",
__func__, of_node_full_name(rtcl_ccu->np));
goto err_hw_unregister;
}

return 0;

err_hw_unregister:
for (--clk_idx; clk_idx >= 0; --clk_idx)
clk_hw_unregister(&rtcl_ccu->clks[clk_idx].hw);

return ret;
}

The above function is used to register all clock drivers
provided above. The rtcl_register_clkhw function is responsible
for performing rtcl_ccu_register_clocks. In the rtcl_get_clkhw
function, the of_clk




NEXT




<s> static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to create a new function key, and then to register it with the key mapper. The key mapper provides 6 function keys, which are displayed to the user when certain keys are pressed. A function key could be a hotkey to launch a




NEXT




<s> int rtl83xx_lag_del(struct dsa_switch *ds, int group, int port)
{
struct rtl838x_switch_priv *priv = ds->priv;

if (group >= priv->n_lags) {
pr_err("%s: LAG %d invalid.\n", __func__, group);
return -EINVAL;
}

if (port >= priv->cpu_port) {
pr_err("%s: Port %d invalid.\n", __func__, port);
return -EINVAL;
}

if (!(priv->lags_port_members[group] & BIT_ULL(port))) {
pr_err("%s: Port %d not member of LAG %d.\n", __func__, port, group);
return -ENOSPC;
}

/* 0x7f algo mask all */
priv->r->mask_port_reg_be(BIT_ULL(port), 0, priv->r->trk_mbr_ctr(group));
priv->lags_port_members[group] &= ~BIT_ULL(port);

pr_info("%s: Removed port %d from LAG %d. Members now %016llx.\n",
__func__, port, group, priv->lags_port_members[group]);

return 0;
}

The above function is used to remove/leave a port from lag. The function
is invoked when a port (member port of lag) is removed from lag. Before
removing the port from lag, the lag algorithm masks-off the 6 bits of
port from




NEXT




<s> set_nonblock(int enable)
{
if (enable == !!(sockflags & O_NONBLOCK))
return;

sockflags ^= O_NONBLOCK;
fcntl(s, F_SETFL, sockflags);
}

The above function is used to set the nonblock option of a given socket. There was a bug in the above code where enable was ignored and always used the original value of sockflags instead of the passed value. This has since been fixed.</s>




NEXT




<s> static u32 rtl838x_l2_hash_key(struct rtl838x_switch_priv *priv, u64 seed)
{
u32 h1, h2, h3, h;

if (sw_r32(priv->r->l2_ctrl_0) & 1) {
h1 = (seed >> 11) & 0x7ff;
h1 = ((h1 & 0x1f) << 6) | ((h1 >> 5) & 0x3f);

h2 = (seed >> 33) & 0x7ff;
h2 = ((h2 & 0x3f) << 5) | ((h2 >> 6) & 0x1f);

h3 = (seed >> 44) & 0x7ff;
h3 = ((h3 & 0x7f) << 4) | ((h3 >> 7) & 0xf);

h = h1 ^ h2 ^ h3 ^ ((seed >> 55) & 0x1ff);
h ^= ((seed >> 22) & 0x7ff) ^ (seed & 0x7ff);
} else {
h = ((seed >> 55) & 0x1ff) ^ ((seed >> 44) & 0x7ff) ^
((seed >> 33) & 0x7ff) ^ ((seed >> 22) & 0x7ff) ^
((seed >> 11) & 0x7ff) ^ (seed & 0x7ff);
}

return h;
}

The above function is used to compute the L2 hash key for a particular packet
header, this will be used as index to find a specific MAC address in the hardware
MAC entry table.

The RTL838x hardware MAC table uses bitmap to index the




NEXT




<s> static int ip175c_set_flags(struct ip17xx_state *state)
{
int val;

if (!REG_SUPP(state->regs->ROUTER_CONTROL_REG)) {
return 0;
}

val = getPhy(state, state->regs->ROUTER_CONTROL_REG);
if (val < 0) {
return val;
}
if (state->regs->ROUTER_EN_BIT >= 0) {
if (state->router_mode) {
val |= (1<<state->regs->ROUTER_EN_BIT);
} else {
val &= (~(1<<state->regs->ROUTER_EN_BIT));
}
}
if (state->regs->TAG_VLAN_BIT >= 0) {
if (state->vlan_enabled) {
val |= (1<<state->regs->TAG_VLAN_BIT);
} else {
val &= (~(1<<state->regs->TAG_VLAN_BIT));
}
}
if (state->regs->NUMLAN_GROUPS_BIT >= 0) {
val &= (~((state->regs->NUMLAN_GROUPS_MAX-1)<<state->regs->NUMLAN_GROUPS_BIT));
if (state->num_vlans > state->regs->NUMLAN_GROUPS_MAX) {
val |= state->regs->NUMLAN_GROUPS_MAX << state->regs->NUMLAN_GROUPS_BIT;
} else if (state->num_vlans >= 1) {
val |= (state->num_vlans-1) << state->regs->NUMLAN_GROUPS_BIT;
}
}
return setPhy(state, state->regs->ROUTER_CONTROL_REG, val);
}

The above function is used to set VLAN routing for one port of an interface.

static int ip175c_set_interface(struct ip17xx_state *state, u32 data,
struct ip17xx_device *




NEXT




<s> ret_t rtl8367c_setAsicRemarkingDscpSrc(rtk_uint32 type)
{

if(type >= DSCP_PRISEL_END )
return RT_ERR_QOS_SEL_PRI_SOURCE;

return rtl8367c_setAsicRegBits(RTL8367C_REG_RMK_CFG_SEL_CTRL, RTL8367C_RMK_DSCP_CFG_SEL_MASK, type);
}

The above function is used to configure the DSCP source for remarking.
The function RTL8367C_RMK_DSCP_SRC_PPS0 is used before DSCP marking,
which is default by DSCP




NEXT




<s> static int mt7621_nfc_calc_ecc_strength(struct mt7621_nfc *nfc,
u32 avail_ecc_bytes)
{
struct nand_chip *nand = &nfc->nand;
struct mtd_info *mtd = nand_to_mtd(nand);
u32 strength;
int i;

strength = avail_ecc_bytes * 8 / ECC_PARITY_BITS;

/* Find the closest supported ecc strength */
for (i = ARRAY_SIZE(mt7621_ecc_strength) - 1; i >= 0; i--) {
if (mt7621_ecc_strength[i] <= strength)
break;
}

if (unlikely(i < 0)) {
dev_err(nfc->dev, "OOB size (%u) is not supported\n",
mtd->oobsize);
return -EINVAL;
}

nand->ecc.strength = mt7621_ecc_strength[i];
nand->ecc.bytes =
DIV_ROUND_UP(nand->ecc.strength * ECC_PARITY_BITS, 8);

dev_info(nfc->dev, "ECC strength adjusted to %u bits\n",
nand->ecc.strength);

return i;
}

The above function is used to calculate the ECC strength based on the
OOB size of the NAND flash. This ensures that the NAND chip, which
supports only certain number of ECC bytes with specified OOB size,
remains consistent and performs as




NEXT




<s> rtk_api_ret_t rtk_led_serialMode_get(rtk_led_active_t *pActive)
{
rtk_api_ret_t retVal;
rtk_uint32 regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pActive)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLedSerialModeConfig(pActive,&regData))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read the status of LED serial mode. When
the serial mode is enabled, the LED behavior is changed to support to
monitor the link state of both 100Mbps and 10Mbps Ethernet interfaces




NEXT




<s> static int proc_read_pp32(char *, char **, off_t, int, int *, void *);
static int proc_write_pp32(struct file *, const char *, unsigned long, void *);
static int stricmp(const char *, const char *);
static int strincmp(const char *, const char *, int);
static int get_token(char **, char **, int *, int *);
static int get_number(char **, int *, int);
static inline void ignore_space(char **, int *);



/*
* ####################################
*            Local Variable
* ####################################
*/



/*
* ####################################
*            Local Function
* ####################################
*/

static inline void proc_file_create(void)
{
struct proc_dir_entry *res;

res = create_proc_entry("driver/ifx_ptm/mem",
0,
NULL);
if ( res != NULL )
res->write_proc = proc_write_mem;
else
printk("%s:%s:%d: failed to create proc mem!", __FILE__, __func__, __LINE__);

res = create_proc_entry("driver/ifx_ptm/pp32",
0,
NULL);
if ( res != NULL ) {
res->read_proc = proc_read_pp32;
res->write_proc = proc_write_pp32;
}
else
printk("%s:%s:%d: failed to create proc pp32!", __FILE__, __func__, __LINE__);
}

The above function is used to create local file system.

static int proc_write_pp32(struct file *filp, const char *buff, size_t count, loff_t *ppos)

The above function is used to handle




NEXT




<s> ret_t rtl8367c_getAsicLedIndicateInfoConfig(rtk_uint32 ledno, rtk_uint32* pConfig)
{
CONST rtk_uint16 bits[RTL8367C_LEDGROUPNO]= {RTL8367C_LED0_CFG_MASK, RTL8367C_LED1_CFG_MASK, RTL8367C_LED2_CFG_MASK};

if(ledno >= RTL8367C_LEDGROUPNO)
return RT_ERR_OUT_OF_RANGE;

/* Get register value */
return rtl8367c_getAsicRegBits(RTL8367C_REG_LED_CONFIGURATION, bits[ledno], pConfig);
}

The above function is used to read the current configuration of the led. The register used to store these configurations is located at 0x140 (offset 0x48).

rtk_uint32* pConfig: is a pointer to the 




NEXT




<s> static int wlc_string(wlc_param param, void *data, void *value)
{
char *var = *((char **) data);

if ((param & PARAM_MODE) == GET) {
strcpy(value, var);
}

return 0;
}

The above function is used to manipulate a string type variable. The code
looks like that of a C or C++ program, and you might ask why we bother with
the mess of declaring it in the above way. Aren’t there better ways to




NEXT




<s> static int mtdsplit_parse_brnimage(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct mtd_partition *parts;
uint32_t buf;
unsigned long rootfs_offset, rootfs_size, kernel_size;
size_t len;
int ret = 0;

for (rootfs_offset = 0; rootfs_offset < master->size;
rootfs_offset += BRNIMAGE_ALIGN_BYTES) {
ret = mtd_check_rootfs_magic(master, rootfs_offset, NULL);
if (!ret)
break;
}

if (ret)
return ret;

if (rootfs_offset >= master->size)
return -EINVAL;

ret = mtd_read(master, rootfs_offset - BRNIMAGE_FOOTER_SIZE, 4, &len,
(void *)&buf);
if (ret)
return ret;

if (len != 4)
return -EIO;

kernel_size = le32_to_cpu(buf);

if (kernel_size > (rootfs_offset - BRNIMAGE_MIN_OVERHEAD))
return -EINVAL;

if (kernel_size < (rootfs_offset - BRNIMAGE_MAX_OVERHEAD))
return -EINVAL;

/*
* The footer must be untouched as it contains the checksum of the
* original brnImage (kernel + squashfs)!
*/
rootfs_size = master->size - rootfs_offset - BRNIMAGE_FOOTER_SIZE;

parts = kzalloc(BRNIMAGE_NR_PARTS * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = 0;
parts[0].size = kernel_size;

parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = rootfs_size;

*pparts = parts;
return BRNIMAGE_NR_PARTS;
}

The above function is used to find the position of the kernel and rootfs in a
brn-image file system. It creates a pointer which points to the kernel and
rootfs location. This pointer is then used in mtdsplit’s main function while
creat




NEXT




<s> static void mt7621_nfc_hw_reset(struct mt7621_nfc *nfc)
{
u32 val;
int ret;

/* reset all registers and force the NFI master to terminate */
nfi_write16(nfc, NFI_CON, CON_FIFO_FLUSH | CON_NFI_RST);

/* wait for the master to finish the last transaction */
ret = readw_poll_timeout(nfc->nfi_regs + NFI_MASTER_STA, val,
!(val & MASTER_STA_MASK), 50,
NFI_RESET_TIMEOUT);
if (ret) {
dev_warn(nfc->dev, "Failed to reset NFI master in %dms\n",
NFI_RESET_TIMEOUT);
}

/* ensure any status register affected by the NFI master is reset */
nfi_write16(nfc, NFI_CON, CON_FIFO_FLUSH | CON_NFI_RST);
nfi_write16(nfc, NFI_STRDATA, 0);
}

The above function is used to power-cycle the NFI master. It is used before
restarting the NFC stack. There is one other function used before restart,
_mt7621_nfc_hw_start().

static void _




NEXT




<s> static int __init ws_ap3825i_probe(void)
{
if (of_machine_is_compatible("extreme-networks,ws-ap3825i"))
return 1;
return 0;
}

The above function is used to match the MAC address. If of_machine_is_compatible() returns 1, the function ws_ap3825i_probe() will be called.

If of_machine_is_compatible() function returns 




NEXT




<s> void ifxdeu_fini_sha1 (void)
{
crypto_unregister_shash(&ifxdeu_sha1_alg);


}

The above function is used to end the SHA-1 implementation.

void ifxdeu_init_sha1 (void)
{
ifxdeu_sha1_init();
crypto_register_shash(&ifxdeu_sha1




NEXT




<s> mtk_bmt_add_debugfs(void)
{
struct dentry *dir;

dir = bmtd.debugfs_dir = debugfs_create_dir("mtk-bmt", NULL);
if (!dir)
return;

debugfs_create_file_unsafe("repair", S_IWUSR, dir, NULL, &fops_repair);
debugfs_create_file_unsafe("mark_good", S_IWUSR, dir, NULL, &fops_mark_good);
debugfs_create_file_unsafe("mark_bad", S_IWUSR, dir, NULL, &fops_mark_bad);
debugfs_create_file_unsafe("debug", S_IWUSR, dir, NULL, &fops_debug);
}

The above function is used to add two “debugfs” files into the debugfs directory under the root (“/sys/kernel/debug/mtk-bmt”).

But I got the error:

Error creating file “/sys/kernel/debug




NEXT




<s> ar8xxx_read(struct ar8xxx_priv *priv, int reg)
{
struct mii_bus *bus = priv->mii_bus;
u16 r1, r2, page;
u32 val;

split_addr((u32) reg, &r1, &r2, &page);

mutex_lock(&bus->mdio_lock);

bus->write(bus, 0x18, 0, page);
wait_for_page_switch();
val = ar8xxx_mii_read32(priv, 0x10 | r2, r1);

mutex_unlock(&bus->mdio_lock);

return val;
}

The above function is used to read data of the microcontroller through the MII interface. MII bus defines a standard interface between devices and PHY. The ar8xxx_read function uses bus->read function to communicate with the MII bus. It will access data from




NEXT




<s> void rtl931x_print_matrix(void)
{
volatile u64 *ptr = RTL838X_SW_BASE + RTL839X_PORT_ISO_CTRL(0);

for (int i = 0; i < 52; i += 4)
pr_info("> %16llx %16llx %16llx %16llx\n",
ptr[i + 0], ptr[i + 1], ptr[i + 2], ptr[i + 3]);
pr_info("CPU_PORT> %16llx\n", ptr[52]);
}

The above function is used to print the content of the MSI-X Table on
the screen. It receives the pointer to the memory area which contains the
MSI-X Table. (If the pointer and the MSI-X Table are at the same address,




NEXT




<s> static int nmbm_attach(struct nmbm_instance *ni)
{
bool success;

if (!ni)
return -EINVAL;

/* Initialize NMBM instance */
nmbm_init_structure(ni);

success = nmbm_find_signature(ni, &ni->signature, &ni->signature_ba);
if (!success) {
if (!ni->force_create) {
nlog_err(ni, "Signature not found\n");
return -ENODEV;
}

success = nmbm_create_new(ni);
if (!success)
return -ENODEV;

return 0;
}

nlog_info(ni, "Signature found at block %u [0x%08llx]\n",
ni->signature_ba, ba2addr(ni, ni->signature_ba));

if (ni->signature.header.version != NMBM_VER) {
nlog_err(ni, "NMBM version %u.%u is not supported\n",
NMBM_VERSION_MAJOR_GET(ni->signature.header.version),
NMBM_VERSION_MINOR_GET(ni->signature.header.version));
return -EINVAL;
}

if (ni->signature.nand_size != bmtd.total_blks << bmtd.blk_shift ||
ni->signature.block_size != bmtd.blk_size ||
ni->signature.page_size != bmtd.pg_size ||
ni->signature.spare_size != bmtd.mtd->oobsize) {
nlog_err(ni, "NMBM configuration mismatch\n");
return -EINVAL;
}

success = nmbm_load_existing(ni);
if (!success)
return -ENODEV;

return 0;
}

The above function is used to check if the signature is stored into NAND,
if not, it will create a new one, if it is, the function will try to load
the existing. The process of load existing can be seen in
`nmbm_




NEXT




<s> static void do_scroll(WINDOW *win, int *scroll, int n)
{
/* Scroll menu up */
scrollok(win, TRUE);
wscrl(win, n);
scrollok(win, FALSE);
*scroll = *scroll + n;
wrefresh(win);
}

The above function is used to scroll up a window. I have two questions related to this. As I have to do the same on a terminal window using the ncurses library.

1. Is it ok to use ncurses on the terminal window(I use




NEXT




<s> ret_t rtl8367c_getAsicPortPageMax(rtk_uint32 port, rtk_uint32 *pPageCount)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;
if(port < 8)
return rtl8367c_getAsicRegBits(RTL8367C_FLOWCTRL_PORT_PAGE_MAX_REG(port), RTL8367C_FLOWCTRL_PORT_PAGE_MAX_MASK, pPageCount);
else
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT0_PAGE_MAX+port-8, RTL8367C_FLOWCTRL_PORT_PAGE_MAX_MASK, pPageCount);


}

The above function is used to get all the entries of the page registers.


ret_t rtl8367c_setAsicVlanPort(rtk_uint32 port, rtk_uint32 vlanPri)





NEXT




<s> int mt7620_has_carrier(struct fe_priv *priv)
{
struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
int i;

for (i = 0; i < GSW_PORT6; i++)
if (mtk_switch_r32(gsw, GSW_REG_PORT_STATUS(i)) & 0x1)
return 1;
return 0;
}

The above function is used to check if the MT7620 is in carrier state.

Now, I wonder what if I want to detect other carrier by using other GSW registers apart from GSW_REG_PORT_STATUS(0)?

How do




NEXT




<s> static unsigned int AT91F_ResetRegisters(void)
{
volatile int i = 0;

/* set the PIOs in input*/
/* This disables the UART output, so dont execute for now*/

#ifndef	DEBUGOUT
*AT91C_PIOA_ODR = 0xFFFFFFFF;	/* Disables all the output pins */
*AT91C_PIOA_PER = 0xFFFFFFFF;	/* Enables the PIO to control all the pins */
#endif

AT91F_AIC_DisableIt (AT91C_BASE_AIC, AT91C_ID_SYS);
/* close all peripheral clocks */

#ifndef	DEBUGOUT
AT91C_BASE_PMC->PMC_PCDR = 0xFFFFFFFC;
#endif
/* Disable core interrupts and set supervisor mode */
__asm__ ("msr CPSR_c, #0xDF"); //* ARM_MODE_SYS(0x1F) | I_BIT(0x80) | F_BIT(0x40)
/* Clear all the interrupts */
*AT91C_AIC_ICCR = 0xffffffff;

/* read the AIC_IVR and AIC_FVR */
i = *AT91C_AIC_IVR;
i = *AT91C_AIC_FVR;

/* write the end of interrupt control register */
*AT91C_AIC_EOICR	= 0;

return 1;
}

The above function is used to reset the CPU for booting.  It is also used to
restart the microcontroller after reset of interrupts.

 	{ The main reason as to why we are resetting the microcontroller is to
 			




NEXT




<s> extern struct ether_addr *ether_aton(const char *asc);
static inline int my_ether_ntoa(unsigned char *ea, char *buf)
{
return sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x",
ea[0], ea[1], ea[2], ea[3], ea[4], ea[5]);
}

The above function is used to set eth header value.

In ethtool, if I want to print ethernet address, e.g., the etheraddr field of struct ethtool_cmd, shall I use the eth_ntoa()? In




NEXT




<s> static int ip_phy_write_masked(struct ip17xx_state *state, int port, int reg, unsigned int mask, unsigned int data)
{
int val = ip_phy_read(state, port, reg);
if (val < 0)
return 0;
return ip_phy_write(state, port, reg, (val & ~mask) | data);
}

The above function is used to read or write a specific bit of the MII register.
The register value is read, masked with ones complement of given mask and
then the data is masked by given mask before being ORed with register value.
This effectively writes




NEXT




<s> static int psb6970_set_pvid(struct switch_dev *dev, int port, int vlan)
{
struct psb6970_priv *priv = to_psb6970(dev);

/* make sure no invalid PVIDs get set */
if (vlan >= dev->vlans)
return -EINVAL;

priv->pvid[port] = vlan;
return 0;
}

The above function is used to enable PVID for ports in psb6970 based switches. As can be seen from the comments on the code, when port is configured with the PVID, all untagged packets from those ports are filtered by VLAN ID




NEXT




<s> static int ar934x_nfc_write_oob(struct nand_chip *chip,
int page)
{
struct ar934x_nfc *nfc = chip->priv;
struct mtd_info *mtd = ar934x_nfc_to_mtd(nfc);
nfc_dbg(nfc, "write_oob: page:%d\n", page);

memcpy(nfc->buf, chip->oob_poi, mtd->oobsize);

return ar934x_nfc_send_write(nfc, NAND_CMD_PAGEPROG, mtd->writesize,
page, mtd->oobsize);
}

The above function is used to write data to the device, but when compiled, shows “write_oob: page: 22052914” in the serial monitor. Then, the device keeps the error message and cannot boot. Could you tell me




NEXT




<s> ret_t rtl8367c_getAsicRemarkingDot1pAbility(rtk_uint32 port, rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_1QREMARK_ENABLE_OFFSET, pEnabled);
}

The above function is used to querying 1Q remarking dot1p ability.

rtk_uint16 rtl8367c_getAsic1QRemarkingPortIndex(rtk_uint32 port, rtk_




NEXT




<s> uc_value_t *wpa_ucode_global_init(const char *name, uc_resource_type_t *global_type)
{
uc_value_t *global = uc_resource_new(global_type, NULL);
uc_value_t *proto;

uc_vm_registry_set(&vm, "hostap.global", global);
proto = ucv_prototype_get(global);
ucv_object_add(proto, "data", ucv_get(ucv_object_new(&vm)));

#define ADD_CONST(x) ucv_object_add(proto, #x, ucv_int64_new(x))
ADD_CONST(MSG_EXCESSIVE);
ADD_CONST(MSG_MSGDUMP);
ADD_CONST(MSG_DEBUG);
ADD_CONST(MSG_INFO);
ADD_CONST(MSG_WARNING);
ADD_CONST(MSG_ERROR);
#undef ADD_CONST

ucv_object_add(uc_vm_scope_get(&vm), name, ucv_get(global));

return global;
}

The above function is used to make any global variable, so how should I use it to make global values, such as:

uc_value_t *wpa_ucode_global_init(MSG_EXCESSIVE, uc_resource_type_




NEXT




<s> void AT91F_ST_HANDLER(void)
{
volatile unsigned int csr = *AT91C_DBGU_CSR;
#ifdef XMODEM
unsigned int error;
#endif

if (AT91C_BASE_ST->ST_SR & 0x01) {
StTick++;
ctlTempo.CtlTempoTick(&ctlTempo);
return;
}

#ifdef XMODEM
error = AT91F_US_Error((AT91PS_USART)AT91C_BASE_DBGU);
if (csr & error) {
/* Stop previous Xmodem transmition*/
*(AT91C_DBGU_CR) = AT91C_US_RSTSTA;
AT91F_US_DisableIt((AT91PS_USART)AT91C_BASE_DBGU, AT91C_US_ENDRX);
AT91F_US_EnableIt((AT91PS_USART)AT91C_BASE_DBGU, AT91C_US_RXRDY);

}

else if (csr & (AT91C_US_TXRDY | AT91C_US_ENDTX | AT91C_US_TXEMPTY |
AT91C_US_RXRDY | AT91C_US_ENDRX | AT91C_US_TIMEOUT |
AT91C_US_RXBUFF)) {
if ( !(svcXmodem.eot) )
svcXmodem.Handler(&svcXmodem, csr);
}
#endif
}

The above function is used to handle the debug uart (DBGU) interrupt.
With the new firmware (V6.1.1 and later), I need to rewrite this interrupt
handler as the interrupt type changed from level to edge, and to handle





NEXT




<s> int nand_dev_ready(struct mtd_info *mtd)
{
struct nand_chip *chip = mtd->priv;

udelay(chip->chip_delay);

return 1;
}

The above function is used to check for the readiness of the device (i.e.
to be polled by the driver until the device is ready).

The problem is that it is not being checked for the device by the driver.
To remedy this




NEXT




<s> ret_t rtl8367c_setAsicTrunkingHashTable(rtk_uint32 hashval, rtk_uint32 portId)
{
if(hashval > RTL8367C_TRUNKING_HASHVALUE_MAX)
return RT_ERR_OUT_OF_RANGE;

if(portId >= RTL8367C_TRUNKING_PORTNO)
return RT_ERR_PORT_ID;

if(hashval >= 8)
return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL1, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH8_MASK<<((hashval-8)*2), portId);
else
return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL0, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH0_MASK<<(hashval*2), portId);
}

The above function is used to configure the Port-Trunking Hashtable Mapping Registers. You will find that it only requires the Hash value and the port number. The port number can be any port from 0 to 7. When you configure the Asic




NEXT




<s> rtk_api_ret_t rtk_qos_schedulingQueue_get(rtk_port_t port, rtk_qos_queue_weights_t *pQweights)
{
rtk_api_ret_t retVal;
rtk_uint32 qid,qtype,qweight;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

for (qid = 0; qid < RTL8367C_QUEUENO; qid++)
{
if ((retVal = rtl8367c_getAsicQueueType(rtk_switch_port_L2P_get(port), qid, &qtype)) != RT_ERR_OK)
return retVal;

if (QTYPE_STRICT == qtype)
{
pQweights->weights[qid] = 0;
}
else if (QTYPE_WFQ == qtype)
{
if ((retVal = rtl8367c_getAsicWFQWeight(rtk_switch_port_L2P_get(port), qid, &qweight)) != RT_ERR_OK)
return retVal;
pQweights->weights[qid] = qweight;
}
}
return RT_ERR_OK;
}

The above function is used to get queue weights of each queue that belong to port. RTK_API_RET_T rtk_qos_schedulingQueue_get takes two arguments: RTK_PORT_T port specifies the physical port and RTK




NEXT




<s> hostapd_bss_get_features(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);

blob_buf_init(&b, 0);
blobmsg_add_u8(&b, "ht_supported", ht_supported(hapd->iface->hw_features));
blobmsg_add_u8(&b, "vht_supported", vht_supported(hapd->iface->hw_features));
ubus_send_reply(ctx, req, b.head);

return 0;
}

The above function is used to get the supported Ht and Vht features but the code always returns null bss feature support even if HT/VHT is not supported by the h/w I am using. Also there is no other way to get the capabilities of h/




NEXT




<s> ret_t rtl8367c_getAsicLedGroupEnable(rtk_uint32 group, rtk_uint32 *portmask)
{
ret_t retVal;
rtk_uint32 regAddr;
rtk_uint32 regDataMask,regData;

if ( group >= RTL8367C_LEDGROUPNO )
return RT_ERR_INPUT;

regAddr = RTL8367C_REG_PARA_LED_IO_EN1 + group/2;
regDataMask = 0xFF << ((group%2)*8);
retVal = rtl8367c_getAsicRegBits(regAddr, regDataMask, portmask);
if(retVal != RT_ERR_OK)
return retVal;


regAddr = RTL8367C_REG_PARA_LED_IO_EN3;
regDataMask = 0x3 << (group*2);
retVal = rtl8367c_getAsicRegBits(regAddr, regDataMask, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*portmask = (regData << 8) | *portmask;

return RT_ERR_OK;
}

The above function is used to get the portmask of LED group enable of ASIC.
Because the LED group 0-4 are controlled by REG30100H REG30102H,
and the LED group 5-7 are controlled




NEXT




<s> static void __init rtcl_probe_early(struct device_node *np)
{
if (rtcl_ccu_create(np))
return;

if (rtcl_ccu_register_clocks())
kfree(rtcl_ccu);
else
rtcl_ccu_log_early();
}

The above function is used to initialize all clock devices, early in the bootup sequence. Here, we register the function as first_dev_initcall() to be invoked early. First, we try to probe the chip connected through the syscon. If it is not there




NEXT




<s> ret_t rtl8367c_getAsicSvlanPrioritySel(rtk_uint32* pPriSel)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_SPRISEL_MASK, pPriSel);
}

The above function is used to get the asic configured QSVLA priority selection. For this example, we get the priority selection value from the switch by calling this function.

We will then take the same value to set the QSVLA priority selection as below:





NEXT




<s> static struct clk_hw *rtcl_get_clkhw(struct of_phandle_args *clkspec, void *prv)
{
unsigned int idx = clkspec->args[0];

if (idx >= CLK_COUNT) {
pr_err("%s: Invalid index %u\n", __func__, idx);
return ERR_PTR(-EINVAL);
}

return &rtcl_ccu->clks[idx].hw;
}

The above function is used to obtain a clk hw for the RTCL.

The index (clkspec->args[0]) to the CLK array is the index argument</s>




NEXT




<s> static void ar8327_get_arl_entry(struct ar8xxx_priv *priv,
struct arl_entry *a, u32 *status, enum arl_op op)
{
struct mii_bus *bus = priv->mii_bus;
u16 r2, page;
u16 r1_data0, r1_data1, r1_data2, r1_func;
u32 val0, val1, val2;

split_addr(AR8327_REG_ATU_DATA0, &r1_data0, &r2, &page);
r2 |= 0x10;

r1_data1 = (AR8327_REG_ATU_DATA1 >> 1) & 0x1e;
r1_data2 = (AR8327_REG_ATU_DATA2 >> 1) & 0x1e;
r1_func  = (AR8327_REG_ATU_FUNC >> 1) & 0x1e;

switch (op) {
case AR8XXX_ARL_INITIALIZE:
/* all ATU registers are on the same page
* therefore set page only once
*/
bus->write(bus, 0x18, 0, page);
wait_for_page_switch();

ar8327_wait_atu_ready(priv, r2, r1_func);

ar8xxx_mii_write32(priv, r2, r1_data0, 0);
ar8xxx_mii_write32(priv, r2, r1_data1, 0);
ar8xxx_mii_write32(priv, r2, r1_data2, 0);
break;
case AR8XXX_ARL_GET_NEXT:
ar8xxx_mii_write32(priv, r2, r1_func,
AR8327_ATU_FUNC_OP_GET_NEXT |
AR8327_ATU_FUNC_BUSY);
ar8327_wait_atu_ready(priv, r2, r1_func);

val0 = ar8xxx_mii_read32(priv, r2, r1_data0);
val1 = ar8xxx_mii_read32(priv, r2, r1_data1);
val2 = ar8xxx_mii_read32(priv, r2, r1_data2);

*status = val2 & AR8327_ATU_STATUS;
if (!*status)
break;

a->portmap = (val1 & AR8327_ATU_PORTS) >> AR8327_ATU_PORTS_S;
a->mac[0] = (val0 & AR8327_ATU_ADDR0) >> AR8327_ATU_ADDR0_S;
a->mac[1] = (val0 & AR8327_ATU_ADDR1) >> AR8327_ATU_ADDR1_S;
a->mac[2] = (val0 & AR8327_ATU_ADDR2) >> AR8327_ATU_ADDR2_S;
a->mac[3] = (val0 & AR8327_ATU_ADDR3) >> AR8327_ATU_ADDR3_S;
a->mac[4] = (val1 & AR8327_ATU_ADDR4) >> AR8327_ATU_ADDR4_S;
a->mac[5] = (val1 & AR8327_ATU_ADDR5) >> AR8327_ATU_ADDR5_S;
break;
}
}

The above function is used to read an entry out of the address learning
register (ARL), which is a FIFO maintained by the hardware. New entries which
the hardware finds in the forwarding table are added to the FIFO. If there are
no




NEXT




<s> static int aes_cbcmac_update(struct shash_desc *desc, const u8 *data, unsigned int len)
{
struct aes_ctx *mctx = crypto_shash_ctx(desc->tfm);
const u32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x0f);

mctx->byte_count += len;

if (avail > len) {
memcpy((char *)mctx->block + (sizeof(mctx->block) - avail),
data, len);
return 0;
}

memcpy((char *)mctx->block + (sizeof(mctx->block) - avail),
data, avail);

aes_cbcmac_transform(desc, mctx->block);
data += avail;
len -= avail;

while (len >= sizeof(mctx->block)) {
memcpy(mctx->block, data, sizeof(mctx->block));
aes_cbcmac_transform(desc, mctx->block);
data += sizeof(mctx->block);
len -= sizeof(mctx->block);
}

memcpy(mctx->block, data, len);
return 0;
}

The above function is used to update the context and is called for
every block of data by the crypto module. In the original code
the aes_cbcmac_transform was called using a block as the first argument.
So, the data in the AES




NEXT




<s> static int radius_setup(struct radius_state *s, struct radius_config *c)
{
struct eap_config *eap = &s->eap;
struct tls_config conf = {
.event_cb = radius_tls_event,
.tls_flags = TLS_CONN_DISABLE_TLSv1_3,
.cb_ctx = s,
};

eap->eap_server = 1;
eap->max_auth_rounds = 100;
eap->max_auth_rounds_short = 50;
eap->ssl_ctx = tls_init(&conf);
if (!eap->ssl_ctx) {
wpa_printf(MSG_INFO, "TLS init failed\n");
return 1;
}

if (tls_global_set_params(eap->ssl_ctx, &c->tls)) {
wpa_printf(MSG_INFO, "failed to set TLS parameters\n");
return 1;
}

c->radius.eap_cfg = eap;
c->radius.conf_ctx = s;
c->radius.get_eap_user = radius_get_eap_user;
s->radius = radius_server_init(&c->radius);
if (!s->radius) {
wpa_printf(MSG_INFO, "failed to initialize radius server\n");
return 1;
}

return 0;
}

The above function is used to setup radius authentication in eap_common.c

Now we have a radius_setup function. Now our next step will be to call this function when EAP starts. So the first thing we need to do is change the below line in




NEXT




<s> static void rtl8366_smi_stop(struct rtl8366_smi *smi)
{
unsigned int sda = smi->gpio_sda;
unsigned int sck = smi->gpio_sck;

rtl8366_smi_clk_delay(smi);
gpio_set_value(sda, 0);
gpio_set_value(sck, 1);
rtl8366_smi_clk_delay(smi);
gpio_set_value(sda, 1);
rtl8366_smi_clk_delay(smi);
gpio_set_value(sck, 1);
rtl8366_smi_clk_delay(smi);
gpio_set_value(sck, 0);
rtl8366_smi_clk_delay(smi);
gpio_set_value(sck, 1);

/* add a click */
rtl8366_smi_clk_delay(smi);
gpio_set_value(sck, 0);
rtl8366_smi_clk_delay(smi);
gpio_set_value(sck, 1);

/* set GPIO pins to input mode */
gpio_direction_input(sda);
gpio_direction_input(sck);
}

The above function is used to bring the device to initial state before it is stopped.</s>




NEXT




<s> static int fe_alloc_tx(struct fe_priv *priv)
{
int i;
struct fe_tx_ring *ring = &priv->tx_ring;

ring->tx_free_idx = 0;
ring->tx_next_idx = 0;
ring->tx_thresh = max((unsigned long)ring->tx_ring_size >> 2,
MAX_SKB_FRAGS);

ring->tx_buf = kcalloc(ring->tx_ring_size, sizeof(*ring->tx_buf),
GFP_KERNEL);
if (!ring->tx_buf)
goto no_tx_mem;

ring->tx_dma = dma_alloc_coherent(priv->dev,
ring->tx_ring_size * sizeof(*ring->tx_dma),
&ring->tx_phys,
GFP_ATOMIC | __GFP_ZERO);
if (!ring->tx_dma)
goto no_tx_mem;

for (i = 0; i < ring->tx_ring_size; i++) {
if (priv->soc->tx_dma)
priv->soc->tx_dma(&ring->tx_dma[i]);
ring->tx_dma[i].txd2 = TX_DMA_DESP2_DEF;
}
/* make sure that all changes to the dma ring are flushed before we
* continue
*/
wmb();

fe_reg_w32(ring->tx_phys, FE_REG_TX_BASE_PTR0);
fe_reg_w32(ring->tx_ring_size, FE_REG_TX_MAX_CNT0);
fe_reg_w32(0, FE_REG_TX_CTX_IDX0);
fe_reg_w32(FE_PST_DTX_IDX0, FE_REG_PDMA_RST_CFG);

return 0;

no_tx_mem:
return -ENOMEM;
}

The above function is used to allocated the TX Memory.</s>




NEXT




<s> static void add_file(const char *name, int parent)
{
int inode, f_offset = 0, fd;
struct jffs2_raw_inode ri;
struct stat st;
char wbuf[4096];
const char *fname;

if (stat(name, &st)) {
fprintf(stderr, "File %s does not exist\n", name);
return;
}

fname = strrchr(name, '/');
if (fname)
fname++;
else
fname = name;

inode = add_dirent(fname, IFTODT(S_IFREG), parent);
memset(&ri, 0, sizeof(ri));
ri.magic = JFFS2_MAGIC_BITMASK;
ri.nodetype = JFFS2_NODETYPE_INODE;

ri.ino = inode;
ri.mode = st.st_mode;
ri.uid = ri.gid = 0;
ri.atime = st.st_atime;
ri.ctime = st.st_ctime;
ri.mtime = st.st_mtime;
ri.isize = st.st_size;
ri.compr = 0;
ri.usercompr = 0;

fd = open(name, 0);
if (fd < 0) {
fprintf(stderr, "File %s does not exist\n", name);
return;
}

for (;;) {
int len = 0;

for (;;) {
len = rbytes() - sizeof(ri);
if (len > 128)
break;

pad(erasesize);
prep_eraseblock();
}

if (len > sizeof(wbuf))
len = sizeof(wbuf);

len = read(fd, wbuf, len);
if (len <= 0)
break;

ri.totlen = sizeof(ri) + len;
ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node) - 4);
ri.version = ++last_version;
ri.offset = f_offset;
ri.csize = ri.dsize = len;
ri.node_crc = crc32(0, &ri, sizeof(ri) - 8);
ri.data_crc = crc32(0, wbuf, len);
f_offset += len;
add_data((char *) &ri, sizeof(ri));
add_data(wbuf, len);
pad(4);
prep_eraseblock();
}

close(fd);
}

The above function is used to add the files located in the local filesystem which are a part of the image to the filesystem located in the ramdisk. The files within the ramdisk can be mounted over the top of the local filesystem to facilitate development. The function takes




NEXT




<s> ret_t rtl8367c_getAsicEavTpid(rtk_uint32* pOuterTag, rtk_uint32* pInnerTag)
{
ret_t retVal;

if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_OTAG_TPID, pOuterTag)) != RT_ERR_OK)
return retVal;
if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_ITAG_TPID, pInnerTag)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the outer-tagged and inner-tagged Tpid.
In 8368, it is hard-coded to 0x04DD, 0xFF50, what else we should consider to modify?




NEXT




<s> int cfb_aes_encrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int enc_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = enc_bytes = walk.nbytes) && (walk.nbytes >= AES_BLOCK_SIZE)) {
enc_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_cfb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, enc_bytes, CRYPTO_DIR_ENCRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

/* to handle remaining bytes < AES_BLOCK_SIZE */
if (walk.nbytes) {
ifx_deu_aes_cfb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, walk.nbytes, CRYPTO_DIR_ENCRYPT, 0);
err = skcipher_walk_done(&walk, 0);
}

return err;
}

The above function is used to encrypte or decrypte using the CFB chaining.

The implementation of cfb_encrypt is shown below.
int f_cbc_encrypt(struct if_cbc_ctx *ctx, unsigned char




NEXT




<s> static int md5_hmac_init(struct shash_desc *desc)
{

struct md5_hmac_ctx *mctx = crypto_shash_ctx(desc->tfm);


mctx->dbn = 0; //dbn workaround
mctx->started = 0;
mctx->byte_count = 0;

return 0;
}

The above function is used to initialize the md5 context and is called with an initial call to shash_digest().</s>




NEXT




<s> static u64 get_mib_counter_port_7620(struct mt7530_priv *priv, int i, int port)
{
return mt7530_r32(priv,
MT7620_MIB_COUNTER_BASE_PORT +
(MT7620_MIB_COUNTER_PORT_OFFSET * port) +
mt7620_port_mibs[i].offset);
}

The above function is used to extract MIB counter for each port.
Then I wrote the MT7620_MIB_COUNTER_TOTAL_BYTES_OFFSET to port 0 as:
mt7620_port_m




NEXT




<s> IFX_MEI_DMARead (DSL_DEV_Device_t * pDev, u32 srcaddr, u32 * databuff,
u32 databuffsize)
{
u32 *p = databuff;
u32 temp;

if (srcaddr & 3)
return DSL_DEV_MEI_ERR_FAILURE;

//      Set the read transfer address
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_DX_AD, srcaddr);

//      Read the data popped across DMA
while (databuffsize--) {
IFX_MEI_LongWordReadOffset (pDev, (u32) ME_DX_DATA, &temp);
if (databuff == (u32 *) DSL_DEV_PRIVATE(pDev)->CMV_RxMsg)	// swap half word
MEI_HALF_WORD_SWAP (temp);
*p = temp;
p++;
}

return DSL_DEV_MEI_ERR_SUCCESS;

}

The above function is used to move a DMA chunk of data from the mei physical address of the data to be moved (or the address to receive it from) to a buffer for processing after reception.</s>




NEXT




<s> static irqreturn_t fe_handle_irq(int irq, void *dev)
{
struct fe_priv *priv = netdev_priv(dev);
u32 status, int_mask;

status = fe_reg_r32(FE_REG_FE_INT_STATUS);

if (unlikely(!status))
return IRQ_NONE;

int_mask = (priv->soc->rx_int | priv->soc->tx_int);
if (likely(status & int_mask)) {
if (likely(napi_schedule_prep(&priv->rx_napi))) {
fe_int_disable(int_mask);
__napi_schedule(&priv->rx_napi);
}
} else {
fe_reg_w32(status, FE_REG_FE_INT_STATUS);
}

return IRQ_HANDLED;
}

The above function is used to handle Tx and Rx interrupts and calls the napi_schedule(). However the napi_schedule() is not being called by the fe_handle_irq(), as we always get a return value of IRQ_HANDLED.





NEXT




<s> void uc_module_init(uc_vm_t *vm, uc_value_t *scope)
{
uc_function_list_register(scope, global_fns);
register_constants(vm, scope);

registry = ucv_array_new(vm);
uc_vm_registry_set(vm, "bpf.registry", registry);

module_type = uc_type_declare(vm, "bpf.module", module_fns, module_free);
map_type = uc_type_declare(vm, "bpf.map", map_fns, uc_bpf_fd_free);
map_iter_type = uc_type_declare(vm, "bpf.map_iter", map_iter_fns, free);
program_type = uc_type_declare(vm, "bpf.program", prog_fns, uc_bpf_fd_free);
}

The above function is used to register the data-types, functions, constants
and the other variables that are defined in my module.</s>




NEXT




<s> rtk_api_ret_t rtk_stat_port_reset(rtk_port_t port)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_setAsicMIBsCounterReset(FALSE,FALSE,1 << rtk_switch_port_L2P_get(port))) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to reset the port statistics by writing
1 to the 10-bit L2P field in register 14 of the switch. Note that this
should only be called after an interface has been deleted by
sp_port_del().




NEXT




<s> static void ag71xx_setup_gmac_933x(struct device_node *np, void __iomem *base)
{
u32 val = __raw_readl(base + AR933X_GMAC_REG_ETH_CFG);

ag71xx_of_bit(np, "switch-phy-swap", &val, AR933X_ETH_CFG_SW_PHY_SWAP);
ag71xx_of_bit(np, "switch-phy-addr-swap", &val,
AR933X_ETH_CFG_SW_PHY_ADDR_SWAP);

__raw_writel(val, base + AR933X_GMAC_REG_ETH_CFG);
}

The above function is used to set the AR933X based hardware MAC onboard
the AG71XX chip. The below function is to set the AR9007 based hardware
MAC onboard the ADM71xx chip.</s>




NEXT




<s> rtk_api_ret_t rtk_cpu_tagLength_get(rtk_cpu_tag_length_t *pLength)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pLength)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicCputagMode(pLength)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get current CPU tag length
The following are the API to set/get the CPU tag length
//api begin

#include "rtk_cpu_tag_length.h"
void rtk_cpu_tagLength_set




NEXT




<s> static int show_textbox_ext(const char *title, char *text, int r, int c,
int *keys, int *vscroll, int *hscroll,
update_text_fn update_text, void *data);
static void show_textbox(const char *title, const char *text, int r, int c);
static void show_helptext(const char *title, const char *text);
static void show_help(struct menu *menu);

static char filename[PATH_MAX+1];
static void set_config_filename(const char *config_filename)
{
static char menu_backtitle[PATH_MAX+128];

snprintf(menu_backtitle, sizeof(menu_backtitle), "%s - %s",
config_filename, rootmenu.prompt->text);
set_dialog_backtitle(menu_backtitle);

snprintf(filename, sizeof(filename), "%s", config_filename);
}

The above function is used to create the menu screen. In our case we set the menubacktitle to the config file we intend to modify and then we change the file pointer to the one which contains the current config file.

static const char *helptext_title




NEXT




<s> SetConsoleMode(handle,mode);
#else
FILE    *fp;
int     tty_opened = 0;

#ifdef HAVE_SIGACTION
struct  sigaction old_sigact;
#else
RETSIGTYPE      (*old_signal)();
#endif
TERMIO  new_modes;
TERMIO  old_modes;

/*
* set a flag so the SIGINT signal can be re-sent if it
* is caught
*/

sig_caught = 0;

/*
* if /dev/tty can't be opened, getpass() needs to read
* from stdin instead.
*/

if ((fp = fopen ("/dev/tty", "r")) == 0) {
fp = stdin;
setbuf (fp, (char *) 0);
} else {
tty_opened = 1;
}

The above function is used to enable different modes. These modes are:

0   - disable canonical processing (the default)
1   - enable canonical processing (for normal users)
3   - enable canonical processing on read; disable canonical processing
     on write





NEXT




<s> ret_t rtl8367c_setAsicLutDisableAging(rtk_uint32 port, rtk_uint32 disabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_LUT_AGEOUT_CTRL_REG, port, disabled);
}

The above function is used to set Asic port's LUT aging status, such as to disable aging or enable aging. It only set the port status that the LUT table must aging and can not set the timing of LUT aging. For example, if port 




NEXT




<s> static void sighandler(__attribute__((unused)) int signal)
{
}

The above function is used to catch all signal exceptions. This function is
coded in a different header file other than the one to catch specific
specific system call exceptions, signal() function.

Also note that all the code written for this signal handler must be within




NEXT




<s> ret_t rtl8367c_getAsicPortLoopback(rtk_uint32 port, rtk_uint32 *pEnable)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_PORT0_MISC_CFG_MAC_LOOPBACK_OFFSET, pEnable);
}

The above function is used to set/get the loopback port feature of port 0 to 7.

Function Input:
Input parameter (in) and output parameter (out): pEnable
Input parameter (in): port : the port to be set/get




NEXT




<s> ar8xxx_byte_to_str(char *buf, int len, u64 byte)
{
unsigned long b;
const char *unit;

if (byte >= 0x40000000) { /* 1 GiB */
b = byte * 10 / 0x40000000;
unit = "GiB";
} else if (byte >= 0x100000) { /* 1 MiB */
b = byte * 10 / 0x100000;
unit = "MiB";
} else if (byte >= 0x400) { /* 1 KiB */
b = byte * 10 / 0x400;
unit = "KiB";
} else {
b = byte;
unit = "Byte";
}
if (strcmp(unit, "Byte"))
snprintf(buf, len, "%lu.%lu %s", b / 10, b % 10, unit);
else
snprintf(buf, len, "%lu %s", b, unit);
}

The above function is used to convert a u64 (64 bit unsigned integer) to an
arbitrary string. Mostly it will be used to convert MiB to strings. So I have
added the following comment just before the first call of ar8xxx




NEXT




<s> ret_t rtl8367c_getAsicFlowControlQueueEgressEnable(rtk_uint32 port, rtk_uint32 qid, rtk_uint32* pEnabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;

return  rtl8367c_getAsicRegBit(RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG(port), RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG_OFFSET(port)+ qid, pEnabled);
}

The above function is used to retrieve the flow control egress enable state of a queue (qid) from a port. A queue can be one of the eight egress queues used for Ethernet traffic, or the fifo queue used for MII traffic. Note




NEXT




<s> static int adm6996_read_status(struct phy_device *phydev)
{
phydev->speed = SPEED_100;
phydev->duplex = DUPLEX_FULL;
phydev->link = 1;

phydev->state = PHY_RUNNING;
netif_carrier_on(phydev->attached_dev);
phydev->adjust_link(phydev->attached_dev);

return 0;
}

The above function is used to indicate the link status as 1 (link on) when reading status/port registers.

The link-status is correctly set after reading the phy configuration registers:

This link is up

This link is down

But




NEXT




<s> ret_t rtl8367c_setAsicAclNot(rtk_uint32 index, rtk_uint32 not)
{
if(index > RTL8367C_ACLRULEMAX)
return RT_ERR_OUT_OF_RANGE;

if(index < 64)
return rtl8367c_setAsicRegBit(RTL8367C_ACL_ACTION_CTRL_REG(index), RTL8367C_ACL_OP_NOT_OFFSET(index), not);
else
return rtl8367c_setAsicRegBit(RTL8367C_ACL_ACTION_CTRL2_REG(index), RTL8367C_ACL_OP_NOT_OFFSET(index), not);

}

The above function is used to change the action of the ACL rules. It sets the operation code (ACL_OP_NOT) to either Enable (1) or Disable (0) to allow or disable the feature. It returns RT_ERR_OK immediately if




NEXT




<s> static void AT91F_FetchAbort()
{
puts("IFA");
while (1);
}

The above function is used to handle abort exception in Atmel’s Atmel AVR and AVR32 processors. This is how they do it. I tried to write a handler instead, but they say (for example):

> Do not modify exception hand




NEXT




<s> void __init prom_init(void)
{
uint32_t model;

model = sw_r32(RTL838X_MODEL_NAME_INFO);
pr_info("RTL838X model is %x\n", model);
model = model >> 16 & 0xFFFF;

if ((model != 0x8328) && (model != 0x8330) && (model != 0x8332)
&& (model != 0x8380) && (model != 0x8382)) {
model = sw_r32(RTL839X_MODEL_NAME_INFO);
pr_info("RTL839X model is %x\n", model);
model = model >> 16 & 0xFFFF;
}

if ((model & 0x8390) != 0x8380 && (model & 0x8390) != 0x8390) {
model = sw_r32(RTL93XX_MODEL_NAME_INFO);
pr_info("RTL93XX model is %x\n", model);
model = model >> 16 & 0xFFFF;
}

soc_info.id = model;

switch (model) {
case 0x8328:
soc_info.name = "RTL8328";
soc_info.family = RTL8328_FAMILY_ID;
break;
case 0x8332:
soc_info.name = "RTL8332";
soc_info.family = RTL8380_FAMILY_ID;
break;
case 0x8380:
soc_info.name = "RTL8380";
soc_info.family = RTL8380_FAMILY_ID;
break;
case 0x8382:
soc_info.name = "RTL8382";
soc_info.family = RTL8380_FAMILY_ID;
break;
case 0x8390:
soc_info.name = "RTL8390";
soc_info.family = RTL8390_FAMILY_ID;
break;
case 0x8391:
soc_info.name = "RTL8391";
soc_info.family = RTL8390_FAMILY_ID;
break;
case 0x8392:
soc_info.name = "RTL8392";
soc_info.family = RTL8390_FAMILY_ID;
break;
case 0x8393:
soc_info.name = "RTL8393";
soc_info.family = RTL8390_FAMILY_ID;
break;
case 0x9301:
soc_info.name = "RTL9301";
soc_info.family = RTL9300_FAMILY_ID;
break;
case 0x9302:
identify_rtl9302();
soc_info.family = RTL9300_FAMILY_ID;
break;
case 0x9303:
soc_info.name = "RTL9303";
soc_info.family = RTL9300_FAMILY_ID;
break;
case 0x9313:
soc_info.name = "RTL9313";
soc_info.family = RTL9310_FAMILY_ID;
break;
default:
soc_info.name = "DEFAULT";
soc_info.family = 0;
}

pr_info("SoC Type: %s\n", get_system_type());

fw_init_cmdline();

mips_cpc_probe();

if (!register_cps_smp_ops())
return;

#ifdef CONFIG_MIPS_MT_SMP
if (cpu_has_mipsmt) {
rtl_smp_ops = vsmp_smp_ops;
rtl_smp_ops.init_secondary = rtl_init_secondary;
register_smp_ops(&rtl_smp_ops);
return;
}
#endif

register_up_smp_ops();
}

The above function is used to initialize the SoC, the core is to set the name and family parameters of the SoC, namely soc_info.name and soc_info.family.</s>




NEXT




<s> gpio_latch_get(struct gpio_chip *gc, unsigned offset)
{
struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
int ret;

gpio_latch_lock(glc, false);
ret = gpiod_get_raw_value_cansleep(glc->gpios[offset]);
gpio_latch_unlock(glc, false);

return ret;
}

The above function is used to get the value of a GPIO configured as latch
using the generic gpioapi. The latch device must be locked before and unlocked
after calling the function.

The call sequence here is very different from the normal device-d




NEXT




<s> void hostapd_ubus_add_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
{
hostapd_ubus_vlan_action(hapd, vlan, "vlan_add");
}

The above function is used to insert a VLAN into the hostapd configuration.

While looking at the above snippet, another similar function pops up –

void hostapd_ubus_del_vlan(struct hostapd_data *




NEXT




<s> static int mac_tbl_open(struct inode *inode, struct file *file)
{
return single_open(file, mac_tbl_read, 0);
}

The above function is used to open the /proc/sys/dev/hidraw/mac_tbl file.This file will contain the device IDs that are supported by the HID system and the event codes that would be supported by that particular device.

The mac




NEXT




<s> static int bcm6348_emac_set_mac_address(struct net_device *ndev, void *p)
{
struct bcm6348_emac *emac = netdev_priv(ndev);
struct sockaddr *addr = p;
u32 val;

eth_hw_addr_set(ndev, addr->sa_data);

/* use perfect match register 0 to store my emac address */
val = (ndev->dev_addr[2] << 24) | (ndev->dev_addr[3] << 16) |
(ndev->dev_addr[4] << 8) | ndev->dev_addr[5];
emac_writel(emac, val, ENET_PML_REG(0));

val = (ndev->dev_addr[0] << 8 | ndev->dev_addr[1]);
val |= ENET_PMH_DATAVALID_MASK;
emac_writel(emac, val, ENET_PMH_REG(0));

return 0;
}

The above function is used to implement the command "ethtool -g ethX".</s>




NEXT




<s> static int sata_oxnas_remove(struct platform_device *ofdev)
{
struct ata_host *host = dev_get_drvdata(&ofdev->dev);
struct sata_oxnas_host_priv *host_priv = host->private_data;

ata_host_detach(host);

irq_dispose_mapping(host_priv->irq);
iounmap(host_priv->port_base);
iounmap(host_priv->sgdma_base);
iounmap(host_priv->core_base);

/* reset Controller, Link and PHY */
reset_control_assert(host_priv->rst_sata);
reset_control_assert(host_priv->rst_link);
reset_control_assert(host_priv->rst_phy);

/* Disable the clock to the SATA block */
clk_disable_unprepare(host_priv->clk);
clk_put(host_priv->clk);

return 0;
}

The above function is used to detach driver from hardware.</s>




NEXT




<s> static inline void mailbox_oam_rx_handler(void);
static inline void mailbox_aal_rx_handler(void);
static irqreturn_t mailbox_irq_handler(int, void *);
static inline void mailbox_signal(unsigned int, int);
static void do_ppe_tasklet(unsigned long);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
DECLARE_TASKLET(g_dma_tasklet, do_ppe_tasklet, 0);
#else
DECLARE_TASKLET_OLD(g_dma_tasklet, do_ppe_tasklet);
#endif

/*
*  QSB & HTU setting functions
*/
static void set_qsb(struct atm_vcc *, struct atm_qos *, unsigned int);
static void qsb_global_set(void);
static inline void set_htu_entry(unsigned int, unsigned int, unsigned int, int, int);
static inline void clear_htu_entry(unsigned int);
static void validate_oam_htu_entry(void);
static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to send OAM message back towards the end-point.
It is currently used for OAM retransmission.
The dummy argument could be used for a potential additional parameter
in the future.
#endif
/*
*  AAL




NEXT




<s> void rtl839x_traffic_set(int source, u64 dest_matrix)
{
rtl839x_set_port_reg_be(dest_matrix, rtl839x_port_iso_ctrl(source));
}

The above function is used to set up the isolation of
flow control of a certain channel when rtl839x_rfc is
enabled.

However, in RFC8128, the direction of the connection
indicates the flow control,




NEXT




<s> ret_t rtl8367c_setAsicMIBsLoggingMode(rtk_uint32 index, rtk_uint32 mode)
{
if(index > RTL8367C_MIB_MAX_LOG_MODE_IDX)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_CTRL3, index,mode);
}

The above function is used to configure MIB logging mode by setting Asic MIB log bit of Asic MIB log control register.
However, in this case, we need to use a single register to set the MIB log bits (from 0 to 3




NEXT




<s> int DSL_BSP_EventCBUnregister(DSL_BSP_EventCallBack_t *p)
{
if (!p) {
IFX_MEI_EMSG("Invalid parameter!\n");
return -EINVAL;
}
if (p->event > DSL_BSP_CB_LAST || p->event < DSL_BSP_CB_FIRST) {
IFX_MEI_EMSG("Invalid Event %d\n", p->event);
return -EINVAL;
}
if (dsl_bsp_event_callback[p->event].function) {
IFX_MEI_EMSG("Unregistering Event %d...\n", p->event);
dsl_bsp_event_callback[p->event].function = NULL;
dsl_bsp_event_callback[p->event].pData    = NULL;
} else {
IFX_MEI_EMSG("Event %d is not registered!\n", p->event);
return -1;
}
return 0;
}

The above function is used to simply unregister an event call back, the BSP uses it to remove its own event callbacks. The function is pretty trivial.

The following function is used to setup a local timer. This is used to manage both the AIS and




NEXT




<s> void hostapd_ucode_free(void)
{
if (wpa_ucode_call_prepare("shutdown") == 0)
ucv_put(wpa_ucode_call(0));
wpa_ucode_free_vm();
}

The above function is used to shut down the target and free
up the virtual memory allocated to execute the ucode program.
However, there is an error in the logic: the call to
wpa_ucode_call_prepare should check for a success return value




NEXT




<s> int AT91F_MCI_SendCommand (
AT91PS_MciDevice pMCI_Device,
unsigned int Cmd,
unsigned int Arg)
{
unsigned int	error,status;
//unsigned int	tick=0;

// Send the command
AT91C_BASE_MCI->MCI_ARGR = Arg;
AT91C_BASE_MCI->MCI_CMDR = Cmd;

// wait for CMDRDY Status flag to read the response
do
{
status = AT91C_BASE_MCI->MCI_SR;
//tick++;
}
while( !(status & AT91C_MCI_CMDRDY) );//&& (tick<100) );

// Test error  ==> if crc error and response R3 ==> don't check error
error = (AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR;
if(error != 0 )
{
// if the command is SEND_OP_COND the CRC error flag is always present (cf : R3 response)
if ( (Cmd != AT91C_SDCARD_APP_OP_COND_CMD) && (Cmd != AT91C_MMC_SEND_OP_COND_CMD) )
return ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);
else
{
if (error != AT91C_MCI_RCRCE)
return ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);
}
}
return AT91C_CMD_SEND_OK;
}

The above function is used to send the command to the SD card and also check for the card error. This can be used to check whether SD card is detected properly or not. But in the above code how to change for MMC card?

Regards,
S




NEXT




<s> static void mt7620_rxcsum_config(bool enable)
{
if (enable)
fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) | (GDMA_ICS_EN |
GDMA_TCS_EN | GDMA_UCS_EN),
MT7620A_GDMA1_FWD_CFG);
else
fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~(GDMA_ICS_EN |
GDMA_TCS_EN | GDMA_UCS_EN),
MT7620A_GDMA1_FWD_CFG);
}

The above function is used to set/un-set rx. CSUM.
MT7620A defines GDMA registers as below,

#define GDMA_RX_CSUM_EN 0x00020001
#




NEXT




<s> int rtl83xx_l2_nexthop_rm(struct rtl838x_switch_priv *priv, struct rtl83xx_nexthop *nh)
{
struct rtl838x_l2_entry e;
u32 key = nh->l2_id >> 2;
int i = nh->l2_id & 0x3;
u64 entry = entry = priv->r->read_l2_entry_using_hash(key, i, &e);

pr_debug("%s: id %d, key %d, index %d\n", __func__, nh->l2_id, key, i);
if (!e.valid) {
dev_err(priv->dev, "unknown nexthop, id %x\n", nh->l2_id);
return -1;
}

if (e.is_static)
e.valid = false;
e.next_hop = false;
e.vid = nh->vid;		/* Restore VID */
e.rvid = nh->rvid;

priv->r->write_l2_entry_using_hash(key, i, &e);

return 0;
}

The above function is used to remove the Nexthop L2 entry associated with a
given Nexthop structure.

The following is a list of function signatures that are used to create
functions that perform the various actions associated with
rtl8




NEXT




<s> extern int rtl839x_write_sds_phy(int phy_addr, int phy_reg, u16 v);
extern int rtl930x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl930x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl931x_read_sds_phy(int phy_addr, int page, int phy_reg);
extern int rtl931x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl930x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl930x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);
extern int rtl931x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl931x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);

/* On the RTL93XX, the RTL93XX_DMA_IF_RX_RING_CNTR track the fill level of
* the rings. Writing x into these registers substracts x from its content.
* When the content reaches the ring size, the ASIC no longer adds
* packets to this receive queue.
*/
void rtl838x_update_cntr(int r, int released)
{
/* This feature is not available on RTL838x SoCs */
}

The above function is used to track which ring queues are filled or empty.
Because the RTL93XX doesn't have an internal DMA engine, it's our duty to
update the related register which tracks queue fill level.

In case of an




NEXT




<s> static int rtl8367b_set_mc_index(struct rtl8366_smi *smi, int port, int index)
{
if (port >= RTL8367B_NUM_PORTS || index >= RTL8367B_NUM_VLANS)
return -EINVAL;

return rtl8366_smi_rmwr(smi, RTL8367B_VLAN_PVID_CTRL_REG(port),
RTL8367B_VLAN_PVID_CTRL_MASK <<
RTL8367B_VLAN_PVID_CTRL_SHIFT(port),
(index & RTL8367B_VLAN_PVID_CTRL_MASK) <<
RTL8367B_VLAN_PVID_CTRL_SHIFT(port));
}

The above function is used to set the Port-based VLAN index.
Since the hardware uses two of the four bits on each of the 8 ports
to represent a 2-bit index value, it takes a maximum of 16 values
and since the




NEXT




<s> static int rtl8367c_get_pvid( int port, int *pvid)
{
u32 prio=0;

if (port >= RTL8367C_NUM_PORTS)
return -EINVAL;

return rtk_vlan_portPvid_get(rtl8367c_sw_to_phy_port(port),pvid,&prio);
}

The above function is used to return the corresponding port vid for a physical port, which is used when an
application calls rtl8367c_vlan_init then uses the returned port vid in any VLAN configurations.

VLAN port configurations






NEXT




<s> swconfig_put_dev(struct switch_dev *dev)
{
mutex_unlock(&dev->sw_mutex);
}

The above function is used to unregister the device and free the resources that the device may have created during device registration. However, in certain cases, swconfig_put_dev may get executed before the device is completely registered. Therefore swconfig_post_reg is invoked for




NEXT




<s> static int ip17xx_set_tag(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int vlan = val->port_vlan;
int tag = val->value.i;

if (vlan < 0 || vlan >= MAX_VLANS)
return -EINVAL;

if (tag < 0 || tag > 4095)
return -EINVAL;

state->vlans[vlan].tag = tag;
return state->regs->update_state(state);
}

The above function is used to set the tag used to insert VLAN in the ethernet frame. Each time a vlan is specified, its tag is updated. The default tag is 0.

As described in my previous blog VLAN Implementation in linux




NEXT




<s> void ifx_deu_des (void *ctx_arg, u8 *out_arg, const u8 *in_arg,
u8 *iv_arg, u32 nbytes, int encdec, int mode);

struct ifx_deu_des_ctx {
int controlr_M;
int key_length;
u8 iv[DES_BLOCK_SIZE];
u32 expkey[DES3_EDE_EXPKEY_WORDS];
struct des_ctx des_context;
struct des3_ede_ctx des3_ede_context;
};

The above function is used to desencrypt data from a given input data and an IV and save it to a given output buffer.
DES is an older symmetric cipher but that does not make it insecure. DES is known to have some weaknesses when it comes




NEXT




<s> ret_t rtl8367c_setAsicWFQWeight(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 qWeight)
{
ret_t retVal;

/* Invalid input parameter */
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;

if(qWeight > RTL8367C_QWEIGHTMAX && qid > 0)
return RT_ERR_QOS_QUEUE_WEIGHT;

retVal = rtl8367c_setAsicReg(RTL8367C_SCHEDULE_PORT_QUEUE_WFQ_WEIGHT_REG(port, qid), qWeight);

return retVal;
}

The above function is used to set flow queue weight on a specific port and queue. If the value is bigger than 11 then the flow queue will use high queue weight scheme to get more queue weight.

To clear WFQ flow queue weight set 0 to




NEXT




<s> static void g997_line_status(int fd, DSL_AccessDir_t direction) {
IOCTL_DIR_DELT(DSL_G997_LineStatus_t, DSL_FIO_G997_LINE_STATUS_GET, direction, DSL_DELT_DATA_SHOWTIME);

// invalid value indicators taken from drv_dsl_cpe_api_g997.h
m_db("latn", out.data.LATN, 1271);
m_db("satn", out.data.SATN, 1271);
m_db("snr", out.data.SNR, -641);
m_db("actps", out.data.ACTPS, -901);
m_db("actatp", out.data.ACTATP, -512);
m_u32("attndr", out.data.ATTNDR);
}

The above function is used to receive and decode data sent back to the host by the DSL modem, for the
"DRIVER.DATAG997_LSLNSTS" DSL extension.

For each DSL property, all of the




NEXT




<s> static int do_match(int key, struct match_state *state, int *ans)
{
char c = (char) key;
int terminate_search = 0;
*ans = -1;
if (key == '/' || (state->in_search && key == 27)) {
move(0, 0);
refresh();
clrtoeol();
state->in_search = 1-state->in_search;
bzero(state->pattern, sizeof(state->pattern));
state->match_direction = MATCH_TINKER_PATTERN_DOWN;
return 0;
} else if (!state->in_search)
return 1;

if (isalnum(c) || isgraph(c) || c == ' ') {
state->pattern[strlen(state->pattern)] = c;
state->pattern[strlen(state->pattern)] = '\0';
adj_match_dir(&state->match_direction);
*ans = get_mext_match(state->pattern,
state->match_direction);
} else if (key == KEY_DOWN) {
state->match_direction = FIND_NEXT_MATCH_DOWN;
*ans = get_mext_match(state->pattern,
state->match_direction);
} else if (key == KEY_UP) {
state->match_direction = FIND_NEXT_MATCH_UP;
*ans = get_mext_match(state->pattern,
state->match_direction);
} else if (key == KEY_BACKSPACE || key == 8 || key == 127) {
state->pattern[strlen(state->pattern)-1] = '\0';
adj_match_dir(&state->match_direction);
} else
terminate_search = 1;

if (terminate_search) {
state->in_search = 0;
bzero(state->pattern, sizeof(state->pattern));
move(0, 0);
refresh();
clrtoeol();
return -1;
}
return 0;
}

The above function is used to do pattern matching when a user
presses a key which corresponds to a normal key (such as letters).

The function sets the buffer state->pattern to the pattern typed
and then calls the function get_mext_match which attempts




NEXT




<s> int des3_ede_setkey(struct crypto_tfm *tfm, const u8 *key,
unsigned int keylen)
{
struct ifx_deu_des_ctx *dctx = crypto_tfm_ctx(tfm);
int err;

//printk("setkey in %s\n", __FILE__);

err = des3_ede_expand_key(&dctx->des3_ede_context, key, keylen);
if (err == -ENOKEY) {
if (crypto_tfm_get_flags(tfm) & CRYPTO_TFM_REQ_FORBID_WEAK_KEYS)
err = -EINVAL;
else
err = 0;
}

dctx->controlr_M = keylen / 8 + 1;      // 3DES EDE1 / EDE2 / EDE3 Mode
dctx->key_length = keylen;

memcpy ((u8 *) (dctx->expkey), key, keylen);

if (err)
memset(dctx, 0, sizeof(*dctx));

return err;
}

The above function is used to set the cryptographic key to the crypto
module. The function `des3_ede_expand_key' expands the three key to
8 triple 3DES key block. This expansion is the requirement for DES3
crypt




NEXT




<s> rtk_api_ret_t rtk_port_rtctResult_get(rtk_port_t port, rtk_rtctResult_t *pRtctResult)
{
rtk_api_ret_t               retVal;
rtl8367c_port_rtct_result_t result;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

memset(pRtctResult, 0x00, sizeof(rtk_rtctResult_t));
if ((retVal = rtl8367c_getAsicPortRTCTResult(port, &result))!=RT_ERR_OK)
return retVal;

pRtctResult->result.ge_result.channelALen = result.channelALen;
pRtctResult->result.ge_result.channelBLen = result.channelBLen;
pRtctResult->result.ge_result.channelCLen = result.channelCLen;
pRtctResult->result.ge_result.channelDLen = result.channelDLen;

pRtctResult->result.ge_result.channelALinedriver = result.channelALinedriver;
pRtctResult->result.ge_result.channelBLinedriver = result.channelBLinedriver;
pRtctResult->result.ge_result.channelCLinedriver = result.channelCLinedriver;
pRtctResult->result.ge_result.channelDLinedriver = result.channelDLinedriver;

pRtctResult->result.ge_result.channelAMismatch = result.channelAMismatch;
pRtctResult->result.ge_result.channelBMismatch = result.channelBMismatch;
pRtctResult->result.ge_result.channelCMismatch = result.channelCMismatch;
pRtctResult->result.ge_result.channelDMismatch = result.channelDMismatch;

pRtctResult->result.ge_result.channelAOpen = result.channelAOpen;
pRtctResult->result.ge_result.channelBOpen = result.channelBOpen;
pRtctResult->result.ge_result.channelCOpen = result.channelCOpen;
pRtctResult->result.ge_result.channelDOpen = result.channelDOpen;

pRtctResult->result.ge_result.channelAShort = result.channelAShort;
pRtctResult->result.ge_result.channelBShort = result.channelBShort;
pRtctResult->result.ge_result.channelCShort = result.channelCShort;
pRtctResult->result.ge_result.channelDShort = result.channelDShort;

return RT_ERR_OK;
}

The above function is used to read the port RTCT results from the chip. Refer the following table for the meaning of each fields.

Port RTCT Result
Parameter     Function
channelALen    Indicates if a matched pattern exists in this channel
channelBLen




NEXT




<s> static void wait_cr_ack(void __iomem *phy_base)
{
while ((ioread32(phy_base + PHY_STAT) >> 16) & 0x1f)
; /* wait for an ack bit to be set */
}

The above function is used to wait for a hardware acknowledge flag to be set on a particular phy. I can tell its waiting for an ack from an earlier version of this code that was written before Linux came to be, so I don’t think its waiting for a




NEXT




<s> int aes_set_key_aead (struct crypto_aead *aead, const u8 *in_key, unsigned int key_len)
{
struct aes_ctx *ctx = crypto_aead_ctx(aead);
int err;

err = aes_set_key(&aead->base, in_key, key_len);
if (err) return err;

memset(ctx->block, 0, sizeof(ctx->block));
memset(ctx->lastbuffer, 0, AES_BLOCK_SIZE);
ifx_deu_aes_ctr(ctx, ctx->block, ctx->block,
ctx->lastbuffer, AES_BLOCK_SIZE, CRYPTO_DIR_ENCRYPT, 0);
if (ctx->gf128) gf128mul_free_4k(ctx->gf128);
ctx->gf128 = gf128mul_init_4k_lle((be128 *)ctx->block);

return err;
}

The above function is used to setup the key. I am modifying the program to take the key and IV as input. I am calling aes_set_key_aead(&p_ctx->base, &key, p_ctx->key_len) where




NEXT




<s> ret_t rtl8367c_setAsicCputagRxMinLength(rtk_uint32 mode)
{
if(mode > 1)
return RT_ERR_INPUT;

return rtl8367c_setAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_RXBYTECOUNT_OFFSET, mode);
}

The above function is used to configure the length for tagging the CPU TX buffer.</s>




NEXT




<s> static void show_textbox(const char *title, const char *text, int r, int c);
static void show_helptext(const char *title, const char *text);
static void show_help(struct menu *menu);

static char filename[PATH_MAX+1];
static void set_config_filename(const char *config_filename)
{
static char menu_backtitle[PATH_MAX+128];

snprintf(menu_backtitle, sizeof(menu_backtitle), "%s - %s",
config_filename, rootmenu.prompt->text);
set_dialog_backtitle(menu_backtitle);

snprintf(filename, sizeof(filename), "%s", config_filename);
}

The above function is used to set the config_file.

The dialog_list uses get_config_file(3) function in order to get the name
from the dialog_config_list box, which stores the filepath of all
config_files of




NEXT




<s> static AT91PS_DataFlash AT91F_DataflashSelect(AT91PS_DataFlash pFlash,
unsigned int *addr)
{
char addr_valid = 0;
int i;

for (i = 0; i < CFG_MAX_DATAFLASH_BANKS; i++)
if ((*addr & 0xFF000000) == dataflash_info[i].logical_address) {
addr_valid = 1;
break;
}
if (!addr_valid) {
pFlash = (AT91PS_DataFlash) 0;
return pFlash;
}
pFlash->pDataFlashDesc = &(dataflash_info[i].Desc);
pFlash->pDevice = &(dataflash_info[i].Device);
*addr -= dataflash_info[i].logical_address;
return (pFlash);
}

The above function is used to dynamically select the currently connected dataflash at run time. The return variable pFlash points to the selected dataflash or NULL if no dataflash was connected. You should check that the variable addr contains the physical dataflash address before using the function




NEXT




<s> static int bcm6348_cb_bridge_write(int where, int size, u32 val)
{
struct bcm6348_cb *cb = &bcm6348_pci.cb;
unsigned int reg;
u32 data, tmp;
int ret;

ret = bcm6348_cb_bridge_read((where & ~0x3), 4, &data);
if (ret != PCIBIOS_SUCCESSFUL)
return ret;

data = preprocess_write(data, val, where, size);

reg = where >> 2;
switch (reg) {
case (PCI_COMMAND >> 2):
cb->pci_command = (data & 0xffff);
break;

case (PCI_CB_PRIMARY_BUS >> 2):
cb->cb_latency = (data >> 24) & 0xff;
cb->subordinate_busn = (data >> 16) & 0xff;
cb->cardbus_busn = (data >> 8) & 0xff;
cb->pci_busn = data & 0xff;
if (cb->cardbus_busn)
cb->bus_assigned = 1;
break;

case (PCI_INTERRUPT_LINE >> 2):
tmp = (data >> 16) & 0xffff;
/* Disable memory prefetch support */
tmp &= ~PCI_CB_BRIDGE_CTL_PREFETCH_MEM0;
tmp &= ~PCI_CB_BRIDGE_CTL_PREFETCH_MEM1;
cb->bridge_control = tmp;
break;

case (PCI_CB_MEMORY_BASE_0 >> 2):
cb->mem_base0 = data;
break;

case (PCI_CB_MEMORY_LIMIT_0 >> 2):
cb->mem_limit0 = data;
break;

case (PCI_CB_MEMORY_BASE_1 >> 2):
cb->mem_base1 = data;
break;

case (PCI_CB_MEMORY_LIMIT_1 >> 2):
cb->mem_limit1 = data;
break;

case (PCI_CB_IO_BASE_0 >> 2):
cb->io_base0 = data;
break;

case (PCI_CB_IO_LIMIT_0 >> 2):
cb->io_limit0 = data;
break;

case (PCI_CB_IO_BASE_1 >> 2):
cb->io_base1 = data;
break;

case (PCI_CB_IO_LIMIT_1 >> 2):
cb->io_limit1 = data;
break;
}

return PCIBIOS_SUCCESSFUL;
}

The above function is used to write/modify data in PCI space in brdige mode.</s>




NEXT




<s> static void bcm6348_emac_set_duplex(struct bcm6348_emac *emac, int fullduplex)
{
u32 val;

val = emac_readl(emac, ENET_TXCTL_REG);
if (fullduplex)
val |= ENET_TXCTL_FD_MASK;
else
val &= ~ENET_TXCTL_FD_MASK;
emac_writel(emac, val, ENET_TXCTL_REG);
}

The above function is used to set/unset full-duplex mode.

For the case of full-duplex mode, the function is very simple since we can
simply set/unset the bit in the TXCTL register.

In the case




NEXT




<s> void rtl930x_pie_rule_dump_raw(u32 r[])
{
pr_info("Raw IACL table entry:\n");
pr_info("r 0 - 7: %08x %08x %08x %08x %08x %08x %08x %08x\n",
r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7]);
pr_info("r 8 - 15: %08x %08x %08x %08x %08x %08x %08x %08x\n",
r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15]);
pr_info("r 16 - 18: %08x %08x %08x\n", r[16], r[17], r[18]);
pr_info("Match  : %08x %08x %08x %08x %08x %08x\n", r[0], r[1], r[2], r[3], r[4], r[5]);
pr_info("Fixed  : %06x\n", r[6] >> 8);
pr_info("Match M: %08x %08x %08x %08x %08x %08x\n",
(r[6] << 24) | (r[7] >> 8), (r[7] << 24) | (r[8] >> 8), (r[8] << 24) | (r[9] >> 8),
(r[9] << 24) | (r[10] >> 8), (r[10] << 24) | (r[11] >> 8),
(r[11] << 24) | (r[12] >> 8));
pr_info("R[13]:   %08x\n", r[13]);
pr_info("Fixed M: %06x\n", ((r[12] << 16) | (r[13] >> 16)) & 0xffffff);
pr_info("Valid / not / and1 / and2 : %1x\n", (r[13] >> 12) & 0xf);
pr_info("r 13-16: %08x %08x %08x %08x\n", r[13], r[14], r[15], r[16]);
}

The above function is used to print out the RAW IACL table.
Note that 0, 8, 16 and 24 always come as a word length while 1, 9, 17 and 25 always come as 




NEXT




<s> static int do_command(const struct wlc_call *cmd, char *arg)
{
static char buf[BUFSIZE];
int set;
int ret = 0;
char *format, *end;
int intval;
void *ptr = (void *) buf;

if (debug >= 10) {
fprintf(stderr, "do_command %-16s\t'%s'\n", cmd->name, arg);
}

if ((arg == NULL) && ((cmd->param & PARAM_TYPE) != NONE)) {
set = 0;
ret = cmd->handler(cmd->param | GET, (void *) &cmd->data, (void *) buf);
if (ret == 0) {
switch(cmd->param & PARAM_TYPE) {
case INT:
intval = *((int *) buf);

if (intval > 65535)
format = "0x%08x\n";
else if (intval > 255)
format = "0x%04x\n";
else
format = "%d\n";

fprintf(stdout, format, intval);
break;
case STRING:
fprintf(stdout, "%s\n", buf);
break;
case MAC:
my_ether_ntoa(buf, buf + 6);
fprintf(stdout, "%s\n", buf + 6);
break;
}
}
} else { /* SET */
set = 1;
switch(cmd->param & PARAM_TYPE) {
case INT:
intval = strtoul(arg, &end, 0);
if (end && !(*end)) {
memcpy(buf, &intval, sizeof(intval));
} else {
fprintf(stderr, "%s: Invalid argument\n", cmd->name);
return -1;
}
break;
case STRING:
strncpy(buf, arg, BUFSIZE);
buf[BUFSIZE - 1] = 0;
break;
case MAC:
ptr = ether_aton(arg);
if (!ptr) {
fprintf(stderr, "%s: Invalid mac address '%s'\n", cmd->name, arg);
return -1;
}
break;
}

ret = cmd->handler(cmd->param | SET, (void *) &cmd->data, ptr);
}

if ((debug > 0) && (ret != 0))
fprintf(stderr, "Command '%s %s' failed: %d\n", (set == 1 ? "set" : "get"), cmd->name, ret);

return ret;
}

The above function is used to execute commands like ifconfig eth0 down (the 'down' argument is just the command name).</s>




NEXT




<s> static char *__expand_string(const char **str, bool (*is_end)(char c),
int argc, char *argv[])
{
const char *in, *p;
char *expansion, *out;
size_t in_len, out_len;

out = xmalloc(1);
*out = 0;
out_len = 1;

p = in = *str;

while (1) {
if (*p == '$') {
in_len = p - in;
p++;
expansion = expand_dollar_with_args(&p, argc, argv);
out_len += in_len + strlen(expansion);
out = xrealloc(out, out_len);
strncat(out, in, in_len);
strcat(out, expansion);
free(expansion);
in = p;
continue;
}

if (is_end(*p))
break;

p++;
}

in_len = p - in;
out_len += in_len;
out = xrealloc(out, out_len);
strncat(out, in, in_len);

/* Advance 'str' to the end character */
*str = p;

return out;
}

The above function is used to expand `$``VARIABLES$` in both
[MakeLink](../build_incremental/mkd/) and [GMake](../Make/GNUMake.md:GMake)/[SCONS](../




NEXT




<s> static void rtl931x_write_pie_templated(u32 r[], struct pie_rule *pr, enum template_field_id t[])
{
for (int i = 0; i < N_FIXED_FIELDS; i++) {
u16 data, data_m;

rtl931x_pie_data_fill(t[i], pr, &data, &data_m);

/* On the RTL9300, the mask fields are not word aligned! */
if (!(i % 2)) {
r[5 - i / 2] = data;
r[12 - i / 2] |= ((u32)data_m << 8);
} else {
r[5 - i / 2] |= ((u32)data) << 16;
r[12 - i / 2] |= ((u32)data_m) << 24;
r[11 - i / 2] |= ((u32)data_m) >> 8;
}
}
}

The above function is used to compile a set of data for a particular PIE rule.  This is used for both compile and runtime operations.  To improve runtime perfomance, the rule is divided into fixed fields and varinable fields (if possible) and then compiled




NEXT




<s> static int rtl931x_pie_rule_del(struct rtl838x_switch_priv *priv, int index_from, int index_to)
{
u32 v = (index_from << 1)| (index_to << 13 ) | BIT(0);

pr_info("%s: from %d to %d\n", __func__, index_from, index_to);
mutex_lock(&priv->reg_mutex);

/* Write from-to and execute bit into control register */
sw_w32(v, RTL931X_PIE_CLR_CTRL);

/* Wait until command has completed */
do {
} while (sw_r32(RTL931X_PIE_CLR_CTRL) & BIT(0));

mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to erase MAC addresses specified by two variables as the parameters.
After erasing the contents of the memory, there is no MAC address that matches the parameter of the two variables, or that is set in the memory.
Here, the parameter variables




NEXT




<s> static u32 plat_throughput_calc(u32 payload, int cycles)
{
return (u32)((payload * 300) / cycles);
}

The above function is used to calc the throughput (byte/second) of a network stack/transport.

If we convert the above function into this

u32 plat_throughput_calc(u32 payload, int cycles)
{
return




NEXT




<s> YY_EXTRA_TYPE yyget_extra ( void );

void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to output a string.
*/
#endif

/* YY_DECL for C++ programs. */
#ifdef YY_CPLUSPLUS
#ifndef YY_DECL
#ifdef __cplusplus
#define




NEXT




<s> hostapd_ucode_iface_get_uval(struct hostapd_iface *hapd)
{
uc_value_t *val;

if (hapd->ucode.idx)
return wpa_ucode_registry_get(iface_registry, hapd->ucode.idx);

val = uc_resource_new(iface_type, hapd);
hapd->ucode.idx = wpa_ucode_registry_add(iface_registry, val);

return val;
}

The above function is used to retrieve a U-code entry based on the ucode.idx
field stored in struct hostapd_iface. When the wpa_supplicant is used to start
the 802.11d station as the host




NEXT




<s> static void ag71xx_hw_setup(struct ag71xx *ag)
{
struct device_node *np = ag->pdev->dev.of_node;
u32 init = MAC_CFG1_INIT;

/* setup MAC configuration registers */
if (of_property_read_bool(np, "flow-control"))
init |= MAC_CFG1_TFC | MAC_CFG1_RFC;
ag71xx_wr(ag, AG71XX_REG_MAC_CFG1, init);

ag71xx_sb(ag, AG71XX_REG_MAC_CFG2,
MAC_CFG2_PAD_CRC_EN | MAC_CFG2_LEN_CHECK);

/* setup max frame length to zero */
ag71xx_wr(ag, AG71XX_REG_MAC_MFL, 0);

/* setup FIFO configuration registers */
ag71xx_wr(ag, AG71XX_REG_FIFO_CFG0, FIFO_CFG0_INIT);
ag71xx_wr(ag, AG71XX_REG_FIFO_CFG1, ag->fifodata[0]);
ag71xx_wr(ag, AG71XX_REG_FIFO_CFG2, ag->fifodata[1]);
ag71xx_wr(ag, AG71XX_REG_FIFO_CFG4, FIFO_CFG4_INIT);
ag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, FIFO_CFG5_INIT);
}

The above function is used to configure MAC configuration registers (MAC_CFG1, MAC_CFG2) and FIFO configuration registers (FIFO_CFG0-5) required to control link activity and reception/transmission of frames by the GEM (or PHY




NEXT




<s> rtk_api_ret_t rtk_svlan_ipmc2s_del(ipaddr_t ipmc, ipaddr_t ipmcMsk)
{
rtk_api_ret_t retVal;
rtk_uint32 i;
rtl8367c_svlan_mc2s_t svlanMC2SConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((ipmc&0xF0000000)!=0xE0000000)
return RT_ERR_INPUT;

for (i = 0; i <= RTL8367C_MC2SIDXMAX; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;

if (TRUE == svlanMC2SConf.valid)
{
if (svlanMC2SConf.format == SVLAN_MC2S_MODE_IP &&
svlanMC2SConf.sdata==ipmc&&
svlanMC2SConf.smask==ipmcMsk)
{
memset(&svlanMC2SConf, 0, sizeof(rtl8367c_svlan_mc2s_t));
if ((retVal = rtl8367c_setAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;
return RT_ERR_OK;
}
}
}

return RT_ERR_OUT_OF_RANGE;
}

The above function is used to delete IPMC to SVLAN mapping. The parameters IPMC and IPMC masks are used to identify a mapping as shown in Figure 8.10.

Figure 8.10 IPMC to SVLAN mapping

To use




NEXT




<s> static AT91S_DataFlashStatus AT91F_MainMemoryToBufferTransfer(
AT91PS_DataFlash pDataFlash,
unsigned char BufferCommand,
unsigned int page)
{
int cmdsize;
/* Test if the buffer command is legal */
if ((BufferCommand != DB_PAGE_2_BUF1_TRF) && (BufferCommand != DB_PAGE_2_BUF2_TRF))
return AT91C_DATAFLASH_BAD_COMMAND;

/* no data to transmit or receive */
pDataFlash->pDataFlashDesc->tx_data_size = 0;
cmdsize = 4;
if (pDataFlash->pDevice->pages_number >= 16384)
cmdsize = 5;
return(AT91F_DataFlashSendCommand(pDataFlash, BufferCommand, cmdsize,
page*pDataFlash->pDevice->pages_size));
}

The above function is used to transfer data between the main memory and the
buffer. As the data is flushed or retrieved from the buffer in pages,
the only parameter required is the page
that is to be transferred. The data in the dataflash register block is




NEXT




<s> static void b53_srab_release_grant(struct b53_device *dev)
{
u8 __iomem *regs = dev->priv;
u32 ctrls;

ctrls = readl(regs + B53_SRAB_CTRLS);
ctrls &= ~B53_SRAB_CTRLS_RCAREQ;
writel(ctrls, regs + B53_SRAB_CTRLS);
}

The above function is used to release a grant before sending a DMA write command. The b53_srab_get_grant() function calls this to free a grant before sending a command to the B53 DDI

To re-enable the SRA




NEXT




<s> int rtcl_register_clkhw(int clk_idx)
{
int ret;
struct clk *clk;
struct clk_init_data hw_init = { };
struct rtcl_clk *rclk = &rtcl_ccu->clks[clk_idx];
struct clk_parent_data parent_data = { .fw_name = rtcl_clk_info[clk_idx].parent_name };

rclk->idx = clk_idx;
rclk->hw.init = &hw_init;

hw_init.num_parents = 1;
hw_init.ops = &rtcl_clk_ops;
hw_init.parent_data = &parent_data;
hw_init.name = rtcl_clk_info[clk_idx].name;

ret = of_clk_hw_register(rtcl_ccu->np, &rclk->hw);
if (ret)
return ret;

clk_hw_register_clkdev(&rclk->hw, rtcl_clk_info[clk_idx].name, NULL);

clk = clk_get(NULL, rtcl_clk_info[clk_idx].name);
rclk->startup = clk_get_rate(clk);
clk_put(clk);

switch (clk_idx) {
case CLK_CPU:
rclk->min = rtcl_round_set[rtcl_ccu->soc][clk_idx].min;
rclk->max = rtcl_round_set[rtcl_ccu->soc][clk_idx].max;
break;
default:
/*
* TODO: This driver supports PLL reclocking and nothing else. Additional
* required steps for non CPU PLLs are missing. E.g. if we want to change memory
* clocks the right way we must adapt a lot of other settings. This includes
* MCR and DTRx timing registers (0xb80001000, 0xb8001008, ...) and a DLL reset
* so that hardware operates in the allowed limits. This is far too complex
* without official support. Avoid this for now.
*/
rclk->min = rclk->max = rclk->startup;
break;
}

return 0;
}

The above function is used to register the clock hardware. However, it expects a set of values to determine the clock frequency range, which can be read from the clock_data[] structure.

Therefore, we will first create the above structure and then, fill it with




NEXT




<s> static void __init ws_ap3825i_setup_arch(void)
{
if (ppc_md.progress)
ppc_md.progress("ws_ap3825i_setup_arch()", 0);

mpc85xx_smp_init();

fsl_pci_assign_primary();

pr_info("WS-AP3825i board from Extreme Networks\n");
}

The above function is used to configure/initialize various
devices for initializing the system on the target board
at the time of power-on.</s>




NEXT




<s> static void sata_oxnas_post_reset_init(struct ata_port *ap);

static int sata_oxnas_acquire_hw(struct ata_port *ap, int may_sleep,
int timeout_jiffies);
static void sata_oxnas_release_hw(struct ata_port *ap);

static const void *HW_LOCKER_UID = (void *)0xdeadbeef;

/***************************************************************************
* ASIC access
***************************************************************************/
static void wait_cr_ack(void __iomem *phy_base)
{
while ((ioread32(phy_base + PHY_STAT) >> 16) & 0x1f)
; /* wait for an ack bit to be set */
}

The above function is used to test for the ack bit, it is a bit odd and may
need some clarification.
The address part of PHY_STAT is a read/write register, and is part of the
PHY_CFG register in the PHY




NEXT




<s> static inline int clk_on(struct dc_ep_dev *dev, u32 bits)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_clk_on(dev->priv, bits);
}

The above function is used to on the various clocks used in display controller. The clocks are turned on using dc_ep_clk_on that is part of the display controller private data structure.

static inline int clk_off(struct dc_ep_dev




NEXT




<s> static void aca_hif_param_init_done(struct dc_ep_priv *priv)
{
u32 addr;
struct aca_hif_params *hif_params = to_hif_params(priv);
struct aca_fw_param *fw_param = to_aca_fw_param(priv);

/* wr32(ACA_HIF_PARAM_ADDR, ACA_HIF_LOC_POS);*/
/* addr = rd32(ACA_HIF_LOC_POS);*/

addr = fw_param->init_addr;
dev_dbg(priv->dev, "init_addr: %x\n", addr);
memcpy_toio(priv->mem + addr, hif_params, sizeof(*hif_params));
kzfree(hif_params);
dev_dbg(priv->dev, "%s\n", __func__);
}

The above function is used to send the H16C ACA_EPOC_PARAM. This is
how the H16C ACA is notified of where the E2EEP will find the ACA_EPOC_PARAM.
The




NEXT




<s> store_link_val(struct nl_msg *msg, struct nlattr *nla, struct switch_val *val)
{
struct nlattr *tb[SWITCH_LINK_ATTR_MAX + 1];
struct switch_port_link *link;
int err = 0;

if (!val->value.link)
val->value.link = malloc(sizeof(struct switch_port_link));

err = nla_parse_nested(tb, SWITCH_LINK_ATTR_MAX, nla, link_policy);
if (err < 0)
goto out;

link = val->value.link;
link->link = !!tb[SWITCH_LINK_FLAG_LINK];
link->duplex = !!tb[SWITCH_LINK_FLAG_DUPLEX];
link->aneg = !!tb[SWITCH_LINK_FLAG_ANEG];
link->tx_flow = !!tb[SWITCH_LINK_FLAG_TX_FLOW];
link->rx_flow = !!tb[SWITCH_LINK_FLAG_RX_FLOW];
link->speed = nla_get_u32(tb[SWITCH_LINK_SPEED]);
link->eee = 0;
if (tb[SWITCH_LINK_FLAG_EEE_100BASET])
link->eee |= SWLIB_LINK_FLAG_EEE_100BASET;
if (tb[SWITCH_LINK_FLAG_EEE_1000BASET])
link->eee |= SWLIB_LINK_FLAG_EEE_1000BASET;

out:
return err;
}

The above function is used to populate a struct switch_port_link variable from a control message received from the controller. The function returns an int value indicating success. First the nla array is used to get a pointer to each element in the attribute list. Then a switch




NEXT




<s> static DSL_DEV_MeiError_t IFX_MEI_CpuModeSet (DSL_DEV_Device_t *, DSL_DEV_CpuMode_t);
static DSL_DEV_MeiError_t IFX_MEI_DownloadBootCode (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_ArcJtagEnable (DSL_DEV_Device_t *, int);
static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to access the data path on the AMAZON card.

The IFX_MEI_CpuModeSet function can be called on AMAZON card.
This function is to set up the operating frequency of cpu by the




NEXT




<s> ar8327_init_globals(struct ar8xxx_priv *priv)
{
struct ar8327_data *data = priv->chip_data;
u32 t;
int i;

/* enable CPU port and disable mirror port */
t = AR8327_FWD_CTRL0_CPU_PORT_EN |
AR8327_FWD_CTRL0_MIRROR_PORT;
ar8xxx_write(priv, AR8327_REG_FWD_CTRL0, t);

/* forward multicast and broadcast frames to CPU */
t = (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_UC_FLOOD_S) |
(AR8327_PORTS_ALL << AR8327_FWD_CTRL1_MC_FLOOD_S) |
(AR8327_PORTS_ALL << AR8327_FWD_CTRL1_BC_FLOOD_S);
ar8xxx_write(priv, AR8327_REG_FWD_CTRL1, t);

/* enable jumbo frames */
ar8xxx_rmw(priv, AR8327_REG_MAX_FRAME_SIZE,
AR8327_MAX_FRAME_SIZE_MTU, 9018 + 8 + 2);

/* Enable MIB counters */
ar8xxx_reg_set(priv, AR8327_REG_MODULE_EN,
AR8327_MODULE_EN_MIB);

/* Disable EEE on all phy's due to stability issues */
for (i = 0; i < AR8XXX_NUM_PHYS; i++)
data->eee[i] = false;
}

The above function is used to initialize the globals of the driver, specifically, for the AR8327 NIC. It can be broken down into the following four parts.</s>




NEXT




<s> instance_handle_sigchld(int sig)
{
int pid = 0;
wait(&pid);
child_pending = false;
}

The above function is used to handle signals generated from a child process exiting. Wait() is used to wait for the child to finish execution which generates SIGCHLD signal. When using a single pipe, do we need to write instance_handle_sigchld() at all




NEXT




<s> ret_t rtl8367c_setAsicMIBsLength(rtk_uint32 txLengthMode, rtk_uint32 rxLengthMode)
{
ret_t retVal;

if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_RMON_LEN_CTRL, RTL8367C_TX_LENGTH_CTRL_OFFSET, txLengthMode)) != RT_ERR_OK)
return retVal;

if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_RMON_LEN_CTRL, RTL8367C_RX_LENGTH_CTRL_OFFSET, rxLengthMode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read/write some of the MIB configuration registers as described in Figure 16.7. There are 4 main modes, 4 of which are read-only:
1) TX packet size, maximum is 1536




NEXT




<s> static void __exit dc_ep_exit(void)
{
pci_unregister_driver(&dc_ep_driver);

pr_info("%s: %s driver unloaded\n", __func__,
dc_ep_driver_name);
}

The above function is used to unregister
the driver as well as register device on the platform with given drivers
and device ids. For more details check the code.
Now, create an make file as

$ cat driver.mk

obj-m += p




NEXT




<s> static void rtl838x_enable_bcast_flood(int port, bool enable)
{

}

The above function is used to set broadcast flood of the selected port. The value parameter enable means to enable or disable broadcast flood.

By calling rtl8388_set_bcast_flood() function, we will make the above changes in the




NEXT




<s> static bool bcm4908img_is_all_ff(const void *buf, size_t length)
{
const uint8_t *in = buf;
int i;

for (i = 0; i < length; i++) {
if (in[i] != 0xff)
return false;
}

return true;
}

The above function is used to check if a buffer of images are all 'ff'.

I've tried to replicate this using a static buffer with no luck.
But when I use a malloc(), the function succeeds.

Why is there a difference




NEXT




<s> static int ip17xx_read_name(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
val->value.s = state->regs->NAME; // Just a const pointer, won't be freed by swconfig.
return 0;
}

The above function is used to print the switch-name of the specific switch that is plugged into the system
and I have found that this is the function that always returns 0 and hence printing the switch_name fails

But when i try to print the EE




NEXT




<s> ret_t rtl8367c_setAsicPortMirror(rtk_uint32 source, rtk_uint32 monitor)
{
ret_t retVal;

if((source > RTL8367C_PORTIDMAX) || (monitor > RTL8367C_PORTIDMAX))
return RT_ERR_PORT_ID;

retVal = rtl8367c_setAsicRegBits(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_SOURCE_PORT_MASK, source);
if(retVal != RT_ERR_OK)
return retVal;


return rtl8367c_setAsicRegBits(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_MONITOR_PORT_MASK, monitor);
}

The above function is used to configure Asic the RTL8367C_MIRROR_SOURCE_PORT_MASK and RTL8367C_MIRROR_MONITOR_PORT_MASK bits.

The RTL




NEXT




<s> BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)
{
BN_ULONG dh,dl,q,ret=0,th,tl,t;
int i,count=2;

if (d == 0) return(BN_MASK2);

i=BN_num_bits_word(d);
assert((i == BN_BITS2) || (h > (BN_ULONG)1<<i));

i=BN_BITS2-i;
if (h >= d) h-=d;

if (i)
{
d<<=i;
h=(h<<i)|(l>>(BN_BITS2-i));
l<<=i;
}
dh=(d&BN_MASK2h)>>BN_BITS4;
dl=(d&BN_MASK2l);
for (;;)
{
if ((h>>BN_BITS4) == dh)
q=BN_MASK2l;
else
q=h/dh;

th=q*dh;
tl=dl*q;
for (;;)
{
t=h-th;
if ((t&BN_MASK2h) ||
((tl) <= (
(t<<BN_BITS4)|
((l&BN_MASK2h)>>BN_BITS4))))
break;
q--;
th-=dh;
tl-=dl;
}
t=(tl>>BN_BITS4);
tl=(tl<<BN_BITS4)&BN_MASK2h;
th+=t;

if (l < tl) th++;
l-=tl;
if (h < th)
{
h+=d;
q--;
}
h-=th;

if (--count == 0) break;

ret=q<<BN_BITS4;
h=((h<<BN_BITS4)|(l>>BN_BITS4))&BN_MASK2;
l=(l&BN_MASK2l)<<BN_BITS4;
}
ret|=q;
return(ret);
}

The above function is used to test the bn_div function (which is part of the GCRY library). It would be interesting to see how efficient it is. The comments make it look like it should be pretty fast.

For comparison, see the C++




NEXT




<s> static ssize_t port_egress_rate_write(struct file *filp, const char __user *buffer,
size_t count, loff_t *ppos)
{
struct rtl838x_port *p = filp->private_data;
struct dsa_switch *ds = p->dp->ds;
struct rtl838x_switch_priv *priv = ds->priv;
u32 value;
size_t res = rtl838x_common_write(buffer, count, ppos, &value);
if (res < 0)
return res;

if (priv->family_id == RTL8380_FAMILY_ID)
rtl838x_set_egress_rate(priv, p->dp->index, value);
else
rtl839x_set_egress_rate(priv, p->dp->index, value);

return res;
}

The above function is used to set the egress rate using u32 value.The input parameter 'priv' is a pointer points to the 'struct rtl838x_switch_priv' structure, which will be used to identify the chip. For RTL




NEXT




<s> static int lq_des_encrypt(struct ablkcipher_request *areq)
{
struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);
struct des_ctx *ctx = crypto_ablkcipher_ctx(cipher);

return lq_queue_mgr(ctx, areq, NULL, CRYPTO_DIR_ENCRYPT, 5);

}

The above function is used to encrypt the request.

## Answer 1, Authority 100%

The lq_des_encrypt function is used to encrypt the request. It uses the lq_queue_mgr function to get the




NEXT




<s> read_jimage_header(struct mtd_info *mtd, size_t offset, u_char *buf,
size_t header_len)
{
size_t retlen;
int ret;

ret = mtd_read(mtd, offset, header_len, &retlen, buf);
if (ret) {
pr_debug("read error in \"%s\"\n", mtd->name);
return ret;
}

if (retlen != header_len) {
pr_debug("short read in \"%s\"\n", mtd->name);
return -EIO;
}

return 0;
}

The above function is used to read the image header. This code is called from
the init_mtd() routine and is passed 3 parameters:

struct mtd_info *mtd
the struct mtd_info that holds all the info for this





NEXT




<s> static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;

/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
static const char *const yytname[] =
{
"\"end of file\"", "error", "\"invalid token\"", "T_HELPTEXT", "T_WORD",
"T_WORD_QUOTE", "T_BOOL", "T_CHOICE", "T_CLOSE_PAREN", "T_COLON_EQUAL",
"T_COMMENT", "T_CONFIG", "T_DEFAULT", "T_DEF_BOOL", "T_DEF_TRISTATE",
"T_DEPENDS", "T_ENDCHOICE", "T_ENDIF", "T_ENDMENU", "T_HELP", "T_HEX",
"T_IF", "T_IMPLY", "T_INT", "T_MAINMENU", "T_MENU", "T_MENUCONFIG",
"T_MODULES", "T_ON", "T_OPEN_PAREN", "T_OPTIONAL", "T_PLUS_EQUAL",
"T_PROMPT", "T_RANGE", "T_RESET", "T_SELECT", "T_SOURCE", "T_STRING",
"T_TRISTATE", "T_VISIBLE", "T_EOL", "T_ASSIGN_VAL", "T_OR", "T_AND",
"T_EQUAL", "T_UNEQUAL", "T_LESS", "T_LESS_EQUAL", "T_GREATER",
"T_GREATER_EQUAL", "T_NOT", "$accept", "input", "mainmenu_stmt",
"stmt_list", "stmt_list_in_choice", "config_entry_start", "config_stmt",
"menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
"config_option", "choice", "choice_entry", "choice_end", "choice_stmt",
"choice_option_list", "choice_option", "type", "logic_type", "default",
"if_entry", "if_end", "if_stmt", "if_stmt_in_choice", "menu",
"menu_entry", "menu_end", "menu_stmt", "menu_option_list", "source_stmt",
"comment", "comment_stmt", "comment_option_list", "help_start", "help",
"depends", "visible", "prompt_stmt_opt", "end", "if_expr", "expr",
"nonconst_symbol", "symbol", "word_opt", "assignment_stmt", "assign_op",
"assign_val", YY_NULLPTR
};

The above function is used to translate a yysymbol_kind_t value to a string. The function and the array above are usually placed at the end of a file and are usually called "TAB". The function and array are used as a lookup table of string-




NEXT




<s> static int ip17xx_get_port_speed(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int nr = val->port_vlan;
int speed, status;

if (nr == state->regs->CPU_PORT) {
val->value.i = 100;
return 0;
}

if (nr >= dev->ports || nr < 0)
return -EINVAL;

status = ip_phy_read(state, nr, 1);
speed = ip_phy_read(state, nr, 18);
if (status < 0 || speed < 0)
return -EIO;

if (status & 4)
val->value.i = ((speed & (1<<11)) ? 100 : 10);
else
val->value.i = 0;

return 0;
}

The above function is used to report port speed and duc the status, however, there are not some case:</s>




NEXT




<s> void ifxdeu_fini_arc4(void)
{
crypto_unregister_alg (&ifxdeu_arc4_alg);
crypto_unregister_skcipher (&ifxdeu_ecb_arc4_alg);


}

The above function is used to clean the code and remove any entries that we
have made.

<ul>
<li>
crypto_unregister_alg (&ifxdeu_arc4_alg);
</li>
<li>
crypto_




NEXT




<s> static int rtl838x_pie_rule_read(struct rtl838x_switch_priv *priv, int idx, struct  pie_rule *pr)
{
/* Read IACL table (1) via register 0 */
struct table_reg *q = rtl_table_get(RTL8380_TBL_0, 1);
u32 r[18];
int block = idx / PIE_BLOCK_SIZE;
u32 t_select = sw_r32(RTL838X_ACL_BLK_TMPLTE_CTRL(block));

memset(pr, 0, sizeof(*pr));
rtl_table_read(q, idx);
for (int i = 0; i < 18; i++)
r[i] = sw_r32(rtl_table_data(q, i));

rtl_table_release(q);

rtl838x_read_pie_fixed_fields(r, pr);
if (!pr->valid)
return 0;

pr_info("%s: template_selectors %08x, tid: %d\n", __func__, t_select, pr->tid);
rtl838x_pie_rule_dump_raw(r);

rtl838x_read_pie_templated(r, pr, fixed_templates[(t_select >> (pr->tid * 3)) & 0x7]);

rtl838x_read_pie_action(r, pr);

return 0;
}

The above function is used to read out a PIE rule (14 fields) which is stored in IACL-0_t[0], IACL-1_t[0],.., IACL-7_t[0] registers of So




NEXT




<s> static irqreturn_t rttm_timer_interrupt(int irq, void *dev_id)
{
struct clock_event_device *clkevt = dev_id;
struct timer_of *to = to_timer_of(clkevt);

rttm_ack_irq(to->of_base.base);
RTTM_DEBUG(to->of_base.base);
clkevt->event_handler(clkevt);

return IRQ_HANDLED;
}

The above function is used to handle RT clocks interrupt from clock event device.</s>




NEXT




<s> void ifxdeu_fini_des (void)
{
crypto_unregister_alg (&ifxdeu_des_alg);
crypto_unregister_skcipher (&ifxdeu_ecb_des_alg);
crypto_unregister_skcipher (&ifxdeu_cbc_des_alg);
crypto_unregister_alg (&ifxdeu_des3_ede_alg);
crypto_unregister_skcipher (&ifxdeu_ecb_des3_ede_alg);
crypto_unregister_skcipher (&ifxdeu_cbc_des3_ede_alg);

}

The above function is used to undo the function of “ifxdeu_fini_des” and “ifxdeu_fini_des3_ede”</s>




NEXT




<s> static void pm_channel_counters_total(int fd, DSL_XTUDir_t direction) {
IOCTL_DIR(DSL_PM_ChannelCountersTotal_t, DSL_FIO_PM_CHANNEL_COUNTERS_TOTAL_GET, direction);

m_u32("cv_c", out.data.nCodeViolations);
m_u32("fec_c", out.data.nFEC);
}

The above function is used to request PM counters from DSP. In case you are getting errors, make sure you are using the correct fd number and direction. See the following functions for more details.

IOCTL_FUNC(DSL_FIO_GetFD




NEXT




<s> static bool remap_block_bbt(u16 block, u16 mapped_blk, int copy_len)
{
int start, end;
u16 new_blk;

if (!mapping_block_in_range(block, &start, &end))
return false;

bbt_set_block_state(mapped_blk, true);

new_blk = get_mapping_block_index_bbt(block);
bbt_nand_erase(new_blk);
if (copy_len > 0)
bbt_nand_copy(new_blk, mapped_blk, copy_len);

return true;
}

The above function is used to re-map a block from source block to a
destination block. Destination block will keep all the blocks states.

static void remap_block(struct nand_chip *chip, uint64_t block,
uint




NEXT




<s> static ssize_t read_file_tx_ring(struct file *file, char __user *user_buf,
size_t count, loff_t *ppos)
{
struct ag71xx *ag = file->private_data;

return read_file_ring(file, user_buf, count, ppos, ag, &ag->tx_ring,
AG71XX_REG_TX_DESC);
}

The above function is used to read the tx_ring to user space for debugging.

In ag71xx_debugfs_create_file_tx_ring, the function
read_file_tx_ring is registered to the sysfs file handler





NEXT




<s> void SHA1Update(SHA1_CTX* context, const unsigned char* data, unsigned int len)
{
unsigned int i, j;

j = (context->count[0] >> 3) & 63;
if ((context->count[0] += len << 3) < (len << 3)) context->count[1]++;
context->count[1] += (len >> 29);
if ((j + len) > 63) {
memcpy(&context->buffer[j], data, (i = 64-j));
SHA1Transform(context->state, context->buffer);
for ( ; i + 63 < len; i += 64) {
SHA1Transform(context->state, &data[i]);
}
j = 0;
}
else i = 0;
memcpy(&context->buffer[j], &data[i], len - i);
}

The above function is used to update the SHA1_CTX (the state and buffer of the hash function from the link) with the new data.

So we can see that the padding is added by using the context->count[] and the buffer.

So,




NEXT




<s> static void bcm6368_enetsw_refill_rx_timer(struct timer_list *t)
{
struct bcm6368_enetsw *priv = from_timer(priv, t, rx_timeout);
struct net_device *ndev = priv->net_dev;

spin_lock(&priv->rx_lock);
bcm6368_enetsw_refill_rx(ndev, false);
spin_unlock(&priv->rx_lock);
}

The above function is used to refill RX descriptors in case of no RX packets are received. You can check the above code with your kernel source. The bcm6368_enetsw_refill_rx() function also prints out its reason




NEXT




<s> static void msdc_pm(pm_message_t state, void *data)
{
struct msdc_host *host = (struct msdc_host *)data;
int evt = state.event;

if (evt == PM_EVENT_USER_RESUME || evt == PM_EVENT_USER_SUSPEND) {
INIT_MSG("USR_%s: suspend<%d> power<%d>",
evt == PM_EVENT_USER_RESUME ? "EVENT_USER_RESUME" : "EVENT_USER_SUSPEND",
host->suspend, host->power_mode);
}

if (evt == PM_EVENT_SUSPEND || evt == PM_EVENT_USER_SUSPEND) {
if (host->suspend) /* already suspend */  /* default 0*/
return;

/* for memory card. already power off by mmc */
if (evt == PM_EVENT_SUSPEND && host->power_mode == MMC_POWER_OFF)
return;

host->suspend = 1;
host->pm_state = state;  /* default PMSG_RESUME */

} else if (evt == PM_EVENT_RESUME || evt == PM_EVENT_USER_RESUME) {
if (!host->suspend) {
//ERR_MSG("warning: already resume");
return;
}

/* No PM resume when USR suspend */
if (evt == PM_EVENT_RESUME && host->pm_state.event == PM_EVENT_USER_SUSPEND) {
ERR_MSG("PM Resume when in USR Suspend");		/* won't happen. */
return;
}

host->suspend = 0;
host->pm_state = state;

}
}

The above function is used to initialize the main MSDC host driver. The following table shows the relationship between the state value variable and the main function of the MSDC host driver for each power management mode.

State      Description
-------------------    -------------------------------------------------------




NEXT




<s> static ssize_t swconfig_trig_mode_store(struct device *dev,
struct device_attribute *attr, const char *buf, size_t size)
{
struct led_classdev *led_cdev = dev_get_drvdata(dev);
struct swconfig_trig_data *trig_data = led_cdev->trigger_data;
char copybuf[128];
int new_mode = -1;
char *p, *token;

/* take a copy since we don't want to trash the inbound buffer when using strsep */
strncpy(copybuf, buf, sizeof(copybuf));
copybuf[sizeof(copybuf) - 1] = 0;
p = copybuf;

while ((token = strsep(&p, " \t\n")) != NULL) {
if (!*token)
continue;

if (new_mode < 0)
new_mode = 0;

if (!strcmp(token, "none"))
new_mode = 0;
else if (!strcmp(token, "tx"))
new_mode |= SWCONFIG_LED_MODE_TX;
else if (!strcmp(token, "rx"))
new_mode |= SWCONFIG_LED_MODE_RX;
else if (!strcmp(token, "link"))
new_mode |= SWCONFIG_LED_MODE_LINK;
else
return -EINVAL;
}

if (new_mode < 0)
return -EINVAL;

write_lock(&trig_data->lock);
trig_data->mode = (u8)new_mode;
write_unlock(&trig_data->lock);

return size;
}

The above function is used to change the mode by which the LED driver
responds to the events raised by the SWCONFIG application. These events are
transmitted as ascii values and must be matched with the correct value to
determine the event. Each time the




NEXT




<s> static void b53_enable_mib(struct b53_device *dev)
{
u8 gc;

b53_read8(dev, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, &gc);

gc &= ~(GC_RESET_MIB | GC_MIB_AC_EN);

b53_write8(dev, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, gc);
}

The above function is used to enable the MIB for a B53 switch chip</s>




NEXT




<s> void conf_set_changed_callback(void (*fn)(void))
{
conf_changed_callback = fn;
}

The above function is used to register a user defined callback which is trigerred on any change in the configuration settings.

Since conf.c is the module which handles all the configuration related functions, it is also notified whenever there is a change. So, this function




NEXT




<s> ret_t rtl8367c_setAsicVlanUntagDscpPriorityEn(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_UNTAG_DSCP_PRI_CFG, RTL8367C_UNTAG_DSCP_PRI_CFG_OFFSET, enabled);
}

The above function is used to enable/disable untag VLAN untag DSCP priority mapping. For instance, once enable it, the DSCP value of a VLAN packet will be set to the corresponding setting in the priority table (the priority table is defined to




NEXT




<s> rtk_api_ret_t  rtk_oam_multiplexerAction_set(rtk_port_t port, rtk_oam_multiplexer_act_t action)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (action >= OAM_MULTIPLEXER_ACTION_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicOamMultiplexer(rtk_switch_port_L2P_get(port), action))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set multiplexer action on specified Port.</s>




NEXT




<s> static int rtl930x_mdio_write(struct mii_bus *bus, int mii_id,
int regnum, u16 value)
{
return rtl930x_mdio_write_paged(bus, mii_id, 0, regnum, value);
}

The above function is used to write MII register in both PHY mode and
Paged Mode. For Paged Mode, the rtl930x chipset needs to write
PMAP register and PAREG register for paged mode to switch
between page mode




NEXT




<s> static int rtl8367b_sw_reset_mibs(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

return rtl8366_smi_rmwr(smi, RTL8367B_MIB_CTRL0_REG(0), 0,
RTL8367B_MIB_CTRL0_GLOBAL_RESET_MASK);
}

The above function is used to reset MIBs of certain SMI.
How MIB in switch is defined?

The SW switch MIB are in a similar structure with other chipset MIBs,
and are managed by this subsystem. It means those




NEXT




<s> ret_t rtl8367c_setAsicRldpCheckingStatePara(rtk_uint32 retryCount, rtk_uint32 retryPeriod)
{
ret_t retVal;

if(retryCount > 0xFF)
return RT_ERR_OUT_OF_RANGE;
if(retryPeriod > RTL8367C_REGDATAMAX)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_RLDP_RETRY_COUNT_REG, RTL8367C_RLDP_RETRY_COUNT_CHKSTATE_MASK, retryCount);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_setAsicReg(RTL8367C_RLDP_RETRY_PERIOD_CHKSTATE_REG, retryPeriod);
}

The above function is used to configure asic to check and report whether a specific rldp path is connected or not.

If one would like to have the rldp path for a specific port to report the link state, the user should use rtl83




NEXT




<s> static int __init mt7621_qtn_rgmii_init(void)
{
void __iomem *base = ioremap(RGMII_REG_BASE, RGMII_REG_SIZE);

if (!base)
return -ENOMEM;
oldval = ioread32(base);
if (oldval != RGMII_REG_VALUE) {
iowrite32(RGMII_REG_VALUE, base);
pr_info(MODULE_NAME ": changed register 0x%08x value from 0x%08x to 0x%08x\n", RGMII_REG_BASE, oldval,  RGMII_REG_VALUE);
}
iounmap(base);
return 0;
}

The above function is used to modify a system memory address stored at RGMII_REG_BASE as below.

#define RGMII_REG_BASE 0xc801000c
#define RGMII_REG_SIZE 0




NEXT




<s> adm6996_get_addr(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);

val->value.i = priv->addr;

return 0;
};

The above function is used to get an attribute value that is
"phys.addr", which will be used to pass as "reg_addr1" parameter
of the command "adm6996_phy_read".

As an example, the below




NEXT




<s> int mt7620_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 val)
{
struct fe_priv *priv = bus->priv;
struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;

return _mt7620_mii_write(gsw, phy_addr, phy_reg, val);
}

The above function is used to write to a register in the PHY devices on the MT7621A SOC. It calls mt7620_mdio_write in the mt7621 chip driver, and subsequently calls _mt762




NEXT




<s> static int __init trelay_init(void)
{
int ret;

debugfs_dir = debugfs_create_dir("trelay", NULL);
if (!debugfs_dir)
return -ENOMEM;

debugfs_create_file("add", S_IWUSR, debugfs_dir, NULL, &fops_add);

ret = register_netdevice_notifier(&tr_dev_notifier);
if (ret < 0)
goto error;

return 0;

error:
debugfs_remove_recursive(debugfs_dir);
return ret;
}

The above function is used to initialize the TRELAY functionality when the kernel is getting initialized. The above function creates a directory called ‘debugfs’ under which a file called ‘add’ will be created after initializing it. Then it registers the device notifier using the function




NEXT




<s> rtk_api_ret_t rtk_oam_state_set(rtk_enable_t enabled)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (enabled >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicOamEnable(enabled))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the oam state.

rtk_api_ret_t rtk_oam_state_get(rtk_enable_t *enabled)
{
rtk_api_ret_t retVal;





NEXT




<s> ret_t rtl8367c_getAsicMaxPulbicPage(rtk_uint32 *pPageCount)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PUBLIC_PAGE_MAX, RTL8367C_FLOWCTRL_PUBLIC_PAGE_MAX_MASK, pPageCount);
}

The above function is used to get the max no of public page used with RTL8367C switch.

This is one of the first step that a user need to look into, before configuring the hardware. We have mentioned many places in this article that




NEXT




<s> adm6996_enable_vlan_6996l(struct adm6996_priv *priv)
{
u16 reg;

reg = r16(priv, ADM_SYSC3);
reg |= ADM_TBV;
reg |= ADM_MAC_CLONE;
w16(priv, ADM_SYSC3, reg);
}

The above function is used to enable VLAN for 6996L network Adapter to create multiple virtual network cards. The function will set ADM_MAC_CLONE=1 (bit(11)) in ADM_SYSC3 register, and set




NEXT




<s> ar8xxx_mib_work_func(struct work_struct *work)
{
struct ar8xxx_priv *priv;
int err, i;

priv = container_of(work, struct ar8xxx_priv, mib_work.work);

mutex_lock(&priv->mib_lock);

err = ar8xxx_mib_capture(priv);
if (err)
goto next_attempt;

for (i = 0; i < priv->dev.ports; i++)
ar8xxx_mib_fetch_port_stat(priv, i, false);

next_attempt:
mutex_unlock(&priv->mib_lock);
schedule_delayed_work(&priv->mib_work,
msecs_to_jiffies(priv->mib_poll_interval));
}

The above function is used to poll the mib data from the adapter periodically.
And the periodic interval is defined in the global work structure variable
mib_poll_interval in struct ar8xxx_priv type.

struct ar8xxx_priv mib




NEXT




<s> ret_t rtl8367c_getAsicIGMPGroup(rtk_uint32 idx, rtk_uint32 *valid, rtl8367c_igmpgroup *grp)
{
ret_t   retVal;
rtk_uint32  regAddr, regData;
rtk_uint32  i;
rtk_uint32  groupInfo = 0;

if(idx > RTL8367C_IGMP_MAX_GOUP)
return RT_ERR_OUT_OF_RANGE;

/* Write ACS_ADR register for data bits */
regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
regData = idx;
retVal = rtl8367c_setAsicReg(regAddr, regData);
if(retVal != RT_ERR_OK)
return retVal;

/* Write ACS_CMD register */
regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_READ, TB_TARGET_IGMP_GROUP);
retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK, regData);
if(retVal != RT_ERR_OK)
return retVal;

/* Read Data Bits */
regAddr = RTL8367C_TABLE_ACCESS_RDDATA_BASE;
for(i = 0 ;i <= 1; i++)
{
retVal = rtl8367c_getAsicReg(regAddr, &regData);
if(retVal != RT_ERR_OK)
return retVal;

groupInfo |= ((regData & 0xFFFF) << (i * 16));
regAddr ++;
}

grp->p0_timer = groupInfo & 0x00000007;
grp->p1_timer = (groupInfo >> 3) & 0x00000007;
grp->p2_timer = (groupInfo >> 6) & 0x00000007;
grp->p3_timer = (groupInfo >> 9) & 0x00000007;
grp->p4_timer = (groupInfo >> 12) & 0x00000007;
grp->p5_timer = (groupInfo >> 15) & 0x00000007;
grp->p6_timer = (groupInfo >> 18) & 0x00000007;
grp->p7_timer = (groupInfo >> 21) & 0x00000007;
grp->report_supp_flag = (groupInfo >> 24) & 0x00000001;
grp->p8_timer = (groupInfo >> 25) & 0x00000007;
grp->p9_timer = (groupInfo >> 28) & 0x00000007;
grp->p10_timer = (groupInfo >> 31) & 0x00000001;

regAddr = RTL8367C_TABLE_ACCESS_RDDATA_BASE + 2;
retVal = rtl8367c_getAsicReg(regAddr, &regData);
if(retVal != RT_ERR_OK)
return retVal;

grp->p10_timer |= (regData & 0x00000003) << 1;

/* Valid bit */
retVal = rtl8367c_getAsicReg(RTL8367C_IGMP_GROUP_USAGE_REG(idx), &regData);
if(retVal != RT_ERR_OK)
return retVal;

*valid = ((regData & (0x0001 << (idx %16))) != 0) ? 1 : 0;

return RT_ERR_OK;
}

The above function is used to get the timer information and valid bit of an igmp group.</s>




NEXT




<s> irqreturn_t rtl931x_switch_irq(int irq, void *dev_id)
{
struct dsa_switch *ds = dev_id;
u32 status = sw_r32(RTL931X_ISR_GLB_SRC);
u64 ports = rtl839x_get_port_reg_le(RTL931X_ISR_PORT_LINK_STS_CHG);
u64 link;

/* Clear status */
rtl839x_set_port_reg_le(ports, RTL931X_ISR_PORT_LINK_STS_CHG);
pr_debug("RTL931X Link change: status: %x, ports %016llx\n", status, ports);

link = rtl839x_get_port_reg_le(RTL931X_MAC_LINK_STS);
/* Must re-read this to get correct status */
link = rtl839x_get_port_reg_le(RTL931X_MAC_LINK_STS);
pr_debug("RTL931X Link change: status: %x, link status %016llx\n", status, link);

for (int i = 0; i < 56; i++) {
if (ports & BIT_ULL(i)) {
if (link & BIT_ULL(i)) {
pr_info("%s port %d up\n", __func__, i);
dsa_port_phylink_mac_change(ds, i, true);
} else {
pr_info("%s port %d down\n", __func__, i);
dsa_port_phylink_mac_change(ds, i, false);
}
}
}

return IRQ_HANDLED;
}

The above function is used to handle the interrupt from RGMII to trigger a link up.
It will search the first port which does not have a link and has a RGMII link up.
If all ports have links, function will terminate without doing anything.




NEXT




<s> void rtl838x_egress_rate_queue_limit(struct rtl838x_switch_priv *priv, int port,
int queue, u32 rate)
{
if (port > priv->cpu_port)
return;

if (queue > 7)
return;

sw_w32(rate, RTL838X_SCHED_Q_EGR_RATE_CTRL(port, queue));
}

The above function is used to update the transmission limit on a per- queue
basis. The limitation of this function is that we had to choose between the queue
number and the port. But I want to have a function that allows me to change
the limit for a




NEXT




<s> ret_t rtl8367c_getAsicMacAddress(ether_addr_t *pMac)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint8 *accessPtr;
rtk_uint32 i;


accessPtr = (rtk_uint8*)pMac;

for(i = 0; i <= 2; i++)
{
retVal = rtl8367c_getAsicReg(RTL8367C_REG_SWITCH_MAC2 - i, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*accessPtr = (regData & 0xFF00) >> 8;
accessPtr ++;
*accessPtr = regData & 0xFF;
accessPtr ++;
}

return retVal;
}

The above function is used to retrieve the register content from CPU memory.
The following is the code which retrieves the register content on CPU and prints it out.
#include <stdio.h>
#include <stdint.h>
#include <driver




NEXT




<s> void rtl9300_do_rx_calibration_4_2(u32 sds_num)
{
u32 vth_list[2];
u32 tap_list[4];

pr_info("start_1.4.2");

rtl9300_sds_rxcal_vth_get(sds_num, vth_list);
rtl9300_sds_rxcal_vth_manual(sds_num, true, vth_list);

mdelay(100);

rtl9300_sds_rxcal_tap_get(sds_num, 0, tap_list);
rtl9300_sds_rxcal_tap_manual(sds_num, 0, true, tap_list);

pr_info("end_1.4.2");
}

The above function is used to calibrate VTH & TAP setting, for RX chain 0 & 1 respectively.

void rtl9300_do_rx_calibration_4_3(u32 sds_num)




NEXT




<s> static void rtl9300_i2c_config_io(struct rtl9300_i2c *i2c, int scl_num, int sda_num)
{
u32 v;

/* Set SCL pin */
REG_MASK(i2c, 0, BIT(RTL9300_I2C_CTRL1_GPIO8_SCL_SEL), RTL9300_I2C_CTRL1);

/* Set SDA pin */
REG_MASK(i2c, 0x7 << RTL9300_I2C_CTRL1_SDA_OUT_SEL,
i2c->sda_num << RTL9300_I2C_CTRL1_SDA_OUT_SEL, RTL9300_I2C_CTRL1);

/* Set SDA pin to I2C functionality */
v = readl(i2c->base + RTL9300_I2C_MST_GLB_CTRL);
v |= BIT(i2c->sda_num);
writel(v, i2c->base + RTL9300_I2C_MST_GLB_CTRL);
}

The above function is used to configure I2C peripheral when loading
i2c_rtl9300.ko. In above code, the variable "i2c->sda_num" is to
identify SDA pin.

However




NEXT




<s> static void rtl838x_set_egr_filter(int port, enum egr_filter state)
{
sw_w32_mask(0x1 << (port % 0x1d), state << (port % 0x1d),
RTL838X_VLAN_PORT_EGR_FLTR + (((port / 29) << 2)));
}

The above function is used to enable or disable egress filter, there is a comment in the source code, it suggest to enable 1~0xd filters by default. So, when you enable 0x1d ~ 0x1d+28 filters,




NEXT




<s> bool expr_depends_symbol(struct expr *dep, struct symbol *sym)
{
if (!dep)
return false;

switch (dep->type) {
case E_AND:
return expr_depends_symbol(dep->left.expr, sym) ||
expr_depends_symbol(dep->right.expr, sym);
case E_SYMBOL:
return dep->left.sym == sym;
case E_EQUAL:
if (dep->left.sym == sym) {
if (dep->right.sym == &symbol_yes || dep->right.sym == &symbol_mod)
return true;
}
break;
case E_UNEQUAL:
if (dep->left.sym == sym) {
if (dep->right.sym == &symbol_no)
return true;
}
break;
default:
;
}
return false;
}

The above function is used to determine whether a dependency is present for a given
symbol. The code is a bit involved, so let’s go over it a bit manually. The
type for a dependency is E_AND, and it checks both its left and right operand




NEXT




<s> u32 rtl9300_sds_rxcal_gray_to_binary(u32 gray_code)
{
int i, j, m;
u32 g[GRAY_BITS];
u32 c[GRAY_BITS];
u32 leq_binary = 0;

for(i = 0; i < GRAY_BITS; i++)
g[i] = (gray_code & BIT(i)) >> i;

m = GRAY_BITS - 1;

c[m] = g[m];

for(i = 0; i < m; i++) {
c[i] = g[i];
for(j  = i + 1; j < GRAY_BITS; j++)
c[i] = c[i] ^ g[j];
}

for(i = 0; i < GRAY_BITS; i++)
leq_binary += c[i] << i;

return leq_binary;
}

The above function is used to convert 8 bit Gray code to binary. The 8 bit Gray code looks like this

Where g[0 to 7] is the binary digit 0 or 1 in the Gray Code Bit. The code for 8 bit gray




NEXT




<s> ar8327_sw_set_igmp_snooping(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
int port;

for (port = 0; port < dev->ports; port++) {
val->port_vlan = port;
if (ar8327_sw_set_port_igmp_snooping(dev, attr, val))
break;
}

return 0;
}

The above function is used to set multicast forwarding state of ports
of all VLANs.
In the function of ar8327_sw_set_igmp_snooping, if there is an error ar8327_sw




NEXT




<s> static void rtl930x_set_l3_nexthop(int idx, u16 dmac_id, u16 interface)
{
/* Access L3_NEXTHOP table (3) via register RTL9300_TBL_1 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_1, 3);

pr_info("%s: Writing to L3_NEXTHOP table, index %d, dmac_id %d, interface %d\n",
__func__, idx, dmac_id, interface);
sw_w32(((dmac_id & 0x7fff) << 7) | (interface & 0x7f), rtl_table_data(r, 0));

pr_info("%s: %08x\n", __func__, sw_r32(rtl_table_data(r,0)));
rtl_table_write(r, idx);
rtl_table_release(r);
}

The above function is used to write data to the L3_NEIGHTHOP table
via register RTL9300_TBL_1, which can only be written by
sw_w32/sw_r32 when using the L3




NEXT




<s> static void rtl839x_write_scheduling_table(int port)
{
u32 cmd = 1 << 9 | /* Execute cmd */
1 << 8 | /* Write */
0 << 6 | /* Table type 0b00 */
(port & 0x3f);
rtl839x_exec_tbl2_cmd(cmd);
}

The above function is used to write the port related information to the scheduling table. The function called before it sets 1 << 9 to perform the scheduling table command execution. By that way we can write values to the scheduling tables. The scheduling table is 




NEXT




<s> void set_dialog_subtitles(struct subtitle_list *subtitles)
{
dlg.subtitles = subtitles;
}

The above function is used to set the video subtitle list for the dialog box, which can
only be populated by a user, with the subtitle viewer, before it is closed and the dialog
displayed. However, this is a terrible choice, since the




NEXT




<s> void ifx_pp32_stop(int pp32)
{
unsigned int mask = 1 << (pp32 << 4);

/*  halt PP32   */
IFX_REG_W32_MASK(0, mask, PP32_FREEZE);
}

The above function is used to stop PP32 on all TAPA T-DM10G chips, and can be used to stop the
PP32 on all R21.6 and T-DM9870 chips.
However, it does




NEXT




<s> static int rtl8231_gpio_probe(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct device_node *np = dev->of_node;
struct rtl8231_gpios *gpios;
int err;

pr_info("Probing RTL8231 GPIOs\n");

if (!np) {
dev_err(&pdev->dev, "No DT found\n");
return -EINVAL;
}

gpios = devm_kzalloc(dev, sizeof(*gpios), GFP_KERNEL);
if (!gpios)
return -ENOMEM;

gpios->id = soc_info.id;
if (soc_info.family == RTL8380_FAMILY_ID) {
gpios->ext_gpio_indrt_access = RTL838X_EXT_GPIO_INDRT_ACCESS;
}

if (soc_info.family == RTL8390_FAMILY_ID) {
gpios->ext_gpio_indrt_access = RTL839X_EXT_GPIO_INDRT_ACCESS;
}

err = of_property_read_u32(np, "indirect-access-bus-id", &gpios->smi_bus_id);
if (!err && gpios->smi_bus_id > RTL8231_SMI_BUS_ID_MAX)
err = -EINVAL;

if (err) {
dev_err(dev, "invalid or missing indirect-access-bus-id\n");
return err;
}

err = rtl8231_init(gpios);
if (err) {
dev_err(dev, "no device found at bus address %d\n", gpios->smi_bus_id);
return err;
}

gpios->dev = dev;
gpios->gc.base = -1;
gpios->gc.ngpio = 37;
gpios->gc.label = "rtl8231";
gpios->gc.parent = dev;
gpios->gc.owner = THIS_MODULE;
gpios->gc.can_sleep = true;

gpios->gc.direction_input = rtl8231_direction_input;
gpios->gc.direction_output = rtl8231_direction_output;
gpios->gc.set = rtl8231_gpio_set;
gpios->gc.get = rtl8231_gpio_get;
gpios->gc.get_direction = rtl8231_get_direction;

return devm_gpiochip_add_data(dev, &gpios->gc, gpios);
}

The above function is used to probe RTL8231 GPIOs, and it is responsible for initializing GPIOs and registering them with GPIOLib.The RTL8231 GPIO driver contains two sections, the first section is the probe function,




NEXT




<s> static int ltq_deu_probe(struct platform_device *pdev)
{
int ret = -ENOSYS;


START_DEU_POWER;
CRTCL_SECT_HASH_INIT;

#define IFX_DEU_DRV_VERSION         "2.0.0"
printk(KERN_INFO "Infineon Technologies DEU driver version %s \n", IFX_DEU_DRV_VERSION);

FIND_DEU_CHIP_VERSION;

#if defined(CONFIG_CRYPTO_DEV_DES)
if ((ret = ifxdeu_init_des ())) {
printk (KERN_ERR "IFX DES initialization failed!\n");
}
#endif
#if defined(CONFIG_CRYPTO_DEV_AES)
if ((ret = ifxdeu_init_aes ())) {
printk (KERN_ERR "IFX AES initialization failed!\n");
}

#endif
#if defined(CONFIG_CRYPTO_DEV_ARC4)
if ((ret = ifxdeu_init_arc4 ())) {
printk (KERN_ERR "IFX ARC4 initialization failed!\n");
}

#endif
#if defined(CONFIG_CRYPTO_DEV_SHA1)
if ((ret = ifxdeu_init_sha1 ())) {
printk (KERN_ERR "IFX SHA1 initialization failed!\n");
}
#endif
#if defined(CONFIG_CRYPTO_DEV_MD5)
if ((ret = ifxdeu_init_md5 ())) {
printk (KERN_ERR "IFX MD5 initialization failed!\n");
}

#endif
#if defined(CONFIG_CRYPTO_DEV_SHA1_HMAC)
if ((ret = ifxdeu_init_sha1_hmac ())) {
printk (KERN_ERR "IFX SHA1_HMAC initialization failed!\n");
}
#endif
#if defined(CONFIG_CRYPTO_DEV_MD5_HMAC)
if ((ret = ifxdeu_init_md5_hmac ())) {
printk (KERN_ERR "IFX MD5_HMAC initialization failed!\n");
}
#endif



return ret;

}

The above function is used to probe the device through which the cryptographic primitives is accessible by the kernel. We’ll go through all the major steps listed in the above function in detail.

STARt DEU_Power: This is a macro call used




NEXT




<s> ret_t rtl8367c_getAsicMLDv2Opeartion(rtk_uint32 port, rtk_uint32 *mldv2_op)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

/* MLDv2 operation */
if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_MLDv2_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_MLDv2_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}

*mldv2_op = value;

return RT_ERR_OK;
}

The above function is used to get MLD v2 operation.


// rtl8367c_getAsicMLDv2Opeartion: Function Definition
// =====================================================
// =
//   Set MLD v




NEXT




<s> uc_bpf_map_set(uc_vm_t *vm, size_t nargs)
{
struct uc_bpf_map *map = uc_fn_thisval("bpf.map");
uc_value_t *a_key = uc_fn_arg(0);
uc_value_t *a_val = uc_fn_arg(1);
uc_value_t *a_flags = uc_fn_arg(2);
uint64_t flags;
void *key, *val;

if (!map)
err_return(EINVAL, NULL);

key = uc_bpf_map_arg(a_key, "key", map->key_size);
if (!key)
return NULL;

val = uc_bpf_map_arg(a_val, "value", map->val_size);
if (!val)
return NULL;

if (!a_flags)
flags = BPF_ANY;
else if (ucv_type(a_flags) != UC_INTEGER)
err_return(EINVAL, "flags");
else
flags = ucv_int64_get(a_flags);

if (bpf_map_update_elem(map->fd.fd, key, val, flags))
return NULL;

return ucv_string_new_length(val, map->val_size);
}

The above function is used to set a value to a BPF map element.</s>




NEXT




<s> srg_led_control_sync(struct srg_led_ctrl *sysled_ctrl)
{
int i, ret;

for (i = 1; i < 5; i++) {
ret = srg_led_i2c_write(sysled_ctrl, i, sysled_ctrl->control[i]);
if (ret)
break;
}
return ret;
}

The above function is used to issue control sync write via i2c and it uses
srg_led_i2c_write() which is again implemented using the device and
client specific structure variables which are not present in the
linux_leds.c file




NEXT




<s> rtk_api_ret_t rtk_svlan_unassign_action_set(rtk_svlan_unassign_action_t action)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (action >= UNASSIGN_END)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicSvlanEgressUnassign((rtk_uint32)action);

return retVal;
}

The above function is used to set S-VLAN unasign action.

RT_ERR_PARM if "action" illegal.</s>




NEXT




<s> static void __exit ar8216_exit(void)
{
mdio_driver_unregister(&ar8xxx_mdio_driver);
phy_drivers_unregister(ar8xxx_phy_driver,
ARRAY_SIZE(ar8xxx_phy_driver));
}

The above function is used to de-register the Ar8216 NIC. At a higher level,
de-registration works as below.
1) The kernel module must call phy_drivers_register to register the
phydriver (




NEXT




<s> static int ag71xx_ethtool_get_sset_count(struct net_device *ndev, int sset)
{
if (sset == ETH_SS_STATS)
return ARRAY_SIZE(ag71xx_statistics);
return -EOPNOTSUPP;
}

The above function is used to get the number of statistics that the device supports.</s>




NEXT




<s> static void rtl931x_pie_rule_rm(struct rtl838x_switch_priv *priv, struct pie_rule *pr)
{
int idx = pr->id;

rtl931x_pie_rule_del(priv, idx, idx);
clear_bit(idx, priv->pie_use_bm);
}

The above function is used to remove an entry from the PIE table, by removing it from the hash table by updating the bit in the USE_PIE bitmap. The function rtl931x_pie_rule_rm_hash is used to do just that




NEXT




<s> static int ar934x_nfc_attach_chip(struct nand_chip *nand)
{
struct mtd_info *mtd = nand_to_mtd(nand);
struct ar934x_nfc *nfc = nand_get_controller_data(nand);
struct device *dev = mtd->dev.parent;
int ret;

ret = ar934x_nfc_init_tail(mtd);
if (ret)
return ret;

if (nand->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST) {
if (mtd->writesize == 2048)
nand->options |= NAND_NO_SUBPAGE_WRITE;

ret = ar934x_nfc_setup_hwecc(nfc);
if (ret)
return ret;
} else if (nand->ecc.engine_type != NAND_ECC_ENGINE_TYPE_SOFT) {
dev_err(dev, "unknown ECC mode %d\n", nand->ecc.engine_type);
return -EINVAL;
} else if ((nand->ecc.algo != NAND_ECC_ALGO_BCH) &&
(nand->ecc.algo != NAND_ECC_ALGO_HAMMING)) {
dev_err(dev, "unknown software ECC algo %d\n", nand->ecc.algo);
return -EINVAL;
}

return 0;
}

The above function is used to initialize the attached chip, it’s a call back from nand_register_controller(). The function checks the mtd’s writesize and according to the setting of NAND_NO_SUBPAGE_WRITE, use the init code




NEXT




<s> radius_userdata_load(struct radius_user_data *u, struct blob_attr *data)
{
enum {
USERSTATE_USERS,
USERSTATE_WILDCARD,
__USERSTATE_MAX,
};
static const struct blobmsg_policy policy[__USERSTATE_MAX] = {
[USERSTATE_USERS] = { "users", BLOBMSG_TYPE_TABLE },
[USERSTATE_WILDCARD] = { "wildcard", BLOBMSG_TYPE_ARRAY },
};
struct blob_attr *tb[__USERSTATE_MAX], *cur;
int rem;

if (!data)
return;

blobmsg_parse(policy, __USERSTATE_MAX, tb, blobmsg_data(data), blobmsg_len(data));

blobmsg_for_each_attr(cur, tb[USERSTATE_USERS], rem)
kvlist_set(&u->users, blobmsg_name(cur), cur);

if (tb[USERSTATE_WILDCARD])
u->wildcard = blob_memdup(tb[USERSTATE_WILDCARD]);
}

The above function is used to add the user details to the userdata table in which the users are present. Also the wildcard value is set when we will implement.

Also now let’s see the function which will be used to update the userdata table to




NEXT




<s> adm6996_write_mii_reg(struct adm6996_priv *priv, enum admreg reg, u16 val)
{
struct phy_device *phydev = priv->priv;
struct mii_bus *bus = phydev->mdio.bus;

bus->write(bus, PHYADDR(reg), val);
}

The above function is used to write a value on 15th PHY register. The purpose of that is to set RX FIFO flush threshold on the PHY. PHY uses RX FIFO flush threshold to decide whether to flush the RX F




NEXT




<s> static int ip17xx_get_reg(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);

val->value.i = state->proc_mii.m;
return 0;
}

The above function is used to extract the value of a given register.
Now, for the above register, let's say we define a register attribute called 'm'

#define ip17xx_m ip17xx_get_reg

REG




NEXT




<s> static int msdc_drv_resume(struct platform_device *pdev)
{
struct pm_message state;

state.event = PM_EVENT_RESUME;
msdc_drv_pm(pdev, state);
return 0;
}

The above function is used to resume the device driver during the resume
of the platform. It is called as part of the platform driver’s
platform_driver_resume function.

The driver needs to return 0 when the above call finishes
successfully.




NEXT




<s> static bool aw9523_precious_reg(struct device *dev, unsigned int reg)
{
/* Reading AW9523_REG_IN_STATE clears interrupt status */
return aw9523_is_reg_hole(reg) ||
reg == AW9523_REG_IN_STATE(0) ||
reg == AW9523_REG_IN_STATE(AW9523_PINS_PER_PORT);
}

The above function is used to check which registers are ok to read
to not cause bus error condition.

We can use the following code to get those registers which can be read

cat /sys/bus/i2c/devices/aw9523




NEXT




<s> static int dc_ep_msi_enable(struct pci_dev *pdev, int nvec)
{
int err;
struct dc_ep_priv *priv = pci_get_drvdata(pdev);

/* NB, ICU initailize first */
dc_ep_icu_init(priv);

err = pci_msi_vec_set(pdev, nvec);
if (err) {
dev_err(&pdev->dev, "%s: Failed to set maximum MSI vector\n",
__func__);
return -EIO;
}

err = pci_enable_msi_exact(pdev, nvec);
if (err) {
dev_err(&pdev->dev,
"%s: Failed to enable MSI interrupts error code: %d\n",
__func__, err);
return -EIO;
}
return 0;
}

The above function is used to enable MSI interrupts for DCEP, in case
they could help decrease the latency.
We can check the device tree data and determine the platform and
enable the MSI interrupts.

static int of_dc_




NEXT




<s> static int resume_polling(u64 saved_state)
{
mutex_lock(&poll_lock);

switch (soc_info.family) {
case RTL8380_FAMILY_ID:
sw_w32(saved_state, RTL838X_SMI_POLL_CTRL);
break;
case RTL8390_FAMILY_ID:
sw_w32(saved_state >> 32, RTL839X_SMI_PORT_POLLING_CTRL + 4);
sw_w32(saved_state, RTL839X_SMI_PORT_POLLING_CTRL);
break;
case RTL9300_FAMILY_ID:
sw_w32(saved_state, RTL930X_SMI_POLL_CTRL);
break;
case RTL9310_FAMILY_ID:
pr_warn("%s not implemented for RTL931X\n", __func__);
break;
}

mutex_unlock(&poll_lock);

return 0;
}

The above function is used to stop polling and resume the
interrupt driven queue processing.

static int
suspend_polling(void)
{
int err;
mutex_lock(&poll_lock);

err = resume_polling(readl




NEXT




<s> rtk_port_t rtk_switch_maxLogicalPort_get(void)
{
rtk_port_t port, maxLogicalPort = 0;

/* Check initialization state */
if(rtk_switch_initialState_get() != INIT_COMPLETED)
{
return UNDEFINE_PORT;
}

for(port = 0; port < RTK_SWITCH_PORT_NUM; port++)
{
if( (halCtrl->log_port_type[port] == UTP_PORT) || (halCtrl->log_port_type[port] == EXT_PORT) )
maxLogicalPort = port;
}

return maxLogicalPort;
}

The above function is used to get the maximum legal logical port number on the device.
As default, the legal port number for each physical port is the port number defined in log_port_type.
For example, for the switch that has no PON port, we




NEXT




<s> ret_t rtl8367c_setAsicStormFilterExtMulticastEnable(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_MCAST_EXT_EN_OFFSET, enabled);
}

The above function is used to disable the multicast filter based on Storm configuration.

On most of the customer’s router/switch platform, this function is used to disable multicast processing and do the multicast forwarding function with L2 and L3




NEXT




<s> int check_type(void)
{
struct ifreq ifr;

strncpy(ifr.ifr_name, ifname, IFNAMSIZ);

if (ioctl(capture_sock, SIOCGIFHWADDR, &ifr) < 0)
return -1;

return (ifr.ifr_hwaddr.sa_family == ARPHRD_IEEE80211_RADIOTAP);
}

The above function is used to determine the type of wireless card that is connected to the Linux system. Check the man pages about SIOCGIFHWADDR.</s>




NEXT




<s> ret_t rtl8367c_setAsicVlanPortAndProtocolBased(rtk_uint32 port, rtk_uint32 index, rtl8367c_protocolvlancfg *pPpbCfg)
{
rtk_uint32  reg_addr, bit_mask, bit_value;
ret_t   retVal;

/* Error Checking */
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(index > RTL8367C_PROTOVLAN_GIDX_MAX)
return RT_ERR_VLAN_PROTO_AND_PORT;

if( (pPpbCfg->valid != FALSE) && (pPpbCfg->valid != TRUE) )
return RT_ERR_INPUT;

if(pPpbCfg->vlan_idx > RTL8367C_CVIDXMAX)
return RT_ERR_VLAN_ENTRY_NOT_FOUND;

if(pPpbCfg->priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

/* Valid bit */
reg_addr  = RTL8367C_VLAN_PPB_VALID_REG(index);
bit_mask  = 0x0001 << port;
bit_value = ((TRUE == pPpbCfg->valid) ? 0x1 : 0x0);
retVal    = rtl8367c_setAsicRegBits(reg_addr, bit_mask, bit_value);
if(retVal != RT_ERR_OK)
return retVal;

/* Calculate the actual register address for CVLAN index*/
if(port < 8)
{
reg_addr = RTL8367C_VLAN_PPB_CTRL_REG(index, port);
bit_mask = RTL8367C_VLAN_PPB_CTRL_MASK(port);
}
else if(port == 8)
{
reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT8_INDEX_MASK;
}
else if(port == 9)
{
reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT9_INDEX_MASK;
}
else if(port == 10)
{
reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT10_INDEX_MASK;
}

bit_value = pPpbCfg->vlan_idx;
retVal  = rtl8367c_setAsicRegBits(reg_addr, bit_mask, bit_value);
if(retVal != RT_ERR_OK)
return retVal;

/* write priority */
reg_addr  = RTL8367C_VLAN_PPB_PRIORITY_ITEM_REG(port, index);
bit_mask  = RTL8367C_VLAN_PPB_PRIORITY_ITEM_MASK(port);
bit_value = pPpbCfg->priority;
retVal    = rtl8367c_setAsicRegBits(reg_addr, bit_mask, bit_value);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the CVID according to the corresponding protocol id. It sets the CVID by writing  to the register that corresponds to its port number and protocol type. In this example, we give a port number 0x08 with VID entry




NEXT




<s> void rtl839x_set_scheduling_queue_weights(struct rtl838x_switch_priv *priv, int port,
int *queue_weights)
{
mutex_lock(&priv->reg_mutex);

rtl839x_read_scheduling_table(port);

for (int i = 0; i < 8; i++) {
int lsb = 48 + i * 8;
int low_byte = 8 - (lsb >> 5);
int start_bit = lsb - (low_byte << 5);
int high_mask = 0x3ff >> (32 - start_bit);

sw_w32_mask(0x3ff << start_bit, (queue_weights[i] & 0x3ff) << start_bit,
RTL839X_TBL_ACCESS_DATA_2(low_byte));
if (high_mask)
sw_w32_mask(high_mask, (queue_weights[i] & 0x3ff) >> (32- start_bit),
RTL839X_TBL_ACCESS_DATA_2(low_byte - 1));
}

rtl839x_write_scheduling_table(port);
mutex_unlock(&priv->reg_mutex);
}

The above function is used to set queue weights between scheduling queues on
some switches that do not work in the standard way. The standard way is to
simply write the weights (bytes) using the set_weight() call so it can be
read and




NEXT




<s> static void color_setup(const char *theme)
{
int use_color;

use_color = set_theme(theme);
if (use_color && has_colors()) {
start_color();
init_dialog_colors();
} else
set_mono_theme();
}

The above function is used to detect if the shell window color/mono and if the terminal supports colors, and then to set the terminal to use an appropriate color scheme.

My question is, if this program runs on unix/linux, are users going to be




NEXT




<s> int board_eth_init(bd_t *bis)
{
u32 value;

/* set the pin multiplexers to enable talking to Ethernent Phys */
pinmux_set(PINMUX_BANK_MFA, 3, PINMUX_MACA_MDC);
pinmux_set(PINMUX_BANK_MFA, 4, PINMUX_MACA_MDIO);

// Ensure the MAC block is properly reset
reset_block(SYS_CTRL_RST_MAC, 1);
udelay(10);
reset_block(SYS_CTRL_RST_MAC, 0);

// Enable the clock to the MAC block
enable_clock(SYS_CTRL_CLK_MAC);

value = readl(SYS_CTRL_GMAC_CTRL);
/* Use simple mux for 25/125 Mhz clock switching */
value |= BIT(SYS_CTRL_GMAC_SIMPLE_MUX);
/* Enable GMII_GTXCLK to follow GMII_REFCLK - required for gigabit PHY */
value |= BIT(SYS_CTRL_GMAC_CKEN_GTX);
/* set auto tx speed */
value |= BIT(SYS_CTRL_GMAC_AUTOSPEED);

writel(value, SYS_CTRL_GMAC_CTRL);

return designware_initialize(MAC_BASE, PHY_INTERFACE_MODE_RGMII);
}

The above function is used to initialize the ethernet controller.
How is the ethernet frame is transmitted? I tried checking the datasheet
of the MAC but the registers are not mentioned. Could you help me in
this regard?

Thanks,




NEXT




<s> rtk_api_ret_t rtk_port_backpressureEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtk_uint32 regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (port != RTK_WHOLE_SYSTEM)
return RT_ERR_PORT_ID;

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortJamMode(&regData)) != RT_ERR_OK)
return retVal;

*pEnable = !regData;

return RT_ERR_OK;
}

The above function is used to query whether port jamming mode is enabled or not:
// [c]
rtk_api_ret_t rtk_port_backpressureEnable_set(rtk_port_t port, rtk_enable_




NEXT




<s> static int rtl8367_sw_reset_mibs(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

return rtl8366_smi_rmwr(smi, RTL8367_MIB_CTRL_REG(0), 0,
RTL8367_MIB_CTRL_GLOBAL_RESET_MASK);
}

The above function is used to reset the MIB counters. But the
documentation of the MIB counter reset
function, is wrong. The rtl8366_smi_rmwr
function uses the bit 6 as global reset (from page




NEXT




<s> static int rtl838x_mdio_remove(struct rtl838x_eth_priv *priv)
{
pr_debug("%s called\n", __func__);
if (!priv->mii_bus)
return 0;

mdiobus_unregister(priv->mii_bus);
mdiobus_free(priv->mii_bus);

return 0;
}

The above function is used to remove the MDIO bus. This is currently used when
the interface changes from copper to fiber. This is expected to be a rare
occurrence, so we do it manually.</s>




NEXT




<s> mt7530_get_port_mirror_tx(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

val->value.i =  priv->port_entries[val->port_vlan].mirror_tx;

return 0;
}

The above function is used to get the transmit mirror value which is set by configuring the SGID/VLAN.
This function copies the transmit mirroring index into its output structure. If the input index is valid, then the transmit mirror entry for that index will




NEXT




<s> static int conf_write_dep(const char *name)
{
struct file *file;
FILE *out;

out = fopen("..config.tmp", "w");
if (!out)
return 1;
fprintf(out, "deps_config := \\\n");
for (file = file_list; file; file = file->next) {
if (file->next)
fprintf(out, "\t%s \\\n", file->name);
else
fprintf(out, "\t%s\n", file->name);
}
fprintf(out, "\n%s: \\\n"
"\t$(deps_config)\n\n", conf_get_autoconfig_name());

env_write_dep(out, conf_get_autoconfig_name());

fprintf(out, "\n$(deps_config): ;\n");
fclose(out);

if (make_parent_dir(name))
return 1;
rename("..config.tmp", name);
return 0;
}

The above function is used to create the autoconfiguration and it checks whether there is a file ..config.tmp and copy it to the autoconfiguration file name supplied into the conf_write_dep() function. The make_parent_dir () function is to




NEXT




<s> int ifx_pp32_start(int pp32)
{
unsigned int mask = 1 << (pp32 << 4);
int ret;

/*  download firmware   */
ret = pp32_download_code(pp32, firmware_binary_code, sizeof(firmware_binary_code) / sizeof(*firmware_binary_code), firmware_binary_data, sizeof(firmware_binary_data) / sizeof(*firmware_binary_data));
if ( ret != 0 )
return ret;

/*  run PP32    */
IFX_REG_W32_MASK(mask, 0, PP32_FREEZE);

/*  idle for a while to let PP32 init itself    */
udelay(10);

return 0;
}

The above function is used to start the PP32 module on the device which the Packet Pusher interface is connected to. The following commands are used for this purpose:

The firmware_binary_code array contains the firmware binary code, and the firmware




NEXT




<s> int get_cipher_ivsize(const cipher_t *cipher)
{
const mbedtls_cipher_info_t *c = cipher;

return c->iv_size;
}

The above function is used to calculate the initial vector IV size for a cipher.

I have not found a reference for this size to be used in the cipher IV.

For example:

```
mbedtls_aes_init(&




NEXT




<s> void printf(char *fmt, ...)
{
va_list ap;
va_start(ap, fmt);
lp_Print(myoutput, 0, fmt, ap);
va_end(ap);
}

The above function is used to print the result of scan or printf on stdout or on file.</s>




NEXT




<s> static int fe_set_ringparam(struct net_device *dev,
struct ethtool_ringparam *ring)
{
struct fe_priv *priv = netdev_priv(dev);

if ((ring->tx_pending < 2) ||
(ring->rx_pending < 2) ||
(ring->rx_pending > MAX_DMA_DESC) ||
(ring->tx_pending > MAX_DMA_DESC))
return -EINVAL;

dev->netdev_ops->ndo_stop(dev);

priv->tx_ring.tx_ring_size = BIT(fls(ring->tx_pending) - 1);
priv->rx_ring.rx_ring_size = BIT(fls(ring->rx_pending) - 1);

dev->netdev_ops->ndo_open(dev);

return 0;
}

The above function is used to set the ring size for the tx or rx ring.
The user can call the the function ethtool_ringparam to set the ring
size.

However, I see that the function is only used when the user has not set




NEXT




<s> static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to initializes the gamma mapping table and is used in PTM initilization. The function uses the value of global variable g_queue_gamma_map, and initialising the table.

static int init_queue_gamma_map




NEXT




<s> static void do_ptm_tasklet(unsigned long);
#endif

/*
*  Debug Functions
*/
#if defined(DEBUG_DUMP_SKB) && DEBUG_DUMP_SKB
static void dump_skb(struct sk_buff *, u32, char *, int, int, int);
#else
#define dump_skb(skb, len, title, port, ch, is_tx)    do {} while (0)

The above function is used to store the contents of a frame into the log
buffer. It is only used debugging purposes (and we've used this for every
single driver so far) so it isn't a problem if it's not present.






NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_unmatchAction_get(rtk_port_t port, rtk_filter_unmatch_action_t* pAction)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pAction)
return RT_ERR_NULL_POINTER;

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if((ret = rtl8367c_getAsicAclUnmatchedPermit(rtk_switch_port_L2P_get(port), pAction)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to get ACL match type.

rtk_api_ret_t rtk_filter_igrAcl_entry_get(rtk_port_t port, rtk_filter_ac_entry_t idx, r




NEXT




<s> ret_t rtl8367c_setAsicPortUnmatchedSaMoving(rtk_uint32 port, rtk_uint32 enabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_REG_L2_SA_MOVING_FORBID, port, (enabled == 1) ? 0 : 1);
}

The above function is used to
1) Set an MAC address to forward packets on that particular port.
2) Forbid SA moving in that particular port.

Below are three parameters on how to get information.
1) Passing "all-00




NEXT




<s> ret_t rtl8367c_setAsicSvlanC2SConf(rtk_uint32 index, rtk_uint32 evid, rtk_uint32 portmask, rtk_uint32 svidx)
{
ret_t retVal;

if(index > RTL8367C_C2SIDXMAX)
return RT_ERR_ENTRY_INDEX;

retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index), svidx);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index) + 1, portmask);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index) + 2, evid);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the internal table information for the VLAN Tag in the C2S direction. For example:

rtk_uint32 ctrIDX, portIDX;
rtk_uint32 svid;
rtk




NEXT




<s> ret_t rtl8367c_setAsicWFQBurstSize(rtk_uint32 burstsize)
{
ret_t retVal;

retVal = rtl8367c_setAsicReg(RTL8367C_SCHEDULE_WFQ_BURST_SIZE_REG, burstsize);

return retVal;
}

The above function is used to set the WFQ burst size value for the system.


The burst size value is saved from the default value to the following memory address after the system power on.

  0x80002060





NEXT




<s> static int b53_global_set_vlan_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct b53_device *priv = sw_to_b53(dev);

priv->enable_vlan = val->value.i;

return 0;
}

The above function is used to enable and disable VLAN on e1000 port. We are
simply storing the received value in the private data of b53_device structure.

The below function is used to get the status of enabling VLAN




NEXT




<s> static int __init mtdsplit_minor_init(void)
{
register_mtd_parser(&mtdsplit_minor_parser);

return 0;
}

The above function is used to define a minor number which is automatically assigned (using a counter variable). This function takes no (or very few) arguments and it registers the mtdsplit minor. It returns the value that was assigned.
mtdsplit_minor_parser




NEXT




<s> ret_t rtl8367c_setAsicPortMirrorVlanTxLeaky(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_TX_VLAN_LEAKY_OFFSET, enabled);
}

The above function is used to set Asic port mirror VLAN leaky enable or disable which is defined in RTL8367C_MIRROR_CTRL2 as below

/ -------------------------- // 6 : 6 Mirror Tx V




NEXT




<s> int rtl83xx_port_dev_lower_find(struct net_device *dev, struct rtl838x_switch_priv *priv)
{
struct rtl83xx_walk_data data;
struct netdev_nested_priv _priv;

data.priv = priv;
data.port = 0;
_priv.data = (void *)&data;

netdev_walk_all_lower_dev(dev, rtl83xx_port_lower_walk, &_priv);

return data.port;
}

The above function is used to locate which port on the switch should we bind the
received packets.

In Ethernet world, a switch has multiple ports and each port can receive
multiple physical network device's packet and each physical network device
can attach to




NEXT




<s> static ssize_t swconfig_trig_speed_mask_show(struct device *dev,
struct device_attribute *attr,
char *buf)
{
struct led_classdev *led_cdev = dev_get_drvdata(dev);
struct swconfig_trig_data *trig_data = led_cdev->trigger_data;
u8 speed_mask;

read_lock(&trig_data->lock);
speed_mask = trig_data->speed_mask;
read_unlock(&trig_data->lock);

sprintf(buf, "%#x\n", speed_mask);

return strlen(buf) + 1;
}

The above function is used to display the data to the console.

The user enters the speed mask:

$ echo 0x1 > speed

The “0x1” is saved in the “speed_mask” variable by the trigger_state_




NEXT




<s> void rtl8231_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)
{
struct rtl8231_gpios *gpios = gpiochip_get_data(gc);

rtl8231_pin_set(gpios, offset, value);
}

The above function is used to set a GPIO value for a given offset within the GPIO chip. The

struct rtl8231_gpios *gpios = gpiochip_get_data(gc);

line is getting the pointer to




NEXT




<s> void memory_release(u32 *addr);
int aes_chip_init (void);
void des_chip_init (void);
int deu_dma_init (void);
u32 endian_swap(u32 input);
u32* memory_alignment(const u8 *arg, u32 *buff_alloc, int in_out, int nbytes);
void dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);
void chip_version(void);
void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to return data from the host in little endian format for the use in DMA (data must be in big endian format). Thus the little endian data will be converted into big endian via the above mentioned function. This is also applicable for CPU




NEXT




<s> void entry(unsigned long icache_size, unsigned long icache_lsize,
unsigned long dcache_size, unsigned long dcache_lsize,
unsigned long fw_arg0, unsigned long fw_arg1,
unsigned long fw_arg2, unsigned long fw_arg3)
{
unsigned int i;  /* temp value */
unsigned int lc; /* literal context bits */
unsigned int lp; /* literal pos state bits */
unsigned int pb; /* pos state bits */
unsigned int osize; /* uncompressed size */

ILzmaInCallback callback;
callback.Read = read_byte;

/* look for trx header, 32-bit data access */
for (data = ((unsigned char *) KSEG1ADDR(BCM4710_FLASH));
((struct trx_header *)data)->magic != TRX_MAGIC &&
((struct trx_header *)data)->magic != EDIMAX_PS_HEADER_MAGIC;
data += 65536);

if (((struct trx_header *)data)->magic == EDIMAX_PS_HEADER_MAGIC)
data += EDIMAX_PS_HEADER_LEN;
/* compressed kernel is in the partition 0 or 1 */
if (((struct trx_header *)data)->offsets[1] > 65536)
data += ((struct trx_header *)data)->offsets[0];
else
data += ((struct trx_header *)data)->offsets[1];

offset = 0;

/* lzma args */
i = get_byte();
lc = i % 9, i = i / 9;
lp = i % 5, pb = i / 5;

/* skip rest of the LZMA coder property */
for (i = 0; i < 4; i++)
get_byte();

/* read the lower half of uncompressed size in the header */
osize = ((unsigned int)get_byte()) +
((unsigned int)get_byte() << 8) +
((unsigned int)get_byte() << 16) +
((unsigned int)get_byte() << 24);

/* skip rest of the header (upper half of uncompressed size) */
for (i = 0; i < 4; i++)
get_byte();

/* decompress kernel */
if (LzmaDecode(workspace, ~0, lc, lp, pb, &callback,
(unsigned char*)LOADADDR, osize, &i) == LZMA_RESULT_OK)
{
blast_dcache(dcache_size, dcache_lsize);
blast_icache(icache_size, icache_lsize);

/* Jump to load address */
((void (*)(unsigned long, unsigned long, unsigned long,
unsigned long)) LOADADDR)(fw_arg0, fw_arg1, fw_arg2,
fw_arg3);
}
}

The above function is used to decompress the flash contents to some memory,
for further execution.
It looks for flash addresses from a 32 Bit header value in a loop until it
finds the required
one, and then decompresses the data. The




NEXT




<s> rtk_api_ret_t rtk_qos_portPriSelIndex_set(rtk_port_t port, rtk_qos_priDecTbl_t index)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (index >= PRIDECTBL_END )
return RT_ERR_ENTRY_INDEX;

if ((retVal = rtl8367c_setAsicPortPriorityDecisionIndex(rtk_switch_port_L2P_get(port), index)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the Port Priority Decision table  index, which can be used to implement high priority. The input port is Layer2 port. When the high priority process is running, each packet coming from this port is high priority level, according to




NEXT




<s> IFX_MEI_ResetARC (DSL_DEV_Device_t * pDev)
{
u32 arc_debug_data = 0;

IFX_MEI_HaltArc (pDev);

IFX_MEI_LongWordRead ((u32) LTQ_RCU_RST, &arc_debug_data);
IFX_MEI_LongWordWrite ((u32) LTQ_RCU_RST,
arc_debug_data | LTQ_RCU_RST_REQ_DFE | LTQ_RCU_RST_REQ_AFE);

// reset ARC
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_RST_CTRL, MEI_SOFT_RESET);
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_RST_CTRL, 0);

IFX_MEI_IRQDisable (pDev);

IFX_MEI_EnableCLK (pDev);

#if 0
// reset part of PPE
*(unsigned long *) (BSP_PPE32_SRST) = 0xC30;
*(unsigned long *) (BSP_PPE32_SRST) = 0xFFF;
#endif

DSL_DEV_PRIVATE(pDev)->modem_ready = 0;

return DSL_DEV_MEI_ERR_SUCCESS;
}

The above function is used to reset the modem. The functions above are also in common with the MTA.  The main difference between these functions and the similar ones in the MTA is that the MTA modem does not use an arc on its board, rather everything




NEXT




<s> static int rtl839x_pie_rule_add(struct rtl838x_switch_priv *priv, struct pie_rule *pr)
{
int idx, block, j, t;
int min_block = 0;
int max_block = priv->n_pie_blocks / 2;

if (pr->is_egress) {
min_block = max_block;
max_block = priv->n_pie_blocks;
}

mutex_lock(&priv->pie_mutex);

for (block = min_block; block < max_block; block++) {
for (j = 0; j < 2; j++) {
t = (sw_r32(RTL839X_ACL_BLK_TMPLTE_CTRL(block)) >> (j * 3)) & 0x7;
idx = rtl839x_pie_verify_template(priv, pr, t, block);
if (idx >= 0)
break;
}
if (j < 2)
break;
}

if (block >= priv->n_pie_blocks) {
mutex_unlock(&priv->pie_mutex);
return -EOPNOTSUPP;
}

set_bit(idx, priv->pie_use_bm);

pr->valid = true;
pr->tid = j;  /* Mapped to template number */
pr->tid_m = 0x3;
pr->id = idx;

rtl839x_pie_lookup_enable(priv, idx);
rtl839x_pie_rule_write(priv, idx, pr);

mutex_unlock(&priv->pie_mutex);

return 0;
}

The above function is used to add a new PIE rule from the kernel space. It does a simple loop over all the
possible match entries. It is possible to have multiple entries for a different TID for the same rule. If the
match fields do not match the




NEXT




<s> rtk_api_ret_t rtk_l2_flushLinkDownPortAddrEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (port != RTK_WHOLE_SYSTEM)
return RT_ERR_PORT_ID;

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLutLinkDownForceAging(pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to query the status of enabling address table forced flushing for the link down port, which is applicable for only Ethernet switch devices. The device status of forcing address table flushing for the link down port does not affect the query results. If the




NEXT




<s> trx_check(int imagefd, const char *mtd, char *buf, int *len)
{
const struct trx_header *trx = (const struct trx_header *) buf;
int fd;

if (strcmp(mtd, "firmware") != 0)
return 1;

if (*len < 32) {
*len += read(imagefd, buf + *len, 32 - *len);
if (*len < 32) {
fprintf(stdout, "Could not get image header, file too small (%d bytes)\n", *len);
return 0;
}
}

if (ntohl(trx->magic) != opt_trxmagic ||
trx->len < sizeof(struct trx_header)) {
if (quiet < 2) {
fprintf(stderr, "Bad trx header\n");
fprintf(stderr, "This is not the correct file format; refusing to flash.\n"
"Please specify the correct file or use -f to force.\n");
}
return 0;
}

/* check if image fits to mtd device */
fd = mtd_check_open(mtd);
if(fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd);
exit(1);
}

if(mtdsize < trx->len) {
fprintf(stderr, "Image too big for partition: %s\n", mtd);
close(fd);
return 0;
}

close(fd);
return 1;
}

The above function is used to verify image format on flash.</s>




NEXT




<s> send_attr_val(struct nl_msg *msg, void *arg)
{
struct switch_val *val = arg;
struct switch_attr *attr = val->attr;

if (send_attr(msg, arg))
goto nla_put_failure;

switch(attr->type) {
case SWITCH_TYPE_NOVAL:
break;
case SWITCH_TYPE_INT:
NLA_PUT_U32(msg, SWITCH_ATTR_OP_VALUE_INT, val->value.i);
break;
case SWITCH_TYPE_STRING:
if (!val->value.s)
goto nla_put_failure;
NLA_PUT_STRING(msg, SWITCH_ATTR_OP_VALUE_STR, val->value.s);
break;
case SWITCH_TYPE_PORTS:
if (send_attr_ports(msg, val) < 0)
goto nla_put_failure;
break;
case SWITCH_TYPE_LINK:
if (send_attr_link(msg, val))
goto nla_put_failure;
break;
default:
goto nla_put_failure;
}
return 0;

nla_put_failure:
return -1;
}

The above function is used to export a particular switch attr value in the format of netlink
message to the upper layer.

In the main function, we use this function to export switch attr values in the format of netlink message
to the upper layer. For the




NEXT




<s> static int __init wanqos_en_setup(char *line)
{
wanqos_en = simple_strtoul(line, NULL, 0);

if ( wanqos_en < 1 || wanqos_en > 8 )
wanqos_en = 0;

return 0;
}

The above function is used to set the wan queue priority. It is a good example of how the system can be made to provide this information.

This is a simple function to show how a kernel module can be used to provide a basic feature of the qos.




NEXT




<s> ret_t rtl8367c_setAsicAclPortRange(rtk_uint32 index, rtk_uint32 type, rtk_uint32 upperPort, rtk_uint32 lowerPort)
{
ret_t retVal;

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL2 + index*3, RTL8367C_ACL_SDPORT_RANGE_ENTRY0_CTRL2_MASK, type);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL1 + index*3, upperPort);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL0 + index*3, lowerPort);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the ACL range on RTL8367C which defines the lower and upper ports to a certain ACL entry. For example, if ACL rule number is 10, it means this ACL rule will take effect on




NEXT




<s> ret_t rtl8367c_setAsicLutLinkDownForceAging(rtk_uint32 enable)
{
if(enable > 1)
return RT_ERR_ENABLE;

return rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LINKDOWN_AGEOUT_OFFSET, enable ? 0 : 1);
}

The above function is used to set the Asic LUT Link Down Force Aging. If to disable this function, the link status of the LUT cache will always be forced to be the old data, which is not affected by the RGMII/SGMII status




NEXT




<s> static int osafeloader_extract(int argc, char **argv) {
FILE *safeloader;
FILE *out;
struct safeloader_header hdr;
size_t bytes;
char name[32];
int base, size;
int err = 0;

if (argc < 3) {
fprintf(stderr, "No SafeLoader file passed\n");
err = -EINVAL;
goto out;
}
safeloader_path = argv[2];

optind = 3;
osafeloader_extract_parse_options(argc, argv);
if (!partition_name) {
fprintf(stderr, "No partition name specified\n");
err = -EINVAL;
goto out;
} else if (!out_path) {
fprintf(stderr, "No output file specified\n");
err = -EINVAL;
goto out;
}

safeloader = fopen(safeloader_path, "r");
if (!safeloader) {
fprintf(stderr, "Couldn't open %s\n", safeloader_path);
err = -EACCES;
goto out;
}

out = fopen(out_path, "w");
if (!out) {
fprintf(stderr, "Couldn't open %s\n", out_path);
err = -EACCES;
goto err_close_safeloader;
}

bytes = fread(&hdr, 1, sizeof(hdr), safeloader);
if (bytes != sizeof(hdr)) {
fprintf(stderr, "Couldn't read %s header\n", safeloader_path);
err =  -EIO;
goto err_close_out;
}

/* Skip vendor info */
fseek(safeloader, 0x1000, SEEK_CUR);

err = -ENOENT;
while (fscanf(safeloader, "fwup-ptn %s base 0x%x size 0x%x\t\r\n", name, &base, &size) == 3) {
uint8_t buf[1024];

if (strcmp(name, partition_name))
continue;

err = 0;

fseek(safeloader, sizeof(hdr) + 0x1000 + base, SEEK_SET);

while ((bytes = fread(buf, 1, osafeloader_min(sizeof(buf), size), safeloader)) > 0) {
if (fwrite(buf, 1, bytes, out) != bytes) {
fprintf(stderr, "Couldn't write %zu B to %s\n", bytes, out_path);
err = -EIO;
break;
}
size -= bytes;
}

if (size) {
fprintf(stderr, "Couldn't extract whole partition %s from %s (%d B left)\n", partition_name, safeloader_path, size);
err = -EIO;
}

break;
}

err_close_out:
fclose(out);
err_close_safeloader:
fclose(safeloader);
out:
return err;
}

The above function is used to extract a firmware image from an Intel BMC’s OSAF (Onboard Safe Firmware) image. (Note: As I mentioned in an earlier post, SafeLoader is a firmware image built by Intel for their Xe




NEXT




<s> static int ip17xx_reset(struct switch_dev *dev)
{
struct ip17xx_state *state = get_state(dev);
int i, err;

if (REG_SUPP(state->regs->RESET_REG)) {
err = setPhy(state, state->regs->RESET_REG, state->regs->RESET_VAL);
if (err < 0)
return err;
err = getPhy(state, state->regs->RESET_REG);

/*
*  Data sheet specifies reset period to be 2 msec.
*  (I don't see any mention of the 2ms delay in the IP178C spec, only
*  in IP175C, but it can't hurt.)
*/
mdelay(2);
}

/* reset switch ports */
for (i = 0; i < state->regs->NUM_PORTS-1; i++) {
err = ip_phy_write(state, i, MII_BMCR, BMCR_RESET);
if (err < 0)
return err;
}

state->router_mode = 0;
state->vlan_enabled = 0;
ip17xx_reset_vlan_config(state);

return state->regs->reset(state);
}

The above function is used to reset the switch. The only differences between the two switches I wrote is the macro and reset values at the beginning of the function and how the vlan_enabled variable is set and used below.</s>




NEXT




<s> static int qca807x_led_config(struct phy_device *phydev)
{
struct device_node *node = phydev->mdio.dev.of_node;
bool led_config = false;
int val;

val = phy_read_mmd(phydev, MDIO_MMD_AN, QCA807X_MMD7_LED_1000N_1);
if (val < 0)
return val;

if (of_property_read_bool(node, "qcom,single-led-1000")) {
val |= QCA807X_LED_TXACT_BLK_EN_2;
val |= QCA807X_LED_RXACT_BLK_EN_2;
val |= QCA807X_LED_GT_ON_EN_2;

led_config = true;
}

if (of_property_read_bool(node, "qcom,single-led-100")) {
val |= QCA807X_LED_HT_ON_EN_2;

led_config = true;
}

if (of_property_read_bool(node, "qcom,single-led-10")) {
val |= QCA807X_LED_BT_ON_EN_2;

led_config = true;
}

if (led_config)
return phy_write_mmd(phydev, MDIO_MMD_AN, QCA807X_MMD7_LED_1000N_1, val);
else
return 0;
}

The above function is used to enable single-LED by reading the device tree of the SoC and checking for the presence of single-LED.</s>




NEXT




<s> speed_str(int speed)
{
switch (speed) {
case 10:
return "10baseT";
case 100:
return "100baseT";
case 1000:
return "1000baseT";
default:
break;
}

return "unknown";
}

The above function is used to convert an integer into a string.

For example: 10 -> "10baseT", 101 -> "unknown", etc

How to do it?

#### Solution

First off, I'll




NEXT




<s> rtk_api_ret_t rtk_rate_stormControlMeterIdx_get(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_uint32 *pIndex)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (stormType >= STORM_GROUP_END)
return RT_ERR_SFC_UNKNOWN_GROUP;

if (NULL == pIndex )
return RT_ERR_NULL_POINTER;

switch (stormType)
{
case STORM_GROUP_UNKNOWN_UNICAST:
if ((retVal = rtl8367c_getAsicStormFilterUnknownUnicastMeter(rtk_switch_port_L2P_get(port), pIndex))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_UNKNOWN_MULTICAST:
if ((retVal = rtl8367c_getAsicStormFilterUnknownMulticastMeter(rtk_switch_port_L2P_get(port), pIndex))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_MULTICAST:
if ((retVal = rtl8367c_getAsicStormFilterMulticastMeter(rtk_switch_port_L2P_get(port), pIndex))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_BROADCAST:
if ((retVal = rtl8367c_getAsicStormFilterBroadcastMeter(rtk_switch_port_L2P_get(port), pIndex))!=RT_ERR_OK)
return retVal;
break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to obtain the index value of a specified rate limit value.

rtk_api_ret_t rtk_rate_stormControlMeterIdx_set(rtk_port_t port, rtk_rate_storm_group




NEXT




<s> ret_t rtl8367c_getAsicReg(rtk_uint32 reg, rtk_uint32 *pValue)
{

#if defined(RTK_X86_ASICDRV)

rtk_uint32 regData;
ret_t retVal;

retVal = Access_Read(reg, 2, &regData);
if(TRUE != retVal)
return RT_ERR_SMI;

*pValue = regData;

if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);

#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)
if(reg >= CLE_VIRTUAL_REG_SIZE)
return RT_ERR_OUT_OF_RANGE;

*pValue = CleVirtualReg[reg];

if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n", reg, CleVirtualReg[reg]);

#elif defined(EMBEDDED_SUPPORT)
if(reg > RTL8367C_REGDATAMAX  )
return RT_ERR_INPUT;

*value = getReg(reg);

#else
rtk_uint32 regData;
ret_t retVal;

retVal = smi_read(reg, &regData);
if(retVal != RT_ERR_OK)
return RT_ERR_SMI;

*pValue = regData;
#ifdef CONFIG_RTL865X_CLE
if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
#endif

#endif

return RT_ERR_OK;
}

The above function is used to get a value of a particular register. The C-macro definition of ASIC_SMI_READ() is used, i.e., RTK_X86_ASICDRV, or SMI driver from U-boot.




NEXT




<s> ret_t rtl8367c_setAsicFlowControlPortPrivateJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_ON_MASK, onThreshold);

return retVal;
}

The above function is used to set and get the Jumbo packet threshold value of a user port in software. First, it checks the threshold value and then assigns it to the Jumbo port’s on-threshold and off-threshold registers.

ret_




NEXT




<s> static int wlc_maclist(wlc_param param, void *data, void *value)
{
unsigned int *var = ((unsigned int *) data);
unsigned int ioc = *var;
int limit = (sizeof(wlbuf) - 4) / sizeof(struct ether_addr);
struct maclist *list = (struct maclist *) wlbuf;
char *str = (char *) value;
char astr[30], *p;
struct ether_addr *addr;
int isset = 0;
int ret;

if ((param & PARAM_MODE) == GET) {
list->count = limit;
ret = wl_ioctl(interface, (ioc >> 16) & 0xffff, wlbuf, sizeof(wlbuf));

if (!ret)
while (list->count) {
str += sprintf(str, "%s", ((((char *) value) == str) ? "" : " "));
str += my_ether_ntoa((unsigned char *) &list->ea[list->count-- - 1], str);
}

return ret;
} else {
while (*str && isspace(*str))
*str++;

if (*str == '+') {
str++;

list->count = limit;
if (wl_ioctl(interface, (ioc >> 16) & 0xffff, wlbuf, sizeof(wlbuf)) == 0)
isset = 1;

while (*str && isspace(*str))
str++;
}

if (!isset)
memset(wlbuf, 0, sizeof(wlbuf));

foreach(astr, str, p) {
if (list->count >= limit)
break;

if ((addr = ether_aton(astr)) != NULL)
memcpy(&list->ea[list->count++], addr, sizeof(struct ether_addr));
}

return wl_ioctl(interface, ioc & 0xffff, wlbuf, sizeof(wlbuf));
}
}

The above function is used to manage maclists in the WLC code. It will check the parameters and will either

If we need to get the maclist entry of a card

If we need to add entries to the maclist

I tried adding the following




NEXT




<s> static const char *sha256_hash(FILE *f)
{
SHA256_CTX ctx;
unsigned char val[SHA256_DIGEST_LENGTH];
void *buf;
int len;

SHA256_Init(&ctx);
while ((buf = hash_buf(f, &len)) != NULL)
SHA256_Update(&ctx, buf, len);
SHA256_Final(val, &ctx);

return hash_string(val, SHA256_DIGEST_LENGTH);
}

The above function is used to calculate the SHA-256 hash of a given file, and it is used throughout DOSBox, especially in the DOSBox GUI, to calculate the hashes of game files. It’s used to verify the integrity of the




NEXT




<s> static int b53_global_set_4095_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct b53_device *priv = sw_to_b53(dev);

priv->allow_vid_4095 = val->value.i;

return 0;
}

The above function is used to set the global enable flag for a particular VLAN ID in TCAM.  Here, we are dealing with VLAN ID 4095.  For a particular VLAN ID in TCAM, if the enable bit is set to zero




NEXT




<s> static const char *obj_stringval(uc_value_t *obj, const char *name)
{
uc_value_t *val = ucv_object_get(obj, name, NULL);

return ucv_string_get(val);
}

The above function is used to obtain the value of name in the property table of object. If name is not a property of object, its return value is NULL.

If name is a property of object, ucv_object_get(...) returns its object reference,




NEXT




<s> void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to swap the byte order of the data for 32-bit
hardware descriptors. The descriptors come in different byte order
based on their origin. For example, if the data is received over
serial interface such as UART from




NEXT




<s> void rtl9300_do_rx_calibration_2_1(u32 sds_num)
{
pr_info("start_1.2.1 ForegroundOffsetCal_Manual\n");

/* Gray config endis to 1 */
rtl9300_sds_field_w(sds_num, 0x2f, 0x02,  2,  2, 0x01);

/* ForegroundOffsetCal_Manual(auto mode) */
rtl9300_sds_field_w(sds_num, 0x2e, 0x01, 14, 14, 0x00);

pr_info("end_1.2.1");
}

The above function is used to start the Rx calibration of WLAN device using RTL871X
driver. It takes just one parameter which is the number of SD3. This function
is responsible for configuring all necessary registers. If the WLAN R




NEXT




<s> void conf_set_changed(bool val)
{
if (conf_changed_callback && conf_changed != val)
conf_changed_callback();

conf_changed = val;
}

The above function is used to tell whether settings were changed by calling the callback function conf_changed_callback(). conf_changed is set to true, whenever the user changes the settings. This is done to differentiate between a regular keypress (i. e. change the background




NEXT




<s> BN_ULONG bn_add_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
{
BN_ULONG c,l,t;

assert(n >= 0);
if (n <= 0) return((BN_ULONG)0);

c=0;
for (;;)
{
t=a[0];
t=(t+c)&BN_MASK2;
c=(t < c);
l=(t+b[0])&BN_MASK2;
c+=(l < t);
r[0]=l;
if (--n <= 0) break;

t=a[1];
t=(t+c)&BN_MASK2;
c=(t < c);
l=(t+b[1])&BN_MASK2;
c+=(l < t);
r[1]=l;
if (--n <= 0) break;

t=a[2];
t=(t+c)&BN_MASK2;
c=(t < c);
l=(t+b[2])&BN_MASK2;
c+=(l < t);
r[2]=l;
if (--n <= 0) break;

t=a[3];
t=(t+c)&BN_MASK2;
c=(t < c);
l=(t+b[3])&BN_MASK2;
c+=(l < t);
r[3]=l;
if (--n <= 0) break;

a+=4;
b+=4;
r+=4;
}
return((BN_ULONG)c);
}

The above function is used to add an unsigned 32 bit integer to a big
number of arbitrary length. The arguments a and b may be 128 or more
bits long (a and b are pointers to BN_ULONG arrays of length n




NEXT




<s> static int aw9523_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)
{
return ARRAY_SIZE(aw9523_pins);
}

The above function is used to get the count of pinmux configs in order
to define how many possible pinmux groups are available.

static int aw9523_pinctrl_describe_gpio(struct sequential lock pctldev,




NEXT




<s> static int rtl8367_detect(struct rtl8366_smi *smi)
{
u32 rtl_no = 0;
u32 rtl_ver = 0;
char *chip_name;
int ret;

ret = rtl8366_smi_read_reg(smi, RTL8367_RTL_NO_REG, &rtl_no);
if (ret) {
dev_err(smi->parent, "unable to read chip number\n");
return ret;
}

switch (rtl_no) {
case RTL8367_RTL_NO_8367R:
chip_name = "8367R";
break;
case RTL8367_RTL_NO_8367M:
chip_name = "8367M";
break;
default:
dev_err(smi->parent, "unknown chip number (%04x)\n", rtl_no);
return -ENODEV;
}

ret = rtl8366_smi_read_reg(smi, RTL8367_RTL_VER_REG, &rtl_ver);
if (ret) {
dev_err(smi->parent, "unable to read chip version\n");
return ret;
}

dev_info(smi->parent, "RTL%s ver. %u chip found\n",
chip_name, rtl_ver & RTL8367_RTL_VER_MASK);

return 0;
}

The above function is used to determine which version of the RTL chipset a driver is being compiled for, which in turn affects the registers supported.

In the rtl8367.c file, the rtl8366_smi_read




NEXT




<s> static int ctr_aes_decrypt(struct ablkcipher_request *areq)
{
struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);
struct aes_ctx *ctx = crypto_ablkcipher_ctx(cipher);

return lq_aes_queue_mgr(ctx, areq, areq->info, CRYPTO_DIR_DECRYPT, 4);
}

The above function is used to decrypt messages using the CTR mode. You may
also have noticed that since this is done using lq_aes_queue_mgr() that we
have to allocate space for our extra 32 bytes in our key block (




NEXT




<s> static int rtl8367c_get_mibs_num(void)
{
return ARRAY_SIZE(rtl8367c_mib_counters);
}

The above function is used to initialize mib counters from the sysfs at runtime only when the kernel support inplace file patching facility.
Also, the below macros are used to update the variable rtcl_mibs_count, which specifies the




NEXT




<s> u32 rtl9300_sds_rxcal_leq_read(int sds_num)
{
u32 leq_gray, leq_bin;
bool leq_manual;

if (!(sds_num % 2))
rtl930x_write_sds_phy(sds_num, 0x1f, 0x2, 0x2f);
else
rtl930x_write_sds_phy(sds_num - 1, 0x1f, 0x2, 0x31);

/* ##Page0x2E, Reg0x15[9], REG0_RX_EN_TEST=[1] */
rtl9300_sds_field_w(sds_num, 0x2e, 0x15, 9, 9, 0x1);

/* ##Page0x21, Reg0x06[11 6], REG0_RX_DEBUG_SEL=[0 1 x x x x] */
rtl9300_sds_field_w(sds_num, 0x21, 0x06, 11, 6, 0x10);
mdelay(1);

/* ##LEQ Read Out */
leq_gray = rtl9300_sds_field_r(sds_num, 0x1f, 0x14, 7, 3);
leq_manual = !!rtl9300_sds_field_r(sds_num, 0x2e, 0x18, 15, 15);
leq_bin = rtl9300_sds_rxcal_gray_to_binary(leq_gray);

pr_info("LEQ_gray: %u, LEQ_bin: %u", leq_gray, leq_bin);
pr_info("LEQ manual: %u", leq_manual);

return leq_bin;
}

The above function is used to detect LE Quality.</s>




NEXT




<s> rtk_api_ret_t rtk_igmp_ReportLeaveFwdAction_get(rtk_igmp_ReportLeaveFwdAct_t *pAction)
{
rtk_api_ret_t   retVal;
rtk_uint32      regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pAction)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPReportLeaveFlood(&regData))!=RT_ERR_OK)
return retVal;

switch(regData)
{
case 1:
*pAction = IGMP_REPORT_LEAVE_TO_ROUTER;
break;
case 2:
*pAction = IGMP_REPORT_LEAVE_TO_ALLPORT;
break;
case 3:
*pAction = IGMP_REPORT_LEAVE_TO_ROUTER_PORT_ADV;
break;
default:
return RT_ERR_FAILED;
}

return RT_ERR_OK;
}

The above function is used to obtain the report leave forwarding action value for igmp snooping.

The following is an example of setting the report leave forwarding action:

```
igmp_ReportLeaveFwd_e act;

rt




NEXT




<s> ret_t rtl8367c_getAsicCputagInsertMode(rtk_uint32 *pMode)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_INSERTMODE_MASK, pMode);
}

The above function is used to check a configuration value(CPU_INSERTMODE) which was set by
rtl8367c_setCputagInsertMode() function to avoid the CPU tagging insert mode be set by firmware.
However, it is




NEXT




<s> static u16 psb6970_mii_read(struct phy_device *phydev, int reg)
{
struct mii_bus *bus = phydev->mdio.bus;

return bus->read(bus, PHYADDR(reg));
}

The above function is used to read the MII register. The bus pointer bus is a pointer of mii_bus to which the PHY devcie is associated with. Using the PHYADDR macro, the corresponding read function is called.

A function which writes to




NEXT




<s> static int __init red_15w_rev1_probe(void)
{
if (of_machine_is_compatible("sophos,red-15w-rev1"))
return 1;
return 0;
}

The above function is used to check the machine id of the board and
see if it is an appropriate board for this driver. You would call it
from probing the device.

int __init spruce_probe(void)
{
return of_




NEXT




<s> void b53_set_forwarding(struct b53_device *dev, int enable)
{
u8 mgmt;

b53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);

if (enable)
mgmt |= SM_SW_FWD_EN;
else
mgmt &= ~SM_SW_FWD_EN;

b53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, mgmt);
}

The above function is used to enable or disable the forwarding of L2 frames in the AQ. How do I know when a particular switch port is actually bridging or forwarding the frames or not by observing the switch registers?

- The switch does not




NEXT




<s> rtk_api_ret_t rtk_port_phyEnableAll_get(rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortEnableAll(pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the current system port enable status.

Example:

// get current system port enable state
typedef struct {
rtk_enable_t enable;
} enable_s;

enable_s enable;





NEXT




<s> u32 endian_swap(u32 input);
u32* memory_alignment(const u8 *arg, u32 *buff_alloc, int in_out, int nbytes);
void dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);
void chip_version(void);
void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to change the endianess of the data for

#endif</s>




NEXT




<s> u16 rtl83xx_pick_tx_queue(struct net_device *dev, struct sk_buff *skb,
struct net_device *sb_dev)
{
static u8 last = 0;

last++;
return last % TXRINGS;
}

The above function is used to pick the appropriate transmit queue (TQ) from which
the software module needs to transmit the packet. In this example, each TQ is
associated with a different channel. The packet to be transmitted is chosen
arbitrarily amongst




NEXT




<s> rtl_attr_get_int(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
int idx = attr->id + (val->port_vlan * attr->ofs);

if (idx >= ARRAY_SIZE(rtl_regs))
return -EINVAL;

val->value.i = rtl_get(dev, idx);
return 0;
}

The above function is used to get a register’s data.

If a certain register’s data changed, all the network interface’s will receive the message and take actions.

The following code is used to get a registers data and take actions when it changes




NEXT




<s> ret_t rtl8367c_setAsicFlowControlSharedJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SHARE_OFF, RTL8367C_FLOWCTRL_JUMBO_SHARE_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SHARE_ON, RTL8367C_FLOWCTRL_JUMBO_SHARE_ON_MASK, onThreshold);

return retVal;
}

The above function is used to set the jumbo frame shared threshold.

The below code snippet prints the output of rtl8367c_getPortJumboFrameThreshold() function.

// jumbo frame threshold printing

rt




NEXT




<s> mvswitch_mangle_tx(struct net_device *dev, struct sk_buff *skb)
{
struct mvswitch_priv *priv;
char *buf = NULL;
u16 vid;

priv = dev->phy_ptr;
if (unlikely(!priv))
goto error;

if (unlikely(skb->len < 16))
goto error;

#ifdef HEADER_MODE
if (__vlan_hwaccel_get_tag(skb, &vid))
goto error;

if (skb_cloned(skb) || (skb->len <= 62) || (skb_headroom(skb) < MV_HEADER_SIZE)) {
if (pskb_expand_head(skb, MV_HEADER_SIZE, (skb->len < 62 ? 62 - skb->len : 0), GFP_ATOMIC))
goto error_expand;
if (skb->len < 62)
skb->len = 62;
}
buf = skb_push(skb, MV_HEADER_SIZE);
#else
if (__vlan_get_tag(skb, &vid))
goto error;

if (unlikely((vid > 15 || !priv->vlans[vid])))
goto error;

if (skb->len <= 64) {
if (pskb_expand_head(skb, 0, 64 + MV_TRAILER_SIZE - skb->len, GFP_ATOMIC))
goto error_expand;

buf = skb->data + 64;
skb->len = 64 + MV_TRAILER_SIZE;
} else {
if (skb_cloned(skb) || unlikely(skb_tailroom(skb) < 4)) {
if (pskb_expand_head(skb, 0, 4, GFP_ATOMIC))
goto error_expand;
}
buf = skb_put(skb, 4);
}

/* move the ethernet header 4 bytes forward, overwriting the vlan tag */
memmove(skb->data + 4, skb->data, 12);
skb->data += 4;
skb->len -= 4;
skb->mac_header += 4;
#endif

if (!buf)
goto error;


#ifdef HEADER_MODE
/* prepend the tag */
*((__be16 *) buf) = cpu_to_be16(
((vid << MV_HEADER_VLAN_S) & MV_HEADER_VLAN_M) |
((priv->vlans[vid] << MV_HEADER_PORTS_S) & MV_HEADER_PORTS_M)
);
#else
/* append the tag */
*((__be32 *) buf) = cpu_to_be32((
(MV_TRAILER_OVERRIDE << MV_TRAILER_FLAGS_S) |
((priv->vlans[vid] & MV_TRAILER_PORTS_M) << MV_TRAILER_PORTS_S)
));
#endif

return skb;

error_expand:
if (net_ratelimit())
printk("%s: failed to expand/update skb for the switch\n", dev->name);

error:
/* any errors? drop the packet! */
dev_kfree_skb_any(skb);
return NULL;
}

The above function is used to place the header or trailer depending on Header or Trailer mode. This code is used for outgoing packets and is executed in a fastpath context.

There were a few differences between my code and the above. The first being that there is




NEXT




<s> static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to return the link rate of the current transmitter
The parameter is the transmitter id , ranging from 0 to 3
If you have 4 transmitters, please fill in the contents as:0x0000000




NEXT




<s> r16(struct adm6996_priv *priv, enum admreg reg)
{
return priv->read(priv, reg);
}

The above function is used to read from ADM6996 registers. Since the registers are mapped to GPIO ports. As we can see the function has a reg variable which takes value from 0 to 7 so we have to connect those GPIOs to our MCU




NEXT




<s> static int b53_phy_read16(struct switch_dev *dev, int addr, u8 reg, u16 *value)
{
struct b53_device *priv = sw_to_b53(dev);

if (priv->ops->phy_read16)
return priv->ops->phy_read16(priv, addr, reg, value);

return b53_read16(priv, B53_PORT_MII_PAGE(addr), reg, value);
}

The above function is used to read a 16-bit value from the MII register.</s>




NEXT




<s> led_cdev_to_ar8327_led(struct led_classdev *led_cdev)
{
return container_of(led_cdev, struct ar8327_led, cdev);
}

The above function is used to get the pointer to the struct ar8327_led
struct, which contains the pointers to the functions used to get/set the
current
brightness and to get/set the status of the led.

The




NEXT




<s> static int rtl8366rb_sw_get_port_link(struct switch_dev *dev,
int port,
struct switch_port_link *link)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data = 0;
u32 speed;

if (port >= RTL8366RB_NUM_PORTS)
return -EINVAL;

rtl8366_smi_read_reg(smi, RTL8366RB_PORT_LINK_STATUS_BASE + (port / 2),
&data);

if (port % 2)
data = data >> 8;

link->link = !!(data & RTL8366RB_PORT_STATUS_LINK_MASK);
if (!link->link)
return 0;

link->duplex = !!(data & RTL8366RB_PORT_STATUS_DUPLEX_MASK);
link->rx_flow = !!(data & RTL8366RB_PORT_STATUS_RXPAUSE_MASK);
link->tx_flow = !!(data & RTL8366RB_PORT_STATUS_TXPAUSE_MASK);
link->aneg = !!(data & RTL8366RB_PORT_STATUS_AN_MASK);

speed = (data & RTL8366RB_PORT_STATUS_SPEED_MASK);
switch (speed) {
case 0:
link->speed = SWITCH_PORT_SPEED_10;
break;
case 1:
link->speed = SWITCH_PORT_SPEED_100;
break;
case 2:
link->speed = SWITCH_PORT_SPEED_1000;
break;
default:
link->speed = SWITCH_PORT_SPEED_UNKNOWN;
break;
}

return 0;
}

The above function is used to read status on switch to get port-link status and related information such status, speed, and duplex etc..

It first read RTL8366RB_PORT_LINK_STATUS_BASE regsiter. For example,




NEXT




<s> swconfig_destroy_led_trigger(struct switch_dev *swdev) { }

The above function is used to destroy the default LED triggered defined in swconfig.

If you wanted to implement a 4097 LED system using 3 switch chips controlled by muxer and have one led trigger per LED you need only modify the above function slightly




NEXT




<s> static void aw9523_irq_mask(struct irq_data *d)
{
struct aw9523 *awi = gpiochip_get_data(irq_data_get_irq_chip_data(d));
unsigned int n = d->hwirq % AW9523_PINS_PER_PORT;

regmap_update_bits(awi->regmap,
AW9523_REG_INTR_DIS(d->hwirq),
BIT(n), BIT(n));
}

The above function is used to set a bit when an interrupt is disabled. In fact, the interrupt source should be disabled.

When aw9523_setup(struct irq_data *d, const struct irq_domain *h) is called, the IR




NEXT




<s> wrg_fix_md5(struct wrg_header *shdr, int fd, size_t data_offset, size_t data_size)
{
char *buf;
ssize_t res;
MD5_CTX ctx;
unsigned char digest[16];
int i;
int err = 0;

buf = malloc(data_size);
if (!buf) {
err = -ENOMEM;
goto err_out;
}

res = pread(fd, buf, data_size, data_offset);
if (res != data_size) {
perror("pread");
err = -EIO;
goto err_free;
}

MD5_Init(&ctx);
MD5_Update(&ctx, (char *)&shdr->offset, sizeof(shdr->offset));
MD5_Update(&ctx, (char *)&shdr->devname, sizeof(shdr->devname));
MD5_Update(&ctx, buf, data_size);
MD5_Final(digest, &ctx);

if (!memcmp(digest, shdr->digest, sizeof(digest))) {
if (quiet < 2)
fprintf(stderr, "the header is fixed already\n");
return -1;
}

if (quiet < 2) {
fprintf(stderr, "new size: %u, new MD5: ", data_size);
for (i = 0; i < sizeof(digest); i++)
fprintf(stderr, "%02x", digest[i]);

fprintf(stderr, "\n");
}

/* update the size in the image */
shdr->size = cpu_to_le32(data_size);

/* update the checksum in the image */
memcpy(shdr->digest, digest, sizeof(digest));

err_free:
free(buf);
err_out:
return err;
}

The above function is used to verify the md5 of user's image. If it is incorrect, then call the following function to repair it.

/* Fix the MD5 of the image by using a new data block provided by user.
 */
static WRN




NEXT




<s> static int rtl8367_init_regs1(struct rtl8366_smi *smi, unsigned mode)
{
const struct rtl8367_initval *initvals;
int count;

switch (mode) {
case 0:
initvals = rtl8367_initvals_1_0;
count = ARRAY_SIZE(rtl8367_initvals_1_0);
break;

case 1:
case 2:
initvals = rtl8367_initvals_1_1;
count = ARRAY_SIZE(rtl8367_initvals_1_1);
break;

default:
dev_err(smi->parent, "%s: unknow mode %u\n", __func__, mode);
return -ENODEV;
}

return rtl8367_write_initvals(smi, initvals, count);
}

The above function is used to copy the initial values of the various registers of the RTL8366 chip that you can see from the rtl8367_initvals_1_0[] and rtl8367_initvals_1_




NEXT




<s> static int show_matching_key_value(struct tffs_key_name_table *key_names)
{
struct tffs_entry tmp;
const char *name;

for (uint32_t i = 0; i < key_names->size; i++) {
name = key_names->entries[i].val;

if (strcmp(name, name_filter) == 0) {
if (find_entry(key_names->entries[i].id, &tmp)) {
print_entry_value(&tmp);
printf("\n");
free(tmp.val);
return EXIT_SUCCESS;
} else {
fprintf(stderr,
"ERROR: no value found for name %s!\n",
name);
return EXIT_FAILURE;
}
}
}

fprintf(stderr, "ERROR: Unknown key name %s!\n", name_filter);
return EXIT_FAILURE;
}

The above function is used to locate all keys matching key_names.
The only requirement for an entry to be displayed is that the key matching
name_filter value for that entry should exists in the search result. The
function returns EXIT_SUCCESS, if this condition




NEXT




<s> ret_t rtl8367c_getAsicQueueType(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 *queueType)
{
ret_t retVal;

/* Invalid input parameter */
if(port  > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;

retVal = rtl8367c_getAsicRegBit(RTL8367C_SCHEDULE_QUEUE_TYPE_REG(port), RTL8367C_SCHEDULE_QUEUE_TYPE_OFFSET(port, qid),queueType);

return retVal;
}

The above function is used to get queue type of the specific port/queue ID.

The following table shows the QType's value, which can be set using the function rtl8367c_getAsicQueueType().

QType Description




NEXT




<s> static int qca807x_set_tunable(struct phy_device *phydev,
struct ethtool_tunable *tuna, const void *data)
{
switch (tuna->id) {
case ETHTOOL_PHY_DOWNSHIFT:
return qca807x_set_downshift(phydev, *(const u8 *)data);
default:
return -EOPNOTSUPP;
}
}

The above function is used to set tunable parameter. This particular function is used to set PHY downshift tunable. In this function, we first get the device information of the phy device. Below is the API that has been used in order to get the PHY




NEXT




<s> int AT91F_DataFlashRead(
AT91PS_DataFlash pDataFlash,
unsigned long addr,
unsigned long size,
char *buffer)
{
unsigned long SizeToRead;

AT91F_SpiEnable(pDataFlash->pDevice->cs);

if(AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_DATAFLASH_TIMEOUT) != AT91C_DATAFLASH_OK)
return -1;

while (size)
{
SizeToRead = (size < 0x8000)? size:0x8000;

if (AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_DATAFLASH_TIMEOUT)
!= AT91C_DATAFLASH_OK)
return -1;

if (AT91F_DataFlashContinuousRead (pDataFlash, addr, (unsigned char *)buffer,
SizeToRead) != AT91C_DATAFLASH_OK)
return -1;

size -= SizeToRead;
addr += SizeToRead;
buffer += SizeToRead;
}

return AT91C_DATAFLASH_OK;
}

The above function is used to transfer data from DataFlash chip to processor memory. It uses continuous read functionality of the chip.

The DataFlash memory chip is an NOR-type non volatile memory similar to Flash memory that is used in memory cards used with digital




NEXT




<s> ret_t rtl8367c_getAsicCputagPosition(rtk_uint32* pPostion)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_POSITION_OFFSET, pPostion);
}

The above function is used to retrieve CPU tag position from the register RTL8367C_REG_CPU_CTRL. The macro definition of register is RTL8367C_REG_CPU_CTRL, and the bit offset is indicated by the R




NEXT




<s> static int __init mtdsplit_jimage_init(void)
{
register_mtd_parser(&jimage_generic_parser);

return 0;
}

The above function is used to run when kernel boots.

static int __exit mtdsplit_jimage_exit(

v

static int __init mtdsplit_jimage_init(

The above function is used to run when kernel boots




NEXT




<s> static int clk_mt7988_sgmii0_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(ARRAY_SIZE(sgmii0_clks));

if (!clk_data)
return -ENOMEM;

mtk_clk_register_gates(node, sgmii0_clks, ARRAY_SIZE(sgmii0_clks),
clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_data;
}
return r;

free_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to probing clock which needs to be configured during run-time.

This function returns a struct device and a pointer to it on each call to the driver when the device has changed state.

This function is called every time the state of




NEXT




<s> ret_t rtl8367c_getAsicMaxTotalPage(rtk_uint32 *pPageCount)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_TOTAL_PAGE_MAX, RTL8367C_FLOWCTRL_TOTAL_PAGE_MAX_MASK, pPageCount);
}

The above function is used to get the maximum available pages in the asic. I see this call is required in case where the number of entries in one page or any entry is more than 16. If the maximum free page does not satisfy the entry requirement it will return




NEXT




<s> static void rtl838x_init_eee(struct rtl838x_switch_priv *priv, bool enable)
{
pr_info("Setting up EEE, state: %d\n", enable);
sw_w32_mask(0x4, 0, RTL838X_SMI_GLB_CTRL);

/* Set timers for EEE */
sw_w32(0x5001411, RTL838X_EEE_TX_TIMER_GIGA_CTRL);
sw_w32(0x5001417, RTL838X_EEE_TX_TIMER_GELITE_CTRL);

/* Enable EEE MAC support on ports */
for (int i = 0; i < priv->cpu_port; i++) {
if (priv->ports[i].phy)
rtl838x_port_eee_set(priv, i, enable);
}
priv->eee_enabled = enable;
}

The above function is used to enable/disable EEE on all ports. The RTL838X is able to configure EEE for specific port speeds, either gigabit, gigabit fiber, or 1000Base-T Ethernet.




NEXT




<s> static int block_load_image_ext4_os(void)
{
int err;

err = ext4_read_file(CONFIG_SPL_EXT4_LOAD_ARGS_NAME,
(void *)CONFIG_SYS_SPL_ARGS_ADDR, 0, 0);
if (err <= 0) {
return -1;
}

return block_load_image_ext4(CONFIG_SPL_EXT4_LOAD_KERNEL_NAME);
}

The above function is used to read the file at the root path from the
ext4 file system. It is called by the function 'block_load_image_ext4'
which is used to launch the kernel on the ext4 file system. If the
function




NEXT




<s> static int expr_compare_type(enum expr_type t1, enum expr_type t2)
{
if (t1 == t2)
return 0;
switch (t1) {
case E_LEQ:
case E_LTH:
case E_GEQ:
case E_GTH:
if (t2 == E_EQUAL || t2 == E_UNEQUAL)
return 1;
case E_EQUAL:
case E_UNEQUAL:
if (t2 == E_NOT)
return 1;
case E_NOT:
if (t2 == E_AND)
return 1;
case E_AND:
if (t2 == E_OR)
return 1;
case E_OR:
if (t2 == E_LIST)
return 1;
case E_LIST:
if (t2 == 0)
return 1;
default:
return -1;
}
printf("[%dgt%d?]", t1, t2);
return 0;
}

The above function is used to test whether to compare types are equal. An
equality type may mean equal, not equal or any comparison type (the first
character is >=, >, < or <=, the rest are the same). A negation type (after





NEXT




<s> uc_wpas_add_iface(uc_vm_t *vm, size_t nargs)
{
uc_value_t *info = uc_fn_arg(0);
uc_value_t *driver = ucv_object_get(info, "driver", NULL);
uc_value_t *ifname = ucv_object_get(info, "iface", NULL);
uc_value_t *bridge = ucv_object_get(info, "bridge", NULL);
uc_value_t *config = ucv_object_get(info, "config", NULL);
uc_value_t *ctrl = ucv_object_get(info, "ctrl", NULL);
struct wpa_interface iface;
int ret = -1;

if (ucv_type(info) != UC_OBJECT)
goto out;

iface = (struct wpa_interface){
.driver = "nl80211",
.ifname = ucv_string_get(ifname),
.bridge_ifname = ucv_string_get(bridge),
.confname = ucv_string_get(config),
.ctrl_interface = ucv_string_get(ctrl),
};

if (driver) {
const char *drvname;
if (ucv_type(driver) != UC_STRING)
goto out;

iface.driver = NULL;
drvname = ucv_string_get(driver);
for (int i = 0; wpa_drivers[i]; i++) {
if (!strcmp(drvname, wpa_drivers[i]->name))
iface.driver = wpa_drivers[i]->name;
}

if (!iface.driver)
goto out;
}

if (!iface.ifname || !iface.confname)
goto out;

ret = wpa_supplicant_add_iface(wpa_global, &iface, 0) ? 0 : -1;
wpas_ucode_update_interfaces();

out:
return ucv_int64_new(ret);
}

The above function is used to register the network interface.

# 5.1. Initializing Network Interfaces

To initialize network cards, add a new value to the wpa_supplicant module data under the `interface->flags field` of the `




NEXT




<s> static bool seil_bootdev_is_active(struct device_node *np)
{
struct mtd_info *env_mtd;
char *buf, *var, *value, *eq;
const char *devnm;
size_t rdlen;
int ret;

/*
* read bootdev name of the partition
* if doesn't exist, return true and skip checking of active device
*/
ret = of_property_read_string(np, "iij,bootdev-name", &devnm);
if (ret == -EINVAL)
return true;
else if (ret < 0)
return false;

env_mtd = get_mtd_device_nm(LDR_ENV_PART_NAME);
if (IS_ERR(env_mtd)) {
pr_err("failed to get mtd device \"%s\"", LDR_ENV_PART_NAME);
return false;
}

buf = vmalloc(env_mtd->size);
if (!buf)
return false;

ret = mtd_read(env_mtd, 0, env_mtd->size, &rdlen, buf);
if (ret || rdlen != env_mtd->size) {
pr_err("failed to read from mtd (%d)\n", ret);
ret = 0;
goto exit_vfree;
}

for (var = buf, ret = false;
var < buf + env_mtd->size && *var;
var = value + strlen(value) + 1) {
eq = strchr(var, '=');
if (!eq)
break;
*eq = '\0';
value = eq + 1;

pr_debug("ENV: %s=%s\n", var, value);
if (!strcmp(var, LDR_ENV_KEY_BOOTDEV)) {
ret = !strcmp(devnm, value);
break;
}
}

exit_vfree:
vfree(buf);

return ret;
}

The above function is used to parse bootdev string, and compare it with the
device name specified in of device tree. If bootdev is specified as something
different than this device tree device name or even disabled by setting
*bootdev* to null, the boot




NEXT




<s> ret_t rtl8367c_getAsicEavInterruptStatus(rtk_uint32* pIms)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_PTP_INTERRUPT_CFG, RTL8367C_PTP_PORT_MASK, pIms);
}

The above function is used to get the EAV interrupt status. However, I have a doubt about the second parameter of rtl8367c_getAsicRegBits. Let's say that second parameter is equal to 0, this means that the bits




NEXT




<s> static int jffs2_find_file(struct mtd_info *mtd, uint8_t *buf,
const char *name, size_t name_len,
loff_t *offs, loff_t size,
char **out_name, size_t *out_name_len)
{
const loff_t end = *offs + size;
struct jffs2_raw_dirent *node;
bool valid = false;
size_t retlen;
uint16_t magic;
int rc;

for (; *offs < end; *offs += mtd->erasesize) {
unsigned int block_offs = 0;

/* Skip CFE erased blocks */
rc = mtd_read(mtd, *offs, sizeof(magic), &retlen,
(void *) &magic);
if (rc || retlen != sizeof(magic)) {
continue;
}

/* Skip blocks not starting with JFFS2 magic */
if (magic != JFFS2_MAGIC_BITMASK)
continue;

/* Read full block */
rc = mtd_read(mtd, *offs, mtd->erasesize, &retlen,
(void *) buf);
if (rc)
return rc;
if (retlen != mtd->erasesize)
return -EINVAL;

while (block_offs < mtd->erasesize) {
node = (struct jffs2_raw_dirent *) &buf[block_offs];

if (!jffs2_dirent_valid(node)) {
block_offs += 4;
continue;
}

if (!memcmp(node->name, OPENWRT_NAME,
OPENWRT_NAME_LEN)) {
valid = true;
} else if (!memcmp(node->name, name, name_len)) {
if (!valid)
return -EINVAL;

if (out_name)
*out_name = kstrndup(node->name,
node->nsize,
GFP_KERNEL);

if (out_name_len)
*out_name_len = node->nsize;

return 0;
}

block_offs += je32_to_cpu(node->totlen);
block_offs = (block_offs + 0x3) & ~0x3;
}
}

return -ENOENT;
}

The above function is used to find a file with the given mtd_info struct, the location of the file in the mtd_info struct
(offs variable), the size of the file (size variable), the name of the file (name variable), and the name




NEXT




<s> adm6996_apply_port_pvids(struct adm6996_priv *priv)
{
u16 reg;
int i;

for (i = 0; i < ADM_NUM_PORTS; i++) {
reg = r16(priv, adm_portcfg[i]);
reg &= ~(ADM_PORTCFG_PVID_MASK);
reg |= ADM_PORTCFG_PVID(priv->pvid[i]);
if (priv->model == ADM6996L) {
if (priv->tagged_ports & (1 << i))
reg |= (1 << 4);
else
reg &= ~(1 << 4);
}
w16(priv, adm_portcfg[i], reg);
}

w16(priv, ADM_P0_PVID, ADM_P0_PVID_VAL(priv->pvid[0]));
w16(priv, ADM_P1_PVID, ADM_P1_PVID_VAL(priv->pvid[1]));
reg = r16(priv, ADM_OTBE_P2_PVID);
reg &= ~(ADM_P2_PVID_MASK);
reg |= ADM_P2_PVID_VAL(priv->pvid[2]);
w16(priv, ADM_OTBE_P2_PVID, reg);
reg = ADM_P3_PVID_VAL(priv->pvid[3]);
reg |= ADM_P4_PVID_VAL(priv->pvid[4]);
w16(priv, ADM_P3_P4_PVID, reg);
reg = r16(priv, ADM_P5_PVID);
reg &= ~(ADM_P2_PVID_MASK);
reg |= ADM_P5_PVID_VAL(priv->pvid[5]);
w16(priv, ADM_P5_PVID, reg);
}

The above function is used to apply the correct PVID to all the ports. This function does not need an argument, but to pass along the address of the struct priv.

To configure the ports, you will call config_ports() in port_ops->setup().




NEXT




<s> struct expr *expr_alloc_one(enum expr_type type, struct expr *ce)
{
struct expr *e = xcalloc(1, sizeof(*e));
e->type = type;
e->left.expr = ce;
return e;
}

The above function is used to allocate an expression tree of a single child node. However the type of the function is wrongly written as `enum expr_type *type` instead of `enum expr_type type`. The consequence of this code error was it caused a double free




NEXT




<s> static int rtl8366_mc_is_used(struct rtl8366_smi *smi, int mc_index, int *used)
{
int err;
int i;

*used = 0;
for (i = 0; i < smi->num_ports; i++) {
int index = 0;

err = smi->ops->get_mc_index(smi, i, &index);
if (err)
return err;

if (mc_index == index) {
*used = 1;
break;
}
}

return 0;
}

The above function is used to find out if the MAC address is actually in
use on the particular interface. This might get executed quite a few times
so it should be light on the wire. Also, the code is not very complex
anymouth, so it does




NEXT




<s> mtd_erase(const char *mtd)
{
int fd;
struct erase_info_user mtdEraseInfo;

if (quiet < 2)
fprintf(stderr, "Erasing %s ...\n", mtd);

fd = mtd_check_open(mtd);
if(fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd);
exit(1);
}

mtdEraseInfo.length = erasesize;

for (mtdEraseInfo.start = 0;
mtdEraseInfo.start < mtdsize;
mtdEraseInfo.start += erasesize) {
if (mtd_block_is_bad(fd, mtdEraseInfo.start)) {
if (!quiet)
fprintf(stderr, "\nSkipping bad block at 0x%x   ", mtdEraseInfo.start);
} else {
ioctl(fd, MEMUNLOCK, &mtdEraseInfo);
if(ioctl(fd, MEMERASE, &mtdEraseInfo))
fprintf(stderr, "Failed to erase block on %s at 0x%x\n", mtd, mtdEraseInfo.start);
}
}

close(fd);
return 0;

}

The above function is used to erase the mtd partitions. It takes the name of the partition and proceeds with the erasing. The code can be seen here.

It is useful to erase the partition before writing to it. I mean when you re




NEXT




<s> ret_t rtl8367c_setAsicOamMultiplexer(rtk_uint32 port, rtk_uint32 multiplexer)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(multiplexer > OAM_MULCPU)
return RT_ERR_NOT_ALLOWED;

return rtl8367c_setAsicRegBits(RTL8367C_REG_OAM_MULTIPLEXER_CTRL0 + port/8, RTL8367C_OAM_MULTIPLEXER_MASK(port%8), multiplexer);
}

The above function is used to set multiplexor for specific port, to configure it please use the below function.

rtk_int32 oam_multiplexer_port_set(rtk_uint32 port_index,rtk_uint




NEXT




<s> static int fit_image_get_data(const void *fit, int noffset,
const void **data, size_t *size)
{
int len;

*data = fdt_getprop(fit, noffset, FIT_DATA_PROP, &len);
if (*data == NULL) {
*size = 0;
return -1;
}

*size = len;
return 0;
}

The above function is used to get the start address of an image section, to
load the data into memory.  It seems a bit wasteful to allocate the buffer
and use strlen to get the length.  Any suggestions for improving it?

Thank you,





NEXT




<s> static int mt7621_ecc_decoder_wait_done(struct mt7621_nfc *nfc, u32 sect)
{
struct device *dev = nfc->dev;
u32 val;
int ret;

ret = readw_poll_timeout_atomic(nfc->ecc_regs + ECC_DECDONE, val,
val & (1 << sect), 10,
ECC_ENGINE_TIMEOUT);

if (ret) {
dev_warn(dev, "ECC decoder for sector %d timed out\n",
sect);
return -ETIMEDOUT;
}

return 0;
}

The above function is used to wait for the decoder operation of the ECC engine to complete. If the ECC decoder operation of the specified sector times out, an error will occur and the function will return a negative value.
The ECC engine is a hardware module




NEXT




<s> ret_t rtl8367c_setAsicLutFlushFid(rtk_uint32 fid)
{
if( fid > RTL8367C_FIDMAX )
return RT_ERR_L2_FID;

return rtl8367c_setAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL1, RTL8367C_LUT_FLUSH_FID_MASK, fid);
}

The above function is used to set the fid value in the LUT Flush Control Register (L2_FLUSH_CTRL1),

It seems that the code is not handling fid > RTL8367C_FIDMAX properly so it seems to




NEXT




<s> rtk_api_ret_t rtk_trunk_distributionAlgorithm_set(rtk_trunk_group_t trk_gid, rtk_uint32 algo_bitmask)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (trk_gid != RTK_WHOLE_SYSTEM)
return RT_ERR_LA_TRUNK_ID;

if (algo_bitmask >= 128)
return RT_ERR_LA_HASHMASK;

if ((retVal = rtl8367c_setAsicTrunkingHashSelect(algo_bitmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set trunk distribution algorithm. It is set by default according to trunk id to be used for fast tracking.
This function set trunk group distribution algorithm.</s>




NEXT




<s> static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to push OAM cells in kernel space for CCIQ.
#endif
#if !defined(CONFIG_IFX_OAM_MODIFICATION)
extern void ifx_process_cell(void *);
#else




NEXT




<s> adm6996_hw_apply(struct switch_dev *dev)
{
struct adm6996_priv *priv = to_adm(dev);

pr_devel("hw_apply\n");

mutex_lock(&priv->reg_mutex);

if (!priv->enable_vlan) {
if (priv->vlan_enabled) {
if (priv->model == ADM6996L)
adm6996_disable_vlan_6996l(priv);
else
adm6996_disable_vlan(priv);
priv->vlan_enabled = 0;
}
goto out;
}

if (!priv->vlan_enabled) {
if (priv->model == ADM6996L)
adm6996_enable_vlan_6996l(priv);
else
adm6996_enable_vlan(priv);
priv->vlan_enabled = 1;
}

adm6996_apply_port_pvids(priv);
if (priv->model == ADM6996L)
adm6996_apply_vlan_filters_6996l(priv);
else
adm6996_apply_vlan_filters(priv);

out:
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to apply the settings that are determined by the rules from vlan rules.

Now when we apply the settings as set in the rules, we need to ensure that we have the required rules defined. Below is the code from adm6996




NEXT




<s> rtk_api_ret_t rtk_cpu_tagLength_set(rtk_cpu_tag_length_t length)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (length >= CPU_LEN_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicCputagMode(length)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the maximum frame length in the CPU buffer
which means that if the value is set to CPU_LEN_0, the CPU is used in the 0-to-1
mode, which can accept any frame; this is the default




NEXT




<s> rtl_attr_get_port_int(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
if (val->port_vlan >= RTL8306_NUM_PORTS)
return -EINVAL;
return rtl_attr_get_int(dev, attr, val);
}

The above function is used to read the port VLAN, with the limitation being port 8 - 15, we currently don't have to worry about.

The below code is from switch.c, which is called by the rtl_handle_set




NEXT




<s> const char *menu_get_help(struct menu *menu)
{
if (menu->help)
return menu->help;
else
return "";
}

The above function is used to retrieve the string of help text the menu might want to supply to the user.  If the string found is blank, it is assumed the menu item has no help text.  It is a common practice of certain programs (e.g. g




NEXT




<s> static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to call read() from cfront.cpp:
static int readyy ( yy_buffer_state * yy_buffer)
{
yy_buffer->yy_ch_buf = yytext_ptr = YY_NULL;
*




NEXT




<s> void ubus_deinit() {
if (!ctx)
return;

ubus_free(ctx);
uloop_done();

DSL_CPE_ThreadShutdown(&thread, 1000);
}

The above function is used to shutdown the device.

Now, I want to use the following function to connect from a remote host where I can enter a password and get access to the device:

int ubus_connect(char *url, char *token




NEXT




<s> static int clk_mt7981_infracfg_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;
int nr = ARRAY_SIZE(infra_divs) + ARRAY_SIZE(infra_muxes) +
ARRAY_SIZE(infra_clks);

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(nr);

if (!clk_data)
return -ENOMEM;

mtk_clk_register_factors(infra_divs, ARRAY_SIZE(infra_divs), clk_data);
mtk_clk_register_muxes(infra_muxes, ARRAY_SIZE(infra_muxes), node,
&mt7981_clk_lock, clk_data);
mtk_clk_register_gates(node, infra_clks, ARRAY_SIZE(infra_clks),
clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_infracfg_data;
}
return r;

free_infracfg_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to register the clock with the platform and register it with drivers that are using the clock.

To use this clock in the device tree, we use of_clk.clks property as below -

    clk_pwrg0c




NEXT




<s> static void describe_mode(standard_t standard, profile_t profile, vector_t vector) {
char buf[128];

switch (standard) {
case STD_T1_413:
strcpy(buf, "T1.413");
break;
case STD_TS_101_388:
strcpy(buf, "TS 101 388");
break;
case STD_G_992_1:
strcpy(buf, "G.992.1 (ADSL)");
break;
case STD_G_992_2:
strcpy(buf, "G.992.2 (ADSL lite)");
break;
case STD_G_992_3:
strcpy(buf, "G.992.3 (ADSL2)");
break;
case STD_G_992_4:
strcpy(buf, "G.992.4 (ADSL2 lite)");
break;
case STD_G_992_5:
strcpy(buf, "G.992.5 (ADSL2+)");
break;
case STD_G_993_1:
strcpy(buf, "G.993.1 (VDSL)");
break;
case STD_G_993_2:
strcpy(buf, "G.993.2 (VDSL2");

switch (profile) {
case PROFILE_8A:
strcat(buf, ", Profile 8a");
break;
case PROFILE_8B:
strcat(buf, ", Profile 8b");
break;
case PROFILE_8C:
strcat(buf, ", Profile 8c");
break;
case PROFILE_8D:
strcat(buf, ", Profile 8d");
break;
case PROFILE_12A:
strcat(buf, ", Profile 12a");
break;
case PROFILE_12B:
strcat(buf, ", Profile 12b");
break;
case PROFILE_17A:
strcat(buf, ", Profile 17a");
break;
case PROFILE_30A:
strcat(buf, ", Profile 30a");
break;
case PROFILE_35B:
strcat(buf, ", Profile 35b");
break;
default:
break;
};

switch (vector) {
case VECTOR_ON_DS:
strcat(buf, ", with downstream vectoring");
break;
case VECTOR_ON_DS_US:
strcat(buf, ", with down- and upstream vectoring");
break;
default:
break;
};

strcat(buf, ")");
break;
default:
return;
};

m_str("mode", buf);
}

The above function is used to describe the operating mode of the ADSL modem in the "Info" panel (see Figure).

We need to add a few more lines to our ADSL modem code so that we can generate the correct "Info" panel:





NEXT




<s> ret_t rtl8367c_getAsicEavPriRemapping(rtk_uint32 srcpriority, rtk_uint32 *pPriority)
{
if(srcpriority > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_getAsicRegBits(RTL8367C_EAV_PRIORITY_REMAPPING_REG(srcpriority), RTL8367C_EAV_PRIORITY_REMAPPING_MASK(srcpriority),pPriority);
}

The above function is used to read the EAV PRIORITY remapping table. It is implemented at both S/W and H/W.
The priority will be used as source priority to query the corresponding result in the EAVPRI Priority remapping table.




NEXT




<s> static int rtl8226_set_eee(struct phy_device *phydev, struct ethtool_eee *e)
{
int port = phydev->mdio.addr;
u64 poll_state;
bool an_enabled;
u32 val;

pr_info("In %s, port %d, enabled %d\n", __func__, port, e->eee_enabled);

poll_state = disable_polling(port);

/* Remember aneg state */
val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1);
an_enabled = !!(val & MDIO_AN_CTRL1_ENABLE);

/* Setup 100/1000MBit */
val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
if (e->eee_enabled)
val |= (MDIO_EEE_100TX | MDIO_EEE_1000T);
else
val &= (MDIO_EEE_100TX | MDIO_EEE_1000T);
phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, val);

/* Setup 2.5GBit */
val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV2);
if (e->eee_enabled)
val |= MDIO_EEE_2_5GT;
else
val &= MDIO_EEE_2_5GT;
phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV2, val);

/* RestartAutoNegotiation */
val = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xA400);
val |= MDIO_AN_CTRL1_RESTART;
phy_write_mmd(phydev, MDIO_MMD_VEND2, 0xA400, val);

resume_polling(poll_state);

return 0;
}

The above function is used to configure the ports for enhanced energy efficiency(EEE).</s>




NEXT




<s> static int rtl930x_pie_verify_template(struct rtl838x_switch_priv *priv,
struct pie_rule *pr, int t, int block)
{
int i;

if (!pr->is_ipv6 && pr->sip_m && !rtl930x_pie_templ_has(t, TEMPLATE_FIELD_SIP0))
return -1;

if (!pr->is_ipv6 && pr->dip_m && !rtl930x_pie_templ_has(t, TEMPLATE_FIELD_DIP0))
return -1;

if (pr->is_ipv6) {
if ((pr->sip6_m.s6_addr32[0] ||
pr->sip6_m.s6_addr32[1] ||
pr->sip6_m.s6_addr32[2] ||
pr->sip6_m.s6_addr32[3]) &&
!rtl930x_pie_templ_has(t, TEMPLATE_FIELD_SIP2))
return -1;
if ((pr->dip6_m.s6_addr32[0] ||
pr->dip6_m.s6_addr32[1] ||
pr->dip6_m.s6_addr32[2] ||
pr->dip6_m.s6_addr32[3]) &&
!rtl930x_pie_templ_has(t, TEMPLATE_FIELD_DIP2))
return -1;
}

if (ether_addr_to_u64(pr->smac) && !rtl930x_pie_templ_has(t, TEMPLATE_FIELD_SMAC0))
return -1;

if (ether_addr_to_u64(pr->dmac) && !rtl930x_pie_templ_has(t, TEMPLATE_FIELD_DMAC0))
return -1;

/* TODO: Check more */

i = find_first_zero_bit(&priv->pie_use_bm[block * 4], PIE_BLOCK_SIZE);

if (i >= PIE_BLOCK_SIZE)
return -1;

return i + PIE_BLOCK_SIZE * block;
}

The above function is used to verify the rules added to the action templates. The rule are verified with two main verification points the first is the direction of the rules which is either L4 or L2 with the latter having an even number of L3 template. The second point is




NEXT




<s> ret_t rtl8367c_setAsicAclAct(rtk_uint32 index, rtl8367c_acl_act_t* pAclAct)
{
rtk_uint16 aclActSmi[RTL8367C_ACL_ACT_TABLE_LEN];
ret_t retVal;
rtk_uint32 regAddr, regData;
rtk_uint16* tableAddr;
rtk_uint32 i;

if(index > RTL8367C_ACLRULEMAX)
return RT_ERR_OUT_OF_RANGE;

memset(aclActSmi, 0x00, sizeof(rtk_uint16) * RTL8367C_ACL_ACT_TABLE_LEN);
_rtl8367c_aclActStUser2Smi(pAclAct, aclActSmi);

/* Write ACS_ADR register for data bits */
regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
regData = index;
retVal = rtl8367c_setAsicReg(regAddr, regData);
if(retVal != RT_ERR_OK)
return retVal;

/* Write Data Bits to ACS_DATA registers */
tableAddr = aclActSmi;
regAddr = RTL8367C_TABLE_ACCESS_WRDATA_BASE;

for(i = 0; i < RTL8367C_ACLACTTBLEN; i++)
{
regData = *tableAddr;
retVal = rtl8367c_setAsicReg(regAddr, regData);
if(retVal != RT_ERR_OK)
return retVal;

regAddr++;
tableAddr++;
}

/* Write ACS_CMD register for care bits*/
regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_WRITE, TB_TARGET_ACLACT);
retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK, regData);
if(retVal != RT_ERR_OK)
return retVal;

#ifdef CONFIG_RTL8367C_ASICDRV_TEST
memcpy(&Rtl8370sVirtualAclActTable[index][0], aclActSmi, sizeof(rtk_uint16) * RTL8367C_ACL_ACT_TABLE_LEN);
#endif

return RT_ERR_OK;
}

The above function is used to write the ACL ACT table to the ASIC.</s>




NEXT




<s> void rtl839x_traffic_enable(int source, int dest)
{
rtl839x_mask_port_reg_be(0, BIT_ULL(dest), rtl839x_port_iso_ctrl(source));
}

The above function is used to enable the traffic in the I/S/O direction in the specific port. (Source port)

But the port_iso_ctrl is not writable, we check the register table again. And we found out the port_iso_




NEXT




<s> ret_t rtl8367c_setAsicEgressFlowControlQueueDropGap(rtk_uint32 gap)
{
if(gap >= RTL8367C_PAGE_NUMBER)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_QUEUE_GAP, RTL8367C_FLOWCTRL_QUEUE_GAP_MASK, gap);
}

The above function is used to set Asic egressflow control queue drop gap. The default drop gap is 1, which means the queue number being dropped is continuous. if the gap is set as 3, the queue number being dropped are every 3.
The




NEXT




<s> static unsigned int get_num(char *str)
{
if (!strncmp("0x", str, 2))
return strtoul(str+2, NULL, 16);
else
return strtoul(str, NULL, 10);
}

The above function is used to convert an input string s, indicating a
number (either decimal or hex), to an unsigned long integer. It does
this by checking to see if the string begins with "0x" which means
its hexadecimal. If




NEXT




<s> ret_t rtl8367c_getAsicFlowControlPortThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_OFF, RTL8367C_FLOWCTRL_PORT_OFF_MASK, pOffThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_ON, RTL8367C_FLOWCTRL_PORT_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to get AsicFlowControlPortThreshold.
The error code that should be return RT_OK and not RT_ERR_OK when success.
But we find that, as is shown above, the error code RT_ERR_OK is returned




NEXT




<s> check_all_interfaces(void)
{
struct ead_instance *in;
struct list_head *p;

br_foreach_bridge(check_bridge, NULL);

/* look for interfaces that are no longer part of a bridge */
list_for_each(p, &instances) {
in = list_entry(p, struct ead_instance, list);

if (in->br_check) {
in->br_check = false;
} else if (in->bridge[0]) {
DEBUG(2, "removing port %s from bridge %s\n", in->ifname, in->bridge);
in->bridge[0] = 0;
stop_server(in, false);
}
}
}

The above function is used to re-check if any interface is currently being used by a bridge. It goes through all interfaces currently registered with br_add_instance and compares each one with known bridges. We mark all interfaces currently belonging to a bridge that is




NEXT




<s> void rtl83xx_fast_age(struct dsa_switch *ds, int port);
u32 rtl838x_get_egress_rate(struct rtl838x_switch_priv *priv, int port);
u32 rtl839x_get_egress_rate(struct rtl838x_switch_priv *priv, int port);
int rtl838x_set_egress_rate(struct rtl838x_switch_priv *priv, int port, u32 rate);
int rtl839x_set_egress_rate(struct rtl838x_switch_priv *priv, int port, u32 rate);


const char *rtl838x_drop_cntr[] = {
"ALE_TX_GOOD_PKTS", "MAC_RX_DROP", "ACL_FWD_DROP", "HW_ATTACK_PREVENTION_DROP",
"RMA_DROP", "VLAN_IGR_FLTR_DROP", "INNER_OUTER_CFI_EQUAL_1_DROP", "PORT_MOVE_DROP",
"NEW_SA_DROP", "MAC_LIMIT_SYS_DROP", "MAC_LIMIT_VLAN_DROP", "MAC_LIMIT_PORT_DROP",
"SWITCH_MAC_DROP", "ROUTING_EXCEPTION_DROP", "DA_LKMISS_DROP", "RSPAN_DROP",
"ACL_LKMISS_DROP", "ACL_DROP", "INBW_DROP", "IGR_METER_DROP",
"ACCEPT_FRAME_TYPE_DROP", "STP_IGR_DROP", "INVALID_SA_DROP", "SA_BLOCKING_DROP",
"DA_BLOCKING_DROP", "L2_INVALID_DPM_DROP", "MCST_INVALID_DPM_DROP", "RX_FLOW_CONTROL_DROP",
"STORM_SPPRS_DROP", "LALS_DROP", "VLAN_EGR_FILTER_DROP", "STP_EGR_DROP",
"SRC_PORT_FILTER_DROP", "PORT_ISOLATION_DROP", "ACL_FLTR_DROP", "MIRROR_FLTR_DROP",
"TX_MAX_DROP", "LINK_DOWN_DROP", "FLOW_CONTROL_DROP", "BRIDGE .1d discards"
};

The above function is used to calculate the ingress flow rate on a DSA switch.
It uses the port level configuration to compute the flow rate that is then passed
to the chip.

struct rtl838x_flow_info {
u3




NEXT




<s> BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)
{
BN_ULONG c=0;
BN_ULONG bl,bh;

assert(num >= 0);
if (num <= 0) return((BN_ULONG)0);

bl=LBITS(w);
bh=HBITS(w);

for (;;)
{
mul_add(rp[0],ap[0],bl,bh,c);
if (--num == 0) break;
mul_add(rp[1],ap[1],bl,bh,c);
if (--num == 0) break;
mul_add(rp[2],ap[2],bl,bh,c);
if (--num == 0) break;
mul_add(rp[3],ap[3],bl,bh,c);
if (--num == 0) break;
ap+=4;
rp+=4;
}
return(c);
}

The above function is used to double-digit add 16 times where the multiplier is only 2 byte long. We can use it to multiply with a big number with only 4 byte length. The function is almost equivalent to mul_add_words()




NEXT




<s> rtk_api_ret_t rtk_l2_ipMcastAddr_next_get(rtk_uint32 *pAddress, rtk_l2_ipMcastAddr_t *pIpMcastAddr)
{
rtk_api_ret_t   retVal;
rtl8367c_luttb  l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Error Checking */
if ((pAddress == NULL) || (pIpMcastAddr == NULL) )
return RT_ERR_INPUT;

if(*pAddress > RTK_MAX_LUT_ADDR_ID )
return RT_ERR_L2_L2UNI_PARAM;

memset(&l2Table, 0, sizeof(rtl8367c_luttb));
l2Table.address = *pAddress;

do
{
if ((retVal = rtl8367c_getAsicL2LookupTb(LUTREADMETHOD_NEXT_L3MC, &l2Table)) != RT_ERR_OK)
return retVal;

if(l2Table.address < *pAddress)
return RT_ERR_L2_ENTRY_NOTFOUND;

}while(l2Table.l3vidlookup == 1);

pIpMcastAddr->sip = l2Table.sip;
pIpMcastAddr->dip = l2Table.dip;

/* Get Logical port mask */
if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pIpMcastAddr->portmask)) != RT_ERR_OK)
return retVal;

pIpMcastAddr->priority      = l2Table.lut_pri;
pIpMcastAddr->fwd_pri_en    = l2Table.fwd_en;
pIpMcastAddr->igmp_asic     = l2Table.igmp_asic;
pIpMcastAddr->igmp_index    = l2Table.igmpidx;
pIpMcastAddr->address       = l2Table.address;
*pAddress = l2Table.address;

return RT_ERR_OK;
}

The above function is used to get the next IPv4 MMCC forwarding entry in the LUT database.

void rtk_l2_ipMcastAddr_get(rtk_uint32 *pAddress, rtk_l2_




NEXT




<s> static int b53_srab_write16(struct b53_device *dev, u8 page, u8 reg,
u16 value)
{
u8 __iomem *regs = dev->priv;
int ret = 0;

ret = b53_srab_request_grant(dev);
if (ret)
goto err;

writel(value, regs + B53_SRAB_WD_L);

ret = b53_srab_op(dev, page, reg, B53_SRAB_CMDSTAT_WRITE);

err:
b53_srab_release_grant(dev);

return ret;
}

The above function is used to write a 16-bit value to SRABs. The write is
synchronous, i.e. the CPU will wait until the write is complete.</s>




NEXT




<s> static int nmbn_read_data(struct nmbm_instance *ni, uint64_t addr, void *data,
uint32_t size)
{
uint64_t off = addr;
uint8_t *ptr = data;
uint32_t sizeremain = size, chunksize, leading;
int ret;

while (sizeremain) {
leading = off & (bmtd.pg_size - 1);
chunksize = bmtd.pg_size - leading;
if (chunksize > sizeremain)
chunksize = sizeremain;

if (chunksize == bmtd.pg_size) {
ret = nmbm_read_phys_page(ni, off - leading, ptr, NULL);
if (ret < 0)
return ret;
} else {
ret = nmbm_read_phys_page(ni, off - leading,
ni->page_cache, NULL);
if (ret < 0)
return ret;

memcpy(ptr, ni->page_cache + leading, chunksize);
}

off += chunksize;
ptr += chunksize;
sizeremain -= chunksize;
}

return 0;
}

The above function is used to read data from the device, at this level it
also does not care much if the data reads are from flash or main
memory.

Next:
[Top](http://lxr.free-electrons.com/source




NEXT




<s> static void pm_data_path_counters_total(int fd, DSL_XTUDir_t direction) {
IOCTL_DIR(DSL_PM_DataPathCountersTotal_t, DSL_FIO_PM_DATA_PATH_COUNTERS_TOTAL_GET, direction);

m_u32("hec", out.data.nHEC);
m_u32("ibe", out.data.nIBE);
m_u32("crc_p", out.data.nCRC_P);
m_u32("crcp_p", out.data.nCRCP_P);
m_u32("cv_p", out.data.nCV_P);
m_u32("cvp_p", out.data.nCVP_P);
}

The above function is used to print out the total number of headers received at the client end. The function is used in the above print_data_path() function in Section 4.11.2 to

print out counters relevant to a client for all data




NEXT




<s> static int sha1_hmac_final_impl(struct shash_desc *desc, u8 *out, bool hash_final);

/*! \fn static void sha1_hmac_transform(struct crypto_tfm *tfm, u32 const *in)
*  \ingroup IFX_SHA1_HMAC_FUNCTIONS
*  \brief save input block to context
*  \param tfm linux crypto algo transform
*  \param in 64-byte block of input
*/
static int sha1_hmac_transform(struct shash_desc *desc, u32 const *in)
{
struct sha1_hmac_ctx *sctx =  crypto_shash_ctx(desc->tfm);

if ( ((sctx->dbn<<4)+1) > SHA1_HMAC_DBN_TEMP_SIZE )
{
//printk("SHA1_HMAC_DBN_TEMP_SIZE exceeded\n");
sha1_hmac_final_impl(desc, (u8 *)sctx->hash, false);
}

memcpy(&sctx->temp[sctx->dbn], in, 64); //dbn workaround
sctx->dbn += 1;

return 0;
}

The above function is used to save a block of input to the context.

/*! \fn static int sha1_hmac_update(struct shash_desc *desc, const u8 * data, unsigned int len)
*  \ingroup IFX




NEXT




<s> static int count_sgs(struct scatterlist *sl, unsigned int total_bytes)
{
int i = 0;

do {
total_bytes -= sl[i].length;
i++;

} while (total_bytes > 0);

return i;
}

The above function is used to count the size of scatter list. But it doesn't take into consideration the case of contiguous memory pages. As shown below the size is counted only based on length of sl[] entry

Case (1): Size of sl[0




NEXT




<s> ret_t rtl8367c_getAsicPortBasedFidEn(rtk_uint32 port, rtk_uint32* pEnabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_REG_PORT_PBFIDEN,port, pEnabled);
}

The above function is used to check whether Port Based Filtering (FB) (PBFIDEN) is enable. If it is, there may have a port-based filtering entry in PBFIDT table.
There is a table below list the bits in P




NEXT




<s> static int rtl8367c_reset_mibs(void)
{
return rtk_stat_global_reset();
}

The above function is used to reset the global mibs on all ports that are configured. In the function if you carefully look you can see that there is a rtk_stat_global_reset() function called. On examining this function you will see that we need




NEXT




<s> struct rtl8366_smi *rtl8366_smi_alloc(struct device *parent)
{
struct rtl8366_smi *smi;

BUG_ON(!parent);

smi = kzalloc(sizeof(*smi), GFP_KERNEL);
if (!smi) {
dev_err(parent, "no memory for private data\n");
return NULL;
}

smi->parent = parent;
return smi;
}

The above function is used to allocate a smi for the SMI driver.
The smi is allocated using kzalloc. The smi variable is a pointer to a
struct, which is used to hold the private data for the SMI driver. This
private




NEXT




<s> uc_hostapd_iface_switch_channel(uc_vm_t *vm, size_t nargs)
{
struct hostapd_iface *iface = uc_fn_thisval("hostapd.iface");
uc_value_t *info = uc_fn_arg(0);
struct hostapd_config *conf;
struct csa_settings csa = {};
uint64_t intval;
int i, ret = 0;

if (!iface || ucv_type(info) != UC_OBJECT)
return NULL;

conf = iface->conf;
if ((intval = ucv_int64_get(ucv_object_get(info, "csa_count", NULL))) && !errno)
csa.cs_count = intval;
if ((intval = ucv_int64_get(ucv_object_get(info, "sec_channel", NULL))) && !errno)
csa.freq_params.sec_channel_offset = intval;

csa.freq_params.ht_enabled = conf->ieee80211n;
csa.freq_params.vht_enabled = conf->ieee80211ac;
csa.freq_params.he_enabled = conf->ieee80211ax;
#ifdef CONFIG_IEEE80211BE
csa.freq_params.eht_enabled = conf->ieee80211be;
#endif
intval = ucv_int64_get(ucv_object_get(info, "oper_chwidth", NULL));
if (errno)
intval = hostapd_get_oper_chwidth(conf);
if (intval)
csa.freq_params.bandwidth = 40 << intval;
else
csa.freq_params.bandwidth = csa.freq_params.sec_channel_offset ? 40 : 20;

if ((intval = ucv_int64_get(ucv_object_get(info, "frequency", NULL))) && !errno)
csa.freq_params.freq = intval;
if ((intval = ucv_int64_get(ucv_object_get(info, "center_freq1", NULL))) && !errno)
csa.freq_params.center_freq1 = intval;
if ((intval = ucv_int64_get(ucv_object_get(info, "center_freq2", NULL))) && !errno)
csa.freq_params.center_freq2 = intval;

for (i = 0; i < iface->num_bss; i++)
ret = hostapd_switch_channel(iface->bss[i], &csa);

return ucv_boolean_new(!ret);
}

The above function is used to switch channels and is called from the above module using the csa module.</s>




NEXT




<s> static int __init mtdsplit_brnimage_init(void)
{
register_mtd_parser(&mtdsplit_brnimage_parser);

return 0;
}

The above function is used to initialize the mtdsplit_brnimage module when the kernel starts up. It registers the
mtdsplit_brnimage parser function with the MTD framework, which allows the module to be used by other MTD-aware
devices




NEXT




<s> static int igmp_show(struct seq_file *seq, void *v)
{
return 0;
}

The above function is used to show the contents of structure defined by
Igmp_rx in the following section.It shows the information about all the igmp
multicast packets received or processed.
static int igmp_debug_show(struct ip_mc




NEXT




<s> int write_phy(u32 port, u32 page, u32 reg, u32 val)
{
switch (soc_info.family) {
case RTL8380_FAMILY_ID:
return rtl838x_write_phy(port, page, reg, val);
case RTL8390_FAMILY_ID:
return rtl839x_write_phy(port, page, reg, val);
case RTL9300_FAMILY_ID:
return rtl930x_write_phy(port, page, reg, val);
case RTL9310_FAMILY_ID:
return rtl931x_write_phy(port, page, reg, val);
}

return -1;
}

The above function is used to write PHY registers for RTL8380-9310. If the chip family is not supported, or the function failed, it

is implemented by the function rtl850x_write_phy:





NEXT




<s> IFX_BSP_HandleGet (int maj, int num)
{
if (num > BSP_MAX_DEVICES)
return NULL;
return &dsl_devices[num];
}

The above function is used to obtain any of the device handles. In particular the video device handles should be used for accessing the physical video device hardware. But when should we use this function? Normally, the application should not use this function and just get the handle from the




NEXT




<s> int __init lqdeu_async_des_init (void)
{
int i, j, ret = -EINVAL;

for (i = 0; i < ARRAY_SIZE(des_drivers_alg); i++) {
ret = crypto_register_alg(&des_drivers_alg[i].alg);
//printk("driver: %s\n", des_drivers_alg[i].alg.cra_name);
if (ret)
goto des_err;
}

des_chip_init();
CRTCL_SECT_INIT;


printk (KERN_NOTICE "IFX DEU DES initialized%s%s.\n", disable_multiblock ? "" : " (multiblock)", disable_deudma ? "" : " (DMA)");
return ret;

des_err:
for (j = 0; j < i; j++)
crypto_unregister_alg(&des_drivers_alg[i].alg);

printk(KERN_ERR "Lantiq %s driver initialization failed!\n", (char *)&des_drivers_alg[i].alg.cra_driver_name);
return ret;

cbc_des3_ede_err:
for (i = 0; i < ARRAY_SIZE(des_drivers_alg); i++) {
if (!strcmp((char *)&des_drivers_alg[i].alg.cra_name, "cbc(des3_ede)"))
crypto_unregister_alg(&des_drivers_alg[i].alg);
}

printk(KERN_ERR "Lantiq %s driver initialization failed!\n", (char *)&des_drivers_alg[i].alg.cra_driver_name);
return ret;
}

The above function is used to initialize the block cipher driver. In this function, the driver uses the Linux kernel crypto interface to register the block cipher.

The driver will register the cipher "des_ede" first, because there may be some older users who




NEXT




<s> static int fit_image_get_data_offset(const void *fit, int noffset, int *data_offset)
{
const fdt32_t *val;

val = fdt_getprop(fit, noffset, FIT_DATA_OFFSET_PROP, NULL);
if (!val)
return -ENOENT;

*data_offset = fdt32_to_cpu(*val);

return 0;
}

The above function is used to get offset of data in memory. The above function should return data offset when it is called with offset 0. It should return 0 when it is called with offset >=2 (as FIT uses only data offsets starting with 2) and




NEXT




<s> uc_hostapd_bss_ctrl(uc_vm_t *vm, size_t nargs)
{
struct hostapd_data *hapd = uc_fn_thisval("hostapd.bss");
uc_value_t *arg = uc_fn_arg(0);
struct sockaddr_storage from = {};
static char reply[4096];
int reply_len;

if (!hapd || !interfaces->ctrl_iface_recv ||
ucv_type(arg) != UC_STRING)
return NULL;

reply_len = interfaces->ctrl_iface_recv(hapd, ucv_string_get(arg),
reply, sizeof(reply),
&from, sizeof(from));
if (reply_len < 0)
return NULL;

if (reply_len && reply[reply_len - 1] == '\n')
reply_len--;

return ucv_string_new_length(reply, reply_len);
}

The above function is used to send a control message (which is a UC
string) via the Unix domain socket socket that hostapd listens on. This
is in the hostapd.bss instance (the first argument).

The third argument is




NEXT




<s> uc_bpf_error(uc_vm_t *vm, size_t nargs)
{
uc_value_t *numeric = uc_fn_arg(0);
const char *msg = last_error.msg;
int code = last_error.code;
uc_stringbuf_t *buf;
const char *s;

if (last_error.code == 0)
return NULL;

set_error(0, NULL);

if (ucv_is_truish(numeric))
return ucv_int64_new(code);

buf = ucv_stringbuf_new();
if (code < 0 && msg) {
ucv_stringbuf_addstr(buf, msg, strlen(msg));
} else {
s = strerror(code);
ucv_stringbuf_addstr(buf, s, strlen(s));
if (msg)
ucv_stringbuf_printf(buf, ": %s", msg);
}

return ucv_stringbuf_finish(buf);
}

The above function is used to get the error message. In our code we get,

error = (const char *)ucv_vm_u8_to_cstr(VMA.current->interpreter, get_last_error().msg);






NEXT




<s> static int rtl9300_i2c_mux_remove(struct platform_device *pdev)
{
struct i2c_mux_core *muxc = platform_get_drvdata(pdev);

i2c_mux_del_adapters(muxc);
i2c_put_adapter(muxc->parent);

return 0;
}

The above function is used to check which
component is already present in the mainframe
board and should we keep them all initialized?
If we should, we should be calling the above
function as well after each component initialization.
Hence we have to move the above




NEXT




<s> void rtl930x_port_eee_set(struct rtl838x_switch_priv *priv, int port, bool enable)
{
u32 v;

/* This works only for Ethernet ports, and on the RTL930X, ports from 26 are SFP */
if (port >= 26)
return;

pr_debug("In %s: setting port %d to %d\n", __func__, port, enable);
v = enable ? 0x3f : 0x0;

/* Set EEE/EEEP state for 100, 500, 1000MBit and 2.5, 5 and 10GBit */
sw_w32_mask(0, v << 10, rtl930x_mac_force_mode_ctrl(port));

/* Set TX/RX EEE state */
v = enable ? 0x3 : 0x0;
sw_w32(v, RTL930X_EEE_CTRL(port));

priv->ports[port].eee_enabled = enable;
}

The above function is used to control EEE (Energy Efficient Ethernet) on a single port.</s>




NEXT




<s> struct expr *expr_trans_bool(struct expr *e)
{
if (!e)
return NULL;
switch (e->type) {
case E_AND:
case E_OR:
case E_NOT:
e->left.expr = expr_trans_bool(e->left.expr);
e->right.expr = expr_trans_bool(e->right.expr);
break;
case E_UNEQUAL:
// FOO!=n -> FOO
if (e->left.sym->type == S_TRISTATE) {
if (e->right.sym == &symbol_no) {
e->type = E_SYMBOL;
e->right.sym = NULL;
}
}
break;
default:
;
}
return e;
}

The above function is used to transform a conditional expression into an equivalent conditional expression that does not contain `||` and/or `E_NE`. This means that after the function is applied to the conditional statement, all of the expressions in the if or if_




NEXT




<s> static int ag71xx_poll(struct napi_struct *napi, int limit)
{
struct ag71xx *ag = container_of(napi, struct ag71xx, napi);
struct net_device *dev = ag->dev;
struct ag71xx_ring *rx_ring = &ag->rx_ring;
int rx_ring_size = BIT(rx_ring->order);
unsigned long flags;
u32 status;
int tx_done;
int rx_done;

tx_done = ag71xx_tx_packets(ag, false, limit);

DBG("%s: processing RX ring\n", dev->name);
rx_done = ag71xx_rx_packets(ag, limit);

ag71xx_debugfs_update_napi_stats(ag, rx_done, tx_done);

if (rx_ring->buf[rx_ring->dirty % rx_ring_size].rx_buf == NULL)
goto oom;

status = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
if (unlikely(status & RX_STATUS_OF)) {
ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_OF);
dev->stats.rx_fifo_errors++;

/* restart RX */
ag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);
}

if (rx_done < limit) {
if (status & RX_STATUS_PR)
goto more;

status = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);
if (status & TX_STATUS_PS)
goto more;

DBG("%s: disable polling mode, rx=%d, tx=%d,limit=%d\n",
dev->name, rx_done, tx_done, limit);

napi_complete(napi);

/* enable interrupts */
spin_lock_irqsave(&ag->lock, flags);
ag71xx_int_enable(ag, AG71XX_INT_POLL);
spin_unlock_irqrestore(&ag->lock, flags);
return rx_done;
}

more:
DBG("%s: stay in polling mode, rx=%d, tx=%d, limit=%d\n",
dev->name, rx_done, tx_done, limit);
return limit;

oom:
if (netif_msg_rx_err(ag))
pr_info("%s: out of memory\n", dev->name);

mod_timer(&ag->oom_timer, jiffies + AG71XX_OOM_REFILL);
napi_complete(napi);
return 0;
}

The above function is used to transmit a packet from the NAPI driver. If the transmission of the outgoing packet is successful, a “tx_done” will be completed. Otherwise, the transmission process will stop and generate an error packet to the upper-level protocol layer.




NEXT




<s> static int ar934x_nfc_write_page(struct nand_chip *chip,
const u8 *buf, int oob_required, int page)
{
struct ar934x_nfc *nfc = chip->priv;
struct mtd_info *mtd = ar934x_nfc_to_mtd(nfc);
int err;

nfc_dbg(nfc, "write_page: page:%d oob:%d\n", page, oob_required);

/* write OOB first */
if (oob_required &&
!is_all_ff(chip->oob_poi, mtd->oobsize)) {
err = ar934x_nfc_write_oob(chip, page);
if (err)
return err;
}

/* TODO: optimize to avoid memcopy */
memcpy(nfc->buf, buf, mtd->writesize);

ar934x_nfc_enable_hwecc(nfc);
err = ar934x_nfc_send_write(nfc, NAND_CMD_PAGEPROG, 0, page,
mtd->writesize);
ar934x_nfc_disable_hwecc(nfc);

return err;
}

The above function is used to program a page and is called from
nand_write_page().

Ar934x nfc driver has the following limitations.

- ECC is HW-checked only after page program. ECC is not checked




NEXT




<s> static char *expand_dollar_with_args(const char **str, int argc, char *argv[])
{
const char *p = *str;
const char *q;
int nest = 0;

/*
* In Kconfig, variable/function references always start with "$(".
* Neither single-letter variables as in $A nor curly braces as in ${CC}
* are supported.  '$' not followed by '(' loses its special meaning.
*/
if (*p != '(') {
*str = p;
return xstrdup("$");
}

p++;
q = p;
while (*q) {
if (*q == '(') {
nest++;
} else if (*q == ')') {
if (nest-- == 0)
break;
}
q++;
}

if (!*q)
pperror("unterminated reference to '%s': missing ')'", p);

/* Advance 'str' to after the expanded initial portion of the string */
*str = q + 1;

return eval_clause(p, q - p, argc, argv);
}

The above function is used to handle the dollar-expression syntax $() (see also section Dollar expressions). For more details, read section Evaluating.

If you're using the dollar-expression syntax outside of Kconfig, you probably expect the string and not




NEXT




<s> static inline void m_double(const char *id, double value) {
blobmsg_add_double(&b, id, value);
}

The above function is used to add a "double" type member to structure.
This particular type has no alignment requirements in the standard on
top of the usual char requirements.
(a)

For the structure to blob format:
<structure_name>.m




NEXT




<s> ret_t rtl8367c_getAsic1xTrapPriority(rtk_uint32 *pPriority)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_DOT1X_PRIORTY_MASK, pPriority);
}

The above function is used to get Asic1x trap priority from DOT1X_REGISTRY.

The following code is taken from rtl8367c_setAsic1XRapPriority() used to set Asic1x trap




NEXT




<s> static int rtl8367b_set_vlan_mc(struct rtl8366_smi *smi, u32 index,
const struct rtl8366_vlan_mc *vlanmc)
{
u32 data[RTL8367B_VLAN_MC_NUM_WORDS];
int err;
int i;

if (index >= RTL8367B_NUM_VLANS ||
vlanmc->vid >= RTL8367B_NUM_VIDS ||
vlanmc->priority > RTL8367B_PRIORITYMAX ||
vlanmc->member > RTL8367B_VLAN_MC0_MEMBER_MASK ||
vlanmc->untag > RTL8367B_UNTAG_MASK ||
vlanmc->fid > RTL8367B_FIDMAX)
return -EINVAL;

data[0] = (vlanmc->member & RTL8367B_VLAN_MC0_MEMBER_MASK) <<
RTL8367B_VLAN_MC0_MEMBER_SHIFT;
data[1] = (vlanmc->fid & RTL8367B_VLAN_MC1_FID_MASK) <<
RTL8367B_VLAN_MC1_FID_SHIFT;
data[2] = 0;
data[3] = (vlanmc->vid & RTL8367B_VLAN_MC3_EVID_MASK) <<
RTL8367B_VLAN_MC3_EVID_SHIFT;

for (i = 0; i < ARRAY_SIZE(data); i++)
REG_WR(smi, RTL8367B_VLAN_MC_BASE(index) + i, data[i]);

return 0;
}

The above function is used to set the VLAN Mcast address table. The VLAN Mcast address table supports up to 4 4-element sub tables and up to 15 entries per sub table. Each entry is indexed by VLAN and the entry has




NEXT




<s> static void uimage_parse_dt(struct mtd_info *master, int *extralen,
u32 *ih_magic, u32 *ih_type,
u32 *header_offset, u32 *part_magic)
{
struct device_node *np = mtd_get_of_node(master);

if (!np || !of_device_is_compatible(np, "openwrt,uimage"))
return;

if (!of_property_read_u32(np, "openwrt,padding", extralen))
pr_debug("got openwrt,padding=%d from device-tree\n", *extralen);
if (!of_property_read_u32(np, "openwrt,ih-magic", ih_magic))
pr_debug("got openwrt,ih-magic=%08x from device-tree\n", *ih_magic);
if (!of_property_read_u32(np, "openwrt,ih-type", ih_type))
pr_debug("got openwrt,ih-type=%08x from device-tree\n", *ih_type);
if (!of_property_read_u32(np, "openwrt,offset", header_offset))
pr_debug("got ih-start=%u from device-tree\n", *header_offset);
if (!of_property_read_u32(np, "openwrt,partition-magic", part_magic))
pr_debug("got openwrt,partition-magic=%08x from device-tree\n", *part_magic);
}

The above function is used to initialize the members of the mtd_uimage struct from
the device tree nodes. These members are used to read the image header from the image
file. The ih_type and ih_magic determine which image format is being used.




NEXT




<s> mvswitch_init(void)
{
phy_register_fixup_for_id(PHY_ANY_ID, mvswitch_fixup);
return phy_driver_register(&mvswitch_driver, THIS_MODULE);
}

The above function is used to register the mvswitch driver.

So it seems likely that mvswitch_init is not properly executed. Do
you know how to implement a module that is loaded automatically at
init time? How can I make the system execute it




NEXT




<s> static int fe_tx_dma_map_page(struct fe_tx_ring *ring, struct fe_map_state *st,
struct page *page, size_t offset, size_t size)
{
int cur_size;
int ret;

while (size > 0) {
cur_size = min_t(size_t, size, TX_DMA_BUF_LEN);

ret = __fe_tx_dma_map_page(ring, st, page, offset, cur_size);
if (ret)
return ret;

size -= cur_size;
offset += cur_size;
}

return 0;
}

The above function is used to map out buffer from hardware ring.

size_t cur_size = min_t(size_t, size, TX_DMA_BUF_LEN);

If __fe_tx_dma_map_page() returns anything




NEXT




<s> void rtl931x_traffic_set(int source, u64 dest_matrix)
{
struct table_reg *r = rtl_table_get(RTL9310_TBL_0, 6);

sw_w32((dest_matrix << 3), rtl_table_data(r, 0));
rtl_table_write(r, source);
rtl_table_release(r);
}

The above function is used to set the destination address matrix.

The structure of rtl_table_t is defined as below:

typedef struct table {
u32 size;
u32 head;
u32 end;
int




NEXT




<s> static inline u8 *oob_ecc_ptr(struct mt7621_nfc *nfc, int sect)
{
struct nand_chip *nand = &nfc->nand;

return nand->oob_poi + nand->ecc.steps * NFI_FDM_SIZE +
sect * (nfc->spare_per_sector - NFI_FDM_SIZE);
}

The above function is used to get the offset of spare bytes in SLC,
but the oob_ecc_ptr() function will fail with MLC.

So, we need to get correct spare bytes offset to fix it.

Change-Id:




NEXT




<s> yydestruct (const char *yymsg,
yysymbol_kind_t yykind, YYSTYPE *yyvaluep)
{
YY_USE (yyvaluep);
if (!yymsg)
yymsg = "Deleting";
YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);

YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
switch (yykind)
{
case YYSYMBOL_choice_entry: /* choice_entry  */
{
fprintf(stderr, "%s:%d: missing end statement for this entry\n",
((*yyvaluep).menu)->file->name, ((*yyvaluep).menu)->lineno);
if (current_menu == ((*yyvaluep).menu))
menu_end_menu();
}
break;

case YYSYMBOL_if_entry: /* if_entry  */
{
fprintf(stderr, "%s:%d: missing end statement for this entry\n",
((*yyvaluep).menu)->file->name, ((*yyvaluep).menu)->lineno);
if (current_menu == ((*yyvaluep).menu))
menu_end_menu();
}
break;

case YYSYMBOL_menu_entry: /* menu_entry  */
{
fprintf(stderr, "%s:%d: missing end statement for this entry\n",
((*yyvaluep).menu)->file->name, ((*yyvaluep).menu)->lineno);
if (current_menu == ((*yyvaluep).menu))
menu_end_menu();
}
break;

default:
break;
}
YY_IGNORE_MAYBE_UNINITIALIZED_END
}

The above function is used to print and delete various constructs. It
handles printing the relevant string or variable along with line
numbers, then calls YY_SYMBOL_PRINT.</s>




NEXT




<s> adm6996_get_ports(struct switch_dev *dev, struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);
u8 ports = priv->vlan_table[val->port_vlan];
u8 tagged = priv->vlan_tagged[val->port_vlan];
int i;

pr_devel("get_ports port_vlan %d\n", val->port_vlan);

val->len = 0;

for (i = 0; i < ADM_NUM_PORTS; i++) {
struct switch_port *p;

if (!(ports & (1 << i)))
continue;

p = &val->value.ports[val->len++];
p->id = i;
if (tagged & (1 << i))
p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
else
p->flags = 0;
}

return 0;
};

The above function is used to provide the ports for tagged/untagged VLAN (port_vlan). Switch uses this function while reading sw->get_ports() function. So this function needs to be modified to provide correct ports for tagged/untagged




NEXT




<s> irqreturn_t rtl838x_switch_irq(int irq, void *dev_id)
{
struct dsa_switch *ds = dev_id;
u32 status = sw_r32(RTL838X_ISR_GLB_SRC);
u32 ports = sw_r32(RTL838X_ISR_PORT_LINK_STS_CHG);
u32 link;

/* Clear status */
sw_w32(ports, RTL838X_ISR_PORT_LINK_STS_CHG);
pr_info("RTL8380 Link change: status: %x, ports %x\n", status, ports);

for (int i = 0; i < 28; i++) {
if (ports & BIT(i)) {
link = sw_r32(RTL838X_MAC_LINK_STS);
if (link & BIT(i))
dsa_port_phylink_mac_change(ds, i, true);
else
dsa_port_phylink_mac_change(ds, i, false);
}
}

return IRQ_HANDLED;
}

The above function is used to handle the Interrupt Service Routine (ISR) and it can detect link-change interrupt. And for convenience, it uses a global variable ‘ports’ to store the result of the register read. The function uses the ‘BIT’ macro to




NEXT




<s> static int bcm6348_emac_mdio_read(struct mii_bus *bus, int phy_id, int loc)
{
struct bcm6348_emac *emac = bus->priv;
struct platform_device *pdev = emac->pdev;
struct device *dev = &pdev->dev;
uint32_t reg;

reg = 0x2 << ENET_MIID_TA_SHIFT;
reg |= loc << ENET_MIID_REG_SHIFT;
reg |= phy_id << ENET_MIID_PHY_SHIFT;
reg |= ENET_MIID_OP_READ;

if (bcm6348_emac_mdio_op(emac, reg)) {
dev_err(dev, "mdio_read: phy=%d loc=%x timeout!\n",
phy_id, loc);
return -EINVAL;
}

reg = emac_readl(emac, ENET_MIID_REG);
reg = (reg >> ENET_MIID_DATA_SHIFT) & ENET_MIID_DATA_MASK;

return (int) reg;
}

The above function is used to read from PHY register. Below is the function
to write to PHY register.

static int bcm6348_emac_mdio_write(struct mii_bus *bus, int phy_id




NEXT




<s> void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to enable DMA on HPS DMA Engine for each
channel (up link Rx and down link Tx) within DMA DMA_DEU driver.
*/


/*! \fn void ifx_danube_pre_1_4




NEXT




<s> static int fe_alloc_rx(struct fe_priv *priv)
{
struct fe_rx_ring *ring = &priv->rx_ring;
int i, pad;

ring->rx_data = kcalloc(ring->rx_ring_size, sizeof(*ring->rx_data),
GFP_KERNEL);
if (!ring->rx_data)
goto no_rx_mem;

for (i = 0; i < ring->rx_ring_size; i++) {
ring->rx_data[i] = page_frag_alloc(&ring->frag_cache,
ring->frag_size,
GFP_KERNEL);
if (!ring->rx_data[i])
goto no_rx_mem;
}

ring->rx_dma = dma_alloc_coherent(priv->dev,
ring->rx_ring_size * sizeof(*ring->rx_dma),
&ring->rx_phys,
GFP_ATOMIC | __GFP_ZERO);
if (!ring->rx_dma)
goto no_rx_mem;

if (priv->flags & FE_FLAG_RX_2B_OFFSET)
pad = 0;
else
pad = NET_IP_ALIGN;
for (i = 0; i < ring->rx_ring_size; i++) {
dma_addr_t dma_addr = dma_map_single(priv->dev,
ring->rx_data[i] + NET_SKB_PAD + pad,
ring->rx_buf_size,
DMA_FROM_DEVICE);
if (unlikely(dma_mapping_error(priv->dev, dma_addr)))
goto no_rx_mem;
ring->rx_dma[i].rxd1 = (unsigned int)dma_addr;

if (priv->flags & FE_FLAG_RX_SG_DMA)
ring->rx_dma[i].rxd2 = RX_DMA_PLEN0(ring->rx_buf_size);
else
ring->rx_dma[i].rxd2 = RX_DMA_LSO;
}
ring->rx_calc_idx = ring->rx_ring_size - 1;
/* make sure that all changes to the dma ring are flushed before we
* continue
*/
wmb();

fe_reg_w32(ring->rx_phys, FE_REG_RX_BASE_PTR0);
fe_reg_w32(ring->rx_ring_size, FE_REG_RX_MAX_CNT0);
fe_reg_w32(ring->rx_calc_idx, FE_REG_RX_CALC_IDX0);
fe_reg_w32(FE_PST_DRX_IDX0, FE_REG_PDMA_RST_CFG);

return 0;

no_rx_mem:
return -ENOMEM;
}

The above function is used to allocate memory for data and
buffers used by the network card. It's actually a lot easier to use a
ring buffer for a driver.

Now, onto the functions for DMA, but the functions are not available
currently




NEXT




<s> static int handle_exit(void)
{
int res;

save_and_exit = 1;
reset_subtitle();
dialog_clear();
if (conf_get_changed())
res = dialog_yesno(NULL,
"Do you wish to save your new configuration?\n"
"(Press <ESC><ESC> to continue kernel configuration.)",
6, 60);
else
res = -1;

end_dialog(saved_x, saved_y);

switch (res) {
case 0:
if (conf_write(filename)) {
fprintf(stderr, "\n\n"
"Error while writing of the configuration.\n"
"Your configuration changes were NOT saved."
"\n\n");
return 1;
}
conf_write_autoconf(0);
/* fall through */
case -1:
if (!silent)
printf("\n\n"
"*** End of the configuration.\n"
"*** Execute 'make' to start the build or try 'make help'."
"\n\n");
res = 0;
break;
default:
if (!silent)
fprintf(stderr, "\n\n"
"Your configuration changes were NOT saved."
"\n\n");
if (res != KEY_ESC)
res = 0;
}

return res;
}

The above function is used to write the changed values into the configuration file and stop display of dialog.

So i replaced this exit function with the original exit function which was in the kernelconf.c file with another name(not important now for me).

I compiled




NEXT




<s> void env_relocate_spec(void)
{
char buf[CONFIG_ENV_SIZE];
block_dev_desc_t *dev_desc = NULL;
int dev = EXT4_ENV_DEVICE;
int part = EXT4_ENV_PART;
int err;

dev_desc = get_dev(EXT4_ENV_INTERFACE, dev);
if (dev_desc == NULL) {
printf("Failed to find %s%d\n",
EXT4_ENV_INTERFACE, dev);
set_default_env(NULL);
return;
}

err = ext4_register_device(dev_desc, part);
if (err) {
printf("Failed to register %s%d:%d\n",
EXT4_ENV_INTERFACE, dev, part);
set_default_env(NULL);
return;
}

err = ext4_read_file(EXT4_ENV_FILE, (uchar *)&buf, 0, CONFIG_ENV_SIZE);
ext4fs_close();

if (err == -1) {
printf("\n** Unable to read \"%s\" from %s%d:%d **\n",
EXT4_ENV_FILE, EXT4_ENV_INTERFACE, dev, part);
set_default_env(NULL);
return;
}

env_import(buf, 1);
}

The above function is used to relocate the env in ext4.</s>




NEXT




<s> int set_led(struct led *led, unsigned char value)
{
char buf[8];

if ( ! led )
return -1;

if ( ! led->controlfd )
return -1;

if ( led->state == value )
return 0;

snprintf(buf, 8, "%d", value);

rewind(led->controlfd);

if ( ! fwrite(buf, sizeof(char), strlen(buf), led->controlfd) )
return -2;

fflush(led->controlfd);
led->state=value;

return 0;
}

The above function is used to implement the following C-like example.

#include</s>




NEXT




<s> static ssize_t sc_commit_show(struct kobject *kobj, struct kobj_attribute *attr,
char *buf)
{
const char *str;
char *out = buf;
u32 crc;

read_lock(&sc_bufrwl);
crc = RB_SC_GETCRC();
read_unlock(&sc_bufrwl);

str = (crc) ? "clean" : "dirty";
out += sprintf(out, "%s\n", str);

return out - buf;
}

The above function is used to tell the programmers whether commit is successful or not. If it shows the file is clean, then that means you have changed the data successfully.</s>




NEXT




<s> u32 mt7530_mdio_r32(struct mt7620_gsw *gsw, u32 reg)
{
u16 high, low;

_mt7620_mii_write(gsw, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
low = _mt7620_mii_read(gsw, 0x1f, (reg >> 2) & 0xf);
high = _mt7620_mii_read(gsw, 0x1f, 0x10);

return (high << 16) | (low & 0xffff);
}

The above function is used to read a single 32-bit register from the
MT7620A MII MDIO interface. It uses a 16-bit interface for the read
operation. The first two lines of the function setup the read





NEXT




<s> ret_t rtl8367c_setAsicPortJamMode(rtk_uint32 mode)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_CFG_BACKPRESSURE, RTL8367C_LONGTXE_OFFSET,mode);
}

The above function is used to set up the jamming mode on the Ethernet port. The jamming mode on the 802.3 Ethernet can improve the transmission performance of the high-latency network by the software-controlled jamming mechanisms.




NEXT




<s> static void parse_options(int argc, char *argv[])
{
while (1) {
int c;

c = getopt(argc, argv, "abd:hln:o");
if (c == -1)
break;

switch (c) {
case 'a':
show_all = true;
name_filter = NULL;
print_all_key_names = false;
break;
case 'b':
swap_bytes = 1;
break;
case 'd':
mtddev = optarg;
break;
case 'h':
usage(EXIT_SUCCESS);
break;
case 'l':
print_all_key_names = true;
show_all = false;
name_filter = NULL;
break;
case 'n':
name_filter = optarg;
show_all = false;
print_all_key_names = false;
break;
case 'o':
read_oob_sector_health = true;
break;
default:
usage(EXIT_FAILURE);
break;
}
}

if (!mtddev) {
fprintf(stderr, "ERROR: No input file (-d <file>) given!\n");
usage(EXIT_FAILURE);
}

if (!show_all && !name_filter && !print_all_key_names) {
fprintf(stderr,
"ERROR: either -l, -a or -n <key name> is required!\n");
usage(EXIT_FAILURE);
}
}

The above function is used to parse user input and extract the required files, name filters or flags with the help of getopts function.
-a prints all non-volatile memory key names
-l prints all non-volatile memory key names in ASCII





NEXT




<s> rtk_api_ret_t rtk_switch_greenEthernet_get(rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtk_uint32 port;
rtk_uint32 state;

/* Check initialization state */
RTK_CHK_INIT_STATE();

RTK_SCAN_ALL_LOG_PORT(port)
{
if(rtk_switch_isUtpPort(port) == RT_ERR_OK)
{
if ((retVal = rtl8367c_getAsicPowerSaving(rtk_switch_port_L2P_get(port), &state))!=RT_ERR_OK)
return retVal;

if(state == DISABLED)
{
*pEnable = DISABLED;
return RT_ERR_OK;
}

if ((retVal = rtl8367c_getAsicGreenEthernet(rtk_switch_port_L2P_get(port), &state))!=RT_ERR_OK)
return retVal;

if(state == DISABLED)
{
*pEnable = DISABLED;
return RT_ERR_OK;
}
}
}

*pEnable = ENABLED;
return RT_ERR_OK;
}

The above function is used to get whether green ethernet is enabled or disabled.

rtk_api_ret_t rtk_switch_greenEthernet_set(rtk_enable_t enable)
{
rtk_uint32




NEXT




<s> BN_CTX *BN_CTX_new(void)
{
BN_CTX *ret;

ret=(BN_CTX *)malloc(sizeof(BN_CTX));
if (ret == NULL)
{
return(NULL);
}

BN_CTX_init(ret);
ret->flags=BN_FLG_MALLOCED;
return(ret);
}

The above function is used to create a new BN_CTX structure. The first step is to allocate space for the new BN_CTX structure. This space is allocated in the current heap. The next step is to set the flags field of the new BN_CTX




NEXT




<s> static int b53_mdio_write8(struct b53_device *dev, u8 page, u8 reg, u8 value)
{
struct mii_bus *bus = dev->priv;
int ret;

ret = mdiobus_write(bus, B53_PSEUDO_PHY, REG_MII_DATA0, value);
if (ret)
return ret;

return b53_mdio_op(dev, page, reg, REG_MII_ADDR_WRITE);
}

The above function is used to write data into

PHY registers.

void b53_mdio_init(struct b53_device *dev)</s>




NEXT




<s> static int gpio_button_get_value(struct gpio_keys_button_data *bdata)
{
int val;

if (bdata->can_sleep)
val = !!gpiod_get_value_cansleep(bdata->gpiod);
else
val = !!gpiod_get_value(bdata->gpiod);

return val;
}

The above function is used to get the value (or state), of the gpio we tied with keys-driver.
The GPIO state is used to check whether, the button being pressed.
The above function is also a callback function and is used to check the button state




NEXT




<s> ret_t rtl8367c_getAsicVlanProtocolBasedGroupData(rtk_uint32 index, rtl8367c_protocolgdatacfg *pPbCfg)
{
rtk_uint32  frameType;
rtk_uint32  etherType;
ret_t   retVal;

/* Error Checking */
if(index > RTL8367C_PROTOVLAN_GIDX_MAX)
return RT_ERR_VLAN_PROTO_AND_PORT;

/* Read Frame type */
retVal = rtl8367c_getAsicRegBits(RTL8367C_VLAN_PPB_FRAMETYPE_REG(index), RTL8367C_VLAN_PPB_FRAMETYPE_MASK, &frameType);
if(retVal != RT_ERR_OK)
return retVal;

/* Read Ether type */
retVal = rtl8367c_getAsicReg(RTL8367C_VLAN_PPB_ETHERTYPR_REG(index), &etherType);
if(retVal != RT_ERR_OK)
return retVal;


pPbCfg->frameType = frameType;
pPbCfg->etherType = etherType;
return RT_ERR_OK;
}

The above function is used to get the protocol based group's parameter (Frame Type & ether type).

ret_t rtl8367c_setAsicVlanPPBEnable(rtk_uint16 vidx, rtk_




NEXT




<s> struct switch_attr *swlib_lookup_attr(struct switch_dev *dev,
enum swlib_attr_group atype, const char *name)
{
struct switch_attr *head;

if (!name || !dev)
return NULL;

switch(atype) {
case SWLIB_ATTR_GROUP_GLOBAL:
head = dev->ops;
break;
case SWLIB_ATTR_GROUP_PORT:
head = dev->port_ops;
break;
case SWLIB_ATTR_GROUP_VLAN:
head = dev->vlan_ops;
break;
}
while(head) {
if (!strcmp(name, head->name))
return head;
head = head->next;
}

return NULL;
}

The above function is used to retrieve the device ops, port ops and vlan
ops. It works fine for most cases, but it fails in one situation:

When passing this code through QA, one of the tests causes it to fail. It
sets the




NEXT




<s> static int rtl8367_set_vlan_4k(struct rtl8366_smi *smi,
const struct rtl8366_vlan_4k *vlan4k)
{
u32 data[RTL8367_TA_VLAN_DATA_SIZE];
int err;
int i;

if (vlan4k->vid >= RTL8367_NUM_VIDS ||
vlan4k->member > RTL8367_TA_VLAN_MEMBER_MASK ||
vlan4k->untag > RTL8367_UNTAG_MASK ||
vlan4k->fid > RTL8367_FIDMAX)
return -EINVAL;

data[0] = (vlan4k->member & RTL8367_TA_VLAN_MEMBER_MASK) <<
RTL8367_TA_VLAN_MEMBER_SHIFT;
data[1] = (vlan4k->fid & RTL8367_TA_VLAN_FID_MASK) <<
RTL8367_TA_VLAN_FID_SHIFT;
data[2] = (vlan4k->untag & RTL8367_TA_VLAN_UNTAG1_MASK) <<
RTL8367_TA_VLAN_UNTAG1_SHIFT;
data[3] = ((vlan4k->untag >> 2) & RTL8367_TA_VLAN_UNTAG2_MASK) <<
RTL8367_TA_VLAN_UNTAG2_SHIFT;

for (i = 0; i < ARRAY_SIZE(data); i++)
REG_WR(smi, RTL8367_TA_DATA_REG(i), data[i]);

/* write VID */
REG_WR(smi, RTL8367_TA_ADDR_REG,
vlan4k->vid & RTL8367_TA_VLAN_VID_MASK);

/* write table access control word */
REG_WR(smi, RTL8367_TA_CTRL_REG, RTL8367_TA_CTRL_CVLAN_WRITE);

return 0;
}

The above function is used to set an single 4096 bytes entry in vlan translation table, and the below code is responsible for setting port vlan.

static int rtl8367_set_port_vlan(struct rtl8




NEXT




<s> static inline void init_atm_tc(void);
static inline void clear_share_buffer(void);

#define IFX_PMU_MODULE_PPE_SLL01  BIT(19)
#define IFX_PMU_MODULE_PPE_TC     BIT(21)
#define IFX_PMU_MODULE_PPE_EMA    BIT(22)
#define IFX_PMU_MODULE_PPE_QSB    BIT(18)
#define IFX_PMU_MODULE_AHBS       BIT(13)
#define IFX_PMU_MODULE_DSL_DFE    BIT(9)


static inline void init_pmu(void)
{
ltq_pmu_enable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_AHBS |
IFX_PMU_MODULE_DSL_DFE);

}

The above function is used to initialize the pmu

The code to activate the PPE TC function is

ltq_pmu_enable(IFX_PMU_MODULE_PPE_TC);
static inline void init_atm_tc




NEXT




<s> ret_t rtl8367c_setAsicEeeGiga(rtk_uint32 port, rtk_uint32 enable)
{
rtk_api_ret_t   retVal;
rtk_uint32      regData;

if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if (enable > 1)
return RT_ERR_INPUT;

if((retVal = rtl8367c_getAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, &regData)) != RT_ERR_OK)
return retVal;

if(enable)
regData |= (0x0001 << 2);
else
regData &= ~(0x0001 << 2);

if((retVal = rtl8367c_setAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, regData)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable/disable EEE function to reduce power loss.
1.  The function should be used with one of rt_setPortMode function.
  It is due to the fact that the enable bit is in the 6 bit field of




NEXT




<s> void hostapd_ubus_notify_authorized(struct hostapd_data *hapd, struct sta_info *sta,
const char *auth_alg)
{
if (!hapd->ubus.obj.has_subscribers)
return;

blob_buf_init(&b, 0);
blobmsg_add_macaddr(&b, "address", sta->addr);
if (auth_alg)
blobmsg_add_string(&b, "auth-alg", auth_alg);

ubus_notify(ctx, &hapd->ubus.obj, "sta-authorized", b.head, -1);
}

The above function is used to notify authorized events to the ubus daemon and will
be called by driver with the notification_update() when new associations and authentications are seen.




The device driver is also responsible for updating the state machine status as




NEXT




<s> static int rtl8367_get_mc_index(struct rtl8366_smi *smi, int port, int *val)
{
u32 data;
int err;

if (port >= RTL8367_NUM_PORTS)
return -EINVAL;

REG_RD(smi, RTL8367_VLAN_PVID_CTRL_REG(port), &data);

*val = (data >> RTL8367_VLAN_PVID_CTRL_SHIFT(port)) &
RTL8367_VLAN_PVID_CTRL_MASK;

return 0;
}

The above function is used to retrieve the multicast index value that is configured  for a port. Note that this function should be the last function called during a probe of a port for its PHYs and VLANs, since the value returned by get_mc_




NEXT




<s> ret_t rtl8367c_setAsicRmaCdp(rtl8367c_rma_t* pRmacfg)
{
rtk_uint32 regData = 0;
ret_t retVal;

if(pRmacfg->operation >= RMAOP_END)
return RT_ERR_RMA_ACTION;

if(pRmacfg->trap_priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

regData |= (pRmacfg->portiso_leaky & 0x0001);
regData |= ((pRmacfg->vlan_leaky & 0x0001) << 1);
regData |= ((pRmacfg->keep_format & 0x0001) << 2);
regData |= ((pRmacfg->trap_priority & 0x0007) << 3);
regData |= ((pRmacfg->discard_storm_filter & 0x0001) << 6);
regData |= ((pRmacfg->operation & 0x0003) << 7);

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, pRmacfg->trap_priority);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_setAsicReg(RTL8367C_REG_RMA_CTRL_CDP, regData);
}

The above function is used to modify RMA configuration registers.

The function definition is as follows:

/* set RTC/Ethernet_Type/Vlan_tag/Ethernet_Type_to_Vlan
* RMA is modified by




NEXT




<s> static int adm6996_switch_init(struct adm6996_priv *priv, const char *alias, struct net_device *netdev)
{
struct switch_dev *swdev;
u16 test, old;

if (!priv->model) {
/* Detect type of chip */
old = r16(priv, ADM_VID_CHECK);
test = old ^ (1 << 12);
w16(priv, ADM_VID_CHECK, test);
test ^= r16(priv, ADM_VID_CHECK);
if (test & (1 << 12)) {
/*
* Bit 12 of this register is read-only.
* This is the FC model.
*/
priv->model = ADM6996FC;
} else {
/* Bit 12 is read-write. This is the M model. */
priv->model = ADM6996M;
w16(priv, ADM_VID_CHECK, old);
}
}

swdev = &priv->dev;
swdev->name = (adm6996_model_name[priv->model]);
swdev->cpu_port = ADM_CPU_PORT;
swdev->ports = ADM_NUM_PORTS;
swdev->vlans = ADM_NUM_VLANS;
swdev->ops = &adm6996_ops;
swdev->alias = alias;

/* The ADM6996L connected through GPIOs does not support any switch
status calls */
if (priv->model == ADM6996L) {
adm6996_ops.attr_port.n_attr = 0;
adm6996_ops.get_port_link = NULL;
}

pr_info ("%s: %s model PHY found.\n", alias, swdev->name);

mutex_lock(&priv->reg_mutex);
adm6996_perform_reset (priv);
mutex_unlock(&priv->reg_mutex);

if (priv->model == ADM6996M || priv->model == ADM6996L) {
return register_switch(swdev, netdev);
}

return -ENODEV;
}

The above function is used to initialize a switch_dev structure.</s>




NEXT




<s> ret_t rtl8367c_getAsicPortEgressRate(rtk_uint32 port, rtk_uint32 *rate)
{
ret_t retVal;
rtk_uint32 regAddr, regData,regData2;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

regAddr = RTL8367C_PORT_EGRESSBW_LSB_REG(port);

retVal = rtl8367c_getAsicReg(regAddr, &regData);
if(retVal != RT_ERR_OK)
return retVal;

regAddr = RTL8367C_PORT_EGRESSBW_MSB_REG(port);
retVal = rtl8367c_getAsicRegBits(regAddr, RTL8367C_PORT6_EGRESSBW_CTRL1_MASK, &regData2);
if(retVal != RT_ERR_OK)
return retVal;

*rate = regData | (regData2 << RTL8367C_QOS_GRANULARTY_MSB_OFFSET);

return RT_ERR_OK;
}

The above function is used to get egress queue rate set for a physical port. If you refer the datasheet on page 63 you will find that this bitfield should not be set as it’s not implemented and reserved. I will try to figure out why




NEXT




<s> psb6970_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct psb6970_priv *priv = to_psb6970(dev);
priv->vlan_id[val->port_vlan] = val->value.i;
return 0;
}

The above function is used to set the VLAN ID. Currently we use only VLAN
1 for all ports.

/*
 * Set the VLAN ID
 * @attr: Struct containing the switch attribute
 * @val: Struct containing the switch value
 *




NEXT




<s> rtl8367_sw_set_vlan_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8367_priv *priv = container_of(dev, struct rtl8367_priv, swdev);

priv->global_vlan_enable = val->value.i ;

return 0;
}

The above function is used to enable/disable VLAN on RTL8367. This is a generic function and can be used
to enable/disable any feature in RTL8367.

The function takes a pointer to switch_dev structure passed




NEXT




<s> static void rtl83xx_vlan_set_pvid(struct rtl838x_switch_priv *priv,
int port, int pvid)
{
/* Set both inner and outer PVID of the port */
priv->r->vlan_port_pvid_set(port, PBVLAN_TYPE_INNER, pvid);
priv->r->vlan_port_pvid_set(port, PBVLAN_TYPE_OUTER, pvid);
priv->r->vlan_port_pvidmode_set(port, PBVLAN_TYPE_INNER,
PBVLAN_MODE_UNTAG_AND_PRITAG);
priv->r->vlan_port_pvidmode_set(port, PBVLAN_TYPE_OUTER,
PBVLAN_MODE_UNTAG_AND_PRITAG);

priv->ports[port].pvid = pvid;
}

The above function is used to set PVID of inner and outer VLAN tag. But I’m confused about the following part.
priv->r->vlan_port_pvidmode_set(port, PBVLAN_TYPE_INNER,





NEXT




<s> rtk_api_ret_t rtk_cpu_priRemap_get(rtk_pri_t int_pri, rtk_pri_t *pNew_pri)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pNew_pri)
return RT_ERR_NULL_POINTER;

if (int_pri > RTL8367C_PRIMAX)
return  RT_ERR_QOS_INT_PRIORITY;

if ((retVal = rtl8367c_getAsicCputagPriorityRemapping(int_pri, pNew_pri)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the new priority assigned to the interface’s priority. The old priority is assigned using this function.

The priority can be defined by the user. This function is used to get back the mapped priority value. The priority’s value is




NEXT




<s> ret_t rtl8367c_getAsicFlowControlSystemJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SYS_OFF, RTL8367C_FLOWCTRL_JUMBO_SYS_OFF_MASK, pOffThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SYS_ON, RTL8367C_FLOWCTRL_JUMBO_SYS_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to read the jumbo threshold values to on and off flow control state, however I think this function doesn't work , as I have only one threshold value for both on and off , I thought this function should return two threshold values for on and




NEXT




<s> static inline u8 *oob_fdm_ptr(struct nand_chip *nand, int sect)
{
return nand->oob_poi + sect * NFI_FDM_SIZE;
}

The above function is used to calculate the pointer for the oob_poi and is given the sector the oob data is for.

I was looking over the 3ware 9650 driver and it had this line of code and a pointer was created




NEXT




<s> static INLINE void mailbox_signal(unsigned int, int);
#ifdef CONFIG_IFX_PTM_RX_TASKLET
static void do_ptm_tasklet(unsigned long);
#endif

/*
*  Debug Functions
*/
#if defined(DEBUG_DUMP_SKB) && DEBUG_DUMP_SKB
static void dump_skb(struct sk_buff *, u32, char *, int, int, int);
#else
#define dump_skb(skb, len, title, port, ch, is_tx)    do {} while (0)

The above function is used to debug Skb dump, If you want, you can print
the skb data in /proc/net/ptm/*

#endif

/*
*  Helper Functions
*/
static void set_hw_tx_




NEXT




<s> static int rtl93xx_get_sds(struct phy_device *phydev)
{
struct device *dev = &phydev->mdio.dev;
struct device_node *dn;
u32 sds_num;

if (!dev)
return -1;
if (dev->of_node) {
dn = dev->of_node;
if (of_property_read_u32(dn, "sds", &sds_num))
sds_num = -1;
} else {
dev_err(dev, "No DT node.\n");
return -1;
}

return sds_num;
}

The above function is used to read the number of PLLs to be used. Here, we take the count available in the device tree. If the same is not configured, then the following statement returns -1 indicating error to the caller of this function.

Now,




NEXT




<s> ar8327_init_port(struct ar8xxx_priv *priv, int port)
{
struct ar8327_data *data = priv->chip_data;
u32 t;

if (port == AR8216_PORT_CPU)
t = data->port0_status;
else if (port == 6)
t = data->port6_status;
else
t = AR8216_PORT_STATUS_LINK_AUTO;

if (port != AR8216_PORT_CPU && port != 6) {
/*hw limitation:if configure mac when there is traffic,
port MAC may work abnormal. Need disable lan&wan mac at fisrt*/
ar8xxx_write(priv, AR8327_REG_PORT_STATUS(port), 0);
msleep(100);
t |= AR8216_PORT_STATUS_FLOW_CONTROL;
ar8xxx_write(priv, AR8327_REG_PORT_STATUS(port), t);
} else {
ar8xxx_write(priv, AR8327_REG_PORT_STATUS(port), t);
}

ar8xxx_write(priv, AR8327_REG_PORT_HEADER(port), 0);

ar8xxx_write(priv, AR8327_REG_PORT_VLAN0(port), 0);

t = AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH << AR8327_PORT_VLAN1_OUT_MODE_S;
ar8xxx_write(priv, AR8327_REG_PORT_VLAN1(port), t);

t = AR8327_PORT_LOOKUP_LEARN;
t |= AR8216_PORT_STATE_FORWARD << AR8327_PORT_LOOKUP_STATE_S;
ar8xxx_write(priv, AR8327_REG_PORT_LOOKUP(port), t);
}

The above function is used to initialize the port of ar8327,
we just want to configure it so that it can correctly receive VLAN0 packets.

1. First register ar8327
2. Configure the 2168




NEXT




<s> void dfe_loopback_irq_handler (DSL_DEV_Device_t *pDev);

#endif //CONFIG_AMAZON_S_MEI_FW_LOOPBACK

DSL_DEV_Version_t bsp_mei_version = {
major:	5,
minor:	0,
revision:0
};

The above function is used to verify the integrity of the Mei code block. Please do not modify or remove this section, unless you have knowledge of Mei

The following section can be modified to provide device specific or build related information

DSL_DEV_Version




NEXT




<s> rtk_api_ret_t rtk_rate_egrQueueBwCtrlEnable_set(rtk_port_t port, rtk_qid_t queue, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

/*for whole port function, the queue value should be 0xFF*/
if (queue != RTK_WHOLE_SYSTEM)
return RT_ERR_QUEUE_ID;

if (enable>=RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicAprEnable(rtk_switch_port_L2P_get(port), enable))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable the eGRESS bandwidth control for each port or globally.

The following is a sample of the code using this function.

<pre>
rtk_port_t port;
rtk_qid_




NEXT




<s> static uint64_t ba2addr(struct nmbm_instance *ni, uint32_t ba)
{
return (uint64_t)ba << bmtd.blk_shift;
}

The above function is used to convert some byte address to some other address, but the code is not clear. The address offset needs to be converted.

uint64_t -> means 64bit

bmtd.blk_shift -> meaning of shift offset




NEXT




<s> static void gsw_reset_ephy(struct mt7620_gsw *gsw)
{
if (!gsw->rst_ephy)
return;

reset_control_assert(gsw->rst_ephy);
usleep_range(10, 20);
reset_control_deassert(gsw->rst_ephy);
usleep_range(10, 20);
}

The above function is used to perform a reset on the MT7620-ePHY. As shown in Figure 7-6 of the MT7620e chipset datasheet the only components which are connected to the reset control are the integrated analog trans




NEXT




<s> send_attr(struct nl_msg *msg, void *arg)
{
struct switch_val *val = arg;
struct switch_attr *attr = val->attr;

NLA_PUT_U32(msg, SWITCH_ATTR_ID, attr->dev->id);
NLA_PUT_U32(msg, SWITCH_ATTR_OP_ID, attr->id);
switch(attr->atype) {
case SWLIB_ATTR_GROUP_PORT:
NLA_PUT_U32(msg, SWITCH_ATTR_OP_PORT, val->port_vlan);
break;
case SWLIB_ATTR_GROUP_VLAN:
NLA_PUT_U32(msg, SWITCH_ATTR_OP_VLAN, val->port_vlan);
break;
default:
break;
}

return 0;

nla_put_failure:
return -1;
}

The above function is used to encode the struct switch_val data structure
into the NL_MSG message, which is a simple struct that contain just one
integer of type SWITCH_ATTR_OP_ID, and the rest of the integer, of
type SW




NEXT




<s> static void hostapd_ubus_connection_lost(struct ubus_context *ctx)
{
uloop_fd_delete(&ctx->sock);
eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
}

The above function is used to disconnect from the Ubus socket, set another timeout to reconnect, and
register another timeout to trigger a callback function called ubus_reconnect_timeout.

The function that sets the timeout to close the connection is:
el




NEXT




<s> static int bcm4908img_bootfs(int argc, char **argv) {
struct bcm4908img_info info;
const char *pathname = NULL;
const char *mode;
const char *cmd;
FILE *fp;
int c;
int err = 0;

while ((c = getopt(argc, argv, "i:")) != -1) {
switch (c) {
case 'i':
pathname = optarg;
break;
}
}

if (argc - optind < 1) {
fprintf(stderr, "No bootfs command specified\n");
err = -EINVAL;
goto out;
}
cmd = argv[optind++];

mode = strcmp(cmd, "mv") ? "r" : "r+";
fp = bcm4908img_open(pathname, mode);
if (!fp) {
fprintf(stderr, "Failed to open BCM4908 image\n");
err = -EACCES;
goto out;
}

err = bcm4908img_parse(fp, &info);
if (err) {
fprintf(stderr, "Failed to parse BCM4908 image\n");
goto err_close;
}

if (!strcmp(cmd, "ls")) {
err = bcm4908img_bootfs_ls(fp, &info);
} else if (!strcmp(cmd, "mv")) {
err = bcm4908img_bootfs_mv(fp, &info, argc, argv);
} else {
err = -EINVAL;
fprintf(stderr, "Unsupported bootfs command: %s\n", cmd);
}

err_close:
bcm4908img_close(fp);
out:
return err;
}

The above function is used to handle “image” commands, and it handles all of the following commands.
-image ls
-image mv src dst

There are two main tasks for me to finish.

## image ls command

### image




NEXT




<s> static int rtl8366s_get_vlan_mc(struct rtl8366_smi *smi, u32 index,
struct rtl8366_vlan_mc *vlanmc)
{
u32 data[2];
int err;
int i;

memset(vlanmc, '\0', sizeof(struct rtl8366_vlan_mc));

if (index >= RTL8366S_NUM_VLANS)
return -EINVAL;

for (i = 0; i < 2; i++) {
err = rtl8366_smi_read_reg(smi,
RTL8366S_VLAN_MC_BASE(index) + i,
&data[i]);
if (err)
return err;
}

vlanmc->vid = data[0] & RTL8366S_VLAN_VID_MASK;
vlanmc->priority = (data[0] >> RTL8366S_VLAN_PRIORITY_SHIFT) &
RTL8366S_VLAN_PRIORITY_MASK;
vlanmc->untag = (data[1] >> RTL8366S_VLAN_UNTAG_SHIFT) &
RTL8366S_VLAN_UNTAG_MASK;
vlanmc->member = data[1] & RTL8366S_VLAN_MEMBER_MASK;
vlanmc->fid = (data[1] >> RTL8366S_VLAN_FID_SHIFT) &
RTL8366S_VLAN_FID_MASK;

return 0;
}

The above function is used to query the VLAN multicast configuration.</s>




NEXT




<s> oxnas_pcie_map_registers(struct platform_device *pdev,
struct device_node *np,
struct oxnas_pcie *pcie)
{
struct resource regs;
int ret = 0;
u32 outbound_ctrl_offset;
u32 pcie_ctrl_offset;

ret = of_address_to_resource(np, 0, &regs);
if (ret) {
dev_err(&pdev->dev, "failed to parse base register space\n");
return -EINVAL;
}

pcie->base = devm_ioremap_resource(&pdev->dev, &regs);
if (!pcie->base) {
dev_err(&pdev->dev, "failed to map base register space\n");
return -ENOMEM;
}

ret = of_address_to_resource(np, 1, &regs);
if (ret) {
dev_err(&pdev->dev, "failed to parse inbound register space\n");
return -EINVAL;
}

pcie->inbound = devm_ioremap_resource(&pdev->dev, &regs);
if (!pcie->inbound) {
dev_err(&pdev->dev, "failed to map inbound register space\n");
return -ENOMEM;
}

pcie->phy = devm_of_phy_get(&pdev->dev, np, NULL);
if (IS_ERR(pcie->phy)) {
if (PTR_ERR(pcie->phy) == -EPROBE_DEFER) {
dev_err(&pdev->dev, "failed to probe phy\n");
return PTR_ERR(pcie->phy);
}
dev_warn(&pdev->dev, "phy not attached\n");
pcie->phy = NULL;
}

if (of_property_read_u32(np, "plxtech,pcie-outbound-offset",
&outbound_ctrl_offset)) {
dev_err(&pdev->dev, "failed to parse outbound register offset\n");
return -EINVAL;
}
pcie->outbound_offset = outbound_ctrl_offset;

if (of_property_read_u32(np, "plxtech,pcie-ctrl-offset",
&pcie_ctrl_offset)) {
dev_err(&pdev->dev, "failed to parse pcie-ctrl register offset\n");
return -EINVAL;
}
pcie->pcie_ctrl_offset = pcie_ctrl_offset;

return 0;
}

The above function is used to map the base registers of Oxnas PCIe driver using of_address_to_resource() and devm_ioremap_resource() API. The function first gets the base register space by calling of_address_to_resource(). If the




NEXT




<s> int spl_start_uboot(void)
{
/* break into full u-boot on 'c' */
return (serial_tstc() && serial_getc() == 'c');
}

The above function is used to execute the full uboot if we send 'c' (Control character) by telnet. If we don't want telnet to access board then we would have to uncomment the following line in mpss_serial.c (m




NEXT




<s> static void sata_oxnas_port_irq(struct ata_port *ap, int force_error)
{
struct ata_queued_cmd *qc;
struct sata_oxnas_port_priv *pd = ap->private_data;
void __iomem *port_base = pd->port_base;

u32 int_status;
unsigned long flags = 0;

DPRINTK("ENTER port %d irqstatus %x\n", ap->port_no,
ioread32(port_base + INT_STATUS));

if (ap->qc_active & (1ULL << ATA_TAG_INTERNAL)) {
qc = ata_qc_from_tag(ap, ATA_TAG_INTERNAL);
DPRINTK("completing non-ncq cmd\n");

if (qc)
ata_qc_complete(qc);

return;
}

qc = ata_qc_from_tag(ap, ap->link.active_tag);


/* record the port's interrupt */
int_status = ioread32(port_base + INT_STATUS);

/* If there's no command associated with this IRQ, ignore it. We may get
* spurious interrupts when cleaning-up after a failed command, ignore
* these too. */
if (likely(qc)) {
/* get the status before any error cleanup */
qc->err_mask = ac_err_mask(sata_oxnas_check_status(ap));
if (force_error) {
/* Pretend there has been a link error */
qc->err_mask |= AC_ERR_ATA_BUS;
DPRINTK(" ####force error####\n");
}
/* tell libata we're done */
local_irq_save(flags);
sata_oxnas_irq_clear(ap);
local_irq_restore(flags);
ata_qc_complete(qc);
} else {
VPRINTK("Ignoring interrupt, can't find the command tag="
"%d %08x\n", ap->link.active_tag, ap->qc_active);
}

/* maybe a hotplug event */
if (unlikely(int_status & INT_LINK_SERROR)) {
u32 serror;

sata_oxnas_scr_read_port(ap, SCR_ERROR, &serror);
if (serror & (SERR_DEV_XCHG | SERR_PHYRDY_CHG)) {
ata_ehi_hotplugged(&ap->link.eh_info);
ata_port_freeze(ap);
}
}
}

The above function is used to deal with interrupts from SATA oxna ports during command execution.
The check_status is a function provided in the port_private member of sata_oxnas_port_priv is defined like this:

static inline u3




NEXT




<s> static void ag71xx_oom_timer_handler(struct timer_list *t)
{
struct ag71xx *ag = from_timer(ag, t, oom_timer);

napi_schedule(&ag->napi);
}

The above function is used to schedule a new timer at each wakeup of the
NAPI poll function which will schedule another OOM timer on an ag71xx
card if ag71xx_handle_ag71xx_out_of_memory() failed




NEXT




<s> static void AT91_XmodemComplete(AT91S_PipeStatus status, void *pVoid)
{
/* stop the Xmodem tempo */
svcXmodem.tempo.Stop(&(svcXmodem.tempo));
XmodemComplete = 1;
}

The above function is used to terminate the Xmodem tempo of an ATFax channel.
The following statement causes the tempo to stop after the last packet is sent.
```
AT91S_PipeStatus status = SVC_Pipe_




NEXT




<s> rtk_api_ret_t rtk_l2_ipMcastAddr_get(rtk_l2_ipMcastAddr_t *pIpMcastAddr)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pIpMcastAddr)
return RT_ERR_NULL_POINTER;

if( (pIpMcastAddr->dip & 0xF0000000) != 0xE0000000)
return RT_ERR_INPUT;

memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
l2Table.sip = pIpMcastAddr->sip;
l2Table.dip = pIpMcastAddr->dip;
l2Table.l3lookup = 1;
l2Table.l3vidlookup = 0;
method = LUTREADMETHOD_MAC;
if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
return retVal;

/* Get Logical port mask */
if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pIpMcastAddr->portmask)) != RT_ERR_OK)
return retVal;

pIpMcastAddr->priority      = l2Table.lut_pri;
pIpMcastAddr->fwd_pri_en    = l2Table.fwd_en;
pIpMcastAddr->igmp_asic     = l2Table.igmp_asic;
pIpMcastAddr->igmp_index    = l2Table.igmpidx;
pIpMcastAddr->address       = l2Table.address;

return RT_ERR_OK;
}

The above function is used to get MCAST address related configuration. It is used to query one MCAST address and its related configuration. It will be called when the following events occur.

    a. The configuration of MCAST address is being configured.

    b




NEXT




<s> rtk_api_ret_t rtk_cpu_tagPort_get(rtk_port_t *pPort, rtk_cpu_insert_t *pMode)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk, port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPort)
return RT_ERR_NULL_POINTER;

if(NULL == pMode)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicCputagPortmask(&pmsk)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicCputagTrapPort(&port)) != RT_ERR_OK)
return retVal;

*pPort = rtk_switch_port_P2L_get(port);

if ((retVal = rtl8367c_getAsicCputagInsertMode(pMode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the cpu tag insert port and mode of a port
If the cpu tag function is not configured(for example, when the CPU Tag VLAN mode is Auto mode), the return tag port value will be 0xFFFFFFFF and the tag




NEXT




<s> hostapd_ucode_bss_get_uval(struct hostapd_data *hapd)
{
uc_value_t *val;

if (hapd->ucode.idx)
return wpa_ucode_registry_get(bss_registry, hapd->ucode.idx);

val = uc_resource_new(bss_type, hapd);
hapd->ucode.idx = wpa_ucode_registry_add(bss_registry, val);

return val;
}

The above function is used to obtain uvalue (or a key-value pair) for a
parameter specified via bnm_get.

The problem is due to the function call below:
uc_value_t *val = uc_resource_new(




NEXT




<s> static void rtl839x_read_pie_action(u32 r[],  struct pie_rule *pr)
{
if (r[13] & BIT(3)) { /* ACT_MASK_FWD set, is it a drop? */
if ((r[14] & 0x7) == 1) {
pr->drop = true;
} else {
pr->fwd_sel = true;
pr->fwd_act = r[14] & 0x7;
}
}

pr->bypass_sel = r[13] & BIT(11);
pr->mpls_sel = r[13] & BIT(10);
pr->nopri_sel = r[13] & BIT(9);
pr->ovid_sel = r[13] & BIT(8);
pr->ivid_sel = r[13] & BIT(7);
pr->meter_sel = r[13] & BIT(6);
pr->mir_sel = r[13] & BIT(5);
pr->log_sel = r[13] & BIT(4);

/* TODO: Read in data fields */

pr->bypass_all = r[16] & BIT(9);
pr->bypass_igr_stp = r[16] & BIT(8);
pr->bypass_ibc_sc = r[16] & BIT(7);
}

The above function is used to fill in the fields in the
struct pie_rule structure.

It appears that there are some bits missing/unused,
e.g. the "act_drop" bit (bit 3) is never used, but the





NEXT




<s> uc_hostapd_remove_iface(uc_vm_t *vm, size_t nargs)
{
uc_value_t *iface = uc_fn_arg(0);

if (ucv_type(iface) != UC_STRING)
return NULL;

hostapd_remove_iface(interfaces, ucv_string_get(iface));
hostapd_ucode_update_interfaces();

return NULL;
}

The above function is used to remove an interface from a hostapd (AP) controller.

The new 5.12.0-rc1 upstream kernel is available for testing, and so I went ahead and did a full kernel update, with all the




NEXT




<s> ret_t rtl8367c_setAsicIGMPCRCErrOP(rtk_uint32 operation)
{
ret_t  retVal;

if(operation >= CRC_ERR_OP_END)
return RT_ERR_OUT_OF_RANGE;

/* CRC Error Operation */
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_CKS_ERR_OP_MASK, operation);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the CRC error operation. There are four error operations including :
- None : When a packet received with CRC error, it would just be discarded as invalid packet.
- CRC Ignore : When a packet received with CRC error, it




NEXT




<s> static void rtl838x_rb_cleanup(struct rtl838x_eth_priv *priv, int status)
{
for (int r = 0; r < priv->rxrings; r++) {
struct ring_b *ring = priv->membase;
struct p_hdr *h;
u32 *last;

pr_debug("In %s working on r: %d\n", __func__, r);
last = (u32 *)KSEG1ADDR(sw_r32(priv->r->dma_if_rx_cur + r * 4));
do {
if ((ring->rx_r[r][ring->c_rx[r]] & 0x1))
break;
pr_debug("Got something: %d\n", ring->c_rx[r]);
h = &ring->rx_header[r][ring->c_rx[r]];
memset(h, 0, sizeof(struct p_hdr));
h->buf = (u8 *)KSEG1ADDR(ring->rx_space +
r * priv->rxringlen * RING_BUFFER +
ring->c_rx[r] * RING_BUFFER);
h->size = RING_BUFFER;
/* make sure the header is visible to the ASIC */
mb();

ring->rx_r[r][ring->c_rx[r]] = KSEG1ADDR(h) | 0x1 | (ring->c_rx[r] == (priv->rxringlen - 1) ?
WRAP :
0x1);
ring->c_rx[r] = (ring->c_rx[r] + 1) % priv->rxringlen;
} while (&ring->rx_r[r][ring->c_rx[r]] != last);
}
}

The above function is used to perform the PCI link speed negotiation with a link partner and to setup the internal link.

Rtl8201
For the Rtl82xx link negotiation, it has been mentioned that there’s a table




NEXT




<s> static int nct5104d_gpio_remove(struct platform_device *pdev)
{
int i;
struct nct5104d_gpio_data *data = platform_get_drvdata(pdev);

for (i = 0; i < data->nr_bank; i++) {
struct nct5104d_gpio_bank *bank = &data->bank[i];

gpiochip_remove (&bank->chip);
}

return 0;
}

The above function is used to implement nct5104d_gpio driver’s remove function</s>




NEXT




<s> static int b53_mmap_write64(struct b53_device *dev, u8 page, u8 reg,
u64 value)
{
u32 hi, lo;

hi = (u32)(value >> 32);
lo = (u32)value;

if (WARN_ON(reg % 4))
return -EINVAL;

b53_mmap_write32(dev, page, reg, lo);
b53_mmap_write32(dev, page, reg + 4, hi);

return 0;
}

The above function is used to update the b53 device memory with a
new value.</s>




NEXT




<s> rtk_api_ret_t rtk_qos_dscpRemark2Dscp_set(rtk_dscp_t dscp, rtk_dscp_t rmkDscp)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((dscp > RTK_DSCPMAX) || (rmkDscp > RTK_DSCPMAX))
return RT_ERR_QOS_DSCP_VALUE;

if ((retVal = rtl8367c_setAsicRemarkingDscp2Dscp(dscp, rmkDscp)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the DSCP remarking values on L2. To set the DSCP value on L3, we could directly call
rtl8367c_setAsicFowardDscp() function.</s>




NEXT




<s> uc_bpf_map_delete(uc_vm_t *vm, size_t nargs)
{
struct uc_bpf_map *map = uc_fn_thisval("bpf.map");
uc_value_t *a_key = uc_fn_arg(0);
uc_value_t *a_return = uc_fn_arg(1);
void *key, *val = NULL;
int ret;

if (!map)
err_return(EINVAL, NULL);

key = uc_bpf_map_arg(a_key, "key", map->key_size);
if (!key)
return NULL;

if (!ucv_is_truish(a_return)) {
ret = bpf_map_delete_elem(map->fd.fd, key);

return ucv_boolean_new(ret == 0);
}

val = alloca(map->val_size);
if (bpf_map_lookup_and_delete_elem(map->fd.fd, key, val))
return NULL;

return ucv_string_new_length(val, map->val_size);
}

The above function is used to delete an element with a matching key from a bpf_map_t map. The first argument is the map that will be used, second argument contains the key of the element to delete, and the return value will be used to return the deleted




NEXT




<s> static irqreturn_t sata_oxnas_interrupt(int irq, void *dev_instance)
{
struct ata_host *ah = dev_instance;
struct sata_oxnas_host_priv *hd = ah->private_data;
void __iomem *core_base = hd->core_base;

u32 int_status;
irqreturn_t ret = IRQ_NONE;
u32 port_no;
u32 mask;
int bug_present;

/* loop until there are no more interrupts */
while ((int_status = (ioread32(core_base + CORE_INT_STATUS)) &
(COREINT_END | (COREINT_END << 1)))) {

/* clear any interrupt */
iowrite32(int_status, core_base + CORE_INT_CLEAR);

/* Only need workaround_bug_6320 for single disk systems as dual
* disk will use uCode which prevents this read underrun problem
* from occurring.
* All single disk systems will use port 0 */
for (port_no = 0; port_no < hd->n_ports; ++port_no) {
/* check the raw end of command interrupt to see if the
* port is done */
mask = (COREINT_END << port_no);
if (!(int_status & mask))
continue;

/* this port had an interrupt, clear it */
iowrite32(mask, core_base + CORE_INT_CLEAR);
/* check for bug 6320 only if no microcode was loaded */
bug_present = (hd->current_ucode == UNKNOWN_MODE) &&
sata_oxnas_bug_6320_detect(ah->ports[port_no]);

sata_oxnas_port_irq(ah->ports[port_no],
bug_present);
ret = IRQ_HANDLED;
}
}

return ret;
}

The above function is used to handle the interrupt. It checks a register in the
core bus module, extract interrupt status, and performs the necessary operations
on the sata ports to handle each interrupt status. The main loop of the code
checks if there are any more




NEXT




<s> void ag71xx_debugfs_root_exit(void)
{
debugfs_remove(ag71xx_debugfs_root);
ag71xx_debugfs_root = NULL;
}

The above function is used to exit from the debugfs root and de-register the /sys/kernel/debug/ag71xx/ dir. After that root is closed.

To re-open the debugfs root, below functions are used:

static




NEXT




<s> rtk_api_ret_t rtk_svlan_l2mc2s_del(rtk_mac_t mac, rtk_mac_t macMsk)
{
rtk_api_ret_t retVal;
rtk_uint32 i;
rtk_uint32 l2add, l2Mask;
rtl8367c_svlan_mc2s_t svlanMC2SConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (mac.octet[0]!= 1&&mac.octet[1]!=0)
return RT_ERR_INPUT;

l2add = (mac.octet[2] << 24) | (mac.octet[3] << 16) | (mac.octet[4] << 8) | mac.octet[5];
l2Mask = (macMsk.octet[2] << 24) | (macMsk.octet[3] << 16) | (macMsk.octet[4] << 8) | macMsk.octet[5];

for (i = 0; i <= RTL8367C_MC2SIDXMAX; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;

if (TRUE == svlanMC2SConf.valid)
{
if (svlanMC2SConf.format == SVLAN_MC2S_MODE_MAC &&
svlanMC2SConf.sdata==l2add&&
svlanMC2SConf.smask==l2Mask)
{
memset(&svlanMC2SConf, 0, sizeof(rtl8367c_svlan_mc2s_t));
if ((retVal = rtl8367c_setAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;
return RT_ERR_OK;
}
}
}

return RT_ERR_OUT_OF_RANGE;
}

The above function is used to configure Multicast to Switching Mac Address Table by programming the related registers inside ASIC. If the configuration is failed, the function will return negative value, and return positive value if the configuration is succesful. Function description and parameters are




NEXT




<s> static void switch_chan_fallback_cb(void *eloop_data, void *user_ctx)
{
struct hostapd_iface *iface = eloop_data;
struct hostapd_freq_params *freq_params = user_ctx;

hostapd_switch_channel_fallback(iface, freq_params);
}

The above function is used to make sure that if roaming does not work well and
the driver is in non-interference mode we switch to a fallback channel and retry
the roaming. The frequency parameter passed to the function needs to be set to
the fall




NEXT




<s> static void aca_dma_init(struct dc_ep_priv *priv)
{
int i;
struct aca_fw_info *fw_info = to_fw_info(priv);

aca_dma_ctrl_init(priv);
aca_dma_port_init(priv);

for (i = 0; i < fw_info->chan_num; i++) {
aca_dma_ch_init(priv, i,
fw_info->adma_desc_base[i] | priv->phymem,
DESC_NUM_PER_CH);
}

dev_dbg(priv->dev, "aca dma init done\n");
}

The above function is used to initialize the ACA DMA. This function calls the three functions mentioned above :-

aca_dma_ctrl_init(priv) :- This function initializes the DMA CTRL block.

aca_dma_port_init




NEXT




<s> static int rtl839x_set_ageing_time(unsigned long msec)
{
int t = sw_r32(RTL839X_L2_CTRL_1);

t &= 0x1FFFFF;
t = t * 3 / 5; /* Aging time in seconds. 0: L2 aging disabled */
pr_debug("L2 AGING time: %d sec\n", t);

t = (msec * 5 + 2000) / 3000;
t = t > 0x1FFFFF ? 0x1FFFFF : t;
sw_w32_mask(0x1FFFFF, t, RTL839X_L2_CTRL_1);
pr_debug("Dynamic aging for ports: %x\n", sw_r32(RTL839X_L2_PORT_AGING_OUT));

return 0;
}

The above function is used to modify the aging time out time for each port on RTL8390 as described in datasheet.</s>




NEXT




<s> static int mtk_bmt_debug(void *data, u64 val)
{
return bmtd.ops->debug(data, val);
}

The above function is used to register/unregister the debug callback while debugfs is unregistered. However, debugfs is registered/unregistered by using register_bmt_debugfs() and unregister_bmt_debugfs() in bmt_debugfs_




NEXT




<s> static int read_byte(void *object, unsigned char **buffer, UInt32 *bufferSize)
{
static unsigned int val;

if (((unsigned int)offset % 4) == 0) {
val = *(unsigned int *)data;
data += 4;
}

*bufferSize = 1;
*buffer = ((unsigned char *)&val) + (offset++ & 3);

return LZMA_RESULT_OK;
}

The above function is used to read one byte at a time from the data
stream. If the offset in the data is not aligned to the 4-byte boundry
then the offset is incremented to bring in the next 4-byte aligned block.






NEXT




<s> static void XmodemProtocol(AT91S_PipeStatus status, void *pVoid)
{
AT91PS_SBuffer pSBuffer = (AT91PS_SBuffer) xmodemPipe.pBuffer->pChild;
AT91PS_USART   pUsart     = svcXmodem.pUsart;

if (pSBuffer->szRdBuffer == 0) {
/* Start a tempo to wait the Xmodem protocol complete */
svcXmodem.tempo.Start(&(svcXmodem.tempo), 10, 0, AT91_XmodemComplete, pUsart);
}
}

The above function is used to parse different protocol types. The parameter
status is the status of the Pipe, and it indicates that if the packet type is
10H (S1) or 0AH (EOF).
If the status contains S1 (




NEXT




<s> ret_t rtl8367c_setAsicMeterExceedStatus(rtk_uint32 index)
{
if(index > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(index < 32)
return rtl8367c_setAsicRegBit(RTL8367C_METER_OVERRATE_INDICATOR_REG(index), RTL8367C_METER_EXCEED_OFFSET(index), 1);
else
return rtl8367c_setAsicRegBit(RTL8367C_REG_METER_OVERRATE_INDICATOR2 + ((index - 32) >> 4), RTL8367C_METER_EXCEED_OFFSET(index), 1);

}

The above function is used to set AsiC register bit to indicate the status of exceeding the meter id.

rtl8367c_setAsicDmacStat(unsigned char* pDst, rtk_uint16 dmac,




NEXT




<s> int hvfprintf(const char *fmt, va_list va)
{
char *s;

do {
if(*fmt == '%')	{
bool done = false;

int type = 0;
int precision = 0;

do {
fmt++;
switch(*fmt) {
case '0' :
if(!precision)
type |= ZEROPAD;
case '1' :
case '2' :
case '3' :
case '4' :
case '5' :
case '6' :
case '7' :
case '8' :
case '9' :
precision = precision * 10 + (*fmt - '0');
break;
case '.' :
break;
case 's' :
s = va_arg(va, char *);
if(!s)
puts("<NULL>");
else
puts(s);
done = true;
break;
case 'c' :
putc(va_arg(va, int));
done = true;
break;
case 'd' :
number(va_arg(va, int), 10, 0, precision, type);
done = true;
break;
case 'x' :
case 'X' :
number(va_arg(va, int), 16, 0, precision, type);
done = true;
break;
case '%' :
putc(*fmt);
done = true;
default:
putc('%');
putc(*fmt);
done = true;
break;
}
} while(!done);
} else if(*fmt == '\\') {
fmt++;
if(*fmt == 'r') {
putc('\r');
} else if(*fmt == 'n') {
putc('\n');
}
} else {
putc(*fmt);
}
fmt++;
} while(*fmt != 0);

return 0;
}

The above function is used to format and print strings into a text buffer.

This function is incomplete in various ways.  It doesn’t yet handle the
following format specifiers:

%a, %A, %e, %f, %




NEXT




<s> static int file_exist(char *filename)
{
struct stat buffer;

return stat(filename, &buffer) == 0;
}

The above function is used to find out if a file exists. There is a simple
trick that can make the function fail to determine whether or not a file
exists. Look at the function carefully and notice that the stat function
returns 0 if the file exists.




NEXT




<s> BEGIN(INITIAL);

if (prev_token != T_EOL && prev_token != T_HELPTEXT)
fprintf(stderr, "%s:%d:warning: no new line at end of file\n",
current_file->name, yylineno);

if (current_file) {
zconf_endfile();
return T_EOL;
}

The above function is used to print a Warning after the very last token in the script has been returned. This should be added to your parser to stop it printing a useless warning in the script output. If it does not get the value of zconf_file from the command




NEXT




<s> ret_t rtl8367c_setAsicRmaLldp(rtk_uint32 enabled, rtl8367c_rma_t* pRmacfg)
{
rtk_uint32 regData = 0;
ret_t retVal;

if(enabled > 1)
return RT_ERR_ENABLE;

if(pRmacfg->operation >= RMAOP_END)
return RT_ERR_RMA_ACTION;

if(pRmacfg->trap_priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_RMA_LLDP_EN, RTL8367C_RMA_LLDP_EN_OFFSET,enabled);
if(retVal != RT_ERR_OK)
return retVal;

regData |= (pRmacfg->portiso_leaky & 0x0001);
regData |= ((pRmacfg->vlan_leaky & 0x0001) << 1);
regData |= ((pRmacfg->keep_format & 0x0001) << 2);
regData |= ((pRmacfg->trap_priority & 0x0007) << 3);
regData |= ((pRmacfg->discard_storm_filter & 0x0001) << 6);
regData |= ((pRmacfg->operation & 0x0003) << 7);

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, pRmacfg->trap_priority);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_setAsicReg(RTL8367C_REG_RMA_CTRL_LLDP, regData);
}

The above function is used to set the Asic register of RMA(Receive Mac-address Learning Disablement Protocol).
The RMacfg is the basic structure that defines the RMA.
In the RMacfg structure, the fields represent the RMA registers




NEXT




<s> static int radius_get_eap_user(void *ctx, const u8 *identity,
size_t identity_len, int phase2,
struct eap_user *user)
{
struct radius_state *s = ctx;
struct radius_user_data *u = phase2 ? &s->phase2 : &s->phase1;
struct blob_attr *entry;
struct eap_user *data;
char *id;

if (identity_len > 512)
return -1;

load_userfile(s);

id = alloca(identity_len + 1);
memcpy(id, identity, identity_len);
id[identity_len] = 0;

entry = radius_user_get(u, id);
if (!entry)
return -1;

if (!user)
return 0;

data = radius_user_get_state(u, entry, id);
if (!data)
return -1;

*user = *data;
if (user->password_len > 0)
user->password = os_memdup(user->password, user->password_len);
if (user->salt_len > 0)
user->salt = os_memdup(user->salt, user->salt_len);
user->phase2 = phase2;

return 0;
}

The above function is used to get an eap_user corresponding to a given identity. It allocates memory for the password and salt if these attributes are not null.

The following bug has been reported for this commit already.

RADIUS can be used




NEXT




<s> static void rb91x_nand_write(struct rb91x_nand_drvdata *drvdata,
const u8 *buf,
unsigned len)
{
void __iomem *base = drvdata->ath79_gpio_base;
u32 oe_reg;
u32 out_reg;
u32 out;
unsigned i;

rb91x_nand_latch_lock(drvdata, 1);
rb91x_nand_rst_key_poll_disable(drvdata, 1);

oe_reg = __raw_readl(base + AR71XX_GPIO_REG_OE);
out_reg = __raw_readl(base + AR71XX_GPIO_REG_OUT);

/* Set data lines to output mode */
__raw_writel(oe_reg & ~(RB91X_NAND_DATA_BITS | RB91X_NAND_NRW_BIT),
base + AR71XX_GPIO_REG_OE);

out = out_reg & ~(RB91X_NAND_DATA_BITS | RB91X_NAND_NRW_BIT);
for (i = 0; i != len; i++) {
u32 data;

data = (buf[i] & RB91X_NAND_HIGH_DATA_MASK) <<
RB91X_NAND_HIGH_DATA_SHIFT;
data |= buf[i] & RB91X_NAND_LOW_DATA_MASK;
data |= out;
__raw_writel(data, base + AR71XX_GPIO_REG_OUT);

/* Deactivate WE line */
data |= RB91X_NAND_NRW_BIT;
__raw_writel(data, base + AR71XX_GPIO_REG_OUT);
/* Flush write */
__raw_readl(base + AR71XX_GPIO_REG_OUT);
}

/* Restore registers */
__raw_writel(out_reg, base + AR71XX_GPIO_REG_OUT);
__raw_writel(oe_reg, base + AR71XX_GPIO_REG_OE);
/* Flush write */
__raw_readl(base + AR71XX_GPIO_REG_OUT);

rb91x_nand_rst_key_poll_disable(drvdata, 0);
rb91x_nand_latch_lock(drvdata, 0);
}

The above function is used to send data to NAND from ATMega32 based AT91
SAM7 based AT91RF610, which has two SPI ports.</s>




NEXT




<s> int wl_glue_register(void)
{
int err;

switch(active_bus_type)
{
#ifdef CONFIG_SSB
case WL_GLUE_BUS_TYPE_SSB:
err = ssb_driver_register(&wl_glue_ssb_driver);
break;
#endif /* CONFIG_SSB */

#ifdef CONFIG_BCMA
case WL_GLUE_BUS_TYPE_BCMA:
err = bcma_driver_register(&wl_glue_bcma_driver);
break;
#endif /* CONFIG_BCMA */

default:
pr_err("Not attaching through glue driver due to unsupported bus\n");
err = -ENOSYS;
break;
}

if (!err)
{
pr_info("SSB/BCMA glue driver successfully attached\n");
wl_glue_attached = 1;
}

return err;
}

The above function is used to register the new glue driver to the kernel driver. When the wireless device gets power up, this function gets automatically invoked. The function takes a bus type as a parameter. If it is SSB then it makes a call to "ssb_




NEXT




<s> void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag, int rx, int tx)
{
struct ag71xx_napi_stats *stats = &ag->debug.napi_stats;

if (rx) {
stats->rx_count++;
stats->rx_packets += rx;
if (rx <= AG71XX_NAPI_WEIGHT)
stats->rx[rx]++;
if (rx > stats->rx_packets_max)
stats->rx_packets_max = rx;
}

if (tx) {
stats->tx_count++;
stats->tx_packets += tx;
if (tx <= AG71XX_NAPI_WEIGHT)
stats->tx[tx]++;
if (tx > stats->tx_packets_max)
stats->tx_packets_max = tx;
}
}

The above function is used to update the rx and tx statistics. For each tx/rx packet, the function is called with the packet count it handled for that particular time. The packets are accumulated until a new value is supplied. The function then goes about updating the rx and




NEXT




<s> static int qca807x_gpio_dir_out(struct gpio_chip *gc, unsigned int offset, int value)
{
qca807x_gpio_set(gc, offset, value);

return 0;
}

The above function is used to write into a gpio. A gpio_set_array is created above
this function.

/*

* Register mapping.

*

* 0x00 - GPIO PIN Control Register

*/</s>




NEXT




<s> static void dma_ctrl_global_polling_enable(struct dc_ep_dev *dev, int interval)
{
u32 reg = 0;

reg |= (1 << 31);
reg |= (interval << 4);

ep_wr32_mask(DMA_CPOLL_CNT_MASK,
reg,  DMA_CPOLL);
}

The above function is used to configure the polling interval value for the global DMA controller polling feature.

How does the global DMA controller support the global DMA controller polling feature?

The global DMA controller supports a global DMA controller polling feature that detects whether




NEXT




<s> inline void rtl930x_exec_tbl0_cmd(u32 cmd)
{
sw_w32(cmd, RTL930X_TBL_ACCESS_CTRL_0);
do { } while (sw_r32(RTL930X_TBL_ACCESS_CTRL_0) & (1 << 17));
}

The above function is used to reset table or load table content from table flash. To reset some tables, this function is used along with tl43xx_tbl_ops.reset_table function.

void tl43xx_tbl_ops.reset




NEXT




<s> static int mt7621_nfc_attach_chip(struct nand_chip *nand)
{
struct mt7621_nfc *nfc = nand_get_controller_data(nand);
int ret;

if (nand->options & NAND_BUSWIDTH_16) {
dev_err(nfc->dev, "16-bit buswidth is not supported");
return -EINVAL;
}

ret = mt7621_nfc_ecc_init(nfc);
if (ret)
return ret;

return mt7621_nfc_set_page_format(nfc);
}

The above function is used to configure flash memory.</s>




NEXT




<s> rtl_reset(struct switch_dev *dev)
{
rtl_hw_init(dev);
return 0;
}

The above function is used to reinit the RTL8153 HW with the last working
parameters. The function is called both for boot time and after the
restart_handler().

For the boot time, the first call of rtl_init




NEXT




<s> static int rb4xx_cpld_probe(struct spi_device *spi)
{
struct device *dev = &spi->dev;
struct rb4xx_cpld *cpld;
int ret;

cpld = devm_kzalloc(dev, sizeof(*cpld), GFP_KERNEL);
if (!cpld)
return -ENOMEM;

dev_set_drvdata(dev, cpld);

cpld->spi		= spi;
cpld->write_nand	= rb4xx_cpld_write_nand;
cpld->read_nand		= rb4xx_cpld_read_nand;
cpld->gpio_set_0_7	= rb4xx_cpld_gpio_set_0_7;
cpld->gpio_set_8	= rb4xx_cpld_gpio_set_8;

spi->mode = SPI_MODE_0 | SPI_TX_DUAL;
ret = spi_setup(spi);
if (ret)
return ret;

return devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,
rb4xx_cpld_cells,
ARRAY_SIZE(rb4xx_cpld_cells),
NULL, 0, NULL);
}

The above function is used to initialize and use the spi-controller present in armada372x chip. In this process first the kobject is created and allocated, then the device is allocated to rb4xx_cpld. Device is then added to the driver




NEXT




<s> hostapd_ucode_update_bss_list(struct hostapd_iface *iface, uc_value_t *if_bss, uc_value_t *bss)
{
uc_value_t *list;
int i;

list = ucv_array_new(vm);
for (i = 0; i < iface->num_bss; i++) {
struct hostapd_data *hapd = iface->bss[i];
uc_value_t *val = hostapd_ucode_bss_get_uval(hapd);

ucv_array_set(list, i, ucv_get(ucv_string_new(hapd->conf->iface)));
ucv_object_add(bss, hapd->conf->iface, ucv_get(val));
}
ucv_object_add(if_bss, iface->phy, ucv_get(list));
}

The above function is used to update bss_config in uc-core for an interface.

There exists a bug in uc-core related to the above function that the bss_idx values are not updated and this eventually leads to incorrect bss_idx




NEXT




<s> static int rttm_next_event(unsigned long delta, struct clock_event_device *clkevt)
{
struct timer_of *to = to_timer_of(clkevt);

RTTM_DEBUG(to->of_base.base);
rttm_stop_timer(to->of_base.base);
rttm_set_period(to->of_base.base, delta);
rttm_start_timer(to, RTTM_CTRL_COUNTER);

return 0;
}

The above function is used to update the counter value after one event timeout. However, in my testing, the timer does not work due to a missing call to ktime_get(), which is responsible for triggering events by calling rttm_time_event. This is




NEXT




<s> static int mt7620_fwd_config(struct fe_priv *priv)
{
struct net_device *dev = priv_netdev(priv);

fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~7, MT7620A_GDMA1_FWD_CFG);

mt7620_txcsum_config((dev->features & NETIF_F_IP_CSUM));
mt7620_rxcsum_config((dev->features & NETIF_F_RXCSUM));

return 0;
}

The above function is used to set csum offloading settings(rx/tx checksum offloading). This function is called by mt7620_phy_config().

The corresponding csum offloading function is mt7620_txcsum_




NEXT




<s> rtk_uint32 rtk_switch_isValidTrunkGrpId(rtk_uint32 grpId)
{
if(init_state != INIT_COMPLETED)
return 0x00;

if( (halCtrl->trunk_group_mask & (0x01 << grpId) ) != 0)
return RT_ERR_OK;
else
return RT_ERR_LA_TRUNK_ID;

}

The above function is used to check if a given trunk group ID is valid. The trunk group ID should fall between 0 ~ 15.

But for now there could be 0-7 trunk group available and ID 7-15 are invalid and could




NEXT




<s> static int rtl838x_l3_setup(struct rtl838x_switch_priv *priv)
{
/* Nothing to be done */
return 0;
}

The above function is used to setup IPv4 inbound and outbound lookup using
the VLAN information.

The following functions are used to setup IPv6 lookup in rtl838x datapath:

static int rtl838




NEXT




<s> static inline int msp430_cmd(struct spi_device *spi, u8 tx[MSP430_CMD_BYTES],
u8 rx[MSP430_CMD_BYTES])
{
struct device *dev = &spi->dev;
int rc;

memset(rx, 0, MSP430_CMD_BYTES);

rc = spi_write_then_read(spi, tx, MSP430_CMD_BYTES,
rx, MSP430_CMD_BYTES);
if (rc)
dev_err(dev, "spi error\n");

dev_dbg(dev, "msp430_cmd: [%02x %02x %02x %02x %02x %02x]"
" -> [%02x %02x %02x %02x %02x %02x]",
tx[0], tx[1], tx[2], tx[3], tx[4], tx[5],
rx[0], rx[1], rx[2], rx[3], rx[4], rx[5]);

return rc;
}

The above function is used to update register value using following parameters.

struct spi_device *spi : The address of spi device which is used for tx and rx operation of command

u8 tx[MSP430_CMD_BYTES]




NEXT




<s> static int rtl8366rb_sw_set_mirror_pause_frames_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

if (val->value.i)
data = RTL8366RB_PMCR_MIRROR_SPC;
else
data = 0;

return rtl8366_smi_rmwr(smi, RTL8366RB_PMCR, RTL8366RB_PMCR_MIRROR_SPC, data);
}

The above function is used to set the enable bit of mirror spc function of PMCR, so if the enable bit is 1, the SMAC's pause frames can be mirrored.

According to the datasheet, the pause frames of SM




NEXT




<s> static void rtl839x_enable_learning(int port, bool enable)
{
/* Limit learning to maximum: 32k entries */

sw_w32_mask(0x7fff << 2, enable ? (0x7fff << 2) : 0,
RTL839X_L2_PORT_LRN_CONSTRT + (port << 2));
}

The above function is used to to disable or enable port learning for a particular port.

What I have noticed when I am running packet capture on a port is that I see some frames that are not related to the packets coming on that port. The same thing happens on other




NEXT




<s> ret_t rtl8367c_getAsicPortIngressBandwidthBypass(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_SW_DUMMY0, RTL8367C_INGRESSBW_BYPASS_EN_OFFSET, pEnabled);
}

The above function is used to check whether the ingress bandwidth bypass is enabled.

The RTL8367C_SW_DUMMY0 register is shown as following:

typedef struct _rtl8367c_




NEXT




<s> static inline u32 aca_txin_hd_cnt(struct dc_ep_dev *dev)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_aca_txin_hd_cnt(dev->priv);
}

The above function is used to retrieve the number of hardware descriptors in the TX/IN stage of the DMA engine. The
ACA TXIN Descriptor Count register is stored in the memory location dev->priv in the dc_aca_device struct. Therefore, we





NEXT




<s> ret_t rtl8367c_getAsicTrunkingHashTable1(rtk_uint32 hashval, rtk_uint32* pPortId)
{
if(hashval > RTL8367C_TRUNKING_HASHVALUE_MAX)
return RT_ERR_OUT_OF_RANGE;

if(hashval >= 8)
return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL3, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH8_MASK<<((hashval-8)*2), pPortId);
else
return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL2, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH0_MASK<<(hashval*2), pPortId);
}

The above function is used to get the physical port id by its Hashing Trunk Table(also called hash table) index. Hashing trunk table is an 8K table in ASIC(8K*32b = 262,144 bytes




NEXT




<s> static int rtl8366rb_sw_reset_port_mibs(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

if (val->port_vlan >= RTL8366RB_NUM_PORTS)
return -EINVAL;

return rtl8366_smi_rmwr(smi, RTL8366RB_MIB_CTRL_REG, 0,
RTL8366RB_MIB_CTRL_PORT_RESET(val->port_vlan));
}

The above function is used to reset port related MIB counters of a given port.</s>




NEXT




<s> void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to allocate the start address of the buffer area on the buffer stack. This area will be overwritten by the code generated in the parser.h file for the parser, and is used to locate the start position of the buffer.

#define yy




NEXT




<s> static void esw_rmw(struct rt305x_esw *esw, unsigned reg,
unsigned long mask, unsigned long val)
{
unsigned long flags;

spin_lock_irqsave(&esw->reg_rw_lock, flags);
esw_rmw_raw(esw, reg, mask, val);
spin_unlock_irqrestore(&esw->reg_rw_lock, flags);
}

The above function is used to read the data from an e-sw device and write a new data to register. It uses the
spin_lock_irqsave() and spin_unlock_irqrestore() functions to prevent interrupts from occuring during the course of its execution




NEXT




<s> static int wlc_wsec_key(wlc_param param, void *null, void *value)
{
wl_wsec_key_t wsec_key;
unsigned char *index = value;
unsigned char *key;
unsigned char *data;
unsigned char hex[3];

if ((param & PARAM_MODE) != SET)
return 0;

memset(&wsec_key, 0, sizeof(wsec_key));
if (index[0] == '=') {
wsec_key.flags = WL_PRIMARY_KEY;
index++;
}

if ((index[0] < '1') || (index[0] > '4') || (index[1] != ','))
return -1;

key = index + 2;
if (strncmp(key, "d:", 2) == 0) { /* delete key */
} else if (strncmp(key, "s:", 2) == 0) { /* ascii key */
key += 2;
wsec_key.len = strlen(key);

if ((wsec_key.len != 5) && (wsec_key.len != 13))
return -1;

strcpy(wsec_key.data, key);
} else { /* hex key */
wsec_key.len = strlen(key);
if ((wsec_key.len != 10) && (wsec_key.len != 26))
return -1;

wsec_key.len /= 2;
data = wsec_key.data;
hex[2] = 0;
do {
hex[0] = *(key++);
hex[1] = *(key++);
*(data++) = (unsigned char) strtoul(hex, NULL, 16);
} while (*key != 0);
}

return wl_bssiovar_set(interface, "wsec_key", vif, &wsec_key, sizeof(wsec_key));
}

The above function is used to set the hexadecimal string value of wseckey and is based on function set_wlan_wsec_key which is used to set the hexadecimal string value of wseckey.</s>




NEXT




<s> void rtl839x_set_distribution_algorithm(int group, int algoidx, u32 algomsk)
{
sw_w32_mask(3 << ((group & 0xf) << 1), algoidx << ((group & 0xf) << 1),
RTL839X_TRK_HASH_IDX_CTRL + ((group >> 4) << 2));
sw_w32(algomsk, RTL839X_TRK_HASH_CTRL + (algoidx << 2));
}

The above function is used to tell the silicon how we want it to distribute packets by MAC address into hashing buckets from the tx queues.

This code is present in linux version 2.6.26.

It appears that this allows




NEXT




<s> static int rtl8367b_sw_reset_port_mibs(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
int port;

port = val->port_vlan;
if (port >= RTL8367B_NUM_PORTS)
return -EINVAL;

return rtl8366_smi_rmwr(smi, RTL8367B_MIB_CTRL0_REG(port / 8), 0,
RTL8367B_MIB_CTRL0_PORT_RESET_MASK(port % 8));
}

The above function is used to reset MIBs counters, but why does it need `RTL8367B_NUM_PORTS` value rather than `dev->num_ports` or such?

I understand that there is a mapping of device




NEXT




<s> ret_t rtl8367c_getAsicStormFilterBroadcastEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_STORM_BCAST_REG, port, pEnabled);
}

The above function is used to get Broadcast filter enable in port based on port number.
I understand, It's using ASIC register to achieve. Below code can not pass compiler.
What's wrong with that?
Is it because I didn't declare




NEXT




<s> ret_t rtl8367c_setAsicEavSysTime(rtk_uint32 second, rtk_uint32 nanoSecond)
{
ret_t retVal;
rtk_uint32 sec_h, sec_l, nsec8_h, nsec8_l;
rtk_uint32 nano_second_8;
rtk_uint32 regData, busyFlag, count;

if(nanoSecond > RTL8367C_EAV_NANOSECONDMAX)
return RT_ERR_INPUT;

regData = 0;
sec_h = second >>16;
sec_l = second & 0xFFFF;
nano_second_8 = nanoSecond >> 3;
nsec8_h = (nano_second_8 >>16) & RTL8367C_PTP_TIME_NSEC_H_NSEC_MASK;
nsec8_l = nano_second_8 &0xFFFF;

if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_SEC_H_SEC, sec_h)) != RT_ERR_OK)
return retVal;
if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_SEC_L_SEC, sec_l)) != RT_ERR_OK)
return retVal;
if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_NSEC_L_NSEC, nsec8_l)) != RT_ERR_OK)
return retVal;

regData = nsec8_h | (PTP_TIME_WRITE<<RTL8367C_PTP_TIME_NSEC_H_CMD_OFFSET) | RTL8367C_PTP_TIME_NSEC_H_EXEC_MASK;

if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, regData)) != RT_ERR_OK)
return retVal;

count = 0;
do {
if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, RTL8367C_PTP_TIME_NSEC_H_EXEC_OFFSET, &busyFlag)) != RT_ERR_OK)
return retVal;
count++;
} while ((busyFlag != 0)&&(count<5));

if (busyFlag != 0)
return RT_ERR_BUSYWAIT_TIMEOUT;

return RT_ERR_OK;
}

The above function is used to set the 64-bit time stamp on the port. The
rtl8367c_setAsicEavSysTime function can help set the 64-bit time
stamp in the RTL83




NEXT




<s> rtk_api_ret_t rtk_trap_unmatchMacPktAction_set(rtk_trap_ucast_action_t ucast_action)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (ucast_action >= UCAST_ACTION_FLOODING)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicPortUnmatchedSaBehavior(ucast_action)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to config asic_port unmatched packet action. The default value is forwarding.

Example:

#ifndef RTK_TRAP_ENABLE
#define RTK_TRAP_ENABLE
#endif

#ifdef RT




NEXT




<s> void print_button(WINDOW * win, const char *label, int y, int x, int selected)
{
int i, temp;

wmove(win, y, x);
wattrset(win, selected ? dlg.button_active.atr
: dlg.button_inactive.atr);
waddstr(win, "<");
temp = strspn(label, " ");
label += temp;
wattrset(win, selected ? dlg.button_label_active.atr
: dlg.button_label_inactive.atr);
for (i = 0; i < temp; i++)
waddch(win, ' ');
wattrset(win, selected ? dlg.button_key_active.atr
: dlg.button_key_inactive.atr);
waddch(win, label[0]);
wattrset(win, selected ? dlg.button_label_active.atr
: dlg.button_label_inactive.atr);
waddstr(win, (char *)label + 1);
wattrset(win, selected ? dlg.button_active.atr
: dlg.button_inactive.atr);
waddstr(win, ">");
wmove(win, y, x + temp + 1);
}

The above function is used to draw a button in the following format:

[ ------>][ <label> ][ <label>]

It can be any label and doesn't have to be a button label, which is a label
that has been




NEXT




<s> static void rtl930x_pie_rule_rm(struct rtl838x_switch_priv *priv, struct pie_rule *pr)
{
int idx = pr->id;

rtl930x_pie_rule_del(priv, idx, idx);
clear_bit(idx, priv->pie_use_bm);
}

The above function is used to remove PIE rule from FW.</s>




NEXT




<s> int radius_main(int argc, char **argv)
{
static struct radius_state state = {};
static struct radius_config config = {};
const char *progname = argv[0];
int ret = 0;
int ch;

wpa_debug_setup_stdout();
wpa_debug_level = 0;

if (eloop_init()) {
wpa_printf(MSG_ERROR, "Failed to initialize event loop");
return 1;
}

eap_server_register_methods();
radius_init(&state);

while ((ch = getopt(argc, argv, "6C:c:d:i:k:K:p:P:s:u:")) != -1) {
switch (ch) {
case '6':
config.radius.ipv6 = 1;
break;
case 'C':
config.tls.ca_cert = optarg;
break;
case 'c':
if (config.tls.client_cert2)
return usage(progname);

if (config.tls.client_cert)
config.tls.client_cert2 = optarg;
else
config.tls.client_cert = optarg;
break;
case 'd':
config.tls.dh_file = optarg;
break;
case 'i':
state.eap.server_id = optarg;
state.eap.server_id_len = strlen(optarg);
break;
case 'k':
if (config.tls.private_key2)
return usage(progname);

if (config.tls.private_key)
config.tls.private_key2 = optarg;
else
config.tls.private_key = optarg;
break;
case 'K':
if (config.tls.private_key_passwd2)
return usage(progname);

if (config.tls.private_key_passwd)
config.tls.private_key_passwd2 = optarg;
else
config.tls.private_key_passwd = optarg;
break;
case 'p':
config.radius.auth_port = atoi(optarg);
break;
case 'P':
config.radius.acct_port = atoi(optarg);
break;
case 's':
config.radius.client_file = optarg;
break;
case 'u':
state.user_file = optarg;
break;
default:
return usage(progname);
}
}

if (!config.tls.client_cert || !config.tls.private_key ||
!config.radius.client_file || !state.eap.server_id ||
!state.user_file) {
wpa_printf(MSG_INFO, "missing options\n");
goto out;
}

ret = radius_setup(&state, &config);
if (ret)
goto out;

load_userfile(&state);
eloop_run();

out:
radius_deinit(&state);
os_program_deinit();

return ret;
}

The above function is used to generate radius_main(int argc, char **argv) function in program file by using function parameter 1 is argc and function parameter 2 is argv.

If the program file have the same structure as above, the generated program can be




NEXT




<s> static int rtl8367c_get_vlan( unsigned short vid, struct rtl8367_vlan_info *vlan)
{
rtk_vlan_cfg_t vlan_cfg;

memset(vlan, '\0', sizeof(struct rtl8367_vlan_info));

if (vid >= RTL8367C_NUM_VIDS)
return -EINVAL;

if(rtk_vlan_get(vid,&vlan_cfg))
return -EINVAL;

vlan->vid = vid;
vlan->member = rtl8367c_portmask_phy_to_sw(vlan_cfg.mbr);
vlan->untag = rtl8367c_portmask_phy_to_sw(vlan_cfg.untag);
vlan->fid = vlan_cfg.fid_msti;

return 0;
}

The above function is used to obtain the VLAN ID of a specified device.
It converts the VID to the index of the vlan table, and then gets the
vlan configuration based on the index.</s>




NEXT




<s> static void routerboot_mtd_notifier_remove(struct mtd_info *mtd)
{
if (mtd->type != MTD_NORFLASH)
return;

if (!strcmp(mtd->name, RB_MTD_HARD_CONFIG))
rb_hardconfig_exit();
else if (!strcmp(mtd->name, RB_MTD_SOFT_CONFIG))
rb_softconfig_exit();
}

The above function is used to handle a MTD remove notification (mtd->name). The function is called only on removal of rb_hardconfig MTD and rb_softconfig MTD .

The functions can be placed in drivers/mtd/mtd-




NEXT




<s> ret_t rtl8367c_setAsicPortMirrorIsolation(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_ISO_OFFSET, enabled);
}

The above function is used to set the enable bit of the mirror isolation function in RTL8367C switch.
And I am using this function in the code like this:

ret_t ret = rtl8367c_setAsic




NEXT




<s> static void rtl839x_stp_get(struct rtl838x_switch_priv *priv, u16 msti, u32 port_state[])
{
u32 cmd = 1 << 16 | /* Execute cmd */
0 << 15 | /* Read */
5 << 12 | /* Table type 0b101 */
(msti & 0xfff);
priv->r->exec_tbl0_cmd(cmd);

for (int i = 0; i < 4; i++)
port_state[i] = sw_r32(priv->r->tbl_access_data_0(i));
}

The above function is used to read the contents of the 4 entries that are used in this command to the variable port_state[].</s>




NEXT




<s> int ag71xx_debugfs_init(struct ag71xx *ag)
{
struct device *dev = &ag->pdev->dev;

ag->debug.debugfs_dir = debugfs_create_dir(dev_name(dev),
ag71xx_debugfs_root);
if (!ag->debug.debugfs_dir) {
dev_err(dev, "unable to create debugfs directory\n");
return -ENOENT;
}

debugfs_create_file("int_stats", S_IRUGO, ag->debug.debugfs_dir,
ag, &ag71xx_fops_int_stats);
debugfs_create_file("napi_stats", S_IRUGO, ag->debug.debugfs_dir,
ag, &ag71xx_fops_napi_stats);
debugfs_create_file("tx_ring", S_IRUGO, ag->debug.debugfs_dir,
ag, &ag71xx_fops_tx_ring);
debugfs_create_file("rx_ring", S_IRUGO, ag->debug.debugfs_dir,
ag, &ag71xx_fops_rx_ring);

return 0;
}

The above function is used to create debug directory under /sys/kernel/debugfs under which the debugfs_file will get created

In case of above driver, ag71xx_debugfs_init() will be called form ag71xx_init()




NEXT




<s> int erase_dataflash(unsigned long addr_dest)
{
unsigned int AddrToWrite = addr_dest;
AT91PS_DataFlash pFlash = &DataFlashInst;

pFlash = AT91F_DataflashSelect (pFlash, &AddrToWrite);
if (AddrToWrite == -1)
return -1;

return AT91F_DataFlashErase(pFlash);
}

The above function is used to erase dataflash blocks. It is passed an address in the dataflash to erase , and returns 0 if successful.

Dataflash is not used much for this particular project , though for most microcontrollers is used for flash storage




NEXT




<s> rtk_api_ret_t rtk_svlan_checkAndCreateMbr(rtk_vlan_t vid, rtk_uint32 *pIndex)
{
rtk_api_ret_t retVal;
rtk_uint32 svidx;
rtk_uint32 empty_idx = 0xFFFF;
rtl8367c_svlan_memconf_t svlan_cfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* vid must be 0~4095 */
if (vid > RTL8367C_VIDMAX)
return RT_ERR_VLAN_VID;

/* Null pointer check */
if(NULL == pIndex)
return RT_ERR_NULL_POINTER;

/* Search exist entry */
for (svidx = 0; svidx <= RTL8367C_SVIDXMAX; svidx++)
{
if(svlan_mbrCfgUsage[svidx] == TRUE)
{
if(svlan_mbrCfgVid[svidx] == vid)
{
/* Found! return index */
*pIndex = svidx;
return RT_ERR_OK;
}
}
else if(empty_idx == 0xFFFF)
{
empty_idx = svidx;
}

}

if(empty_idx == 0xFFFF)
{
/* No empty index */
return RT_ERR_TBL_FULL;
}

svlan_mbrCfgUsage[empty_idx] = TRUE;
svlan_mbrCfgVid[empty_idx] = vid;

memset(&svlan_cfg, 0, sizeof(rtl8367c_svlan_memconf_t));

svlan_cfg.vs_svid = vid;
/*for create check*/
if(vid == 0)
{
svlan_cfg.vs_efid = 1;
}

if((retVal = rtl8367c_setAsicSvlanMemberConfiguration(empty_idx, &svlan_cfg)) != RT_ERR_OK)
return retVal;

*pIndex = empty_idx;
return RT_ERR_OK;
}

The above function is used to check whether SVID VLAN MBR table is already occupied with all SVID entries. When finding new SVID entries, it checks whether the SVID exists in SVID MBR table. If it is already, just get the SVID M




NEXT




<s> ret_t rtl8367c_setAsicVlanPortBasedVID(rtk_uint32 port, rtk_uint32 index, rtk_uint32 pri)
{
rtk_uint32 regAddr, bit_mask;
ret_t  retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(index > RTL8367C_CVIDXMAX)
return RT_ERR_VLAN_ENTRY_NOT_FOUND;

if(pri > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

regAddr = RTL8367C_VLAN_PVID_CTRL_REG(port);
bit_mask = RTL8367C_PORT_VIDX_MASK(port);
retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, index);
if(retVal != RT_ERR_OK)
return retVal;

regAddr = RTL8367C_VLAN_PORTBASED_PRIORITY_REG(port);
bit_mask = RTL8367C_VLAN_PORTBASED_PRIORITY_MASK(port);
retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, pri);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the Port based TPID and VID and the Port based VID. As you can see, port 0 and port 1 have an additional function which is the Port based VID. However, there was a conflict for the Port




NEXT




<s> BIGNUM *BN_CTX_get(BN_CTX *ctx)
{
if (ctx->depth > BN_CTX_NUM_POS || ctx->tos >= BN_CTX_NUM)
{
if (!ctx->too_many)
{
/* disable error code until BN_CTX_end is called: */
ctx->too_many = 1;
}
return NULL;
}
return (&(ctx->bn[ctx->tos++]));
}

The above function is used to set a position in the stack, a depth is then given as a parameter so that the correct part of the stack can be altered.

For example, let us set up a few points in the BN_CTX stack:
/*





NEXT




<s> ret_t rtl8367c_setAsicCputagPosition(rtk_uint32 postion)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_POSITION_OFFSET, postion);
}

The above function is used to set the position of asic cputage position for tagged traffic
In the source code, the postion variable value is passed, which is 32 (set as tagged) 16 (set as untagged).





NEXT




<s> static int rb4xx_nand_remove(struct platform_device *pdev)
{
struct rb4xx_nand *nand = platform_get_drvdata(pdev);

mtd_device_unregister(nand_to_mtd(&nand->chip));
nand_cleanup(&nand->chip);

return 0;
}

The above function is used to stop the driver from accessing NAND device. The function is called during the removal of the device driver. The following command is used to remove the NAND driver.
rmmod rb4xx_nand.ko
In case the module




NEXT




<s> struct ringbuf * ringbuf_init(uint32_t num_item, uint16_t len_item)
{
static struct ringbuf r;

if (len_item <= 0)
return NULL;

r.buf = malloc(num_item * (len_item + sizeof(struct ringbuf_entry)));

if (r.buf)
{
r.len = num_item;
r.fill = 0;
r.slen = (len_item + sizeof(struct ringbuf_entry));

memset(r.buf, 0, num_item * len_item);

return &r;
}

return NULL;
}

The above function is used to initialize a ring buffer, which is a kind of circular data structure consisting of several data items. This function receives as arguments the number of items in the structure, as well as the length of each item. The r parameter refers to the address of the




NEXT




<s> BigIntegerFree(n);

t_sessionkey(ts->session_key, sbuf, slen);
memset(sbuf, 0, slen);

SHA1Update(&ts->oldhash, ts->session_key, sizeof(ts->session_key));
SHA1Update(&ts->oldckhash, ts->session_key, sizeof(ts->session_key));
SHA1Update(&ts->ckhash, ts->session_key, sizeof(ts->session_key));

return ts->session_key;
}

_TYPE( int )
t_serververify(ts, resp)
struct t_server * ts;
unsigned char * resp;
{

The above function is used to verify a session ticket. First the ticket is taken into an integer. (This is to accomodate some of the functions that expect it to be an integer.) Then the data is split into two parts: the session key and the session-t




NEXT




<s> static int rtl838x_set_link_ksettings(struct net_device *ndev,
const struct ethtool_link_ksettings *cmd)
{
struct rtl838x_eth_priv *priv = netdev_priv(ndev);

pr_debug("%s called\n", __func__);

return phylink_ethtool_ksettings_set(priv->phylink, cmd);
}

The above function is used to return the link port status (both flow control & speed) to userspace for the port associated with an NIC using phylink framework. However, we only return speed information through the ETH_SS_SPEED_CAP key.





NEXT




<s> void __init identify_rtl9302(void)
{
switch (sw_r32(RTL93XX_MODEL_NAME_INFO) & 0xfffffff0) {
case 0x93020810:
soc_info.name = "RTL9302A 12x2.5G";
break;
case 0x93021010:
soc_info.name = "RTL9302B 8x2.5G";
break;
case 0x93021810:
soc_info.name = "RTL9302C 16x2.5G";
break;
case 0x93022010:
soc_info.name = "RTL9302D 24x2.5G";
break;
case 0x93020800:
soc_info.name = "RTL9302A";
break;
case 0x93021000:
soc_info.name = "RTL9302B";
break;
case 0x93021800:
soc_info.name = "RTL9302C";
break;
case 0x93022000:
soc_info.name = "RTL9302D";
break;
case 0x93023001:
soc_info.name = "RTL9302F";
break;
default:
soc_info.name = "RTL9302";
}
}

The above function is used to identify the device.

If you compile the VTYsh with "make package" command then there seems like a problem in configuring the switch.
Switch is not configured properly in that case.
It is unable to provide the interface command




NEXT




<s> static void rtl83xx_flow_bypass_all(struct rtl83xx_flow *flow)
{
flow->rule.bypass_sel = true;
flow->rule.bypass_all = true;
flow->rule.bypass_igr_stp = true;
flow->rule.bypass_ibc_sc = true;
}

The above function is used to change the bypass mode of the flow on a flow table entry. To change the port where traffic is directed, we call the above function via the rtl83xx_set_table_entry() function.

static int rtl




NEXT




<s> ar8xxx_mib_init(struct ar8xxx_priv *priv)
{
unsigned int len;

if (!ar8xxx_has_mib_counters(priv))
return 0;

BUG_ON(!priv->chip->mib_decs || !priv->chip->num_mibs);

len = priv->dev.ports * priv->chip->num_mibs *
sizeof(*priv->mib_stats);
priv->mib_stats = kzalloc(len, GFP_KERNEL);

if (!priv->mib_stats)
return -ENOMEM;

return 0;
}

The above function is used to initialize the chip’s MIB statistics that are
available to the driver for user-space inspection. It simply allocates
enough memory to contain the entire MIB stats table.</s>




NEXT




<s> void rtl930x_vlan_port_pvidmode_set(int port, enum pbvlan_type type, enum pbvlan_mode mode)
{
if (type == PBVLAN_TYPE_INNER)
sw_w32_mask(0x3, mode, RTL930X_VLAN_PORT_PB_VLAN + (port << 2));
else
sw_w32_mask(0x3 << 14, mode << 14 ,RTL930X_VLAN_PORT_PB_VLAN + (port << 2));
}

The above function is used to set the port PVID type and mode.  But from the debug printout, it looks like the function uses two different register locations for PVID port mode depending on the PVID type.  My question is why would the port vlan mode




NEXT




<s> hostapd_bss_wps_start(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
int rc;
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);

rc = hostapd_wps_button_pushed(hapd, NULL);

if (rc != 0)
return UBUS_STATUS_NOT_SUPPORTED;

return 0;
}

The above function is used to start the WPSPush button process. The process first calls the
hostapd_wps_button_push() to push the WPS button of device, then it returns 0 when WPS process is done
. For more explanation




NEXT




<s> rtk_api_ret_t rtk_led_OutputEnable_get(rtk_enable_t *pState)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(pState == NULL)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLedOutputEnable(pState))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;

}

The above function is used to read the LED output pin enable set via the command line interface (telnet). It takes a argument of rtk_enable_t*. The function will try to read it from the ASIC and return the result to the caller. Below is




NEXT




<s> static void ptm_setup(struct net_device *, int);
static struct net_device_stats *ptm_get_stats(struct net_device *);
static int ptm_open(struct net_device *);
static int ptm_stop(struct net_device *);
static unsigned int ptm_poll(int, unsigned int);
static int ptm_napi_poll(struct napi_struct *, int);
static int ptm_hard_start_xmit(struct sk_buff *, struct net_device *);
static int ptm_ioctl(struct net_device *, struct ifreq *, int);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
static void ptm_tx_timeout(struct net_device *);
#else
static void ptm_tx_timeout(struct net_device *, unsigned int txqueue);
#endif

static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to initialize the Wanqos flag.
The flag will be used to indicate whether Wanqos is enabled in PTM or not

Purpose for this function is to initialize the gamma index

*/
static int setup




NEXT




<s> static void rtl83xx_port_mirror_del(struct dsa_switch *ds, int port,
struct dsa_mall_mirror_tc_entry *mirror)
{
int group = 0;
struct rtl838x_switch_priv *priv = ds->priv;
int ctrl_reg, dpm_reg, spm_reg;

pr_debug("In %s\n", __func__);
for (group = 0; group < 4; group++) {
if (priv->mirror_group_ports[group] == mirror->to_local_port)
break;
}
if (group >= 4)
return;

ctrl_reg = priv->r->mir_ctrl + group * 4;
dpm_reg = priv->r->mir_dpm + group * 4 * priv->port_width;
spm_reg = priv->r->mir_spm + group * 4 * priv->port_width;

mutex_lock(&priv->reg_mutex);
if (mirror->ingress) {
/* Ingress, clear source port matrix */
priv->r->mask_port_reg_be(1ULL << port, 0, spm_reg);
} else {
/* Egress, clear destination port matrix */
priv->r->mask_port_reg_be(1ULL << port, 0, dpm_reg);
}

if (!(sw_r32(spm_reg) || sw_r32(dpm_reg))) {
priv->mirror_group_ports[group] = -1;
sw_w32(0, ctrl_reg);
}

mutex_unlock(&priv->reg_mutex);
}

The above function is used to de-mirror the ports in the mirror-group by taking the port number of the port to be de-mirroed as its parameter. The process to de-mirror the port involves two major activities
1. Getting the mirror_




NEXT




<s> void end_dialog(int x, int y)
{
/* move cursor back to original position */
move(y, x);
refresh();
endwin();
}

The above function is used to return control back to the main dialog loop. The endwin function ends a ncurses based dialog. This is all well and good, if you are familiar with ncurses. But if you are writing an application which runs on a wide variety




NEXT




<s> static int check_sector(off_t pos)
{
if (!read_oob_sector_health) {
return 1;
}
if (read_sectoroob(pos)) {
return 0;
}
if (read_uint8(oobbuf, 0x00) != 0xff) {
/* block is bad */
return 0;
}
if (read_uint8(oobbuf, 0x01) != 0xff) {
/* sector is bad */
return 0;
}
return 1;
}

The above function is used to check if a sector is bad or not.

As I saw in the debug build of the kernel, oobbuf is defined as:
/* data buffer for read_oob. */
static uint8_t oobbuf[




NEXT




<s> static inline void rttm_disable_irq(void __iomem *base)
{
iowrite32(0, base + RTTM_INT);
}

The above function is used to disable the internal clock of peripheral interrupts by software. When the system is starting up, the RPMsg clock is disabled, and then it is enabled in user space. The interrupt is also disabled by software. Therefore, external events are not




NEXT




<s> static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to allocate a buffer to collect the entire source
file.  We read the file twice with the first read using yy_switch_to_buffer,
with yyppush_buffer pointing to the first position in the buffer, and the
second




NEXT




<s> ret_t rtl8367c_setAsicPriorityPortBased(rtk_uint32 port, rtk_uint32 priority )
{
ret_t retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(priority > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

if(port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_QOS_PORTBASED_PRIORITY_REG(port), RTL8367C_QOS_PORTBASED_PRIORITY_MASK(port), priority);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_QOS_PORTBASED_PRIORITY_CTRL2, 0x7 << ((port - 8) << 2), priority);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set the ingress priority in Port Priority Based Queue.

RetVal will be set to RT_ERR_OK if it is successful. Any other value will mark failed.

The second parameter, port, indicates which member port




NEXT




<s> static int oxnas_pcie_phy_power_on(struct phy *phy)
{
struct oxnas_pcie_phy *pciephy = phy_get_drvdata(phy);

/* Enable PCIe Pre-Emphasis: What these value means? */
writel(ADDR_VAL(0x0014), pciephy->membase + PHY_ADDR);
writel(DATA_VAL(0xce10) | CAP_DATA, pciephy->membase + PHY_DATA);
writel(DATA_VAL(0xce10) | WRITE_EN, pciephy->membase + PHY_DATA);

writel(ADDR_VAL(0x2004), pciephy->membase + PHY_ADDR);
writel(DATA_VAL(0x82c7) | CAP_DATA, pciephy->membase + PHY_DATA);
writel(DATA_VAL(0x82c7) | WRITE_EN, pciephy->membase + PHY_DATA);

return 0;
}

The above function is used to initialize the Pre-Emphasis, and there exists a couple of similar functions to do similar initialization.

In this article series, I am going to discuss what the “Pre-Emphasis” is and how it can be applied in




NEXT




<s> static bool nmbm_load_existing(struct nmbm_instance *ni)
{
bool success;

/* Calculate the boundary of management blocks */
ni->mgmt_start_ba = ni->signature.mgmt_start_pb;

nlog_debug(ni, "NMBM management region starts at block %u [0x%08llx]\n",
ni->mgmt_start_ba, ba2addr(ni, ni->mgmt_start_ba));

/* Look for info table(s) */
success = nmbm_load_info_table(ni, ni->mgmt_start_ba,
ni->signature_ba);
if (success) {
nlog_info(ni, "NMBM has been successfully attached\n");
return true;
}

if (!ni->force_create) {
printk("not creating NMBM table\n");
return false;
}

/* Fill block state table & mapping table */
nmbm_scan_badblocks(ni);
nmbm_build_mapping_table(ni);

/* Write info table(s) */
success = nmbm_create_info_table(ni);
if (success) {
nlog_info(ni, "NMBM has been successfully created\n");
return true;
}

return false;
}

The above function is used to create/access NMBM.

# 374609160d93da
42</s>




NEXT




<s> struct expr *expr_copy(const struct expr *org)
{
struct expr *e;

if (!org)
return NULL;

e = xmalloc(sizeof(*org));
memcpy(e, org, sizeof(*org));
switch (org->type) {
case E_SYMBOL:
e->left = org->left;
break;
case E_NOT:
e->left.expr = expr_copy(org->left.expr);
break;
case E_EQUAL:
case E_GEQ:
case E_GTH:
case E_LEQ:
case E_LTH:
case E_UNEQUAL:
e->left.sym = org->left.sym;
e->right.sym = org->right.sym;
break;
case E_AND:
case E_OR:
case E_LIST:
e->left.expr = expr_copy(org->left.expr);
e->right.expr = expr_copy(org->right.expr);
break;
default:
fprintf(stderr, "can't copy type %d\n", e->type);
free(e);
e = NULL;
break;
}

return e;
}

The above function is used to implement multiple copies of expression,
while one is in fact enough to satisfy it's purpose.

struct expr *expr_copy()</s>




NEXT




<s> void rtl930x_vlan_port_pvid_set(int port, enum pbvlan_type type, int pvid)
{
if (type == PBVLAN_TYPE_INNER)
sw_w32_mask(0xfff << 2, pvid << 2, RTL930X_VLAN_PORT_PB_VLAN + (port << 2));
else
sw_w32_mask(0xfff << 16, pvid << 16, RTL930X_VLAN_PORT_PB_VLAN + (port << 2));
}

The above function is used to set the pvid of the port of the specified type. However, the code is wrong. For example, if we call the above function with port 0, type PBVLAN_TYPE_INNER and pvid 100




NEXT




<s> int rtl8231_init(struct rtl8231_gpios *gpios)
{
u32 ret;

pr_info("%s called, MDIO bus ID: %d\n", __func__, gpios->smi_bus_id);

gpios->reg_cached = 0;

if (soc_info.family == RTL8390_FAMILY_ID) {
/* RTL8390: Enable external gpio in global led control register */
sw_w32_mask(0x7 << 18, 0x4 << 18, RTL839X_LED_GLB_CTRL);
} else if (soc_info.family == RTL8380_FAMILY_ID) {
/* RTL8380: Enable RTL8231 indirect access mode */
sw_w32_mask(0, 1, RTL838X_EXTRA_GPIO_CTRL);
sw_w32_mask(3, 1, RTL838X_DMY_REG5);
}

ret = rtl8231_read(gpios, RTL8231_LED_FUNC1);
if ((ret & 0x80000000) || ((ret & RTL8231_READY_MASK) != RTL8231_READY_VALUE))
return -ENXIO;

/* Select GPIO functionality and force input direction for pins 0-36 */
rtl8231_write(gpios, RTL8231_GPIO_PIN_SEL(0), 0xffff);
rtl8231_write(gpios, RTL8231_GPIO_DIR(0), 0xffff);
rtl8231_write(gpios, RTL8231_GPIO_PIN_SEL(16), 0xffff);
rtl8231_write(gpios, RTL8231_GPIO_DIR(16), 0xffff);
rtl8231_write(gpios, RTL8231_GPIO_PIN_SEL(32), 0x03ff);

/* Set LED_Start to enable drivers for output mode */
rtl8231_write(gpios, RTL8231_LED_FUNC0, 1 << 1);

return 0;
}

The above function is used to initialize the R8231 gpios and read RTL8231_READY_MASK from the LED_FUNC1 register in R8231 chip.
This function is used in the kernel module for the initialization




NEXT




<s> static void __init ws_ap3710i_setup_arch(void)
{
if (ppc_md.progress)
ppc_md.progress("ws_ap3710i_setup_arch()", 0);

mpc85xx_smp_init();

fsl_pci_assign_primary();

pr_info("WS-AP3710i board from Enterasys\n");
}

The above function is used to call a function within enterasys switch.

The problem I'm facing is that the kernel is unable to call such a functions.

1. if I add some dummy function to perform in place of that, then kernel boots up




NEXT




<s> static int mt7621_nfc_dev_ready(struct mt7621_nfc *nfc,
unsigned int timeout_ms)
{
u32 val;

return readl_poll_timeout_atomic(nfc->nfi_regs + NFI_STA, val,
!(val & STA_BUSY), 10,
timeout_ms * 1000);
}

The above function is used to make sure the nfc is actually ready. Now with the above function we can be sure that the nfc is ready and then we can send an RF interface command to the nfc

To send a RF interface command to the NFC,




NEXT




<s> static void nmbm_scan_badblocks(struct nmbm_instance *ni)
{
uint32_t ba;

for (ba = 0; ba < ni->block_count; ba++) {
if (nmbm_check_bad_phys_block(ni, ba)) {
nmbm_set_block_state(ni, ba, BLOCK_ST_BAD);
nlog_info(ni, "Bad block %u [0x%08llx]\n", ba,
ba2addr(ni, ba));
}
}
}

The above function is used to mark the bad-blocks in a NAND memory and can be used by both the erase/write-back and in-place file system layer.

For the erase/write-back layer, which writes data in new pages at




NEXT




<s> fchmod(fileno(bakfp), st.st_mode & 0777);
#endif

t_pwcopy(bakfp, passfp, diff);

fclose(bakfp);
fclose(passfp);

#ifdef USE_RENAME
unlink(bakfile);
if(rename(pwname, bakfile) < 0) {
free(bakfile);
free(bakfile2);
return -1;
}

The above function is used to determine if the name of
the encrypted file (pwname) is different from the last time
it was encrypted. If it is different, it re-encrypts it.

Note that re-encryption (unless




NEXT




<s> get_mapping_block_index_bbt(int block)
{
int start, end, ofs;
int bad_blocks = 0;
int i;

if (!mapping_block_in_range(block, &start, &end))
return block;

start >>= bmtd.blk_shift;
end >>= bmtd.blk_shift;
/* skip bad blocks within the mapping range */
ofs = block - start;
for (i = start; i < end; i++) {
if (bbt_block_is_bad(i))
bad_blocks++;
else if (ofs)
ofs--;
else
break;
}

if (i < end)
return i;

/* when overflowing, remap remaining blocks to bad ones */
for (i = end - 1; bad_blocks > 0; i--) {
if (!bbt_block_is_bad(i))
continue;

bad_blocks--;
if (bad_blocks <= ofs)
return i;
}

return block;
}

The above function is used to check that a specific bbt block has a good offset and hence it is correct to do a lookup and retrieve value from this block. If the block has a bad offset, it is considered a bad block and this is usually a signal that something has




NEXT




<s> static inline void superio_exit(int base)
{
outb(SIO_LOCK_KEY, base);
release_region(base, 2);
}

The above function is used to disable the superio.
The first line sends a reserved value to the port 0xe1b in which the key is located to lock the register. The function then enters into critical section and performs the release of reserved region after removing critical section




NEXT




<s> void ifx_deu_des_ctr (void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
ifx_deu_des (ctx, dst, src, iv, nbytes, encdec, 4);
}

The above function is used to decrypt (and encrypt) DES blocks using
DES. It differs from the below function with two differences. The buffer
used for the intermediate DES result is different (4 bytes versus 8
bytes), which means encrypting




NEXT




<s> void spl_display_print(void)
{
/* print a hint, so that we will not use the wrong SPL by mistake */
puts("  Boot device: " BOOT_DEVICE_TYPE "\n" );
}

The above function is used to report information about boot device type. A user may know the default boot device by the hint. So, at times, users may not use the default boot device, but use the wrong one. When an user use the wrong one, he does not




NEXT




<s> static int rtl8366_smi_read_byte0(struct rtl8366_smi *smi, u8 *data)
{
u32 t;

/* read data */
rtl8366_smi_read_bits(smi, 8, &t);
*data = (t & 0xff);

/* send an ACK */
rtl8366_smi_write_bits(smi, 0x00, 1);

return 0;
}

The above function is used to read one byte via SMI, but it is a SMI with special
function, if we just want to read one byte from a register address, the way is so
simple, just read the whole memory address

static int rtl




NEXT




<s> static int rtl839x_mdio_write(struct mii_bus *bus, int mii_id,
int regnum, u16 value)
{
return rtl839x_mdio_write_paged(bus, mii_id, 0, regnum, value);
}

The above function is used to write registers of the MDIO hardware for some unknown (at least to me) purpose. What I’ve found out until now is MDIO functionality needs to be enabled (during init) and also if this option is set, the phy




NEXT




<s> static int airoha_dir_in(struct gpio_chip *gc, unsigned int gpio)
{
return airoha_dir_set(gc, gpio, 0, 0);
}

The above function is used to set a GPIO as input. It is called from
gpiochip_direction.c and used in set_direction as follows.
static int set_direction(struct gpio_chip *gc, unsigned offset, u32 dir)





NEXT




<s> ret_t rtl8367c_setAsicFlowControlPortPrivateDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_ON_MASK, onThreshold);

return retVal;
}

The above function is used to set the maximum frames per second dropping threshold when software flow controls. In some cases, software flow control may drop frames depending on incoming frame rate, so in order to prevent frames loss or packet reordering, there is a mechanism called Flow control private




NEXT




<s> const char *get_line(const char *text, int line_no)
{
int i;
int lines = 0;

if (!text)
return NULL;

for (i = 0; text[i] != '\0' && lines < line_no; i++)
if (text[i] == '\n')
lines++;
return text+i;
}

The above function is used to extract the particular string out of the entire string, which can be a very handy when parsing a big file, using get_line you can just parse the lines you need and nothing more!

So if your source string is:






NEXT




<s> static int b53_mdio_write64(struct b53_device *dev, u8 page, u8 reg,
u64 value)
{
struct mii_bus *bus = dev->priv;
unsigned i;
u64 temp = value;

for (i = 0; i < 4; i++) {
int ret = mdiobus_write(bus, B53_PSEUDO_PHY, REG_MII_DATA0 + i,
temp & 0xffff);
if (ret)
return ret;
temp >>= 16;
}

return b53_mdio_op(dev, page, reg, REG_MII_ADDR_WRITE);
}

The above function is used to write a 64 bit value to the PHY.
However, a check in b53_mdio_write64 determines that the size of mdiobus_write only supports a maximum of 32 bit writes (




NEXT




<s> rtl_phy_restore(struct switch_dev *dev, int port, struct rtl_phyregs *regs)
{
rtl_set(dev, RTL_PORT_REG(port, NWAY), regs->nway);
rtl_set(dev, RTL_PORT_REG(port, SPEED), regs->speed);
rtl_set(dev, RTL_PORT_REG(port, DUPLEX), regs->duplex);
}

The above function is used to restore the rtl phy
registers after a phy link down event. The device type
code used here is switch_dev. But in reality, the rtl
phy module is used for port operation or 802.




NEXT




<s> static inline int msp430_check_workmode(struct spi_device *spi)
{
struct device *dev = &spi->dev;
u8 tx[MSP430_CMD_BYTES] = {MSP430_CMD_MCU, MSP430_MCU_WM, 0, 0, 0, 0};
u8 rx[MSP430_CMD_BYTES];
int rc;

rc = msp430_cmd(spi, tx, rx);
if (rc)
return rc;

if ((rx[3] == 0xA5 && rx[4] == 'Z') ||
(rx[4] == 0xA5 && rx[5] == 'Z') ||
(rx[4] == '\b' && rx[5] == '\n')) {
dev_err(dev, "invalid workmode: "
"[%02x %02x %02x %02x %02x %02x]\n",
rx[0], rx[1], rx[2], rx[3], rx[4], rx[5]);
return -EINVAL;
}

return 0;
}

The above function is used to check the work mode of MSP430 microcontrollers,
and there might  be problem in some of the SPI interface of MSP430 chips, for example I have
one of the the SPI interface of one of my




NEXT




<s> static void rtl839x_pie_rule_rm(struct rtl838x_switch_priv *priv, struct pie_rule *pr)
{
int idx = pr->id;

rtl839x_pie_rule_del(priv, idx, idx);
clear_bit(idx, priv->pie_use_bm);
}

The above function is used to unregister a 802.1p queue and associated PIE rules from the TC equeue system, then free the associated PIE rule.

A few points:

The 802.1p/8




NEXT




<s> rtk_api_ret_t rtk_port_phyForceModeAbility_get(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
{
rtk_api_ret_t       retVal;
rtk_uint32          phyData0;
rtk_uint32          phyData4;
rtk_uint32          phyData9;
rtk_port_media_t    media_type;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

if(NULL == pAbility)
return RT_ERR_NULL_POINTER;

if (rtk_switch_isComboPort(port) == RT_ERR_OK)
{
if ((retVal = rtk_port_phyComboPortMedia_get(port, &media_type)) != RT_ERR_OK)
return retVal;

if(media_type == PORT_MEDIA_FIBER)
{
return _rtk_port_FiberModeAbility_get(port, pAbility);
}
}

/*Control register setting and restart auto*/
if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, &phyData0)) != RT_ERR_OK)
return retVal;

/*Auto-Negotiation control register setting*/
if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_AN_ADVERTISEMENT_REG, &phyData4)) != RT_ERR_OK)
return retVal;

/*1000 BASE-T control register setting*/
if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_1000_BASET_CONTROL_REG, &phyData9)) != RT_ERR_OK)
return retVal;

if (phyData9 & (1 << 9))
pAbility->Full_1000 = 1;
else
pAbility->Full_1000 = 0;

if (phyData4 & (1 << 11))
pAbility->AsyFC = 1;
else
pAbility->AsyFC = 0;

if (phyData4 & ((1 << 10)))
pAbility->FC = 1;
else
pAbility->FC = 0;


if (phyData4 & (1 << 8))
pAbility->Full_100 = 1;
else
pAbility->Full_100 = 0;

if (phyData4 & (1 << 7))
pAbility->Half_100 = 1;
else
pAbility->Half_100 = 0;

if (phyData4 & (1 << 6))
pAbility->Full_10 = 1;
else
pAbility->Full_10 = 0;

if (phyData4 & (1 << 5))
pAbility->Half_10 = 1;
else
pAbility->Half_10 = 0;


if (phyData0 & (1 << 12))
pAbility->AutoNegotiation = 1;
else
pAbility->AutoNegotiation = 0;

return RT_ERR_OK;
}

The above function is used to query the ability of a port’s PHY.

#if 0

/* Control Register setting and restart auto */

/* Auto-Negotiation control register setting */

/* 1000BASE-T




NEXT




<s> ret_t rtl8367c_setAsicLedGroupEnable(rtk_uint32 group, rtk_uint32 portmask)
{
ret_t retVal;
rtk_uint32 regAddr;
rtk_uint32 regDataMask;

if ( group >= RTL8367C_LEDGROUPNO )
return RT_ERR_INPUT;

regAddr = RTL8367C_REG_PARA_LED_IO_EN1 + group/2;
regDataMask = 0xFF << ((group%2)*8);
retVal = rtl8367c_setAsicRegBits(regAddr, regDataMask, portmask&0xff);
if(retVal != RT_ERR_OK)
return retVal;

regAddr = RTL8367C_REG_PARA_LED_IO_EN3;
regDataMask = 0x3 << (group*2);
retVal = rtl8367c_setAsicRegBits(regAddr, regDataMask, (portmask>>8)&0x7);
if(retVal != RT_ERR_OK)
return retVal;


return RT_ERR_OK;
}

The above function is used to enable/disable led group(group no.0~7).
Each led group consists of 8 leds.
Leds which have the same function in each group will be driven at the same time.

Note: The function of




NEXT




<s> ret_t rtl8367c_setAsicI2CSoftRSTseqCmd(void)
{

rtk_uint32 regData;
ret_t retVal;

/*Bits [4-1] = 0b0110, tx soft reset Command;  Bit [0] = 1, Trigger the Command */
if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
return retVal;
regData &= 0xFFE0;
regData |= 0x000d;

if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
return retVal;


/* wait for command finished */
do{
if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
return retVal;
}while( regData != 0x0);

return RT_ERR_OK ;
}

The above function is used to set the Soft Reset for I2C subsystem.
Please refer to the source code file: asic.c

Notes:

This function is not available for 8365C, 8366B




NEXT




<s> ret_t rtl8367c_getAsicIGMPv1Opeartion(rtk_uint32 port, rtk_uint32 *igmpv1_op)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

/* IGMPv1 operation */
if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV1_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV1_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}

*igmpv1_op = value;

return RT_ERR_OK;
}

The above function is used to read the IGMPv1 operation bit in RTL8367C ASIC. For 2-port or 4-port module, the bit could be found in sub-register RTL8367C_REG




NEXT




<s> static int mt798x_2p5ge_phy_config_init(struct phy_device *phydev)
{
int ret;
int i;
const struct firmware *fw;
struct device *dev = &phydev->mdio.dev;
struct device_node *np;
void __iomem *dmb_addr;
void __iomem *pmb_addr;
void __iomem *mcucsr_base;
u16 reg;
struct pinctrl *pinctrl;

np = of_find_compatible_node(NULL, NULL, "mediatek,2p5gphy-fw");
if (!np)
return -ENOENT;

dmb_addr = of_iomap(np, 0);
if (!dmb_addr)
return -ENOMEM;
pmb_addr = of_iomap(np, 1);
if (!pmb_addr)
return -ENOMEM;
mcucsr_base = of_iomap(np, 2);
if (!mcucsr_base)
return -ENOMEM;

ret = request_firmware(&fw, MEDAITEK_2P5GE_PHY_DMB_FW, dev);
if (ret) {
dev_err(dev, "failed to load firmware: %s, ret: %d\n",
MEDAITEK_2P5GE_PHY_DMB_FW, ret);
return ret;
}
for (i = 0; i < fw->size - 1; i += 4)
writel(*((uint32_t *)(fw->data + i)), dmb_addr + i);
release_firmware(fw);

ret = request_firmware(&fw, MEDIATEK_2P5GE_PHY_PMB_FW, dev);
if (ret) {
dev_err(dev, "failed to load firmware: %s, ret: %d\n",
MEDIATEK_2P5GE_PHY_PMB_FW, ret);
return ret;
}
for (i = 0; i < fw->size - 1; i += 4)
writel(*((uint32_t *)(fw->data + i)), pmb_addr + i);
release_firmware(fw);

reg = readw(mcucsr_base + MD32_EN_CFG);
writew(reg | MD32_EN, mcucsr_base + MD32_EN_CFG);
dev_dbg(dev, "Firmware loading/trigger ok.\n");

/* Setup LED */
phy_clear_bits_mmd(phydev, MDIO_MMD_VEND2, MTK_PHY_LED0_ON_CTRL,
MTK_PHY_LED0_POLARITY);

phy_set_bits_mmd(phydev, MDIO_MMD_VEND2, MTK_PHY_LED0_ON_CTRL,
MTK_PHY_LED0_ON_LINK10 |
MTK_PHY_LED0_ON_LINK100 |
MTK_PHY_LED0_ON_LINK1000 |
MTK_PHY_LED0_ON_LINK2500);

phy_set_bits_mmd(phydev, MDIO_MMD_VEND2, MTK_PHY_LED1_ON_CTRL,
MTK_PHY_LED1_ON_FDX | MTK_PHY_LED1_ON_HDX);

pinctrl = devm_pinctrl_get_select(&phydev->mdio.dev, "i2p5gbe-led");
if (IS_ERR(pinctrl)) {
dev_err(&phydev->mdio.dev, "Fail to set LED pins!\n");
return PTR_ERR(pinctrl);
}

return 0;
}

The above function is used to initialize 2P5GE phy configuration, which is similar with MT7603 phy configuration.

MT7603 phy register mappings are as follows.

MT7603 Phy register m




NEXT




<s> static int bcm6348_do_cfg_read(int type, unsigned int busn,
unsigned int devfn, int where, int size,
u32 *val)
{
struct bcm6348_pci *priv = &bcm6348_pci;
u32 data;

/* two phase cycle, first we write address, then read data at
* another location, caller already has a spinlock so no need
* to add one here */
if (bcm6348_setup_cfg_access(type, busn, devfn, where))
return PCIBIOS_DEVICE_NOT_FOUND;
iob();
data = le32_to_cpu(__raw_readl(priv->io));
/* restore IO space normal behaviour */
__raw_writel(0, priv->pci + MPI_L2PCFG_REG);

*val = postprocess_read(data, where, size);

return PCIBIOS_SUCCESSFUL;
}

The above function is used to read a location from PC’s PCI bus. The function reads a location from PC’s PCI bus and stores it in some variable, but the problematic line (where I get my segmentation fault) is here: `*val = post




NEXT




<s> int nvram_close(nvram_handle_t *h)
{
_nvram_free(h);
munmap(h->mmap, h->length);
close(h->fd);
free(h);

return 0;
}

The above function is used to close the nvram file handle. It is called in the following cases: when the nvram_commit or nvram_set function is called; before nvram_open is called; when nvram_close is called.

When nv




NEXT




<s> ret_t rtl8367c_setAsicIGMPStaticRouterPort(rtk_uint32 pmsk)
{
if(pmsk > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

return rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_STATIC_ROUTER_PORT, RTL8367C_IGMP_STATIC_ROUTER_PORT_MASK, pmsk);
}

The above function is used to configure the IGMP static router port.

In this demo, the IGMP static router port is port 7.

So, the source code is:

  rtl8367c_setAsic




NEXT




<s> static void _rtl8367c_aclRuleStUser2Smi(rtl8367c_aclrule *pAclUser, rtl8367c_aclrulesmi *pAclSmi)
{
rtk_uint8 *care_ptr, *data_ptr;
rtk_uint8 care_tmp, data_tmp;
rtk_uint32 i;

pAclSmi->data_bits_ext.rule_info = ((pAclUser->data_bits.active_portmsk >> 8) & 0x7) << 1;
pAclSmi->data_bits.rule_info = ((pAclUser->data_bits.active_portmsk & 0xff) << 8) | ((pAclUser->data_bits.tag_exist & 0x1F) << 3) | (pAclUser->data_bits.type & 0x07);

for(i = 0;i < RTL8367C_ACLRULEFIELDNO; i++)
pAclSmi->data_bits.field[i] = pAclUser->data_bits.field[i];

pAclSmi->valid = pAclUser->valid;

pAclSmi->care_bits_ext.rule_info = ((pAclUser->care_bits.active_portmsk >> 8) & 0x7) << 1;
pAclSmi->care_bits.rule_info = ((pAclUser->care_bits.active_portmsk & 0xff) << 8) | ((pAclUser->care_bits.tag_exist & 0x1F) << 3) | (pAclUser->care_bits.type & 0x07);

for(i = 0; i < RTL8367C_ACLRULEFIELDNO; i++)
pAclSmi->care_bits.field[i] = pAclUser->care_bits.field[i];

care_ptr = (rtk_uint8*)&pAclSmi->care_bits;
data_ptr = (rtk_uint8*)&pAclSmi->data_bits;

for ( i = 0; i < sizeof(struct acl_rule_smi_st); i++)
{
care_tmp = *(care_ptr + i) & ~(*(data_ptr + i));
data_tmp = *(care_ptr + i) & *(data_ptr + i);

*(care_ptr + i) = care_tmp;
*(data_ptr + i) = data_tmp;
}

care_ptr = (rtk_uint8*)&pAclSmi->care_bits_ext;
data_ptr = (rtk_uint8*)&pAclSmi->data_bits_ext;
care_tmp = *care_ptr & ~(*data_ptr);
data_tmp = *care_ptr & *data_ptr;

*care_ptr = care_tmp;
*data_ptr = data_tmp;
}

The above function is used to copy acl rule user to acl smi. This code is the source file which is used to copy all the fields to the acl rule smi except for the smi field.
rtk_uint16 port_no =




NEXT




<s> ret_t rtl8367c_setAsic1xTrapPriority(rtk_uint32 priority)
{
if(priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_DOT1X_PRIORTY_MASK,priority);
}

The above function is used to set the dot1x trap priority in HW. Here is what the manual says,
“The Dot1x trap priority register defines the priority of the port-based Dot1x trap action and controls the priority level of ACL




NEXT




<s> static ssize_t phyreg_ops(struct file *file,
const char __user *buffer, size_t count,
loff_t *data)
{
char buf[64];
unsigned int port;
unsigned int offset;
unsigned int val;

memset(buf, 0, 64);

if (copy_from_user(buf, buffer, count))
return -EFAULT;


if(buf[0] == 'w') {

if(sscanf(buf, "w %d %x %x", &port,&offset,&val) == -1)
return -EFAULT;
else
rtk_hal_set_phy_reg(port,offset,val);

} else {

if(sscanf(buf, "r %d %x",&port, &offset) == -1)
return -EFAULT;
else
rtk_hal_get_phy_reg(port,offset);
}

return count;
}

The above function is used to implement rtk_phyreg_write and rtk_phyreg_read respectively.</s>




NEXT




<s> static int rtl8366rb_write_phy_reg(struct rtl8366_smi *smi,
u32 phy_no, u32 page, u32 addr, u32 data)
{
u32 reg;
int ret;

if (phy_no > RTL8366RB_PHY_NO_MAX)
return -EINVAL;

if (page > RTL8366RB_PHY_PAGE_MAX)
return -EINVAL;

if (addr > RTL8366RB_PHY_ADDR_MAX)
return -EINVAL;

ret = rtl8366_smi_write_reg(smi, RTL8366RB_PHY_ACCESS_CTRL_REG,
RTL8366RB_PHY_CTRL_WRITE);
if (ret)
return ret;

reg = 0x8000 | (1 << (phy_no + RTL8366RB_PHY_NO_OFFSET)) |
((page << RTL8366RB_PHY_PAGE_OFFSET) & RTL8366RB_PHY_PAGE_MASK) |
(addr & RTL8366RB_PHY_REG_MASK);

ret = rtl8366_smi_write_reg(smi, reg, data);
if (ret)
return ret;

return 0;
}

The above function is used to write a single address of PHY register.</s>




NEXT




<s> ret_t rtl8367c_getAsicUnknownMulticastTrapPriority(rtk_uint32 *pPriority)
{
return rtl8367c_getAsicRegBits(RTL8367C_QOS_TRAP_PRIORITY_CTRL0_REG, RTL8367C_UNKNOWN_MC_PRIORTY_MASK, pPriority);
}

The above function is used to retrieve the priority value of unknown multicast frame for ASIC.

rtk_uint16 u16MCType;
ret_t RetVal=rtl8367c_getAsicUnknownMulticast




NEXT




<s> ret_t rtl8367c_getAsicTrunkingGroup(rtk_uint32 group, rtk_uint32* pPortmask)
{
if(group > RTL8367C_MAX_TRUNK_GID)
return RT_ERR_LA_TRUNK_ID;

return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_GROUP_MASK, RTL8367C_PORT_TRUNK_GROUP0_MASK_MASK << (group * 4), pPortmask);
}

The above function is used to read the trunking group masks for a particular group.

//
//

This example shows the usage of rtl8367c_getAsicTrunkingGroup().

/*
//

int main(__




NEXT




<s> ar8xxx_is_possible(struct mii_bus *bus)
{
unsigned int i, found_phys = 0;

for (i = 0; i < 5; i++) {
u32 phy_id;

phy_id = mdiobus_read(bus, i, MII_PHYSID1) << 16;
phy_id |= mdiobus_read(bus, i, MII_PHYSID2);
if (ar8xxx_phy_match(phy_id)) {
found_phys++;
} else if (phy_id) {
pr_debug("ar8xxx: unknown PHY at %s:%02x id:%08x\n",
dev_name(&bus->dev), i, phy_id);
}
}
return !!found_phys;
}

The above function is used to check if we have Ar8302 as PHY in the network card.</s>




NEXT




<s> static int rtl8367_setup(struct rtl8366_smi *smi)
{
struct rtl8367_platform_data *pdata;
int err;
int i;

pdata = smi->parent->platform_data;

err = rtl8367_init_regs(smi);
if (err)
return err;

/* initialize external interfaces */
if (smi->parent->of_node) {
err = rtl8367_extif_init_of(smi, 0, "realtek,extif0");
if (err)
return err;

err = rtl8367_extif_init_of(smi, 1, "realtek,extif1");
if (err)
return err;
} else {
err = rtl8367_extif_init(smi, 0, pdata->extif0_cfg);
if (err)
return err;

err = rtl8367_extif_init(smi, 1, pdata->extif1_cfg);
if (err)
return err;
}

/* set maximum packet length to 1536 bytes */
REG_RMW(smi, RTL8367_SWC0_REG, RTL8367_SWC0_MAX_LENGTH_MASK,
RTL8367_SWC0_MAX_LENGTH_1536);

/*
* discard VLAN tagged packets if the port is not a member of
* the VLAN with which the packets is associated.
*/
REG_WR(smi, RTL8367_VLAN_INGRESS_REG, RTL8367_PORTS_ALL);

/*
* Setup egress tag mode for each port.
*/
for (i = 0; i < RTL8367_NUM_PORTS; i++)
REG_RMW(smi,
RTL8367_PORT_CFG_REG(i),
RTL8367_PORT_CFG_EGRESS_MODE_MASK <<
RTL8367_PORT_CFG_EGRESS_MODE_SHIFT,
RTL8367_PORT_CFG_EGRESS_MODE_ORIGINAL <<
RTL8367_PORT_CFG_EGRESS_MODE_SHIFT);

/* setup LEDs */
err = rtl8367_led_group_set_ports(smi, 0, RTL8367_PORTS_ALL);
if (err)
return err;

err = rtl8367_led_group_set_mode(smi, 0);
if (err)
return err;

err = rtl8367_led_op_select_parallel(smi);
if (err)
return err;

err = rtl8367_led_blinkrate_set(smi, 1);
if (err)
return err;

err = rtl8367_led_group_set_config(smi, 0, 2);
if (err)
return err;

return 0;
}

The above function is used to initialise the rtl8367 switch chip by setting
up various registers and configuring external interfaces like GPHYs and
GMII.</s>




NEXT




<s> static void search_conf(void)
{
struct symbol **sym_arr;
struct gstr res;
struct gstr title;
char *dialog_input;
int dres, vscroll = 0, hscroll = 0;
bool again;
struct gstr sttext;
struct subtitle_part stpart;

title = str_new();
str_printf( &title, "Enter (sub)string or regexp to search for "
"(with or without \"%s\")", CONFIG_);

again:
dialog_clear();
dres = dialog_inputbox("Search Configuration Parameter",
str_get(&title),
10, 75, "");
switch (dres) {
case 0:
break;
case 1:
show_helptext("Search Configuration", search_help);
goto again;
default:
str_free(&title);
return;
}

/* strip the prefix if necessary */
dialog_input = dialog_input_result;
if (strncasecmp(dialog_input_result, CONFIG_, strlen(CONFIG_)) == 0)
dialog_input += strlen(CONFIG_);

sttext = str_new();
str_printf(&sttext, "Search (%s)", dialog_input_result);
stpart.text = str_get(&sttext);
list_add_tail(&stpart.entries, &trail);

sym_arr = sym_re_search(dialog_input);
do {
LIST_HEAD(head);
struct menu *targets[JUMP_NB];
int keys[JUMP_NB + 1], i;
struct search_data data = {
.head = &head,
.targets = targets,
.keys = keys,
};
struct jump_key *pos, *tmp;

res = get_relations_str(sym_arr, &head);
set_subtitle();
dres = show_textbox_ext("Search Results", (char *)
str_get(&res), 0, 0, keys, &vscroll,
&hscroll, &update_text, (void *)
&data);
again = false;
for (i = 0; i < JUMP_NB && keys[i]; i++)
if (dres == keys[i]) {
conf(targets[i]->parent, targets[i]);
again = true;
}
str_free(&res);
list_for_each_entry_safe(pos, tmp, &head, entries)
free(pos);
} while (again);
free(sym_arr);
str_free(&title);
list_del(trail.prev);
str_free(&sttext);
}

The above function is used to check whether the entered string is
valid or not. Here, it checks whether the entered string has all
valid characters or not. This function returns 0 if the string is
valid. Otherwise, it returns 1. It is called in




NEXT




<s> u64 rtl839x_traffic_get(int source)
{
return rtl839x_get_port_reg_be(rtl839x_port_iso_ctrl(source));
}

The above function is used to get the traffic data(octets) for a given port.

Below is a C-code of my implementation of this same function on rtl839x.

u64 port_traffic_get(u




NEXT




<s> rtk_api_ret_t rtk_ptp_mac_set(rtk_mac_t mac)
{
rtk_api_ret_t retVal;
ether_addr_t sw_mac;

memcpy(sw_mac.octet, mac.octet, ETHER_ADDR_LEN);

if((retVal=rtl8367c_setAsicEavMacAddress(sw_mac))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the switch's mac addr

The following code snippet is used to get the switch's mac addr

rtk_api_ret_t getMibStatus(int opType, char *value, int *len




NEXT




<s> static int b53_srab_write48(struct b53_device *dev, u8 page, u8 reg,
u64 value)
{
u8 __iomem *regs = dev->priv;
int ret = 0;

ret = b53_srab_request_grant(dev);
if (ret)
goto err;

writel((u32)value, regs + B53_SRAB_WD_L);
writel((u16)(value >> 32), regs + B53_SRAB_WD_H);

ret = b53_srab_op(dev, page, reg, B53_SRAB_CMDSTAT_WRITE);

err:
b53_srab_release_grant(dev);

return ret;

}

The above function is used to write to any of the B53 address registers using an
Srab. There is an Sram and Srab, which are essentially shared memory pages that
each core shares with other cores and the PCIe controller using 1,6




NEXT




<s> mt7530_r32(struct mt7530_priv *priv, u32 reg)
{
u32 val;
if (priv->bus) {
u16 high, low;

mutex_lock(&priv->bus->mdio_lock);
__mdiobus_write(priv->bus, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
low = __mdiobus_read(priv->bus, 0x1f, (reg >> 2) & 0xf);
high = __mdiobus_read(priv->bus, 0x1f, 0x10);
mutex_unlock(&priv->bus->mdio_lock);

return (high << 16) | (low & 0xffff);
}

val = ioread32(priv->base + reg);
pr_debug("MT7530 MDIO Read [%04x]=%08x\n", reg, val);

return val;
}

The above function is used to read from MDIO register.
If the user has provided a bus, it reads bus to read from the onboard Flash of the Wifi adapter.
Otherwise it reads data directly from the CPU memory-mapped area.

In




NEXT




<s> static int atm_showtime_exit(void)
{
int port_num;

if ( !g_showtime )
return -1;

#if defined(CONFIG_VR9)
IFX_REG_W32(0x00, UTP_CFG);
#endif

for ( port_num = 0; port_num < ATM_PORT_NUMBER; port_num++ )
atm_dev_signal_change(g_atm_priv_data.port[port_num].dev, ATM_PHY_SIG_LOST);

g_showtime = 0;
g_xdata_addr = NULL;
printk("leave showtime\n");
return 0;
}

The above function is used to disable VIA port's PHY function, and free a buffer allocated by atm_dev_alloc_msg_data function. Please keep in mind that before calling atm_dev_alloc_msg_data, we need to initialize VIA




NEXT




<s> static void rtl930x_vlan_tables_read(u32 vlan, struct rtl838x_vlan_info *info)
{
u32 v, w;
/* Read VLAN table (1) via register 0 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_0, 1);

rtl_table_read(r, vlan);
v = sw_r32(rtl_table_data(r, 0));
w = sw_r32(rtl_table_data(r, 1));
pr_debug("VLAN_READ %d: %08x %08x\n", vlan, v, w);
rtl_table_release(r);

info->tagged_ports = v >> 3;
info->profile_id = (w >> 24) & 7;
info->hash_mc_fid = !!(w & BIT(27));
info->hash_uc_fid = !!(w & BIT(28));
info->fid = ((v & 0x7) << 3) | ((w >> 29) & 0x7);

/* Read UNTAG table via table register 2 */
r = rtl_table_get(RTL9300_TBL_2, 0);
rtl_table_read(r, vlan);
v = sw_r32(rtl_table_data(r, 0));
rtl_table_release(r);

info->untagged_ports = v >> 3;
}

The above function is used to get vlan id info from register.

It’s pretty easy to write 2 tests. One test is to get vlan id info from valid vlan and another test is to get vlan id info from invalid vlan id.




NEXT




<s> static unsigned int en7523_get_base_rate(void __iomem *base, unsigned int i)
{
const struct en_clk_desc *desc = &en7523_base_clks[i];
u32 val;

if (!desc->base_bits)
return desc->base_value;

val = readl(base + desc->base_reg);
val >>= desc->base_shift;
val &= (1 << desc->base_bits) - 1;

if (val >= desc->n_base_values)
return 0;

return desc->base_values[val];
}

The above function is used to get the base rate for each of the clocks available on the board. Note that the index for the registers is i which is the clock id for the en7523_base_clks array. This function gets the first value (




NEXT




<s> uc_bpf_open_map(uc_vm_t *vm, size_t nargs)
{
struct bpf_map_info info;
uc_value_t *path = uc_fn_arg(0);
__u32 len = sizeof(info);
int err;
int fd;

if (ucv_type(path) != UC_STRING)
err_return(EINVAL, "module path");

fd = bpf_obj_get(ucv_string_get(path));
if (fd < 0)
err_return(errno, NULL);

err = bpf_obj_get_info_by_fd(fd, &info, &len);
if (err) {
close(fd);
err_return(errno, NULL);
}

return uc_bpf_map_create(fd, info.key_size, info.value_size, true);
}

The above function is used to open a bpf map that has not been added to kernel using the bpf helper function "bpf_obj_get_map". However it should also be noted that a bpf program that uses this helper function to add a map to kernel




NEXT




<s> ret_t rtl8367c_setAsic1xMBEnConfig(rtk_uint32 port, rtk_uint32 enabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_MAC_ENABLE_REG, port, enabled);
}

The above function is used to enable/disable 802.1x mode by port ID and the setting will take effect immediately.
RTL8367C_DOT1X_MAC_ENABLE_REG
    Address: 0x1b0




NEXT




<s> ret_t rtl8367c_getAsicShareMeterBucketSize(rtk_uint32 index, rtk_uint32 *pLbthreshold)
{
if(index > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(index < 32)
return rtl8367c_getAsicReg(RTL8367C_METER_BUCKET_SIZE_REG(index), pLbthreshold);
else
return rtl8367c_getAsicReg(RTL8367C_REG_METER32_BUCKET_SIZE + index - 32, pLbthreshold);
}

The above function is used to get share meter size in a switch. It is used to get share meter bucket size when meter counter reaches the limit.

#ifdef RTL_BIG_ENDIAN:
if(index > RTL8367C




NEXT




<s> void __init prom_free_prom_memory(void)
{

}

The above function is used to free the uninitialized memory which are usually a chunk or more of consecutive memory at the beginning of the available RAM (before the RAM reserved for the OS).
Although not directly usable by the OS, some applications may be written based on the




NEXT




<s> ret_t rtl8367c_getAsicPortMirrorIsolationRxLeaky(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_RX_ISOLATION_LEAKY_OFFSET, pEnabled);
}

The above function is used to get mirroring port information.
I'm getting the below error when called the above function.

rtl8367c_config_init is not initialised

I have done the follow steps.
1.




NEXT




<s> static ssize_t bcm4908img_create_append_file(FILE *trx, const char *in_path, uint32_t *crc32) {
FILE *in;
size_t bytes;
ssize_t length = 0;
uint8_t buf[1024];

in = fopen(in_path, "r");
if (!in) {
fprintf(stderr, "Failed to open %s\n", in_path);
return -EACCES;
}

while ((bytes = fread(buf, 1, sizeof(buf), in)) > 0) {
if (fwrite(buf, 1, bytes, trx) != bytes) {
fprintf(stderr, "Failed to write %zu B to %s\n", bytes, pathname);
length = -EIO;
break;
}
*crc32 = bcm4908img_crc32(*crc32, buf, bytes);
length += bytes;
}

fclose(in);

return length;
}

The above function is used to append a file in the created file. However, this function can only be called when we know the size of the file, i.e. when we know the `trx` file has been created completely. Hence, when we call it,




NEXT




<s> static inline u32 sata_oxnas_hostportbusy(struct ata_port *ap)
{
struct sata_oxnas_host_priv *hd = ap->host->private_data;

return (ioread32(hd->port_base + SATA_COMMAND) & CMD_CORE_BUSY) ||
(hd->n_ports > 1 &&
(ioread32(hd->port_base + PORT_SIZE + SATA_COMMAND) &
CMD_CORE_BUSY));
}

The above function is used to poll for core ready completion
(CMD_CORE_BUSY getting cleared).

For a dual port host, which are not yet fully supported by the
kernel, we poll port 1 in addition to port 0. The port 




NEXT




<s> void msdc_performance(u32 opcode, u32 sizes, u32 bRx, u32 ticks)
{
struct sdio_profile *result = &sdio_perfomance;
struct cmd_profile *cmd;
u32 block;

if (sdio_pro_enable == 0)
return;

if (opcode == 52) {
cmd = bRx ?  &result->cmd52_rx : &result->cmd52_tx;
} else if (opcode == 53) {
if (sizes < 512) {
cmd = bRx ?  &result->cmd53_rx_byte[sizes] : &result->cmd53_tx_byte[sizes];
} else {
block = sizes / 512;
if (block >= 99) {
printk("cmd53 error blocks\n");
while (1)
;
}
cmd = bRx ?  &result->cmd53_rx_blk[block] : &result->cmd53_tx_blk[block];
}
} else {
return;
}

/* update the members */
if (ticks > cmd->max_tc)
cmd->max_tc = ticks;
if (cmd->min_tc == 0 || ticks < cmd->min_tc)
cmd->min_tc = ticks;
cmd->tot_tc += ticks;
cmd->tot_bytes += sizes;
cmd->count++;

if (bRx)
result->total_rx_bytes += sizes;
else
result->total_tx_bytes += sizes;
result->total_tc += ticks;

/* dump when total_tc > 30s */
if (result->total_tc >= sdio_pro_time * TICKS_ONE_MS * 1000) {
msdc_sdio_profile(result);
memset(result, 0, sizeof(struct sdio_profile));
}
}

The above function is used to dump sdio command performance. It will be called after each command is executed. The data will be used to check sdio controller performance. The format of the dump data is as following:

The result can be used to check mmc performance




NEXT




<s> w16(struct adm6996_priv *priv, enum admreg reg, u16 val)
{
priv->write(priv, reg, val);
}

The above function is used to write 16 bits data into register of
ADM6996.The function priv->write is undefined in the driver,
because we need to decide the interface is I2C/SLLC-I2C or





NEXT




<s> void __init plat_mem_setup(void)
{
void *dtb;

set_io_port_base(KSEG1);

dtb = get_fdt();
if (!dtb)
panic("no dtb found");

/*
* Load the devicetree. This causes the chosen node to be
* parsed resulting in our memory appearing
*/
__dt_setup_arch(dtb);
}

The above function is used to set base address of CPU registers in the kernel. But
how do we change it to suit our specific needs? In order to change CPU base
address register, one needs to change address in the dtb. We might need to do
this




NEXT




<s> static int __init button_hotplug_init(void)
{
int ret;

printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
ret = input_register_handler(&button_hotplug_handler);
if (ret)
BH_ERR("unable to register input handler\n");

return ret;
}

The above function is used to initialise the driver. It registers the input handler with the kernel.

static void __exit button_hotplug_exit(void)
{
input_unregister_handler(&button_hotplug_handler);
printk(KERN_




NEXT




<s> ret_t rtl8367c_getAsicStormFilterUnknownUnicastEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_STORM_UNKNOWN_UCAST_REG, port, pEnabled);
}

The above function is used to access 32 bytes storm filter register. For example, let A.1 be storm filter register number 1 on port 3. We can get that register's content by executing the call rtl8367c_get




NEXT




<s> bool menu_is_empty(struct menu *menu)
{
struct menu *child;

for (child = menu->list; child; child = child->next) {
if (menu_is_visible(child))
return(false);
}
return(true);
}

The above function is used to check if the sub element or child element
of a menu is empty and set the visible variable of it to false,

This is a simple example

The above menu is created in a php page and
the function menu_is




NEXT




<s> static bool nmbm_check_header(const void *data, uint32_t size)
{
const struct nmbm_header *header = data;
struct nmbm_header nhdr;
uint32_t new_checksum;

/*
* Make sure expected structure size is equal or smaller than
* buffer size.
*/
if (header->size > size)
return false;

memcpy(&nhdr, data, sizeof(nhdr));

nhdr.checksum = 0;
new_checksum = nmbm_crc32(0, &nhdr, sizeof(nhdr));
if (header->size > sizeof(nhdr))
new_checksum = nmbm_crc32(new_checksum,
(const uint8_t *)data + sizeof(nhdr),
header->size - sizeof(nhdr));

if (header->checksum != new_checksum)
return false;

return true;
}

The above function is used to check that the file (a packet) we have read contains valid NMBM format. Notice that we use the same format we used in our example. The checksum is calculated from the data in the header and the data in the file.





NEXT




<s> void rtl838x_set_distribution_algorithm(int group, int algoidx, u32 algomsk)
{
algoidx &= 1; /* RTL838X only supports 2 concurrent algorithms */
sw_w32_mask(1 << (group % 8), algoidx << (group % 8),
RTL838X_TRK_HASH_IDX_CTRL + ((group >> 3) << 2));
sw_w32(algomsk, RTL838X_TRK_HASH_CTRL + (algoidx << 2));
}

The above function is used to set a specific distribution algorithm
IDX(group), to a group of 4 hash functions, and each hash function
gets a distribution algorithm IDX + 56 * i, where i = 0,...,7.

Al




NEXT




<s> static int __init hiveap_330_probe(void)
{
if (of_machine_is_compatible("aerohive,hiveap-330"))
return 1;
return 0;
}

The above function is used to detect the aerohive 330 ap. As 330 is the only device which is compatible with the machine. if of_machine_is_compatible does not return 1 then it means it is not compatible with this device




NEXT




<s> ret_t rtl8367c_setAsicPriorityDscpBased(rtk_uint32 dscp, rtk_uint32 priority )
{
if(priority > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

if(dscp > RTL8367C_DSCPMAX)
return RT_ERR_QOS_DSCP_VALUE;

return rtl8367c_setAsicRegBits(RTL8367C_QOS_DSCP_TO_PRIORITY_REG(dscp), RTL8367C_QOS_DSCP_TO_PRIORITY_MASK(dscp), priority);
}

The above function is used to configure priority table for DSCP based QoS.
The register is the QOS_DSCP_TO_PRIORITY register.
The parameter is DSCP value.
The return is the set value, this function




NEXT




<s> SC_TAG_SHOW_STORE_U32TVS_FUNCS(bootdevices)
SC_TAG_SHOW_STORE_BOOLTS_FUNCS(bootkey)
SC_TAG_SHOW_STORE_BOOLTS_FUNCS(cpumode)
SC_TAG_SHOW_STORE_BOOLTS_FUNCS(bootproto)
SC_TAG_SHOW_STORE_BOOLTS_FUNCS(booter)
SC_TAG_SHOW_STORE_BOOLTS_FUNCS(silent_boot)

static ssize_t sc_tag_show_bootdelays(const u8 *pld, u16 pld_len, char *buf)
{
const char *fmt;
char *out = buf;
u32 data;	// cpu-endian
int i;

if (sizeof(data) != pld_len)
return -EINVAL;

read_lock(&sc_bufrwl);
data = *(u32 *)pld;		// pld aliases sc_buf
read_unlock(&sc_bufrwl);

for (i = RB_BOOT_DELAY_MIN; i <= RB_BOOT_DELAY_MAX; i++) {
fmt = (i == data) ? "[%d] " : "%d ";
out += sprintf(out, fmt, i);
}

out += sprintf(out, "\n");
return out - buf;
}

The above function is used to show the boot delay modes available. Since the field is 3 bits, there are 8 possible boot delay values.</s>




NEXT




<s> rtk_api_ret_t rtk_rate_stormControlExtMeterIdx_set(rtk_rate_storm_group_t stormType, rtk_uint32 index)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (stormType >= STORM_GROUP_END)
return RT_ERR_SFC_UNKNOWN_GROUP;

if (index > RTK_MAX_METER_ID)
return RT_ERR_FILTER_METER_ID;

switch (stormType)
{
case STORM_GROUP_UNKNOWN_UNICAST:
if ((retVal = rtl8367c_setAsicStormFilterExtUnknownUnicastMeter(index))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_UNKNOWN_MULTICAST:
if ((retVal = rtl8367c_setAsicStormFilterExtUnknownMulticastMeter(index))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_MULTICAST:
if ((retVal = rtl8367c_setAsicStormFilterExtMulticastMeter(index))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_BROADCAST:
if ((retVal = rtl8367c_setAsicStormFilterExtBroadcastMeter(index))!=RT_ERR_OK)
return retVal;
break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to configure a Meter index to Storm Control. Storm Control only applies to STORM_GROUP_UNKNOWN_UNICAST, STORM_GROUP_UNKNOWN_MULTICAST, STORM_GROUP_MULTICAST, and STORM_




NEXT




<s> FILE *zconf_fopen(const char *name)
{
char *env, fullname[PATH_MAX+1];
FILE *f;

f = fopen(name, "r");
if (!f && name != NULL && name[0] != '/') {
env = getenv(SRCTREE);
if (env) {
snprintf(fullname, sizeof(fullname),
"%s/%s", env, name);
f = fopen(fullname, "r");
}
}
return f;
}

The above function is used to open a file in case it isn't in the current directory. At first I didn't have the env variable, but it helped getting a different file in some occasions. I'd like to avoid getting the SRCTREE env, but




NEXT




<s> rol32(uint32_t word, int shift)
{
return (word << shift) | (word >> (32 - shift));
}

The above function is used to shift a 32 bit number to the left by some amount (shift) within one word. This is done by a few logical operations. It has a number of advantages:

- It requires one fewer multiplies than rotating by the




NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_unmatchAction_set(rtk_port_t port, rtk_filter_unmatch_action_t action)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if(action >= FILTER_UNMATCH_END)
return RT_ERR_INPUT;

if((ret = rtl8367c_setAsicAclUnmatchedPermit(rtk_switch_port_L2P_get(port), action)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to set the action when match the MAC, IP of ICMP/ARP packet but the Ether type or IP protocol is wrong.

The value of action has been defined in Filter_unmatch_action as follows:

    typedef




NEXT




<s> ar8xxx_phy_mmd_read(struct ar8xxx_priv *priv, int phy_addr, u16 addr, u16 reg)
{
struct mii_bus *bus = priv->mii_bus;
u16 data;

mutex_lock(&bus->mdio_lock);
ar8xxx_phy_mmd_prep(bus, phy_addr, addr, reg);
data = bus->read(bus, phy_addr, MII_ATH_MMD_DATA);
mutex_unlock(&bus->mdio_lock);

return data;
}

The above function is used to read a MMD register in the PHY.

The phy_mdio_read function reads a MII-style register from the PHY,
which is a subset of the MMD registers.

ar8xxx_




NEXT




<s> int dc_ep_dev_info_release(int dev_idx)
{
struct dc_ep_priv *priv;

if ((dev_idx < 0) || (dev_idx >= DC_EP_MAX_NUM)) {
pr_err("%s invalid device index %d\n",
__func__, dev_idx);
return -EIO;
}

priv = &g_dc_ep_info.pcie_ep[dev_idx];
if (atomic_read(&priv->refcnt) <= 0) {
pr_err("%s mismatch request/release module usage\n",
__func__);
return -EIO;
}

atomic_dec(&priv->refcnt);
return 0;
}

The above function is used to release the private data of the PCIe end-point device.</s>




NEXT




<s> ret_t rtl8367c_setAsicRldp8051Portmask(rtk_uint32 portmask)
{
ret_t retVal;
if(portmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

retVal = rtl8367c_setAsicRegBits(RTL8367C_RLDP_CTRL0_REG,RTL8367C_RLDP_8051_LOOP_PORTMSK_MASK,portmask & 0xff);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_RLDP_CTRL5,RTL8367C_RLDP_CTRL5_MASK,(portmask >> 8) & 7);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set RLDP 8051 Loopback Port Mask.

Function Description: This function is used to set RLDP 8051 Loopback Port Mask. It takes an input portmask to determine which ports




NEXT




<s> static uint32_t nmbm_get_block_state(struct nmbm_instance *ni, uint32_t ba)
{
return nmbm_get_block_state_raw(ni->block_state, ba);
}

The above function is used to check that the specified block is still usable. Blocks can become unusable when the block bitmap changes. Any read() or write() to a block will update the block bitmap, even if the actual read or write succeeds.

It




NEXT




<s> inline void rtl931x_exec_tbl1_cmd(u32 cmd)
{
sw_w32(cmd, RTL931X_TBL_ACCESS_CTRL_1);
do { } while (sw_r32(RTL931X_TBL_ACCESS_CTRL_1) & (1 << 17));
}

The above function is used to execute certain commands. It is written in terms of the RTL931X_TBL_ACTCTR_1 register which has a bit that reads "Enable Tbl Access" which you can see is named bit 17.




NEXT




<s> static void msdc_dma_start(struct msdc_host *host)
{
void __iomem *base = host->base;
u32 wints = MSDC_INTEN_XFER_COMPL | MSDC_INTEN_DATTMO | MSDC_INTEN_DATCRCERR;

sdr_set_bits(MSDC_INTEN, wints);
//dsb(); /* --- by chhung */
sdr_set_field(MSDC_DMA_CTRL, MSDC_DMA_CTRL_START, 1);

N_MSG(DMA, "DMA start");
}

The above function is used to initiate DMA transaction with the SD/MMC card. But I am not very good at understanding such C code. I will go through the following steps to understand what the code is doing.
1. First I will replace the call to s




NEXT




<s> int dc_aca_stop(struct dc_ep_priv *priv, u32 *func, int reset)
{
u32 val = *func;
u32 reg;

if (!val)
return 0;

*func = 0;

/* Only do it if reset is required. Otherwise, pending is fine */
if (reset) {
if (val & ACA_TXIN_EN) {
reg = rd32(TXIN_COUNTERS);
if (MS(reg, ACA_PENDING_JOB)
|| (MS(reg, ACA_AVAIL_BUF) != ACA_PP_BUFS)) {
*func = ACA_TXIN_EN;
return -EBUSY;
}
}

if (val & ACA_TXOUT_EN) {
reg = rd32(TXOUT_COUNTERS);
if (MS(reg, ACA_PENDING_JOB)
|| (MS(reg, ACA_AVAIL_BUF) != ACA_PP_BUFS)) {
*func = ACA_TXOUT_EN;
return -EBUSY;
}
}


if (val & ACA_RXIN_EN) {
reg = rd32(RXIN_COUNTERS);
if (MS(reg, ACA_PENDING_JOB)
|| (MS(reg, ACA_AVAIL_BUF) != ACA_PP_BUFS)) {
*func = ACA_RXIN_EN;
return -EBUSY;
}
}

if (val & ACA_RXOUT_EN) {
reg = rd32(RXOUT_COUNTERS);
if (MS(reg, ACA_PENDING_JOB)
|| (MS(reg, ACA_AVAIL_BUF) != ACA_PP_BUFS)) {
*func = ACA_RXOUT_EN;
return -EBUSY;
}
}
}

wr32_mask(val, 0, GNRC_EN_TASK_BITMAP);

if (reset) {
aca_dma_ch_off(priv);
aca_xbar_ia_reject_set(priv, ACA_ACC_IA04);
aca_xbar_ia_reject_set(priv, ACA_M_IA06);
aca_sw_reset(priv);
}
return 0;
}

The above function is used to stop the AcA in case of an error detection is done and is used before resuming the AcA.
As you all know, we only accept IAs on RxOUT, TxIN, TxOUT ports of the AcA




NEXT




<s> static int zyxel_bootconfig_mtd_open(struct zyxel_bootconfig_mtd *mtd, const char *mtd_name) {
int ret = 0;

mtd->fd = open(mtd_name, O_RDWR | O_SYNC);
if (mtd->fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd_name);
ret = -1;
goto out;
}

if (ioctl(mtd->fd, MEMGETINFO, &mtd->mtd_info)) {
fprintf(stderr, "Could not get MTD device info from %s\n", mtd_name);
ret = -1;
zyxel_bootconfig_mtd_close(mtd);
goto out;
}

out:
return ret;
}

The above function is used to open a device file that belongs to a specific MTD device. Currently it supports the names ‘mtd1’, ‘mtd2’ and ‘mtd3’.

int zyxel_boot_config_mtd_read




NEXT




<s> swconfig_get_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
int ret;
if (val->port_vlan >= dev->vlans)
return -EINVAL;

if (!dev->ops->get_vlan_ports)
return -EOPNOTSUPP;

ret = dev->ops->get_vlan_ports(dev, val);
return ret;
}

The above function is used to get the ports used in a VLAN on a given switch device. The function is called by the netlink module using dev_attr_vlans.get, with the attr passed as the struct switch_port_vlan port_vlan




NEXT




<s> static int trelay_do_remove(struct trelay *tr)
{
list_del(&tr->list);

/* First and before all, ensure that the debugfs file is removed
* to prevent dangling pointer in file->private_data */
debugfs_remove_recursive(tr->debugfs);

dev_put(tr->dev1);
dev_put(tr->dev2);

netdev_rx_handler_unregister(tr->dev1);
netdev_rx_handler_unregister(tr->dev2);

trelay_log(KERN_INFO, tr, "stopped");

kfree(tr);

return 0;
}

The above function is used to remove trelay from the module unload.
static int
trelay_release(struct device *dev)
{
struct trelay *tr = netdev_priv(to_net_dev(dev));

trel




NEXT




<s> static void scr_write(int device, unsigned int sc_reg, u32 val)
{
/* Setup the data for the write */
*(sata_regs_base[device] + SATA_LINK_DATA) = val;

/* Setup adr of required register. std regs start eight into async region */
*(sata_regs_base[device] + SATA_LINK_WR_ADDR) = sc_reg
* 4+ SATA_STD_ASYNC_REGS_OFF;

/* Wait for data to be written */
int loops = MAX_SRC_WRITE_LOOPS;
do {
if (*(sata_regs_base[device] + SATA_LINK_CONTROL) & 1UL) {
break;
}
udelay(10);
} while (--loops);

if (!loops) {
printf("scr_write() Timed out of wait for write completion\n");
}
}

The above function is used to write data to the sata regsitsers, the above code is from scr_write.c.
This is used when you set the "port multiator" via the gui, when you click on the buttons it sends values to




NEXT




<s> static inline int rtl839x_port_iso_ctrl(int p)
{
return RTL839X_PORT_ISO_CTRL(p);
}

The above function is used to get the register port ISO controller.

static int max_rx[8] = {-1};
static int max_tx[8] = {-1};
static int max_rx_len[8] = {-




NEXT




<s> static void rtl839x_pie_lookup_enable(struct rtl838x_switch_priv *priv, int index)
{
int block = index / PIE_BLOCK_SIZE;

sw_w32_mask(0, BIT(block), RTL839X_ACL_BLK_LOOKUP_CTRL);
}

The above function is used to enable PIE lookup for traffic belonging to given 64-bit hash bucket index. It is one of several pieces of code that use sw_w32_mask() to set a bit, which seems fairly common in driver implementations and




NEXT




<s> static int ip17xx_get_tag(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int vlan = val->port_vlan;

if (vlan < 0 || vlan >= MAX_VLANS)
return -EINVAL;

val->value.i = state->vlans[vlan].tag;
return 0;
}

The above function is used to get the value of the VLAN tag and is called when a VLAN tag attribute is read in the switch tree.

The following function is used to set the value of a VLAN tag attribute:

static int ip17xx




NEXT




<s> static int ubifs_find(struct mtd_info *mtd, loff_t *offs, loff_t size)
{
const loff_t end = *offs + size;
uint32_t magic;
size_t retlen;
int rc;

for (; *offs < end; *offs += mtd->erasesize) {
rc = mtd_read(mtd, *offs, sizeof(magic), &retlen,
(unsigned char *) &magic);
if (rc || retlen != sizeof(magic))
continue;

if (be32_to_cpu(magic) == UBI_MAGIC)
return 0;
}

return -ENOENT;
}

The above function is used to find the location of the first block. To find
where does it locate?

Let’s see what UBIMAGIC is.

static uint32_t ubifs_getubi_magic(struct ubifs




NEXT




<s> static ssize_t bcm4908img_create_append_zeros(FILE *trx, size_t length) {
uint8_t *buf;

buf = malloc(length);
if (!buf)
return -ENOMEM;
memset(buf, 0, length);

if (fwrite(buf, 1, length, trx) != length) {
fprintf(stderr, "Failed to write %zu B to %s\n", length, pathname);
free(buf);
return -EIO;
}

free(buf);

return length;
}

The above function is used to write multiple zeros to a file in the flash file system.

```</s>




NEXT




<s> int rtl83xx_lag_add(struct dsa_switch *ds, int group, int port, struct netdev_lag_upper_info *info)
{
struct rtl838x_switch_priv *priv = ds->priv;
int i;
u32 algomsk = 0;
u32 algoidx = 0;

if (info->tx_type != NETDEV_LAG_TX_TYPE_HASH) {
pr_err("%s: Only mode LACP 802.3ad (4) allowed.\n", __func__);
return -EINVAL;
}

if (group >= priv->n_lags) {
pr_err("%s: LAG %d invalid.\n", __func__, group);
return -EINVAL;
}

if (port >= priv->cpu_port) {
pr_err("%s: Port %d invalid.\n", __func__, port);
return -EINVAL;
}

for (i = 0; i < priv->n_lags; i++) {
if (priv->lags_port_members[i] & BIT_ULL(port))
break;
}
if (i != priv->n_lags) {
pr_err("%s: Port %d already member of LAG %d.\n", __func__, port, i);
return -ENOSPC;
}

switch(info->hash_type) {
case NETDEV_LAG_HASH_L2:
algomsk |= TRUNK_DISTRIBUTION_ALGO_DMAC_BIT;
algomsk |= TRUNK_DISTRIBUTION_ALGO_SMAC_BIT;
break;
case NETDEV_LAG_HASH_L23:
algomsk |= TRUNK_DISTRIBUTION_ALGO_DMAC_BIT;
algomsk |= TRUNK_DISTRIBUTION_ALGO_SMAC_BIT;
algomsk |= TRUNK_DISTRIBUTION_ALGO_SIP_BIT; /* source ip */
algomsk |= TRUNK_DISTRIBUTION_ALGO_DIP_BIT; /* dest ip */
algoidx = 1;
break;
case NETDEV_LAG_HASH_L34:
algomsk |= TRUNK_DISTRIBUTION_ALGO_SRC_L4PORT_BIT; /* sport */
algomsk |= TRUNK_DISTRIBUTION_ALGO_DST_L4PORT_BIT; /* dport */
algomsk |= TRUNK_DISTRIBUTION_ALGO_SIP_BIT; /* source ip */
algomsk |= TRUNK_DISTRIBUTION_ALGO_DIP_BIT; /* dest ip */
algoidx = 2;
break;
default:
algomsk |= 0x7f;
}
priv->r->set_distribution_algorithm(group, algoidx, algomsk);
priv->r->mask_port_reg_be(0, BIT_ULL(port), priv->r->trk_mbr_ctr(group));
priv->lags_port_members[group] |= BIT_ULL(port);

pr_info("%s: Added port %d to LAG %d. Members now %016llx.\n",
__func__, port, group, priv->lags_port_members[group]);

return 0;
}

The above function is used to add certain interface to a group. This function is also used for adding a physical interface to a bonding. It sets the trunk forwarding method and the distribution method, depending on which mode this interface is using. For example, with 80




NEXT




<s> static int rtl8367_led_group_set_mode(struct rtl8366_smi *smi,
unsigned int mode)
{
u16 mask;
u16 set;
int err;

mode &= RTL8367_LED_CONFIG_DATA_M;

mask = (RTL8367_LED_CONFIG_DATA_M << RTL8367_LED_CONFIG_DATA_S) |
RTL8367_LED_CONFIG_SEL;
set = (mode << RTL8367_LED_CONFIG_DATA_S) | RTL8367_LED_CONFIG_SEL;

REG_RMW(smi, RTL8367_LED_CONFIG_REG, mask, set);

return 0;
}

The above function is used to set the group mode of led on RT-8326.

The RT-8326 LED Group Control Register is 4-bit, and 0x10110 is set
to the RTL8




NEXT




<s> ret_t rtl8367c_getAsicPHYReg(rtk_uint32 phyNo, rtk_uint32 phyAddr, rtk_uint32 *pRegData )
{
rtk_uint32 ocp_addr;

if(phyAddr > RTL8367C_PHY_REGNOMAX)
return RT_ERR_PHY_REG_ID;

ocp_addr = 0xa400 + phyAddr*2;

return rtl8367c_getAsicPHYOCPReg(phyNo, ocp_addr, pRegData);
}

The above function is used to get the PHY register values from the device.

#if 0
rtk_bool rtl8367c_setAsicPHYReg(rtk_uint32 phyNo, rtk_uint3




NEXT




<s> void rtl839x_update_cntr(int r, int released)
{
/* This feature is not available on RTL839x SoCs */
}

The above function is used to update counters that are incremented for each
sent or received packet to determine the rate of traffic on an 802.11 interface.

For example, rtl87_counters[RTL87_CO




NEXT




<s> __ar8216_init_port(struct ar8xxx_priv *priv, int port,
bool cpu_ge, bool flow_en)
{
/* Enable port learning and tx */
ar8xxx_write(priv, AR8216_REG_PORT_CTRL(port),
AR8216_PORT_CTRL_LEARN |
(4 << AR8216_PORT_CTRL_STATE_S));

ar8xxx_write(priv, AR8216_REG_PORT_VLAN(port), 0);

if (port == AR8216_PORT_CPU) {
ar8xxx_write(priv, AR8216_REG_PORT_STATUS(port),
AR8216_PORT_STATUS_LINK_UP |
(cpu_ge ? AR8216_PORT_SPEED_1000M : AR8216_PORT_SPEED_100M) |
AR8216_PORT_STATUS_TXMAC |
AR8216_PORT_STATUS_RXMAC |
(flow_en ? AR8216_PORT_STATUS_RXFLOW : 0) |
(flow_en ? AR8216_PORT_STATUS_TXFLOW : 0) |
AR8216_PORT_STATUS_DUPLEX);
} else {
ar8xxx_write(priv, AR8216_REG_PORT_STATUS(port),
AR8216_PORT_STATUS_LINK_AUTO);
}
}

The above function is used to init ethernet port.

The 2nd argument is port number. It can be '0' for port0, '1' for port1, etc...

The 3rd argument means cpu port?

The




NEXT




<s> static u32 mt7621_nfc_pio_read(struct mt7621_nfc *nfc, bool br)
{
u32 reg;

/* after each byte read, the NFI_STA reg is reset by the hardware */
reg = (nfi_read32(nfc, NFI_STA) & STA_NFI_FSM_M) >> STA_NFI_FSM_S;
if (reg != STA_FSM_CUSTOM_DATA) {
reg = nfi_read16(nfc, NFI_CNFG);
reg |= CNFG_READ_MODE | CNFG_BYTE_RW;
if (!br)
reg &= ~CNFG_BYTE_RW;
nfi_write16(nfc, NFI_CNFG, reg);

/*
* set to max sector to allow the HW to continue reading over
* unaligned accesses
*/
nfi_write16(nfc, NFI_CON, CON_NFI_SEC_M | CON_NFI_BRD);

/* trigger to fetch data */
nfi_write16(nfc, NFI_STRDATA, STR_DATA);
}

mt7621_nfc_wait_pio_ready(nfc);

return nfi_read32(nfc, NFI_DATAR);
}

The above function is used to fetch data for a read operation. The first few lines of the function check if the previous read operation was complete. If not, it enters a loop. The loop ends only if it detects that NFI_FSM_CUSTOM_




NEXT




<s> static inline uint16_t to_entry_header_id(uint32_t name_id)
{
if (swap_bytes)
return ntohl(name_id) & 0xffff;

return name_id & 0xffff;
}

The above function is used to convert a uint32_t name_id back to a ntohl
uint16_t, without the leading two null bytes typically found in a udp
header.

Is there any reason why the ntohl (




NEXT




<s> void BN_CTX_end(BN_CTX *ctx)
{
if (ctx == NULL) return;
assert(ctx->depth > 0);
if (ctx->depth == 0)
/* should never happen, but we can tolerate it if not in
* debug mode (could be a 'goto err' in the calling function
* before BN_CTX_start was reached) */
BN_CTX_start(ctx);

ctx->too_many = 0;
ctx->depth--;
if (ctx->depth < BN_CTX_NUM_POS)
ctx->tos = ctx->pos[ctx->depth];
}

The above function is used to end the creation of a BIGNUM/BN_CTX.</s>




NEXT




<s> static int rtl8367b_switch_init(struct rtl8366_smi *smi)
{
struct switch_dev *dev = &smi->sw_dev;
int err;

dev->name = "RTL8367B";
dev->cpu_port = smi->cpu_port;
dev->ports = RTL8367B_NUM_PORTS;
dev->vlans = RTL8367B_NUM_VIDS;
dev->ops = &rtl8367b_sw_ops;
dev->alias = dev_name(smi->parent);

err = register_switch(dev, NULL);
if (err)
dev_err(smi->parent, "switch registration failed\n");

return err;
}

The above function is used to initialize switch ports, registers, etc. Note: it is only called once when the system boots up. To register the switch, first a switch device file is created in rtl8367b/Kconfig:

[switch]




NEXT




<s> static void bcma_fbs_fixup(struct bcma_fbs *priv, u16 *sprom)
{
struct device_node *node = priv->dev->of_node;
u32 fixups, off, val;
int i = 0;

if (!of_get_property(node, "brcm,sprom-fixups", &fixups))
return;

fixups /= sizeof(u32);

dev_info(priv->dev, "patching SPROM with %u fixups...\n", fixups >> 1);

while (i < fixups) {
if (of_property_read_u32_index(node, "brcm,sprom-fixups",
i++, &off)) {
dev_err(priv->dev, "error reading fixup[%u] offset\n",
i - 1);
return;
}

if (of_property_read_u32_index(node, "brcm,sprom-fixups",
i++, &val)) {
dev_err(priv->dev, "error reading fixup[%u] value\n",
i - 1);
return;
}

dev_dbg(priv->dev, "fixup[%d]=0x%04x\n", off, val);

sprom[off] = val;
}
}

The above function is used to parse the fixup configuration from dtc file in order to apply dtc fixer to fixup the sprom.
I have found that if brcm provides better mechanism to fix the SPROM, the fixer will not required to be




NEXT




<s> ret_t rtl8367c_getAsicPortSmallIpg(rtk_uint32 port, rtk_uint32* pEnable)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_PORT_SMALL_IPG_REG(port), RTL8367C_PORT0_MISC_CFG_SMALL_TAG_IPG_OFFSET, pEnable);
}

The above function is used to get IPG value.
The value is: 0 ~ 255

rtk_uint32 AsicPortSmallIpg[], AsicPortSmallIpv6Pkg, AsicPortSmallIpv4




NEXT




<s> static bool is_end_of_token(char c)
{
/* Why are '.' and '/' valid characters for symbols? */
return !(isalnum(c) || c == '_' || c == '-' || c == '.' || c == '/');
}

The above function is used to identify the end of an identifier.

To solve this, we add a new character in the language grammar which is the end of identifier. So that we
can make use of the is_end_of_token function.






NEXT




<s> swconfig_send_ports(struct sk_buff **msg, struct genl_info *info, int attr,
const struct switch_val *val)
{
struct swconfig_callback cb;
int err = 0;
int i;

if (!val->value.ports)
return -EINVAL;

memset(&cb, 0, sizeof(cb));
cb.cmd = attr;
cb.msg = *msg;
cb.info = info;
cb.fill = swconfig_send_port;
cb.close = swconfig_close_portlist;

cb.nest[0] = nla_nest_start(cb.msg, cb.cmd);
for (i = 0; i < val->len; i++) {
err = swconfig_send_multipart(&cb, &val->value.ports[i]);
if (err)
goto done;
}
err = val->len;
swconfig_close_portlist(&cb, NULL);
*msg = cb.msg;

done:
return err;
}

The above function is used to return the port list back to the calling
program.

static int swconfig_close_portlist(struct swconfig_callback *cb,
void **return_data)
{
if (cb->portlist_close &&




NEXT




<s> static int rtl839x_smi_wait_op(int timeout)
{
int ret = 0;
u32 val;

ret = readx_poll_timeout(sw_r32, RTL839X_PHYREG_ACCESS_CTRL,
val, !(val & 0x1), 20, timeout);
if (ret)
pr_err("%s: timeout\n", __func__);

return ret;
}

The above function is used to make PHY reg access atomic. However
there is a problem in it.

Consider a case where your program is stuck at a loop or if the driver
is busy making lots of function calls at a time.

Consider




NEXT




<s> hostapd_bss_reload(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);

return hostapd_reload_config(hapd->iface);
}

The above function is used to restart hostapd. By setting a flag in the
struct hostapd_data context.

struct ubus_object_type hostapd_conf_objs[] = {
UBUS_OBJECT_ADD(HOT




NEXT




<s> BigIntegerCmp(c1, c2)
BigInteger c1, c2;
{
return BN_cmp(c1, c2);
}

The above function is used to compare BigInteger variables, which are defined
through the following variable declaration:

BigInteger d1;

BigIntegerCmp(d1, d2)
BigInteger d1, d2;
{
if (Big




NEXT




<s> static void _rtl8367c_VlanMCStUser2Smi(rtl8367c_vlanconfiguser *pVlanCg, rtk_uint16 *pSmiVlanCfg)
{
pSmiVlanCfg[0] |= pVlanCg->mbr & 0x07FF;

pSmiVlanCfg[1] |= pVlanCg->fid_msti & 0x000F;

pSmiVlanCfg[2] |= pVlanCg->vbpen & 0x0001;
pSmiVlanCfg[2] |= (pVlanCg->vbpri & 0x0007) << 1;
pSmiVlanCfg[2] |= (pVlanCg->envlanpol & 0x0001) << 4;
pSmiVlanCfg[2] |= (pVlanCg->meteridx & 0x003F) << 5;

pSmiVlanCfg[3] |= pVlanCg->evid & 0x1FFF;
}

The above function is used to convert the new VLAN configuration structure to the old VLAN configuration structure.

The following list explains the meanings of the parameters:

pSmiVlanCfg (input/output): The old VLAN configuration structure, which was




NEXT




<s> adm6996_write_gpio_reg(struct adm6996_priv *priv, enum admreg reg, u16 val)
{
/* cmd(27bits): sb(1) + opc(01) + addr(bbbbbbbb) + data(bbbbbbbbbbbbbbbb) */
u8 bits[4] = {
(0x05 << 5) | (reg >> 3),
(reg << 5) | (u8)(val >> 11),
(u8)(val >> 3),
(u8)(val << 5)
};

/* Enable GPIO outputs with all pins to 0 */
gpio_direction_output(priv->eecs, 0);
gpio_direction_output(priv->eesk, 0);
gpio_direction_output(priv->eedi, 0);

/* Write cmd. Total 27 bits */
adm6996_gpio_write(priv, 1, bits, 27);

/* Extra clock(s) required per datasheet */
adm6996_gpio_adclk(priv, 2);

/* Disable GPIO outputs */
gpio_direction_input(priv->eecs);
gpio_direction_input(priv->eesk);
gpio_direction_input(priv->eedi);
}

The above function is used to write GPIO commands (27 bits) to the GPIO pins
(1 to 5) of the 8-bit EEPROM.
The function first does a GPIO_write(1) on the respective GPIO pin for each




NEXT




<s> switch_generic_set_link(struct switch_dev *dev, int port,
struct switch_port_link *link)
{
if (WARN_ON(!dev->ops->phy_write16))
return -ENOTSUPP;

/* Generic implementation */
if (link->aneg) {
dev->ops->phy_write16(dev, port, MII_BMCR, 0x0000);
dev->ops->phy_write16(dev, port, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
} else {
u16 bmcr = 0;

if (link->duplex)
bmcr |= BMCR_FULLDPLX;

switch (link->speed) {
case SWITCH_PORT_SPEED_10:
break;
case SWITCH_PORT_SPEED_100:
bmcr |= BMCR_SPEED100;
break;
case SWITCH_PORT_SPEED_1000:
bmcr |= BMCR_SPEED1000;
break;
default:
return -ENOTSUPP;
}

dev->ops->phy_write16(dev, port, MII_BMCR, bmcr);
}

return 0;
}

The above function is used to set the port operating speed and duplex mode. Port may operate at
either half duplex or full duplex, and supported speeds include 10 Mbps, 100 Mbps, or 1000




NEXT




<s> static void conf_message_callback(const char *s)
{
if (save_and_exit) {
if (!silent)
printf("%s", s);
} else {
show_textbox(NULL, s, 6, 60);
}
}

The above function is used to process the output of the configuration menu. If `save_and_exit' is `TRUE', we just print the output, and if `FALSE', we show it in a textbox.

```
void handle_exit()





NEXT




<s> ret_t rtl8367c_getAsicIGMPQueryRX(rtk_uint32 port, rtk_uint32 *allow_query)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

/* Allow Query */
if (port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_QUERY_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_QUERY_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
*allow_query = value;

return RT_ERR_OK;
}

The above function is used to read the IGMP Query bit at register 0x16D2~0x16EF, 0~7 means 0~7 ports. And the port parameter from 0~7 need to redefined to 8




NEXT




<s> rtk_api_ret_t rtk_qos_queueNum_set(rtk_port_t port, rtk_queue_num_t queue_num)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((0 == queue_num) || (queue_num > RTK_MAX_NUM_OF_QUEUE))
return RT_ERR_FAILED;

if (RTK_MAX_NUM_OF_QUEUE == queue_num)
queue_num = 0;

if ((retVal = rtl8367c_setAsicOutputQueueMappingIndex(rtk_switch_port_L2P_get(port), queue_num)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set queue number to the certain port . If the value of queue number is 0, then the queue number will be 0~31, in order for the switch to apply the following default mapping

0~24 for q0




NEXT




<s> int wpa_ucode_run(const char *script)
{
uc_source_t *source;
uc_program_t *prog;
uc_value_t *ops;
char *err;
int ret;

source = uc_source_new_file(script);
if (!source)
return -1;

prog = uc_compile(vm.config, source, &err);
uc_source_put(source);
if (!prog) {
wpa_printf(MSG_ERROR, "Error loading ucode: %s\n", err);
return -1;
}

ret = uc_vm_execute(&vm, prog, &ops);
uc_program_put(prog);
if (ret || !ops)
return -1;

registry = ucv_array_new(&vm);
uc_vm_registry_set(&vm, "hostap.registry", registry);
ucv_array_set(registry, 0, ucv_get(ops));

return 0;
}

The above function is used to compile and execute the wpa-driver.ucode file, which is a Ucode script that is executed at startup to configure the device driver as
required. The wpa-config-tool binary itself uses the wpa-driver.u




NEXT




<s> rtk_api_ret_t  rtk_oam_multiplexerAction_get(rtk_port_t port, rtk_oam_multiplexer_act_t *pAction)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicOamMultiplexer(rtk_switch_port_L2P_get(port), pAction))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the OAM Multiplexer config on specified port. The input parameters are:
1. Port that need to be configured. RTK_PORT_TYPE should be used for input parameter.
2. OAM Multiplexer




NEXT




<s> static int mt7621_nfc_probe(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct mt7621_nfc *nfc;
struct resource *res;
int ret;

nfc = devm_kzalloc(dev, sizeof(*nfc), GFP_KERNEL);
if (!nfc)
return -ENOMEM;

nand_controller_init(&nfc->controller);
nfc->controller.ops = &mt7621_nfc_controller_ops;
nfc->dev = dev;

res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "nfi");
nfc->nfi_base = res->start;
nfc->nfi_regs = devm_ioremap_resource(dev, res);
if (IS_ERR(nfc->nfi_regs)) {
ret = PTR_ERR(nfc->nfi_regs);
return ret;
}

res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ecc");
nfc->ecc_regs = devm_ioremap_resource(dev, res);
if (IS_ERR(nfc->ecc_regs)) {
ret = PTR_ERR(nfc->ecc_regs);
return ret;
}

nfc->nfi_clk = devm_clk_get(dev, "nfi_clk");
if (IS_ERR(nfc->nfi_clk)) {
dev_warn(dev, "nfi clk not provided\n");
nfc->nfi_clk = NULL;
} else {
ret = clk_prepare_enable(nfc->nfi_clk);
if (ret) {
dev_err(dev, "Failed to enable nfi core clock\n");
return ret;
}
}

platform_set_drvdata(pdev, nfc);

ret = mt7621_nfc_init_chip(nfc);
if (ret) {
dev_err(dev, "Failed to initialize nand chip\n");
goto clk_disable;
}

return 0;

clk_disable:
clk_disable_unprepare(nfc->nfi_clk);

return ret;
}

The above function is used to initialize the mt7621_nfc subsystem. It first allocates memory for an struct mt7621_nfc object, initialized the nand_controller object and sets up mt7621_nfc_




NEXT




<s> static int b53_mdio_phy_read16(struct b53_device *dev, int addr, u8 reg,
u16 *value)
{
struct mii_bus *bus = dev->priv;

*value = mdiobus_read(bus, addr, reg);

return 0;
}

The above function is used to read register data from device driver. This function is used in phy_gmac.c (driver for mv6443) file. The above function is invoked to read the data in ethtool_gmii(phy




NEXT




<s> swlib_free_all(struct switch_dev *dev)
{
struct switch_dev *p;

while (dev) {
p = dev->next;
swlib_free(dev);
dev = p;
}
}

The above function is used to free the allocated memory of a switch device.

The call to swlib_free also frees a switch’s physical and virtual interfaces
along with the various resources associated with it.

It is possible to destroy a switch




NEXT




<s> int bbt_nand_copy(u16 dest_blk, u16 src_blk, loff_t max_offset)
{
int pages = bmtd.blk_size >> bmtd.pg_shift;
loff_t src = (loff_t)src_blk << bmtd.blk_shift;
loff_t dest = (loff_t)dest_blk << bmtd.blk_shift;
loff_t offset = 0;
uint8_t oob[64];
int i, ret;

for (i = 0; i < pages; i++) {
struct mtd_oob_ops rd_ops = {
.mode = MTD_OPS_PLACE_OOB,
.oobbuf = oob,
.ooblen = min_t(int, bmtd.mtd->oobsize / pages, sizeof(oob)),
.datbuf = bmtd.data_buf,
.len = bmtd.pg_size,
};
struct mtd_oob_ops wr_ops = {
.mode = MTD_OPS_PLACE_OOB,
.oobbuf = oob,
.datbuf = bmtd.data_buf,
.len = bmtd.pg_size,
};

if (offset >= max_offset)
break;

ret = bmtd._read_oob(bmtd.mtd, src + offset, &rd_ops);
if (ret < 0 && !mtd_is_bitflip(ret))
return ret;

if (!rd_ops.retlen)
break;

ret = bmtd._write_oob(bmtd.mtd, dest + offset, &wr_ops);
if (ret < 0)
return ret;

wr_ops.ooblen = rd_ops.oobretlen;
offset += rd_ops.retlen;
}

return 0;
}

The above function is used to write/copy the data from src_blk to the dest_blk.</s>




NEXT




<s> static void rtl83xx_init_stats(struct rtl838x_switch_priv *priv)
{
mutex_lock(&priv->reg_mutex);

/* Enable statistics module: all counters plus debug.
* On RTL839x all counters are enabled by default
*/
if (priv->family_id == RTL8380_FAMILY_ID)
sw_w32_mask(0, 3, RTL838X_STAT_CTRL);

/* Reset statistics counters */
sw_w32_mask(0, 1, priv->r->stat_rst);

mutex_unlock(&priv->reg_mutex);
}

The above function is used to initialize the statistics module. As mentioned at the start of this article, RTL83xx is built as a modular design supporting both RTL8380/8390. When the user doesn't enable statistics module,




NEXT




<s> ret_t rtl8367c_getAsicSdsReg(rtk_uint32 sdsId, rtk_uint32 sdsReg, rtk_uint32 sdsPage, rtk_uint32 *value)
{
rtk_uint32 retVal, busy;

if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (sdsPage<<5) | sdsReg)) != RT_ERR_OK)
return retVal;

if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x0080|sdsId)) != RT_ERR_OK)
return retVal;

while(1)
{
if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_SDS_INDACS_CMD, &busy))!=RT_ERR_OK)
return retVal;

if ((busy & 0x100) == 0)
break;
}

if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_SDS_INDACS_DATA, value))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read SDS Data by the following steps：
    1. Write the register RTL8367C_REG_SDS_INDACS_ADR as 'AsicPage.AsicReg,SDS page'. As




NEXT




<s> static void rtl83xx_setup_l2_uc_entry(struct rtl838x_l2_entry *e, int port, int vid, u64 mac)
{
memset(e, 0, sizeof(*e));

e->type = L2_UNICAST;
e->valid = true;

e->age = 3;
e->is_static = true;

e->port = port;

e->rvid = e->vid = vid;
e->is_ip_mc = e->is_ipv6_mc = false;
u64_to_ether_addr(mac, e->mac);
}

The above function is used to add an L2 entry, with port as destination MAC port index.

But the table doesn't tell us in which port is the packet's src MAC address?</s>




NEXT




<s> static void rtl839x_read_scheduling_table(int port)
{
u32 cmd = 1 << 9 | /* Execute cmd */
0 << 8 | /* Read */
0 << 6 | /* Table type 0b00 */
(port & 0x3f);
rtl839x_exec_tbl2_cmd(cmd);
}

The above function is used to read the port scheduling table. It works well in rtl839x_port_mode.
The function is not used in rtl839x_vlan_mode. When rtl839x_v




NEXT




<s> ret_t rtl8367c_getAsicAclVidRange(rtk_uint32 index, rtk_uint32* pType, rtk_uint32* pUpperVid, rtk_uint32* pLowerVid)
{
ret_t retVal;
rtk_uint32 regData;

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_VID_RANGE_ENTRY0_CTRL1 + index*2, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pType = (regData & RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_TYPE_MASK) >> RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_TYPE_OFFSET;
*pUpperVid = regData & RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_HIGH_MASK;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_VID_RANGE_ENTRY0_CTRL0 + index*2, pLowerVid);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get ACL VID range.</s>




NEXT




<s> ar8xxx_sw_set_port_reset_mib(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
int port;
int ret;

if (!ar8xxx_has_mib_counters(priv))
return -EOPNOTSUPP;

port = val->port_vlan;
if (port >= dev->ports)
return -EINVAL;

mutex_lock(&priv->mib_lock);
ret = ar8xxx_mib_capture(priv);
if (ret)
goto unlock;

ar8xxx_mib_fetch_port_stat(priv, port, true);

ret = 0;

unlock:
mutex_unlock(&priv->mib_lock);
return ret;
}

The above function is used to set port flow control for a particular
port. The function basically just checks for the current port mode using
MII Register 2.4.1, (IEEE 802.3x flow control in Receive path) and




NEXT




<s> int rtl931x_write_phy(u32 port, u32 page, u32 reg, u32 val)
{
u32 v;
int err = 0;

val &= 0xffff;
if (port > 63 || page > 4095 || reg > 31)
return -ENOTSUPP;

mutex_lock(&smi_lock);
pr_debug("%s: writing to phy %d %d %d %d\n", __func__, port, page, reg, val);
/* Clear both port registers */
sw_w32(0, RTL931X_SMI_INDRT_ACCESS_CTRL_2);
sw_w32(0, RTL931X_SMI_INDRT_ACCESS_CTRL_2 + 4);
sw_w32_mask(0, BIT(port % 32), RTL931X_SMI_INDRT_ACCESS_CTRL_2 + (port / 32) * 4);

sw_w32_mask(0xffff, val, RTL931X_SMI_INDRT_ACCESS_CTRL_3);

v = reg << 6 | page << 11 ;
sw_w32(v, RTL931X_SMI_INDRT_ACCESS_CTRL_0);

sw_w32(0x1ff, RTL931X_SMI_INDRT_ACCESS_CTRL_1);

v |= BIT(4) | 1; /* Write operation and execute */
sw_w32(v, RTL931X_SMI_INDRT_ACCESS_CTRL_0);

do {
} while (sw_r32(RTL931X_SMI_INDRT_ACCESS_CTRL_0) & 0x1);

if (sw_r32(RTL931X_SMI_INDRT_ACCESS_CTRL_0) & 0x2)
err = -EIO;

mutex_unlock(&smi_lock);

return err;
}

The above function is used to modify the 65536-byte registers on a chip. The RTL931x chip has 8 ports and 4096 32-bit registers per port. This is how the RTL93




NEXT




<s> static int psb6970_read_status(struct phy_device *phydev)
{
phydev->speed = SPEED_100;
phydev->duplex = DUPLEX_FULL;
phydev->link = 1;

phydev->state = PHY_RUNNING;
netif_carrier_on(phydev->attached_dev);
phydev->adjust_link(phydev->attached_dev);

return 0;
}

The above function is used to read the device’s status. Currently, we are
checking against a static state and returning.

As this device is not compliant to any common standard, we
are hardcoding the link state here to provide some link indication




NEXT




<s> ret_t rtl8367c_setAsicVlanEgressTagMode(rtk_uint32 port, rtl8367c_egtagmode tagMode)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(tagMode >= EG_TAG_MODE_END)
return RT_ERR_INPUT;

return rtl8367c_setAsicRegBits(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_VLAN_EGRESS_MDOE_MASK, tagMode);
}

The above function is used to set Vlan tagging egress mode of specific port.

If the interface port has Vlan tagging capability, user can set the following registers:

* Vlan tagging mode: for each egress port, the VTag




NEXT




<s> IFX_MEI_IoctlCopyTo (int from_kernel, char *dest, char *from, int size)
{
int ret = 0;

if (!from_kernel)
ret = copy_to_user ((char *) dest, (char *) from, size);
else
ret = (int)memcpy ((char *) dest, (char *) from, size);
return ret;
}

The above function is used to copy data in kernel buffer to userspace. If from_kernel is 1, then the copy is performed as plain memcpy call, if it is 0, then this involves a proper userspace data-copy.

Can you confirm that




NEXT




<s> ar8xxx_phy_mmd_prep(struct mii_bus *bus, int phy_addr, u16 addr, u16 reg)
{
bus->write(bus, phy_addr, MII_ATH_MMD_ADDR, addr);
bus->write(bus, phy_addr, MII_ATH_MMD_DATA, reg);
bus->write(bus, phy_addr, MII_ATH_MMD_ADDR, addr | 0x4000);
}

The above function is used to prepare the MMD for an 8xxx PHY.

It was used to get MAC addresses from 8.10

```
// MACaddr from P9X79-E
static void get_macaddr




NEXT




<s> static int rtl8367_sw_get_port_link(struct switch_dev *dev,
int port,
struct switch_port_link *link)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data = 0;
u32 speed;

if (port >= RTL8367_NUM_PORTS)
return -EINVAL;

rtl8366_smi_read_reg(smi, RTL8367_PORT_STATUS_REG(port), &data);

link->link = !!(data & RTL8367_PORT_STATUS_LINK);
if (!link->link)
return 0;

link->duplex = !!(data & RTL8367_PORT_STATUS_DUPLEX);
link->rx_flow = !!(data & RTL8367_PORT_STATUS_RXPAUSE);
link->tx_flow = !!(data & RTL8367_PORT_STATUS_TXPAUSE);
link->aneg = !!(data & RTL8367_PORT_STATUS_NWAY);

speed = (data & RTL8367_PORT_STATUS_SPEED_MASK);
switch (speed) {
case 0:
link->speed = SWITCH_PORT_SPEED_10;
break;
case 1:
link->speed = SWITCH_PORT_SPEED_100;
break;
case 2:
link->speed = SWITCH_PORT_SPEED_1000;
break;
default:
link->speed = SWITCH_PORT_SPEED_UNKNOWN;
break;
}

return 0;
}

The above function is used to query the Ethernet link status. The switch_port_link data structure is used to describe the status of the physical link of an interface, and in particular, contains the following information:

link – Boolean, whether there is a link




NEXT




<s> ret_t rtl8367c_setAsicIGMPTableFullOP(rtk_uint32 operation)
{
ret_t  retVal;

if(operation >= TABLE_FULL_OP_END)
return RT_ERR_OUT_OF_RANGE;

/* Table full Operation */
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG1, RTL8367C_TABLE_FULL_OP_MASK, operation);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to change the full operation for a specified group entry as follows :

/* change full op. to 1-to-1 if table is full */
retVal = rtl8367c_setAsicIGMPTableFull




NEXT




<s> mtd_unlock(const char *mtd)
{
struct erase_info_user mtdLockInfo;
char *next = NULL;
char *str = NULL;
int fd;

if (strchr(mtd, ':')) {
str = strdup(mtd);
mtd = str;
}

do {
next = strchr(mtd, ':');
if (next) {
*next = 0;
next++;
}

fd = mtd_check_open(mtd);
if(fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd);
exit(1);
}

if (quiet < 2)
fprintf(stderr, "Unlocking %s ...\n", mtd);

mtdLockInfo.start = 0;
mtdLockInfo.length = mtdsize;
ioctl(fd, MEMUNLOCK, &mtdLockInfo);
close(fd);
mtd = next;
} while (next);

if (str)
free(str);

return 0;
}

The above function is used to unlock a MTD partition.</s>




NEXT




<s> static int rtl8366_smi_write_byte_noack(struct rtl8366_smi *smi, u8 data)
{
rtl8366_smi_write_bits(smi, data, 8);
return 0;
}

The above function is used to write an 8-bit data through SMI interface, and it writes 8-bits of data data through SMI interface, at a time.

static int rtl8366_smi_write_word_no




NEXT




<s> void rtl839x_print_matrix(void)
{
volatile u64 *ptr9;

ptr9 = RTL838X_SW_BASE + RTL839X_PORT_ISO_CTRL(0);
for (int i = 0; i < 52; i += 4)
pr_debug("> %16llx %16llx %16llx %16llx\n",
ptr9[i + 0], ptr9[i + 1], ptr9[i + 2], ptr9[i + 3]);
pr_debug("CPU_PORT> %16llx\n", ptr9[52]);
}

The above function is used to read the 54527 port matrix registers, the port matrix registers of RTL8390 can be read by reading the address RTL838X_PORT_ISO_CTRL(0) and 52 of




NEXT




<s> ret_t rtl8367c_getAsicRmaCdp(rtl8367c_rma_t* pRmacfg)
{
ret_t retVal;
rtk_uint32 regData;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_RMA_CTRL_CDP, &regData);
if(retVal != RT_ERR_OK)
return retVal;

pRmacfg->operation = ((regData >> 7) & 0x0003);
pRmacfg->discard_storm_filter = ((regData >> 6) & 0x0001);
pRmacfg->trap_priority = ((regData >> 3) & 0x0007);
pRmacfg->keep_format = ((regData >> 2) & 0x0001);
pRmacfg->vlan_leaky = ((regData >> 1) & 0x0001);
pRmacfg->portiso_leaky = (regData & 0x0001);

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, &regData);
if(retVal != RT_ERR_OK)
return retVal;

pRmacfg->trap_priority = regData;

return RT_ERR_OK;
}

The above function is used to get the configuration of rma CDR module from hardware registers

It is used on a code that I found for my current project

How does it go?

```
 rmaCfg->portiso_leaky    =




NEXT




<s> static int rtl83xx_port_fdb_del(struct dsa_switch *ds, int port,
const unsigned char *addr, u16 vid)
{
struct rtl838x_switch_priv *priv = ds->priv;
u64 mac = ether_addr_to_u64(addr);
struct rtl838x_l2_entry e;
int err = 0, idx;
u64 seed = priv->r->l2_hash_seed(mac, vid);

pr_debug("In %s, mac %llx, vid: %d\n", __func__, mac, vid);
mutex_lock(&priv->reg_mutex);

idx = rtl83xx_find_l2_hash_entry(priv, seed, true, &e);

if (idx >= 0) {
pr_debug("Found entry index %d, key %d and bucket %d\n", idx, idx >> 2, idx & 3);
e.valid = false;
priv->r->write_l2_entry_using_hash(idx >> 2, idx & 0x3, &e);
goto out;
}

/* Check CAM for spillover from hash buckets */
idx = rtl83xx_find_l2_cam_entry(priv, seed, true, &e);

if (idx >= 0) {
e.valid = false;
priv->r->write_cam(idx, &e);
goto out;
}
err = -ENOENT;

out:
mutex_unlock(&priv->reg_mutex);

return err;
}

The above function is used to remove MM entry.

The below function is used to insert entry to the FW.

static int rtl83xx_port_fdb_add(struct dsa_switch *ds, int port,
const




NEXT




<s> ret_t rtl8367c_setAsicRldpMagicNum(ether_addr_t seed)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint16 *accessPtr;
rtk_uint32 i;

accessPtr = (rtk_uint16*)&seed;

for (i = 0; i < 3; i++)
{
regData = *accessPtr;
retVal = rtl8367c_setAsicReg(RTL8367C_RLDP_MAGIC_NUM_REG_BASE + i, regData);
if(retVal != RT_ERR_OK)
return retVal;

accessPtr++;
}

return retVal;
}

The above function is used to set the magic number. If i change the default magic to 0x3333 to 0x333 (like the one in switch_init_config.h), does this work? Thanks.</s>




NEXT




<s> static unsigned char *ag71xx_speed_str(struct ag71xx *ag)
{
switch (ag->speed) {
case SPEED_1000:
return "1000";
case SPEED_100:
return "100";
case SPEED_10:
return "10";
}

return "?";
}

The above function is used to return a string representing current Ethernet
connection speed.</s>




NEXT




<s> static int bcm6348_pci_read(struct pci_bus *bus, unsigned int devfn,
int where, int size, u32 *val)
{
int type;

type = bus->parent ? 1 : 0;

if (type == 0 && PCI_SLOT(devfn) == CARDBUS_PCI_IDSEL)
return PCIBIOS_DEVICE_NOT_FOUND;

return bcm6348_do_cfg_read(type, bus->number, devfn,
where, size, val);
}

The above function is used to read the memory of the pci card and it works fine when there is no such card. But when I insert the pci card, the kernel panics. But when I remove the pci card, the kernel continues to work fine and the pc can only




NEXT




<s> static void en7523_pci_unprepare(struct clk_hw *hw)
{
struct en_clk_gate *cg = container_of(hw, struct en_clk_gate, hw);
void __iomem *np_base = cg->base;
u32 val;

val = readl(np_base + REG_PCI_CONTROL);
val &= ~REG_PCI_CONTROL_REFCLK_EN1;
writel(val, np_base + REG_PCI_CONTROL);
}

The above function is used to prepare the PCIs's clock before disable it.

The bug is found in a specific use case, and can not be reproduce at
least so far.

If CONFIG_PCI_EN_CLK_MODE is set to




NEXT




<s> ret_t rtl8367c_setAsicPortUnknownSaBehavior(rtk_uint32 behavior)
{
if(behavior >= L2_BEHAVE_SA_END)
return RT_ERR_NOT_ALLOWED;

return rtl8367c_setAsicRegBits(RTL8367C_PORT_SECURIT_CTRL_REG, RTL8367C_UNKNOWN_SA_BEHAVE_MASK, behavior);
}

The above function is used to set unknown SA behavior to:

PORT_SECURITY_BEHAVIOR_DENY
PORT_SECURITY_BEHAVIOR_ACCEPT
PORT_SECURITY_BEHAVIOR




NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_field_sel_set(rtk_uint32 index, rtk_field_sel_t format, rtk_uint32 offset)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(index >= RTL8367C_FIELDSEL_FORMAT_NUMBER)
return RT_ERR_OUT_OF_RANGE;

if(format >= FORMAT_END)
return RT_ERR_OUT_OF_RANGE;

if(offset > RTL8367C_FIELDSEL_MAX_OFFSET)
return RT_ERR_OUT_OF_RANGE;

if((ret = rtl8367c_setAsicFieldSelector(index, (rtk_uint32)format, offset)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to set the selection mode of a field in the ingress filtering ACL operation.

*   index
    The ID of the field used.
    Supported range: [0-3]
*   format
    The selection




NEXT




<s> void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
void yy_delete_buffer ( YY_BUFFER_STATE b  );
void yy_flush_buffer ( YY_BUFFER_STATE b  );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to create a new buffer and returns a pointer to it. If the new buffer is a duplicate of another buffer a single reference count is increased for both new and old. The only place where this should be a problem is if we write through the duplicate buffer




NEXT




<s> mvswitch_probe(struct phy_device *pdev)
{
struct mvswitch_priv *priv;

priv = kzalloc(sizeof(struct mvswitch_priv), GFP_KERNEL);
if (priv == NULL)
return -ENOMEM;

pdev->priv = priv;

return 0;
}

The above function is used to request memory (via kzalloc) from the kernel for the device specific private data of the switch driver and also sets the link between the switch private data and the phy device data to a pointer reference to priv using the pdev->priv field




NEXT




<s> ret_t rtl8367c_setAsicQueueType(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 queueType)
{
ret_t retVal;

/* Invalid input parameter */
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;

/* Set Related Registers */
retVal = rtl8367c_setAsicRegBit(RTL8367C_SCHEDULE_QUEUE_TYPE_REG(port), RTL8367C_SCHEDULE_QUEUE_TYPE_OFFSET(port, qid),queueType);

return retVal;
}

The above function is used to set the queue type of an specific queue. But sometimes, what we need is to set queue type of a group of queues. For example, an interface's queues' traffic type are all set to be RX_QUEUE.




NEXT




<s> rtk_api_ret_t rtk_trap_unknownUnicastPktAction_get(rtk_port_t port, rtk_trap_ucast_action_t *pUcast_action)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if (NULL == pUcast_action)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortUnknownDaBehavior(rtk_switch_port_L2P_get(port), pUcast_action)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the unknown unicast packet actions in the hardware.

A unicast frame is an Ethernet frame addressed to a single destination host, as distinct from a broadcast frame or a multicast frame addressed to multiple hosts.





NEXT




<s> static void umt_txin_send(struct dc_ep_dev *dev,
u8 __iomem *soc_dbase, int num)
{
int i;
struct aca_dma_desc desc;

memset(&desc, 0, sizeof(desc));
desc.own = 0;
desc.sop = 1;
desc.eop = 1;
desc.dic = 1;
desc.pdu_type = 1;
desc.data_len = 127;
desc.data_pointer = 0x26000000;
desc.dw1 = 0x700;
desc.dw0 = 0x0000007f;

for (i = 0; i < num; i++) {
desc.data_pointer += roundup(desc.data_len, 4);
ep_mem_write(soc_dbase + i * sizeof(desc),
(void *)&desc, sizeof(desc));
}

ep_wr32(num, TXIN_HD_ACCUM_ADD);
}

The above function is used to send a short, data-less Tx request frame, to a port using ep_mem*() API. ep_mem_write writes its data to a host memory that acts as the physical address space of an EPDMA transaction memory.




NEXT




<s> static void b53_phy_remove(struct phy_device *phydev)
{
struct b53_device *priv = phydev->priv;

if (!priv)
return;

b53_switch_remove(priv);

phydev->priv = NULL;
}

The above function is used to inform the phy driver that a device node corresponding to the phy is to be removed from the system. We are doing two things here.

First is that the phy-related hardware operations will be unregistered.

The




NEXT




<s> static void sym_validate_range(struct symbol *sym)
{
struct property *prop;
int base;
long long val, val2;
char str[64];

switch (sym->type) {
case S_INT:
base = 10;
break;
case S_HEX:
base = 16;
break;
default:
return;
}
prop = sym_get_range_prop(sym);
if (!prop)
return;
val = strtoll(sym->curr.val, NULL, base);
val2 = sym_get_range_val(prop->expr->left.sym, base);
if (val >= val2) {
val2 = sym_get_range_val(prop->expr->right.sym, base);
if (val <= val2)
return;
}
if (sym->type == S_INT)
sprintf(str, "%lld", val2);
else
sprintf(str, "0x%llx", val2);
sym->curr.val = xstrdup(str);
}

The above function is used to convert a hex string into integer.

Here are the steps we need to take when converting a hex string into an integer

1. We check if the string is hexadecimal by reading the char and validating if it'




NEXT




<s> static void rtl83xx_get_ethtool_stats(struct dsa_switch *ds, int port,
uint64_t *data)
{
struct rtl838x_switch_priv *priv = ds->priv;
const struct rtl83xx_mib_desc *mib;
u64 h;

for (int i = 0; i < ARRAY_SIZE(rtl83xx_mib); i++) {
mib = &rtl83xx_mib[i];

data[i] = sw_r32(priv->r->stat_port_std_mib + (port << 8) + 252 - mib->offset);
if (mib->size == 2) {
h = sw_r32(priv->r->stat_port_std_mib + (port << 8) + 248 - mib->offset);
data[i] |= h << 32;
}
}
}

The above function is used to get Ethernet statistics from the chip.
The values from the chip are used as the output for the getethtoolstats
command in the OCL.

The above code assumes that the chip provides 64-bit values




NEXT




<s> static void qca807x_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)
{
struct qca807x_gpio_priv *priv = gpiochip_get_data(gc);
int val;

val = phy_read_mmd(priv->phy, MDIO_MMD_AN, qca807x_gpio_get_reg(offset));
val &= ~QCA807X_GPIO_FORCE_MODE_MASK;
val |= QCA807X_GPIO_FORCE_EN;
val |= FIELD_PREP(QCA807X_GPIO_FORCE_MODE_MASK, value);

phy_write_mmd(priv->phy, MDIO_MMD_AN, qca807x_gpio_get_reg(offset), val);
}

The above function is used to set a GPIO to force mode i.e. 1 or 0. The function also has the following function call.

phy_write_mmd(priv->phy, MDIO_MMD_AN, qca80




NEXT




<s> rtk_api_ret_t rtk_stat_lengthMode_set(rtk_stat_lengthMode_t txMode, rtk_stat_lengthMode_t rxMode)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(txMode >= LENGTH_MODE_END)
return RT_ERR_INPUT;

if(rxMode >= LENGTH_MODE_END)
return RT_ERR_INPUT;

if((retVal = rtl8367c_setAsicMIBsLength((rtk_uint32)txMode, (rtk_uint32)rxMode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the length mode for statistics which is in asic chip:
enum
{
    LENGTH_MODE_1051_7B=0, /* 64 B 102.4 Mbps and




NEXT




<s> static inline void icu_enable_intr(struct dc_ep_dev *dev, u32 bits)
{
if (WARN_ON(!dev))
return;
if (WARN_ON(!dev->priv))
return;

dc_ep_icu_en_intr(dev->priv, bits);
}

The above function is used to enable interrupts of an Intel CPU in GSI mode.
The function takes a struct dc_ep_dev pointer and an u32 value to enable specific GSI interrupts. The code first checks if the dev and dev->priv po




NEXT




<s> rtl_set(struct switch_dev *dev, enum rtl_regidx s, unsigned int val)
{
const struct rtl_reg *r = &rtl_regs[s];
u16 mask = 0xffff;

BUG_ON(s >= ARRAY_SIZE(rtl_regs));

if (r->bits == 0) /* unimplemented */
return 0;

if (r->shift > 0)
val <<= r->shift;

if (r->inverted)
val = ~val;

if (r->bits != 16) {
mask = (1 << r->bits) - 1;
mask <<= r->shift;
}
val &= mask;
return rtl_rmw(dev, r->page, r->phy, r->reg, mask, val);
}

The above function is used to write (set) a register: by default, the mask is always full (i.e. 16 bits) and thus the value is ANDed with zero and ORed with the value read from the register. There is one caveat




NEXT




<s> void *xcalloc(size_t nmemb, size_t size)
{
void *p = calloc(nmemb, size);
if (p)
return p;
fprintf(stderr, "Out of memory.\n");
exit(1);
}

The above function is used to allocate memory and when calloc fails, it exits the program with a message.

#pragma GCC diagnostic error
#pragma GCC diagno

The following error and warning flags can be set up using a pragma declaration




NEXT




<s> static int ltq_ptm_remove(struct platform_device *pdev)
{
int i;
ifx_mei_atm_showtime_enter = NULL;
ifx_mei_atm_showtime_exit  = NULL;


ifx_pp32_stop(0);

free_irq(PPE_MAILBOX_IGU1_INT, &g_ptm_priv_data);

for ( i = 0; i < ARRAY_SIZE(g_net_dev); i++ )
unregister_netdev(g_net_dev[i]);

for ( i = 0; i < ARRAY_SIZE(g_net_dev); i++ ) {
free_netdev(g_net_dev[i]);
g_net_dev[i] = NULL;
}

clear_tables();

ifx_ptm_uninit_chip();

clear_priv_data();

return 0;
}

The above function is used to de-initialize the device. The device is de-initialized upon removing or unregistering the driver, but this function could be used for de-initialization of various other scenarios (such as device re-initialization, etc) as well.




NEXT




<s> static unsigned char *fe_speed_str(int speed)
{
switch (speed) {
case 2:
case SPEED_1000:
return "1000";
case 1:
case SPEED_100:
return "100";
case 0:
case SPEED_10:
return "10";
}

return "? ";
}

The above function is used to print bandwidth value in megatbit per second.

int main()
{

unsigned char *speed_str = fe_speed_str(100);

printf("The speed_str value is %s\




NEXT




<s> static int esw_get_alt_vlan_disable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

val->value.i = esw->alt_vlan_disable;

return 0;
}

The above function is used to get the value of alt_vlan_disable.

/* ------------- switch config API ------------- */
static int esw_switch_config(struct switch_dev *dev,
const struct switch_config *config)
{




NEXT




<s> rtk_api_ret_t rtk_trap_rmaAction_set(rtk_trap_type_t type, rtk_trap_rma_action_t rma_action)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;
rtk_uint32 tmp;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= TRAP_END)
return RT_ERR_INPUT;

if (rma_action >= RMA_ACTION_END)
return RT_ERR_RMA_ACTION;

if (type >= 0 && type <= TRAP_UNDEF_GARP_2F)
{
if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.operation = rma_action;

if ((retVal = rtl8367c_setAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (type == TRAP_CDP)
{
if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.operation = rma_action;

if ((retVal = rtl8367c_setAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (type  == TRAP_CSSTP)
{
if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.operation = rma_action;

if ((retVal = rtl8367c_setAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;
}
else if (type  == TRAP_LLDP)
{
if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
return retVal;

rmacfg.operation = rma_action;

if ((retVal = rtl8367c_setAsicRmaLldp(tmp, &rmacfg)) != RT_ERR_OK)
return retVal;
}
else
return RT_ERR_INPUT;

return RT_ERR_OK;
}

The above function is used to set Action in RMA. This API returns OK(=0) for success, and other value as failure.

The above function takes the following parameters:

type : It is the type of RMA to configure. It can have




NEXT




<s> static int rtl8367_reset_chip(struct rtl8366_smi *smi)
{
int timeout = 10;
int err;
u32 data;

REG_WR(smi, RTL8367_CHIP_RESET_REG, RTL8367_CHIP_RESET_HW);
msleep(RTL8367_RESET_DELAY);

do {
REG_RD(smi, RTL8367_CHIP_RESET_REG, &data);
if (!(data & RTL8367_CHIP_RESET_HW))
break;

msleep(1);
} while (--timeout);

if (!timeout) {
dev_err(smi->parent, "chip reset timed out\n");
return -ETIMEDOUT;
}

return 0;
}

The above function is used to reset the chip. You can see that the function will reset the chip (i.e. put the chip in reset mode) and then wait for a certain amount of seconds until the chip exit from the reset mode. (In our device we used




NEXT




<s> static u8 ar934x_nfc_read_byte(struct nand_chip *chip)
{
struct ar934x_nfc *nfc = chip->priv;
u8 data;

WARN_ON(nfc->buf_index >= nfc->buf_size);

if (nfc->swap_dma || nfc->read_id)
data = nfc->buf[nfc->buf_index ^ 3];
else
data = nfc->buf[nfc->buf_index];

nfc->buf_index++;

return data;
}

The above function is used to read a byte from nfc->buf array . In case of single buffered mode it reads the data from nfc->buf[] directly.

In case of dual buffered mode it reads from the selected nfc->buf[] (the




NEXT




<s> ret_t rtl8367c_getAsicVlanPortBasedVID(rtk_uint32 port, rtk_uint32 *pIndex, rtk_uint32 *pPri)
{
rtk_uint32 regAddr,bit_mask;
ret_t  retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

regAddr = RTL8367C_VLAN_PVID_CTRL_REG(port);
bit_mask = RTL8367C_PORT_VIDX_MASK(port);
retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, pIndex);
if(retVal != RT_ERR_OK)
return retVal;

regAddr = RTL8367C_VLAN_PORTBASED_PRIORITY_REG(port);
bit_mask = RTL8367C_VLAN_PORTBASED_PRIORITY_MASK(port);
retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, pPri);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the VID value for the specified port of Asic.

The function return RT_ERR_OK if the value for VID is got successfully or the return value RT_ERR_NONE_FOUND if the VID is not




NEXT




<s> handle_get_prime(struct ead_packet *pkt, int len, int *nstate)
{
struct ead_msg *msg = &pktbuf->msg;
struct ead_msg_salt *salt = EAD_DATA(msg, salt);

msg->len = htonl(sizeof(struct ead_msg_salt));
salt->prime = tce->index - 1;
salt->len = ts->s.len;
memcpy(salt->salt, ts->s.data, ts->s.len);
memcpy(salt->ext_salt, pw_saltbuf, MAXSALTLEN);

*nstate = EAD_TYPE_SEND_A;
return true;
}

The above function is used to pack up the data structures that will comprise the packet that's being sent back to the client... the prime number used and the salt (more info on that here).

However, you'll notice the first two assignments of prime and




NEXT




<s> ret_t rtl8367c_setAsicRldpCompareRandomNumber(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_COMP_ID_OFFSET, enabled);
}

The above function is used to enable/disable Compare ID function. A random number is generated from RNG to compare with user setting to prevent hacking.

The command can be set via “set rldp asic compare-random-number” interface under C




NEXT




<s> static inline void reset_assert_device(struct dc_ep_dev *dev, u32 bits)
{
if (WARN_ON(!dev))
return;
if (WARN_ON(!dev->priv))
return;

dc_ep_assert_device(dev->priv, bits);
}

The above function is used to reset the device and is implemented in the
assert_device_impl() function.

To reset the device, we first reset the clock (using clk_disable(), which
is implemented by dc_host_clock_disable()). Then,




NEXT




<s> unsigned char ide_inb(int device, int port)
{
unsigned char val = 0;

/* Only permit accesses to disks found to be present during ide_preinit() */
if (!disk_present[device]) {
return ATA_STAT_FAULT;
}

device_select(device);

switch (port) {
case ATA_PORT_CTL:
val = (*(sata_regs_base[device] + SATA_ORB4_OFF)
& (0xFFUL << SATA_CTL_BIT)) >> SATA_CTL_BIT;
break;
case ATA_PORT_FEATURE:
val = (*(sata_regs_base[device] + SATA_ORB2_OFF)
& (0xFFUL << SATA_FEATURE_BIT)) >> SATA_FEATURE_BIT;
break;
case ATA_PORT_NSECT:
val = (*(sata_regs_base[device] + SATA_ORB2_OFF)
& (0xFFUL << SATA_NSECT_BIT)) >> SATA_NSECT_BIT;
break;
case ATA_PORT_LBAL:
val = (*(sata_regs_base[device] + SATA_ORB3_OFF)
& (0xFFUL << SATA_LBAL_BIT)) >> SATA_LBAL_BIT;
break;
case ATA_PORT_LBAM:
val = (*(sata_regs_base[device] + SATA_ORB3_OFF)
& (0xFFUL << SATA_LBAM_BIT)) >> SATA_LBAM_BIT;
break;
case ATA_PORT_LBAH:
val = (*(sata_regs_base[device] + SATA_ORB3_OFF)
& (0xFFUL << SATA_LBAH_BIT)) >> SATA_LBAH_BIT;
break;
case ATA_PORT_DEVICE:
val = (*(sata_regs_base[device] + SATA_ORB3_OFF)
& (0xFFUL << SATA_HOB_LBAH_BIT)) >> SATA_HOB_LBAH_BIT;
val |= (*(sata_regs_base[device] + SATA_ORB1_OFF)
& (0xFFUL << SATA_DEVICE_BIT)) >> SATA_DEVICE_BIT;
break;
case ATA_PORT_COMMAND:
val = (*(sata_regs_base[device] + SATA_ORB2_OFF)
& (0xFFUL << SATA_COMMAND_BIT)) >> SATA_COMMAND_BIT;
val |= ATA_STAT_DRQ;
break;
default:
printf("ide_inb() Unknown port = %d\n", port);
break;
}

//    printf("inb: %d:%01x => %02x\n", device, port, val);

return val;
}

The above function is used to read data from the SATA interface during the BIOS_Setup (EFI) code.

Here's the SATA part.
1. Set CTRL port to 1.

2.

(unsigned




NEXT




<s> static void rtl838x_set_static_move_action(int port, bool forward)
{
int shift = MV_ACT_PORT_SHIFT(port);
u32 val = forward ? MV_ACT_FORWARD : MV_ACT_DROP;

sw_w32_mask(MV_ACT_MASK << shift, val << shift,
RTL838X_L2_PORT_STATIC_MV_ACT(port));
}

The above function is used to set static port ACL move actions, where “port” is the
port index (0, 1, 2 or 3) and “forward” indicates whether this is to be used for static-
forwarding. The following is




NEXT




<s> rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_add(rtk_port_t port, rtk_vlan_protoAndPortInfo_t *pInfo)
{
rtk_api_ret_t retVal, i;
rtk_uint32 exist, empty, used, index;
rtl8367c_protocolgdatacfg ppb_data_cfg;
rtl8367c_protocolvlancfg ppb_vlan_cfg;
rtl8367c_provlan_frametype tmp;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pInfo)
return RT_ERR_NULL_POINTER;

if (pInfo->proto_type > RTK_MAX_NUM_OF_PROTO_TYPE)
return RT_ERR_OUT_OF_RANGE;

if (pInfo->frame_type >= FRAME_TYPE_END)
return RT_ERR_OUT_OF_RANGE;

if (pInfo->cvid > RTL8367C_VIDMAX)
return RT_ERR_VLAN_VID;

if (pInfo->cpri > RTL8367C_PRIMAX)
return RT_ERR_VLAN_PRIORITY;

exist = 0xFF;
empty = 0xFF;
for (i = RTL8367C_PROTOVLAN_GIDX_MAX; i >= 0; i--)
{
if ((retVal = rtl8367c_getAsicVlanProtocolBasedGroupData(i, &ppb_data_cfg)) != RT_ERR_OK)
return retVal;
tmp = pInfo->frame_type;
if (ppb_data_cfg.etherType == pInfo->proto_type && ppb_data_cfg.frameType == tmp)
{
/*Already exist*/
exist = i;
break;
}
else if (ppb_data_cfg.etherType == 0 && ppb_data_cfg.frameType == 0)
{
/*find empty index*/
empty = i;
}
}

used = 0xFF;
/*No empty and exist index*/
if (0xFF == exist && 0xFF == empty)
return RT_ERR_TBL_FULL;
else if (exist<RTL8367C_PROTOVLAN_GROUPNO)
{
/*exist index*/
used = exist;
}
else if (empty<RTL8367C_PROTOVLAN_GROUPNO)
{
/*No exist index, but have empty index*/
ppb_data_cfg.frameType = pInfo->frame_type;
ppb_data_cfg.etherType = pInfo->proto_type;
if ((retVal = rtl8367c_setAsicVlanProtocolBasedGroupData(empty, &ppb_data_cfg)) != RT_ERR_OK)
return retVal;
used = empty;
}
else
return RT_ERR_FAILED;

if((retVal = rtk_vlan_checkAndCreateMbr(pInfo->cvid, &index)) != RT_ERR_OK)
return retVal;

ppb_vlan_cfg.vlan_idx = index;
ppb_vlan_cfg.valid = TRUE;
ppb_vlan_cfg.priority = pInfo->cpri;
if ((retVal = rtl8367c_setAsicVlanPortAndProtocolBased(rtk_switch_port_L2P_get(port), used, &ppb_vlan_cfg)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to add portAndProtocolBased vlan for each port.
For example: add portAndProtocolBased vlan for all ports in port group 0.

#include <stdio.h>
#include <stdlib.h>




NEXT




<s> rtk_api_ret_t rtk_trap_reasonTrapToCpuPriority_get(rtk_trap_reason_type_t type, rtk_pri_t *pPriority)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= TRAP_REASON_END)
return RT_ERR_INPUT;

if(NULL == pPriority)
return RT_ERR_NULL_POINTER;

switch (type)
{
case TRAP_REASON_RMA:
if ((retVal = rtl8367c_getAsicRma(0, &rmacfg)) != RT_ERR_OK)
return retVal;
*pPriority = rmacfg.trap_priority;

break;
case TRAP_REASON_OAM:
if ((retVal = rtl8367c_getAsicOamCpuPri(pPriority)) != RT_ERR_OK)
return retVal;

break;
case TRAP_REASON_1XUNAUTH:
if ((retVal = rtl8367c_getAsic1xTrapPriority(pPriority)) != RT_ERR_OK)
return retVal;

break;
case TRAP_REASON_VLANSTACK:
if ((retVal = rtl8367c_getAsicSvlanTrapPriority(pPriority)) != RT_ERR_OK)
return retVal;

break;
case TRAP_REASON_UNKNOWNMC:
if ((retVal = rtl8367c_getAsicUnknownMulticastTrapPriority(pPriority)) != RT_ERR_OK)
return retVal;

break;
default:
return RT_ERR_CHIP_NOT_SUPPORTED;

}

return RT_ERR_OK;
}

The above function is used to retrieve the trap to CPU priority.

The parameter type defines the trap type. The possible values are defined by following enumeration.
| Type       | Meaning                        |
| ------------- | -----------------------------|
| TRAP




NEXT




<s> static void rtl838x_setup_ring_buffer(struct rtl838x_eth_priv *priv, struct ring_b *ring)
{
for (int i = 0; i < priv->rxrings; i++) {
struct p_hdr *h;
int j;

for (j = 0; j < priv->rxringlen; j++) {
h = &ring->rx_header[i][j];
memset(h, 0, sizeof(struct p_hdr));
h->buf = (u8 *)KSEG1ADDR(ring->rx_space +
i * priv->rxringlen * RING_BUFFER +
j * RING_BUFFER);
h->size = RING_BUFFER;
/* All rings owned by switch, last one wraps */
ring->rx_r[i][j] = KSEG1ADDR(h) | 1 | (j == (priv->rxringlen - 1) ?
WRAP :
0);
}
ring->c_rx[i] = 0;
}

for (int i = 0; i < TXRINGS; i++) {
struct p_hdr *h;
int j;

for (j = 0; j < TXRINGLEN; j++) {
h = &ring->tx_header[i][j];
memset(h, 0, sizeof(struct p_hdr));
h->buf = (u8 *)KSEG1ADDR(ring->tx_space +
i * TXRINGLEN * RING_BUFFER +
j * RING_BUFFER);
h->size = RING_BUFFER;
ring->tx_r[i][j] = KSEG1ADDR(&ring->tx_header[i][j]);
}
/* Last header is wrapping around */
ring->tx_r[i][j - 1] |= WRAP;
ring->c_tx[i] = 0;
}
}

The above function is used to setup ring buffers for transmission and reception of data by the rtl838x_eth.

The loop runs through 2 sets of rings depending upon whether a value of the integer variable i is odd or even. The first set is




NEXT




<s> uc_bpf_map_pin(uc_vm_t *vm, size_t nargs)
{
return uc_bpf_obj_pin(vm, nargs, "bpf.map");
}

The above function is used to attach a bpf map object to the uc virtual machine using the function pin. This function is used to retrieve the pointer to the map from the vm and store it in the global variable *map. The next function is the function unpin.




NEXT




<s> void rtk_hal_vlan_mode(struct ra_switch_ioctl_data *data)
{
rtk_vlan_cfg_t vlan1, vlan2;
rtk_api_ret_t ret;

ret = rtk_vlan_get(1, &vlan1);
if (ret != RT_ERR_OK)
printk("rtk_vlan_get failed\n");

ret = rtk_vlan_get(2, &vlan2);
if (ret != RT_ERR_OK)
printk("rtk_vlan_get failed\n");

if (data->mode == 0) { //ivl
vlan1.ivl_en = 1;
vlan1.fid_msti = 0;
rtk_vlan_set(1, &vlan1);
vlan2.ivl_en = 1;
vlan2.fid_msti = 0;
rtk_vlan_set(2, &vlan2);
} else if(data->mode == 1) {//svl
vlan1.ivl_en = 0;
vlan1.fid_msti = 0;
rtk_vlan_set(1, &vlan1);
vlan2.ivl_en = 0;
vlan2.fid_msti = 1;
rtk_vlan_set(2, &vlan2);
} else
printk("mode not supported\n");
}

The above function is used to control port VLAN. If you want to enable VLAN and put L2 forwarding, you need to control VLAN port by VLAN mode, the VLAN number corresponds to the port number. You can see rtk_api definition in




NEXT




<s> static struct symbol *sym_check_sym_deps(struct symbol *sym)
{
struct symbol *sym2;
struct property *prop;
struct dep_stack stack;

dep_stack_insert(&stack, sym);

stack.expr = &sym->dir_dep.expr;
sym2 = sym_check_expr_deps(sym->dir_dep.expr);
if (sym2)
goto out;

stack.expr = &sym->rev_dep.expr;
sym2 = sym_check_expr_deps(sym->rev_dep.expr);
if (sym2)
goto out;

stack.expr = &sym->implied.expr;
sym2 = sym_check_expr_deps(sym->implied.expr);
if (sym2)
goto out;

stack.expr = NULL;

for (prop = sym->prop; prop; prop = prop->next) {
if (prop->type == P_CHOICE || prop->type == P_SELECT ||
prop->type == P_IMPLY)
continue;
stack.prop = prop;
sym2 = sym_check_expr_deps(prop->visible.expr);
if (sym2)
break;
if (prop->type != P_DEFAULT || sym_is_choice(sym))
continue;
stack.expr = &prop->expr;
sym2 = sym_check_expr_deps(prop->expr);
if (sym2)
break;
stack.expr = NULL;
}

out:
dep_stack_remove();

return sym2;
}

The above function is used to make sure that if a symbol has any
property that may change its dependencies, the other properties that
also depend on it are considered too. This solves circular dependency
checking correctly

In case the target symbol has a property that has




NEXT




<s> ar8xxx_sw_set_reset_mibs(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
unsigned int len;
int ret;

if (!ar8xxx_has_mib_counters(priv))
return -EOPNOTSUPP;

mutex_lock(&priv->mib_lock);

len = priv->dev.ports * priv->chip->num_mibs *
sizeof(*priv->mib_stats);
memset(priv->mib_stats, '\0', len);
ret = ar8xxx_mib_flush(priv);
if (ret)
goto unlock;

ret = 0;

unlock:
mutex_unlock(&priv->mib_lock);
return ret;
}

The above function is used to copy the MIB stats from a
switch_dev to the internal mib_stats buffer of the ar8xxx_priv
data structure. Once this has been accomplished, it flushes the
registers by using the mib_flush




NEXT




<s> static int sha1_hmac_final(struct shash_desc *desc, u8 *out)
{
return sha1_hmac_final_impl(desc, out, true);
}

The above function is used to compute HMAC for both inner and outer digest. The outer HMAC digest is used to be included in the SHA1 block while inner digest is used as normal inner message digest.

HMAC function is based on the following equations –






NEXT




<s> rtk_api_ret_t rtk_stp_mstpState_get(rtk_stp_msti_id_t msti, rtk_port_t port, rtk_stp_state_t *pStp_state)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (msti > RTK_MAX_NUM_OF_MSTI)
return RT_ERR_MSTI;

if(NULL == pStp_state)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicSpanningTreeStatus(rtk_switch_port_L2P_get(port), msti, pStp_state)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to check whether MSTP feature is enabled.

rtk_api_ret_t rtk_stp_mstp_is_enable_get(void)
{
	return (rtk_mstp_




NEXT




<s> static inline void fe_int_disable(u32 mask)
{
fe_reg_w32(fe_reg_r32(FE_REG_FE_INT_ENABLE) & ~mask,
FE_REG_FE_INT_ENABLE);
/* flush write */
fe_reg_r32(FE_REG_FE_INT_ENABLE);
}

The above function is used to disable a few interrupts that are disabled at
bootup. The interrupts that are disabled here are:

FE_IRQ_SOFT_RESET                                  1
FE_IRQ_FE_FLOW_CONTROL_ERROR                




NEXT




<s> ret_t rtl8367c_getAsicPortMirrorIsolation(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_ISO_OFFSET, pEnabled);
}

The above function is used to check the mirror isolation.
Please refer to the above function to see how this function is used.

rtl8367c_setAsicPortMirrorIsolation(rtk_uint32 Enable)
//Parameters




NEXT




<s> ret_t rtl8367c_setAsicAclTemplate(rtk_uint32 index, rtl8367c_acltemplate_t* pAclType)
{
ret_t retVal;
rtk_uint32 i;
rtk_uint32 regAddr, regData;

if(index >= RTL8367C_ACLTEMPLATENO)
return RT_ERR_OUT_OF_RANGE;

regAddr = RTL8367C_ACL_RULE_TEMPLATE_CTRL_REG(index);

for(i = 0; i < (RTL8367C_ACLRULEFIELDNO/2); i++)
{
regData = pAclType->field[i*2+1];
regData = regData << 8 | pAclType->field[i*2];

retVal = rtl8367c_setAsicReg(regAddr + i, regData);

if(retVal != RT_ERR_OK)
return retVal;
}

return retVal;
}

The above function is used to copy the template to ACL rule memory. For a single MAC based ACL rule, we need 8 registers (15-22 in register index in Fig.1). Two 8-bit registers will be used to store one byte




NEXT




<s> static int fe_tx_dma_map_skb(struct fe_tx_ring *ring, struct fe_map_state *st,
struct sk_buff *skb)
{
struct page *page = virt_to_page(skb->data);
size_t offset = offset_in_page(skb->data);
size_t size = skb_headlen(skb);

return fe_tx_dma_map_page(ring, st, page, offset, size);
}

The above function is used to map a skb onto the ring, and this is called on
init of the skb. The same code path is also used when the ring is rebound
(moved from memory to ring).

The problem is that on ring init,




NEXT




<s> ret_t rtl8367c_getAsicGreenEthernet(rtk_uint32 port, rtk_uint32* green)
{
ret_t retVal;
rtk_uint32 regData;

/* 0xa436 = 0x8011 */
if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xA436, 0x8011)) != RT_ERR_OK)
return retVal;

/* wr 0xa438[15] = 0: disable, 1: enable */
if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xA438, &regData)) != RT_ERR_OK)
return retVal;

if(regData & 0x8000)
*green = ENABLED;
else
*green = DISABLED;

return RT_ERR_OK;
}

The above function is used to check status on AGE for all ports. I only need the 17th bit to determine if the the port is AGE enabled or disabled. Can I just check the AGE status for port 17 and then call this function with




NEXT




<s> static bool nmbm_rebuild_info_table(struct nmbm_instance *ni)
{
uint32_t table_start_ba, table_end_ba, next_start_ba;
uint32_t main_table_end_ba;
bool success;

/* Set initial value */
ni->main_table_ba = 0;
ni->backup_table_ba = 0;
ni->mapping_blocks_ba = ni->mapping_blocks_top_ba;

/* Write main table */
success = nmbm_write_info_table(ni, ni->mgmt_start_ba,
ni->mapping_blocks_top_ba,
&table_start_ba, &table_end_ba);
if (!success) {
/* Failed to write main table, data will be lost */
nlog_err(ni, "Unable to write at least one info table!\n");
nlog_err(ni, "Please save your data before power off!\n");
ni->protected = 1;
return false;
}

/* Main info table is successfully written, record its offset */
ni->main_table_ba = table_start_ba;
main_table_end_ba = table_end_ba;

/* Adjust mapping_blocks_ba */
ni->mapping_blocks_ba = table_end_ba;

nmbm_mark_tables_clean(ni);

nlog_table_creation(ni, true, table_start_ba, table_end_ba);

/* Reserve spare blocks for main info table. */
success = nmbm_try_reserve_blocks(ni, table_end_ba,
&next_start_ba,
ni->info_table_spare_blocks, 0,
ni->mapping_blocks_top_ba -
size2blk(ni, ni->info_table_size));
if (!success) {
/* There is no spare block. */
nlog_debug(ni, "No room for backup info table\n");
return true;
}

/* Write backup info table. */
success = nmbm_write_info_table(ni, next_start_ba,
ni->mapping_blocks_top_ba,
&table_start_ba, &table_end_ba);
if (!success) {
/* There is no enough blocks for backup table. */
nlog_debug(ni, "No room for backup info table\n");
return true;
}

/* Backup table is successfully written, record its offset */
ni->backup_table_ba = table_start_ba;

/* Adjust mapping_blocks_off */
ni->mapping_blocks_ba = table_end_ba;

/* Erase spare blocks of main table to clean possible interference data */
nmbm_erase_range(ni, main_table_end_ba, ni->backup_table_ba);

nlog_table_creation(ni, false, table_start_ba, table_end_ba);

return true;
}

The above function is used to build the main table and the backup table and record the corresponding information, including the offset of the main table, the offset of the backup table, the initial offset of saving blocks of the mapping table. The offset information after the block is obtained in the




NEXT




<s> IFX_MEI_LongWordRead (u32 ul_address, u32 * pul_data)
{
*pul_data = IFX_MEI_READ_REGISTER_L (ul_address);
rmb();
return;
}

The above function is used to read the long data from MEI register. It calls the following macro:

#define IFX_MEI_READ_REGISTER_L(register_address) ((*volatile u32 *)(MEI_BASE_




NEXT




<s> static int rtl838x_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
{
return rtl838x_mdio_read_paged(bus, mii_id, 0, regnum);
}

The above function is used to read a register stored at offset regnum, from
device specified by mii_id.

If you are still confused about the usage of these functions, here two
examples:
1.	Read the register at offset 0




NEXT




<s> static int rtl8366s_sw_set_green(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

return rtl8366s_set_green(smi, val->value.i);
}

The above function is used to enable/disable green packet support on per-queue basis.
The function call is triggered at smi level upon receiving command message that comes
from the switch side.

Note:
As default, green packet is enabled on all queues




NEXT




<s> static void ag71xx_bit_clear(void __iomem *reg, u32 bit)
{
u32 val;

val = __raw_readl(reg) & ~bit;
__raw_writel(val, reg);
__raw_readl(reg);
}

The above function is used to clear some bits in a register.
It is defined as
static void ag71xx_bit_clear(void __iomem *reg, u32 bit)

and is found to be called by
{
ag7




NEXT




<s> static int ip175d_set_vlan_mode(struct ip17xx_state *state);
static int ip175d_reset(struct ip17xx_state *state);

static const struct register_mappings IP175D = {
.NAME = "IP175D",
.MODEL_NO = 0x18,

// The IP175D has a completely different interface, so we leave most
// of the registers undefined and switch to different code paths.

.VLAN_DEFAULT_TAG_REG = {
NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,
NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,
},

.ADD_TAG_REG = NOTSUPPORTED,
.REMOVE_TAG_REG = NOTSUPPORTED,

.SIMPLE_VLAN_REGISTERS = 0,

.VLAN_LOOKUP_REG = NOTSUPPORTED,
.VLAN_LOOKUP_REG_5 = NOTSUPPORTED,
.TAG_VLAN_MASK_REG = NOTSUPPORTED,

.RESET_VAL = 0x175D,
.RESET_REG = {20,2},
.MODE_REG = NOTSUPPORTED,

.ROUTER_CONTROL_REG = NOTSUPPORTED,
.ROUTER_EN_BIT = -1,
.NUMLAN_GROUPS_BIT = -1,

.VLAN_CONTROL_REG = NOTSUPPORTED,
.TAG_VLAN_BIT = -1,

.NUM_PORTS = 6,
.CPU_PORT = 5,

.MII_REGISTER_EN = NOTSUPPORTED,

.update_state = ip175d_update_state,
.set_vlan_mode = ip175d_set_vlan_mode,
.reset = ip175d_reset,
};

The above function is used to set the IP175D to 0x175D (that is, the reset values).  This resets ALL functions of the IP175Ds.  (In the case that other values could be better,




NEXT




<s> static inline void set_htu_entry(unsigned int, unsigned int, unsigned int, int, int);
static inline void clear_htu_entry(unsigned int);
static void validate_oam_htu_entry(void);
static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to encapsulate the OAM packets generated
locally into the ATM cell's upper layer data.
#endif

/*
*  ATM Device Driver related function and structure definations
*/
struct ltq_at




NEXT




<s> int ecb_des_encrypt(struct skcipher_request *req)
{
struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int enc_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = enc_bytes = walk.nbytes)) {
enc_bytes -= (nbytes % DES_BLOCK_SIZE);
ifx_deu_des_ecb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
NULL, enc_bytes, CRYPTO_DIR_ENCRYPT, 0);
nbytes &= DES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

return err;
}

The above function is used to encrypt data.

int ecb_des_decrypt(struct skcipher_request *req)
{
struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(req->base




NEXT




<s> static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to enable queue gamma map in order to increase PQ performance.
queue_gamma_map_table is 4 bit, we use 0~2 bit to represent three queues, use 3 bit to represent one group.
0




NEXT




<s> WriteRegLong (u32 addr, u32 data)
{
//*((volatile u32 *)(addr)) =  data;
IFX_MEI_WRITE_REGISTER_L (data, addr);
}

The above function is used to set a value into a specified register. I want to know its difference with the below.
WriteRegLong (u32 addr, u32 data)
{
*((volatile u8 *)(addr)) =  data;




NEXT




<s> static inline u32 sata_oxnas_hostdmabusy(struct ata_port *ap)
{
struct sata_oxnas_port_priv *pd = ap->private_data;

return ioread32(pd->sgdma_base + SGDMA_STATUS) & SGDMA_BUSY;
}

The above function is used to determine whether the SGDMA is busy or not

static inline void sata_oxnas_hostdmastatus(struct ata_port *ap)
{
struct sata_oxnas_port_priv *pd =




NEXT




<s> static int ar934x_nfc_read_page(struct nand_chip *chip,
u8 *buf, int oob_required, int page)
{
struct ar934x_nfc *nfc = chip->priv;
struct mtd_info *mtd = ar934x_nfc_to_mtd(nfc);
u32 ecc_ctrl;
int max_bitflips = 0;
bool ecc_failed;
bool ecc_corrected;
int err;

nfc_dbg(nfc, "read_page: page:%d oob:%d\n", page, oob_required);

ar934x_nfc_enable_hwecc(nfc);
err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, 0, page,
mtd->writesize);
ar934x_nfc_disable_hwecc(nfc);

if (err)
return err;

/* TODO: optimize to avoid memcpy */
memcpy(buf, nfc->buf, mtd->writesize);

/* read the ECC status */
ecc_ctrl = ar934x_nfc_rr(nfc, AR934X_NFC_REG_ECC_CTRL);
ecc_failed = ecc_ctrl & AR934X_NFC_ECC_CTRL_ERR_UNCORRECT;
ecc_corrected = ecc_ctrl & AR934X_NFC_ECC_CTRL_ERR_CORRECT;

if (oob_required || ecc_failed) {
err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, mtd->writesize,
page, mtd->oobsize);
if (err)
return err;

if (oob_required)
memcpy(chip->oob_poi, nfc->buf, mtd->oobsize);
}

if (ecc_failed) {
/*
* The hardware ECC engine reports uncorrectable errors
* on empty pages. Check the ECC bytes and the data. If
* both contains 0xff bytes only, dont report a failure.
*
* TODO: prebuild a buffer with 0xff bytes and use memcmp
* for better performance?
*/
if (!is_all_ff(&nfc->buf[nfc->ecc_oob_pos], chip->ecc.total) ||
!is_all_ff(buf, mtd->writesize))
mtd->ecc_stats.failed++;
} else if (ecc_corrected) {
/*
* The hardware does not report the exact count of the
* corrected bitflips, use assumptions based on the
* threshold.
*/
if (ecc_ctrl & AR934X_NFC_ECC_CTRL_ERR_OVER) {
/*
* The number of corrected bitflips exceeds the
* threshold. Assume the maximum.
*/
max_bitflips = chip->ecc.strength * chip->ecc.steps;
} else {
max_bitflips = nfc->ecc_thres * chip->ecc.steps;
}

mtd->ecc_stats.corrected += max_bitflips;
}

return max_bitflips;
}

The above function is used to read the data from the NAND flash. First, the read request command is configured and sent to NAND flash. Then we read the data from NAND flash. But you see that there is a loop to check if the ECC status and




NEXT




<s> static int rtl838x_eee_port_ability(struct rtl838x_switch_priv *priv,
struct ethtool_eee *e, int port)
{
u64 link;

if (port >= 24)
return 0;

link = rtl839x_get_port_reg_le(RTL838X_MAC_LINK_STS);
if (!(link & BIT(port)))
return 0;

if (sw_r32(rtl838x_mac_force_mode_ctrl(port)) & BIT(9))
e->advertised |= ADVERTISED_100baseT_Full;

if (sw_r32(rtl838x_mac_force_mode_ctrl(port)) & BIT(10))
e->advertised |= ADVERTISED_1000baseT_Full;

if (sw_r32(RTL838X_MAC_EEE_ABLTY) & BIT(port)) {
e->lp_advertised = ADVERTISED_100baseT_Full;
e->lp_advertised |= ADVERTISED_1000baseT_Full;
return 1;
}

return 0;
}

The above function is used to obtain the EEE capability of a given port. However, this implementation has issues:
1.
This function is called by the kernel driver but there is no kernel driver for the RTL838x chipset, and this function is




NEXT




<s> static inline void sata_oxnas_reset_sgdma(struct ata_port *ap)
{
struct sata_oxnas_port_priv *pd = ap->private_data;

iowrite32(SGDMA_RESETS_CTRL, pd->sgdma_base + SGDMA_RESETS);
}

The above function is used to reset the SGDMA for a specific port.

I think it is a reasonable assumption that
the SGDMA and the link controller should be reset
simultaneously to bring up a SATA port.

How/where to




NEXT




<s> void fill_window(WINDOW *win, const char *text)
{
int x, y;
int total_lines = get_line_no(text);
int i;

getmaxyx(win, y, x);
/* do not go over end of line */
total_lines = min(total_lines, y);
for (i = 0; i < total_lines; i++) {
char tmp[x+10];
const char *line = get_line(text, i);
int len = get_line_length(line);
strncpy(tmp, line, min(len, x));
tmp[len] = '\0';
mvwprintw(win, i, 0, "%s", tmp);
}
}

The above function is used to draw the window. We have to give it the pointer to the current window along with a string having the value to be printed in the window.</s>




NEXT




<s> static int rtl8366s_sw_get_learning_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi,RTL8366S_SSCR0, &data);
val->value.i = !data;

return 0;
}

The above function is used to query the status of MAC table learning.</s>




NEXT




<s> ret_t rtl8367c_setAsicEavPortEnable(rtk_uint32 port, rtk_uint32 enabled)
{
if(port > RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(port < 5)
return rtl8367c_setAsicRegBit(RTL8367C_EAV_PORT_CFG_REG(port), RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
else if(port == 5)
return rtl8367c_setAsicRegBit(RTL8367C_REG_P5_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
else if(port == 6)
return rtl8367c_setAsicRegBit(RTL8367C_REG_P6_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
else if(port == 7)
return rtl8367c_setAsicRegBit(RTL8367C_REG_P7_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
else if(port == 8)
return rtl8367c_setAsicRegBit(RTL8367C_REG_P8_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
else if(port == 9)
return rtl8367c_setAsicRegBit(RTL8367C_REG_P9_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);


return RT_ERR_OK;
}

The above function is used to enable or disable the PTP EAV port.
To configure EAV port with RTL8651D (RTL8651-LC), refer to following information.
# Supported PTP EAV Port
|




NEXT




<s> static int psb6970_reset_switch(struct switch_dev *dev)
{
struct psb6970_priv *priv = to_psb6970(dev);
int i;

mutex_lock(&priv->reg_mutex);

memset(&priv->psb6970_priv_volatile, 0,
sizeof(priv->psb6970_priv_volatile));

for (i = 0; i < PSB6970_MAX_VLANS; i++)
priv->vlan_id[i] = i;

mutex_unlock(&priv->reg_mutex);

return psb6970_hw_apply(dev);
}

The above function is used to reset the switch to initial state and apply the latest SW to HW configuration, but this function would re-trigger hw_init and reset all vlan-port mappings on the device. As a result, if a switch could recover to its




NEXT




<s> static int rtl838x_set_ageing_time(unsigned long msec)
{
int t = sw_r32(RTL838X_L2_CTRL_1);

t &= 0x7FFFFF;
t = t * 128 / 625; /* Aging time in seconds. 0: L2 aging disabled */
pr_debug("L2 AGING time: %d sec\n", t);

t = (msec * 625 + 127000) / 128000;
t = t > 0x7FFFFF ? 0x7FFFFF : t;
sw_w32_mask(0x7FFFFF, t, RTL838X_L2_CTRL_1);
pr_debug("Dynamic aging for ports: %x\n", sw_r32(RTL838X_L2_PORT_AGING_OUT));

return 0;
}

The above function is used to configure the device for aging time and is called from a 5 seconds timer when aging is disabled.</s>




NEXT




<s> static int rtl83xx_port_mirror_add(struct dsa_switch *ds, int port,
struct dsa_mall_mirror_tc_entry *mirror,
bool ingress)
{
/* We support 4 mirror groups, one destination port per group */
int group;
struct rtl838x_switch_priv *priv = ds->priv;
int ctrl_reg, dpm_reg, spm_reg;

pr_debug("In %s\n", __func__);

for (group = 0; group < 4; group++) {
if (priv->mirror_group_ports[group] == mirror->to_local_port)
break;
}
if (group >= 4) {
for (group = 0; group < 4; group++) {
if (priv->mirror_group_ports[group] < 0)
break;
}
}

if (group >= 4)
return -ENOSPC;

ctrl_reg = priv->r->mir_ctrl + group * 4;
dpm_reg = priv->r->mir_dpm + group * 4 * priv->port_width;
spm_reg = priv->r->mir_spm + group * 4 * priv->port_width;

pr_debug("Using group %d\n", group);
mutex_lock(&priv->reg_mutex);

if (priv->family_id == RTL8380_FAMILY_ID) {
/* Enable mirroring to port across VLANs (bit 11) */
sw_w32(1 << 11 | (mirror->to_local_port << 4) | 1, ctrl_reg);
} else {
/* Enable mirroring to destination port */
sw_w32((mirror->to_local_port << 4) | 1, ctrl_reg);
}

if (ingress && (priv->r->get_port_reg_be(spm_reg) & (1ULL << port))) {
mutex_unlock(&priv->reg_mutex);
return -EEXIST;
}
if ((!ingress) && (priv->r->get_port_reg_be(dpm_reg) & (1ULL << port))) {
mutex_unlock(&priv->reg_mutex);
return -EEXIST;
}

if (ingress)
priv->r->mask_port_reg_be(0, 1ULL << port, spm_reg);
else
priv->r->mask_port_reg_be(0, 1ULL << port, dpm_reg);

priv->mirror_group_ports[group] = mirror->to_local_port;
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to mirror traffic from some port to multiple ports. But I need to mirror only 1 port to others 4-5 ports (from one switch to to several servers) . Here I have 2 questions:
1. Is the above function just




NEXT




<s> ret_t rtl8367c_setAsicEavInterruptMask(rtk_uint32 imr)
{
if ((imr&(RTL8367C_PTP_INTR_MASK<<8))>0)
return RT_ERR_INPUT;

return rtl8367c_setAsicRegBits(RTL8367C_REG_PTP_TIME_CFG2, RTL8367C_PTP_INTR_MASK, imr);
}

The above function is used to set up the interrupt mask of EAV. As the name implies, it sets up the interrupt mask for the EAV time source interface. From the source code, we can find that rtl8367c_setAsicRegBits




NEXT




<s> static void espi_claim_bus(struct fsl_spi *fsl)
{
ccsr_espi_t *espi = fsl->espi;
uint32_t csmode;
int i;

/* Enable eSPI interface */
out_be32(&espi->mode, ESPI_MODE_RXTHR(3)
| ESPI_MODE_TXTHR(4) | ESPI_MODE_EN);

out_be32(&espi->mask, 0x00000000); /* Mask  all eSPI interrupts */

/* Init CS mode interface */
for (i = 0; i < ESPI_MAX_CS_NUM; i++)
out_be32(&espi->csmode[i], ESPI_CSMODE_INIT_VAL);

csmode = ESPI_CSMODE_INIT_VAL;

/* Set eSPI BRG clock source */
csmode |= ESPI_CSMODE_PM(fsl->pm) | fsl->div16;

/* Set eSPI mode */
if (fsl->mode & SPI_CPHA)
csmode |= ESPI_CSMODE_CP_BEGIN_EDGCLK;
if (fsl->mode & SPI_CPOL)
csmode |= ESPI_CSMODE_CI_INACTIVEHIGH;

/* Character bit order: msb first */
csmode |= ESPI_CSMODE_REV_MSB_FIRST;

/* Character length in bits, between 0x3~0xf, i.e. 4bits~16bits */
csmode |= ESPI_CSMODE_LEN(7);

out_be32(&espi->csmode[fsl->cs], csmode);
}

The above function is used to claim bus. There are a few steps we need to explain in this article, we will discuss these points below.

Enable eSPI interface.

This step is to set up basic communication. As can be seen from the ESPI_




NEXT




<s> static int rtl8367b_enable_vlan4k(struct rtl8366_smi *smi, int enable)
{
return 0;
}

The above function is used to enable/disable the vlan tag for VLAN insertion by the VOQ engine based on RTL8367B hardware.

I propose the same way (enable as 0; disable as 1):

static




NEXT




<s> void serial_console_init(void)
{
out_8(reg_base + (UART_FCR << reg_shift), 0x06);
}

The above function is used to clear the interrupts in the UART so no
more IRQ interrupts are generated for a particular set of port.

In case of serial console it is better to keep the IRQ handling
interrupts disabled. By default the U




NEXT




<s> static u64 rtl838x_read_mcast_pmask(int idx)
{
u32 portmask;
/* Read MC_PMSK (2) via register RTL8380_TBL_L2 */
struct table_reg *q = rtl_table_get(RTL8380_TBL_L2, 2);

rtl_table_read(q, idx);
portmask = sw_r32(rtl_table_data(q, 0));
rtl_table_release(q);

return portmask;
}

The above function is used to get the multicast group address table,
and also its portmask.

However with RTL-8153(and for some RTL8152s), when the 8/12 port is
config




NEXT




<s> static int rtl8366rb_setup(struct rtl8366_smi *smi)
{
int err;
#ifdef CONFIG_OF
unsigned i;
struct device_node *np;
unsigned num_initvals;
const __be32 *paddr;

np = smi->parent->of_node;

paddr = of_get_property(np, "realtek,initvals", &num_initvals);
if (paddr) {
dev_info(smi->parent, "applying initvals from DTS\n");

if (num_initvals < (2 * sizeof(*paddr)))
return -EINVAL;

num_initvals /= sizeof(*paddr);

for (i = 0; i < num_initvals - 1; i += 2) {
u32 reg = be32_to_cpup(paddr + i);
u32 val = be32_to_cpup(paddr + i + 1);

REG_WR(smi, reg, val);
}
}
#endif

/* set maximum packet length to 1536 bytes */
REG_RMW(smi, RTL8366RB_SGCR, RTL8366RB_SGCR_MAX_LENGTH_MASK,
RTL8366RB_SGCR_MAX_LENGTH_1536);

/* enable learning for all ports */
REG_WR(smi, RTL8366RB_SSCR0, 0);

/* enable auto ageing for all ports */
REG_WR(smi, RTL8366RB_SSCR1, 0);

/*
* discard VLAN tagged packets if the port is not a member of
* the VLAN with which the packets is associated.
*/
REG_WR(smi, RTL8366RB_VLAN_INGRESS_CTRL2_REG, RTL8366RB_PORT_ALL);

/* don't drop packets whose DA has not been learned */
REG_RMW(smi, RTL8366RB_SSCR2, RTL8366RB_SSCR2_DROP_UNKNOWN_DA, 0);

return 0;
}

The above function is used to set up the RTL8366RB chip. I'm using an ifconfig option to set the MTU to 1500bytes; what I'm now trying to figure out is if you can set the max length




NEXT




<s> int rtl839x_l3_setup(struct rtl838x_switch_priv *priv)
{
rtl839x_setup_port_macs(priv);

return 0;
}

The above function is used to set the physical port mac addresses in a rtl839x switch.

The rtl839x_setup_port_macs uses rtl839x_port_mac function to set specific port mac.




NEXT




<s> static void vr9_shutdown(void)
{
}

The above function is used to shut down a virtual machine driver instance
associated with a particular process.  By design, the main purpose of this
function is to clear any references to memory (as the driver is going to be
shut down, it should not be




NEXT




<s> rtk_api_ret_t rtk_qos_1pRemarkSrcSel_get(rtk_qos_1pRmkSrc_t *pType)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_getAsicRemarkingDot1pSrc(pType)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to obtain 1P Dot1pSrc as default setting for REMARK.

Example:

#include "/data/local/kernel-4.4.27/drivers/net/ethernet/rtl8




NEXT




<s> rtk_api_ret_t rtk_l2_learningCnt_get(rtk_port_t port, rtk_mac_cnt_t *pMac_cnt)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pMac_cnt)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicLutLearnNo(rtk_switch_port_L2P_get(port), pMac_cnt)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get learning counter. The value is defined in the below enum.

typedef enum
{
    LUT_TYPE         = 0x43, /* LUT data type: Port + MAC + Bit */
    MAC




NEXT




<s> static int rtl8366s_get_vlan_4k(struct rtl8366_smi *smi, u32 vid,
struct rtl8366_vlan_4k *vlan4k)
{
u32 data[2];
int err;
int i;

memset(vlan4k, '\0', sizeof(struct rtl8366_vlan_4k));

if (vid >= RTL8366S_NUM_VIDS)
return -EINVAL;

/* write VID */
err = rtl8366_smi_write_reg(smi, RTL8366S_VLAN_TABLE_WRITE_BASE,
vid & RTL8366S_VLAN_VID_MASK);
if (err)
return err;

/* write table access control word */
err = rtl8366_smi_write_reg(smi, RTL8366S_TABLE_ACCESS_CTRL_REG,
RTL8366S_TABLE_VLAN_READ_CTRL);
if (err)
return err;

for (i = 0; i < 2; i++) {
err = rtl8366_smi_read_reg(smi,
RTL8366S_VLAN_TABLE_READ_BASE + i,
&data[i]);
if (err)
return err;
}

vlan4k->vid = vid;
vlan4k->untag = (data[1] >> RTL8366S_VLAN_UNTAG_SHIFT) &
RTL8366S_VLAN_UNTAG_MASK;
vlan4k->member = data[1] & RTL8366S_VLAN_MEMBER_MASK;
vlan4k->fid = (data[1] >> RTL8366S_VLAN_FID_SHIFT) &
RTL8366S_VLAN_FID_MASK;

return 0;
}

The above function is used to fetch VLAN entry from RTL8366S hardware. The function
return a struct of type rtl8366_vlan_4k. There it fetches the vid, untag member and fid.</s>




NEXT




<s> ret_t rtl8367c_setAsicStormFilterExtBroadcastEnable(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_BCAST_EXT_EN_OFFSET, enabled);
}

The above function is used to enable the 2nd stage storm filter, based on source IP address of Ethernet frame in the data buffer, to filter the frames whose Destination MAC Address is all 1.

The 2nd stage storm filter consists of a




NEXT




<s> rtk_api_ret_t rtk_ptp_portEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port is PTP port */
RTK_CHK_PORT_IS_PTP(port);

if ((retVal = rtl8367c_getAsicEavPortEnable(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to return the enable or disable status for PTP port, according to port number input.</s>




NEXT




<s> static inline int gpio_od_set(struct dc_ep_dev *dev, u32 gpio, int val)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_gpio_od_set(dev->priv, gpio, val);
}

The above function is used to set the open drain status for a particular GPIO port and that is the reason that it needs to be called only when the GPIO driver is not accessed via the mfd/gpio_chip access path.

However, the above function has been used




NEXT




<s> static inline int rtl838x_l2_port_new_sa_fwd(int p)
{
return RTL838X_L2_PORT_NEW_SA_FWD(p);
}

The above function is used to get the number of SA's which can be added/updated using

RTL838x_L2_SA_MATCH()

if(RTL838x_L2_PORT_NEW_SA




NEXT




<s> static int ag71xx_open(struct net_device *dev)
{
struct ag71xx *ag = netdev_priv(dev);
unsigned int max_frame_len;
int ret;

netif_carrier_off(dev);
max_frame_len = ag71xx_max_frame_len(dev->mtu);
ag->rx_buf_size = SKB_DATA_ALIGN(max_frame_len + NET_SKB_PAD + NET_IP_ALIGN);

/* setup max frame length */
ag71xx_wr(ag, AG71XX_REG_MAC_MFL, max_frame_len);
ag71xx_hw_set_macaddr(ag, dev->dev_addr);

ret = ag71xx_hw_enable(ag);
if (ret)
goto err;

phy_start(ag->phy_dev);

return 0;

err:
ag71xx_rings_cleanup(ag);
return ret;
}

The above function is used to initialize the device to start transmission or receiving the data frames. In the above code we initialize some variables such as: max_frame_len – which is the packet size the device can accommodate and ag71xx_rx_buf_size –




NEXT




<s> rtk_api_ret_t rtk_qos_1pRemarkSrcSel_set(rtk_qos_1pRmkSrc_t type)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= DOT1P_RMK_SRC_END )
return RT_ERR_QOS_INT_PRIORITY;

if ((retVal = rtl8367c_setAsicRemarkingDot1pSrc(type)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the 802.1p marking source. This function could be invoked with:

rtkApi_set(RTK_API_NAME(qos_1pRemarkSrcSel), DOT1P




NEXT




<s> static void dc_ep_remove(struct pci_dev *pdev)
{
struct dc_ep_priv *priv = pci_get_drvdata(pdev);

#ifndef CONFIG_OF
struct pcie_ep_adapter *adapter =
(struct pcie_ep_adapter *) pci_get_drvdata(pdev);

platform_device_unregister(adapter->mei_dev);
#endif
if (priv == NULL)
return;

if (atomic_read(&priv->refcnt) != 0) {
dev_err(&pdev->dev, "%s still being used, can't remove\n",
__func__);
return;
}
dc_aca_free_fw_file(priv);
dc_aca_shutdown(priv);
dc_ep_icu_disable(priv);
pci_iounmap(pdev, priv->mem);
pci_release_region(pdev, DC_EP_BAR_NUM);
pci_disable_msi(pdev);
wmb();
pci_clear_master(pdev);
pci_disable_device(pdev);
}

The above function is used to remove PCIe EP device, it can call after
unload the driver, it will also call during loading the driver.

This function, can call it in the following conditions:
2016-08-20:




NEXT




<s> const char *get_system_type(void)
{
return soc_info.name;
}

The above function is used to get the system type from the system config
file.
It is included in sysconfig.c file and is called from the below function:

const char *get_board_info(void)
{
static char binfo[




NEXT




<s> static int __init ar8216_init(void)
{
int ret;

ret = phy_drivers_register(ar8xxx_phy_driver,
ARRAY_SIZE(ar8xxx_phy_driver),
THIS_MODULE);
if (ret)
return ret;

ret = mdio_driver_register(&ar8xxx_mdio_driver);
if (ret)
phy_drivers_unregister(ar8xxx_phy_driver,
ARRAY_SIZE(ar8xxx_phy_driver));

return ret;
}

The above function is used to register the AR8216 MDIO driver,
which is used to access the media access control (MAC) addresses
of the devices on the network.

To use the AR8216 MDIO driver, you will need




NEXT




<s> ret_t rtl8367c_setAsicPortIsolationPermittedPortmask(rtk_uint32 port, rtk_uint32 permitPortmask)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if( permitPortmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

return rtl8367c_setAsicReg(RTL8367C_PORT_ISOLATION_PORT_MASK_REG(port), permitPortmask);
}

The above function is used to set port isolation permitted portmask.
To set this kind of port isolation is just need to define permit por mask for a specific port.
This permit por mask should be set in all VLAN port masks and trunk port masks.
This will




NEXT




<s> static void dma_start(void)
{
unsigned int reg;
reg = readl(SATA_DMA_REGS_BASE + DMA_CTRL_STATUS);
reg = encode_start(reg);
writel(reg, SATA_DMA_REGS_BASE + DMA_CTRL_STATUS);
}

The above function is used to start the DMA transfer on a sata controller. The function reads the value of DMA_CTRL_STATUS register, stores it, modify the value with a macro encode_start() and then writes the value into the same register.

What is




NEXT




<s> static int MyReadFileAndCheck(unsigned char *src, void *dest, size_t size)
{
if (size == 0)
return 0;
memcpy(dest, src + rpos, size);
rpos += size;
return 1;
}

The above function is used to read data from a file and check if the data is valid. It takes in a pointer to a file source, a pointer to a destination, and a size. If the size is zero, the function returns. Otherwise, it copies data from the




NEXT




<s> static int button_hotplug_create_event(const char *name, unsigned int type,
unsigned long seen, int pressed)
{
struct bh_event *event;

pr_debug(PFX "create event, name=%s, seen=%lu, pressed=%d\n",
name, seen, pressed);

event = kzalloc(sizeof(*event), GFP_KERNEL);
if (!event)
return -ENOMEM;

event->name = name;
event->type = type;
event->seen = seen;
event->action = pressed ? "pressed" : "released";

INIT_WORK(&event->work, (void *)(void *)button_hotplug_work);
schedule_work(&event->work);

return 0;
}

The above function is used to do the creation of hotplug related events
and is invoked as follows:

static DEFINE_MUTEX(button_hotplug_mutex);

static int button_hotplug_work_func(struct work_struct *




NEXT




<s> rtk_api_ret_t rtk_svlan_ipmc2s_get(ipaddr_t ipmc, ipaddr_t ipmcMsk, rtk_vlan_t *pSvid)
{
rtk_api_ret_t retVal;
rtk_uint32 i;
rtl8367c_svlan_memconf_t svlanMemConf;
rtl8367c_svlan_mc2s_t svlanMC2SConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pSvid)
return RT_ERR_NULL_POINTER;

if ((ipmc&0xF0000000)!=0xE0000000)
return RT_ERR_INPUT;

for (i = 0; i <= RTL8367C_MC2SIDXMAX; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;

if (TRUE == svlanMC2SConf.valid &&
svlanMC2SConf.format == SVLAN_MC2S_MODE_IP &&
svlanMC2SConf.sdata == ipmc &&
svlanMC2SConf.smask == ipmcMsk)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(svlanMC2SConf.svidx, &svlanMemConf)) != RT_ERR_OK)
return retVal;
*pSvid = svlanMemConf.vs_svid;
return RT_ERR_OK;
}
}

return RT_ERR_OUT_OF_RANGE;
}

The above function is used to set unicast MAC address on VMAC, we'll first check each field. ipmc and ipmcMsk should be valid ones in rtl8367c_cmd_vlan_init(). if ipmcMsk




NEXT




<s> static int reg_open(struct inode *inode, struct file *file)
{
return single_open(file, reg_show, 0);
}

The above function is used to open a new file for the “dmesg”command .You are expected to understand the code of this function as it is based on the previous functions. The code does not have any differences from what we have seen previously.

For reg




NEXT




<s> be16dec(const void *buf)
{
const uint8_t *p = buf;

return (((uint16_t) p[0]) << 8) | p[1];
}

The above function is used to extract a single 16-bit value from a larger buffer. We can extract a number of different values from various locations in the buffer. I thought this might be an easy and simple way to implement a quick and dirty CRC-16 as




NEXT




<s> static inline void set_out_lanes(struct oxnas_pcie *pcie, unsigned lanes)
{
regmap_update_bits(pcie->sys_ctrl, pcie->outbound_offset + PCIE_AHB_SLAVE_CTRL,
PCIE_SLAVE_BE_MASK, PCIE_SLAVE_BE(lanes));
wmb();
}

The above function is used to update "PCIE_SLAVE_BE". This field is in bits 8-11 and bits 31-32 for 64 bits devices.

After checking in the code "outbound_offset" is




NEXT




<s> static void dep_stack_insert(struct dep_stack *stack, struct symbol *sym)
{
memset(stack, 0, sizeof(*stack));
if (check_top)
check_top->next = stack;
stack->prev = check_top;
stack->sym = sym;
check_top = stack;
}

The above function is used to push a new element in the stack, while the previous function in the same file is as the following:
int dep_stack_is_empty(struct dep_stack *stack)
{
return !stack;
}

I




NEXT




<s> BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w)
{
#ifndef BN_LLONG
BN_ULONG ret=0;
#else
BN_ULLONG ret=0;
#endif
int i;

w&=BN_MASK2;
for (i=a->top-1; i>=0; i--)
{
#ifndef BN_LLONG
ret=((ret<<BN_BITS4)|((a->d[i]>>BN_BITS4)&BN_MASK2l))%w;
ret=((ret<<BN_BITS4)|(a->d[i]&BN_MASK2l))%w;
#else
ret=(BN_ULLONG)(((ret<<(BN_ULLONG)BN_BITS2)|a->d[i])%
(BN_ULLONG)w);
#endif
}
return((BN_ULONG)ret);
}

The above function is used to divide integers of length bigger than than
WORDSIZE by WORDSIZE (which equals 32 or 64), thus BN_mod_word is
called with BN_MOD_WORD and BN_MOD_D




NEXT




<s> static nvram_tuple_t * _nvram_realloc( nvram_handle_t *h, nvram_tuple_t *t,
const char *name, const char *value )
{
if ((strlen(value) + 1) > h->length - h->offset)
return NULL;

if (!t) {
if (!(t = malloc(sizeof(nvram_tuple_t) + strlen(name) + 1)))
return NULL;

/* Copy name */
t->name = (char *) &t[1];
strcpy(t->name, name);

t->value = NULL;
}

/* Copy value */
if (!t->value || strcmp(t->value, value))
{
if(!(t->value = (char *) realloc(t->value, strlen(value)+1)))
return NULL;

strcpy(t->value, value);
t->value[strlen(value)] = '\0';
}

return t;
}

The above function is used to store additional information.

The function needs freeing when it is not needed anymore.</s>




NEXT




<s> ret_t rtl8367c_setAsicStormFilterUnknownUnicastEnable(rtk_uint32 port, rtk_uint32 enabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_STORM_UNKNOWN_UCAST_REG, port, enabled);
}

The above function is used to set ASIC's storm control whether enable the unknown unicast frame.

The storm filter control registers are as following:

STORM_UCAST_CTRL_REG0:
bit[0]: Aging Timeout Mode




NEXT




<s> ret_t rtl8367c_setAsicLutFlushMode(rtk_uint32 mode)
{
if( mode >= FLUSHMDOE_END )
return RT_ERR_NOT_ALLOWED;

return rtl8367c_setAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL2, RTL8367C_LUT_FLUSH_MODE_MASK, mode);
}

The above function is used to set Flash mode in ASIC by setting the value “rtl8367c_setAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL2, RTL8367




NEXT




<s> ar8327_hw_config_of(struct ar8xxx_priv *priv, struct device_node *np)
{
return -EINVAL;
}

The above function is used to read the parameters from the device tree.
It returns ERR_IF_NULL(err, ret) which means the device tree is missing.
If the device tree is missing, the function will continue to parse the next node.
Now we




NEXT




<s> void rtl931x_traffic_enable(int source, int dest)
{
struct table_reg *r = rtl_table_get(RTL9310_TBL_0, 6);
rtl_table_read(r, source);
sw_w32_mask(0, BIT(dest + 3), rtl_table_data(r, 0));
rtl_table_write(r, source);
rtl_table_release(r);
}

The above function is used to enable a particular set of l2 forwarding rules for traffic received on a particular MAC address. (i.e., from one interface). Source and dest are indexes in an array of MAC addresses (from_if[]) and (to_if




NEXT




<s> static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to read the  MEI_PORT_CONFIG_ADDR registers using mmap  */
int __init read_txrx_link_rate(void)
{
    unsigned int value;
    int ret;
    static unsigned int




NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_template_get(rtk_filter_template_t *aclTemplate)
{
rtk_api_ret_t ret;
rtk_uint32 idxField;
rtl8367c_acltemplate_t aclType;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == aclTemplate)
return RT_ERR_NULL_POINTER;

if(aclTemplate->index >= RTK_MAX_NUM_OF_FILTER_TYPE)
return RT_ERR_INPUT;

if((ret = rtl8367c_getAsicAclTemplate(aclTemplate->index, &aclType)) != RT_ERR_OK)
return ret;

for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField ++)
{
aclTemplate->fieldType[idxField] = aclType.field[idxField];
}

return RT_ERR_OK;
}

The above function is used to retrieve the user’s configuration for iGr ACL template in the hardware.</s>




NEXT




<s> static bool rtl838x_pie_templ_has(int t, enum template_field_id field_type)
{
enum template_field_id ft;

for (int i = 0; i < N_FIXED_FIELDS; i++) {
ft = fixed_templates[t][i];
if (field_type == ft)
return true;
}

return false;
}

The above function is used to find whether the template has the specified field
(using the template index).


We use this function in rtl838x_templ_parse</s>




NEXT




<s> static bool ag71xx_check_dma_stuck(struct ag71xx *ag)
{
unsigned long timestamp;
u32 rx_sm, tx_sm, rx_fd;

timestamp = netdev_get_tx_queue(ag->dev, 0)->trans_start;
if (likely(time_before(jiffies, timestamp + HZ/10)))
return false;

if (!netif_carrier_ok(ag->dev))
return false;

rx_sm = ag71xx_rr(ag, AG71XX_REG_RX_SM);
if ((rx_sm & 0x7) == 0x3 && ((rx_sm >> 4) & 0x7) == 0x6)
return true;

tx_sm = ag71xx_rr(ag, AG71XX_REG_TX_SM);
rx_fd = ag71xx_rr(ag, AG71XX_REG_FIFO_DEPTH);
if (((tx_sm >> 4) & 0x7) == 0 && ((rx_sm & 0x7) == 0) &&
((rx_sm >> 4) & 0x7) == 0 && rx_fd == 0)
return true;

return false;
}

The above function is used to diagnose stuck dma, however that is only used
when kernel version is lower than 5.5.</s>




NEXT




<s> static void AT91F_InitMemories()
{
int *pEbi = (int *)0xFFFFFF60;

//* Setup MEMC to support all connected memories (CS0 = FLASH; CS1=SDRAM)
pEbi  = (int *)0xFFFFFF60;
*pEbi = 0x00000002;

//* CS0 cs for flash
pEbi  = (int *)0xFFFFFF70;
*pEbi = 0x00003284;

AT91F_InitSdram();
}

The above function is used to enable MEMC. I have used the AT91F_InitSdram() to initialize memory to be used for SD access. I see that the function sets the memory mode using below

*(u32*)AT91F




NEXT




<s> gpio_latch_set(struct gpio_chip *gc, unsigned offset, int value)
{
struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
bool enable_latch = false;
bool disable_latch = false;

if (offset == glc->le_gpio) {
enable_latch = value ^ glc->le_active_low;
disable_latch = !enable_latch;
}

gpio_latch_lock(glc, enable_latch);
gpiod_set_raw_value_cansleep(glc->gpios[offset], value);
gpio_latch_unlock(glc, disable_latch);
}

The above function is used to set value 0 or 1 to a single GPIO line of a GPIO_LATCH chip.

The problem is that the gpios[offset] in this function is not initialized,
but it's used in the enable_




NEXT




<s> ret_t rtl8367c_getAsicPortMirrorRealKeep(rtk_uint32* pMode)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_REALKEEP_EN_OFFSET, pMode);
}

The above function is used to read the bit to determine whether the real interface keep or not.

The register layout is

 8                              16                              24
+-----------+-----------+-----------+-----------+-----------+
| Mirror Real Mode |




NEXT




<s> static inline void mailbox_aal_rx_handler(void);
static irqreturn_t mailbox_irq_handler(int, void *);
static inline void mailbox_signal(unsigned int, int);
static void do_ppe_tasklet(unsigned long);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
DECLARE_TASKLET(g_dma_tasklet, do_ppe_tasklet, 0);
#else
DECLARE_TASKLET_OLD(g_dma_tasklet, do_ppe_tasklet);
#endif

/*
*  QSB & HTU setting functions
*/
static void set_qsb(struct atm_vcc *, struct atm_qos *, unsigned int);
static void qsb_global_set(void);
static inline void set_htu_entry(unsigned int, unsigned int, unsigned int, int, int);
static inline void clear_htu_entry(unsigned int);
static void validate_oam_htu_entry(void);
static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to push the OAM cell that originated from the MUX on OAM port. It must not be called from the MUX ISR.
#endif

extern int atmoamq_setup(struct qos_device *




NEXT




<s> static int rtl8366_smi_enable_vlan(struct rtl8366_smi *smi, int enable)
{
int err;

err = smi->ops->enable_vlan(smi, enable);
if (err)
return err;

smi->vlan_enabled = enable;

if (!enable) {
smi->vlan4k_enabled = 0;
err = smi->ops->enable_vlan4k(smi, enable);
}

return err;
}

The above function is used to configure enable or disable 802.1Q VLAN to the controller. First it sends the command to SMIM and the wait for reply. If the SMIM return failure, then this function will fail too.

After configuring




NEXT




<s> static void pm_channel_counters_showtime(int fd) {
IOCTL_DIR(DSL_PM_ChannelCounters_t, DSL_FIO_PM_CHANNEL_COUNTERS_SHOWTIME_GET, DSL_NEAR_END);

m_u32("uptime", out.interval.nElapsedTime);
}

The above function is used to display the time since the last system reboot.
The DSL forum has a related sample code here.

Alternatively here is a quick bash one-liner to get the uptime of device, with this you can




NEXT




<s> static int b53_srab_read48(struct b53_device *dev, u8 page, u8 reg, u64 *val)
{
u8 __iomem *regs = dev->priv;
int ret = 0;

ret = b53_srab_request_grant(dev);
if (ret)
goto err;

ret = b53_srab_op(dev, page, reg, 0);
if (ret)
goto err;

*val = readl(regs + B53_SRAB_RD_L);
*val += ((u64)readl(regs + B53_SRAB_RD_H) & 0xffff) << 32;

err:
b53_srab_release_grant(dev);

return ret;
}

The above function is used to read a 48-bit value from the SRAB register,
by reading 64-bit register twice (B53_SRAB_RD_L and B53_SRAB_RD_H)

1




NEXT




<s> ret_t rtl8367c_getAsic1xMBOpdirConfig(rtk_uint32 *pOpdir)
{
return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_MAC_OPDIR_OFFSET, pOpdir);
}

The above function is used to fetch the MAC operation direction
(opposite or normal) setting in the RTL8367C ASIC registers.

ret_t rtl8367c_getAsic1xMPKwdir(rt




NEXT




<s> ret_t rtl8367c_setAsicVlanTransparent(rtk_uint32 port, rtk_uint32 portmask)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(portmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

return rtl8367c_setAsicRegBits(RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL0 + port, RTL8367C_VLAN_EGRESS_TRANS_CTRL0_MASK, portmask);
}

The above function is used to configure a set of ports to set the ingress/egress VLAN transparency function.
This API is only supported on RTL8367C, where the input parameters are Port and Port-Mask, and the output
parameter




NEXT




<s> ret_t rtl8367c_setAsicPortMirrorIsolationRxLeaky(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_RX_ISOLATION_LEAKY_OFFSET, enabled);
}

The above function is used to enable the RX leaking of the packet at the target port of the mirror destination of the RX path when the corresponding mirror frame is not marked with the "Mirror Mark" field set at the "Port 11", as shown in




NEXT




<s> static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to send the out-of-band (OOB) messages
out to the ATM PHY/MAC. These OOB messages contain the error
information for the received cells, which the ATM PHY/MAC have
processed as




NEXT




<s> static ssize_t hc_attr_show(struct kobject *kobj, struct kobj_attribute *attr,
char *buf);

/* Array of known tags to publish in sysfs */
static struct hc_attr {
const u16 tag_id;
ssize_t (* const tshow)(const u8 *pld, u16 pld_len, char *buf);
struct kobj_attribute kattr;
u16 pld_ofs;
u16 pld_len;
} hc_attrs[] = {
{
.tag_id = RB_ID_FLASH_INFO,
.tshow = routerboot_tag_show_u32s,
.kattr = __ATTR(flash_info, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_MAC_ADDRESS_PACK,
.tshow = hc_tag_show_mac,
.kattr = __ATTR(mac_base, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_BOARD_PRODUCT_CODE,
.tshow = routerboot_tag_show_string,
.kattr = __ATTR(board_product_code, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_BIOS_VERSION,
.tshow = routerboot_tag_show_string,
.kattr = __ATTR(booter_version, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_SERIAL_NUMBER,
.tshow = routerboot_tag_show_string,
.kattr = __ATTR(board_serial, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_MEMORY_SIZE,
.tshow = routerboot_tag_show_u32s,
.kattr = __ATTR(mem_size, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_MAC_ADDRESS_COUNT,
.tshow = routerboot_tag_show_u32s,
.kattr = __ATTR(mac_count, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_HW_OPTIONS,
.tshow = hc_tag_show_hwoptions,
.kattr = __ATTR(hw_options, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_WLAN_DATA,
.tshow = NULL,
}, {
.tag_id = RB_ID_BOARD_IDENTIFIER,
.tshow = routerboot_tag_show_string,
.kattr = __ATTR(board_identifier, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_PRODUCT_NAME,
.tshow = routerboot_tag_show_string,
.kattr = __ATTR(product_name, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_DEFCONF,
.tshow = routerboot_tag_show_string,
.kattr = __ATTR(defconf, S_IRUSR, hc_attr_show, NULL),
}, {
.tag_id = RB_ID_BOARD_REVISION,
.tshow = routerboot_tag_show_string,
.kattr = __ATTR(board_revision, S_IRUSR, hc_attr_show, NULL),
}
};

The above function is used to generate the sysfs attributes of an interface.

static

ssize_t

attr_show(

const

u8

*

pld,
u16

pld_len,




NEXT




<s> int rtl8366_smi_init(struct rtl8366_smi *smi)
{
int err;

if (!smi->ops)
return -EINVAL;

err = __rtl8366_smi_init(smi, dev_name(smi->parent));
if (err)
goto err_out;

if (!smi->ext_mbus)
dev_info(smi->parent, "using GPIO pins %u (SDA) and %u (SCK)\n",
smi->gpio_sda, smi->gpio_sck);
else
dev_info(smi->parent, "using MDIO bus '%s'\n", smi->ext_mbus->name);

err = smi->ops->detect(smi);
if (err) {
dev_err(smi->parent, "chip detection failed, err=%d\n", err);
goto err_free_sck;
}

err = rtl8366_reset(smi);
if (err)
goto err_free_sck;

err = smi->ops->setup(smi);
if (err) {
dev_err(smi->parent, "chip setup failed, err=%d\n", err);
goto err_free_sck;
}

err = rtl8366_init_vlan(smi);
if (err) {
dev_err(smi->parent, "VLAN initialization failed, err=%d\n",
err);
goto err_free_sck;
}

err = rtl8366_smi_enable_all_ports(smi, 1);
if (err)
goto err_free_sck;

err = rtl8366_smi_mii_init(smi);
if (err)
goto err_free_sck;

rtl8366_debugfs_init(smi);

return 0;

err_free_sck:
__rtl8366_smi_cleanup(smi);
err_out:
return err;
}

The above function is used to initialize SMI (System Management Interface)
and is called from the function
rtl8366_drv_init, where SMI is initialized for the first time.


#ifdef CONFIG_DEBUG_FS






NEXT




<s> ret_t rtl8367c_setAsicSystemLutLearnLimitNo(rtk_uint32 number)
{
if(number > RTL8367C_LUT_LEARNLIMITMAX)
return RT_ERR_LIMITED_L2ENTRY_NUM;

return rtl8367c_setAsicReg(RTL8367C_REG_LUT_SYS_LEARN_LIMITNO, number);
}

The above function is used to set the learn limit number of system LUTs where a certain number of MAC addresses are learnt through ARP table for the system LUT. For instance, if the MAC address is learnt from ARP table, its entry exists in the




NEXT




<s> static void msdc_set_buswidth(struct msdc_host *host, u32 width)
{
void __iomem *base = host->base;
u32 val = sdr_read32(SDC_CFG);

val &= ~SDC_CFG_BUSWIDTH;

switch (width) {
default:
case MMC_BUS_WIDTH_1:
width = 1;
val |= (MSDC_BUS_1BITS << 16);
break;
case MMC_BUS_WIDTH_4:
val |= (MSDC_BUS_4BITS << 16);
break;
case MMC_BUS_WIDTH_8:
val |= (MSDC_BUS_8BITS << 16);
break;
}

sdr_write32(SDC_CFG, val);

N_MSG(CFG, "Bus Width = %d", width);
}

The above function is used to set the bus width as requested by the driver.</s>




NEXT




<s> static void rtk_hal_set_port_mirror(unsigned int port ,unsigned int rx_port_map,unsigned int tx_port_map)
{
rtk_portmask_t rx_portmask;
rtk_portmask_t tx_portmask;
rtk_api_ret_t ret;
int i;

rtk_mirror_portIso_set(ENABLED);
RTK_PORTMASK_CLEAR(rx_portmask);
RTK_PORTMASK_CLEAR(tx_portmask);

for (i = 0; i < 5; i++)
if (rx_port_map & (1 << i))
RTK_PORTMASK_PORT_SET(rx_portmask, i);

for (i = 0; i < 2; i++)
if (rx_port_map & (1 << (i + 5)))
RTK_PORTMASK_PORT_SET(rx_portmask, (i + EXT_PORT0));

RTK_PORTMASK_CLEAR(tx_portmask);

for (i = 0; i < 5; i++)
if (tx_port_map & (1 << i))
RTK_PORTMASK_PORT_SET(tx_portmask, i);

for (i = 0; i < 2; i++)
if (tx_port_map & (1 << (i + 5)))
RTK_PORTMASK_PORT_SET(tx_portmask, (i + EXT_PORT0));

ret = rtk_mirror_portBased_set(port, &rx_portmask, &tx_portmask);

if (!ret)
printk("rtk_mirror_portBased_set success\n");

}

The above function is used to enable/disable, set the receive and transmit port mapping (e.g. if we use 2 mirrored ports, we can set only two ports of a mirrored pair. Here, we use two mirrored ports of port




NEXT




<s> rtl_attr_set_port_int(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
if (val->port_vlan >= RTL8306_NUM_PORTS)
return -EINVAL;

return rtl_attr_set_int(dev, attr, val);
}

The above function is used to set the port int attribute on a switch chip. It checks if the port number is valid and performs a call to the rtl_attr_set_int() function to set the value of the attribute. This function is called by the switch driver




NEXT




<s> rtk_api_ret_t rtk_vlan_portPvid_get(rtk_port_t port, rtk_vlan_t *pPvid, rtk_pri_t *pPriority)
{
rtk_api_ret_t retVal;
rtk_uint32 index, pri;
rtl8367c_vlanconfiguser mbrCfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pPvid)
return RT_ERR_NULL_POINTER;

if(NULL == pPriority)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicVlanPortBasedVID(rtk_switch_port_L2P_get(port), &index, &pri)) != RT_ERR_OK)
return retVal;

memset(&mbrCfg, 0x00, sizeof(rtl8367c_vlanconfiguser));
if ((retVal = rtl8367c_getAsicVlanMemberConfig(index, &mbrCfg)) != RT_ERR_OK)
return retVal;

*pPvid = mbrCfg.evid;
*pPriority = pri;

return RT_ERR_OK;
}

The above function is used to read Port based port VLAN settings, which includes the Port member and the Port based port VLAN. Note that the Port based port VLAN could be read through other APIs, including rtk_portvlan_set/get_ext




NEXT




<s> static int b53_srab_read16(struct b53_device *dev, u8 page, u8 reg, u16 *val)
{
u8 __iomem *regs = dev->priv;
int ret = 0;

ret = b53_srab_request_grant(dev);
if (ret)
goto err;

ret = b53_srab_op(dev, page, reg, 0);
if (ret)
goto err;

*val = readl(regs + B53_SRAB_RD_L) & 0xffff;

err:
b53_srab_release_grant(dev);

return ret;
}

The above function is used to read 16 bit value from B53 SRA memory. As you can see it first get a grant and then reads the value.

Now you might wonder that why this mechanism is being chosen? Let me explain it to you.




NEXT




<s> bool sym_set_tristate_value(struct symbol *sym, tristate val)
{
tristate oldval = sym_get_tristate_value(sym);

if (oldval != val && !sym_tristate_within_range(sym, val))
return false;

if (!(sym->flags & SYMBOL_DEF_USER)) {
sym->flags |= SYMBOL_DEF_USER;
sym_set_changed(sym);
}
/*
* setting a choice value also resets the new flag of the choice
* symbol and all other choice values.
*/
if (sym_is_choice_value(sym) && val == yes) {
struct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));
struct property *prop;
struct expr *e;

cs->def[S_DEF_USER].val = sym;
cs->flags |= SYMBOL_DEF_USER;
prop = sym_get_choice_prop(cs);
for (e = prop->expr; e; e = e->left.expr) {
if (e->right.sym->visible != no)
e->right.sym->flags |= SYMBOL_DEF_USER;
}
}

sym->def[S_DEF_USER].tri = val;
if (oldval != val)
sym_clear_all_valid();

return true;
}

The above function is used to set value in Cygwin.

However, I have to find out a way to set the status of the check box in
the form from user side itself.

I hope if someone tell me where the check box in form is




NEXT




<s> ar8327_atu_flush_port(struct ar8xxx_priv *priv, int port)
{
u32 t;
int ret;

ret = ar8216_wait_bit(priv, AR8327_REG_ATU_FUNC,
AR8327_ATU_FUNC_BUSY, 0);
if (!ret) {
t = (port << AR8327_ATU_PORT_NUM_S);
t |= AR8327_ATU_FUNC_OP_FLUSH_PORT;
t |= AR8327_ATU_FUNC_BUSY;
ar8xxx_write(priv, AR8327_REG_ATU_FUNC, t);
}

return ret;
}

The above function is used to flush one of the AR8320 buffers of a specific port. Note that this function can only set the bus state to busy when port is selected 1, 2, or 3 (any other value will cause the function to fail




NEXT




<s> static int rtl83xx_vlan_del(struct dsa_switch *ds, int port,
const struct switchdev_obj_port_vlan *vlan)
{
struct rtl838x_vlan_info info;
struct rtl838x_switch_priv *priv = ds->priv;
u16 pvid;

pr_debug("%s: port %d, vid %d, flags %x\n",
__func__, port, vlan->vid, vlan->flags);

if (vlan->vid > 4095) {
dev_err(priv->dev, "VLAN out of range: %d", vlan->vid);
return -ENOTSUPP;
}

mutex_lock(&priv->reg_mutex);
pvid = priv->ports[port].pvid;

/* Reset to default if removing the current PVID */
if (vlan->vid == pvid) {
rtl83xx_vlan_set_pvid(priv, port, 0);
}
/* Get port memberships of this vlan */
priv->r->vlan_tables_read(vlan->vid, &info);

/* remove port from both tables */
info.untagged_ports &= (~BIT_ULL(port));
info.tagged_ports &= (~BIT_ULL(port));

priv->r->vlan_set_untagged(vlan->vid, info.untagged_ports);
pr_debug("Untagged ports, VLAN %d: %llx\n", vlan->vid, info.untagged_ports);

priv->r->vlan_set_tagged(vlan->vid, &info);
pr_debug("Tagged ports, VLAN %d: %llx\n", vlan->vid, info.tagged_ports);

mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to remove a specific VLAN from a given port.
However, when I use this function, it crashes my box (see below), can anyone tell me what’s wrong with it?

[ 30.1925




NEXT




<s> static void rb4xx_nand_write_buf(struct nand_chip *chip, const u8 *buf, int len)
{
struct rb4xx_nand *nand = chip->priv;
struct rb4xx_cpld *cpld = nand->cpld;

cpld->write_nand(cpld, buf, len);
}

The above function is used to trigger write to nand by cpld.
In cpld, we check the buffer[len] to determine whether to do a multi-block write or not.
In cpld_set_mode, we make nand write 0




NEXT




<s> rtk_api_ret_t rtk_led_operation_set(rtk_led_operation_t mode)
{
rtk_api_ret_t retVal;
rtk_uint32 regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ( mode >= LED_OP_END)
return RT_ERR_INPUT;

switch (mode)
{
case LED_OP_PARALLEL:
regData = LEDOP_PARALLEL;
break;
case LED_OP_SERIAL:
regData = LEDOP_SERIAL;
break;
default:
return RT_ERR_CHIP_NOT_SUPPORTED;
break;
}

if ((retVal = rtl8367c_setAsicLedOperationMode(regData)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the LED mode. The two LED modes includes
parallel mode and serial mode (default mode)

rtk_led_operation_get(rtk_led_mode_t *mode)

Get the LED mode of the




NEXT




<s> static int l2_table_show(struct seq_file *m, void *v)
{
struct rtl838x_switch_priv *priv = m->private;
struct rtl838x_l2_entry e;
int bucket, index;

mutex_lock(&priv->reg_mutex);

for (int i = 0; i < priv->fib_entries; i++) {
bucket = i >> 2;
index = i & 0x3;
priv->r->read_l2_entry_using_hash(bucket, index, &e);

if (!e.valid)
continue;

seq_printf(m, "Hash table bucket %d index %d ", bucket, index);
l2_table_print_entry(m, priv, &e);

if (!((i + 1) % 64))
cond_resched();
}

for (int i = 0; i < 64; i++) {
priv->r->read_cam(i, &e);

if (!e.valid)
continue;

seq_printf(m, "CAM index %d ", i);
l2_table_print_entry(m, priv, &e);
}

mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to dump L2 Table entries. It prints L2 entries that use static and dynamic hash buckets. CAM indexes in this file start from 0 to 63.</s>




NEXT




<s> char *xstrndup(const char *s, size_t n)
{
char *p;

p = strndup(s, n);
if (p)
return p;
fprintf(stderr, "Out of memory.\n");
exit(1);
}

The above function is used to duplicate one string within another, n being the maximum length of the other (destination). Note that the string can span past the end of the destination. In the case of a failure, the strandup function returns NULL and a warning is printed on




NEXT




<s> int set_promisc(int on)
{
struct ifreq ifr;

strncpy(ifr.ifr_name, ifname, IFNAMSIZ);

if (ioctl(capture_sock, SIOCGIFFLAGS, &ifr) < 0)
return -1;

if (on && !(ifr.ifr_flags & IFF_PROMISC))
{
ifr.ifr_flags |= IFF_PROMISC;

if (ioctl(capture_sock, SIOCSIFFLAGS, &ifr))
return -1;

return 1;
}
else if (!on && (ifr.ifr_flags & IFF_PROMISC))
{
ifr.ifr_flags &= ~IFF_PROMISC;

if (ioctl(capture_sock, SIOCSIFFLAGS, &ifr))
return -1;

return 1;
}

return 0;
}

The above function is used to put the network interface into promiscuous mode.</s>




NEXT




<s> static void show_help(struct menu *menu);

static char filename[PATH_MAX+1];
static void set_config_filename(const char *config_filename)
{
static char menu_backtitle[PATH_MAX+128];

snprintf(menu_backtitle, sizeof(menu_backtitle), "%s - %s",
config_filename, rootmenu.prompt->text);
set_dialog_backtitle(menu_backtitle);

snprintf(filename, sizeof(filename), "%s", config_filename);
}

The above function is used to change the menu's title, when the user has chosen to rename it. We're copying the contents of config_filename to a string called filename. There's also a string called menu_backtitle that has room for the




NEXT




<s> static int rtl8366_smi_mii_init(struct rtl8366_smi *smi)
{
int ret;

#ifdef CONFIG_OF
struct device_node *np = NULL;

np = of_get_child_by_name(smi->parent->of_node, "mdio-bus");
#endif

smi->mii_bus = mdiobus_alloc();
if (smi->mii_bus == NULL) {
ret = -ENOMEM;
goto err;
}

smi->mii_bus->priv = (void *) smi;
smi->mii_bus->name = dev_name(smi->parent);
smi->mii_bus->read = smi->ops->mii_read;
smi->mii_bus->write = smi->ops->mii_write;
snprintf(smi->mii_bus->id, MII_BUS_ID_SIZE, "%s",
dev_name(smi->parent));
smi->mii_bus->parent = smi->parent;
smi->mii_bus->phy_mask = ~(0x1f);

#ifdef CONFIG_OF
if (np)
ret = of_mdiobus_register(smi->mii_bus, np);
else
#endif
ret = mdiobus_register(smi->mii_bus);

if (ret)
goto err_free;

return 0;

err_free:
mdiobus_free(smi->mii_bus);
err:
return ret;
}

The above function is used to create the phy driver instance. First
it allocates the private memory for the instance and then tries to
create the phy driver.

static void rtl8366_smi_mdiobus_event(




NEXT




<s> static int msdc_ops_get_cd(struct mmc_host *mmc)
{
struct msdc_host *host = mmc_priv(mmc);
void __iomem *base = host->base;
unsigned long flags;
int present = 1;

/* for sdio, MSDC_REMOVABLE not set, always return 1 */
if (!(host->hw->flags & MSDC_REMOVABLE)) {
/* For sdio, read H/W always get<1>, but may timeout some times */
#if 1
host->card_inserted = 1;
return 1;
#else
host->card_inserted = (host->pm_state.event == PM_EVENT_USER_RESUME) ? 1 : 0;
INIT_MSG("sdio ops_get_cd<%d>", host->card_inserted);
return host->card_inserted;
#endif
}

/* MSDC_CD_PIN_EN set for card */
if (host->hw->flags & MSDC_CD_PIN_EN) {
spin_lock_irqsave(&host->lock, flags);
#if 0
present = host->card_inserted;  /* why not read from H/W: Fix me*/
#else
// CD
if (cd_active_low)
present = (sdr_read32(MSDC_PS) & MSDC_PS_CDSTS) ? 0 : 1;
else
present = (sdr_read32(MSDC_PS) & MSDC_PS_CDSTS) ? 1 : 0;
if (host->mmc->caps & MMC_CAP_NEEDS_POLL)
present = 1;
host->card_inserted = present;
#endif
spin_unlock_irqrestore(&host->lock, flags);
} else {
present = 0; /* TODO? Check DAT3 pins for card detection */
}

INIT_MSG("ops_get_cd return<%d>", present);
return present;
}

The above function is used to detect if card present or not, and then will be called in the sdio ops_get_cd function. But msdc ops_get_cd only check for card detection by reading the status register, and no information is available whether the




NEXT




<s> mvswitch_exit(void)
{
phy_driver_unregister(&mvswitch_driver);
}

The above function is used to unregister the phy driver, and remove the switch from the phy_provider list. This way, the switch controller is disconnected from the kernel.

However, the switch still exists in the kernel. To completely remove it, we




NEXT




<s> static void print_position(WINDOW * win);

static int hscroll;
static int begin_reached, end_reached, page_length;
static char *buf;
static char *page;

/*
* refresh window content
*/
static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
int cur_y, int cur_x, update_text_fn update_text,
void *data)
{
print_page(box, boxh, boxw, update_text, data);
print_position(dialog);
wmove(dialog, cur_y, cur_x);	/* Restore cursor position */
wrefresh(dialog);
}

The above function is used to refresh the text content of a text box.
It includes four functions: print_position(), print_page(), wmove(),
and wrefresh(). The print_position() function draws the
horizontal scrollbar of the window. The print_




NEXT




<s> rtk_api_ret_t rtk_rldp_portLoopPair_get(rtk_port_t port, rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicRldpLoopedPortPair(rtk_switch_port_L2P_get(port), &pmsk))!=RT_ERR_OK)
return retVal;

if ((retVal = rtk_switch_portmask_P2L_get(pmsk, pPortmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to obtain the spanning tree portmask of an input port. The function works as following:

1. If the input parameter port is invalid or switch initialization is not complete, the return value will be E_RTK_FAIL.






NEXT




<s> int bcma_get_fallback_sprom(struct bcma_bus *bus, struct ssb_sprom *out)
{
struct bcma_fbs *pos;
u32 pci_bus, pci_dev;

if (bus->hosttype != BCMA_HOSTTYPE_PCI)
return -ENOENT;

pci_bus = bus->host_pci->bus->number;
pci_dev = PCI_SLOT(bus->host_pci->devfn);

list_for_each_entry(pos, &bcma_fbs_list, list) {
if (pos->pci_bus != pci_bus ||
pos->pci_dev != pci_dev)
continue;

if (pos->devid_override)
bus->host_pci->device = pos->sprom.dev_id;

memcpy(out, &pos->sprom, sizeof(struct ssb_sprom));
dev_info(pos->dev, "requested by [%x:%x]",
pos->pci_bus, pos->pci_dev);

return 0;
}

pr_err("unable to fill SPROM for [%x:%x]\n", pci_bus, pci_dev);

return -EINVAL;
}

The above function is used to set the devid for a board/sprom_override setting in sysfs for use in fallback_sprom.c. The fallback_sprom function is intended to use SPROM stored in NV-RAM (for boards




NEXT




<s> static int b53_global_get_4095_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct b53_device *priv = sw_to_b53(dev);

val->value.i = priv->allow_vid_4095;

return 0;
}

The above function is used to read a global property of the OpenvSwitch device.
The value is fetched from a device private data of type b53_device. The b53_device
is a structure that contains the information specific for device b53




NEXT




<s> rtk_port_t rtk_switch_port_P2L_get(rtk_uint32 physicalPort)
{
if(init_state != INIT_COMPLETED)
return UNDEFINE_PORT;

if(physicalPort >= RTK_SWITCH_PORT_NUM)
return UNDEFINE_PORT;

return (halCtrl->p2l_port[physicalPort]);
}

The above function is used to map port to the logica port index.

If switch_port >= RTK_SWITCH_PORT_NUM, the function returns UNDEFINE_PORT,
otherwise, the logical ports is returned.

Note that




NEXT




<s> static u32 rtl930x_l2_hash_key(struct rtl838x_switch_priv *priv, u64 seed)
{
u32 k0, k1, h1, h2, h;

k0 = (u32) (((seed >> 55) & 0x1f) ^
((seed >> 44) & 0x7ff) ^
((seed >> 33) & 0x7ff) ^
((seed >> 22) & 0x7ff) ^
((seed >> 11) & 0x7ff) ^
(seed & 0x7ff));

h1 = (seed >> 11) & 0x7ff;
h1 = ((h1 & 0x1f) << 6) | ((h1 >> 5) & 0x3f);

h2 = (seed >> 33) & 0x7ff;
h2 = ((h2 & 0x3f) << 5)| ((h2 >> 6) & 0x3f);

k1 = (u32) (((seed << 55) & 0x1f) ^
((seed >> 44) & 0x7ff) ^
h2 ^
((seed >> 22) & 0x7ff) ^
h1 ^
(seed & 0x7ff));

/* Algorithm choice for block 0 */
if (sw_r32(RTL930X_L2_CTRL) & BIT(0))
h = k1;
else
h = k0;

/* Algorithm choice for block 1
* Since k0 and k1 are < 2048, adding 2048 will offset the hash into the second
* half of hash-space
* 2048 is in fact the hash-table size 16384 divided by 4 hashes per bucket
* divided by 2 to divide the hash space in 2
*/
if (sw_r32(RTL930X_L2_CTRL) & BIT(1))
h |= (k1 + 2048) << 16;
else
h |= (k0 + 2048) << 16;

return h;
}

The above function is used to get the hash index for a flow table entry and a
key-seed value, and the seed must be calculated based on the key fields
defined by the flow table. The rtl930x_l2_hash_key()




NEXT




<s> ret_t rtl8367c_setAsicAclVidRange(rtk_uint32 index, rtk_uint32 type, rtk_uint32 upperVid, rtk_uint32 lowerVid)
{
ret_t retVal;
rtk_uint32 regData;

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

regData = ((type << RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_TYPE_OFFSET) & RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_TYPE_MASK) |
(upperVid & RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_HIGH_MASK);

retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_VID_RANGE_ENTRY0_CTRL1 + index*2, regData);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_VID_RANGE_ENTRY0_CTRL0 + index*2, lowerVid);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the ACL with a start and end of VLAN ID. If the destination VLAN ID of a flow is within this range it will be matched by ACL.

The function returns an error code as described below:
-RT




NEXT




<s> t_tob64(dst, src, size)
register char *dst, *src;
register unsigned size;
{
int c, pos = size % 3;
unsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;
char *olddst = dst;

switch(pos) {
case 1:
b2 = src[0];
break;
case 2:
b1 = src[0];
b2 = src[1];
break;
}

while(1) {
c = (b0 & 0xfc) >> 2;
if(notleading || c != 0) {
*dst++ = b64table[c];
notleading = 1;
}
c = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);
if(notleading || c != 0) {
*dst++ = b64table[c];
notleading = 1;
}
c = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);
if(notleading || c != 0) {
*dst++ = b64table[c];
notleading = 1;
}
c = b2 & 0x3f;
if(notleading || c != 0) {
*dst++ = b64table[c];
notleading = 1;
}
if(pos >= size)
break;
else {
b0 = src[pos++];
b1 = src[pos++];
b2 = src[pos++];
}
}

*dst++ = '\0';
return olddst;
}

The above function is used to print out binary data in base 64 format.  The idea of this algorithm is to encode a sequence of three bytes into a sequence of four base 64 symbols. For example, 'b = 0, b1 = 1




NEXT




<s> mtdsplit_parse_trx(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct mtd_partition *parts;
struct trx_header hdr;
int nr_parts;
size_t offset;
size_t trx_offset;
size_t trx_size = 0;
size_t rootfs_offset;
size_t rootfs_size = 0;
int ret;

nr_parts = 2;
parts = kzalloc(nr_parts * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

/* find trx image on erase block boundaries */
for (offset = 0; offset < master->size; offset += master->erasesize) {
trx_size = 0;

ret = read_trx_header(master, offset, &hdr);
if (ret)
continue;

if (hdr.magic != cpu_to_le32(TRX_MAGIC)) {
pr_debug("no valid trx header found in \"%s\" at offset %llx\n",
master->name, (unsigned long long) offset);
continue;
}

trx_size = le32_to_cpu(hdr.len);
if ((offset + trx_size) > master->size) {
pr_debug("trx image exceeds MTD device \"%s\"\n",
master->name);
continue;
}
break;
}

if (trx_size == 0) {
pr_debug("no trx header found in \"%s\"\n", master->name);
ret = -ENODEV;
goto err;
}

trx_offset = offset + hdr.offset[0];
rootfs_offset = offset + hdr.offset[1];
rootfs_size = master->size - rootfs_offset;
trx_size = rootfs_offset - trx_offset;

if (rootfs_size == 0) {
pr_debug("no rootfs found in \"%s\"\n", master->name);
ret = -ENODEV;
goto err;
}

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = trx_offset;
parts[0].size = trx_size;

parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = rootfs_size;

*pparts = parts;
return nr_parts;

err:
kfree(parts);
return ret;
}

The above function is used to parse the TRX partition table in nand based flash devices.

TRX partition table basically contains two partitions.
a) kernel partition in offset 0
b) linux rootfs partition in offset 1

In order




NEXT




<s> static int ip17xx_get_tagged(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);

if (state->add_tag & (1<<val->port_vlan)) {
if (state->remove_tag & (1<<val->port_vlan))
val->value.i = 3; // shouldn't ever happen.
else
val->value.i = 1;
} else {
if (state->remove_tag & (1<<val->port_vlan))
val->value.i = 0;
else
val->value.i = 2;
}
return 0;
}

The above function is used to determine the VLAN state (tagged/untagged) of the VLAN for a particular port number as per IEEE 802.1Q. However, for IP1700 and IP1720 (that




NEXT




<s> int mtd_open(const char *mtd, bool block)
{
FILE *fp;
char dev[PATH_MAX];
int i;
int ret;
int flags = O_RDWR | O_SYNC;
char name[PATH_MAX];

snprintf(name, sizeof(name), "\"%s\"", mtd);
if ((fp = fopen("/proc/mtd", "r"))) {
while (fgets(dev, sizeof(dev), fp)) {
if (sscanf(dev, "mtd%d:", &i) && strstr(dev, name)) {
snprintf(dev, sizeof(dev), "/dev/mtd%s/%d", (block ? "block" : ""), i);
if ((ret=open(dev, flags))<0) {
snprintf(dev, sizeof(dev), "/dev/mtd%s%d", (block ? "block" : ""), i);
ret=open(dev, flags);
}
fclose(fp);
return ret;
}
}
fclose(fp);
}

return open(mtd, flags);
}

The above function is used to open the actual device where the raw image is written.

#### 4.7. Writing back to MTD device

To write an image back onto the nandchip we need to write back to the device and unmap the page




NEXT




<s> static void rtl839x_create_tx_header(struct p_hdr *h, unsigned int dest_port, int prio)
{
/* cpu_tag[0] is reserved on the RTL83XX SoCs */
h->cpu_tag[1] = 0x0100; /* RTL8390_CPU_TAG marker */
h->cpu_tag[2] = BIT(4); /* AS_DPM flag */
h->cpu_tag[3] = h->cpu_tag[4] = h->cpu_tag[5] = 0;
/* h->cpu_tag[1] |= BIT(1) | BIT(0); */ /* Bypass filter 1/2 */
if (dest_port >= 32) {
dest_port -= 32;
h->cpu_tag[2] |= (BIT(dest_port) >> 16) & 0xf;
h->cpu_tag[3] = BIT(dest_port) & 0xffff;
} else {
h->cpu_tag[4] = BIT(dest_port) >> 16;
h->cpu_tag[5] = BIT(dest_port) & 0xffff;
}

/* Set internal priority (PRI) and enable (AS_PRI) */
if (prio >= 0)
h->cpu_tag[2] |= ((prio & 0x7) | BIT(3)) << 8;
}

The above function is used to prepare the headers of outgoing network
packets. RTL839x chipsets also support filtering for incoming packets, and
so the chipset uses the same internal headers to filter incoming packets.
But we will not use that




NEXT




<s> static void nmbm_mark_tables_clean(struct nmbm_instance *ni)
{
ni->block_state_changed = 0;
ni->block_mapping_changed = 0;
}

The above function is used to mark several data members of structure
nmbm_instance as clean. It is then used at several points to make sure
that the corresponding data is up to date. This kind of scheme is used
also in the kernel to keep cache lines




NEXT




<s> mtk_bmt_replace_ops(struct mtd_info *mtd)
{
bmtd._read_oob = mtd->_read_oob;
bmtd._write_oob = mtd->_write_oob;
bmtd._erase = mtd->_erase;
bmtd._block_isbad = mtd->_block_isbad;
bmtd._block_markbad = mtd->_block_markbad;

mtd->_read_oob = mtk_bmt_read;
mtd->_write_oob = mtk_bmt_write;
mtd->_erase = mtk_bmt_mtd_erase;
mtd->_block_isbad = mtk_bmt_block_isbad;
mtd->_block_markbad = mtk_bmt_block_markbad;
}

The above function is used to replace the default functions with a special function that can handle some features. And as the result, the mtd device can support some new features such as erase, markbad and rewrite.
Now, I need to support these functions for my




NEXT




<s> static void handle_f7(int *key, struct menu *current_item);
static void handle_f8(int *key, struct menu *current_item);
static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to initialize the function_keys data structure containing the information of all the keystrokes you want to map your keyboard key for.

In the example above, you have mapped key F7 to the function_key “my_menu”, similarly




NEXT




<s> Byte LzmaLiteralDecodeMatch(CProb *probs, CRangeDecoder *rd, Byte matchByte)
{
int symbol = 1;
#ifdef _LZMA_LOC_OPT
RC_INIT_VAR
#endif
do
{
int bit;
int matchBit = (matchByte >> 7) & 1;
matchByte <<= 1;
#ifdef _LZMA_LOC_OPT
{
CProb *prob = probs + ((1 + matchBit) << 8) + symbol;
RC_GET_BIT2(prob, symbol, bit = 0, bit = 1)
}
#else
bit = RangeDecoderBitDecode(probs + ((1 + matchBit) << 8) + symbol, rd);
symbol = (symbol << 1) | bit;
#endif
if (matchBit != bit)
{
while (symbol < 0x100)
{
#ifdef _LZMA_LOC_OPT
CProb *prob = probs + symbol;
RC_GET_BIT(prob, symbol)
#else
symbol = (symbol + symbol) | RangeDecoderBitDecode(probs + symbol, rd);
#endif
}
break;
}
}
while (symbol < 0x100);
#ifdef _LZMA_LOC_OPT
RC_FLUSH_VAR
#endif
return symbol;
}

The above function is used to decode a match symbol based on
`matchByte`. For example, if `matchByte` is 0xAB (where the first bit is equal
to 0 and the second bit is equal to 1), then `symbol` will




NEXT




<s> static int oxnas_pcie_phy_init(struct phy *phy)
{
struct oxnas_pcie_phy *pciephy = phy_get_drvdata(phy);
int ret;

/* generate clocks from HCSL buffers, shared parts */
regmap_write(pciephy->sys_ctrl, SYS_CTRL_HCSL_CTRL_REGOFFSET, HCSL_BIAS_ON|HCSL_PCIE_EN);

/* Ensure PCIe PHY is properly reset */
ret = reset_control_reset(pciephy->rstc);

if (ret) {
dev_err(pciephy->dev, "phy reset failed %d\n", ret);
return ret;
}

return 0;
}

The above function is used to power up the PHY controller. At this stage, the controller receives the clocks from the HCSL registers.

The following list is the status of the PHY registers after the above function executed.

0xbc00




NEXT




<s> static void __init mtk_ethsys_init(struct device_node *node)
{
struct clk_onecell_data *clk_data;
int r;

clk_data = mtk_alloc_clk_data(ARRAY_SIZE(eth_clks));

mtk_clk_register_gates(node, eth_clks, ARRAY_SIZE(eth_clks), clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);

if (r)
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
}

The above function is used to register for the clocks defined for Ethsys.
This function will add the clocks one by one if we could have a list of clocks
and gate them we need to provide the clock list to this funciton while compiling the




NEXT




<s> void rtk_hal_qos_set_table2type(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;
rtk_priority_select_t PriDec;

/* write all pri to 0 */
PriDec.port_pri = 0;
PriDec.dot1q_pri = 0;
PriDec.acl_pri = 0;
PriDec.cvlan_pri = 0;
PriDec.svlan_pri = 0;
PriDec.dscp_pri = 0;
PriDec.dmac_pri = 0;
PriDec.smac_pri = 0;

if (data->qos_type == 0)
PriDec.port_pri = 1;
else if (data->qos_type == 1)
PriDec.dot1q_pri = 1;
else if (data->qos_type == 2)
PriDec.acl_pri = 1;
else if (data->qos_type == 3)
PriDec.dscp_pri = 1;
else if (data->qos_type == 4)
PriDec.cvlan_pri = 1;
else if (data->qos_type == 5)
PriDec.svlan_pri = 1;
else if (data->qos_type == 6)
PriDec.dmac_pri = 1;
else if (data->qos_type == 7)
PriDec.smac_pri = 1;

if (data->qos_table_idx == 0)
ret = rtk_qos_priSel_set(PRIDECTBL_IDX0, &PriDec);
else
ret = rtk_qos_priSel_set(PRIDECTBL_IDX1, &PriDec);

if (ret != 0)
printk("rtk_qos_priSel_set failed\n");

}

The above function is used to configure table type. The first is the Qos Table ID, there are two tables:ID0 and ID1, they are the same.

Qos table configuration

Table type selection

The type of this configuration is to choose




NEXT




<s> static int b53_port_set_pvid(struct switch_dev *dev, int port, int val)
{
struct b53_device *priv = sw_to_b53(dev);

if (val > 15 && is5325(priv))
return -EINVAL;
if (val == 4095 && !priv->allow_vid_4095)
return -EINVAL;

priv->ports[port].pvid = val;

return 0;
}

The above function is used to assign a VID to a specific port. The port parameter of function b53_port_set_pvid is the port number. And the pvid is VID.</s>




NEXT




<s> static u64 rtl930x_read_cam(int idx, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL9300_TBL_L2, 1);

rtl_table_read(q, idx);
for (int i = 0; i < 3; i++)
r[i] = sw_r32(rtl_table_data(q, i));

rtl_table_release(q);

rtl930x_fill_l2_entry(r, e);
if (!e->valid)
return 0;

/* return mac with concatenated vid as unique id */
return ((u64)r[0] << 28) | ((r[1] & 0xffff0000) >> 4) | e->vid;
}

The above function is used to query the MAC table and translate to the unique identifier. In an attempt to find the same vulnerability there, and get rid of the same problem, in this commit, I have a patch that replaces the above call to the rtl93




NEXT




<s> static inline uint16_t get_header_id(const struct tffs_entry_header *header)
{
if (swap_bytes)
return ntohs(header->id);

return header->id;
}

The above function is used to compute the value of id from the following expression.

The id value as calculated by get_header_id(a) is always 0. The expected value is 1. The reason is that a->file_header.id has




NEXT




<s> rtk_api_ret_t rtk_ptp_portTrap_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (enable>=RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicEavTrap(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to setup port trap based on the PTP events. It requires you enter the sub-mode PTP first and select the port you wish to setup PTP. The enable parameter denotes the different ptp events.

To disable, use rtk




NEXT




<s> static inline struct gpio_latch_chip *to_gpio_latch_chip(struct gpio_chip *gc)
{
return container_of(gc, struct gpio_latch_chip, gc);
}

The above function is used to convert a gpio_latch_chip structure pointer.

static struct gpio_latch_chip gpio_latch;

struct gpio_chip gc = {
.label = "latch",
.




NEXT




<s> int mtd_tpl_recoverflag_write(const char *mtd, const bool recovery_active)
{
struct erase_info_user erase_info;
struct uboot_args *args;
uint32_t magic;
int ret = 0;
int fd;

args = malloc(erasesize);
if (!args) {
fprintf(stderr, "Could not allocate memory!\n");
return -1;
}

fd = mtd_check_open(mtd);
if (fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd);
ret = -1;
goto out;
}

/* read first block (containing the magic) */
pread(fd, args, erasesize, 0);

/* set magic to desired value */
magic = TPL_RECOVER_MAGIC;
if (!recovery_active)
magic = TPL_NO_RECOVER_MAGIC;

/* no need to write when magic is already set correctly */
if (magic == args->magic)
goto out;

/* erase first block (containing the magic) */
erase_info.start = 0;
erase_info.length = erasesize;

ret = ioctl(fd, MEMERASE, &erase_info);
if (ret < 0) {
fprintf(stderr, "failed to erase block: %i\n", ret);
goto out;
}

/* write magic to flash */
args->magic = magic;

ret = pwrite(fd, args, erasesize, 0);
if (ret < 0)
fprintf(stderr, "failed to write: %i\n", ret);

sync();
out:
free(args);
close(fd);

return ret;
}

The above function is used to set the magic value. It sets the flag that the bootloader is in recovery mode or not.
The command we'll use to set the magic value will be:
./tpl_recoverflag_write 0:100




NEXT




<s> static int rb4xx_cpld_write_nand(struct rb4xx_cpld *cpld, const void *tx_buf,
unsigned int len)
{
struct spi_message m;
static const u8 cmd = CPLD_CMD_WRITE_NAND;
struct spi_transfer t[3] = {
{
.tx_buf = &cmd,
.len = sizeof(cmd),
}, {
.tx_buf = tx_buf,
.len = len,
.tx_nbits = SPI_NBITS_DUAL,
}, {
.len = 1,
.tx_nbits = SPI_NBITS_DUAL,
},
};

spi_message_init(&m);
spi_message_add_tail(&t[0], &m);
spi_message_add_tail(&t[1], &m);
spi_message_add_tail(&t[2], &m);
return spi_sync(cpld->spi, &m);
}

The above function is used to write to NAND in spi mode (i.e., to talk with the NAND via CPLD SPI interface
rather than directly via NAND controller).

However, it seems to have a potential memory corruption problem in the




NEXT




<s> ret_t rtl8367c_getAsicStormFilterExtMulticastEnable(rtk_uint32 *pEnabled)
{
if(NULL == pEnabled)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_MCAST_EXT_EN_OFFSET, pEnabled);
}

The above function is used to query MC filtering mode of the Extended Storm table.

rtk_uint32 rtl8367c_getAsicStormFilterExtMulticastThreshold(void)
{
return rtl83




NEXT




<s> static netdev_tx_t ag71xx_hard_start_xmit(struct sk_buff *skb,
struct net_device *dev)
{
struct ag71xx *ag = netdev_priv(dev);
struct ag71xx_ring *ring = &ag->tx_ring;
int ring_mask = BIT(ring->order) - 1;
int ring_size = BIT(ring->order);
struct ag71xx_desc *desc;
dma_addr_t dma_addr;
int i, n, ring_min;

if (skb->len <= 4) {
DBG("%s: packet len is too small\n", ag->dev->name);
goto err_drop;
}

dma_addr = dma_map_single(&ag->pdev->dev, skb->data, skb->len,
DMA_TO_DEVICE);

i = ring->curr & ring_mask;
desc = ag71xx_ring_desc(ring, i);

/* setup descriptor fields */
n = ag71xx_fill_dma_desc(ring, (u32) dma_addr, skb->len & ag->desc_pktlen_mask);
if (n < 0)
goto err_drop_unmap;

i = (ring->curr + n - 1) & ring_mask;
ring->buf[i].len = skb->len;
ring->buf[i].skb = skb;

netdev_sent_queue(dev, skb->len);

skb_tx_timestamp(skb);

desc->ctrl &= ~DESC_EMPTY;
ring->curr += n;

/* flush descriptor */
wmb();

ring_min = 2;
if (ring->desc_split)
ring_min *= AG71XX_TX_RING_DS_PER_PKT;

if (ring->curr - ring->dirty >= ring_size - ring_min) {
DBG("%s: tx queue full\n", dev->name);
netif_stop_queue(dev);
}

DBG("%s: packet injected into TX queue\n", ag->dev->name);

/* enable TX engine */
ag71xx_wr(ag, AG71XX_REG_TX_CTRL, TX_CTRL_TXE);

return NETDEV_TX_OK;

err_drop_unmap:
dma_unmap_single(&ag->pdev->dev, dma_addr, skb->len, DMA_TO_DEVICE);

err_drop:
dev->stats.tx_dropped++;

dev_kfree_skb(skb);
return NETDEV_TX_OK;
}

The above function is used to send data from the applications to MAC sublayer by registering packet as an Ag71xx transfer descriptor in a DMA buffer and subsequently starting the data transmission. This function is called whenever an application needs to transmit something over the port. It performs various




NEXT




<s> ret_t rtl8367c_getAsicIGMPMRPRX(rtk_uint32 port, rtk_uint32 *allow_mrp)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

/* Allow Multicast Routing Protocol */
if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MRP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MRP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
*allow_mrp = value;

return RT_ERR_OK;
}

The above function is used to configure the router as an OSPF MED route redistribution point. The method uses the port index to perform an asymmetric data forwarding procedure. To be more specific, if a packet is received by one port, we can use the port




NEXT




<s> static void __md5_Init(struct MD5Context *);
static void __md5_Update(struct MD5Context *, const unsigned char *, unsigned int);
static void __md5_Pad(struct MD5Context *);
static void __md5_Final(unsigned char [16], struct MD5Context *);
static void __md5_Transform(uint32_t [4], const unsigned char [64]);


#define MD5_MAGIC_STR "$1$"
#define MD5_MAGIC_LEN (sizeof(MD5_MAGIC_STR) - 1)
static const unsigned char __md5__magic[] = MD5_MAGIC_STR;


#ifdef i386
#define __md5_Encode memcpy
#define __md5_Decode memcpy
#else /* i386 */

/*
* __md5_Encodes input (uint32_t) into output (unsigned char). Assumes len is
* a multiple of 4.
*/
static void
__md5_Encode(unsigned char *output, uint32_t *input, unsigned int len)
{
unsigned int i, j;

for (i = 0, j = 0; j < len; i++, j += 4) {
output[j] = input[i];
output[j+1] = (input[i] >> 8);
output[j+2] = (input[i] >> 16);
output[j+3] = (input[i] >> 24);
}
}

The above function is used to encode a 32 bit integer into 4 bytes.
*/
static void
__md5_Encode(unsigned char *output, uint32_t *input, unsigned int len)
{
unsigned int i, j;




NEXT




<s> static int rtl8366rb_probe(struct platform_device *pdev)
{
static int rtl8366_smi_version_printed;
struct rtl8366_smi *smi;
int err;

if (!rtl8366_smi_version_printed++)
printk(KERN_NOTICE RTL8366RB_DRIVER_DESC
" version " RTL8366RB_DRIVER_VER"\n");

smi = rtl8366_smi_probe(pdev);
if (IS_ERR(smi))
return PTR_ERR(smi);

smi->clk_delay = 10;
smi->cmd_read = 0xa9;
smi->cmd_write = 0xa8;
smi->ops = &rtl8366rb_smi_ops;
smi->cpu_port = RTL8366RB_PORT_NUM_CPU;
smi->num_ports = RTL8366RB_NUM_PORTS;
smi->num_vlan_mc = RTL8366RB_NUM_VLANS;
smi->mib_counters = rtl8366rb_mib_counters;
smi->num_mib_counters = ARRAY_SIZE(rtl8366rb_mib_counters);

err = rtl8366_smi_init(smi);
if (err)
goto err_free_smi;

platform_set_drvdata(pdev, smi);

err = rtl8366rb_switch_init(smi);
if (err)
goto err_clear_drvdata;

return 0;

err_clear_drvdata:
platform_set_drvdata(pdev, NULL);
rtl8366_smi_cleanup(smi);
err_free_smi:
kfree(smi);
return err;
}

The above function is used to start rtl8366rb_switch. It should be run only a
single time. It registers a

This section shows how rtl8366rb_switch is used by the other drivers in the
system.




NEXT




<s> static int hc_wlan_data_unpack_erd(const u16 tag_id, const u8 *inbuf, size_t inlen,
void *outbuf, size_t *outlen)
{
u16 lzo_ofs, lzo_len;
int ret;

/* Find embedded tag */
ret = routerboot_tag_find(inbuf, inlen, tag_id, &lzo_ofs, &lzo_len);
if (ret) {
pr_debug(RB_HC_PR_PFX "no ERD data for id 0x%04x\n", tag_id);
goto fail;
}

if (lzo_len > inlen) {
pr_debug(RB_HC_PR_PFX "Invalid ERD data length\n");
ret = -EINVAL;
goto fail;
}

ret = lzo1x_decompress_safe(inbuf+lzo_ofs, lzo_len, outbuf, outlen);
if (ret)
pr_debug(RB_HC_PR_PFX "LZO decompression error (%d)\n", ret);

fail:
return ret;
}

The above function is used to unpack the data for ERD packets. The
code starts off by looking up the tag id. An if statement then sees if
tag_id is equal to HC_TAG_HDR_ERD, if so the code below




NEXT




<s> static u64 rtl930x_read_mcast_pmask(int idx)
{
u32 portmask;
/* Read MC_PORTMASK (2) via register RTL9300_TBL_L2 */
struct table_reg *q = rtl_table_get(RTL9300_TBL_L2, 2);

rtl_table_read(q, idx);
portmask = sw_r32(rtl_table_data(q, 0));
portmask >>= 3;
rtl_table_release(q);

pr_debug("%s: Index idx %d has portmask %08x\n", __func__, idx, portmask);

return portmask;
}

The above function is used to extract the mcast portmask of a particular entry in L2 table.</s>




NEXT




<s> rtk_api_ret_t rtk_rate_stormControlExtPortmask_set(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicStormFilterExtEnablePortMask(pmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set storm control Ext portmask.</s>




NEXT




<s> void rtl9300_sds_rxcal_vth_manual(u32 sds_num, bool manual, u32 vth_list[])
{
if (manual) {
rtl9300_sds_field_w(sds_num, 0x2e, 0x0f, 13, 13, 0x1);
rtl9300_sds_field_w(sds_num, 0x2e, 0x13,  5,  3, vth_list[0]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x13,  2,  0, vth_list[1]);
} else {
rtl9300_sds_field_w(sds_num, 0x2e, 0x0f, 13, 13, 0x0);
mdelay(10);
}
}

The above function is used to switch between Auto VTH measurement and manual VTH setting. RTL9380 uses this to
measure Vth every 2.5 seconds, and set the VTH for PDS. Then it switches back to Auto VTH




NEXT




<s> rtk_api_ret_t rtk_igmp_tableFullAction_set(rtk_igmp_tableFullAction_t action)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(action >= IGMP_TABLE_FULL_OP_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIGMPTableFullOP((rtk_uint32)action))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the default table action.


rtk_api_ret_t rtk_igmp_tableFullAction_get(rtk_igmp_tableFullAction_t* action)
{
rtk_api




NEXT




<s> int rtl931x_link_sts_get(u32 sds)
{
u32 sts, sts1, latch_sts, latch_sts1;
if (0){
u32 xsg_sdsid_0, xsg_sdsid_1;

xsg_sdsid_0 = sds < 2 ? sds : (sds - 1) * 2;
xsg_sdsid_1 = xsg_sdsid_0 + 1;

sts = rtl9310_sds_field_r(xsg_sdsid_0, 0x1, 29, 8, 0);
sts1 = rtl9310_sds_field_r(xsg_sdsid_1, 0x1, 29, 8, 0);
latch_sts = rtl9310_sds_field_r(xsg_sdsid_0, 0x1, 30, 8, 0);
latch_sts1 = rtl9310_sds_field_r(xsg_sdsid_1, 0x1, 30, 8, 0);
} else {
u32  asds, dsds;

asds = rtl931x_get_analog_sds(sds);
sts = rtl9310_sds_field_r(asds, 0x5, 0, 12, 12);
latch_sts = rtl9310_sds_field_r(asds, 0x4, 1, 2, 2);

dsds = sds < 2 ? sds : (sds - 1) * 2;
latch_sts1 = rtl9310_sds_field_r(dsds, 0x2, 1, 2, 2);
sts1 = rtl9310_sds_field_r(dsds, 0x2, 1, 2, 2);
}

pr_info("%s: serdes %d sts %d, sts1 %d, latch_sts %d, latch_sts1 %d\n", __func__,
sds, sts, sts1, latch_sts, latch_sts1);

return sts1;
}

The above function is used to dump the SDS link status.

If it fails, it may be due to the fact that the SDS has not been enabled. So the code needs extra work to fix it!

If we look at the init routine, the




NEXT




<s> static inline u32 rotr(u32 val, int bits)
{
return (val >> bits) | (val << (32 - bits));
}

The above function is used to find the last element of an array sorted in ascending order in the above way the last element is at the
end,
//find last element in an array
int lastElem(int a[], int size)
{
int i;




NEXT




<s> ar8xxx_sw_set_mirror_rx_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

mutex_lock(&priv->reg_mutex);
priv->mirror_rx = !!val->value.i;
priv->chip->set_mirror_regs(priv);
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to set a single mirror rx bit that is read from
the sysfs attribute file

/sys/class/net/r8a815b00ca0000_0v1_0v1_0v




NEXT




<s> void rtk_hal_qos_get_table2type(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;
rtk_priority_select_t PriDec;

if (data->qos_table_idx == 0)
ret = rtk_qos_priSel_get(PRIDECTBL_IDX0, &PriDec);
else
ret = rtk_qos_priSel_get(PRIDECTBL_IDX1, &PriDec);

if (ret != 0)
printk("rtk_qos_priSel_set failed\n");
else {
printk("port_pri  = %d\n", PriDec.port_pri);
printk("dot1q_pri = %d\n", PriDec.dot1q_pri);
printk("acl_pri   = %d\n", PriDec.acl_pri);
printk("dscp_pri  = %d\n", PriDec.dscp_pri);
printk("cvlan_pri = %d\n", PriDec.cvlan_pri);
printk("svlan_pri = %d\n", PriDec.svlan_pri);
printk("dmac_pri  = %d\n", PriDec.dmac_pri);
printk("smac_pri  = %d\n", PriDec.smac_pri);
}
}

The above function is used to convert rtk_priority_selection_tbl_t structure to
rtk_qos_priSel_t structure and call corresponding API to obtain the parameters stored
in table. The table is rtk_qos_p




NEXT




<s> be32enc(void *buf, uint32_t u)
{
uint8_t *p = buf;

p[0] = ((uint8_t) ((u >> 24) & 0xff));
p[1] = ((uint8_t) ((u >> 16) & 0xff));
p[2] = ((uint8_t) ((u >> 8) & 0xff));
p[3] = ((uint8_t) (u & 0xff));
}

The above function is used to encode a u32 into a byte buffer. This function is similar to be32dec() except we don't reverse the byte order. This function could be called by
be32enc(x.buf, x.l);




NEXT




<s> uc_bpf_program_tc_attach(uc_vm_t *vm, size_t nargs)
{
struct uc_bpf_fd *f = uc_fn_thisval("bpf.program");
uc_value_t *ifname = uc_fn_arg(0);
uc_value_t *type = uc_fn_arg(1);
uc_value_t *prio = uc_fn_arg(2);

if (!f)
err_return(EINVAL, NULL);

return uc_bpf_set_tc_hook(ifname, type, prio, f->fd);
}

The above function is used to attach bpf program to the traffic passing between host and vm. In this lab, we want to use it to attach our eBPF filter to the vm’s traffic so that only traffic from certain source IP will be let go.






NEXT




<s> rtk_api_ret_t rtk_igmp_dynamicRouterPortAllow_set(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t   retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

RTK_CHK_PORTMASK_VALID(pPortmask);

if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIGMPAllowDynamicRouterPort(pmask))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the port mask that allows to use a dynamic router port for unicast IGMP membership report. The function can configure the port mask for each interface.

rtk_api_ret_t rtk_igmp_dyn




NEXT




<s> uc_value_t *uc_wpa_printf(uc_vm_t *vm, size_t nargs)
{
uc_value_t *level = uc_fn_arg(0);
uc_value_t *ret, **args;
uc_cfn_ptr_t _sprintf;
int l = MSG_INFO;
int i, start = 0;

_sprintf = uc_stdlib_function("sprintf");
if (!sprintf)
return NULL;

if (ucv_type(level) == UC_INTEGER) {
l = ucv_int64_get(level);
start++;
}

if (nargs <= start)
return NULL;

ret = _sprintf(vm, nargs - start);
if (ucv_type(ret) != UC_STRING)
return NULL;

wpa_printf(l, "%s", ucv_string_get(ret));
ucv_put(ret);

return NULL;
}

The above function is used to print a formatted string as an information message. The level argument can be 0 (error), 1 (warning), or any other MSG_[0,1,2,3] constant defined by uc_message.h.





NEXT




<s> static int rtl838x_pie_verify_template(struct rtl838x_switch_priv *priv,
struct pie_rule *pr, int t, int block)
{
int i;

if (!pr->is_ipv6 && pr->sip_m && !rtl838x_pie_templ_has(t, TEMPLATE_FIELD_SIP0))
return -1;

if (!pr->is_ipv6 && pr->dip_m && !rtl838x_pie_templ_has(t, TEMPLATE_FIELD_DIP0))
return -1;

if (pr->is_ipv6) {
if ((pr->sip6_m.s6_addr32[0] ||
pr->sip6_m.s6_addr32[1] ||
pr->sip6_m.s6_addr32[2] ||
pr->sip6_m.s6_addr32[3]) &&
!rtl838x_pie_templ_has(t, TEMPLATE_FIELD_SIP2))
return -1;
if ((pr->dip6_m.s6_addr32[0] ||
pr->dip6_m.s6_addr32[1] ||
pr->dip6_m.s6_addr32[2] ||
pr->dip6_m.s6_addr32[3]) &&
!rtl838x_pie_templ_has(t, TEMPLATE_FIELD_DIP2))
return -1;
}

if (ether_addr_to_u64(pr->smac) && !rtl838x_pie_templ_has(t, TEMPLATE_FIELD_SMAC0))
return -1;

if (ether_addr_to_u64(pr->dmac) && !rtl838x_pie_templ_has(t, TEMPLATE_FIELD_DMAC0))
return -1;

/* TODO: Check more */

i = find_first_zero_bit(&priv->pie_use_bm[block * 4], PIE_BLOCK_SIZE);

if (i >= PIE_BLOCK_SIZE)
return -1;

return i + PIE_BLOCK_SIZE * block;
}

The above function is used to verify template usage, as such, some
variables like smac are not checked due to the current implementation
and will be fixed later.

A bug is found in the "rule_delete" function (only used for deleting one





NEXT




<s> static inline void uninit_pmu(void);
static inline void reset_ppe(struct platform_device *pdev);
static inline void init_pdma(void);
static inline void init_mailbox(void);
static inline void init_atm_tc(void);
static inline void clear_share_buffer(void);

#define IFX_PMU_MODULE_PPE_SLL01  BIT(19)
#define IFX_PMU_MODULE_PPE_TC     BIT(21)
#define IFX_PMU_MODULE_PPE_EMA    BIT(22)
#define IFX_PMU_MODULE_PPE_QSB    BIT(18)
#define IFX_PMU_MODULE_AHBS       BIT(13)
#define IFX_PMU_MODULE_DSL_DFE    BIT(9)


static inline void init_pmu(void)
{
ltq_pmu_enable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_AHBS |
IFX_PMU_MODULE_DSL_DFE);

}

The above function is used to initialize module with IFX_PMU_MODULE_PPE_SLL01, IFX_PMU_MODULE_PPE_TC,
IFX_PMU_MODULE_PPE_EMA, IFX_




NEXT




<s> int gcm_aes_setauthsize (struct crypto_aead *aead, unsigned int authsize)
{
return crypto_gcm_check_authsize(authsize);
}

The above function is used to set the authentication size of the AEAD
algorithm.

In the case of an AEAD algorithm of type GCM, the authentication
size must be such that it is an (integer) multiple of the GHASH digest





NEXT




<s> static int rtl8231_direction_output(struct gpio_chip *gc, unsigned int offset, int value)
{
int err;
struct rtl8231_gpios *gpios = gpiochip_get_data(gc);

pr_debug("%s: %d\n", __func__, offset);
mutex_lock(&miim_lock);
err = rtl8231_pin_dir(gpios, offset, 0);
mutex_unlock(&miim_lock);

if (!err)
err = rtl8231_pin_set(gpios, offset, value);

return err;
}

The above function is used to configure some of the GPIOs in the direction needed by the Atheros software.</s>




NEXT




<s> static bool nmbm_update_single_info_table(struct nmbm_instance *ni,
bool update_main_table)
{
uint32_t write_start_ba, write_limit, table_start_ba, table_end_ba;
bool success;

/* Determine the write range */
if (update_main_table) {
write_start_ba = ni->main_table_ba;
write_limit = ni->backup_table_ba;
} else {
write_start_ba = ni->backup_table_ba;
write_limit = ni->mapping_blocks_top_ba;
}

success = nmbm_write_info_table(ni, write_start_ba, write_limit,
&table_start_ba, &table_end_ba);
if (success) {
if (update_main_table) {
ni->main_table_ba = table_start_ba;
} else {
ni->backup_table_ba = table_start_ba;
ni->mapping_blocks_ba = table_end_ba;
}

nmbm_mark_tables_clean(ni);

nlog_table_update(ni, update_main_table, table_start_ba,
table_end_ba);

return true;
}

if (update_main_table) {
/*
* If failed to update main table, make backup table the new
* main table, and call nmbm_rescue_single_info_table()
*/
nlog_warn(ni, "Unable to update %s info table\n",
update_main_table ? "Main" : "Backup");

ni->main_table_ba = ni->backup_table_ba;
ni->backup_table_ba = 0;
return nmbm_rescue_single_info_table(ni);
}

/* Only one table left */
ni->mapping_blocks_ba = ni->backup_table_ba;
ni->backup_table_ba = 0;

return false;
}

The above function is used to update the single information table for a
block. At block_id=0 there is a backup table for the main table, at
block_id=1 or 2 there is a mapping of physical blocks to logical blocks,
and there




NEXT




<s> DSL_DEV_MeiError_t DSL_BSP_MemoryDebugAccess (DSL_DEV_Device_t *, DSL_BSP_MemoryAccessType_t, DSL_uint32_t, DSL_uint32_t*, DSL_uint32_t);
DSL_DEV_MeiError_t DSL_BSP_SendCMV (DSL_DEV_Device_t *, u16 *, int, u16 *);

int DSL_BSP_KernelIoctls (DSL_DEV_Device_t *, unsigned int, unsigned long);

static DSL_DEV_MeiError_t IFX_MEI_RunAdslModem (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_CpuModeSet (DSL_DEV_Device_t *, DSL_DEV_CpuMode_t);
static DSL_DEV_MeiError_t IFX_MEI_DownloadBootCode (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_ArcJtagEnable (DSL_DEV_Device_t *, int);
static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to print the debug information when the debugging environment is turned on.

The two above functions are used to control the LED of adsl and PSE.

Global data, the two of them are used to record the information of tx_




NEXT




<s> static int b53_mdio_read16(struct b53_device *dev, u8 page, u8 reg, u16 *val)
{
struct mii_bus *bus = dev->priv;
int ret;

ret = b53_mdio_op(dev, page, reg, REG_MII_ADDR_READ);
if (ret)
return ret;

*val = mdiobus_read(bus, B53_PSEUDO_PHY, REG_MII_DATA0);

return 0;
}

The above function is used to read a 16bit MII register (with a 8bit page and 8bit register address). Now, in the MDIO frame being configured for communication, why is the value of 0x80 being written (0x




NEXT




<s> extern int rtl931x_write_sds_phy(int phy_addr, int page, int phy_reg, u16 v);
extern int rtl930x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl930x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);
extern int rtl931x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val);
extern int rtl931x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val);

/* On the RTL93XX, the RTL93XX_DMA_IF_RX_RING_CNTR track the fill level of
* the rings. Writing x into these registers substracts x from its content.
* When the content reaches the ring size, the ASIC no longer adds
* packets to this receive queue.
*/
void rtl838x_update_cntr(int r, int released)
{
/* This feature is not available on RTL838x SoCs */
}

The above function is used to remove packet from the Rx ring and update the counter.
The RTL9282 and rtl9284 only have one ring and hence no problem to remove packet from that ring.
The RTL9322




NEXT




<s> rtk_api_ret_t rtk_vlan_portIgrFilterEnable_set(rtk_port_t port, rtk_enable_t igr_filter)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (igr_filter >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicVlanIngressFilter(rtk_switch_port_L2P_get(port), igr_filter)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set ingress filter flag of L2 port or all ports in an instance in RTK API 3.6.5.


rtk_enable_t rtk_vlan_portIgrFilterEnable_get(rt




NEXT




<s> ret_t rtl8367c_getAsicFlowControlJumboMode(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_FLOWCTRL_JUMBO_SIZE, RTL8367C_JUMBO_MODE_OFFSET, pEnabled);
}

The above function is used to get asic forwarding jumbo frame mode. If jumbo frame is disable, the 8-byte (which is the default size of rtl8367c_getAsicRegBit) is used. If j




NEXT




<s> ret_t rtl8367c_setAsicSpanningTreeStatus(rtk_uint32 port, rtk_uint32 msti, rtk_uint32 state)
{
rtk_uint32  reg_addr,bits_msk;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(msti > RTL8367C_MSTIMAX)
return RT_ERR_MSTI;

if(state > STPST_FORWARDING)
return RT_ERR_MSTP_STATE;

if(port < 8)
return rtl8367c_setAsicRegBits(RTL8367C_VLAN_MSTI_REG(msti,port), RTL8367C_VLAN_MSTI_MASK(port),state);
else{
reg_addr = RTL8367C_VLAN_MSTI_REG(msti,port);
switch(port){
case 8: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT8_STATE_MASK;break;
case 9: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT9_STATE_MASK;break;
case 10: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT10_STATE_MASK;break;
}
return rtl8367c_setAsicRegBits(reg_addr, bits_msk,state);
}
}

The above function is used to enable or disable spanning tree. Its input parameters are:

port ID: indicate the port ID

msti: indicate the instance number of spanning tree protocol

state: indicates the state of the spanning tree






NEXT




<s> rtk_api_ret_t rtk_svlan_servicePort_add(rtk_port_t port)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicSvlanUplinkPortMask(&pmsk)) != RT_ERR_OK)
return retVal;

pmsk = pmsk | (1<<rtk_switch_port_L2P_get(port));

if ((retVal = rtl8367c_setAsicSvlanUplinkPortMask(pmsk)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to bind uplink port to S-VLAN service tag interface. The function is available in SDK from Rev.1.30.</s>




NEXT




<s> ret_t rtl8367c_setAsicRegBit(rtk_uint32 reg, rtk_uint32 bit, rtk_uint32 value)
{

#if defined(RTK_X86_ASICDRV)
rtk_uint32 regData;
ret_t retVal;

if(bit >= RTL8367C_REGBITLENGTH)
return RT_ERR_INPUT;

retVal = Access_Read(reg, 2, &regData);
if(TRUE != retVal)
return RT_ERR_SMI;

if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);

if(value)
regData = regData | (1 << bit);
else
regData = regData & (~(1 << bit));

retVal = Access_Write(reg,2, regData);
if(TRUE != retVal)
return RT_ERR_SMI;

if(0x8367B == cleDebuggingDisplay)
PRINT("W[0x%4.4x]=0x%4.4x\n", reg, regData);


#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)

if(bit >= RTL8367C_REGBITLENGTH)
return RT_ERR_INPUT;

else if(reg >= CLE_VIRTUAL_REG_SIZE)
return RT_ERR_OUT_OF_RANGE;

if(value)
{
CleVirtualReg[reg] =  CleVirtualReg[reg] | (1 << bit);
}
else
{
CleVirtualReg[reg] =  CleVirtualReg[reg] & (~(1 << bit));
}

if(0x8367B == cleDebuggingDisplay)
PRINT("W[0x%4.4x]=0x%4.4x\n", reg, CleVirtualReg[reg]);

#elif defined(EMBEDDED_SUPPORT)
rtk_uint16 tmp;

if(reg > RTL8367C_REGDATAMAX || value > 1)
return RT_ERR_INPUT;

tmp = getReg(reg);
tmp &= (1 << bitIdx);
tmp |= (value << bitIdx);
setReg(reg, tmp);

#else
rtk_uint32 regData;
ret_t retVal;

if(bit >= RTL8367C_REGBITLENGTH)
return RT_ERR_INPUT;

retVal = smi_read(reg, &regData);
if(retVal != RT_ERR_OK)
return RT_ERR_SMI;

#ifdef CONFIG_RTL865X_CLE
if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
#endif
if(value)
regData = regData | (1 << bit);
else
regData = regData & (~(1 << bit));

retVal = smi_write(reg, regData);
if(retVal != RT_ERR_OK)
return RT_ERR_SMI;

#ifdef CONFIG_RTL865X_CLE
if(0x8367B == cleDebuggingDisplay)
PRINT("W[0x%4.4x]=0x%4.4x\n", reg, regData);
#endif

#endif
return RT_ERR_OK;
}

The above function is used to set one single bit on a register at bit location.
Below are some examples of setting bits of some different registers. (Please refer to rtl_cle.h & include/cle_regdef.h for detail) (Bit locations




NEXT




<s> prepare_password(void)
{
static char lbuf[1024];
unsigned char dig[SHA_DIGESTSIZE];
BigInteger x, v, n, g;
SHA1_CTX ctxt;
int ulen = strlen(username);
FILE *f;

lbuf[sizeof(lbuf) - 1] = 0;

f = fopen(passwd_file, "r");
if (!f)
return false;

while (fgets(lbuf, sizeof(lbuf) - 1, f) != NULL) {
char *str, *s2;

if (strncmp(lbuf, username, ulen) != 0)
continue;

if (lbuf[ulen] != ':')
continue;

str = &lbuf[ulen + 1];

if (strncmp(str, "$1$", 3) != 0)
continue;

s2 = strchr(str + 3, '$');
if (!s2)
continue;

if (s2 - str >= MAXSALTLEN)
continue;

strncpy((char *) pw_saltbuf, str, s2 - str);
pw_saltbuf[s2 - str] = 0;

s2 = strchr(s2, ':');
if (!s2)
continue;

*s2 = 0;
if (s2 - str >= MAXPARAMLEN)
continue;

strncpy((char *)password, str, MAXPARAMLEN);
fclose(f);
goto hash_password;
}

/* not found */
fclose(f);
return false;

hash_password:
tce = gettcid(tpe.index);
do {
t_random(tpe.password.data, SALTLEN);
} while (memcmp(saltbuf, (char *)dig, sizeof(saltbuf)) == 0);
if (saltbuf[0] == 0)
saltbuf[0] = 0xff;

n = BigIntegerFromBytes(tce->modulus.data, tce->modulus.len);
g = BigIntegerFromBytes(tce->generator.data, tce->generator.len);
v = BigIntegerFromInt(0);

SHA1Init(&ctxt);
SHA1Update(&ctxt, (unsigned char *) username, strlen(username));
SHA1Update(&ctxt, (unsigned char *) ":", 1);
SHA1Update(&ctxt, (unsigned char *) password, strlen(password));
SHA1Final(dig, &ctxt);

SHA1Init(&ctxt);
SHA1Update(&ctxt, saltbuf, tpe.salt.len);
SHA1Update(&ctxt, dig, sizeof(dig));
SHA1Final(dig, &ctxt);

/* x = H(s, H(u, ':', p)) */
x = BigIntegerFromBytes(dig, sizeof(dig));

BigIntegerModExp(v, g, x, n);
tpe.password.len = BigIntegerToBytes(v, (unsigned char *)pwbuf);

BigIntegerFree(v);
BigIntegerFree(x);
BigIntegerFree(g);
BigIntegerFree(n);
return true;
}

The above function is used to prepare password, and then the variable `tpe` contains a cryptographic `ticket` that is an encrypted password.
We can perform various operations on `tpe`, for example, `tpe.password` and we can see




NEXT




<s> void wpas_ucode_free_bss(struct wpa_supplicant *wpa_s)
{
uc_value_t *val;

val = wpa_ucode_registry_remove(iface_registry, wpa_s->ucode.idx);
if (!val)
return;

wpa_s->ucode.idx = 0;
if (wpa_ucode_call_prepare("iface_remove"))
return;

uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
uc_value_push(ucv_get(val));
ucv_put(wpa_ucode_call(2));
ucv_gc(vm);
}

The above function is used to free resources allocated for each interface's UCODE binding. The wpa_ucode_registry_remove() call removes the element with that index from the interface registry. The element is then pushed to prepare for a call to ucode if




NEXT




<s> static int __init ehci_oxnas_init(void)
{
if (usb_disabled())
return -ENODEV;

ehci_init_driver(&oxnas_hc_driver, &oxnas_overrides);
return platform_driver_register(&ehci_oxnas_driver);
}

The above function is used to register the ehci_oxnas_driver using the platform_driver_register API function. It is also used to initialize the the oxnas host controller driver. The platform_device_register(platform_device); API is used to register the




NEXT




<s> static void sata_oxnas_release_hw(struct ata_port *ap);

static const void *HW_LOCKER_UID = (void *)0xdeadbeef;

/***************************************************************************
* ASIC access
***************************************************************************/
static void wait_cr_ack(void __iomem *phy_base)
{
while ((ioread32(phy_base + PHY_STAT) >> 16) & 0x1f)
; /* wait for an ack bit to be set */
}

The above function is used to write a value to a memory mapped I/O space,
and wait for the ACK bit to be set.

static void sata_oxnas_enable_pio_mode(void __iomem *phy_base)





NEXT




<s> void yyset_out  ( FILE * _out_str  );

int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to simulate the behavior of a non-zero ECHO input
option on the command line, without changing the command line
behavior.  The macro definition can be overridden by an explicit definition
of ECHO in the sc




NEXT




<s> rtk_api_ret_t rtk_trap_lldpEnable_set(rtk_enable_t enabled)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;
rtk_enable_t tmp;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (enabled >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRmaLldp(enabled, &rmacfg)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable lldp

How can i test if this method is actually being set in my lldp settings in the chip?

Thank you.</s>




NEXT




<s> static inline void ar934x_nfc_write_cmd_reg(struct ar934x_nfc *nfc, u32 cmd_reg)
{
wmb();

ar934x_nfc_wr(nfc, AR934X_NFC_REG_CMD, cmd_reg);
/* flush write */
ar934x_nfc_rr(nfc, AR934X_NFC_REG_CMD);
}

The above function is used to write the command registers.

The write will return after 16 clock cycles. So, in the normal case, the write cannot finish within that time due to pipeline latency, and it will never return until the bus is read.





NEXT




<s> static int clk_mt7988_ethsys_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(ARRAY_SIZE(ethdma_clks));

if (!clk_data)
return -ENOMEM;

mtk_clk_register_gates(node, ethdma_clks, ARRAY_SIZE(ethdma_clks),
clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_data;
}
return r;

free_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to register the CLk_eth system provided by mt7988.

However, when the above function ran, the module could not be registered as
clock.

And there is the error information below:

mtk_




NEXT




<s> rtl8306_read_status(struct phy_device *pdev)
{
struct rtl_priv *priv = pdev->priv;
struct switch_dev *dev = &priv->dev;

if (pdev->mdio.addr == 4) {
/* WAN */
pdev->speed = rtl_get(dev, RTL_PORT_REG(4, SPEED)) ? SPEED_100 : SPEED_10;
pdev->duplex = rtl_get(dev, RTL_PORT_REG(4, DUPLEX)) ? DUPLEX_FULL : DUPLEX_HALF;
pdev->link = !!rtl_get(dev, RTL_PORT_REG(4, LINK));
} else {
/* LAN */
pdev->speed = SPEED_100;
pdev->duplex = DUPLEX_FULL;
pdev->link = 1;
}

/*
* Bypass generic PHY status read,
* it doesn't work with this switch
*/
if (pdev->link) {
pdev->state = PHY_RUNNING;
netif_carrier_on(pdev->attached_dev);
pdev->adjust_link(pdev->attached_dev);
} else {
pdev->state = PHY_NOLINK;
netif_carrier_off(pdev->attached_dev);
pdev->adjust_link(pdev->attached_dev);
}

return 0;
}

The above function is used to get the latest link status of the network port, it will report a valid link status to the upper layer driver. In my case, I only want to check the status of the WAN port (4) and to make sure I got that right




NEXT




<s> static u64 rtl839x_read_cam(int idx, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL8390_TBL_L2, 1); /* Access L2 Table 1 */

rtl_table_read(q, idx);
for (int i = 0; i < 3; i++)
r[i] = sw_r32(rtl_table_data(q, i));

rtl_table_release(q);

rtl839x_fill_l2_entry(r, e);
if (!e->valid)
return 0;

pr_debug("Found in CAM: R1 %x R2 %x R3 %x\n", r[0], r[1], r[2]);

/* Return MAC with concatenated VID ac concatenated ID */
return rtl839x_l2_hash_seed(ether_addr_to_u64(&e->mac[0]), e->rvid);
}

The above function is used to generate the CAM index hash value and then find the entry we want.

I have written the l2lookup function in rtl8386_l2lookup.c as follows (i have not added any of the
code




NEXT




<s> rtk_api_ret_t rtk_trunk_trafficSeparate_set(rtk_trunk_group_t trk_gid, rtk_trunk_separateType_t separateType)
{
rtk_api_ret_t retVal;
rtk_uint32 enabled;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (trk_gid != RTK_WHOLE_SYSTEM)
return RT_ERR_LA_TRUNK_ID;

if(separateType >= SEPARATE_END)
return RT_ERR_INPUT;

enabled = (separateType == SEPARATE_FLOOD) ? ENABLED : DISABLED;
if ((retVal = rtl8367c_setAsicTrunkingFlood(enabled)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to adjust the flood configuration among trunk members, including flood control of TX and RX.
The argument trk_gid is used to set the configuration on the whole CPU or a single interface.
The argument separateType specifies whether to enable




NEXT




<s> rtk_api_ret_t rtk_vlan_portFid_set(rtk_port_t port, rtk_enable_t enable, rtk_fid_t fid)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (enable>=RTK_ENABLE_END)
return RT_ERR_ENABLE;

/* fid must be 0~4095 */
if (fid > RTK_FID_MAX)
return RT_ERR_L2_FID;

if ((retVal = rtl8367c_setAsicPortBasedFidEn(rtk_switch_port_L2P_get(port), enable))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicPortBasedFid(rtk_switch_port_L2P_get(port), fid))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set asic port based FID from 0 to 4095 for each ports. The function will take effect only when asic based forwarding is enabled.

The function will return RT_ERR_SUCCESS for success or specific




NEXT




<s> ret_t rtl8367c_getAsicSvlanUntagVlan(rtk_uint32* pIndex)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_UNTAG_UNMAT_CFG, RTL8367C_VS_UNTAG_SVIDX_MASK, pIndex);
}

The above function is used to get the Svlan untag vlan field from register. I am trying to do the above function in my kernel driver by calling the following function,

```
rtl8367c_getAsicRegBits(RT




NEXT




<s> ret_t rtl8367c_setAsicFlowControlPortThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_OFF, RTL8367C_FLOWCTRL_PORT_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_ON, RTL8367C_FLOWCTRL_PORT_ON_MASK, onThreshold);

return retVal;
}

The above function is used to set the flow control port thresholds. The flow control process in the ASIC only reacts to packets entering the ASIC from the outside. A packet exiting the ASIC (for example, on a port after going through the switch or




NEXT




<s> static void button_hotplug_disconnect(struct input_handle *handle)
{
struct bh_priv *priv = handle->private;

input_close_device(handle);
input_unregister_handle(handle);

kfree(priv);
}

The above function is used to terminate the connection between the daemon and the hotplug devices and free the allocated memory. I had another question though. I am implementing the hotplug connection handler on the device side in a daemon and want to know:

1.




NEXT




<s> static void dc_aca_test_init(struct dc_ep_dev *dev, void *soc_base)
{
umt_txin_send(dev, (u8 __iomem *)soc_base, 8);
ppe_txout_send(dev, (TXOUT_PD_DBASE + dev->membase), 8);
ppe_rxout_send(dev, (RXOUT_PD_DBASE + dev->membase), 8);
}

The above function is used to test if there is a single 16-bit
PE-TxIn word on the bus and to test ACA (ACA0-7) bus timings on the
PE-TxOut bus.

dc_aca_




NEXT




<s> static int trelay_remove_release(struct inode *inode, struct file *file)
{
struct trelay *tr, *tmp;

/* This is the only file op that is called outside debugfs_use_file_*()
* context which means that: (1) this file can be removed and
* (2) file->private_data may no longer be valid */
rtnl_lock();
list_for_each_entry_safe(tr, tmp, &trelay_devs, list)
if (tr->to_remove)
trelay_do_remove(tr);
rtnl_unlock();

return 0;
}

The above function is used to release the data structures created by
trelay_create and trelay_add.</s>




NEXT




<s> rtk_api_ret_t rtk_l2_limitSystemLearningCntPortMask_set(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

/* Check port mask */
RTK_CHK_PORTMASK_VALID(pPortmask);

if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicSystemLutLearnPortMask(pmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to setup the system LUT learn to a portmask. The system  LUT learn counts are decremented one by one on each port until the system reaches a zero count in all learn counters. When the learn counter is a zero count,




NEXT




<s> static u64 rtl930x_get_l3_egress_mac(u32 idx)
{
u64 mac;
/* Read L3_EGR_INTF_MAC table (2) via register RTL9300_TBL_2 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_2, 2);

rtl_table_read(r, idx);
/* The table has a size of 2 registers */
mac = sw_r32(rtl_table_data(r, 0));
mac <<= 32;
mac |= sw_r32(rtl_table_data(r, 1));
rtl_table_release(r);

return mac;
}

The above function is used to retrieve the MAC address from its 64 bit index and is used in the FDB_SAR and EROS_SAR tables.

Now, lets analyze this function.
In case of the FDB_SAR table




NEXT




<s> static int rtl839x_pie_rule_del(struct rtl838x_switch_priv *priv, int index_from, int index_to)
{
u32 v = (index_from << 1)| (index_to << 13 ) | BIT(0);

pr_debug("%s: from %d to %d\n", __func__, index_from, index_to);
mutex_lock(&priv->reg_mutex);

/* Write from-to and execute bit into control register */
sw_w32(v, RTL839X_ACL_CLR_CTRL);

/* Wait until command has completed */
do {
} while (sw_r32(RTL839X_ACL_CLR_CTRL) & BIT(0));

mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to delete rule entries from the ACL RAM, it does not modify its corresponding ACL VL, but execute the delete command based on the input parameters. It is a useful function that can delete entries one by one. This function will be used in




NEXT




<s> extern void AT91F_ST_ASM_HANDLER(void);
extern void Jump(unsigned int addr);

const char *menu_dataflash[] = {
#ifdef XMODEM
"1: P DFboot\n",
"2: P U-Boot\n",
#endif
"3: P SDCard\n",
#ifdef	PAGESZ_1056
"4: R UBOOT\n",
#else
"4: R UBOOT\n",
#endif
#ifdef XMODEM
"5: P DF [addr]\n",
#endif
"6: RD DF [addr]\n",
"7: E DF\n"
};

The above function is used to perform DF operations from menu.
The number is the main index for the function.</s>




NEXT




<s> static char item_tag(void)
{
ITEM *cur;
struct mitem *mcur;

cur = current_item(curses_menu);
if (cur == NULL)
return 0;
mcur = (struct mitem *) item_userptr(cur);
return mcur->tag;
}

The above function is used to return the tag of the current item.  In a similar manner, the function below is used to return the text buffer pointer.


static CHAR_DATA *item_text(struct mitem *t, bool retswitch




NEXT




<s> static int wlc_cap(wlc_param param, void *data, void *value)
{
char *iov = *((char **) data);

if (param & GET)
return wl_iovar_get(interface, iov, value, BUFSIZE);

return -1;
}

The above function is used to get/set capabilities of a wifi device
which is nothing but setting/getting values of certain ioctl values. These
values are as under

#define WLC_PHY_SUPPORTED_TURBO 1
#




NEXT




<s> rtk_api_ret_t rtk_igmp_leaveTimer_set(rtk_uint32 timer)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(timer > RTL8367C_MAX_LEAVE_TIMER)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIGMPLeaveTimer(timer))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set leave timer with different period as the default value of leave timer is 3 minutes.</s>




NEXT




<s> static void dc_aca_clk_off(struct dc_ep_priv *priv)
{
dc_ep_clk_off(priv, PMU_ADMA);
}

The above function is used to disable the ACA clock
from FCLK via PMU. We’re not using PMU to request / release
the ACA clock via ACG. Instead, this clock is maintained by
ACG and request / release is managed by




NEXT




<s> void rtk_hal_qos_set_dscp2pri(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;

ret = rtk_qos_dscpPriRemap_set(data->qos_dscp, data->qos_pri);
if (ret != 0)
printk("rtk_qos_dscpPriRemap_set failed\n");
}

The above function is used to map dscp with pri according to dscp value.

We also need to find the pfs value (from 0 to 2) before calling this function. It's used to indicate the mapping range: 0-




NEXT




<s> static void aca_txin_init(struct dc_ep_priv *priv,
struct aca_cfg_param *aca_txin)
{
u32 val = 0;
struct aca_mem_layout *mem_layout = to_mem_layout(priv);
struct aca_hif_params *hif_params = to_hif_params(priv);
struct aca_hif_param *txin_param = &hif_params->txin;

if (aca_txin->byteswap)
val = BYTE_SWAP_EN;

val |= (aca_txin->hd_size_in_dw - 1)
| SM((aca_txin->pd_size_in_dw - 1), PD_DESC_IN_DW);
wr32(val, TXIN_CONV_CFG);

/* SoC cumulative counter address */
wr32(aca_txin->soc_cmlt_cnt_addr, GNRC_TXIN_CMLT_CNT_ADDR);


/* SoC descriptors */
txin_param->soc_desc_base = aca_txin->soc_desc_base;
txin_param->soc_desc_num = aca_txin->soc_desc_num;

/* Ping/pong buffer */
txin_param->pp_buf_base = priv->phymem
+ mem_layout->txin_host_desc_base;

txin_param->pp_buf_num = mem_layout->txin_host_dnum;

/* PD ring */
txin_param->pd_desc_base = priv->phymem
+ aca_txin->pd_desc_base;
txin_param->pd_desc_num = aca_txin->pd_desc_num;

dev_dbg(priv->dev, "aca txin init done\n");
}

The above function is used to initialise TXIN configuration.
aca_txin_init is called during DC_HAL_INIT
with parameters defined in file hw_aca.c.</s>




NEXT




<s> ret_t rtl8367c_setAsicTrunkingHashTable1(rtk_uint32 hashval, rtk_uint32 portId)
{
if(hashval > RTL8367C_TRUNKING_HASHVALUE_MAX)
return RT_ERR_OUT_OF_RANGE;

if(portId >= RTL8367C_TRUNKING1_PORTN0)
return RT_ERR_PORT_ID;

if(hashval >= 8)
return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL3, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH8_MASK<<((hashval-8)*2), portId);
else
return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL2, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH0_MASK<<(hashval*2), portId);
}

The above function is used to set up hash table of trunking.
If you want to set Trunking hash table 1, hashval must be range from 0 to 7.

rtk_uint16 vlan, rtk_uint1




NEXT




<s> int rtl8366_sw_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
struct switch_port *port;
struct rtl8366_vlan_4k vlan4k;
int i;

if (!smi->ops->is_vlan_valid(smi, val->port_vlan))
return -EINVAL;

smi->ops->get_vlan_4k(smi, val->port_vlan, &vlan4k);

port = &val->value.ports[0];
val->len = 0;
for (i = 0; i < smi->num_ports; i++) {
if (!(vlan4k.member & BIT(i)))
continue;

port->id = i;
port->flags = (vlan4k.untag & BIT(i)) ?
0 : BIT(SWITCH_PORT_FLAG_TAGGED);
val->len++;
port++;
}
return 0;
}

The above function is used to query the device which of the switch ports belong to a specific VLAN. If you want to display the VLAN membership of a port in the device's Web interface, you can add a module to the switch that registers this function as a query




NEXT




<s> static inline void dmas_writel(struct bcm6348_iudma *iudma, u32 val, u32 off,
int chan)
{
__raw_writel(val, iudma->dma_sram + chan * DMA_CHAN_WIDTH + off);
}

The above function is used to write 32 bit words to an offset within the
32 bit wide SRAM of the BCM6348 chip. It's part of a larger structure that
also contains a field that holds the address offset of a pointer




NEXT




<s> static bool nmbm_update_info_table(struct nmbm_instance *ni)
{
bool success;

if (ni->protected)
return true;

while (ni->block_state_changed || ni->block_mapping_changed) {
success = nmbm_update_info_table_once(ni, false);
if (!success) {
nlog_err(ni, "Failed to update info table\n");
return false;
}
}

return true;
}

The above function is used to update info table when the block mapping is
changed or block state is changed from the main thread.</s>




NEXT




<s> adm6996_set_pvid(struct switch_dev *dev, int port, int vlan)
{
struct adm6996_priv *priv = to_adm(dev);

pr_devel("set_pvid port %d vlan %d\n", port, vlan);

if (vlan > ADM_VLAN_MAX_ID)
return -EINVAL;

priv->pvid[port] = vlan;

return 0;
}

The above function is used to set pvid in a switch with 802.1q.The function will store the new value of port into the adm6996_priv structure.

In the same time, the program will do pvid translation for




NEXT




<s> add_attr(struct nl_msg *msg, void *ptr)
{
struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
struct attrlist_arg *arg = ptr;
struct switch_attr *new;

if (nla_parse(tb, SWITCH_ATTR_MAX - 1, genlmsg_attrdata(gnlh, 0),
genlmsg_attrlen(gnlh, 0), NULL) < 0)
goto done;

new = swlib_alloc(sizeof(struct switch_attr));
if (!new)
goto done;

new->dev = arg->dev;
new->atype = arg->atype;
if (arg->prev) {
arg->prev->next = new;
} else {
arg->prev = *arg->head;
}
*arg->head = new;
arg->head = &new->next;

if (tb[SWITCH_ATTR_OP_ID])
new->id = nla_get_u32(tb[SWITCH_ATTR_OP_ID]);
if (tb[SWITCH_ATTR_OP_TYPE])
new->type = nla_get_u32(tb[SWITCH_ATTR_OP_TYPE]);
if (tb[SWITCH_ATTR_OP_NAME])
new->name = strdup(nla_get_string(tb[SWITCH_ATTR_OP_NAME]));
if (tb[SWITCH_ATTR_OP_DESCRIPTION])
new->description = strdup(nla_get_string(tb[SWITCH_ATTR_OP_DESCRIPTION]));

done:
return NL_SKIP;
}

The above function is used to add attributes to the message. The `tb` is the
message template of the `struct ifinfomsg` type. In order to parse the template
based on the `NL_CALL(NL_UNITED, NL_AUTO_




NEXT




<s> gettpnam
(user)
const char * user;
{
struct t_pwent * tpptr;
struct t_confent * tcptr;

if(pwinit() < 0)
return NULL;
tpptr = t_getpwbyname(syspw, user);
if(tpptr == NULL)
return NULL;
tcptr =
gettcid
(tpptr->index);
if(tcptr == NULL)
return NULL;
pwsetup(&tpass, tpptr, tcptr);
return &tpass;
}

The above function is used to get a specific users password entry.
It uses the getpwbyname and gettcid functions (which uses
getptent), which are used to get the users pwentry, then the user
conf entry. Both of these should




NEXT




<s> void ifx_deu_des_ofb (void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
ifx_deu_des (ctx, dst, src, iv, nbytes, encdec, 2);
}

The above function is used to encrypt data with Triple DES and CBC/ECB mode. The first two parameters are pointers to structures of the following kind:


typedef struct {
DES_ctx *c;
uint8_t




NEXT




<s> unsigned int mii_mgr_write(unsigned int phy_addr,unsigned int phy_register,unsigned int write_data)
{
struct mii_bus *bus =  _gsw->bus;

mutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);

bus->write(bus, phy_addr, phy_register, write_data);

mutex_unlock(&bus->mdio_lock);

return 0;
}

The above function is used to write the data in the structure to the MDIO.
I used that function to get a successful communication to the external
PHY.
But it was not possible to get a successful communication using ioctl MII_BREADREG and READ_




NEXT




<s> static void aca_xbar_ia_reject_clr(struct dc_ep_priv *priv, int ia_id)
{
u32 val;

/* Check reject bit */
val = rd32(ACA_AGENT_CTRL(ia_id));
if ((val & XBAR_CTRL_REJECT) == 0)
return;

/* Clear reject bit */
val &= ~XBAR_CTRL_REJECT;
wr32(val, ACA_AGENT_CTRL(ia_id));
rd32(ACA_AGENT_CTRL(ia_id));
}

The above function is used to clear the reject bit. When a 3D client
(ACA/GL) uses the ACA XBAR to talk to a 2D client (L3D) and
the 3D client is running out of memory




NEXT




<s> static loff_t ubootenv_llseek(struct file *file, loff_t off, int whence)
{
struct ubootenv_drvdata *data = to_ubootenv_drvdata(file);

return fixed_size_llseek(file, off, whence, data->rmem->size);
}

The above function is used to support SEEK_END and SEEK_CUR when reading from
ubootnvmem. It does not check whether the seeked value is valid, and does not
guarantee readability after the seek. This function is required




NEXT




<s> static inline int ifx_ptm_version(char *buf)
{
int len = 0;
unsigned int major, mid, minor;

ifx_ptm_get_fw_ver(&major, &mid, &minor);

len += ifx_drv_ver(buf + len, "PTM", IFX_PTM_VER_MAJOR, IFX_PTM_VER_MID, IFX_PTM_VER_MINOR);
if ( mid == ~0 )
len += sprintf(buf + len, "    PTM (E1) firmware version %u.%u\n", major, minor);
else
len += sprintf(buf + len, "    PTM (E1) firmware version %u.%u.%u\n", major, mid, minor);

return len;
}

The above function is used to display firmware version of a PTM card. This code is added below to retrieve the firmware version from the hardware.
static void ifx_ptm_get_fw_ver(unsigned int *major, unsigned int *mid,




NEXT




<s> static int esw_get_port_led(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
int idx = val->port_vlan;

if (idx < 0 || idx >= RT305X_ESW_NUM_PORTS ||
idx >= RT305X_ESW_NUM_LEDS)
return -EINVAL;

val->value.i = esw_r32(esw, RT305X_ESW_REG_P0LED + 4*idx);

return 0;
}

The above function is used to fetch the state of each port’s leds. This function is called once for each VLAN in the list of VLANs (as indexed by the port_vlan member of val), using the vlan attribute to index into the




NEXT




<s> ret_t rtl8367c_getAsicIGMPStaticRouterPort(rtk_uint32 *pmsk)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_STATIC_ROUTER_PORT, RTL8367C_IGMP_STATIC_ROUTER_PORT_MASK, pmsk);
}

The above function is used to query the static router port in IGMP snooping engine.
It is used in the IGMP snooping engine initialization flow for the first time to check whether the current system enables igmp snooping or not. If it




NEXT




<s> ret_t rtl8367c_setAsicEavTrap(rtk_uint32 port, rtk_uint32 enabled)
{
if(port > RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_REG_PTP_PORT0_CFG1 + (port * 0x20), RTL8367C_PTP_PORT0_CFG1_OFFSET, enabled);
}

The above function is used to set the asic eav trap for the particular port. In order to configure RTL8367C as a NPE(Network Process Element) , eav trap needs to be set on the NPE ports as in the NPE




NEXT




<s> ret_t rtl8367c_getAsicRldpTxPortmask(rtk_uint32 *pPortmask)
{
return rtl8367c_getAsicReg(RTL8367C_RLDP_TX_PMSK_REG, pPortmask);
}

The above function is used to get the TX Portmask from the HW.
However, rtl8367cx has a HW bug. The HW could not set TX Portmask to the TxPortMask.
So, we need to modify the




NEXT




<s> static void set_bluetitle_theme(void)
{
set_classic_theme();
DLG_COLOR(title,               COLOR_BLUE,   COLOR_WHITE, true);
DLG_COLOR(button_key_active,   COLOR_YELLOW, COLOR_BLUE,  true);
DLG_COLOR(button_label_active, COLOR_WHITE,  COLOR_BLUE,  true);
DLG_COLOR(searchbox_title,     COLOR_BLUE,   COLOR_WHITE, true);
DLG_COLOR(position_indicator,  COLOR_BLUE,   COLOR_WHITE, true);
DLG_COLOR(tag,                 COLOR_BLUE,   COLOR_WHITE, true);
DLG_COLOR(tag_key,             COLOR_BLUE,   COLOR_WHITE, true);

}

The above function is used to set the text, background colors of dialogues etc(the entire game). I've used the classic scheme for the above as I believe they're relatively unobtrusive, unless you want to use high-contrast colors then you have




NEXT




<s> ret_t rtl8367c_setAsicAclActCtrl(rtk_uint32 index, rtk_uint32 aclActCtrl)
{
ret_t retVal;

if(index > RTL8367C_ACLRULEMAX)
return RT_ERR_OUT_OF_RANGE;

if(index >= 64)
retVal = rtl8367c_setAsicRegBits(RTL8367C_ACL_ACTION_CTRL2_REG(index), RTL8367C_ACL_OP_ACTION_MASK(index), aclActCtrl);
else
retVal = rtl8367c_setAsicRegBits(RTL8367C_ACL_ACTION_CTRL_REG(index), RTL8367C_ACL_OP_ACTION_MASK(index), aclActCtrl);

return retVal;
}

The above function is used to configure whether the ACL rule for each ACL action is enabled or disabled. So the parameter ACL_CTRL bit is used. Refer to the following diagram.

For the sake of simplicity, we take 58 as an example.




NEXT




<s> ret_t rtl8367c_getAsicMIBsTimer(rtk_uint32* pTimer)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_MIB_CTRL4, RTL8367C_MIB_TIMER_MASK, pTimer);
}

The above function is used to get the timer.

I tried to get the timer of the above function like as below code:
return rtl8367c_getAsicMIBsTimer(&asicTmr3Minutes);
asic




NEXT




<s> static int rtl8367_write_initvals(struct rtl8366_smi *smi,
const struct rtl8367_initval *initvals,
int count)
{
int err;
int i;

for (i = 0; i < count; i++)
REG_WR(smi, initvals[i].reg, initvals[i].val);

return 0;
}

The above function is used to read the firmware version in the 8370.

int read_chip_firmware_ver(void)
{
int ret;
static unsigned int chip_version[4];
int i;






NEXT




<s> static inline int clk_set(struct dc_ep_dev *dev, u32 sysclk, u32 ppeclk)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_ep_clk_set(dev->priv, sysclk, ppeclk);
}

The above function is used to set the clock values of the device. This function takes as input the system clock and the PPE clock values which need to set on the device.</s>




NEXT




<s> mtd_verify(const char *mtd, char *file)
{
uint32_t f_md5[4], m_md5[4];
struct stat s;
md5_ctx_t ctx;
int ret = 0;
int fd;

if (quiet < 2)
fprintf(stderr, "Verifying %s against %s ...\n", mtd, file);

if (stat(file, &s) || md5sum(file, f_md5) < 0) {
fprintf(stderr, "Failed to hash %s\n", file);
return -1;
}

fd = mtd_check_open(mtd);
if(fd < 0) {
fprintf(stderr, "Could not open mtd device: %s\n", mtd);
return -1;
}

md5_begin(&ctx);
do {
char buf[256];
int len = (s.st_size > sizeof(buf)) ? (sizeof(buf)) : (s.st_size);
int rlen = read(fd, buf, len);

if (rlen < 0) {
if (errno == EINTR)
continue;
ret = -1;
goto out;
}
if (!rlen)
break;
md5_hash(buf, rlen, &ctx);
s.st_size -= rlen;
} while (s.st_size > 0);

md5_end(m_md5, &ctx);

fprintf(stderr, "%08x%08x%08x%08x - %s\n", m_md5[0], m_md5[1], m_md5[2], m_md5[3], mtd);
fprintf(stderr, "%08x%08x%08x%08x - %s\n", f_md5[0], f_md5[1], f_md5[2], f_md5[3], file);

ret = memcmp(f_md5, m_md5, sizeof(m_md5));
if (!ret)
fprintf(stderr, "Success\n");
else
fprintf(stderr, "Failed\n");

out:
close(fd);
return ret;
}

The above function is used to verify that the data stored inside the MTD is accurate.

The two things we need to calculate the hash for are the file used to write the device and the device that was written to (which is read). These are passed in as the




NEXT




<s> static u32 rtl930x_l3_hash4(u32 ip, int algorithm, bool move_dip)
{
u32 rows[4];
u32 hash;
u32 s0, s1, pH;

memset(rows, 0, sizeof(rows));

rows[0] = HASH_PICK(ip, 27, 5);
rows[1] = HASH_PICK(ip, 18, 9);
rows[2] = HASH_PICK(ip, 9, 9);

if (!move_dip)
rows[3] = HASH_PICK(ip, 0, 9);

if (!algorithm) {
hash = rows[0] ^ rows[1] ^ rows[2] ^ rows[3];
} else {
s0 = rows[0] + rows[1] + rows[2];
s1 = (s0 & 0x1ff) + ((s0 & (0x1ff << 9)) >> 9);
pH = (s1 & 0x1ff) + ((s1 & (0x1ff << 9)) >> 9);
hash = pH ^ rows[3];
}
return hash;
}

The above function is used to hash the MAC address to find out in which slot the MAC address will be stored. When L3CST is enabled, the MAC address, L3CST mode and a random value are used to hash the MAC address.

First,




NEXT




<s> static int rtl8218b_ext_phy_probe(struct phy_device *phydev)
{
struct device *dev = &phydev->mdio.dev;
int addr = phydev->mdio.addr;

/* All base addresses of the PHYs start at multiples of 8 */
devm_phy_package_join(dev, phydev, addr & (~7),
sizeof(struct rtl83xx_shared_private));

if (!(addr % 8)) {
struct rtl83xx_shared_private *shared = phydev->shared->priv;
shared->name = "RTL8218B (external)";
if (soc_info.family == RTL8380_FAMILY_ID) {
/* Configuration must be done while patching still possible */
return rtl8380_configure_ext_rtl8218b(phydev);
}
}

return 0;
}

The above function is used to detect RTL8218B_EXT in the external phy mode.</s>




NEXT




<s> static void rtl_init_secondary(void)
{
#ifndef CONFIG_CEVT_R4K
/*
* These devices are low on resources. There might be the chance that CEVT_R4K
* is not enabled in kernel build. Nevertheless the timer and interrupt 7 might
* be active by default after startup of secondary VPE. With no registered
* handler that leads to continuous unhandeled interrupts. In this case disable
* counting (DC) in the core and confirm a pending interrupt.
*/
write_c0_cause(read_c0_cause() | CAUSEF_DC);
write_c0_compare(0);
#endif /* CONFIG_CEVT_R4K */
/*
* Enable all CPU interrupts, as everything is managed by the external
* controller. TODO: Standard vsmp_init_secondary() has special treatment for
* Malta if external GIC is available. Maybe we need this too.
*/
if (mips_gic_present())
pr_warn("%s: GIC present. Maybe interrupt enabling required.\n", __func__);
else
set_c0_status(ST0_IM);
}

The above function is used to initialise all the processor/memory-management
functions (including the timer functions) of CPU-b when CPU-a performs a
processor-switch. (CPU-b could then be initialised as an A2000 secondary





NEXT




<s> rtk_api_ret_t rtk_rate_egrBandwidthCtrlRate_get(rtk_port_t port, rtk_rate_t *pRate, rtk_enable_t *pIfg_include)
{
rtk_api_ret_t retVal;
rtk_uint32 regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pRate)
return RT_ERR_NULL_POINTER;

if(NULL == pIfg_include)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortEgressRate(rtk_switch_port_L2P_get(port), &regData)) != RT_ERR_OK)
return retVal;

*pRate = regData << 3;

if ((retVal = rtl8367c_getAsicPortEgressRateIfg((rtk_uint32*)pIfg_include)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the egress bandwidth setting for the port.

uint8_t
rate_get_ifg_include(port)
{
rtk_rate_t rate;
rtk_port_t port;





NEXT




<s> ret_t rtl8367c_setAsicLutIpmcFwdRouterPort(rtk_uint32 enable)
{
if(enable > 1)
return RT_ERR_ENABLE;

return rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG2, RTL8367C_LUT_IPMC_FWD_RPORT_OFFSET, enable);
}

The above function is used to configure the IPMC FWD port in MAC.  The setting of
1 will enable RGMII mode.

In order to set the above function return the
RT_ERR_ENABLE error code,  we need to change the value




NEXT




<s> static int bcm6368_enetsw_tx_reclaim(struct net_device *ndev, int force,
int budget)
{
struct bcm6368_enetsw *priv = netdev_priv(ndev);
struct platform_device *pdev = priv->pdev;
struct device *dev = &pdev->dev;
unsigned int bytes = 0;
int released = 0;

while (priv->tx_desc_count < priv->tx_ring_size) {
struct bcm6368_enetsw_desc *desc;
struct sk_buff *skb;

/* We run in a bh and fight against start_xmit, which
* is called with bh disabled */
spin_lock(&priv->tx_lock);

desc = &priv->tx_desc_cpu[priv->tx_dirty_desc];

if (!force && (desc->len_stat & DMADESC_OWNER_MASK)) {
spin_unlock(&priv->tx_lock);
break;
}

/* ensure other field of the descriptor were not read
* before we checked ownership */
rmb();

skb = priv->tx_skb[priv->tx_dirty_desc];
priv->tx_skb[priv->tx_dirty_desc] = NULL;
dma_unmap_single(dev, desc->address, skb->len,
DMA_TO_DEVICE);

priv->tx_dirty_desc++;
if (priv->tx_dirty_desc == priv->tx_ring_size)
priv->tx_dirty_desc = 0;
priv->tx_desc_count++;

spin_unlock(&priv->tx_lock);

if (desc->len_stat & DMADESC_UNDER_MASK)
ndev->stats.tx_errors++;

bytes += skb->len;
napi_consume_skb(skb, budget);
released++;
}

netdev_completed_queue(ndev, released, bytes);

if (netif_queue_stopped(ndev) && released)
netif_wake_queue(ndev);

return released;
}

The above function is used to reclaim and release packets currently
in queue for sending for the eth0 interface. This function is executed
as a softirq handler and as
part of the NAPI mechanism. The softirq is called every 10ms, and





NEXT




<s> ret_t rtl8367c_setAsicLutFlushType(rtk_uint32 type)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_L2_FLUSH_CTRL2, RTL8367C_LUT_FLUSH_TYPE_OFFSET,type);
}

The above function is used to set the LUT flush type.
The LUT flush control bit setting can refer to the figure below.

The bit setting in register RTL8367C_REG_L2_FLUSH_CTRL2 is based on




NEXT




<s> ret_t rtl8367c_setAsicRldpIndicatorSource(rtk_uint32 src)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_INDICATOR_SOURCE_OFFSET, src);
}

The above function is used to specify the source of rldp indicator.

In this example, the default source of rldp indicator is set as the value from bit (0,1,2) of RTL8367C_RLDP_IND




NEXT




<s> static void _deu_arc4 (void *ctx_arg, u8 *out_arg, const u8 *in_arg,
u8 *iv_arg, u32 nbytes, int encdec, int mode)
{
volatile struct arc4_t *arc4 = (struct arc4_t *) ARC4_START;

int i = 0;
unsigned long flag;

#if 1 // need to handle nbytes not multiple of 16
volatile u32 tmp_array32[4];
volatile u8 *tmp_ptr8;
int remaining_bytes, j;
#endif

CRTCL_SECT_START;

arc4->IDLEN = nbytes;

#if 1
while (i < nbytes) {
arc4->ID3R = *((u32 *) in_arg + (i>>2) + 0);
arc4->ID2R = *((u32 *) in_arg + (i>>2) + 1);
arc4->ID1R = *((u32 *) in_arg + (i>>2) + 2);
arc4->ID0R = *((u32 *) in_arg + (i>>2) + 3);

arc4->controlr.GO = 1;

while (arc4->controlr.BUS) {
// this will not take long
}

#if 1
// need to handle nbytes not multiple of 16
tmp_array32[0] = arc4->OD3R;
tmp_array32[1] = arc4->OD2R;
tmp_array32[2] = arc4->OD1R;
tmp_array32[3] = arc4->OD0R;

remaining_bytes = nbytes - i;
if (remaining_bytes > 16)
remaining_bytes = 16;

tmp_ptr8 = (u8 *)&tmp_array32[0];
for (j = 0; j < remaining_bytes; j++)
*out_arg++ = *tmp_ptr8++;
#else
*((u32 *) out_arg + (i>>2) + 0) = arc4->OD3R;
*((u32 *) out_arg + (i>>2) + 1) = arc4->OD2R;
*((u32 *) out_arg + (i>>2) + 2) = arc4->OD1R;
*((u32 *) out_arg + (i>>2) + 3) = arc4->OD0R;
#endif

i += 16;
}
#else // dma

#endif // dma

CRTCL_SECT_END;
}

The above function is used to compress plaintext into ciphertext,
encrypted with an arc4 encryption scheme.

Note that the arc4_ctx struct must be passed to the function as a
value. It is not modified. Note that when used to enc




NEXT




<s> static u32 rtl839x_l2_hash_key(struct rtl838x_switch_priv *priv, u64 seed)
{
u32 h1, h2, h;

if (sw_r32(priv->r->l2_ctrl_0) & 1) {
h1 = (u32) (((seed >> 60) & 0x3f) ^ ((seed >> 54) & 0x3f) ^
((seed >> 36) & 0x3f) ^ ((seed >> 30) & 0x3f) ^
((seed >> 12) & 0x3f) ^ ((seed >> 6) & 0x3f));
h2 = (u32) (((seed >> 48) & 0x3f) ^ ((seed >> 42) & 0x3f) ^
((seed >> 24) & 0x3f) ^ ((seed >> 18) & 0x3f) ^
(seed & 0x3f));
h = (h1 << 6) | h2;
} else {
h = (seed >> 60) ^
((((seed >> 48) & 0x3f) << 6) | ((seed >> 54) & 0x3f)) ^
((seed >> 36) & 0xfff) ^ ((seed >> 24) & 0xfff) ^
((seed >> 12) & 0xfff) ^ (seed & 0xfff);
}

return h;
}

The above function is used to hash the destination MAC address and return a single hash value. This function has only been tested for the Intel E1000 driver; if you’re using a different NIC controller, I don’t believe this feature has been implemented:




NEXT




<s> static char *env_expand(const char *name)
{
struct env *e;
const char *value;

if (!*name)
return NULL;

list_for_each_entry(e, &env_list, node) {
if (!strcmp(name, e->name))
return xstrdup(e->value);
}

value = getenv(name);
if (!value)
return NULL;

/*
* We need to remember all referenced environment variables.
* They will be written out to include/config/auto.conf.cmd
*/
env_add(name, value);

return xstrdup(value);
}

The above function is used to expand the value of environment variables from
.config files. It stores a list of all the referenced environment variables.
This list could grow very large (thousands of entries), but will not be
stored by the bootloader.




NEXT




<s> int routerboot_tag_find(const u8 *bufhead, const size_t buflen, const u16 tag_id,
u16 *pld_ofs, u16 *pld_len)
{
const u32 *datum, *bufend;
u32 node;
u16 id, len;
int ret;

if (!bufhead || !tag_id)
return -EINVAL;

ret = -ENOENT;
datum = (const u32 *)bufhead;
bufend = (const u32 *)(bufhead + buflen);

while (datum < bufend) {
node = *datum++;

/* Tag list ends with null node */
if (!node)
break;

id = node & 0xFFFF;
len = node >> 16;

if (tag_id == id) {
if (datum >= bufend)
break;

if (pld_ofs)
*pld_ofs = (u16)((u8 *)datum - bufhead);
if (pld_len)
*pld_len = len;

ret = 0;
break;
}

/*
* The only known situation where len may not end on 32bit
* boundary is within ERD data. Since we're only extracting
* one tag (the first and only one) from that data, we should
* never need to forcefully ALIGN(). Do it anyway, this is not a
* performance path.
*/
len = ALIGN(len, sizeof(*datum));
datum += len / sizeof(*datum);
}

return ret;
}

The above function is used to extract a specific tag from the routerboot
partition. Let us test it with the sample data present in the RP2040.bin
partition which is extracted using the sample application below:

```go
package main





NEXT




<s> ar8216_init_port(struct ar8xxx_priv *priv, int port)
{
__ar8216_init_port(priv, port, ar8xxx_has_gige(priv),
chip_is_ar8316(priv));
}

The above function is used to initialize port.

int __ar8216_init_port(struct ar8xxx_priv *priv, int port, int gige, bool reg512)
{
    struct tl_eth_desc




NEXT




<s> static void m_vendor(const char *id, const uint8_t *value) {
// ITU-T T.35: U.S.
if (U16(value[0], value[1]) != 0xb500)
return;

const char *str = NULL;
switch (U32(value[2], value[3], value[4], value[5])) {
STR_CASE(0x414C4342, "Alcatel")
STR_CASE(0x414E4456, "Analog Devices")
STR_CASE(0x4244434D, "Broadcom")
STR_CASE(0x43454E54, "Centillium")
STR_CASE(0x4753504E, "Globespan")
STR_CASE(0x494B4E53, "Ikanos")
STR_CASE(0x4946544E, "Infineon")
STR_CASE(0x54535443, "Texas Instruments")
STR_CASE(0x544D4D42, "Thomson MultiMedia Broadband")
STR_CASE(0x5443544E, "Trend Chip Technologies")
STR_CASE(0x53544D49, "ST Micro")
};

if (!str)
return;

if ((value[6] == 0) && (value[7] == 0)) {
m_str(id, str);
return;
}

char buf[64];
sprintf(buf, "%s %d.%d", str, value[6], value[7]);
m_str(id, buf);

return;
}

The above function is used to identify ethernet cards by vendor id. This function seems to be working well for some vendors such as Marvell, but seems to be missing some other vendors (such as ADM). Can someone let me know if they have the same issue




NEXT




<s> static int esw_get_port_bool(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
int idx = val->port_vlan;
u32 x, reg, shift;

if (idx < 0 || idx >= RT305X_ESW_NUM_PORTS)
return -EINVAL;

switch (attr->id) {
case RT305X_ESW_ATTR_PORT_DISABLE:
reg = RT305X_ESW_REG_POC0;
shift = RT305X_ESW_POC0_DIS_PORT_S;
break;
case RT305X_ESW_ATTR_PORT_DOUBLETAG:
reg = RT305X_ESW_REG_SGC2;
shift = RT305X_ESW_SGC2_DOUBLE_TAG_S;
break;
case RT305X_ESW_ATTR_PORT_UNTAG:
reg = RT305X_ESW_REG_POC2;
shift = RT305X_ESW_POC2_UNTAG_EN_S;
break;
case RT305X_ESW_ATTR_PORT_LAN:
reg = RT305X_ESW_REG_SGC2;
shift = RT305X_ESW_SGC2_LAN_PMAP_S;
if (idx >= RT305X_ESW_NUM_LANWAN)
return -EINVAL;
break;
default:
return -EINVAL;
}

x = esw_r32(esw, reg);
val->value.i = (x >> (idx + shift)) & 1;

return 0;
}

The above function is used to read out the port attribute, the port attributes can be referenced in “esw.h” file, the port attributes includes:
- PORT_DISABLE
- PORT_DOUBLETAG
- PORT_UNTAG
- PORT_LAN





NEXT




<s> read_trx_header(struct mtd_info *mtd, size_t offset,
struct trx_header *header)
{
size_t header_len;
size_t retlen;
int ret;

header_len = sizeof(*header);
ret = mtd_read(mtd, offset, header_len, &retlen,
(unsigned char *) header);
if (ret) {
pr_debug("read error in \"%s\"\n", mtd->name);
return ret;
}

if (retlen != header_len) {
pr_debug("short read in \"%s\"\n", mtd->name);
return -EIO;
}

return 0;
}

The above function is used to read the MTD header out, the function reads a header out from the target MTD and put the result in the trx_header structure.

The function mtd_read is used to read out the specified data from the MTD




NEXT




<s> ret_t rtl8367c_getAsicMIBsCounter(rtk_uint32 port, RTL8367C_MIBCOUNTER mibIdx, rtk_uint64* pCounter)
{
ret_t retVal;
rtk_uint32 regAddr;
rtk_uint32 regData;
rtk_uint32 mibAddr;
rtk_uint32 mibOff=0;

/* address offset to MIBs counter */
CONST rtk_uint16 mibLength[RTL8367C_MIBS_NUMBER]= {
4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
4,2,2,2,2,2,2,2,2,
4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2};

rtk_uint16 i;
rtk_uint64 mibCounter;


if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(mibIdx >= RTL8367C_MIBS_NUMBER)
return RT_ERR_STAT_INVALID_CNTR;

if(dot1dTpLearnedEntryDiscards == mibIdx)
{
mibAddr = RTL8367C_MIB_LEARNENTRYDISCARD_OFFSET;
}
else
{
i = 0;
mibOff = RTL8367C_MIB_PORT_OFFSET * port;

if(port > 7)
mibOff = mibOff + 68;

while(i < mibIdx)
{
mibOff += mibLength[i];
i++;
}

mibAddr = mibOff;
}


/*writing access counter address first*/
/*This address is SRAM address, and SRAM address = MIB register address >> 2*/
/*then ASIC will prepare 64bits counter wait for being retrived*/
/*Write Mib related address to access control register*/
retVal = rtl8367c_setAsicReg(RTL8367C_REG_MIB_ADDRESS, (mibAddr >> 2));
if(retVal != RT_ERR_OK)
return retVal;



/* polling busy flag */
i = 100;
while(i > 0)
{
/*read MIB control register*/
retVal = rtl8367c_getAsicReg(RTL8367C_MIB_CTRL_REG,&regData);
if(retVal != RT_ERR_OK)
return retVal;

if((regData & RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK) == 0)
{
break;
}

i--;
}

if(regData & RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK)
return RT_ERR_BUSYWAIT_TIMEOUT;

if(regData & RTL8367C_RESET_FLAG_MASK)
return RT_ERR_STAT_CNTR_FAIL;

mibCounter = 0;
i = mibLength[mibIdx];
if(4 == i)
regAddr = RTL8367C_MIB_COUNTER_BASE_REG + 3;
else
regAddr = RTL8367C_MIB_COUNTER_BASE_REG + ((mibOff + 1) % 4);

while(i)
{
retVal = rtl8367c_getAsicReg(regAddr, &regData);
if(retVal != RT_ERR_OK)
return retVal;

mibCounter = (mibCounter << 16) | (regData & 0xFFFF);

regAddr --;
i --;

}

*pCounter = mibCounter;

return RT_ERR_OK;
}

The above function is used to fetch the counters from ASIC. As I mentioned previously, the address of these counters in ASIC is given by formula (MIB register address>>2) So the above function starts by polling the busy bit in MIB COUN




NEXT




<s> ret_t rtl8367c_setReservedVidAction(rtk_uint32 vid0Action, rtk_uint32 vid4095Action)
{
ret_t   retVal;

if(vid0Action >= RES_VID_ACT_END)
return RT_ERR_INPUT;

if(vid4095Action >= RES_VID_ACT_END)
return RT_ERR_INPUT;

if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_VID0_TYPE_OFFSET, vid0Action)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_VID4095_TYPE_OFFSET, vid4095Action)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the VLAN reserved VID to be used as untagged VLAN. When enabled, the VID is used to match the packet to be untagged when the packet's VID is tagged to be 0 or 




NEXT




<s> ret_t rtl8367c_getAsicIGMPCRCErrOP(rtk_uint32 *poperation)
{
ret_t   retVal;
rtk_uint32  value;

/* CRC Error Operation */
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_CKS_ERR_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;

*poperation = value;

return RT_ERR_OK;
}

The above function is used to retrieve the IGMP CRC Error Operation value.The IGMP/MLD message is protected by cyclic redundancy check (CRC) to prevent the malicious packets to join. For IGMP/MLD CRC error,




NEXT




<s> static AT91S_DataFlashStatus AT91F_PageErase(
AT91PS_DataFlash pDataFlash,
unsigned int page)
{
int cmdsize;
/* Test if the buffer command is legal */
/* no data to transmit or receive */
pDataFlash->pDataFlashDesc->tx_data_size = 0;

cmdsize = 4;
if (pDataFlash->pDevice->pages_number >= 16384)
cmdsize = 5;
return(AT91F_DataFlashSendCommand(pDataFlash, DB_PAGE_ERASE, cmdsize,
page*pDataFlash->pDevice->pages_size));
}

The above function is used to blank all 512 bytes on the selected page.</s>




NEXT




<s> unmap_block_bbt(u16 block)
{
bbt_set_block_state(block, false);
}

The above function is used to unmap the specified block. The block in question should obviously already be mapped before such an unmap is issued. This is due to the fact that the B-tree must take the mapping status into account before it does anything with a block. If




NEXT




<s> ar8xxx_write(struct ar8xxx_priv *priv, int reg, u32 val)
{
struct mii_bus *bus = priv->mii_bus;
u16 r1, r2, page;

split_addr((u32) reg, &r1, &r2, &page);

mutex_lock(&bus->mdio_lock);

bus->write(bus, 0x18, 0, page);
wait_for_page_switch();
ar8xxx_mii_write32(priv, 0x10 | r2, r1, val);

mutex_unlock(&bus->mdio_lock);
}

The above function is used to write to arbitrary register of the PHY in the
Ar83xx series MCU.

The problem is the function uses mutex to protect access of MDIO line between
processes in the same PHY. It results in reduced




NEXT




<s> static void check_enc_dec(const int enc)
{
if (enc == -1)
return;
fprintf(stderr, "Error: both -d and -e were specified.\n");
exit(EXIT_FAILURE);
}

The above function is used to ensure that -d and -e are not both specified, in this case, I want -e to be used, this is why the function only compares enc to -1, and to a value (enc) given by the compiler. Now




NEXT




<s> void dc_aca_free_fw_file(struct dc_ep_priv *priv)
{
struct aca_fw_info *fw_info = to_fw_info(priv);

if (fw_info->fw && !IS_ERR(fw_info->fw))
release_firmware(fw_info->fw);

fw_info->fw = NULL;
fw_info->fw_data = NULL;
fw_info->fw_len = 0;
}

The above function is used to deallocate all resources, which were used in the dc_aca_load_fw_file function. The above function is to be called at the end of executing every firmware.</s>




NEXT




<s> ret_t rtl8367c_setAsicIGMPRobVar(rtk_uint32 rob_var)
{
ret_t  retVal;

if(rob_var > RTL8367C_MAX_ROB_VAR)
return RT_ERR_OUT_OF_RANGE;

/* Bourstness variable */
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_ROBURSTNESS_VAR_MASK, rob_var);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the ROB burstness variable (rob_var) in the IGMP router table via RTL8367C register interface.

I would like to know if it is possible set a value for ROBURSTNESS




NEXT




<s> static int aca_soc_desc_alloc(int dev)
{
dma_addr_t phy_addr;
void *base;
u32 size;

if (dev < 0 || dev > (DC_EP_MAX_PEER + 1))
return -EINVAL;

/* TXIN */
size = TXIN_SOC_DES_NUM * TXIN_HD_DES_SIZE * 4;
base  = dma_alloc_coherent(NULL, size, &phy_addr, GFP_DMA);
if (!base)
goto txin;
aca_soc_hd_desc[dev].txin.base = base;
aca_soc_hd_desc[dev].txin.phy_base = phy_addr;
aca_soc_hd_desc[dev].txin.size = size;
pr_info("txin soc desc base %p phy 0x%08x size 0x%08x\n",
base, (u32)phy_addr, size);

/* TXOUT */
size = TXOUT_SOC_DES_NUM * TXOUT_HD_DES_SIZE * 4;
base  = dma_alloc_coherent(NULL, size, &phy_addr, GFP_DMA);
if (!base)
goto txout;
aca_soc_hd_desc[dev].txout.base = base;
aca_soc_hd_desc[dev].txout.phy_base = phy_addr;
aca_soc_hd_desc[dev].txout.size = size;
pr_info("txout soc desc base %p phy 0x%08x size 0x%08x\n",
base, (u32)phy_addr, size);
/* RXOUT */
size = RXOUT_SOC_DES_NUM * RXOUT_HD_DES_SIZE * 4;
base  = dma_alloc_coherent(NULL, size, &phy_addr, GFP_DMA);
if (!base)
goto rxout;
aca_soc_hd_desc[dev].rxout.base = base;
aca_soc_hd_desc[dev].rxout.phy_base = phy_addr;
aca_soc_hd_desc[dev].rxout.size = size;
pr_info("rxout soc desc base %p phy 0x%08x size 0x%08x\n",
base, (u32)phy_addr, size);
return 0;
rxout:
dma_free_coherent(NULL, aca_soc_hd_desc[dev].txout.size,
aca_soc_hd_desc[dev].txout.base,
aca_soc_hd_desc[dev].txout.phy_base);
txout:
dma_free_coherent(NULL, aca_soc_hd_desc[dev].txin.size,
aca_soc_hd_desc[dev].txin.base,
aca_soc_hd_desc[dev].txin.phy_base);
txin:
return -ENOMEM;
}

The above function is used to allocate buffer pages for the descriptor.
It will call dma_alloc_coherent function internally. The first thing we
need to do is to decide the size of the buffer pages. This depends on the
device number, since the




NEXT




<s> int item_count(void)
{
int n = 0;
struct dialog_list *p;

for (p = item_head; p; p = p->next)
n++;
return n;
}

The above function is used to find out how many item the user have at list/trader and so on.

I just wonder: if the list contains an item with 5 stacks, it will be count out as five items when p points to it, right




NEXT




<s> static int md5_hmac_setkey_hw(const u8 *key, unsigned int keylen)
{
volatile struct deu_hash_t *hash = (struct deu_hash_t *) HASH_START;
int i, j;
u32 *in_key = (u32 *)key;

//printk("\nsetkey keylen: %d\n key: ", keylen);

hash->KIDX |= 0x80000000; // reset all 16 words of the key to '0'
j = 0;
for (i = 0; i < keylen; i+=4)
{
hash->KIDX = j;
asm("sync");
hash->KEY = *((u32 *) in_key + j);
asm("sync");
j++;
}

return 0;
}

The above function is used to fill the first 16 words of the hash state structure with given key.</s>




NEXT




<s> UInt32 RangeDecoderDecodeDirectBits(CRangeDecoder *rd, int numTotalBits)
{
RC_INIT_VAR
UInt32 result = 0;
int i;
for (i = numTotalBits; i > 0; i--)
{
/* UInt32 t; */
range >>= 1;

result <<= 1;
if (code >= range)
{
code -= range;
result |= 1;
}
/*
t = (code - range) >> 31;
t &= 1;
code -= range & (t - 1);
result = (result + result) | (1 - t);
*/
RC_NORMALIZE
}
RC_FLUSH_VAR
return result;
}

The above function is used to decode a string of directly coded bits. The result, and the state of the decoder, is as if range bits were decoded by sequentially running over this bitstream and making three decisions:
2^(range - 1)




NEXT




<s> void br_shutdown(void)
{
close(br_socket_fd);
br_socket_fd = -1;
}

The above function is used to shutdown, I was curious as to whether after having called this function from the program, I could then open a connection to the same socket.

The answer is yes as the port is in use by the program, it won't let




NEXT




<s> static int __init adm6996_init(void)
{
int err;

phy_register_fixup_for_id(PHY_ANY_ID, adm6996_fixup);
err = phy_driver_register(&adm6996_phy_driver, THIS_MODULE);
if (err)
return err;

err = platform_driver_register(&adm6996_gpio_driver);
if (err)
phy_driver_unregister(&adm6996_phy_driver);

return err;
}

The above function is used to perform following activities.
1.Registers adm6996_phy_driver as physical interface.
2.Registers adm6996_gpio_driver as platform driver.

The following is the content of the adm




NEXT




<s> ret_t rtl8367c_getAsicFlowControlSystemThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_SYS_OFF, RTL8367C_FLOWCTRL_SYS_OFF_MASK, pOffThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_SYS_ON, RTL8367C_FLOWCTRL_SYS_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to retrieve system flow control off and system flow control on thresholds from hardware.
By using these thresholds and the method as per IEEE802.3x , the host can determine the link state through the method as below .




NEXT




<s> rtk_api_ret_t rtk_vlan_transparent_set(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask)
{
rtk_api_ret_t retVal;
rtk_uint32    pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(egr_port);

if(NULL == pIgr_pmask)
return RT_ERR_NULL_POINTER;

RTK_CHK_PORTMASK_VALID(pIgr_pmask);

if(rtk_switch_portmask_L2P_get(pIgr_pmask, &pmask) != RT_ERR_OK)
return RT_ERR_FAILED;

if ((retVal = rtl8367c_setAsicVlanTransparent(rtk_switch_port_L2P_get(egr_port), pmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set VLAN transparent and add the port to the transparent port mask which is created in the step above.</s>




NEXT




<s> static int aes_cbcmac_setkey(struct crypto_shash *tfm, const u8 *key, unsigned int keylen)
{
return aes_set_key(crypto_shash_tfm(tfm), key, keylen);

return 0;
}

The above function is used to setup the AES Context while configuring the AES-MAC driver to use the key from the AES context.

The AES-MAC is setup in the following way by following the above call:

#define SHA51




NEXT




<s> rtl_get_port_link(struct switch_dev *dev, int port, struct switch_port_link *link)
{
if (port >= RTL8306_NUM_PORTS)
return -EINVAL;

/* in case the link changes from down to up, the register is only updated on read */
link->link = rtl_get(dev, RTL_PORT_REG(port, LINK));
if (!link->link)
link->link = rtl_get(dev, RTL_PORT_REG(port, LINK));

if (!link->link)
return 0;

link->duplex = rtl_get(dev, RTL_PORT_REG(port, DUPLEX));
link->aneg = rtl_get(dev, RTL_PORT_REG(port, NWAY));

if (rtl_get(dev, RTL_PORT_REG(port, SPEED)))
link->speed = SWITCH_PORT_SPEED_100;
else
link->speed = SWITCH_PORT_SPEED_10;

return 0;
}

The above function is used to collect various info related to the port such as the link bit, duplex bit and speed bit for a single port on the switch. The port_link bit is always checked with the link bit. If the port link bit is 0, the




NEXT




<s> static void expr_print_revdep(struct expr *e,
void (*fn)(void *, struct symbol *, const char *),
void *data, tristate pr_type, const char **title)
{
if (e->type == E_OR) {
expr_print_revdep(e->left.expr, fn, data, pr_type, title);
expr_print_revdep(e->right.expr, fn, data, pr_type, title);
} else if (expr_calc_value(e) == pr_type) {
if (*title) {
fn(data, NULL, *title);
*title = NULL;
}

fn(data, NULL, "  - ");
expr_print(e, fn, data, E_NONE);
fn(data, NULL, "\n");
}
}

The above function is used to print the output of ggc.</s>




NEXT




<s> static int rtl8366s_sw_reset_port_mibs(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

if (val->port_vlan >= RTL8366S_NUM_PORTS)
return -EINVAL;


return rtl8366_smi_rmwr(smi, RTL8366S_MIB_CTRL_REG,
0, (1 << (val->port_vlan + 3)));
}

The above function is used to reset the switch counters:


Note that this function is a simple wrapper to rtl8366_sw_reset_port_mibs
It calls rtl8366_smi_rmwr with




NEXT




<s> static int rtl838x_mdio_reset(struct mii_bus *bus)
{
pr_debug("%s called\n", __func__);
/* Disable MAC polling the PHY so that we can start configuration */
sw_w32(0x00000000, RTL838X_SMI_POLL_CTRL);

/* Enable PHY control via SoC */
sw_w32_mask(0, 1 << 15, RTL838X_SMI_GLB_CTRL);

/* Probably should reset all PHYs here... */
return 0;
}

The above function is used to reset a MAC device. First of all, we disable the so-called MAC_POLLING feature using the SMI_GKT_POLL_CTRL register and set bit[15] to 1 for enabling the SMI




NEXT




<s> void	 red_LED_on(void)
{
AT91PS_PIO	PIOB	= AT91C_BASE_PIOB;
//	PIOB->PIO_CODR		= RED_LED;
PIOB->PIO_CODR		= (1 << 2);
}

The above function is used to turn off red LED.

void	 green_LED_on(void)
{
AT91PS_PIO	PIOB	= AT91C_BASE_PIOB;
//	PIOB->PIO_CO




NEXT




<s> rtk_api_ret_t rtk_dot1x_macBasedEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsic1xMBEnConfig(rtk_switch_port_L2P_get(port),enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set whether MAC addresses are used to generate the dot1x port access control policies.

rtk_dot1x_macBasedEnable_set() is used to set the parameter “enable” as follows:

If “enable”




NEXT




<s> ret_t rtl8367c_getAsicRemarkingDot1pParameter(rtk_uint32 priority, rtk_uint32 *pNewPriority )
{
if(priority > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_getAsicRegBits(RTL8367C_QOS_1Q_REMARK_REG(priority), RTL8367C_QOS_1Q_REMARK_MASK(priority), pNewPriority);
}

The above function is used to get 802.1Q dot1p parameter of a specific priority.

rtk_uint32 priority;
rtk_uint32 newPriority;
rtk_uint32 priority = 1;





NEXT




<s> ret_t rtl8367c_setAsicAclUnmatchedPermit(rtk_uint32 port, rtk_uint32 enabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_ACL_UNMATCH_PERMIT_REG, port, enabled);
}

The above function is used to configure per ACL per port matching behavior.

1. If ACL Unmatched permit is enabled

When the in-band ACL match logic failed, the traffic is marked as a “unmatched packet” and permitted to output the




NEXT




<s> rtl_hw_init(struct switch_dev *dev)
{
struct rtl_priv *priv = to_rtl(dev);
int cpu_mask = 1 << dev->cpu_port;
int i;

rtl_set(dev, RTL_REG_VLAN_ENABLE, 0);
rtl_set(dev, RTL_REG_VLAN_FILTER, 0);
rtl_set(dev, RTL_REG_EN_TRUNK, 0);
rtl_set(dev, RTL_REG_TRUNK_PORTSEL, 0);

/* initialize cpu port settings */
if (priv->do_cpu) {
rtl_set(dev, RTL_REG_CPUPORT, dev->cpu_port);
rtl_set(dev, RTL_REG_EN_CPUPORT, 1);
} else {
rtl_set(dev, RTL_REG_CPUPORT, 7);
rtl_set(dev, RTL_REG_EN_CPUPORT, 0);
}
rtl_set(dev, RTL_REG_EN_TAG_OUT, 0);
rtl_set(dev, RTL_REG_EN_TAG_IN, 0);
rtl_set(dev, RTL_REG_EN_TAG_CLR, 0);

/* reset all vlans */
for (i = 0; i < RTL8306_NUM_VLANS; i++) {
rtl_set(dev, RTL_VLAN_REG(i, VID), i);
rtl_set(dev, RTL_VLAN_REG(i, PORTMASK), 0);
}

/* default to port isolation */
for (i = 0; i < RTL8306_NUM_PORTS; i++) {
unsigned long mask;

if ((1 << i) == cpu_mask)
mask = ((1 << RTL8306_NUM_PORTS) - 1) & ~cpu_mask; /* all bits set */
else
mask = cpu_mask | (1 << i);

rtl_set(dev, RTL_VLAN_REG(i, PORTMASK), mask);
rtl_set(dev, RTL_PORT_REG(i, PVID), i);
rtl_set(dev, RTL_PORT_REG(i, NULL_VID_REPLACE), 1);
rtl_set(dev, RTL_PORT_REG(i, VID_INSERT), 1);
rtl_set(dev, RTL_PORT_REG(i, TAG_INSERT), 3);
}
rtl_hw_apply(dev);
}

The above function is used to configure default hardware configuration, so that it will initialize the switch device after being opened.
And it will use it as the default configuration when switch device is created by create_switch_dev function.

Therefore, let us analyze it line




NEXT




<s> static void rtl838x_hw_en_rxtx(struct rtl838x_eth_priv *priv)
{
/* Disable Head of Line features for all RX rings */
sw_w32(0xffffffff, priv->r->dma_if_rx_ring_size(0));

/* Truncate RX buffer to DEFAULT_MTU bytes, pad TX */
sw_w32((DEFAULT_MTU << 16) | RX_TRUNCATE_EN_83XX | TX_PAD_EN_838X, priv->r->dma_if_ctrl);

/* Enable RX done, RX overflow and TX done interrupts */
sw_w32(0xfffff, priv->r->dma_if_intr_msk);

/* Enable DMA, engine expects empty FCS field */
sw_w32_mask(0, RX_EN | TX_EN, priv->r->dma_if_ctrl);

/* Restart TX/RX to CPU port */
sw_w32_mask(0x0, 0x3, priv->r->mac_port_ctrl(priv->cpu_port));
/* Set Speed, duplex, flow control
* FORCE_EN | LINK_EN | NWAY_EN | DUP_SEL
* | SPD_SEL = 0b10 | FORCE_FC_EN | PHY_MASTER_SLV_MANUAL_EN
* | MEDIA_SEL
*/
sw_w32(0x6192F, priv->r->mac_force_mode_ctrl + priv->cpu_port * 4);

/* Enable CRC checks on CPU-port */
sw_w32_mask(0, BIT(3), priv->r->mac_port_ctrl(priv->cpu_port));
}

The above function is used to enable RX/TX from the user to the CPU port.</s>




NEXT




<s> static int aes_cbcmac_final(struct shash_desc *desc, u8 *out)
{
return aes_cbcmac_final_impl(desc, out, true);
}

The above function is used to wrap up (hash) message digest after the message has been written. Here is the implementation of aes_cbcmac_final function:

static int
aes_cbcmac_xor_key(int size, const




NEXT




<s> psb6970_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct psb6970_priv *priv = to_psb6970(dev);
val->value.i = priv->vlan;
return 0;
}

The above function is used to get the valna configuration of the device. It takes as input the device, the attribute and the value structure which is used to store the value returned. The `priv’ variable is the private data associated with the device containing the VLAN configuration.




NEXT




<s> void menu_add_dep(struct expr *dep)
{
current_entry->dep = expr_alloc_and(current_entry->dep, dep);
}

The above function is used to add a new dependency, which may be of complex type, such as (a < b). If the user does not call it with proper precautions, there will be memory leaks.

I wonder if there is another function which takes




NEXT




<s> rtk_api_ret_t rtk_stat_port_get(rtk_port_t port, rtk_stat_port_type_t cntr_idx, rtk_stat_counter_t *pCntr)
{
rtk_api_ret_t       retVal;
RTL8367C_MIBCOUNTER mib_idx;
rtk_stat_counter_t  second_cnt;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pCntr)
return RT_ERR_NULL_POINTER;

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if (cntr_idx>=STAT_PORT_CNTR_END)
return RT_ERR_STAT_INVALID_PORT_CNTR;

if((retVal = _get_asic_mib_idx(cntr_idx, &mib_idx)) != RT_ERR_OK)
return retVal;

if(mib_idx == MIB_NOT_SUPPORT)
return RT_ERR_CHIP_NOT_SUPPORTED;

if ((retVal = rtl8367c_getAsicMIBsCounter(rtk_switch_port_L2P_get(port), mib_idx, pCntr)) != RT_ERR_OK)
return retVal;

if(cntr_idx == STAT_EtherStatsMulticastPkts)
{
if((retVal = _get_asic_mib_idx(STAT_IfOutMulticastPkts, &mib_idx)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicMIBsCounter(rtk_switch_port_L2P_get(port), mib_idx, &second_cnt)) != RT_ERR_OK)
return retVal;

*pCntr += second_cnt;
}

if(cntr_idx == STAT_EtherStatsBroadcastPkts)
{
if((retVal = _get_asic_mib_idx(STAT_IfOutBroadcastPkts, &mib_idx)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicMIBsCounter(rtk_switch_port_L2P_get(port), mib_idx, &second_cnt)) != RT_ERR_OK)
return retVal;

*pCntr += second_cnt;
}

return RT_ERR_OK;
}

The above function is used to get a port counter through a counter index. It returns an RTK API enumerated value indicating a success.

RTK_CHK_INIT_STATE();

rtk_api_ret_t _get_asic_




NEXT




<s> static int rtl8366rb_sw_get_port_disable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

if (val->port_vlan >= RTL8366RB_NUM_PORTS)
return -EINVAL;

rtl8366_smi_read_reg(smi, RTL8366RB_PECR, &data);
if (data & (1 << val->port_vlan))
val->value.i = 1;
else
val->value.i = 0;

return 0;
}

The above function is used to get the port status. If a physical port is
disabled by an RTL8366RB switch, then its bit will be '1', else it will be
'0'. It is a read-only attribute.

static




NEXT




<s> static void aw9523_irq_unmask(struct irq_data *d)
{
struct aw9523 *awi = gpiochip_get_data(irq_data_get_irq_chip_data(d));
unsigned int n = d->hwirq % AW9523_PINS_PER_PORT;

regmap_update_bits(awi->regmap,
AW9523_REG_INTR_DIS(d->hwirq),
BIT(n), 0);
}

The above function is used to unmask an IRQ request on an aw9523 port.  But
n is the irq number, and not a pin number.   So I modified it to be:

unsigned int n = d->hwirq;





NEXT




<s> rtk_api_ret_t rtk_ptp_portIntStatus_get(rtk_port_t port, rtk_ptp_intStatus_t *pStatusMask)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port is PTP port */
RTK_CHK_PORT_IS_PTP(port);

if(NULL == pStatusMask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicEavPortInterruptStatus(rtk_switch_port_L2P_get(port), pStatusMask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get PTP Port interrupt status.</s>




NEXT




<s> ret_t rtl8367c_getAsicEavPortEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
{
if(port > RTL8367C_PORTNO)
return RT_ERR_PORT_ID;



if(port < 5)
return rtl8367c_getAsicRegBit(RTL8367C_EAV_PORT_CFG_REG(port), RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
else if(port == 5)
return rtl8367c_getAsicRegBit(RTL8367C_REG_P5_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
else if(port == 6)
return rtl8367c_getAsicRegBit(RTL8367C_REG_P6_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
else if(port == 7)
return rtl8367c_getAsicRegBit(RTL8367C_REG_P7_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
else if(port == 8)
return rtl8367c_getAsicRegBit(RTL8367C_REG_P8_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
else if(port == 9)
return rtl8367c_getAsicRegBit(RTL8367C_REG_P9_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);


return RT_ERR_OK;
}

The above function is used to get port EAV enable status.

In the above function, EAV_PORT_CFG registers reside in different chip areas.

The EAV_PORT_CFG registers are located at following regions:</s>




NEXT




<s> rtk_api_ret_t rtk_eee_init(void)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if((retVal = rtl8367c_setAsicRegBit(0x0018, 10, 1)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_setAsicRegBit(0x0018, 11, 1)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure 802.3az feature in 8367C chip. It could make the port or link go into low power mode when it's possible.

The configuration parameters is as follows:

  Bit           




NEXT




<s> static bool nmbm_create_info_table(struct nmbm_instance *ni)
{
uint32_t lb;
bool success;

/* Set initial mapping_blocks_top_off  */
success = nmbm_block_walk(ni, false, ni->signature_ba,
&ni->mapping_blocks_top_ba, 1,
ni->mgmt_start_ba);
if (!success) {
nlog_err(ni, "No room for spare blocks\n");
return false;
}

/* Generate info table cache */
nmbm_generate_info_table_cache(ni);

/* Write info table */
success = nmbm_rebuild_info_table(ni);
if (!success) {
nlog_err(ni, "Failed to build info tables\n");
return false;
}

/* Remap bad block(s) at end of data area */
for (lb = ni->data_block_count; lb < ni->mgmt_start_ba; lb++) {
success = nmbm_map_block(ni, lb);
if (!success)
break;

ni->data_block_count++;
}

/* If state table and/or mapping table changed, update info table. */
success = nmbm_update_info_table(ni);
if (!success)
return false;

return true;
}

The above function is used to build and validate the device’s NMBM implementation. It’s the core of the build path and relies on a few other functions.

Here’s the key points in the routine:

- Creates the info table cache




NEXT




<s> ret_t rtl8367c_getAsicPortUnknownSaBehavior(rtk_uint32 *pBehavior)
{
return rtl8367c_getAsicRegBits(RTL8367C_PORT_SECURIT_CTRL_REG, RTL8367C_UNKNOWN_SA_BEHAVE_MASK, pBehavior);
}

The above function is used to get the current unknown(unlearned) Sa behavior mode. We will use this to change the ROM port behavior. This is not the same with the port security. Port security(PortLearn) setting is just to make the R




NEXT




<s> ret_t rtl8367c_getAsicPortMirrorRxFunction(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_RX_OFFSET, pEnabled);
}

The above function is used to get the enable bit of mirror rx function.

If we use this function to get the value of this enable bit and it returns value zero, it would mean mirror rx function was not enabled.

Now according to mirror rx function description,




NEXT




<s> gpio_latch_direction_output(struct gpio_chip *gc, unsigned offset, int value)
{
struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
bool enable_latch = false;
bool disable_latch = false;
int ret;

if (offset == glc->le_gpio) {
enable_latch = value ^ glc->le_active_low;
disable_latch = !enable_latch;
}

gpio_latch_lock(glc, enable_latch);
ret = gpiod_direction_output_raw(glc->gpios[offset], value);
gpio_latch_unlock(glc, disable_latch);

return ret;
}

The above function is used to set GPIO pin to an output state, or an input, in the case that an attached device requires it. An argument containing a Boolean value is used to enable, or disable, the ‘latch’ property of the GPIO pin being modified. If




NEXT




<s> static void bcm6368_enetsw_disable_dma(struct bcm6368_enetsw *priv, int chan)
{
int limit = 1000;

dmac_writel(priv, 0, DMAC_CHANCFG_REG, chan);

do {
u32 val;

val = dma_readl(priv, DMAC_CHANCFG_REG, chan);
if (!(val & DMAC_CHANCFG_EN_MASK))
break;

udelay(1);
} while (limit--);
}

The above function is used to disable channel10 and channel11 used for RL1024 and MF1024 when disabling the DMA channels.
When I disable the DMA channel through commandline I still see the LED being blinking at my




NEXT




<s> static int phyreg_open(struct inode *inode, struct file *file)
{
return single_open(file, phyreg_show, 0);
}

The above function is used to open the file where the user can see what a
kernel module is doing. The below function is called when the file is
closed by the user.

static int phyreg_release(struct inode *inode, struct file *file




NEXT




<s> ret_t rtl8367c_setAsicStormFilterExtUnknownUnicastMeter(rtk_uint32 meter)
{
if(meter > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

return rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG1, RTL8367C_UNUC_STORM_EXT_METERIDX_MASK, meter);
}

The above function is used to set the meter ID for unknown unicast traffic based on a given meter index. The function gets a 32-bit unsigned integer value as parameter, i.e., this function provides up to 32 meter IDs for unknown un




NEXT




<s> int wpa_ucode_call_prepare(const char *fname)
{
uc_value_t *obj, *func;

if (!registry)
return -1;

obj = ucv_array_get(registry, 0);
if (!obj)
return -1;

func = ucv_object_get(obj, fname, NULL);
if (!ucv_is_callable(func))
return -1;

uc_vm_stack_push(&vm, ucv_get(obj));
uc_vm_stack_push(&vm, ucv_get(func));

return 0;
}

The above function is used to prepare a call to a function exported by
WPA-supplicant-ucode. It expects a string containing the function name,
and returns a negative error code on failures.

All functions exposed by this plugin use a single




NEXT




<s> static int witness(BIGNUM *w, const BIGNUM *a, const BIGNUM *a1,
const BIGNUM *a1_odd, int k, BN_CTX *ctx, BN_MONT_CTX *mont);

/*
* This is the safe prime generation logic.
* To generate a safe prime p (where p = 2q+1 and q is prime), we start
* with a random odd q that is one bit shorter than the desired length
* of p.  We use a simple 30-element sieve to filter the values of q
* and consider only those that are 11, 23, or 29 (mod 30).  (If q were
* anything else, either q or p would be divisible by 2, 3, or 5).
* For the values of q that are left, we apply the following tests in
* this order:
*
*   trial divide q
*   let p = 2q + 1
*   trial divide p
*   apply Fermat test to q (2^q == 2 (mod q))
*   apply Fermat test to p (2^p == 2 (mod p))
*   apply real probablistic primality test to q
*   apply real probablistic primality test to p
*
* A number that passes all these tests is considered a safe prime for
* our purposes.  The tests are ordered this way for efficiency; the
* slower tests are run rarely if ever at all.
*/

static int
trialdiv(x)
const BigInteger x;
{
static int primes[] = {               /* All odd primes < 256 */
3,   5,   7,  11,  13,  17,  19,  23,  29,
31,  37,  41,  43,  47,  53,  59,  61,  67,
71,  73,  79,  83,  89,  97, 101, 103,
107, 109, 113, 127, 131, 137, 139, 149, 151,
157, 163, 167, 173, 179, 181, 191, 193, 197,
199, 211, 223, 227, 229, 233, 239, 241, 251
};
static int nprimes = sizeof(primes) / sizeof(int);
int i;

for(i = 0; i < nprimes; ++i) {
if(BigIntegerModInt(x, primes[i]) == 0)
return primes[i];
}
return 1;
}

The above function is used to determine the trial factors of a number.
The function itself is very straightforward using the modulo operation.

static int
trialsieve(x)
const BigInteger x;
{
int d;

for(d =




NEXT




<s> static int trelay_do_add(char *name, char *devn1, char *devn2)
{
struct net_device *dev1, *dev2;
struct trelay *tr, *tr1;
int ret;

tr = kzalloc(sizeof(*tr) + strlen(name) + 1, GFP_KERNEL);
if (!tr)
return -ENOMEM;

rtnl_lock();
rcu_read_lock();

ret = -EEXIST;
list_for_each_entry(tr1, &trelay_devs, list) {
if (!strcmp(tr1->name, name))
goto out;
}

ret = -ENOENT;
dev1 = dev_get_by_name_rcu(&init_net, devn1);
dev2 = dev_get_by_name_rcu(&init_net, devn2);
if (!dev1 || !dev2)
goto out;

ret = netdev_rx_handler_register(dev1, trelay_handle_frame, dev2);
if (ret < 0)
goto out;

ret = netdev_rx_handler_register(dev2, trelay_handle_frame, dev1);
if (ret < 0) {
netdev_rx_handler_unregister(dev1);
goto out;
}

dev_hold(dev1);
dev_hold(dev2);

strcpy(tr->name, name);
tr->dev1 = dev1;
tr->dev2 = dev2;
list_add_tail(&tr->list, &trelay_devs);

trelay_log(KERN_INFO, tr, "started");

tr->debugfs = debugfs_create_dir(name, debugfs_dir);
debugfs_create_file("remove", S_IWUSR, tr->debugfs, tr, &fops_remove);
ret = 0;

out:
rcu_read_unlock();
rtnl_unlock();
if (ret < 0)
kfree(tr);

return ret;
}

The above function is used to add a trelay. It’s implemented by looking up the names of devices in the trelay and checking for the existence of a trelay called name. If a trelay existed, the check would fail. If not, then the trelay




NEXT




<s> int rtl931x_read_phy(u32 port, u32 page, u32 reg, u32 *val)
{
u32 v;

if (port > 63 || page > 4095 || reg > 31)
return -ENOTSUPP;

mutex_lock(&smi_lock);

sw_w32(port << 5, RTL931X_SMI_INDRT_ACCESS_BC_PHYID_CTRL);

v = reg << 6 | page << 11 | 1;
sw_w32(v, RTL931X_SMI_INDRT_ACCESS_CTRL_0);

do {
} while (sw_r32(RTL931X_SMI_INDRT_ACCESS_CTRL_0) & 0x1);

v = sw_r32(RTL931X_SMI_INDRT_ACCESS_CTRL_0);
*val = sw_r32(RTL931X_SMI_INDRT_ACCESS_CTRL_3);
*val = (*val & 0xffff0000) >> 16;

pr_debug("%s: port %d, page: %d, reg: %x, val: %x, v: %08x\n",
__func__, port, page, reg, *val, v);

mutex_unlock(&smi_lock);

return 0;
}

The above function is used to read data from a specific PHY
register, and as shown by the logs in the last few lines of
code, a log entry is printed in the dmesg for the same. This
logs the input values to the function, and




NEXT




<s> char *expand_dollar(const char **str)
{
return expand_dollar_with_args(str, 0, NULL);
}

The above function is used to expand dollar signs as if they weren't in quotes.
expand_dollar_with_args is more sophisticated.

static char *expand_dollar_with_args(const char **str, int arg, char **args




NEXT




<s> static ssize_t rtl8366_read_debugfs_vlan_4k(struct file *file,
char __user *user_buf,
size_t count, loff_t *ppos)
{
struct rtl8366_smi *smi = (struct rtl8366_smi *)file->private_data;
int i, len = 0;
int offset;
char *buf = smi->buf;

if (smi->dbg_vlan_4k_page >= RTL8366_VLAN4K_NUM_PAGES) {
len += snprintf(buf + len, sizeof(smi->buf) - len,
"invalid page: %u\n", smi->dbg_vlan_4k_page);
return simple_read_from_buffer(user_buf, count, ppos, buf, len);
}

len += snprintf(buf + len, sizeof(smi->buf) - len,
"%4s %6s %6s %3s\n",
"vid", "member", "untag", "fid");

offset = RTL8366_VLAN4K_PAGE_SIZE * smi->dbg_vlan_4k_page;
for (i = 0; i < RTL8366_VLAN4K_PAGE_SIZE; i++) {
struct rtl8366_vlan_4k vlan4k;

smi->ops->get_vlan_4k(smi, offset + i, &vlan4k);

len += snprintf(buf + len, sizeof(smi->buf) - len,
"%4d 0x%04x 0x%04x %3d\n",
vlan4k.vid, vlan4k.member,
vlan4k.untag, vlan4k.fid);
}

return simple_read_from_buffer(user_buf, count, ppos, buf, len);
}

The above function is used to show the current VLAN4K setting in EEPROM.

However, in kernel module, we have to do quite a lot of works to do the
following things:

1. Get access from RX buffer





NEXT




<s> ret_t rtl8367c_getAsicIGMPv3Opeartion(rtk_uint32 port, rtk_uint32 *igmpv3_op)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

/* IGMPv3 operation */
if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV3_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV3_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}

*igmpv3_op = value;

return RT_ERR_OK;
}

The above function is used to get current IGMPv3 Operation setting in RTL8367B.
Please refer to the rtl8367e_igmp.h for the detailed definition of
parameters and possible return value.</s>




NEXT




<s> static int qca807x_report_length(struct phy_device *phydev,
int pair, int result)
{
int length;
int ret;

ret = phy_read_mmd(phydev, MDIO_MMD_PCS, QCA807X_CDT_MMD3_MDI0_LENGTH + pair);
if (ret < 0)
return ret;

switch (result) {
case ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT:
length = (FIELD_GET(QCA807X_CDT_SAME_SHORT_LENGTH_MASK, ret) * 800) / 10;
break;
case ETHTOOL_A_CABLE_RESULT_CODE_OPEN:
case ETHTOOL_A_CABLE_RESULT_CODE_CROSS_SHORT:
length = (FIELD_GET(QCA807X_CDT_CROSS_SHORT_LENGTH_MASK, ret) * 800) / 10;
break;
}

ethnl_cable_test_fault_length(phydev, pair, length);

return 0;
}

The above function is used to read the fault length of a cable test from the PHY register,
but it can’t get the right result.
The reason may be that QCA807x only implements the same mode and cross mode and
no mixed mode




NEXT




<s> BN_MONT_CTX *BN_MONT_CTX_new(void)
{
BN_MONT_CTX *ret;

if ((ret=(BN_MONT_CTX *)malloc(sizeof(BN_MONT_CTX))) == NULL)
return(NULL);

BN_MONT_CTX_init(ret);
ret->flags=BN_FLG_MALLOCED;
return(ret);
}

The above function is used to create a new Montgomery context variable.
Since we already have all the BN_*_CTX types, we should be able figure out the meaning of this as well. I know it has something to do with Montgomery modular calculations.





NEXT




<s> ret_t rtl8367c_setAsicSvlanTpid(rtk_uint32 protocolType)
{
return rtl8367c_setAsicReg(RTL8367C_REG_VS_TPID, protocolType);
}

The above function is used to set VS tag protocol type which is used to filter packet with certain VS tag type. If the mac address is matched, the packet will be filtered according to VL tag header and certain VS tag protocol type(tagType). If the




NEXT




<s> ret_t rtl8367c_setAsicLedOperationMode(rtk_uint32 mode)
{
ret_t retVal;

/* Invalid input parameter */
if( mode >= LEDOP_END)
return RT_ERR_INPUT;

switch(mode)
{
case LEDOP_PARALLEL:
if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_LED_SELECT_OFFSET, 0))!=  RT_ERR_OK)
return retVal;
/*Disable serial CLK mode*/
if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SCAN0_LED_IO_EN1,RTL8367C_LED_SERI_CLK_EN_OFFSET, 0))!=  RT_ERR_OK)
return retVal;
/*Disable serial DATA mode*/
if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SCAN0_LED_IO_EN1,RTL8367C_LED_SERI_DATA_EN_OFFSET, 0))!=  RT_ERR_OK)
return retVal;
break;
case LEDOP_SERIAL:
if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_LED_SELECT_OFFSET, 1))!=  RT_ERR_OK)
return retVal;
/*Enable serial CLK mode*/
if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SCAN0_LED_IO_EN1,RTL8367C_LED_SERI_CLK_EN_OFFSET, 1))!=  RT_ERR_OK)
return retVal;
/*Enable serial DATA mode*/
if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SCAN0_LED_IO_EN1,RTL8367C_LED_SERI_DATA_EN_OFFSET, 1))!=  RT_ERR_OK)
return retVal;
break;
default:
return RT_ERR_INPUT;
break;
}

return RT_ERR_OK;
}

The above function is used to set the LED operating mode. It is available in the file:
rtl8367c_defconfig.c

To use this function, you can do it in two ways, you have to include this file in your program




NEXT




<s> rtk_api_ret_t rtk_qos_priMap_get(rtk_queue_num_t queue_num, rtk_qos_pri2queue_t *pPri2qid)
{
rtk_api_ret_t retVal;
rtk_uint32 pri;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((0 == queue_num) || (queue_num > RTK_MAX_NUM_OF_QUEUE))
return RT_ERR_QUEUE_NUM;

for (pri = 0; pri <= RTK_PRIMAX; pri++)
{
if ((retVal = rtl8367c_getAsicPriorityToQIDMappingTable(queue_num-1, pri, &pPri2qid->pri2queue[pri])) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to get the mapping between QID and PRI.</s>




NEXT




<s> rtk_api_ret_t rtk_cpu_tagPosition_get(rtk_cpu_position_t *pPosition)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPosition)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicCputagPosition(pPosition)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the tagging position register value.
rtl8367c_getAsicCputagPosition, which is a new function defined in this document, is the basic entry function.

In addition to the function in as




NEXT




<s> static void fe_tx_timeout(struct net_device *dev, unsigned int txqueue)
{
struct fe_priv *priv = netdev_priv(dev);
struct fe_tx_ring *ring = &priv->tx_ring;

priv->netdev->stats.tx_errors++;
netif_err(priv, tx_err, dev,
"transmit timed out\n");
netif_info(priv, drv, dev, "dma_cfg:%08x\n",
fe_reg_r32(FE_REG_PDMA_GLO_CFG));
netif_info(priv, drv, dev, "tx_ring=%d, "
"base=%08x, max=%u, ctx=%u, dtx=%u, fdx=%hu, next=%hu\n",
0, fe_reg_r32(FE_REG_TX_BASE_PTR0),
fe_reg_r32(FE_REG_TX_MAX_CNT0),
fe_reg_r32(FE_REG_TX_CTX_IDX0),
fe_reg_r32(FE_REG_TX_DTX_IDX0),
ring->tx_free_idx,
ring->tx_next_idx);
netif_info(priv, drv, dev,
"rx_ring=%d, base=%08x, max=%u, calc=%u, drx=%u\n",
0, fe_reg_r32(FE_REG_RX_BASE_PTR0),
fe_reg_r32(FE_REG_RX_MAX_CNT0),
fe_reg_r32(FE_REG_RX_CALC_IDX0),
fe_reg_r32(FE_REG_RX_DRX_IDX0));

if (!test_and_set_bit(FE_FLAG_RESET_PENDING, priv->pending_flags))
schedule_work(&priv->pending_work);
}

The above function is used to call when TSO packet sending from DMA fails.
It prints some registesers and re-call a scheduled work to re-start PHY RTT. But this will not work if no more packet pending in TSO
ring or it




NEXT




<s> static inline void dma_writel(struct bcm6348_iudma *iudma, u32 val, u32 off)
{
spin_lock(&iudma->dma_base_lock);
__raw_writel(val, iudma->dma_base + off);
spin_unlock(&iudma->dma_base_lock);
}

The above function is used to write data to iocdma base address.
Now look at the below code in this driver.

static inline u32 dma_readl(struct bcm6348_iudma *iudma,unsigned




NEXT




<s> void rtl931x_sw_init(struct rtl838x_switch_priv *priv)
{
/*	rtl931x_sds_init(priv); */
}

The above function is used to initialise the switch. It calls function rtl931x_sds_init(priv) to carry out switch setup.

This function contains an if loop that uses the variable qid to check the value of the index.




NEXT




<s> rt305x_esw_get_bc_status(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

val->value.i = esw->bc_storm_protect;

return 0;
}

The above function is used to get BC storm protection state.

In the following example the value is 0, which means the BC storm protection is turned on.

# /bin/systemctl stop rt305x_esw_rtctl start rt




NEXT




<s> indicate_writing(const char *mtd)
{
if (quiet < 2)
fprintf(stderr, "\nWriting from %s to %s ... ", imagefile, mtd);

if (!quiet)
fprintf(stderr, " [ ]");
}

The above function is used to give a console indication on the progress of a flashing operation for a NAND-based device. The function takes a pointer to an MTD partition name and performs one of two operations:

> 1. Either adds the character (i




NEXT




<s> ret_t rtl8367c_setAsicPortUnknownMulticastFloodingPortmask(rtk_uint32 portmask)
{
if(portmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

return rtl8367c_setAsicReg(RTL8367C_UNMCAST_FLOADING_PMSK_REG, portmask);
}

The above function is used to set Unicast flooding based on Port mask to all port.</s>




NEXT




<s> ret_t rtl8367c_setAsicVlan4kEntry(rtl8367c_user_vlan4kentry *pVlan4kEntry )
{
rtk_uint16              vlan_4k_entry[RTL8367C_VLAN_4KTABLE_LEN];
rtk_uint32                  page_idx;
rtk_uint16                  *tableAddr;
ret_t                   retVal;
rtk_uint32                  regData;

if(pVlan4kEntry->vid > RTL8367C_VIDMAX)
return RT_ERR_VLAN_VID;

if(pVlan4kEntry->mbr > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

if(pVlan4kEntry->untag > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

if(pVlan4kEntry->fid_msti > RTL8367C_FIDMAX)
return RT_ERR_L2_FID;

if(pVlan4kEntry->meteridx > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(pVlan4kEntry->vbpri > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

memset(vlan_4k_entry, 0x00, sizeof(rtk_uint16) * RTL8367C_VLAN_4KTABLE_LEN);
_rtl8367c_Vlan4kStUser2Smi(pVlan4kEntry, vlan_4k_entry);

/* Prepare Data */
tableAddr = vlan_4k_entry;
for(page_idx = 0; page_idx < RTL8367C_VLAN_4KTABLE_LEN; page_idx++)
{
regData = *tableAddr;
retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_WRDATA_BASE + page_idx, regData);
if(retVal != RT_ERR_OK)
return retVal;

tableAddr++;
}

/* Write Address (VLAN_ID) */
regData = pVlan4kEntry->vid;
retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_ADDR_REG, regData);
if(retVal != RT_ERR_OK)
return retVal;

/* Write Command */
retVal = rtl8367c_setAsicRegBits(RTL8367C_TABLE_ACCESS_CTRL_REG, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK,RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_WRITE,TB_TARGET_CVLAN));
if(retVal != RT_ERR_OK)
return retVal;

#if defined(CONFIG_RTL8367C_ASICDRV_TEST)
memcpy(&Rtl8370sVirtualVlanTable[pVlan4kEntry->vid], pVlan4kEntry, sizeof(rtl8367c_user_vlan4kentry));
#endif

return RT_ERR_OK;
}

The above function is used to enter a virtual VLAN entry.</s>




NEXT




<s> struct symbol *sym_lookup(const char *name, int flags)
{
struct symbol *symbol;
char *new_name;
int hash;

if (name) {
if (name[0] && !name[1]) {
switch (name[0]) {
case 'y': return &symbol_yes;
case 'm': return &symbol_mod;
case 'n': return &symbol_no;
}
}
hash = strhash(name) % SYMBOL_HASHSIZE;

for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
if (symbol->name &&
!strcmp(symbol->name, name) &&
(flags ? symbol->flags & flags
: !(symbol->flags & (SYMBOL_CONST|SYMBOL_CHOICE))))
return symbol;
}
new_name = xstrdup(name);
} else {
new_name = NULL;
hash = 0;
}

symbol = xmalloc(sizeof(*symbol));
memset(symbol, 0, sizeof(*symbol));
symbol->name = new_name;
symbol->type = S_UNKNOWN;
symbol->flags = flags;

symbol->next = symbol_hash[hash];
symbol_hash[hash] = symbol;

return symbol;
}

The above function is used to lookup for names of all kinds. A new struct symbol is created if the name has not already been added to the symbol_hash array, but can be of unknown type (not yet specified using symbol_type) on a first encounter.






NEXT




<s> void rtl9300_do_rx_calibration_2_3(int sds_num)
{
u32 fgcal_binary, fgcal_gray;
u32 offset_range;

pr_info("start_1.2.3 Foreground Calibration\n");

while(1) {
if (!(sds_num % 2))
rtl930x_write_sds_phy(sds_num, 0x1f, 0x2, 0x2f);
else
rtl930x_write_sds_phy(sds_num -1 , 0x1f, 0x2, 0x31);

/* ##Page0x2E, Reg0x15[9], REG0_RX_EN_TEST=[1] */
rtl9300_sds_field_w(sds_num, 0x2e, 0x15, 9, 9, 0x1);
/* ##Page0x21, Reg0x06[11 6], REG0_RX_DEBUG_SEL=[1 0 x x x x] */
rtl9300_sds_field_w(sds_num, 0x21, 0x06, 11, 6, 0x20);
/* ##Page0x2F, Reg0x0C[5 0], REG0_COEF_SEL=[0 0 1 1 1 1] */
rtl9300_sds_field_w(sds_num, 0x2f, 0x0c, 5, 0, 0xf);
/* ##FGCAL read gray */
fgcal_gray = rtl9300_sds_field_r(sds_num, 0x1f, 0x14, 5, 0);
/* ##Page0x2F, Reg0x0C[5 0], REG0_COEF_SEL=[0 0 1 1 1 0] */
rtl9300_sds_field_w(sds_num, 0x2f, 0x0c, 5, 0, 0xe);
/* ##FGCAL read binary */
fgcal_binary = rtl9300_sds_field_r(sds_num, 0x1f, 0x14, 5, 0);

pr_info("%s: fgcal_gray: %d, fgcal_binary %d\n",
__func__, fgcal_gray, fgcal_binary);

offset_range = rtl9300_sds_field_r(sds_num, 0x2e, 0x15, 15, 14);

if (fgcal_binary > 60 || fgcal_binary < 3) {
if (offset_range == 3) {
pr_info("%s: Foreground Calibration result marginal!", __func__);
break;
} else {
offset_range++;
rtl9300_sds_field_w(sds_num, 0x2e, 0x15, 15, 14, offset_range);
rtl9300_do_rx_calibration_2_2(sds_num);
}
} else {
break;
}
}
pr_info("%s: end_1.2.3\n", __func__);
}

The above function is used to calibrate the received signal.
This function is called by function rtl930x_do_rxcal_calibrate. This function is also called by function rtl9300_open. This function is called




NEXT




<s> rtk_api_ret_t rtk_switch_logicalPortCheck(rtk_port_t logicalPort)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(logicalPort >= RTK_SWITCH_PORT_NUM)
return RT_ERR_FAILED;

if(halCtrl->l2p_port[logicalPort] == 0xFF)
return RT_ERR_FAILED;

return RT_ERR_OK;
}

The above function is used to check whether the specified logical port is correct. If not, an error will be returned directly.

# 5.2 Physical port to logical port mapping

When configuring static forwarding for switching ports, the port must be bound to




NEXT




<s> rtk_api_ret_t rtk_svlan_trapPri_set(rtk_pri_t priority)
{
rtk_api_ret_t   retVal;

RTK_CHK_INIT_STATE();

if(priority > RTL8367C_PRIMAX)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicSvlanTrapPriority(priority);

return retVal;
}   /* end of rtk_svlan_trapPri_set */

The above function is used to set the SVLAN trap priority.

The corresponding call in the SDK/Example application is:

```
retVal = rtl8367clib_setSvlanTrapPri(priority)
``




NEXT




<s> rtk_api_ret_t rtk_switch_probe(switch_chip_t *pSwitchChip)
{
#if defined(FORCE_PROBE_RTL8367C)

*pSwitchChip = CHIP_RTL8367C;
halCtrl = &rtl8367c_hal_Ctrl;

#elif defined(FORCE_PROBE_RTL8370B)

*pSwitchChip = CHIP_RTL8370B;
halCtrl = &rtl8370b_hal_Ctrl;

#elif defined(FORCE_PROBE_RTL8364B)

*pSwitchChip = CHIP_RTL8364B;
halCtrl = &rtl8364b_hal_Ctrl;

#elif defined(FORCE_PROBE_RTL8363SC_VB)

*pSwitchChip = CHIP_RTL8363SC_VB;
halCtrl = &rtl8363sc_vb_hal_Ctrl;

#else
rtk_uint32 retVal;
rtk_uint32 data, regValue;

if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicReg(0x1300, &data)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicReg(0x1301, &regValue)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
return retVal;

switch (data)
{
case 0x0276:
case 0x0597:
case 0x6367:
*pSwitchChip = CHIP_RTL8367C;
halCtrl = &rtl8367c_hal_Ctrl;
break;
case 0x0652:
case 0x6368:
*pSwitchChip = CHIP_RTL8370B;
halCtrl = &rtl8370b_hal_Ctrl;
break;
case 0x0801:
case 0x6511:
if( (regValue & 0x00F0) == 0x0080)
{
*pSwitchChip = CHIP_RTL8363SC_VB;
halCtrl = &rtl8363sc_vb_hal_Ctrl;
}
else
{
*pSwitchChip = CHIP_RTL8364B;
halCtrl = &rtl8364b_hal_Ctrl;
}
break;
default:
return RT_ERR_FAILED;
}
#endif

return RT_ERR_OK;
}

The above function is used to identify which ASIC chip is to be used. It will identify from a list of possible ASIC's
and then call the appropriate chip initialization.

The code is part of the rtk_sw.c file.

I




NEXT




<s> mvswitch_mangle_rx(struct net_device *dev, struct sk_buff *skb)
{
struct mvswitch_priv *priv;
unsigned char *buf;
int vlan = -1;
int i;

priv = dev->phy_ptr;
if (WARN_ON_ONCE(!priv))
return;

#ifdef HEADER_MODE
buf = skb->data;
skb_pull(skb, MV_HEADER_SIZE);
#else
buf = skb->data + skb->len - MV_TRAILER_SIZE;
if (buf[0] != 0x80)
return;
#endif

/* look for the vlan matching the incoming port */
for (i = 0; i < ARRAY_SIZE(priv->vlans); i++) {
if ((1 << buf[1]) & priv->vlans[i])
vlan = i;
}

if (vlan == -1)
return;

__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
}

The above function is used to add VLAN tag into the rx packet using hw accelerator . It is currently called for each new incoming packet on all ports.

mvswitch_mangle_tx is similar function for tx side</s>




NEXT




<s> static int rtl8367_is_vlan_valid(struct rtl8366_smi *smi, unsigned vlan)
{
unsigned max = RTL8367_NUM_VLANS;

if (smi->vlan4k_enabled)
max = RTL8367_NUM_VIDS - 1;

if (vlan == 0 || vlan >= max)
return 0;

return 1;
}

The above function is used to check if a given VLAN number  is valid</s>




NEXT




<s> int ag71xx_setup_gmac(struct device_node *np)
{
struct device_node *np_dev;
void __iomem *base;
int err = 0;

np = of_get_child_by_name(np, "gmac-config");
if (!np)
return 0;

np_dev = of_parse_phandle(np, "device", 0);
if (!np_dev)
goto out;

base = of_iomap(np_dev, 0);
if (!base) {
pr_err("%pOF: can't map GMAC registers\n", np_dev);
err = -ENOMEM;
goto err_iomap;
}

if (of_device_is_compatible(np_dev, "qca,ar9330-gmac"))
ag71xx_setup_gmac_933x(np, base);
else if (of_device_is_compatible(np_dev, "qca,ar9340-gmac"))
ag71xx_setup_gmac_934x(np, base);
else if (of_device_is_compatible(np_dev, "qca,qca9550-gmac"))
ag71xx_setup_gmac_955x(np, base);
else if (of_device_is_compatible(np_dev, "qca,qca9560-gmac"))
ag71xx_setup_gmac_956x(np, base);

iounmap(base);

err_iomap:
of_node_put(np_dev);
out:
of_node_put(np);
return err;
}

The above function is used to set up the gmac registers for various platforms.
First we get the child node for the gmac-config using of_get_child_by_name()
and check if the node is NULL by returning from that function itself.





NEXT




<s> void BN_MONT_CTX_init(BN_MONT_CTX *ctx)
{
ctx->ri=0;
BN_init(&(ctx->RR));
BN_init(&(ctx->N));
BN_init(&(ctx->Ni));
ctx->flags=0;
}

The above function is used to initialize the BN_MONT_CTX structure and set all the fields to their default values.</s>




NEXT




<s> static int aca_max_gpio(struct dc_ep_priv *priv)
{
return fls(rd32(PADC_AVAIL));
}

The above function is used to obtain maximum GPIO count of GPIO driver.
static struct gpio_driver gpio_aca_driver =
:
.probe = pcmcia_gpio_probe,
.max_gpio = aca_max_gpio,





NEXT




<s> check_bridge(const char *name, void *arg)
{
br_foreach_port(name, check_bridge_port, arg);
return 0;
}

The above function is used to check every port of a bridge instance, and check_bridge_port is used to check a specific port of a bridge. However, I dont have the source code right now, is this true?

I know the above is true for i




NEXT




<s> static u64 get_mib_counter_7620(struct mt7530_priv *priv, int i)
{
return mt7530_r32(priv, MT7620_MIB_COUNTER_BASE + mt7620_mibs[i].offset);
}

The above function is used to read a specific MIB value from a SoC. It seems that it has a bug in which the MT7621 and MT7622 use a different offset in mibs[i] and the rest of the drivers don




NEXT




<s> extern void AT91F_ASM_MCI_Handler(void);
//* Global Variables
AT91S_MciDeviceFeatures			MCI_Device_Features;
AT91S_MciDeviceDesc				MCI_Device_Desc;
AT91S_MciDevice					MCI_Device;

#undef ENABLE_WRITE
#undef MMC

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_SendCommand
//* \brief Generic function to send a command to the MMC or SDCard
//*----------------------------------------------------------------------------
int AT91F_MCI_SendCommand (
AT91PS_MciDevice pMCI_Device,
unsigned int Cmd,
unsigned int Arg)
{
unsigned int	error,status;
//unsigned int	tick=0;

// Send the command
AT91C_BASE_MCI->MCI_ARGR = Arg;
AT91C_BASE_MCI->MCI_CMDR = Cmd;

// wait for CMDRDY Status flag to read the response
do
{
status = AT91C_BASE_MCI->MCI_SR;
//tick++;
}
while( !(status & AT91C_MCI_CMDRDY) );//&& (tick<100) );

// Test error  ==> if crc error and response R3 ==> don't check error
error = (AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR;
if(error != 0 )
{
// if the command is SEND_OP_COND the CRC error flag is always present (cf : R3 response)
if ( (Cmd != AT91C_SDCARD_APP_OP_COND_CMD) && (Cmd != AT91C_MMC_SEND_OP_COND_CMD) )
return ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);
else
{
if (error != AT91C_MCI_RCRCE)
return ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);
}
}
return AT91C_CMD_SEND_OK;
}

The above function is used to perform various MCI hardware commands as explained in the following examples.
//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_GetCSD
//* \brief Function called to get the card identifier




NEXT




<s> static void rtl930x_write_mcast_pmask(int idx, u64 portmask)
{
u32 pm = portmask;

/* Access MC_PORTMASK (2) via register RTL9300_TBL_L2 */
struct table_reg *q = rtl_table_get(RTL9300_TBL_L2, 2);

pr_debug("%s: Index idx %d has portmask %08x\n", __func__, idx, pm);
pm <<= 3;
sw_w32(pm, rtl_table_data(q, 0));
rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to write to the index idx portmask, in the TBL_L2 table with a value of 2. The value portmask is shifted left three bits, i.e. pm <<= 3;

If the portmask value




NEXT




<s> void rtl9300_do_rx_calibration_5(u32 sds_num, phy_interface_t phy_mode)
{
if (phy_mode == PHY_INTERFACE_MODE_10GBASER) /* dfeTap1_4Enable true */
rtl9300_do_rx_calibration_5_2(sds_num);
}

The above function is used to calibrate the TX and RX channels(s). The function basically uses the “txcal_1_4” table inside the datasheet as reference:

You can also read/write the registers directly instead of calling above rout




NEXT




<s> void __exit b53_phy_driver_unregister(void)
{
phy_driver_unregister(&b53_phy_driver_id3);
phy_driver_unregister(&b53_phy_driver_id2);
phy_driver_unregister(&b53_phy_driver_id1);
}

The above function is used to unregister the IEEE802.11 B53 PHY drivers. The function unregisters all the three IEEE802.11 b53 PHY drivers. The function is a built-in function and




NEXT




<s> ar8327_atu_flush(struct ar8xxx_priv *priv)
{
int ret;

ret = ar8216_wait_bit(priv, AR8327_REG_ATU_FUNC,
AR8327_ATU_FUNC_BUSY, 0);
if (!ret)
ar8xxx_write(priv, AR8327_REG_ATU_FUNC,
AR8327_ATU_FUNC_OP_FLUSH |
AR8327_ATU_FUNC_BUSY);

return ret;
}

The above function is used to trigger the memory flush cycle by
hardware. The ar8xxx_write() function is defined in the ar8xxx_common.c
file and it just takes a struct ar8xxx_priv * as input parameter and
pass it




NEXT




<s> static int sata_oxnas_softreset(struct ata_link *link, unsigned int *class,
unsigned long deadline)
{
struct ata_port *ap = link->ap;
struct sata_oxnas_port_priv *pd = ap->private_data;
void __iomem *port_base = pd->port_base;
int rc;

struct ata_taskfile tf;
u32 Command_Reg;

DPRINTK("ENTER\n");

port_base = pd->port_base;

if (ata_link_offline(link)) {
DPRINTK("PHY reports no device\n");
*class = ATA_DEV_NONE;
goto out;
}

/* write value to register */
iowrite32(0, port_base + ORB1);
iowrite32(0, port_base + ORB2);
iowrite32(0, port_base + ORB3);
iowrite32((ap->ctl) << 24, port_base + ORB4);

/* command the core to send a control FIS */
Command_Reg = ioread32(port_base + SATA_COMMAND);
Command_Reg &= ~SATA_OPCODE_MASK;
Command_Reg |= CMD_WRITE_TO_ORB_REGS_NO_COMMAND;
iowrite32(Command_Reg, port_base + SATA_COMMAND);
udelay(20);	/* FIXME: flush */

/* write value to register */
iowrite32((ap->ctl | ATA_SRST) << 24, port_base + ORB4);

/* command the core to send a control FIS */
Command_Reg &= ~SATA_OPCODE_MASK;
Command_Reg |= CMD_WRITE_TO_ORB_REGS_NO_COMMAND;
iowrite32(Command_Reg, port_base + SATA_COMMAND);
udelay(20);	/* FIXME: flush */

/* write value to register */
iowrite32((ap->ctl) << 24, port_base + ORB4);

/* command the core to send a control FIS */
Command_Reg &= ~SATA_OPCODE_MASK;
Command_Reg |= CMD_WRITE_TO_ORB_REGS_NO_COMMAND;
iowrite32(Command_Reg, port_base + SATA_COMMAND);

msleep(150);

rc = ata_sff_wait_ready(link, deadline);

/* if link is occupied, -ENODEV too is an error */
if (rc && (rc != -ENODEV || sata_scr_valid(link))) {
ata_link_err(link, "SRST failed (errno=%d)\n", rc);
return rc;
}

/* determine by signature whether we have ATA or ATAPI devices */
sata_oxnas_tf_read(ap, &tf);
*class = ata_dev_classify(&tf);

if (*class == ATA_DEV_UNKNOWN)
*class = ATA_DEV_NONE;

out:
DPRINTK("EXIT, class=%u\n", *class);
return 0;
}

The above function is used to reinitialize a drive, which will also clean up
any corrupt FISes in the device.

The first part of the function is actually to send out four null fis, then
to send a sata reset sequence, followed by sending




NEXT




<s> static int b53_srab_remove(struct platform_device *pdev)
{
struct b53_device *dev = platform_get_drvdata(pdev);

if (dev)
b53_switch_remove(dev);

return 0;
}

The above function is used to remove a SRAB switch, i.e. uninstall the driver.

static int b53_srab_suspend(struct platform_device *pdev, pm_message_t state)
{
struct b53_




NEXT




<s> ret_t rtl8367c_setAsicSvlanLookupType(rtk_uint32 type)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_SVLAN_LOOKUP_TYPE, RTL8367C_SVLAN_LOOKUP_TYPE_OFFSET, type);
}

The above function is used to enable/disable Tunnel Id learning functionality in an IEEE 802.1Q VLAN environment.

ret_t rtl8367c_setAsicSvlanTidLearningMode(rtk




NEXT




<s> uc_bpf_map_foreach(uc_vm_t *vm, size_t nargs)
{
struct uc_bpf_map *map = uc_fn_thisval("bpf.map");
uc_value_t *func = uc_fn_arg(0);
bool has_next;
void *key, *next;
bool ret = false;

key = alloca(map->key_size);
next = alloca(map->key_size);
has_next = !bpf_map_get_next_key(map->fd.fd, NULL, next);

while (has_next) {
uc_value_t *rv;
bool stop;

memcpy(key, next, map->key_size);
has_next = !bpf_map_get_next_key(map->fd.fd, next, next);

uc_value_push(ucv_get(func));
uc_value_push(ucv_string_new_length((const char *)key, map->key_size));

if (uc_call(1) != EXCEPTION_NONE)
break;

rv = uc_vm_stack_pop(vm);
stop = (ucv_type(rv) == UC_BOOLEAN && !ucv_boolean_get(rv));
ucv_put(rv);

if (stop)
break;

ret = true;
}

return ucv_boolean_new(ret);
}

The above function is used to provide a mechanism of iterating through the elements of a BPF map. The function is executed inside BPF programs using the uc_bpf_map_foreach library function (not shown here) which is similar to the Java for-each




NEXT




<s> ret_t rtl8367c_getAsicPortPriorityDecisionIndex(rtk_uint32 port, rtk_uint32 *pIndex )
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_IDX_CTRL, port, pIndex);
}

The above function is used to get index number of Port Priority Decision Entry in priority decision table.
The following code is for illustration purpose.

rtk_uint32 asicPriorityDecisionIndex[RTL8367C_PORTID




NEXT




<s> static void ath79_mii0_ctrl_set_if(struct ag71xx *ag)
{
unsigned int mii_if;

switch (ag->phy_if_mode) {
case PHY_INTERFACE_MODE_MII:
mii_if = AR71XX_MII0_CTRL_IF_MII;
break;
case PHY_INTERFACE_MODE_GMII:
mii_if = AR71XX_MII0_CTRL_IF_GMII;
break;
case PHY_INTERFACE_MODE_RGMII:
case PHY_INTERFACE_MODE_RGMII_ID:
case PHY_INTERFACE_MODE_RGMII_RXID:
case PHY_INTERFACE_MODE_RGMII_TXID:
mii_if = AR71XX_MII0_CTRL_IF_RGMII;
break;
case PHY_INTERFACE_MODE_RMII:
mii_if = AR71XX_MII0_CTRL_IF_RMII;
break;
default:
WARN(1, "Impossible PHY mode defined.\n");
return;
}

ath79_mii_ctrl_set_if(ag, mii_if);
}

The above function is used to configure the PHY interface mode. This is
only available on platforms that do not provide for this value in ag->phy_if_mode.

The AR71XX documentation says that this register should be written to 0x2




NEXT




<s> const char *zyxel_bootconfig_image_status_name(const enum zyxel_bootconfig_image_status bootconfig) {
struct zyxel_image_status* s;

for (s = image_status_codes; s->name; s++) {
if (bootconfig == s->code) {
return s->name;
}
}

return "N/A";
}

The above function is used to name the BootConfig type by its ID.

When updating these values, make sure they update correctly in two different ways. First, with boot.bin installed on the router, the names will appear on the device. This is useful for ver




NEXT




<s> static inline bool is_all_ff(u8 *buf, int len)
{
while (len--)
if (buf[len] != 0xff)
return false;

return true;
}

The above function is used to assert that when decompressing a video stream (MPEG-2), there aren’t holes, and that when reading an image file (JPEG) all bytes have a value of FF. Since FF is a special value, this




NEXT




<s> static int rtl8367s_hw_reset(void)
{
struct rtk_gsw *gsw = _gsw;

if (gsw->reset_pin < 0)
return 0;

gpio_direction_output(gsw->reset_pin, 0);

usleep_range(1000, 1100);

gpio_set_value(gsw->reset_pin, 1);

mdelay(500);

return 0;
}

The above function is used to reset RTL8367S MAC through the reset pin which is GPIO. The RTL8367S reset pin is reset-gpio as marked. Pin is set to 0, which means active low reset. After reset,




NEXT




<s> void rtl9300_sds_rxcal_dcvs_manual(u32 sds_num, u32 dcvs_id, bool manual, u32 dvcs_list[])
{
if (manual) {
switch(dcvs_id) {
case 0:
rtl9300_sds_field_w(sds_num, 0x2e, 0x1e, 14, 14, 0x1);
rtl9300_sds_field_w(sds_num, 0x2f, 0x03,  5,  5, dvcs_list[0]);
rtl9300_sds_field_w(sds_num, 0x2f, 0x03,  4,  0, dvcs_list[1]);
break;
case 1:
rtl9300_sds_field_w(sds_num, 0x2e, 0x1e, 13, 13, 0x1);
rtl9300_sds_field_w(sds_num, 0x2e, 0x1d, 15, 15, dvcs_list[0]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x1d, 14, 11, dvcs_list[1]);
break;
case 2:
rtl9300_sds_field_w(sds_num, 0x2e, 0x1e, 12, 12, 0x1);
rtl9300_sds_field_w(sds_num, 0x2e, 0x1d, 10, 10, dvcs_list[0]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x1d,  9,  6, dvcs_list[1]);
break;
case 3:
rtl9300_sds_field_w(sds_num, 0x2e, 0x1e, 11, 11, 0x1);
rtl9300_sds_field_w(sds_num, 0x2e, 0x1d,  5,  5, dvcs_list[0]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x1d,  4,  1, dvcs_list[1]);
break;
case 4:
rtl9300_sds_field_w(sds_num, 0x2e, 0x01, 15, 15, 0x1);
rtl9300_sds_field_w(sds_num, 0x2e, 0x11, 10, 10, dvcs_list[0]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x11,  9,  6, dvcs_list[1]);
break;
case 5:
rtl9300_sds_field_w(sds_num, 0x2e, 0x02, 11, 11, 0x1);
rtl9300_sds_field_w(sds_num, 0x2e, 0x11,  4,  4, dvcs_list[0]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x11,  3,  0, dvcs_list[1]);
break;
default:
break;
}
} else {
switch(dcvs_id) {
case 0:
rtl9300_sds_field_w(sds_num, 0x2e, 0x1e, 14, 14, 0x0);
break;
case 1:
rtl9300_sds_field_w(sds_num, 0x2e, 0x1e, 13, 13, 0x0);
break;
case 2:
rtl9300_sds_field_w(sds_num, 0x2e, 0x1e, 12, 12, 0x0);
break;
case 3:
rtl9300_sds_field_w(sds_num, 0x2e, 0x1e, 11, 11, 0x0);
break;
case 4:
rtl9300_sds_field_w(sds_num, 0x2e, 0x01, 15, 15, 0x0);
break;
case 5:
rtl9300_sds_field_w(sds_num, 0x2e, 0x02, 11, 11, 0x0);
break;
default:
break;
}
mdelay(1);
}
}

The above function is used to set/unset the DCVS in the auto gain control loop.
Please notice the function will only work with the rtl9300-sds.c driver.
The reason for this is the current design is to disable DC




NEXT




<s> yy_symbol_value_print (FILE *yyo,
yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
{
FILE *yyoutput = yyo;
YY_USE (yyoutput);
if (!yyvaluep)
return;
# ifdef YYPRINT
if (yykind < YYNTOKENS)
YYPRINT (yyo, yytoknum[yykind], *yyvaluep);
# endif
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
YY_USE (yykind);
YY_IGNORE_MAYBE_UNINITIALIZED_END
}

The above function is used to print the value of the parsed syntax tree to the standard output.
This function is defined in a separate header file named yy_symbol_value_print.h.
This file is generated by flex as a part of its normal operation.





NEXT




<s> rtk_api_ret_t rtk_trap_reasonTrapToCpuPriority_set(rtk_trap_reason_type_t type, rtk_pri_t priority)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= TRAP_REASON_END)
return RT_ERR_INPUT;

if (priority > RTL8367C_PRIMAX)
return  RT_ERR_QOS_INT_PRIORITY;

switch (type)
{
case TRAP_REASON_RMA:
if ((retVal = rtl8367c_getAsicRma(0, &rmacfg)) != RT_ERR_OK)
return retVal;
rmacfg.trap_priority= priority;
if ((retVal = rtl8367c_setAsicRma(0, &rmacfg)) != RT_ERR_OK)
return retVal;

break;
case TRAP_REASON_OAM:
if ((retVal = rtl8367c_setAsicOamCpuPri(priority)) != RT_ERR_OK)
return retVal;

break;
case TRAP_REASON_1XUNAUTH:
if ((retVal = rtl8367c_setAsic1xTrapPriority(priority)) != RT_ERR_OK)
return retVal;

break;
case TRAP_REASON_VLANSTACK:
if ((retVal = rtl8367c_setAsicSvlanTrapPriority(priority)) != RT_ERR_OK)
return retVal;

break;
case TRAP_REASON_UNKNOWNMC:
if ((retVal = rtl8367c_setAsicUnknownMulticastTrapPriority(priority)) != RT_ERR_OK)
return retVal;

break;
default:
return RT_ERR_CHIP_NOT_SUPPORTED;
}


return RT_ERR_OK;
}

The above function is used to set the priority of  packet trap report to CPU.
The corresponding trap type and priority list refer to Table 18.

Table 18. RT-3328  Trap reporting priority
-------------------------------------------------------------





NEXT




<s> static int make_parent_dir(const char *path)
{
char tmp[PATH_MAX + 1];
char *p;

strncpy(tmp, path, sizeof(tmp));
tmp[sizeof(tmp) - 1] = 0;

/* Remove the base name. Just return if nothing is left */
p = strrchr(tmp, '/');
if (!p)
return 0;
*(p + 1) = 0;

/* Just in case it is an absolute path */
p = tmp;
while (*p == '/')
p++;

while ((p = strchr(p, '/'))) {
*p = 0;

/* skip if the directory exists */
if (!is_dir(tmp) && mkdir(tmp, 0755))
return -1;

*p = '/';
while (*p == '/')
p++;
}

return 0;
}

The above function is used to create the directory if the file does not exist.</s>




NEXT




<s> static int sata_oxnas_bug_6320_detect(struct ata_port *ap)
{
struct sata_oxnas_port_priv *pd = ap->private_data;
void __iomem *core_base = pd->core_base;
int is_read;
int quads_transferred;
int remainder;
int sector_quads_remaining;
int bug_present = 0;

/* Only want to apply fix to reads */
is_read = !(ioread32(core_base + DM_DBG1) & (ap->port_no ?
BIT(CORE_PORT1_DATA_DIR_BIT) :
BIT(CORE_PORT0_DATA_DIR_BIT)));

/* Check for an incomplete transfer, i.e. not a multiple of 512 bytes
transferred (datacount_port register counts quads transferred) */
quads_transferred =
ioread32(core_base + (ap->port_no ?
DATACOUNT_PORT1 : DATACOUNT_PORT0));

remainder = quads_transferred & 0x7f;
sector_quads_remaining = remainder ? (0x80 - remainder) : 0;

if (is_read && (sector_quads_remaining == 2)) {
bug_present = 1;
} else if (sector_quads_remaining) {
if (is_read) {
ata_port_warn(ap, "SATA read fixup cannot deal with "
"%d quads remaining\n",
sector_quads_remaining);
} else {
ata_port_warn(ap, "SATA write fixup of %d quads "
"remaining not supported\n",
sector_quads_remaining);
}
}

return bug_present;
}

The above function is used to detect the presence of the bug in certain
SATA ports on the OXNAS system.</s>




NEXT




<s> ret_t rtl8367c_getAsicFlowControlPortJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_OFF, RTL8367C_FLOWCTRL_JUMBO_PORT_OFF_MASK, pOffThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_ON, RTL8367C_FLOWCTRL_JUMBO_PORT_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to get Asic flow control port Jumbo threshold. In this function call, the
parameters *pOffThreshold and *pOnThreshold are output parameters and the corresponding data buffer
length should be larger than 1.

The following example




NEXT




<s> static void rtl930x_fill_l2_row(u32 r[], struct rtl838x_l2_entry *e)
{
u32 port;

if (!e->valid) {
r[0] = r[1] = r[2] = 0;
return;
}

r[2] = BIT(31);	/* Set valid bit */

r[0] = ((u32)e->mac[0]) << 24 |
((u32)e->mac[1]) << 16 |
((u32)e->mac[2]) << 8 |
((u32)e->mac[3]);
r[1] = ((u32)e->mac[4]) << 24 |
((u32)e->mac[5]) << 16;

r[2] |= e->next_hop ? BIT(12) : 0;

if (e->type == L2_UNICAST) {
r[2] |= e->is_static ? BIT(14) : 0;
r[1] |= e->rvid & 0xfff;
r[2] |= (e->port & 0x3ff) << 20;
if (e->is_trunk) {
r[2] |= BIT(30);
port = e->stack_dev << 9 | (e->port & 0x3f);
} else {
port = (e->stack_dev & 0xf) << 6;
port |= e->port & 0x3f;
}
r[2] |= port << 20;
r[2] |= e->block_da ? BIT(15) : 0;
r[2] |= e->block_sa ? BIT(17) : 0;
r[2] |= e->suspended ? BIT(13) : 0;
r[2] |= (e->age & 0x3) << 17;
/* the UC_VID field in hardware is used for the VID or for the route id */
if (e->next_hop)
r[2] |= e->nh_route_id & 0x7ff;
else
r[2] |= e->vid & 0xfff;
} else { /* L2_MULTICAST */
r[2] |= (e->mc_portmask_index & 0x3ff) << 16;
r[2] |= e->mc_mac_index & 0x7ff;
}
}

The above function is used to populate the l2 row of the AGE/L2 table in the RTL838x chip. The function gets a pointer to an l2_entry and fills a 3-word structure (r) that is used




NEXT




<s> static int mtk_bmt_debug_v2(void *data, u64 val)
{
struct bbmt *bbmt = bmt_tbl(bmtd.bbt);
struct mtd_info *mtd = bmtd.mtd;
unsigned long *used;
int main_blocks = mtd->size >> bmtd.blk_shift;
int n_remap = 0;
int i;

used = mtk_bmt_get_mapping_mask();
if (!used)
return -ENOMEM;

switch (val) {
case 0:
for (i = 1; i < main_blocks; i++) {
if (bmtd.bbt->bb_tbl[i] == i)
continue;

printk("remap [%x->%x]\n", i, bmtd.bbt->bb_tbl[i]);
n_remap++;
}
for (i = 0; i <= bmtd.bmt_blk_idx; i++) {
char c;

switch (bbmt[i].mapped) {
case NO_MAPPED:
continue;
case NORMAL_MAPPED:
c = 'm';
if (test_bit(i, used))
c = 'M';
break;
case BMT_MAPPED:
c = 'B';
break;
default:
c = 'X';
break;
}
printk("[%x:%c] = 0x%x\n", i, c, bbmt[i].block);
}
break;
case 100:
for (i = 0; i <= bmtd.bmt_blk_idx; i++) {
if (bbmt[i].mapped != NORMAL_MAPPED)
continue;

if (test_bit(i, used))
continue;

n_remap++;
bbmt[i].mapped = NO_MAPPED;
printk("free block [%d:%x]\n", i, bbmt[i].block);
}
if (n_remap)
bmtd.bmt_blk_idx = upload_bmt(bmtd.bbt, bmtd.bmt_blk_idx);
break;
}

kfree(used);

return 0;
}

The above function is used to update block mapping in bbmt and upload it to
JEDEC memory. It can be used to manage bad blocks and remap them.
Here I created two cases. In case 0, it will scan through bbmt table




NEXT




<s> static void rtl839x_l2_learning_setup(void)
{
/* Set portmask for broadcast (offset bit 12) and unknown unicast (offset 0)
* address flooding to the reserved entry in the portmask table used
* also for multicast flooding */
sw_w32(UNKNOWN_MC_PMASK << 12 | UNKNOWN_MC_PMASK, RTL839X_L2_FLD_PMSK);

/* Limit learning to maximum: 32k entries, after that just flood (bits 0-1) */
sw_w32((0x7fff << 2) | 0, RTL839X_L2_LRN_CONSTRT);

/* Do not trap ARP packets to CPU_PORT */
sw_w32(0, RTL839X_SPCL_TRAP_ARP_CTRL);
}

The above function is used to set up the learning behavior of rtl839x chip. Let us understand this function in detail to clear our concept of flooding.

Unknown_mc_pmask - used for multicast flooding
unknown_mc_




NEXT




<s> static int msdc_tune_request(struct mmc_host *mmc, struct mmc_request *mrq)
{
struct msdc_host *host = mmc_priv(mmc);
struct mmc_command *cmd;
struct mmc_data *data;
//u32 base = host->base;
int ret = 0, read;

cmd  = mrq->cmd;
data = mrq->cmd->data;

read = data->flags & MMC_DATA_READ ? 1 : 0;

if (read) {
if (data->error == -EIO)
ret = msdc_tune_bread(mmc, mrq);
} else {
ret = msdc_check_busy(mmc, host);
if (ret) {
ERR_MSG("XXX cmd13 wait program done failed");
return ret;
}
/* CRC and TO */
/* Fix me: don't care card status? */
ret = msdc_tune_bwrite(mmc, mrq);
}

return ret;
}

The above function is used to detect if the current device is a normal SDHC device. And to determine the card status whether it is locked or not.

MSDC_CHECK_DEVICE_STATE

ret = msdc_check_device_state(host




NEXT




<s> adm6996_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);

pr_devel("get_vid port %d\n", val->port_vlan);

val->value.i = priv->vlan_id[val->port_vlan];

return 0;
};

The above function is used to get information about VLAN ID associated with a particular port. As you can see, this function just retrieves info about a VLAN ID associated with a particular port from the structure of type adm6996_priv. Let's take




NEXT




<s> static inline void superio_outb(int base, int reg, int val)
{
outb(reg, base);
outb(val, base + 1);
}

The above function is used to access a peripheral connected to the southbridge.

Now the northbridge registers are typically used to configure ports into the southbridge, some examples are:

Superbridge port 0x000: Enable / Disable IO Port




NEXT




<s> static inline size_t bcm4908img_min(size_t x, size_t y) {
return x < y ? x : y;
}

The above function is used to compute the smallest size between x and y.

static inline size_t bcm4908img_max(size_t x, size_t y) {
return x > y ? x : y;
}





NEXT




<s> static void gpio_latch_lock(struct gpio_latch_chip *glc, bool enable)
{
mutex_lock(&glc->mutex);

if (enable)
glc->latch_enabled = true;

if (glc->latch_enabled)
mutex_lock(&glc->latch_mutex);
}

The above function is used to lock/unlock the GPIO latch. Lock is to be done before enabling the GPIO latching. Unlock is to be done only after GPIO latching pin is disabled (set low).

Note: If an unauthorized/un




NEXT




<s> list_switch(struct nl_msg *msg, void *arg)
{
struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));

if (nla_parse(tb, SWITCH_ATTR_MAX, genlmsg_attrdata(gnlh, 0), genlmsg_attrlen(gnlh, 0), NULL) < 0)
goto done;

if (!tb[SWITCH_ATTR_DEV_NAME] || !tb[SWITCH_ATTR_NAME])
goto done;

printf("Found: %s - %s\n", nla_get_string(tb[SWITCH_ATTR_DEV_NAME]),
nla_get_string(tb[SWITCH_ATTR_ALIAS]));

done:
return NL_SKIP;
}

The above function is used to retrieve and print the necessary values of interest from the received struct_msg through its NL_MSG. It returns NL_SKIP to the caller if the parsing finished.
Now that we have created the parsing function for our genl_




NEXT




<s> ret_t rtl8367c_setAsicRemarkingDot1pSrc(rtk_uint32 type)
{

if(type >= DOT1P_PRISEL_END )
return RT_ERR_QOS_SEL_PRI_SOURCE;

return rtl8367c_setAsicRegBit(RTL8367C_REG_RMK_CFG_SEL_CTRL, RTL8367C_RMK_1Q_CFG_SEL_OFFSET, type);
}

The above function is used to set the dot1p tag source in Asic.  The valid parameters are RT_DOT1P_PRISEL_VLAN and RT_DOT1P_PRISEL_8021P.

As far as I know




NEXT




<s> static u64 rtl83xx_mc_group_add_port(struct rtl838x_switch_priv *priv, int mc_group, int port)
{
u64 portmask = priv->r->read_mcast_pmask(mc_group);

pr_debug("%s: %d\n", __func__, port);

portmask |= BIT_ULL(port);
priv->r->write_mcast_pmask(mc_group, portmask);

return portmask;
}

The above function is used to add a port to a multicast group. Portmask is a bit-vector where each bit is a single bitvector.  We could use bitmask instead of portmask but for clarity I’ll stick with portmask.

The




NEXT




<s> static void _deu_arc4_ecb(void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
_deu_arc4 (ctx, dst, src, NULL, nbytes, encdec, 0);
}

The above function is used to encrypt (or to decrypt) the data in the
src buffer by the key stored in the dst buffer, in ECB mode.

In ECB mode, the whole block of data is treated as many independent
blocks of 




NEXT




<s> static int __init fe_init(struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);
struct device_node *port;
int err;

fe_reset_fe(priv);

if (priv->soc->switch_init) {
err = priv->soc->switch_init(priv);
if (err) {
if (err == -EPROBE_DEFER)
return err;

netdev_err(dev, "failed to initialize switch core\n");
return -ENODEV;
}
}

fe_reset_phy(priv);

of_get_mac_address(priv->dev->of_node, dev->dev_addr);

/* If the mac address is invalid, use random mac address  */
if (!is_valid_ether_addr(dev->dev_addr)) {
eth_hw_addr_random(dev);
dev_err(priv->dev, "generated random MAC address %pM\n",
dev->dev_addr);
}

err = fe_mdio_init(priv);
if (err)
return err;

if (priv->soc->port_init)
for_each_child_of_node(priv->dev->of_node, port)
if (of_device_is_compatible(port, "mediatek,eth-port") &&
of_device_is_available(port))
priv->soc->port_init(priv, port);

if (priv->phy) {
err = priv->phy->connect(priv);
if (err)
goto err_phy_disconnect;
}

err = fe_hw_init(dev);
if (err)
goto err_phy_disconnect;

if ((priv->flags & FE_FLAG_HAS_SWITCH) && priv->soc->switch_config)
priv->soc->switch_config(priv);

return 0;

err_phy_disconnect:
if (priv->phy)
priv->phy->disconnect(priv);
fe_mdio_cleanup(priv);

return err;
}

The above function is used to initialize the fe interface. It handles the initialiation of MDIO, physical connections and port configurations. It also initialiates the hardware according to the hardware architecture. It eventually initializes the switch core if its initialized and handles the reset of the PH




NEXT




<s> ret_t rtl8367c_getAsicStormFilterExtEnablePortMask(rtk_uint32 *pPortmask)
{
rtk_uint32 tmpPmsk;
ret_t retVal;

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_EXT_EN_PORTMASK_MASK, &tmpPmsk);
if(retVal != RT_ERR_OK)
return retVal;
*pPortmask = tmpPmsk & 0x3ff;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_EXT_EN_PORTMASK_EXT_MASK, &tmpPmsk);
if(retVal != RT_ERR_OK)
return retVal;
*pPortmask |= (tmpPmsk & 1) << 10;

return RT_ERR_OK;
}

The above function is used to retrieve the enabled port of extension storm control.

Extension storm filter is used to prevent flooding issue caused by storm. Each port can be enabled/disabled for storm filter detection individually even with the auto-mode is being used. With this extension




NEXT




<s> rtk_api_ret_t rtk_svlan_lookupType_get(rtk_svlan_lookupType_t *pType)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pType)
return RT_ERR_NULL_POINTER;

retVal = rtl8367c_getAsicSvlanLookupType(pType);

svlan_lookupType = *pType;

return retVal;
}

The above function is used to configure and get the lookup type. By default, the lookup mode type is MAC address. When the lookup mode is VLAN ID, the lookup mode must be set to VID. This is because the MAC-VLAN is not supported on the




NEXT




<s> static void msdc_dump_io_resp(struct msdc_host *host, u32 resp)
{
u32 flags = (resp >> 8) & 0xFF;
#if 0
char *state[] = {"DIS", "CMD", "TRN", "RFU"};
#endif
if (flags & (1 << 7))
N_MSG(RSP, "[IO] COM_CRC_ERR");
if (flags & (1 << 6))
N_MSG(RSP, "[IO] Illgal command");
if (flags & (1 << 3))
N_MSG(RSP, "[IO] Error");
if (flags & (1 << 2))
N_MSG(RSP, "[IO] RFU");
if (flags & (1 << 1))
N_MSG(RSP, "[IO] Function number error");
if (flags & (1 << 0))
N_MSG(RSP, "[IO] Out of range");

N_MSG(RSP, "[IO] State: %s, Data:0x%x", state[(resp >> 12) & 0x3], resp & 0xFF);
}

The above function is used to dump out the io resp of any command.
One of the things you might notice in the log is the out_of_range case which prints out:

[IO] Out of range

I found that many times this happens because




NEXT




<s> static void rtl8214fc_power_set(struct phy_device *phydev, int port, bool on)
{
char *state = on ? "on" : "off";

if (port == PORT_FIBRE) {
pr_info("%s: Powering %s FIBRE (port %d)\n", __func__, state, phydev->mdio.addr);
phy_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_FIBRE);
} else {
pr_info("%s: Powering %s COPPER (port %d)\n", __func__, state, phydev->mdio.addr);
phy_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_COPPER);
}

if (on) {
phy_modify_paged(phydev, RTL821X_PAGE_POWER, 0x10, BMCR_PDOWN, 0);
} else {
phy_modify_paged(phydev, RTL821X_PAGE_POWER, 0x10, 0, BMCR_PDOWN);
}

phy_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_AUTO);
}

The above function is used to turn the phy on or off depending on the parameter "on" given by calling function.

phydev is one of the input structure for the function, which is defined as follows in the struct net_device_ops.
struct ph




NEXT




<s> show_attrs(struct switch_dev *dev, struct switch_attr *attr, struct switch_val *val)
{
while (attr) {
if (attr->type != SWITCH_TYPE_NOVAL) {
printf("\t%s: ", attr->name);
if (swlib_get_attr(dev, attr, val) < 0)
printf("???");
else {
print_attr_val(attr, val);
free_attr_val(attr, val);
}
putchar('\n');
}
attr = attr->next;
}
}

The above function is used to show configuration attributes in a struct switch_val data structure. To show the attributes for the whole switch:

show_attrs(&switch);

or to show the attributes for a switch interface:

show_attrs(&switch, switch




NEXT




<s> static int b53_mdio_read32(struct b53_device *dev, u8 page, u8 reg, u32 *val)
{
struct mii_bus *bus = dev->priv;
int ret;

ret = b53_mdio_op(dev, page, reg, REG_MII_ADDR_READ);
if (ret)
return ret;

*val = mdiobus_read(bus, B53_PSEUDO_PHY, REG_MII_DATA0);
*val |= mdiobus_read(bus, B53_PSEUDO_PHY, REG_MII_DATA1) << 16;

return 0;
}

The above function is used to read from the MDIO address, REG_MII_DATA0(32-bit) & REG_MII_DATA1(32-bit). However, I get an error that register REG_MII_DATA0 is




NEXT




<s> ret_t rtl8367c_getAsicFlowControlSystemDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SYS_OFF, RTL8367C_FLOWCTRL_FCOFF_SYS_OFF_MASK, pOffThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SYS_ON, RTL8367C_FLOWCTRL_FCOFF_SYS_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to read the system drop threshold of FCOFF. the system drop threshold, also referred as system off threshold, is defined as:

The minimum number of packets which are dropped. Note that no more than four packets will get dropped by a single




NEXT




<s> static int rtl8367c_is_vlan_valid(unsigned int vlan)
{
unsigned max = RTL8367C_NUM_VIDS;

if (vlan == 0 || vlan >= max)
return 0;

return 1;
}

The above function is used to enforce a limit on the VLANs supported by the
chip and allows the code to use a simple index instead of a VID type. I used
this to enforce a limit on VLANs supported by the 8367C




NEXT




<s> static void parse_str(int af, char *str, void *addr, unsigned long *mask)
{
int ret;
char *slash;

/* Split the address at the slash. */
if ((slash = strchr(str, '/')) == NULL)
print_usage();
*slash = '\0';

/* Parse the address. */
if ((ret = inet_pton(af, str, addr)) != 1) {
if (ret == 0)
print_usage();
else
print_error();
}

/* Parse the mask. */
*mask = strtoul(slash+1, NULL, 10);
if ((af == AF_INET  && *mask >  32) ||
(af == AF_INET6 && *mask > 128))
print_usage();
}

The above function is used to parse an IP address from a string into a network address in memory.
1) It receives arguments for the address type, a pointer to an empty string, a pointer to the network address (in memory) and a pointer for the number of bits




NEXT




<s> static int b53_mdio_read64(struct b53_device *dev, u8 page, u8 reg, u64 *val)
{
struct mii_bus *bus = dev->priv;
u64 temp = 0;
int i;
int ret;

ret = b53_mdio_op(dev, page, reg, REG_MII_ADDR_READ);
if (ret)
return ret;

for (i = 3; i >= 0; i--) {
temp <<= 16;
temp |= mdiobus_read(bus, B53_PSEUDO_PHY, REG_MII_DATA0 + i);
}

*val = temp;

return 0;
}

The above function is used to read 64 bits of data. The function first does a normal MDII operation, and then calls
mdiobus_read() which does standard MDII op on bus, followed by a pseudo MII op on B53_




NEXT




<s> static void __init mtk_sgmiisys_0_init(struct device_node *node)
{
struct clk_onecell_data *clk_data;
int r;

clk_data = mtk_alloc_clk_data(ARRAY_SIZE(sgmii0_clks));

mtk_clk_register_gates(node, sgmii0_clks, ARRAY_SIZE(sgmii0_clks),
clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r)
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
}

The above function is used to initialize the clock tree for the SGMII0</s>




NEXT




<s> static int mtk_bmt_debug_nmbm(void *data, u64 val)
{
struct nmbm_instance *ni = bmtd.ni;
int i;

switch (val) {
case 0:
for (i = 1; i < ni->data_block_count; i++) {
if (ni->block_mapping[i] < ni->mapping_blocks_ba)
continue;

printk("remap [%x->%x]\n", i, ni->block_mapping[i]);
}
}

return 0;
}

The above function is used to print the entire block mapping table. With the help of the printk function, the block mapping table can be seen in the log.</s>




NEXT




<s> link(bakfile2, pwname);
unlink(bakfile2);
#endif
free(bakfile);
free(bakfile2);

return 0;
}

_TYPE( struct t_pwent * )
t_makepwent(tpw, user, pass, salt, confent)
struct t_pw * tpw;
const char * user;
const char * pass;
const struct t_num * salt;
const struct t_confent * confent;
{

The above function is used to create a pseudo-password entry. It takes as arguments the structure t_pw, the name of the user, the password and its salt. The structure t_pw is used to define pseudo-password. The structure t_confent defines the




NEXT




<s> int get_cipher_keysize(const cipher_t *cipher)
{
const mbedtls_cipher_info_t *c = cipher;

return c->key_bitlen >> 3;
}

The above function is used to retrieve the keysize of a cipher. This is done by dividing the key bitlen by 8 and then converting it to an integer.


int get_cipher_blocksize(const cipher_t *c




NEXT




<s> unlink(bakfile2);
#endif
free(bakfile);
free(bakfile2);

return 0;
}

_TYPE( struct t_pwent * )
t_makepwent(tpw, user, pass, salt, confent)
struct t_pw * tpw;
const char * user;
const char * pass;
const struct t_num * salt;
const struct t_confent * confent;
{

The above function is used to process the "passwd" file and put the encrypted
user passwords into the array <tt>pswtab</tt>. It also sets the <tt>crypt_st
ruct</tt>, <tt>crypt_




NEXT




<s> ret_t rtl8367c_setAsicStormFilterUnknownUnicastMeter(rtk_uint32 port, rtk_uint32 meter)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(meter > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

return rtl8367c_setAsicRegBits(RTL8367C_STORM_UNDA_METER_CTRL_REG(port), RTL8367C_STORM_UNDA_METER_CTRL_MASK(port), meter);
}

The above function is used to enable / disable the storm control filter of an unknown unicast frame in a meter.

When the filter is disabled (meter==RTL8367C_METERMAX), unknown unicast packets will flood into the




NEXT




<s> yylval.string = expand_token(yytext, yyleng);
if (strlen(yylval.string))
return T_WORD;
free(yylval.string);
}
YY_BREAK
case 51:
YY_RULE_SETUP
warn_ignored_character(*yytext);
YY_BREAK

case 52:
YY_RULE_SETUP
{

The above function is used to generate the following lexical scanner for the C programming language. The generated lexical scanner reads the C statements and is responsible for detecting the keywords, integers, floating value, comments, special operators, etc. Also, the




NEXT




<s> ret_t rtl8367c_setAsicStormFilterExtMulticastMeter(rtk_uint32 meter)
{
if(meter > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

return rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG0, RTL8367C_MC_STORM_EXT_METERIDX_MASK, meter);
}

The above function is used to change the ID of multicast meter to be 1, and then I used the function below to enable multicast storm control and filter multicast packets, that are not used by host.

rtl8367c




NEXT




<s> unsigned char *hexstr2buf(const char *str, long *len)
{
unsigned char *buf;
long inlen = strlen(str);

*len = 0;
if (inlen % 2)
return NULL;

*len = inlen >> 1;
buf = malloc(*len);
for  (long x = 0; x < *len; x++)
sscanf(str + x * 2, "%2hhx", buf + x);
return buf;
}

The above function is used to convert any hex string to buf. So i can use it within a project to convert a file to buf. My question is, How do i convert a file "sample.hex" to buf? What will the string parameter be?

EDIT




NEXT




<s> tick()
{
struct itimerval it, oit;

it.it_interval.tv_sec = 0;
it.it_interval.tv_usec = 0;
it.it_value.tv_sec = 0;
it.it_value.tv_usec = 16665;
if (setitimer(ITIMER_REAL, &it, &oit) < 0)
perror("tick");
}

The above function is used to generate a signal every 93.3 milliseconds under the UNIX platform. It will generate SIGALRM when the user enters
the system. It needs to be called before getting into the system, and it needs to be defined in the




NEXT




<s> swconfig_set_attr(struct sk_buff *skb, struct genl_info *info)
{
const struct switch_attr *attr;
struct switch_dev *dev;
struct switch_val val;
int err = -EINVAL;

if (!capable(CAP_NET_ADMIN))
return -EPERM;

dev = swconfig_get_dev(info);
if (!dev)
return -EINVAL;

memset(&val, 0, sizeof(val));
attr = swconfig_lookup_attr(dev, info, &val);
if (!attr || !attr->set)
goto error;

val.attr = attr;
switch (attr->type) {
case SWITCH_TYPE_NOVAL:
break;
case SWITCH_TYPE_INT:
if (!info->attrs[SWITCH_ATTR_OP_VALUE_INT])
goto error;
val.value.i =
nla_get_u32(info->attrs[SWITCH_ATTR_OP_VALUE_INT]);
break;
case SWITCH_TYPE_STRING:
if (!info->attrs[SWITCH_ATTR_OP_VALUE_STR])
goto error;
val.value.s =
nla_data(info->attrs[SWITCH_ATTR_OP_VALUE_STR]);
break;
case SWITCH_TYPE_PORTS:
val.value.ports = dev->portbuf;
memset(dev->portbuf, 0,
sizeof(struct switch_port) * dev->ports);

/* TODO: implement multipart? */
if (info->attrs[SWITCH_ATTR_OP_VALUE_PORTS]) {
err = swconfig_parse_ports(skb,
info->attrs[SWITCH_ATTR_OP_VALUE_PORTS],
&val, dev->ports);
if (err < 0)
goto error;
} else {
val.len = 0;
err = 0;
}
break;
case SWITCH_TYPE_LINK:
val.value.link = &dev->linkbuf;
memset(&dev->linkbuf, 0, sizeof(struct switch_port_link));

if (info->attrs[SWITCH_ATTR_OP_VALUE_LINK]) {
err = swconfig_parse_link(skb,
info->attrs[SWITCH_ATTR_OP_VALUE_LINK],
val.value.link);
if (err < 0)
goto error;
} else {
val.len = 0;
err = 0;
}
break;
default:
goto error;
}

err = attr->set(dev, attr, &val);
error:
swconfig_put_dev(dev);
return err;
}

The above function is used to set values of the switch’s attributes. We will start with the simple setting of the string, integer and noValue attributes type:

case SWITCH_TYPE_NOVAL:
break;
case SWITCH_TYPE_




NEXT




<s> static void dep_stack_remove(void)
{
check_top = check_top->prev;
if (check_top)
check_top->next = NULL;
}

The above function is used to remove a dependency from the stack of dependencies. We make the top pointer of the stack point to the new top instead of the dependency to be removed and the top pointer is NULL for all free dependencies. The above procedure is used only at the time of




NEXT




<s> rtk_api_ret_t rtk_trap_unmatchMacPktAction_get(rtk_trap_ucast_action_t *pUcast_action)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pUcast_action)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortUnmatchedSaBehavior(pUcast_action)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get TRAP unmatch MAC action:

```
typedef enum
{
RT_TRAP_UCAST_CONTINUE=0,  RT_TRAP_UCAST_DROP,
}rtk




NEXT




<s> void BN_clear_free(BIGNUM *a)
{
int i;

if (a == NULL) return;
if (a->d != NULL)
{
memset(a->d,0,a->dmax*sizeof(a->d[0]));
if (!(BN_get_flags(a,BN_FLG_STATIC_DATA)))
free(a->d);
}
i=BN_get_flags(a,BN_FLG_MALLOCED);
memset(a,0,sizeof(BIGNUM));
if (i)
free(a);
}

The above function is used to clean up (zero the bits) then free BIGNUM variables that have been malloced using either BN_EXPAND or BN_new(). It also tests to check if a flag has been set (in case a hacker doesn




NEXT




<s> static __inline__ void blast_icache(unsigned long size, unsigned long lsize)
{
unsigned long start = KSEG0;
unsigned long end = (start + size);

while(start < end) {
cache_unroll(start,Index_Invalidate_I);
start += lsize;
}
}

The above function is used to invalidate cache for the code segment in the memory. We had covered different types of caches in our earlier posts, which include I-caches. Instruction caches have the instructions of a running program stored in them for quicker access while




NEXT




<s> static int rtl8366s_enable_vlan4k(struct rtl8366_smi *smi, int enable)
{
return rtl8366_smi_rmwr(smi, RTL8366S_VLAN_TB_CTRL_REG,
1, (enable) ? 1 : 0);
}

The above function is used to enable/disable the VLAN tag mode. When a frame
with a VLAN tag in its header is received, if the function is called with argument
‘enable’, the tag will be removed and the frame be stored in the filter bank





NEXT




<s> static int sha1_final(struct shash_desc *desc, u8 *out)
{
struct sha1_ctx *sctx = shash_desc_ctx(desc);
u32 index, padlen;
u64 t;
u8 bits[8] = { 0, };
static const u8 padding[64] = { 0x80, };
//volatile struct deu_hash_t *hashs = (struct deu_hash_t *) HASH_START;
//unsigned long flag;

t = sctx->count;
bits[7] = 0xff & t;
t >>= 8;
bits[6] = 0xff & t;
t >>= 8;
bits[5] = 0xff & t;
t >>= 8;
bits[4] = 0xff & t;
t >>= 8;
bits[3] = 0xff & t;
t >>= 8;
bits[2] = 0xff & t;
t >>= 8;
bits[1] = 0xff & t;
t >>= 8;
bits[0] = 0xff & t;

/* Pad out to 56 mod 64 */
index = (sctx->count >> 3) & 0x3f;
padlen = (index < 56) ? (56 - index) : ((64 + 56) - index);
sha1_update (desc, padding, padlen);

/* Append length */
sha1_update (desc, bits, sizeof bits);

memcpy(out, sctx->hash, SHA1_DIGEST_SIZE);

// Wipe context
memset (sctx, 0, sizeof *sctx);

return 0;
}

The above function is used to calculate the hash message using the SHA-1 algorithm.


This algorithm calculates the SHA-1 hash using the SHA1_update() function in the following way:
<p style="margin:48px 48px




NEXT




<s> int br_init(void)
{
if ((br_socket_fd = socket(AF_LOCAL, SOCK_STREAM, 0)) < 0)
return errno;
return 0;
}

The above function is used to initialize the file descriptor for the socket and return 0 if successful.


int br_bind(void)
{
if (bind(br_socket_fd, &br_local_socket_addr,sizeof(br_




NEXT




<s> static inline int rtl930x_mac_force_mode_ctrl(int p)
{
return RTL930X_MAC_FORCE_MODE_CTRL + (p << 2);
}

The above function is used to handle rtl930x_mac_force_mode_ctrl to select different modes of operation in RTL930X. There are 4 modes listed with mac address based on bit fields 1-0 to choose the mode




NEXT




<s> static void rtl839x_read_out_q_table(int port)
{
u32 cmd = 1 << 9 | /* Execute cmd */
0 << 8 | /* Read */
2 << 6 | /* Table type 0b10 */
(port & 0x3f);
rtl839x_exec_tbl2_cmd(cmd);
}

The above function is used to read out the q_table. I have found that the function rtl839x_init_port() is used to set up the PHY. The port setting is done by:
phy_r = rtl839




NEXT




<s> static int __init rtl83xx_get_l2aging(struct rtl838x_switch_priv *priv)
{
int t = sw_r32(priv->r->l2_ctrl_1);

t &= priv->family_id == RTL8380_FAMILY_ID ? 0x7fffff : 0x1FFFFF;

if (priv->family_id == RTL8380_FAMILY_ID)
t = t * 128 / 625; /* Aging time in seconds. 0: L2 aging disabled */
else
t = (t * 3) / 5;

pr_debug("L2 AGING time: %d sec\n", t);
pr_debug("Dynamic aging for ports: %x\n", sw_r32(priv->r->l2_port_aging_out));

return t;
}

The above function is used to check for the l2 aging time in a switch
device. It takes a structure rtl838x_switch_priv pointer as an input
parameter. This is required by the driver to access the properties of
the switch. The




NEXT




<s> ret_t rtl8367c_getAsicForceLed(rtk_uint32 port, rtk_uint32 group, rtk_uint32* pMode)
{
rtk_uint16 regAddr;
ret_t retVal;

/* Invalid input parameter */
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(group >= RTL8367C_LEDGROUPNO)
return RT_ERR_INPUT;

/* Get Related Registers */
if(port < 8){
regAddr = RTL8367C_LED_FORCE_MODE_BASE + (group << 1);
if((retVal = rtl8367c_getAsicRegBits(regAddr, 0x3 << (port * 2), pMode)) != RT_ERR_OK)
return retVal;
}else if(port >= 8){
regAddr = RTL8367C_REG_CPU_FORCE_LED0_CFG1 + (group << 1);
if((retVal = rtl8367c_getAsicRegBits(regAddr, 0x3 << ((port-8) * 2), pMode)) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to read back the asic LED status from the 8367C internal registers. The function is used in three places: led_set_asic_force_led  (setting the LED on or off), led_get_as




NEXT




<s> adm6996_set_ports(struct switch_dev *dev, struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);
u8 *ports = &priv->vlan_table[val->port_vlan];
u8 *tagged = &priv->vlan_tagged[val->port_vlan];
int i;

pr_devel("set_ports port_vlan %d ports", val->port_vlan);

*ports = 0;
*tagged = 0;

for (i = 0; i < val->len; i++) {
struct switch_port *p = &val->value.ports[i];

#ifdef DEBUG
pr_cont(" %d%s", p->id,
((p->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) ? "T" :
""));
#endif

if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
*tagged |= (1 << p->id);
priv->tagged_ports |= (1 << p->id);
}

*ports |= (1 << p->id);
}

#ifdef DEBUG
pr_cont("\n");
#endif

return 0;
};

The above function is used to save the desired ports in the private variable “vlan_table[]”. When the switch receives new vlans from the kernel, it checks the vlan_table[].

It is important to note that each switch_val is mapped to




NEXT




<s> void put_u4(uint8_t v)
{
v &= 0xf;
switch (v) {
case 0x0 ... 0x9:
putchar('0' + v);
break;
case 0xa ... 0xf:
putchar('a' + (v - 0xa));
}
}

The above function is used to put a character representation
of the u8 variable v on our console.  You will see this
used frequently in the output functions below.

void put_u32(uint32_t v)
{
  int




NEXT




<s> static void clean_items(void)
{
int i;
for (i = 0; curses_menu_items[i]; i++)
free_item(curses_menu_items[i]);
bzero(curses_menu_items, sizeof(curses_menu_items));
bzero(k_menu_items, sizeof(k_menu_items));
items_num = 0;
}

The above function is used to clean all menu items. This works good if menu was created with
add_menu_item() function.

So you have function that destroys all menu on the screen. So what is the problem?
If you check add_menu




NEXT




<s> void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
#  ifndef YYFREE
#   define YYFREE free
#   if ! defined free && ! defined EXIT_SUCCESS
void free (void *); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
# endif
#endif /* !defined yyoverflow */

#if (! defined yyoverflow \
&& (! defined __cplusplus \
|| (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))

/* A type that is properly aligned for any stack member.  */
union yyalloc
{
yy_state_t yyss_alloc;
YYSTYPE yyvs_alloc;
};

The above function is used to find if there is any data available outside the limit of an array.

The pointer used in function YYREALLOC is the pointer that points to where the first element of array is stored.
YY_ALIGNMENT is the constant that is




NEXT




<s> static int rtl930x_mdio_read_paged(struct mii_bus *bus, int mii_id, u16 page, int regnum)
{
u32 val;
int err;
struct rtl838x_eth_priv *priv = bus->priv;

if (priv->phy_is_internal[mii_id])
return rtl930x_read_sds_phy(priv->sds_id[mii_id], page, regnum);

if (regnum & (MII_ADDR_C45 | MII_ADDR_C22_MMD)) {
err = rtl930x_read_mmd_phy(mii_id,
mdiobus_c45_devad(regnum),
regnum, &val);
pr_debug("MMD: %d dev %x register %x read %x, err %d\n", mii_id,
mdiobus_c45_devad(regnum), mdiobus_c45_regad(regnum),
val, err);
} else {
err = rtl930x_read_phy(mii_id, page, regnum, &val);
pr_debug("PHY: %d register %x read %x, err %d\n", mii_id, regnum, val, err);
}

if (err)
return err;

return val;
}

The above function is used to
read from a phy's register,
which in turn utilizes this
function internally:

static inline int rtl930x_read_phy(int id, int phy_page, int phy




NEXT




<s> static int b53_phy_write16(struct switch_dev *dev, int addr, u8 reg, u16 value)
{
struct b53_device *priv = sw_to_b53(dev);

if (priv->ops->phy_write16)
return priv->ops->phy_write16(priv, addr, reg, value);

return b53_write16(priv, B53_PORT_MII_PAGE(addr), reg, value);
}

The above function is used to write to a specific location in the MII Register. It is assumed this registers is part of the MAC, not the PHY. How can I use these registers which are actually in the PHY and not the MAC or how do I have to




NEXT




<s> static void rtl839x_enable_flood(int port, bool enable)
{
/* 0: Forward
* 1: Disable
* 2: to CPU
* 3: Copy to CPU
*/
sw_w32_mask(0x3, enable ? 0 : 1,
RTL839X_L2_PORT_LRN_CONSTRT + (port << 2));
}

The above function is used to turn on/off the action when a MAC address hits the port.

For learning mode, all flooding ports are forced into a learning state in the port register. So, when a new MAC address is seen, it goes into the MAC




NEXT




<s> rtl_rmw(struct switch_dev *dev, unsigned int page, unsigned int phy, unsigned int reg, u16 mask, u16 val)
{
struct rtl_priv *priv = to_rtl(dev);
struct mii_bus *bus = priv->bus;
u16 r;

rtl_set_page(priv, page);
r = bus->read(bus, phy, reg);
r &= ~mask;
r |= val;
bus->write(bus, phy, reg, r);
return bus->read(bus, phy, reg); /* flush */
}

The above function is used to program registers that may or may not be written with the writeable set bit.

Solution #1:
Inside of the rtl_rmw function, when calling the "bus->write" function, mask out 16




NEXT




<s> static int __init mt7981_pinctrl_init(void)
{
return platform_driver_register(&mt7981_pinctrl_driver);
}

The above function is used to register platform driver.

struct platform_driver {
struct module *mod;
int (*probe)(struct platform_device *dev);
int (*remove)(struct platform_device *dev);
struct resource  __maybe_unused *




NEXT




<s> const char* part_type(unsigned int id)
{
switch(id) {
case MAGIC_ANNEX_B:
return "/tmp/vr9_dsl_fw_annex_b.bin";
case MAGIC_TAPI:
return "/tmp/vr9_tapi_fw.bin";
}
printf("\tUnknown lzma type 0x%02X\n", id);
return "/tmp/unknown.lzma";
}

The above function is used to find the URL to a lzma file, if it
exists at it's local cache.

To enable the lzma decompressor, include the following line in your
Kconfig:


# We need a




NEXT




<s> static void validate_oam_htu_entry(void);
static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to inject an OAM cell into the IFX internal
OAM engine
#endif

/*
*  OAM cell processing
*/
void rx_oam_htu_cell(void);
/*
*  RDI




NEXT




<s> void rtl9300_serdes_mac_link_config(int sds, bool tx_normal, bool rx_normal)
{
u32 v10, v1;

v10 = rtl930x_read_sds_phy(sds, 6, 2); /* 10GBit, page 6, reg 2 */
v1 = rtl930x_read_sds_phy(sds, 0, 0); /* 1GBit, page 0, reg 0 */
pr_info("%s: registers before %08x %08x\n", __func__, v10, v1);

v10 &= ~(BIT(13) | BIT(14));
v1 &= ~(BIT(8) | BIT(9));

v10 |= rx_normal ? 0 : BIT(13);
v1 |= rx_normal ? 0 : BIT(9);

v10 |= tx_normal ? 0 : BIT(14);
v1 |= tx_normal ? 0 : BIT(8);

rtl930x_write_sds_phy(sds, 6, 2, v10);
rtl930x_write_sds_phy(sds, 0, 0, v1);

v10 = rtl930x_read_sds_phy(sds, 6, 2);
v1 = rtl930x_read_sds_phy(sds, 0, 0);
pr_info("%s: registers after %08x %08x\n", __func__, v10, v1);
}

The above function is used to configure SDS link mode, and it contains two arguments, which represent the mode of TX and RX link. TX/RX link may be in NORMAL or RDG (1110 Bit Data Pattern) mode, or 1




NEXT




<s> char *xstrdup(const char *s)
{
char *p;

p = strdup(s);
if (p)
return p;
fprintf(stderr, "Out of memory.\n");
exit(1);
}

The above function is used to create a copied copy of some characters.
Here xstrdup has the function pointer char and pointer to constant character s, we can pass string in s.
We just need to create new memory space from that we pass pointer there.
So




NEXT




<s> rtk_api_ret_t rtk_port_rgmiiDelayExt_set(rtk_port_t port, rtk_data_t txDelay, rtk_data_t rxDelay)
{
rtk_api_ret_t retVal;
rtk_uint32 regAddr, regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_EXT(port);

if ((txDelay > 1) || (rxDelay > 7))
return RT_ERR_INPUT;

if(port == EXT_PORT0)
regAddr = RTL8367C_REG_EXT1_RGMXF;
else if(port == EXT_PORT1)
regAddr = RTL8367C_REG_EXT2_RGMXF;
else
return RT_ERR_INPUT;

if ((retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
return retVal;

regData = (regData & 0xFFF0) | ((txDelay << 3) & 0x0008) | (rxDelay & 0x0007);

if ((retVal = rtl8367c_setAsicReg(regAddr, regData)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the Delay value of each port.</s>




NEXT




<s> rtk_api_ret_t rtk_l2_floodPortMask_set(rtk_l2_flood_type_t floood_type, rtk_portmask_t *pFlood_portmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (floood_type >= FLOOD_END)
return RT_ERR_INPUT;

/* check port valid */
RTK_CHK_PORTMASK_VALID(pFlood_portmask);

/* Get Physical port mask */
if ((retVal = rtk_switch_portmask_L2P_get(pFlood_portmask, &pmask))!=RT_ERR_OK)
return retVal;

switch (floood_type)
{
case FLOOD_UNKNOWNDA:
if ((retVal = rtl8367c_setAsicPortUnknownDaFloodingPortmask(pmask)) != RT_ERR_OK)
return retVal;
break;
case FLOOD_UNKNOWNMC:
if ((retVal = rtl8367c_setAsicPortUnknownMulticastFloodingPortmask(pmask)) != RT_ERR_OK)
return retVal;
break;
case FLOOD_BC:
if ((retVal = rtl8367c_setAsicPortBcastFloodingPortmask(pmask)) != RT_ERR_OK)
return retVal;
break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to set the port mask of any destination flooding of the switch which include three different functions: Flood Unknown DA (FLOOD_UNKNOWNDA), Flood Unknown Multicast (FLOOD_UNKNOWNMC), and Flood Broadcast (




NEXT




<s> static void rtl930x_write_l2_entry_using_hash(u32 hash, u32 pos, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL9300_TBL_L2, 0);
u32 idx = (0 << 14) | (hash << 2) | pos; /* Access SRAM, with hash and at pos in bucket */

pr_debug("%s: hash %d, pos %d\n", __func__, hash, pos);
pr_debug("%s: index %d -> mac %02x:%02x:%02x:%02x:%02x:%02x\n", __func__, idx,
e->mac[0], e->mac[1], e->mac[2], e->mac[3],e->mac[4],e->mac[5]);

rtl930x_fill_l2_row(r, e);

for (int i = 0; i < 3; i++)
sw_w32(r[i], rtl_table_data(q, i));

rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to write to L2 entry using hash information. We notice that the second parameter ‘pos’ is the offset of the bucket to write to. If we can set this to the index of the final entry in a bucket, we could overflow a pointer to




NEXT




<s> static void __zconf_nextfile(const char *name)
{
struct file *iter;
struct file *file = file_lookup(name);
struct buffer *buf = xmalloc(sizeof(*buf));
memset(buf, 0, sizeof(*buf));

current_buf->state = YY_CURRENT_BUFFER;
yyin = zconf_fopen(file->name);
if (!yyin) {
fprintf(stderr, "%s:%d: can't open file \"%s\"\n",
zconf_curname(), zconf_lineno(), file->name);
exit(1);
}
yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
buf->parent = current_buf;
current_buf = buf;

current_file->lineno = yylineno;
file->parent = current_file;

for (iter = current_file; iter; iter = iter->parent) {
if (!strcmp(iter->name, file->name)) {
fprintf(stderr,
"Recursive inclusion detected.\n"
"Inclusion path:\n"
"  current file : %s\n", file->name);
iter = file;
do {
iter = iter->parent;
fprintf(stderr, "  included from: %s:%d\n",
iter->name, iter->lineno - 1);
} while (strcmp(iter->name, file->name));
exit(1);
}
}

yylineno = 1;
current_file = file;
}

The above function is used to create new buffers for each new file. The `yyin` symbol
point to a file stream, and the `yy_create_buffer` call creates a buffer and associates it
to the particular stream on which we wish to operate.




NEXT




<s> static void rtl838x_mac_config(struct phylink_config *config,
unsigned int mode,
const struct phylink_link_state *state)
{
/* This is only being called for the master device,
* i.e. the CPU-Port. We don't need to do anything.
*/

pr_info("In %s, mode %x\n", __func__, mode);
}

The above function is used to initialize MAC and PHY with a given config object.
The config object contains the device’s MAC address information, PHY device index, number
of lanes, link speed and width.
The rtl8386-mac




NEXT




<s> ret_t rtl8367c_setAsicEgressFlowControlPortDropGap(rtk_uint32 gap)
{
if(gap >= RTL8367C_PAGE_NUMBER)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_GAP, RTL8367C_FLOWCTRL_PORT_GAP_MASK, gap);
}

The above function is used to set/get the gap of Egress FlowControl. This is the offset and mask of RTL8367C_FLOWCTRL_PORT_GAP_MASK 0x00600A1D:






NEXT




<s> swconfig_get_attr(struct sk_buff *skb, struct genl_info *info)
{
struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
const struct switch_attr *attr;
struct switch_dev *dev;
struct sk_buff *msg = NULL;
struct switch_val val;
int err = -EINVAL;
int cmd = hdr->cmd;

dev = swconfig_get_dev(info);
if (!dev)
return -EINVAL;

memset(&val, 0, sizeof(val));
attr = swconfig_lookup_attr(dev, info, &val);
if (!attr || !attr->get)
goto error;

if (attr->type == SWITCH_TYPE_PORTS) {
val.value.ports = dev->portbuf;
memset(dev->portbuf, 0,
sizeof(struct switch_port) * dev->ports);
} else if (attr->type == SWITCH_TYPE_LINK) {
val.value.link = &dev->linkbuf;
memset(&dev->linkbuf, 0, sizeof(struct switch_port_link));
}

err = attr->get(dev, attr, &val);
if (err)
goto error;

msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
if (!msg)
goto error;

hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &switch_fam,
0, cmd);
if (IS_ERR(hdr))
goto nla_put_failure;

switch (attr->type) {
case SWITCH_TYPE_INT:
if (nla_put_u32(msg, SWITCH_ATTR_OP_VALUE_INT, val.value.i))
goto nla_put_failure;
break;
case SWITCH_TYPE_STRING:
if (nla_put_string(msg, SWITCH_ATTR_OP_VALUE_STR, val.value.s))
goto nla_put_failure;
break;
case SWITCH_TYPE_PORTS:
err = swconfig_send_ports(&msg, info,
SWITCH_ATTR_OP_VALUE_PORTS, &val);
if (err < 0)
goto nla_put_failure;
break;
case SWITCH_TYPE_LINK:
err = swconfig_send_link(msg, info,
SWITCH_ATTR_OP_VALUE_LINK, val.value.link);
if (err < 0)
goto nla_put_failure;
break;
default:
pr_debug("invalid type in attribute\n");
err = -EINVAL;
goto nla_put_failure;
}
genlmsg_end(msg, hdr);
err = msg->len;
if (err < 0)
goto nla_put_failure;

swconfig_put_dev(dev);
return genlmsg_reply(msg, info);

nla_put_failure:
if (msg)
nlmsg_free(msg);
error:
swconfig_put_dev(dev);
if (!err)
err = -ENOMEM;
return err;
}

The above function is used to return an attribute information in a switch port device, however this function calls
another function “swconfig_send_ports”. The function “swconfig_send_ports” is called when the type of the  attribute
is SWITCH




NEXT




<s> static int rtl8367_set_vlan_mc(struct rtl8366_smi *smi, u32 index,
const struct rtl8366_vlan_mc *vlanmc)
{
u32 data[RTL8367_VLAN_MC_DATA_SIZE];
int err;
int i;

if (index >= RTL8367_NUM_VLANS ||
vlanmc->vid >= RTL8367_NUM_VIDS ||
vlanmc->priority > RTL8367_PRIORITYMAX ||
vlanmc->member > RTL8367_VLAN_MC_MEMBER_MASK ||
vlanmc->untag > RTL8367_UNTAG_MASK ||
vlanmc->fid > RTL8367_FIDMAX)
return -EINVAL;

data[0] = (vlanmc->member & RTL8367_VLAN_MC_MEMBER_MASK) <<
RTL8367_VLAN_MC_MEMBER_SHIFT;
data[1] = (vlanmc->fid & RTL8367_VLAN_MC_FID_MASK) <<
RTL8367_VLAN_MC_FID_SHIFT;
data[2] = 0;
data[3] = (vlanmc->vid & RTL8367_VLAN_MC_EVID_MASK) <<
RTL8367_VLAN_MC_EVID_SHIFT;

for (i = 0; i < ARRAY_SIZE(data); i++)
REG_WR(smi, RTL8367_VLAN_MC_BASE(index) + i, data[i]);

return 0;
}

The above function is used to set multi-destination forwarding entries in RTL8367. It takes in a VLANMC structure, which contains the
information for setting up a multi-destination forwarding entry. This structure includes the VID, the priority,




NEXT




<s> inline int rtl930x_tbl_access_data_0(int i)
{
return RTL930X_TBL_ACCESS_DATA_0(i);
}

The above function is used to access the register table. However, this is
not good since for the register RTL930X_TBL_ACCESS_DATA_0 the first 8 bit of
each entry represents the access privilege code and the last 2




NEXT




<s> static void aw9523_irq_bus_lock(struct irq_data *d)
{
struct aw9523 *awi = gpiochip_get_data(irq_data_get_irq_chip_data(d));

mutex_lock(&awi->irq->lock);
regcache_cache_only(awi->regmap, true);
}

The above function is used to protect bus and other stuff. I don't think
that such kind of lock will be suitable for regmap_read/write since they
are usually called from IRQ handler and in most cases IRQ handlers run at
thread level




NEXT




<s> static void rt5350_tx_dma(struct fe_tx_dma *txd)
{
txd->txd4 = 0;
}

The above function is used to generate a packet. I want to add some extra information (say a 20-bit counter) to this packet. How can I do this using this function?
And how (or from where/which device driver) will I get the




NEXT




<s> static void rtl83xx_setup_l2_mc_entry(struct rtl838x_l2_entry *e, int vid, u64 mac, int mc_group)
{
memset(e, 0, sizeof(*e));

e->type = L2_MULTICAST;
e->valid = true;

e->mc_portmask_index = mc_group;

e->rvid = e->vid = vid;
e->is_ip_mc = e->is_ipv6_mc = false;
u64_to_ether_addr(mac, e->mac);
}

The above function is used to set-up L2 multicast filtering entries.  It takes as input, a pointer to the multicast filter entry, the multicast group, the MAC address to be learned and the multicast group index where it will




NEXT




<s> DEFINE_MUTEX(miim_lock);

static u32 rtl8231_read(struct rtl8231_gpios *gpios, u32 reg)
{
u32 t = 0, n = 0;

reg &= 0x1f;

/* Calculate read register address */
t = (gpios->smi_bus_id << 2) | (reg << 7);

/* Set execution bit: cleared when operation completed */
t |= 1;

/* Start execution */
sw_w32(t, gpios->ext_gpio_indrt_access);
do {
udelay(1);
t = sw_r32(gpios->ext_gpio_indrt_access);
n++;
} while ((t & 1) && (n < USEC_TIMEOUT));

if (n >= USEC_TIMEOUT)
return 0x80000000;

pr_debug("%s: %x, %x, %x\n", __func__, gpios->smi_bus_id,
reg, (t & 0xffff0000) >> 16);

return (t & 0xffff0000) >> 16;
}

The above function is used to read values from the GPIOS (General Purpose I/O Space).
Each GPIO is defined in the following format. In my case, I am using the AK8975 chip for a 3-axis accelerometer.




NEXT




<s> ret_t rtl8367c_setAsicStormFilterExtUnknownMulticastEnable(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_UNKNOWN_MCAST_EXT_EN_OFFSET, enabled);
}

The above function is used to enable or disable storming on unknown multicast packets. This feature is designed for network monitoring. If this feature is enabled, the MAC address table will not be used for unknown multicast storm control, resulting in more storming events. Con




NEXT




<s> static void rtk_hal_dump_table(void)
{
rtk_uint32 i;
rtk_uint32 address = 0;
rtk_l2_ucastAddr_t l2_data;
rtk_l2_ipMcastAddr_t ipMcastAddr;
rtk_l2_age_time_t age_timout;

rtk_l2_aging_get(&age_timout);
printk("Mac table age timeout =%d\n",(unsigned int)age_timout);

printk("hash  port(0:17)   fid   vid  mac-address\n");
while (1) {
if (rtk_l2_addr_next_get(READMETHOD_NEXT_L2UC, UTP_PORT0, &address, &l2_data) != RT_ERR_OK) {
break;
} else {
printk("%03x   ", l2_data.address);
for (i = 0; i < 5; i++)
if ( l2_data.port == i)
printk("1");
else
printk("-");
for (i = 16; i < 18; i++)
if ( l2_data.port == i)
printk("1");
else
printk("-");

printk("      %2d", l2_data.fid);
printk("  %4d", l2_data.cvid);
printk("  %02x%02x%02x%02x%02x%02x\n", l2_data.mac.octet[0],
l2_data.mac.octet[1], l2_data.mac.octet[2], l2_data.mac.octet[3],
l2_data.mac.octet[4], l2_data.mac.octet[5]);
address ++;
}
}

address = 0;
while (1) {
if (rtk_l2_ipMcastAddr_next_get(&address, &ipMcastAddr) != RT_ERR_OK) {
break;
} else {
printk("%03x   ", ipMcastAddr.address);
for (i = 0; i < 5; i++)
printk("%c", RTK_PORTMASK_IS_PORT_SET(ipMcastAddr.portmask, i) ? '1' : '-');
for (i = 16; i < 18; i++)
printk("%c", RTK_PORTMASK_IS_PORT_SET(ipMcastAddr.portmask, i) ? '1' : '-');
printk("                ");
printk("01005E%06x\n", (ipMcastAddr.dip & 0xefffff));
address ++;
}
}
}

The above function is used to print MAC table and multi-case port table. It is added as part of rtk_app_hal.c. The program can be built as follows:

> make clean
> make
> insmod rtk_app_




NEXT




<s> rtk_api_ret_t rtk_mirror_portIso_set(rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicPortMirrorIsolation(enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure mirror port isolation. The mirror port isolation feature is used to create a loop-free mirror when the inverted mirror port is not available.
The mirror port with mirror isolation should not be set to VLAN trunk port.

#if




NEXT




<s> ar8316_init_globals(struct ar8xxx_priv *priv)
{
/* standard atheros magic */
ar8xxx_write(priv, 0x38, 0xc000050e);

/* enable cpu port to receive multicast and broadcast frames */
ar8xxx_write(priv, AR8216_REG_FLOOD_MASK, 0x003f003f);

/* enable jumbo frames */
ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
AR8316_GCTRL_MTU, 9018 + 8 + 2);

/* Enable MIB counters */
ar8xxx_rmw(priv, AR8216_REG_MIB_FUNC, AR8216_MIB_FUNC | AR8236_MIB_EN,
(AR8216_MIB_FUNC_NO_OP << AR8216_MIB_FUNC_S) |
AR8236_MIB_EN);
}

The above function is used to initialize the AR8216 hardware. The
function configures the CPU port to receive frames and also enables
jumbo frames. The next step is to configure the port for the AR8216.
The following function config




NEXT




<s> void rtk_hal_dump_full_mib(void)
{
rtk_port_t port;
rtk_stat_counter_t Cntr;
rtk_stat_port_type_t cntr_idx;

for (port = UTP_PORT0; port < (UTP_PORT0 + 5); port++) {
printk("\nPort%d\n", port);
for (cntr_idx = STAT_IfInOctets; cntr_idx < STAT_PORT_CNTR_END; cntr_idx ++) {
rtk_stat_port_get(port, cntr_idx, &Cntr);
printk("%8llu ", Cntr);
if (((cntr_idx%10) == 9))
printk("\n");
}
}

for (port = EXT_PORT0; port < (EXT_PORT0 + 2); port++) {
printk("\nPort%d\n", port);
for (cntr_idx = STAT_IfInOctets; cntr_idx < STAT_PORT_CNTR_END; cntr_idx ++) {
rtk_stat_port_get(port, cntr_idx, &Cntr);
printk("%8llu ", Cntr);
if (((cntr_idx%10) == 9))
printk("\n");
}
}
rtk_stat_global_reset();
}

The above function is used to dump the MAC layer traffic counters. From above code, we can easily see that the port 0 is the port of USB module, so it is port 7 on the physical board.

#include <rtk_board.h




NEXT




<s> YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to indicate that the input should be read
interactively(for example, if yyin is stdin, the user can hit Ctrl-D in
input to break a loop reading to the end of the file).


1.




NEXT




<s> static bool nmbm_rescue_single_info_table(struct nmbm_instance *ni)
{
uint32_t table_start_ba, table_end_ba, write_ba;
bool success;

/* Try to write new info table in front of existing table */
success = nmbm_write_info_table(ni, ni->mgmt_start_ba,
ni->main_table_ba,
&table_start_ba,
&table_end_ba);
if (success) {
/*
* New table becomes the main table, existing table becomes
* the backup table.
*/
ni->backup_table_ba = ni->main_table_ba;
ni->main_table_ba = table_start_ba;

nmbm_mark_tables_clean(ni);

/* Erase spare blocks of main table to clean possible interference data */
nmbm_erase_range(ni, table_end_ba, ni->backup_table_ba);

nlog_table_creation(ni, true, table_start_ba, table_end_ba);

return true;
}

/* Try to reserve spare blocks for existing table */
success = nmbm_try_reserve_blocks(ni, ni->mapping_blocks_ba, &write_ba,
ni->info_table_spare_blocks, 0,
ni->mapping_blocks_top_ba -
size2blk(ni, ni->info_table_size));
if (!success) {
nlog_warn(ni, "Failed to rescue single info table\n");
return false;
}

/* Try to write new info table next to the existing table */
while (write_ba >= ni->mapping_blocks_ba) {
success = nmbm_write_info_table(ni, write_ba,
ni->mapping_blocks_top_ba,
&table_start_ba,
&table_end_ba);
if (success)
break;

write_ba--;
}

if (success) {
/* Erase spare blocks of main table to clean possible interference data */
nmbm_erase_range(ni, ni->mapping_blocks_ba, table_start_ba);

/* New table becomes the backup table */
ni->backup_table_ba = table_start_ba;
ni->mapping_blocks_ba = table_end_ba;

nmbm_mark_tables_clean(ni);

nlog_table_creation(ni, false, table_start_ba, table_end_ba);

return true;
}

nlog_warn(ni, "Failed to rescue single info table\n");
return false;
}

The above function is used to rescue a single NMBM info table in a situation where the original NMBM instance with two tables cannot be repaired, and it tries to use a spare table to replace it. It starts at the mapping blocks and attempts to write the info




NEXT




<s> static ssize_t stp_state_write(struct file *filp, const char __user *buffer,
size_t count, loff_t *ppos)
{
struct rtl838x_port *p = filp->private_data;
u32 value;
size_t res = rtl838x_common_write(buffer, count, ppos, &value);
if (res < 0)
return res;

rtl83xx_port_stp_state_set(p->dp->ds, p->dp->index, (u8)value);

return res;
}

The above function is used to write (set) the STP state of a given port, in
which the port is being operated.

The user input value (buffer) is written to the chip directly through call
to rtl838x_common_




NEXT




<s> void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to create a new buffer state and set the current one to it. This is the usual way to add a new file to the parser state, when some new file is wanted from the user.

#define yy_set_buffer(buffer)




NEXT




<s> rtk_api_ret_t rtk_qos_dscpRemarkSrcSel_get(rtk_qos_dscpRmkSrc_t *pType)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_getAsicRemarkingDscpSrc(pType)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve all 4 values from the register. In order to display the 4 values individually as below, the function will have to be invoked 4 times in a loop.</s>




NEXT




<s> static int aw9523_hw_init(struct aw9523 *awi)
{
u8 p1_pin = AW9523_PINS_PER_PORT;
unsigned int val;
int ret;

/* No register caching during initialization */
regcache_cache_bypass(awi->regmap, true);

/* Bring up the chip */
ret = aw9523_hw_reset(awi);
if (ret) {
dev_err(awi->dev, "HW Reset failed: %d\n", ret);
return ret;
}

/*
* This is the expected chip and it is running: it's time to
* set a safe default configuration in case the user doesn't
* configure (all of the available) pins in this chip.
* P.S.: The writes order doesn't matter.
*/

/* Set all pins as GPIO */
ret = regmap_write(awi->regmap, AW9523_REG_PORT_MODE(0), U8_MAX);
if (ret)
return ret;
ret = regmap_write(awi->regmap, AW9523_REG_PORT_MODE(p1_pin), U8_MAX);
if (ret)
return ret;

/* Set Open-Drain mode on Port 0 (Port 1 is always P-P) */
ret = regmap_write(awi->regmap, AW9523_REG_GCR, 0);
if (ret)
return ret;

/* Set all pins as inputs */
ret = regmap_write(awi->regmap, AW9523_REG_CONF_STATE(0), U8_MAX);
if (ret)
return ret;
ret = regmap_write(awi->regmap, AW9523_REG_CONF_STATE(p1_pin), U8_MAX);
if (ret)
return ret;

/* Disable all interrupts to avoid unreasoned wakeups */
ret = regmap_write(awi->regmap, AW9523_REG_INTR_DIS(0), U8_MAX);
if (ret)
return ret;
ret = regmap_write(awi->regmap, AW9523_REG_INTR_DIS(p1_pin), U8_MAX);
if (ret)
return ret;

/* Clear setup-generated interrupts by performing a port state read */
ret = aw9523_get_port_state(awi->regmap, 0, 0, &val);
if (ret)
return ret;
ret = aw9523_get_port_state(awi->regmap, p1_pin, 0, &val);
if (ret)
return ret;

/* Everything went fine: activate and reinitialize register cache */
regcache_cache_bypass(awi->regmap, false);
return regmap_reinit_cache(awi->regmap, &aw9523_regmap);
}

The above function is used to initalize/initialize the chip (I’m using it for writing purposes and I’ve seen many examples with the “initialize” spelling, so I’ll stick to whichever one will save me typing) when the Linux kernel




NEXT




<s> static int rtl9300_serdes_probe(struct phy_device *phydev)
{
if (soc_info.family != RTL9300_FAMILY_ID)
return -ENODEV;

phydev_info(phydev, "Detected internal RTL9300 Serdes\n");

return rtl9300_configure_serdes(phydev);
}

The above function is used to query the presence of SerDes chips in the
RTL9300 ASIC. This is done by checking the value of a certain register
bit. This chip presence check is the last bit of info required by
libphy, so




NEXT




<s> static int __init gpio_button_init(void)
{
int ret;

ret = platform_driver_register(&gpio_keys_driver);
if (ret)
return ret;

ret = platform_driver_register(&gpio_keys_polled_driver);
if (ret)
platform_driver_unregister(&gpio_keys_driver);

return ret;
}

The above function is used to load the gpio key driver module. A function is created to probe the key driver device tree node and attach the corresponding driver to it.

The probe function creates GPIO keys and polled polling device tree nodes and registers them as sysfs




NEXT




<s> int serial_console_tstc(void)
{
return ((in_8(reg_base + (UART_LSR << reg_shift)) & UART_LSR_DR) != 0);
}

The above function is used to check if there is an empty byte in the receive register. It checks the UART LSR register (Location/Status Register) which is bit D0 in the lower 5 bits.

The UART LSR register contains the following





NEXT




<s> rtk_api_ret_t rtk_stat_global_reset(void)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_setAsicMIBsCounterReset(TRUE,FALSE, 0)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to reset MIB counters to be used to calculate MAC table hit rate or other MAC table counters.

Notice that, the input parameter to this function should be TRUE; however it’s ignored when the code is compiled at the Linux




NEXT




<s> static int aw9523_pconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
unsigned long *configs, unsigned int num_configs)
{
struct aw9523 *awi = pinctrl_dev_get_drvdata(pctldev);
enum pin_config_param param;
int regbit = pin % AW9523_PINS_PER_PORT;
u32 arg;
u8 reg;
unsigned int mask, val;
int i, rc;

mutex_lock(&awi->i2c_lock);
for (i = 0; i < num_configs; i++) {
param = pinconf_to_config_param(configs[i]);
arg = pinconf_to_config_argument(configs[i]);

rc = aw9523_pcfg_param_to_reg(param, pin, &reg);
if (rc)
goto end;

switch (param) {
case PIN_CONFIG_OUTPUT:
/* First, enable pin output */
rc = regmap_update_bits(awi->regmap,
AW9523_REG_CONF_STATE(pin),
BIT(regbit), 0);
if (rc)
goto end;

/* Then, fall through to config output level */
fallthrough;
case PIN_CONFIG_OUTPUT_ENABLE:
arg = !arg;
fallthrough;
case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
case PIN_CONFIG_BIAS_PULL_DOWN:
case PIN_CONFIG_BIAS_PULL_UP:
case PIN_CONFIG_INPUT_ENABLE:
mask = BIT(regbit);
val = arg ? BIT(regbit) : 0;
break;
case PIN_CONFIG_DRIVE_OPEN_DRAIN:
/* Open-Drain is supported only on port 0 */
if (pin >= AW9523_PINS_PER_PORT) {
rc = -ENOTSUPP;
goto end;
}
mask = AW9523_GCR_GPOMD_MASK;
val = 0;
break;
case PIN_CONFIG_DRIVE_PUSH_PULL:
/* Port 1 is always Push-Pull */
if (pin >= AW9523_PINS_PER_PORT) {
mask = 0;
val = 0;
continue;
}
mask = AW9523_GCR_GPOMD_MASK;
val = AW9523_GCR_GPOMD_MASK;
break;
default:
rc = -ENOTSUPP;
goto end;
}

rc = regmap_update_bits(awi->regmap, reg, mask, val);
if (rc)
goto end;
}
end:
mutex_unlock(&awi->i2c_lock);
return rc;
}

The above function is used to set pins.</s>




NEXT




<s> static void rtl838x_vlan_fwd_on_inner(int port, bool is_set)
{
if (is_set)
sw_w32_mask(BIT(port), 0, RTL838X_VLAN_PORT_FWD);
else
sw_w32_mask(0, BIT(port), RTL838X_VLAN_PORT_FWD);
}

The above function is used to configure the rx fwd capability to inner Vlan port
when there is rx vlan fwd-enable/disable (inner vlan) configuration change.
It will clear the old configuration based on the old config, and then set new





NEXT




<s> ar8xxx_free(struct ar8xxx_priv *priv)
{
if (priv->chip && priv->chip->cleanup)
priv->chip->cleanup(priv);

kfree(priv->chip_data);
kfree(priv->mib_stats);
kfree(priv);
}

The above function is used to free resources which are allocated during the ar8xxx_init() function above. I’m trying to understand why the “chip_data” is set to NULL at the end of the above function. I’m guessing this allows the functions




NEXT




<s> static int ar934x_nfc_hw_init(struct ar934x_nfc *nfc)
{
ar934x_nfc_hw_reset_assert(nfc);
ar934x_nfc_hw_reset_deassert(nfc);
/*
* setup timings
* TODO: make it configurable via platform data or DT
*/
ar934x_nfc_wr(nfc, AR934X_NFC_REG_TIME_SEQ,
AR934X_NFC_TIME_SEQ_DEFAULT);
ar934x_nfc_wr(nfc, AR934X_NFC_REG_TIMINGS_ASYN,
AR934X_NFC_TIMINGS_ASYN_DEFAULT);
ar934x_nfc_wr(nfc, AR934X_NFC_REG_TIMINGS_SYN,
AR934X_NFC_TIMINGS_SYN_DEFAULT);

/* disable WP on all chips, and select chip 0 */
ar934x_nfc_wr(nfc, AR934X_NFC_REG_MEM_CTRL, 0xff00);

ar934x_nfc_wr(nfc, AR934X_NFC_REG_DMA_ADDR_OFFS, 0);

/* initialize Control register */
nfc->ctrl_reg = AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);

if (nfc->small_page) {
/*  Setup generic sequence register for small page reads. */
ar934x_nfc_wr(nfc, AR934X_NFC_REG_GEN_SEQ_CTRL,
AR934X_NFC_GENSEQ_SMALL_PAGE_READ);
}

return 0;
}

The above function is used to initialize the NFC hardware before any
operation. It is called from ar934x_nfc_isr_init(). There are not many
things there - a reset pulse, default timing initialization, enable WP
on all




NEXT




<s> rtk_api_ret_t  rtk_oam_parserAction_get(rtk_port_t port, rtk_oam_parser_act_t *pAction)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicOamParser(rtk_switch_port_L2P_get(port), pAction))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read OAM Parser Actions.

rtk_api_ret_t  rtk_oam_parserAction_set(rtk_port_t port, rtk_oam_parser_act_t action




NEXT




<s> print_usage(void)
{
printf("swconfig list\n");
printf("swconfig dev <dev> [port <port>|vlan <vlan>] (help|set <key> <value>|get <key>|load <config>|show)\n");
exit(1);
}

The above function is used to print the usage information of the swconfig command.

### Step 3: Parse CLI parameters

The parameters passed to the swconfig command can be parsed using the parse_input() function. This function is defined in the parsing




NEXT




<s> static void conf_warning(const char *fmt, ...)
__attribute__ ((format (printf, 1, 2)));

static void conf_message(const char *fmt, ...)
__attribute__ ((format (printf, 1, 2)));

static const char *conf_filename;
static int conf_lineno, conf_warnings;

static void conf_warning(const char *fmt, ...)
{
va_list ap;
va_start(ap, fmt);
fprintf(stderr, "%s:%d:warning: ", conf_filename, conf_lineno);
vfprintf(stderr, fmt, ap);
fprintf(stderr, "\n");
va_end(ap);
conf_warnings++;
}

The above function is used to generate and output warning messages. The variable conf_warnings is the overall total number of warnings. The static variable conf_filename is the filename of the configuration file, useful for reporting warnings in files which use the conf_xxx macro.






NEXT




<s> static inline uint64_t read_uint64(void *buf, ptrdiff_t off)
{
uint64_t tmp = *(uint64_t *)(buf + off);
if (swap_bytes) {
tmp = be64toh(tmp);
}
return tmp;
}

The above function is used to read uint64_t data from a file. I was previously using it for reading uint32_t, and it worked just fine. But now on a machine with an AMD processor and Linux (in other words, a machine where swap




NEXT




<s> static void aca_init_parse(struct dc_ep_priv *priv, const char *data,
u32 sid)
{
struct aca_fw_param *fw_param = to_aca_fw_param(priv);
struct aca_fw_param *param;
u32 hdr_sz, hdr_addr;

param = (struct aca_fw_param *)data;
hdr_sz = be32_to_cpu(param->st_sz);
hdr_addr = be32_to_cpu(param->init_addr);

fw_param->init_addr = hdr_addr;
fw_param->st_sz = hdr_sz;
dev_dbg(priv->dev, "init st size: %d, addr: 0x%x\n",
hdr_sz, hdr_addr);
}

The above function is used to parse the ACA initial section. In the real device, there is only support for SIP for the ACA bootloader. Therefore, the function will just set fw_param->num_init_cmd to 0, and initialize its




NEXT




<s> static int rtl8366rb_reset_chip(struct rtl8366_smi *smi)
{
int timeout = 10;
u32 data;

rtl8366_smi_write_reg_noack(smi, RTL8366RB_RESET_CTRL_REG,
RTL8366RB_CHIP_CTRL_RESET_HW);
do {
msleep(1);
if (rtl8366_smi_read_reg(smi, RTL8366RB_RESET_CTRL_REG, &data))
return -EIO;

if (!(data & RTL8366RB_CHIP_CTRL_RESET_HW))
break;
} while (--timeout);

if (!timeout) {
printk("Timeout waiting for the switch to reset\n");
return -EIO;
}

return 0;
}

The above function is used to reset the switch chip.

This entry was posted in Network Processor / Data Plane Processors, Switching. Bookmark the .</s>




NEXT




<s> pwsetup(out, tpwd, tcnf)
struct t_passwd * out;
struct t_pwent * tpwd;
struct t_confent * tcnf;
{
out->tp.name = tpwd->name;
out->tp.password.len = tpwd->password.len;
out->tp.password.data = tpwd->password.data;
out->tp.salt.len = tpwd->salt.len;
out->tp.salt.data = tpwd->salt.data;
out->tp.index = tpwd->index;

out->tc.index = tcnf->index;
out->tc.modulus.len = tcnf->modulus.len;
out->tc.modulus.data = tcnf->modulus.data;
out->tc.generator.len = tcnf->generator.len;
out->tc.generator.data = tcnf->generator.data;
}

The above function is used to create a structure containing username, password, salt value from the password database entry and index from the configuration database. It is used only in the pwcheck function.</s>




NEXT




<s> static int rtl83xx_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
void *cb_priv)
{
struct rtl838x_switch_priv *priv = cb_priv;

switch (type) {
case TC_SETUP_CLSFLOWER:
pr_debug("%s: TC_SETUP_CLSFLOWER\n", __func__);
return rtl83xx_setup_tc_cls_flower(priv, type_data);
default:
return -EOPNOTSUPP;
}
}

The above function is used to setup a TC flow
(for packet classification), with a setup callback, and passes
the associated flow block data as type data argument.</s>




NEXT




<s> static inline int rtl838x_l2_port_new_salrn(int p)
{
return RTL838X_L2_PORT_NEW_SALRN(p);
}

The above function is used to generate the SALRN bits in the PBRRD for a P port.
Unfortunately, with the existing code, there is no way to tell if a particular PBRRD value is a valid or invalid PBRRD




NEXT




<s> int yyget_debug ( void );

void yyset_debug ( int debug_flag  );

YY_EXTRA_TYPE yyget_extra ( void );

void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to convert the YY_CHAR type to a yytype_int16.
If it can't, it returns YY_NULL. If it can, the returned value is returned.
*/

#define YY_RETURN




NEXT




<s> rtk_api_ret_t rtk_led_enable_set(rtk_led_group_t group, rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;
rtk_port_t port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (group >= LED_GROUP_END)
return RT_ERR_INPUT;

RTK_CHK_PORTMASK_VALID(pPortmask);

RTK_PORTMASK_SCAN((*pPortmask), port)
{
if(rtk_switch_isCPUPort(port) == RT_ERR_OK)
return RT_ERR_PORT_MASK;
}

if((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicLedGroupEnable(group, pmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to to enable or disable LED groups. The supported LED groups are 0 to 11 (LED_GROUP_END is equal to 11 ) LED0 to LED4 are mapped to MAC 0 to 4, LED5 to LED




NEXT




<s> BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)
{
int i;
BN_ULONG *A;
const BN_ULONG *B;

bn_check_top(b);

if (a == b) return(a);
if (bn_wexpand(a,b->top) == NULL) return(NULL);

#if 1
A=a->d;
B=b->d;
for (i=b->top>>2; i>0; i--,A+=4,B+=4)
{
BN_ULONG a0,a1,a2,a3;
a0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];
A[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;
}
switch (b->top&3)
{
case 3: A[2]=B[2];
case 2: A[1]=B[1];
case 1: A[0]=B[0];
case 0: ; /* ultrix cc workaround, see comments in bn_expand2 */
}
#else
memcpy(a->d,b->d,sizeof(b->d[0])*b->top);
#endif

/*      memset(&(a->d[b->top]),0,sizeof(a->d[0])*(a->max-b->top));*/
a->top=b->top;
if ((a->top == 0) && (a->d != NULL))
a->d[0]=0;
a->neg=b->neg;
return(a);
}

The above function is used to copy values from any given object to another. This function will be very helpful in the following section while comparing numbers.

void ulong2buf (unsigned long val, int len, unsigned char *buf)
{

while (len




NEXT




<s> rtk_api_ret_t rtk_ptp_refTime_get(rtk_ptp_timeStamp_t *pTimeStamp)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_getAsicEavSysTime(&pTimeStamp->sec, &pTimeStamp->nsec))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read the current system time from hardware. To set the system time in hardware, add the following function to your driver code:

rtk_api_ret_t rtk_ptp_sysTime_set(rtk_pt




NEXT




<s> static void rtlglue_drvMutexLock(void)
{
/* It is empty currently. Implement this function if Lock/Unlock function is needed */
return;
}

The above function is used to implement locking mechanism on device.
In other words, this function is used to acquire a unique serial code so that thread/process
can have synchronization mechanism if there are several threads/processes working on the same device
at the same




NEXT




<s> void ifx_ptm_uninit_chip(void)
{
uninit_pmu();
}

The above function is used to un-initialize PTM related functions.

void ifx_ptm_uninit_pmu(void)
{
}

The above function is used to uninitialize pmu.

void ifx_ptm




NEXT




<s> void rtl9300_sds_rxcal_vth_get(u32  sds_num, u32 vth_list[])
{
u32 vth_manual;

/* ##Page0x1F, Reg0x02[15 0], REG_DBGO_SEL=[0x002F]; */ /* Lane0 */
/* ##Page0x1F, Reg0x02[15 0], REG_DBGO_SEL=[0x0031]; */ /* Lane1 */
if (!(sds_num % 2))
rtl930x_write_sds_phy(sds_num, 0x1f, 0x2, 0x2f);
else
rtl930x_write_sds_phy(sds_num - 1, 0x1f, 0x2, 0x31);

/* ##Page0x2E, Reg0x15[9], REG0_RX_EN_TEST=[1] */
rtl9300_sds_field_w(sds_num, 0x2e, 0x15, 9, 9, 0x1);
/* ##Page0x21, Reg0x06[11 6], REG0_RX_DEBUG_SEL=[1 0 x x x x] */
rtl9300_sds_field_w(sds_num, 0x21, 0x06, 11, 6, 0x20);
/* ##Page0x2F, Reg0x0C[5 0], REG0_COEF_SEL=[0 0 1 1 0 0] */
rtl9300_sds_field_w(sds_num, 0x2f, 0x0c, 5, 0, 0xc);

mdelay(1);

/* ##VthP & VthN Read Out */
vth_list[0] = rtl9300_sds_field_r(sds_num, 0x1f, 0x14, 2, 0); /* v_thp set bin */
vth_list[1] = rtl9300_sds_field_r(sds_num, 0x1f, 0x14, 5, 3); /* v_thn set bin */

pr_info("vth_set_bin = %d", vth_list[0]);
pr_info("vth_set_bin = %d", vth_list[1]);

vth_manual = !!rtl9300_sds_field_r(sds_num, 0x2e, 0x0f, 13, 13);
pr_info("Vth Maunal = %d", vth_manual);
}

The above function is used to read the value of vth_set_bin[0] and vth_set_bin[1]
in the R2 page and the value of 0x0f[13] in the R8E page.</s>




NEXT




<s> ret_t rtl8367c_setAsicPortLoopback(rtk_uint32 port, rtk_uint32 enable)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_PORT0_MISC_CFG_MAC_LOOPBACK_OFFSET, enable);
}

The above function is used to set the value of the field rtl8367c_setAsicPortLoopback in RTL8367C_PORT_MISC_CFG with a specified value.

Here is the corresponding register setting procedure




NEXT




<s> int ctr_basic_aes_encrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int enc_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = enc_bytes = walk.nbytes) && (walk.nbytes >= AES_BLOCK_SIZE)) {
enc_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_ctr(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, enc_bytes, CRYPTO_DIR_ENCRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

/* to handle remaining bytes < AES_BLOCK_SIZE */
if (walk.nbytes) {
ifx_deu_aes_ctr(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, walk.nbytes, CRYPTO_DIR_ENCRYPT, 0);
err = skcipher_walk_done(&walk, 0);
}

return err;
}

The above function is used to encrypt the data which is input to the driver. During decryption, the same function is used to decrypt the data. Thus AES_ALG structure is used to encrypt and decrypt the data.</s>




NEXT




<s> static int wlc_bssiovar(wlc_param param, void *data, void *value)
{
int *val = (int *) value;
char *iov = *((char **) data);
int ret = 0;

if (param & SET) {
switch(param & PARAM_TYPE) {
case INT:
ret = wl_bssiovar_setint(interface, iov, vif, *val);
}
}
if (param & GET) {
switch(param & PARAM_TYPE) {
case INT:
ret = wl_bssiovar_get(interface, iov, vif, val, sizeof(int));
}
}

return ret;
}

The above function is used to set or get a variable of bssid table. When we use these functions, we need to consider 3 things:

1. Interface; you use this interface to call these functions, because different interfaces may contain different bss




NEXT




<s> ar7240sw_hw_init(struct ar8xxx_priv *priv)
{
if (priv->initialized)
return 0;

ar8xxx_write(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET);
ar8xxx_reg_wait(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET, 0, 1000);

priv->port4_phy = 1;
/* disable port5 to prevent mii conflict */
ar8xxx_write(priv, AR8216_REG_PORT_STATUS(5), 0);

ar8xxx_phy_init(priv);

priv->initialized = true;
return 0;
}

The above function is used to initialize the PHY.

The following code is used to wait for the reset bit in the CTRL register to
clear itself.

ar8xxx_reg_wait(struct ar8xxx_priv &#40;struct




NEXT




<s> static void sata_oxnas_post_internal_cmd(struct ata_queued_cmd *qc)
{
DPRINTK("ENTER\n");
/* If the core is busy here, make it idle */
if (qc->flags & ATA_QCFLAG_FAILED)
sata_oxnas_cleanup(qc->ap->host);
}

The above function is used to post an internal command to an AHCI controller and the function above it is used to destroy the object in case of failure.

struct ahci_request {
struct ahci_host_state *ahi;
struct ata




NEXT




<s> static u32 bcm6348_int_cfg_readl(u32 reg)
{
struct bcm6348_pci *priv = &bcm6348_pci;
u32 tmp;

tmp = reg & MPI_PCICFGCTL_CFGADDR_MASK;
tmp |= MPI_PCICFGCTL_WRITEEN_MASK;
__raw_writel(tmp, priv->pci + MPI_PCICFGCTL_REG);
iob();
return __raw_readl(priv->pci + MPI_PCICFGDATA_REG);
}

The above function is used to read 4 bytes of a register that is 64 KB
from the PCI config space. In the absence of IOB control
(MSI/MSI-X interrupts would not be setup and interrupts would not be enabled




NEXT




<s> void conf_parse(const char *name)
{
struct symbol *sym;
int i;

zconf_initscan(name);

_menu_init();

#if YYDEBUG
if (getenv("ZCONF_DEBUG"))
yydebug = 1;
#endif
yyparse();

/* Variables are expanded in the parse phase. We can free them here. */
variable_all_del();

if (yynerrs)
exit(1);
if (!modules_sym)
modules_sym = sym_find( "n" );

if (!menu_has_prompt(&rootmenu)) {
current_entry = &rootmenu;
menu_add_prompt(P_MENU, "Main menu", NULL);
}

menu_finalize(&rootmenu);
for_all_symbols(i, sym) {
if (sym_check_deps(sym))
yynerrs++;
}
if (yynerrs)
exit(1);
conf_set_changed(true);
}

The above function is used to parse the configuration, but there are a lot of things going on there that would be much more convenient to handle as a direct operation on the tree. For example, the menu_add_prompt() call sets the prompt, and the menu_




NEXT




<s> rtk_api_ret_t rtk_rate_egrQueueBwCtrlRate_get(rtk_port_t port, rtk_qid_t queue, rtk_meter_id_t *pIndex)
{
rtk_api_ret_t retVal;
rtk_uint32 offset_idx;
rtk_uint32 phy_port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (queue >= RTK_MAX_NUM_OF_QUEUE)
return RT_ERR_QUEUE_ID;

if(NULL == pIndex)
return RT_ERR_NULL_POINTER;

phy_port = rtk_switch_port_L2P_get(port);
if ((retVal=rtl8367c_getAsicAprMeter(phy_port, queue,&offset_idx))!=RT_ERR_OK)
return retVal;

*pIndex = offset_idx + ((phy_port%4)*8);

return RT_ERR_OK;
}

The above function is used to read the index of APM configured by MMD. After configing APM by the following config_api function, we should use the function above to obtain the configuration of the bandwidth.</s>




NEXT




<s> static void rtk_hal_disable_igmpsnoop(void)
{
if (rtk_igmp_state_set(DISABLED) != RT_ERR_OK)
printk("Disable IGMP SNOOPING failed\n");
}

The above function is used to disable multicast snooping in RTL8153-based
boards (WRT54G4, WNR2366 and WRT600N+H). It is called by WL_DISABLE




NEXT




<s> rtk_api_ret_t rtk_igmp_leaveTimer_get(rtk_uint32 *pTimer)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pTimer)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPLeaveTimer(pTimer))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the IGMP Leave timer.</s>




NEXT




<s> ret_t rtl8367c_getAsicInterruptPolarity(rtk_uint32* pPolarity)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_INTR_CTRL, RTL8367C_INTR_CTRL_OFFSET, pPolarity);
}

The above function is used to read the interrupt polarity from the Asic.

The interrupt polarity specifies whether an interrupt is triggered in high level or low level.
We can get the interrupt status from RT_IRQn_enter.
This function shows the




NEXT




<s> static int rtl8367_extif_set_force(struct rtl8366_smi *smi, int id,
struct rtl8367_port_ability *pa)
{
u32 mask;
u32 val;
int err;

mask = (RTL8367_DI_FORCE_MODE |
RTL8367_DI_FORCE_NWAY |
RTL8367_DI_FORCE_TXPAUSE |
RTL8367_DI_FORCE_RXPAUSE |
RTL8367_DI_FORCE_LINK |
RTL8367_DI_FORCE_DUPLEX |
RTL8367_DI_FORCE_SPEED_MASK);

val = pa->speed;
val |= pa->force_mode ? RTL8367_DI_FORCE_MODE : 0;
val |= pa->nway ? RTL8367_DI_FORCE_NWAY : 0;
val |= pa->txpause ? RTL8367_DI_FORCE_TXPAUSE : 0;
val |= pa->rxpause ? RTL8367_DI_FORCE_RXPAUSE : 0;
val |= pa->link ? RTL8367_DI_FORCE_LINK : 0;
val |= pa->duplex ? RTL8367_DI_FORCE_DUPLEX : 0;

REG_RMW(smi, RTL8367_DI_FORCE_REG(id), mask, val);

return 0;
}

The above function is used to set certain bit in the force register, that is, enable or disable certain bit function. However during implementation I am not understanding these two lines:

REG_RMW(smi, RTL8367_DI_FORCE




NEXT




<s> void mt7620_mdio_link_adjust(struct fe_priv *priv, int port)
{
mt7620_print_link_state(priv, port, priv->link[port],
priv->phy->speed[port],
(priv->phy->duplex[port] == DUPLEX_FULL));
mt7620_handle_carrier(priv);
}

The above function is used to adjust the link state, but doesn't actually do anything to change the link state itself and I have no idea where the actual state adjustment code is.</s>




NEXT




<s> static int rtl930x_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
{
return rtl930x_mdio_read_paged(bus, mii_id, 0, regnum);
}

The above function is used to get MAC PHY register value by MII API.
When we use MDIO API to read MAC PHY register value, it takes so
much time. Why?

During MDIO API, this function is called:





NEXT




<s> ar8xxx_reg_wait(struct ar8xxx_priv *priv, u32 reg, u32 mask, u32 val,
unsigned timeout)
{
int i;

for (i = 0; i < timeout; i++) {
u32 t;

t = ar8xxx_read(priv, reg);
if ((t & mask) == val)
return 0;

usleep_range(1000, 2000);
cond_resched();
}

return -ETIMEDOUT;
}

The above function is used to poll and wait until a condition is set. The
function does not work because of two main reasons. The first reason is that
cond_resched() is called. In Linux Kernel, this macro is a busy loop. The
function




NEXT




<s> static void rtl930x_vlan_fwd_on_inner(int port, bool is_set)
{
/* Always set all tag modes to fwd based on either inner or outer tag */
if (is_set)
sw_w32_mask(0xf, 0, RTL930X_VLAN_PORT_FWD + (port << 2));
else
sw_w32_mask(0, 0xf, RTL930X_VLAN_PORT_FWD + (port << 2));
}

The above function is used to set up the tag mode to either forward in the
inner tag or outer tag. As it has to perform the same operation (masking)
for all four tag modes regardless of the value(0 or 1) of is_set,




NEXT




<s> ead_get_tx_iv(void)
{
unsigned int ofs;

ofs = 1 + ((ivofs_vec >> 2 * ivofs_idx) & 0x3);
ivofs_idx = (ivofs_idx + 1) % 16;
ead_tx_iv += ofs;

return ead_tx_iv;
}

The above function is used to generate encrypted packets. So, the IV value that is stored at the specified offset from the tx_iv field of tx_crypt_struct. Since the IV vector is 64 Bytes in size, and we are shifting by 




NEXT




<s> struct expr *expr_alloc_two(enum expr_type type, struct expr *e1, struct expr *e2)
{
struct expr *e = xcalloc(1, sizeof(*e));
e->type = type;
e->left.expr = e1;
e->right.expr = e2;
return e;
}

The above function is used to allocate an expression which contains two expressions and I am getting runtime error that shows the expression is double free.

When I print the e1 and e2 arguments, I realize they are both uninitialized and e->left.expr still points to




NEXT




<s> static inline int wait_no_error(int device)
{
int status = 0;

/* Check for ATA core error */
if (*(sata_regs_base[device] + SATA_INT_STATUS_OFF)
& (1 << SATA_INT_STATUS_ERROR_BIT)) {
printf("wait_no_error() SATA core flagged error\n");
} else {
int loops = MAX_NO_ERROR_LOOPS;
do {
/* Check for ATA device error */
if (!(ide_inb(device, ATA_PORT_COMMAND)
& (1 << ATA_STATUS_ERR_BIT))) {
status = 1;
break;
}
udelay(10);
} while (--loops);

if (!loops) {
printf("wait_no_error() Timed out of wait for SATA no-error condition\n");
}
}

return status;
}

The above function is used to check that the SATA core and the ATA device did not raise any errors after the host tried to issue a command. If the code reaches the end of the function without any errors, it means that the previous operation completed successfully. If not (




NEXT




<s> static void rtl9300_i2c_reg_addr_set(struct rtl9300_i2c *i2c, u32 reg, u16 len)
{
/* Set register address width */
REG_MASK(i2c, 0x3 << RTL9300_I2C_CTRL2_MADDR_WIDTH, len << RTL9300_I2C_CTRL2_MADDR_WIDTH,
RTL9300_I2C_CTRL2);

/* Set register address */
REG_MASK(i2c, 0xffffff << RTL9300_I2C_CTRL1_MEM_ADDR, reg << RTL9300_I2C_CTRL1_MEM_ADDR,
RTL9300_I2C_CTRL1);
}

The above function is used to set the register address and width to read/write data.

The function “RTL9300_I2C_CTRL2_MADDR_WIDTH” means the address width in register RTL9300_I




NEXT




<s> static int fe_mdio_reset(struct mii_bus *bus)
{
/* TODO */
return 0;
}

The above function is used to reset the MAC that is connected via MII.
Once the bus is ready to be used, one can simply use this
function called mii_bus_register() which looks something as
below

static int fe_mdio




NEXT




<s> static void rb91x_nand_read_buf(struct nand_chip *chip, u8 *buf, int len)
{
rb91x_nand_read(chip->priv, buf, len);
}

The above function is used to read data from the NAND flash. But as it's just a local function used in the NAND driver, there's no need to put it under the "export_symbol" attribute.

The code change is very simple and




NEXT




<s> static int reg_show(struct seq_file *seq, void *v)
{
return 0;
}

The above function is used to handle the show action.
Now let us try printing the value of some register in your board.
Make a file named regs.c in the drivers folder.
In this file write the below code:

#include #include





NEXT




<s> static bool nmbm_find_signature(struct nmbm_instance *ni,
struct nmbm_signature *signature,
uint32_t *signature_ba)
{
struct nmbm_signature sig;
uint64_t off, addr;
uint32_t block_count, ba, limit;
bool success;
int ret;

/* Calculate top and bottom block address */
block_count = bmtd.total_blks;
ba = block_count;
limit = (block_count / NMBM_MGMT_DIV) * (NMBM_MGMT_DIV - ni->max_ratio);
if (ni->max_reserved_blocks && block_count - limit > ni->max_reserved_blocks)
limit = block_count - ni->max_reserved_blocks;

while (ba >= limit) {
ba--;
addr = ba2addr(ni, ba);

if (nmbm_check_bad_phys_block(ni, ba))
continue;

/* Check every page.
* As long as at leaset one page contains valid signature,
* the block is treated as a valid signature block.
*/
for (off = 0; off < bmtd.blk_size;
off += bmtd.pg_size) {
ret = nmbn_read_data(ni, addr + off, &sig,
sizeof(sig));
if (ret)
continue;

/* Check for header size and checksum */
success = nmbm_check_header(&sig, sizeof(sig));
if (!success)
continue;

/* Check for header magic */
if (sig.header.magic == NMBM_MAGIC_SIGNATURE) {
/* Found it */
memcpy(signature, &sig, sizeof(sig));
*signature_ba = ba;
return true;
}
}
};

return false;
}

The above function is used to validate the signature.
The following code shows how to parse the signature from the disk.

uint32_t signature_ba;
ret = nmbm_find_signature(instance, signature, &signature_ba);





NEXT




<s> static void parse_key_names(struct tffs_entry *names_entry,
struct tffs_key_name_table *key_names)
{
uint32_t pos = 0, i = 0;
struct tffs_name_table_entry *name_item;

key_names->entries = NULL;

do {
key_names->entries = realloc(key_names->entries,
sizeof(struct tffs_name_table_entry) * (i + 1));
if (key_names->entries == NULL) {
fprintf(stderr, "ERROR: memory allocation failed!\n");
exit(EXIT_FAILURE);
}
name_item = &key_names->entries[i];

name_item->id = read_uint32(names_entry->val, pos);
pos += sizeof(uint32_t);
name_item->val = strdup((const char *)(names_entry->val + pos));

/*
* There is no "length" field because the string values are
* simply NULL-terminated -> strlen() gives us the size.
*/
pos += get_walk_size(strlen(name_item->val) + 1);

++i;
} while (pos < names_entry->len);

key_names->size = i;
}

The above function is used to parse the TFFS directory entries
– keyed file names, in particular. This function is in turn called
by the tffsparse_read_dir() function.

And the following is a code snippet from within the




NEXT




<s> static inline void init_ema(void);
static inline void init_mailbox(void);
static inline void init_atm_tc(void);
static inline void clear_share_buffer(void);



/*
* ####################################
*            Local Variable
* ####################################
*/



/*
* ####################################
*            Local Function
* ####################################
*/

#define IFX_PMU_MODULE_PPE_SLL01  BIT(19)
#define IFX_PMU_MODULE_PPE_TC     BIT(21)
#define IFX_PMU_MODULE_PPE_EMA    BIT(22)
#define IFX_PMU_MODULE_PPE_QSB    BIT(18)
#define IFX_PMU_MODULE_TPE       BIT(13)
#define IFX_PMU_MODULE_DSL_DFE    BIT(9)


static inline void init_pmu(void)
{
ltq_pmu_enable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_TPE |
IFX_PMU_MODULE_DSL_DFE);

}

The above function is used to enable pmu

#include "../common/pmu_ifx.h"
#include <ifxmips.h>
#include <ltq_pmx.h>

typedef enum {
IF




NEXT




<s> static void fe_phy_start(struct fe_priv *priv)
{
unsigned long flags;
int i;

for (i = 0; i < 8; i++) {
if (priv->phy->phy_fixed[i]) {
spin_lock_irqsave(&priv->phy->lock, flags);
priv->link[i] = 1;
if (priv->soc->mdio_adjust_link)
priv->soc->mdio_adjust_link(priv, i);
spin_unlock_irqrestore(&priv->phy->lock, flags);
} else if (priv->phy->phy[i]) {
phy_start(priv->phy->phy[i]);
}
}
}

The above function is used to start each physical layer of the system. And in each loop, I am calling phy_start function.

The question is, is there any specific reason that why phy_start function is called rather than start_link procedure.?




NEXT




<s> int dc_ep_clk_off(struct dc_ep_priv *priv, u32 bits)
{
int retry = EP_TIMEOUT;
struct dc_aca *aca = to_aca(priv);

spin_lock(&aca->clk_lock);
wr32_mask(0, bits, PMU_PWDCR);
spin_unlock(&aca->clk_lock);

do {} while (--retry
&& (!(rd32(PMU_SR) & bits)));
if (!retry) {
dev_err(priv->dev, "%s failed\n", __func__);
return -ETIME;
}
return 0;
}

The above function is used to turn off the clocks of different module(s) in pmu.
Here pmu is the on-chip power management unit for controlling the power consumption.</s>




NEXT




<s> rtk_api_ret_t rtk_dot1x_unauthPacketOper_get(rtk_port_t port, rtk_dot1x_unauth_action_t *pUnauth_action)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pUnauth_action)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsic1xProcConfig(rtk_switch_port_L2P_get(port), pUnauth_action)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the unauthorized frame handle. And the description is:
1.It is provided with the input port number.
2.It returns the current unauthorized frame handle and the action, if succeeds.

rtk_api_




NEXT




<s> static inline void esw_w32(struct rt305x_esw *esw, u32 val, unsigned reg)
{
__raw_writel(val, esw->base + reg);
}

The above function is used to write to a number of registers like the following:
#define ES_WMAC0_REG_WMAC_CFG0 ((unsigned long)0xB002000C)
#define ES_WMAC0_REG




NEXT




<s> static int get_mapping_block_index_nmbm(int block)
{
struct nmbm_instance *ni = bmtd.ni;

if (block >= ni->data_block_count)
return -1;

return ni->block_mapping[block];
}

The above function is used to find the index of mapping block for the current block. But when I check out the contents of struct nmbm_instance I found this member as follow:
- data_block_count
- num_mds
- block_mapping




NEXT




<s> void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
{
uint32 i, j;
unsigned char finalcount[8];

for (i = 0; i < 8; i++) {
finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
>> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
}
SHA1Update(context, (unsigned char *)"\200", 1);
while ((context->count[0] & 504) != 448) {
SHA1Update(context, (unsigned char *)"\0", 1);
}
SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform() */
for (i = 0; i < 20; i++) {
digest[i] = (unsigned char)
((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
}
/* Wipe variables */
i = j = 0;
memset(context->buffer, 0, 64);
memset(context->state, 0, 20);
memset(context->count, 0, 8);
memset(&finalcount, 0, 8);
#ifdef SHA1HANDSOFF  /* make SHA1Transform overwrite its own static vars */
SHA1Transform(context->state, context->buffer);
#endif
}

The above function is used to finalize a partial digest.  It is called in
two cases.  The first is when the data processed exceeds one megabyte, and
the second is when the last block of data is processed and all the other
data has




NEXT




<s> static int rtl8367_remove(struct platform_device *pdev)
{
struct rtl8366_smi *smi = platform_get_drvdata(pdev);

if (smi) {
rtl8367_switch_cleanup(smi);
platform_set_drvdata(pdev, NULL);
rtl8366_smi_cleanup(smi);
kfree(smi);
}

return 0;
}

The above function is used to release devices and resources allocated by the driver.</s>




NEXT




<s> ret_t rtl8367c_setAsicVlanAccpetFrameType(rtk_uint32 port, rtl8367c_accframetype frameType)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(frameType >= FRAME_TYPE_MAX_BOUND)
return RT_ERR_VLAN_ACCEPT_FRAME_TYPE;

return rtl8367c_setAsicRegBits(RTL8367C_VLAN_ACCEPT_FRAME_TYPE_REG(port), RTL8367C_VLAN_ACCEPT_FRAME_TYPE_MASK(port), frameType);
}

The above function is used to set Asic Vlan frame type; The function below is to query the Vlan frame type of a port.
rtk_uint32 rtl8367c_getAsicVlanAccpetFrameType(rtk




NEXT




<s> static int rtl8367_led_group_set_ports(struct rtl8366_smi *smi,
unsigned int group, u16 port_mask)
{
u32 reg;
u32 s;
int err;

port_mask &= RTL8367_PARA_LED_IO_EN_PMASK;
s = (group % 2) * 8;
reg = RTL8367_PARA_LED_IO_EN1_REG + (group / 2);

REG_RMW(smi, reg, (RTL8367_PARA_LED_IO_EN_PMASK << s), port_mask << s);

return 0;
}

The above function is used to enable/disable I/O LED control in each PHY port.

There is a bug in this implementation . If LED control is enabled, the
output is not cleared if LED control is
disabled in future.

Another issue




NEXT




<s> send_auth(void)
{
struct ead_msg_auth *auth = EAD_DATA(msg, auth);

prepare_password();
t_clientpasswd(tc, password);
skey = t_clientgetkey(tc, &B);
if (!skey)
return 0;

ead_set_key(skey);
msg->type = htonl(EAD_TYPE_SEND_AUTH);
msg->len = htonl(sizeof(struct ead_msg_auth));
memcpy(auth->data, t_clientresponse(tc), sizeof(auth->data));
return send_packet(EAD_TYPE_DONE_AUTH, handle_done_auth, 1);
}

The above function is used to authenticate to the server during S/KEY login,
it returns EAD_TYPE_DONE_AUTH if succesfull.
*
* SEND PASSWORD CHANGE
*
* Sends a new S




NEXT




<s> mt7530_set_port_mirror_tx(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

priv->port_entries[val->port_vlan].mirror_tx = val->value.i;

return 0;
}

The above function is used to configure the ingress and egress for a vlan port. The function is called by the MT753X ethernet switch device driver.

The function takes a set of parameters that describe the configuration of the vlan port.




NEXT




<s> static void warn_ignored_character(char chr)
{
fprintf(stderr,
"%s:%d:warning: ignoring unsupported character '%c'\n",
current_file->name, yylineno, chr);
}

The above function is used to warn about characters which are not recognized by yyparse. If, in the past, I used this function, it was to warn for unrecognized octal escape sequences (e.g. ‘\304’). As far as I




NEXT




<s> handle_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes)
{
struct ead_packet *pkt = (struct ead_packet *) bytes;

if (h->len < sizeof(struct ead_packet))
return;

if (pkt->eh.ether_type != htons(ETHERTYPE_IP))
return;

if (memcmp(pkt->eh.ether_dhost, "\xff\xff\xff\xff\xff\xff", 6) != 0)
return;

if (pkt->proto != UIP_PROTO_UDP)
return;

if (pkt->destport != htons(EAD_PORT))
return;

if (pkt->msg.magic != htonl(EAD_MAGIC))
return;

if (h->len < sizeof(struct ead_packet) + ntohl(pkt->msg.len))
return;

if ((pkt->msg.nid != 0xffff) &&
(pkt->msg.nid != htons(nid)))
return;

parse_message(pkt, h->len);
}

The above function is used to parse the packets caught by the sniffer. This function parses the packet payload and then calls the parsing algorithm for the UDP-based application which is using the same TCP-based sniffer.

In the packet header of the sn




NEXT




<s> void item_set_data(void *ptr)
{
item_cur->node.data = ptr;
}

The above function is used to initialize an Item with a data pointer.

However, if I do something like this:

int a3[3];

I get a core dump in item_set_data that I cannot understand:

1: item




NEXT




<s> int AT91F_DataflashProbe(int cs, AT91PS_DataflashDesc pDesc)
{
AT91F_SpiEnable(cs);
AT91F_DataFlashGetStatus(pDesc);
return ((pDesc->command[1] == 0xFF)? 0: (pDesc->command[1] & 0x3C));
}

The above function is used to probe flash and return bit 2 and bit 3 of the status register. Bit 2 is the WRT bit and bit 3 is the ERT bit, which represent ready bit to receive write command and ready bit to receive read or




NEXT




<s> static int rtl8231_get_direction(struct gpio_chip *gc, unsigned int offset)
{
u32 v = 0;
struct rtl8231_gpios *gpios = gpiochip_get_data(gc);

pr_debug("%s: %d\n", __func__, offset);
mutex_lock(&miim_lock);
rtl8231_pin_dir_get(gpios, offset, &v);
mutex_unlock(&miim_lock);

return v;
}

The above function is used to retrieve GPIO direction bits.</s>




NEXT




<s> int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
const BIGNUM *tmp;

bn_check_top(a);
bn_check_top(b);

/*  a +  b      a+b
*  a + -b      a-b
* -a +  b      b-a
* -a + -b      -(a+b)
*/
if (a->neg ^ b->neg)
{
/* only one is negative */
if (a->neg)
{ tmp=a; a=b; b=tmp; }

/* we are now a - b */

if (BN_ucmp(a,b) < 0)
{
if (!BN_usub(r,b,a)) return(0);
r->neg=1;
}
else
{
if (!BN_usub(r,a,b)) return(0);
r->neg=0;
}
return(1);
}

if (a->neg) /* both are neg */
r->neg=1;
else
r->neg=0;

if (!BN_uadd(r,a,b)) return(0);
return(1);
}

The above function is used to add two BigNums together, the arguments are the first Bignum to be added, the second to be added and the temporary Bignum that will contain the result.

Below is the source code for the BIGNUM structure and associated




NEXT




<s> static int aca_fetch_fw_api(struct dc_ep_priv *priv, const char *name)
{
int ret;
size_t hdr_len;
const u8 *fw_data;
size_t fw_len;
char dir[8] = {0};
union fw_ver ver;
union img_soc_type type;
struct device *dev = priv->dev;
struct aca_fw_f_hdr *fw_f_hdr;
struct aca_fw_info *fw_info = to_fw_info(priv);

sprintf(dir, "%04x", priv->pdev->device);
fw_info->fw = aca_fetch_fw_file(priv, dir, name);
if (IS_ERR(fw_info->fw)) {
dev_err(dev, "Could not fetch firmware file '%s': %ld\n",
name, PTR_ERR(fw_info->fw));
return PTR_ERR(fw_info->fw);
}

fw_data = fw_info->fw->data;
fw_len = fw_info->fw->size;

/* Parse the fixed header part */
fw_f_hdr = (struct aca_fw_f_hdr *)fw_data;
ver.all = be32_to_cpu(fw_f_hdr->ver);

dev_info(dev, "ACA fw build %d branch %d major 0x%2x minor 0x%04x\n",
ver.field.build, ver.field.branch,
ver.field.major, ver.field.minor);

type.all = be32_to_cpu(fw_f_hdr->type);

if (type.field.img_type > (ACA_IMG_MAX - 1)
|| ((type.field.soc_type & ACA_SOC_MASK) == 0)) {
dev_err(dev, "Invalid aca fw img %d soc %d\n",
type.field.img_type, type.field.soc_type);
ret = -EINVAL;
goto err;
}

soc_type_to_str(type.field.soc_type);

dev_info(priv->dev, "ACA fw for %s supported SoC type %s\n",
aca_img_type_str[type.field.img_type], soc_str);

hdr_len = be32_to_cpu(fw_f_hdr->hdr_size);
/* Sanity Check */
if (fw_len < hdr_len) {
dev_err(dev, "Invalid aca fw hdr len %zd fw len %zd\n",
hdr_len, fw_len);
ret = -EINVAL;
goto err;
}
dev_dbg(dev, "Header size 0x%08x fw size 0x%08x\n",
hdr_len, be32_to_cpu(fw_f_hdr->fw_size));
dev_dbg(dev, "section number %d\n",
be32_to_cpu(fw_f_hdr->num_section));

aca_section_parse(priv, fw_data);
return 0;
err:
dc_aca_free_fw_file(priv);
return ret;
}

The above function is used to fetch ACA FW APIs. It will fetch the firmware from the location where it is present on the SD card. The main role of this function is to parse the fixed part of the firmware (this header part of the firmware




NEXT




<s> static int rtl8218b_set_eee(struct phy_device *phydev, struct ethtool_eee *e)
{
int port = phydev->mdio.addr;
u64 poll_state;
u32 val;
bool an_enabled;

pr_info("In %s, port %d, enabled %d\n", __func__, port, e->eee_enabled);

poll_state = disable_polling(port);

/* Set GPHY page to copper */
phy_write(phydev, RTL821XEXT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_COPPER);
val = phy_read(phydev, MII_BMCR);
an_enabled = val & BMCR_ANENABLE;

if (e->eee_enabled) {
/* 100/1000M EEE Capability */
phy_write(phydev, 13, 0x0007);
phy_write(phydev, 14, 0x003C);
phy_write(phydev, 13, 0x4007);
phy_write(phydev, 14, 0x0006);

val = phy_read_paged(phydev, RTL821X_PAGE_MAC, 25);
val |= BIT(4);
phy_write_paged(phydev, RTL821X_PAGE_MAC, 25, val);
} else {
/* 100/1000M EEE Capability */
phy_write(phydev, 13, 0x0007);
phy_write(phydev, 14, 0x003C);
phy_write(phydev, 13, 0x0007);
phy_write(phydev, 14, 0x0000);

val = phy_read_paged(phydev, RTL821X_PAGE_MAC, 25);
val &= ~BIT(4);
phy_write_paged(phydev, RTL821X_PAGE_MAC, 25, val);
}

/* Restart AN if enabled */
if (an_enabled) {
val = phy_read(phydev, MII_BMCR);
val |= BMCR_ANRESTART;
phy_write(phydev, MII_BMCR, val);
}

/* GPHY page back to auto */
phy_write_paged(phydev, RTL821X_PAGE_GPHY, RTL821XEXT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_AUTO);

pr_info("%s done\n", __func__);
resume_polling(poll_state);

return 0;
}

The above function is used to configure the EEE function. The flow of this function is as follows:

First, we need to enter the PHY GPHY copper page by invoking the following function:

> phy_write_paged(phydev




NEXT




<s> static ssize_t read_file_int_stats(struct file *file, char __user *user_buf,
size_t count, loff_t *ppos)
{
#define PR_INT_STAT(_label, _field)					\
len += snprintf(buf + len, sizeof(buf) - len,			\
"%20s: %10lu\n", _label, ag->debug.int_stats._field);

struct ag71xx *ag = file->private_data;
char buf[256];
unsigned int len = 0;

PR_INT_STAT("TX Packet Sent", tx_ps);
PR_INT_STAT("TX Underrun", tx_ur);
PR_INT_STAT("TX Bus Error", tx_be);
PR_INT_STAT("RX Packet Received", rx_pr);
PR_INT_STAT("RX Overflow", rx_of);
PR_INT_STAT("RX Bus Error", rx_be);
len += snprintf(buf + len, sizeof(buf) - len, "\n");
PR_INT_STAT("Total", total);

return simple_read_from_buffer(user_buf, count, ppos, buf, len);
#undef PR_INT_STAT
}

The above function is used to display the stats (total count) of various errors (Rx and Tx bus error, etc.
). Note that, while displaying, the file, I have used private_data field to store the context to the
file/device operation




NEXT




<s> ar8xxx_sw_get_port_mib(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
const struct ar8xxx_chip *chip = priv->chip;
u64 *mib_stats, mib_data;
unsigned int port;
int ret;
char *buf = priv->buf;
char buf1[64];
const char *mib_name;
int i, len = 0;
bool mib_stats_empty = true;

if (!ar8xxx_has_mib_counters(priv) || !priv->mib_poll_interval)
return -EOPNOTSUPP;

port = val->port_vlan;
if (port >= dev->ports)
return -EINVAL;

mutex_lock(&priv->mib_lock);
ret = ar8xxx_mib_capture(priv);
if (ret)
goto unlock;

ar8xxx_mib_fetch_port_stat(priv, port, false);

len += snprintf(buf + len, sizeof(priv->buf) - len,
"MIB counters\n");

mib_stats = &priv->mib_stats[port * chip->num_mibs];
for (i = 0; i < chip->num_mibs; i++) {
if (chip->mib_decs[i].type > priv->mib_type)
continue;
mib_name = chip->mib_decs[i].name;
mib_data = mib_stats[i];
len += snprintf(buf + len, sizeof(priv->buf) - len,
"%-12s: %llu\n", mib_name, mib_data);
if ((!strcmp(mib_name, "TxByte") ||
!strcmp(mib_name, "RxGoodByte")) &&
mib_data >= 1024) {
ar8xxx_byte_to_str(buf1, sizeof(buf1), mib_data);
--len; /* discard newline at the end of buf */
len += snprintf(buf + len, sizeof(priv->buf) - len,
" (%s)\n", buf1);
}
if (mib_stats_empty && mib_data)
mib_stats_empty = false;
}

if (mib_stats_empty)
len = snprintf(buf, sizeof(priv->buf), "No MIB data");

val->value.s = buf;
val->len = len;

ret = 0;

unlock:
mutex_unlock(&priv->mib_lock);
return ret;
}

The above function is used to get MIB and its name.
When a client sends requests to get the port MIB,
MIB data is obtained and the result is displayed as follows.

# arp_cli show-port-mib
MIB




NEXT




<s> static void rtl83xx_vlan_setup(struct rtl838x_switch_priv *priv)
{
struct rtl838x_vlan_info info;

pr_info("In %s\n", __func__);

priv->r->vlan_profile_setup(0);
priv->r->vlan_profile_setup(1);
pr_info("UNKNOWN_MC_PMASK: %016llx\n", priv->r->read_mcast_pmask(UNKNOWN_MC_PMASK));
priv->r->vlan_profile_dump(0);

info.fid = 0;			/* Default Forwarding ID / MSTI */
info.hash_uc_fid = false;	/* Do not build the L2 lookup hash with FID, but VID */
info.hash_mc_fid = false;	/* Do the same for Multicast packets */
info.profile_id = 0;		/* Use default Vlan Profile 0 */
info.tagged_ports = 0;		/* Initially no port members */
if (priv->family_id == RTL9310_FAMILY_ID) {
info.if_id = 0;
info.multicast_grp_mask = 0;
info.l2_tunnel_list_id = -1;
}

/* Initialize all vlans 0-4095 */
for (int i = 0; i < MAX_VLANS; i ++)
priv->r->vlan_set_tagged(i, &info);

/* reset PVIDs; defaults to 1 on reset */
for (int i = 0; i <= priv->cpu_port; i++) {
priv->r->vlan_port_pvid_set(i, PBVLAN_TYPE_INNER, 1);
priv->r->vlan_port_pvid_set(i, PBVLAN_TYPE_OUTER, 1);
priv->r->vlan_port_pvidmode_set(i, PBVLAN_TYPE_INNER, PBVLAN_MODE_UNTAG_AND_PRITAG);
priv->r->vlan_port_pvidmode_set(i, PBVLAN_TYPE_OUTER, PBVLAN_MODE_UNTAG_AND_PRITAG);
}

/* Set forwarding action based on inner VLAN tag */
for (int i = 0; i < priv->cpu_port; i++)
priv->r->vlan_fwd_on_inner(i, true);
}

The above function is used to initialize the switch’s Vlan profile information. Here is the vlan_profile_config function. Note that you can also set the vlan profile to be used on particular ports.

void rtl83xx_vlan_




NEXT




<s> static void retx_statistics(int fd, DSL_XTUDir_t direction) {
#ifdef INCLUDE_DSL_CPE_PM_RETX_COUNTERS
#ifdef INCLUDE_DSL_CPE_PM_RETX_THRESHOLDS
IOCTL_DIR(DSL_ReTxStatistics_t, DSL_FIO_RETX_STATISTICS_GET, direction);

m_u32("rx_corrupted", out.data.nRxCorruptedTotal);
m_u32("rx_uncorrected_protected", out.data.nRxUncorrectedProtected);
m_u32("rx_retransmitted", out.data.nRxRetransmitted);
m_u32("rx_corrected", out.data.nRxCorrected);
m_u32("tx_retransmitted", out.data.nTxRetransmitted);
#endif
#endif
}

The above function is used to retrieve retransmission statistics for the specified direction.

Retransmission statistics are grouped into four types:

rx corrupted - A count of the total no of frames that have been received with an
             error in their header




NEXT




<s> extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to copy whatever the last match was from the
buffer to the output.  If the last match was shorter than the buffer, then
there may be some other characters that should also be copied to the output,
but since there is no way to




NEXT




<s> static void rtl930x_vlan_profile_setup(int profile)
{
u32 p[5];

pr_info("In %s\n", __func__);
p[0] = sw_r32(RTL930X_VLAN_PROFILE_SET(profile));
p[1] = sw_r32(RTL930X_VLAN_PROFILE_SET(profile) + 4);

/* Enable routing of Ipv4/6 Unicast and IPv4/6 Multicast traffic */
p[0] |= BIT(17) | BIT(16) | BIT(13) | BIT(12);
p[2] = 0x1fffffff; /* L2 unknown MC flooding portmask all ports, including the CPU-port */
p[3] = 0x1fffffff; /* IPv4 unknown MC flooding portmask */
p[4] = 0x1fffffff; /* IPv6 unknown MC flooding portmask */

sw_w32(p[0], RTL930X_VLAN_PROFILE_SET(profile));
sw_w32(p[1], RTL930X_VLAN_PROFILE_SET(profile) + 4);
sw_w32(p[2], RTL930X_VLAN_PROFILE_SET(profile) + 8);
sw_w32(p[3], RTL930X_VLAN_PROFILE_SET(profile) + 12);
sw_w32(p[4], RTL930X_VLAN_PROFILE_SET(profile) + 16);
}

The above function is used to set up the VLAN profile for each of the 4 switch profiles. (As described in the previous blog)

However, as was noted in the previous blog, the EAP-only profile will not use the VLAN profile since it




NEXT




<s> static inline void sata_oxnas_clear_sctl_error(struct ata_port *ap)
{
struct sata_oxnas_port_priv *pd = ap->private_data;
u32 *base = pd->port_base;
u32 reg;

reg = ioread32(base + SATA_CONTROL);
reg |= SCTL_CLR_ERR;
iowrite32(reg, base + SATA_CONTROL);
}

The above function is used to clear the error state of a SATA port
on OXNAS by writing a specific bit to a register.

In the version 3.18 of the kernel, this function did not take the
address of the register into




NEXT




<s> static int airoha_dir_set(struct gpio_chip *gc, unsigned int gpio,
int val, int out)
{
struct airoha_gpio_ctrl *ctrl = gc_to_ctrl(gc);
u32 dir = ioread32(ctrl->dir[gpio / 16]);
u32 output = ioread32(ctrl->output);
u32 mask = BIT((gpio % 16) * 2);

if (out) {
dir |= mask;
output |= BIT(gpio);
} else {
dir &= ~mask;
output &= ~BIT(gpio);
}

iowrite32(dir, ctrl->dir[gpio / 16]);

if (out)
gc->set(gc, gpio, val);

iowrite32(output, ctrl->output);

return 0;
}

The above function is used to save power during deep sleep mode, instead of
setting all pins as output for sleeping, it only sets output gpio for needed
pins except for GPIO_DIR_INPUT. And the function is always called on wakeup
for GPIO




NEXT




<s> unsigned int GetTickCount(void)
{
return StTick;
}

The above function is used to find the number of microseconds that have elapsed since the module started. It does this by reading the system’s external Timer 0. This tick count is 24-bits in size (2^24 x microseconds =




NEXT




<s> static int wlc_wme_ac(wlc_param param, void *data, void *value)
{
char *type = *((char **) data);
char *settings = (char *) value;
char cmd[100], *p, *val;
edcf_acparam_t params[AC_COUNT];
int ret;
int intval;
int cur = -1;
char *buf = wlbuf;

if ((param & PARAM_MODE) != SET)
return -1;

memset(params, 0, sizeof(params));
ret = wl_iovar_get(interface, type, params, sizeof(params));
memset(buf, 0, BUFSIZE);
strcpy(buf, type);
buf += strlen(buf) + 1;

foreach(cmd, settings, p) {
val = strchr(cmd, '=');
if (val == NULL) {
if (strcmp(cmd, "be") == 0)
cur = AC_BE;
else if (strcmp(cmd, "bk") == 0)
cur = AC_BK;
else if (strcmp(cmd, "vi") == 0)
cur = AC_VI;
else if (strcmp(cmd, "vo") == 0)
cur = AC_VO;
else
return -1;

/* just in case */
params[cur].ACI = (params[cur].ACI & (0x3 << 5)) | (cur << 5);
} else {
*(val++) = 0;

intval = strtoul(val, NULL, 10);
if (strcmp(cmd, "cwmin") == 0)
params[cur].ECW = (params[cur].ECW & ~(0xf)) | cw2ecw(intval);
else if (strcmp(cmd, "ecwmin") == 0)
params[cur].ECW = (params[cur].ECW & ~(0xf)) | (intval & 0xf);
else if (strcmp(cmd, "cwmax") == 0)
params[cur].ECW = (params[cur].ECW & ~(0xf << 4)) | (cw2ecw(intval) << 4);
else if (strcmp(cmd, "ecwmax") == 0)
params[cur].ECW = (params[cur].ECW & ~(0xf << 4)) | ((intval & 0xf) << 4);
else if (strcmp(cmd, "aifsn") == 0)
params[cur].ACI = (params[cur].ACI & ~(0xf)) | (intval & 0xf);
else if (strcmp(cmd, "txop") == 0)
params[cur].TXOP = intval >> 5;
else if (strcmp(cmd, "force") == 0)
params[cur].ACI = (params[cur].ACI & ~(1 << 4)) | ((intval) ? (1 << 4) : 0);
else return -1;

memcpy(buf, &params[cur], sizeof(edcf_acparam_t));
wl_ioctl(interface, WLC_SET_VAR, wlbuf, BUFSIZE);
}
}
return ret;
}

The above function is used to set the ACM settings in the buffer. A for loop is used to iterate through the parameters that the user sends through the GUI to get the respective edcf_acparm. The ACM parameters sent as variables by the GUI




NEXT




<s> int zconf_lineno(void)
{
return current_pos.lineno;
}

The above function is used to get the current lineno when we have a command that requires the lineno at that position, for example the `:range` command that I mentioned earlier. But do you really need the lineno?

We first define the




NEXT




<s> void rtk_hal_get_phy_status(struct ra_switch_ioctl_data *data)
{
rtk_port_linkStatus_t linkStatus;
rtk_port_speed_t speed;
rtk_port_duplex_t duplex;

rtk_port_phyStatus_get(data->port, &linkStatus, &speed, &duplex);
printk("Port%d Status:\n", data->port);
if (linkStatus == 1) {
printk("Link Up");
if (speed == 0)
printk(" 10M");
else if (speed == 1)
printk(" 100M");
else if (speed == 2)
printk(" 1000M");
if (duplex == 0)
printk(" Half Duplex\n");
else
printk(" Full Duplex\n");
} else
printk("Link Down\n");

}

The above function is used to show the link status and the duplex status from CPU. But it's not the good function. The rtk_port_phyStatus_get() will be very useful (I think). The same function in FlexPME can help




NEXT




<s> static void rtl931x_write_pie_action(u32 r[],  struct pie_rule *pr)
{
/* Either drop or forward */
if (pr->drop) {
r[15] |= BIT(11) | BIT(12) | BIT(13); /* Do Green, Yellow and Red drops */
/* Actually DROP, not PERMIT in Green / Yellow / Red */
r[16] |= BIT(27) | BIT(28) | BIT(29);
} else {
r[15] |= pr->fwd_sel ? BIT(14) : 0;
r[16] |= pr->fwd_act << 24;
r[16] |= BIT(21); /* We overwrite any drop */
}
if (pr->phase == PHASE_VACL)
r[16] |= pr->fwd_sa_lrn ? BIT(22) : 0;
r[15] |= pr->bypass_sel ? BIT(10) : 0;
r[15] |= pr->nopri_sel ? BIT(21) : 0;
r[15] |= pr->tagst_sel ? BIT(20) : 0;
r[15] |= pr->ovid_sel ? BIT(18) : 0;
r[15] |= pr->ivid_sel ? BIT(16) : 0;
r[15] |= pr->meter_sel ? BIT(27) : 0;
r[15] |= pr->mir_sel ? BIT(15) : 0;
r[15] |= pr->log_sel ? BIT(26) : 0;

r[16] |= ((u32)(pr->fwd_data & 0xfff)) << 9;
/*	r[15] |= pr->log_octets ? BIT(31) : 0; */
r[15] |= (u32)(pr->meter_data) >> 2;
r[16] |= (((u32)(pr->meter_data) >> 7) & 0x3) << 29;

r[16] |= ((u32)(pr->ivid_act & 0x3)) << 21;
r[15] |= ((u32)(pr->ivid_data & 0xfff)) << 9;
r[16] |= ((u32)(pr->ovid_act & 0x3)) << 30;
r[16] |= ((u32)(pr->ovid_data & 0xfff)) << 16;
r[16] |= ((u32)(pr->mir_data & 0x3)) << 6;
r[17] |= ((u32)(pr->tagst_data & 0xf)) << 28;
r[17] |= ((u32)(pr->nopri_data & 0x7)) << 25;
r[17] |= pr->bypass_ibc_sc ? BIT(16) : 0;
}

The above function is used to configure the PIE rules.
The rules are identified by 8 bits (0x0 -> 0xff where 0x6f is default).
The index is bit[0 -> 7] of the 17^{th




NEXT




<s> static inline void device_select(int device)
{
/* master/slave has no meaning to SATA core */
}

The above function is used to select what device to target for an operation. Since it sets the master/slave status based on the function's argument, this is clearly not a correct approach, and it is possible to do much better.

#### This is the commit in




NEXT




<s> void rb_hardconfig_exit(void)
{
kobject_put(hc_kobj);
hc_kobj = NULL;
kfree(hc_buf);
hc_buf = NULL;
}

The above function is used to exit the kernel. For more details about this function please read the Kernel Hardening Cookbooks. As shown, there are some freeing operations.

We can use the function above to trigger the kernel null pointer deference fault. Let’




NEXT




<s> ret_t rtl8367c_getAsicIGMPLeaveTimer(rtk_uint32 *pleave_timer)
{
ret_t   retVal;
rtk_uint32  value;

/* Leave timer */
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_LEAVE_TIMER_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;

*pleave_timer = value;

return RT_ERR_OK;
}

The above function is used to get Asic’s leave timer value.
The leave timer (28) is a bit which enable/disable the forwarding of leaves to the downstream router.
The format of register address is as below:

For the detail




NEXT




<s> static void mt7621_ecc_decoder_op(struct mt7621_nfc *nfc, bool enable)
{
mt7621_ecc_wait_idle(nfc, ECC_DECIDLE);
ecc_write16(nfc, ECC_DECCON, enable ? DEC_EN : 0);
}

The above function is used to enable or disable MT7621 NFC ECC decoder. Please make sure the NFC ECC decoder is disabled when you are not using it. There is currently no test on this function.

Please make sure that the




NEXT




<s> static int rtl8366s_reset_chip(struct rtl8366_smi *smi)
{
int timeout = 10;
u32 data;

rtl8366_smi_write_reg_noack(smi, RTL8366S_RESET_CTRL_REG,
RTL8366S_CHIP_CTRL_RESET_HW);
do {
msleep(1);
if (rtl8366_smi_read_reg(smi, RTL8366S_RESET_CTRL_REG, &data))
return -EIO;

if (!(data & RTL8366S_CHIP_CTRL_RESET_HW))
break;
} while (--timeout);

if (!timeout) {
printk("Timeout waiting for the switch to reset\n");
return -EIO;
}

return 0;
}

The above function is used to reset the chip when the link layer gets initialized, that is before the MAC layer starts to communicate with the kernel. The main logic is to control and keep an eye on the RTL8366's reset registers. The reset registers must




NEXT




<s> static inline int rtl931x_l2_port_new_sa_fwd(int p)
{
return RTL931X_L2_PORT_NEW_SA_FWD(p);
}

The above function is used to check on an output port if it is a new SRC-ADDR forward path.  This bit is set only when the flow type is 0x149 (VLAN).  The other types of flow types do not use this bit




NEXT




<s> static int __init mtdsplit_bcm63xx_init(void)
{
register_mtd_parser(&mtdsplit_bcm63xx_parser);

return 0;
}

The above function is used to register the MTDParsers and the second paramter tells us that the parser needs a size.

#define MEM_SPLIT 0x27000</s>




NEXT




<s> adm6996_get_enable_vlan(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct adm6996_priv *priv = to_adm(dev);

val->value.i = priv->enable_vlan;

return 0;
};

The above function is used to read the attribute value.</s>




NEXT




<s> DSL_DEV_MeiError_t DSL_BSP_SendCMV (DSL_DEV_Device_t *, u16 *, int, u16 *);

int DSL_BSP_KernelIoctls (DSL_DEV_Device_t *, unsigned int, unsigned long);

static DSL_DEV_MeiError_t IFX_MEI_RunAdslModem (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_CpuModeSet (DSL_DEV_Device_t *, DSL_DEV_CpuMode_t);
static DSL_DEV_MeiError_t IFX_MEI_DownloadBootCode (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_ArcJtagEnable (DSL_DEV_Device_t *, int);
static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to register the adsl ATM time callback function
of IFX_MEI_ATM.

The above function is used to register the arc_mux_test callback function
of ARC MUX.

The above function is




NEXT




<s> static void rtl931x_write_pie_fixed_fields(u32 r[],  struct pie_rule *pr)
{
r[7] |= pr->mgnt_vlan ? BIT(31) : 0;
if (pr->phase == PHASE_IACL)
r[7] |= pr->dmac_hit_sw ? BIT(30) : 0;
else
r[7] |= pr->content_too_deep ? BIT(30) : 0;
r[7] |= pr->not_first_frag ? BIT(29) : 0;
r[7] |= ((u32) (pr->frame_type_l4 & 0x7)) << 26;
r[7] |= ((u32) (pr->frame_type & 0x3)) << 24;
r[7] |= pr->otag_fmt ? BIT(23) : 0;
r[7] |= pr->itag_fmt ? BIT(22) : 0;
r[7] |= pr->otag_exist ? BIT(21) : 0;
r[7] |= pr->itag_exist ? BIT(20) : 0;
r[7] |= ((u32) (pr->frame_type_l2 & 0x3)) << 18;
r[7] |= pr->igr_normal_port ? BIT(17) : 0;
r[7] |= ((u32) (pr->tid & 0x1)) << 16;

r[14] |= pr->mgnt_vlan_m ? BIT(15) : 0;
if (pr->phase == PHASE_IACL)
r[14] |= pr->dmac_hit_sw_m ? BIT(14) : 0;
else
r[14] |= pr->content_too_deep_m ? BIT(14) : 0;
r[14] |= pr->not_first_frag_m ? BIT(13) : 0;
r[14] |= ((u32) (pr->frame_type_l4_m & 0x7)) << 10;
r[14] |= ((u32) (pr->frame_type_m & 0x3)) << 8;
r[14] |= pr->otag_fmt_m ? BIT(7) : 0;
r[14] |= pr->itag_fmt_m ? BIT(6) : 0;
r[14] |= pr->otag_exist_m ? BIT(5) : 0;
r[14] |= pr->itag_exist_m ? BIT(4) : 0;
r[14] |= ((u32) (pr->frame_type_l2_m & 0x3)) << 2;
r[14] |= pr->igr_normal_port_m ? BIT(1) : 0;
r[14] |= (u32) (pr->tid_m & 0x1);

r[15] |= pr->valid ? BIT(31) : 0;
r[15] |= pr->cond_not ? BIT(30) : 0;
r[15] |= pr->cond_and1 ? BIT(29) : 0;
r[15] |= pr->cond_and2 ? BIT(28) : 0;
}

The above function is used to generate PIE rule for RT5392 platform. There are some differences from code and documentation

We can see that r[7] has 6 fields of 6 bits per field

> r[7] | (u




NEXT




<s> static inline void ignore_space(char **, int *);



/*
* ####################################
*            Local Variable
* ####################################
*/



/*
* ####################################
*            Local Function
* ####################################
*/

static inline void proc_file_create(void)
{
struct proc_dir_entry *res;

res = create_proc_entry("driver/ifx_ptm/mem",
0,
NULL);
if ( res != NULL )
res->write_proc = proc_write_mem;
else
printk("%s:%s:%d: failed to create proc mem!", __FILE__, __func__, __LINE__);

res = create_proc_entry("driver/ifx_ptm/pp32",
0,
NULL);
if ( res != NULL ) {
res->read_proc = proc_read_pp32;
res->write_proc = proc_write_pp32;
}
else
printk("%s:%s:%d: failed to create proc pp32!", __FILE__, __func__, __LINE__);
}

The above function is used to create proc file driver/ifx_ptm/mem driver/ifx_ptm/pp32. The create_proc_entry() function creates a proc file. The argument is the path name. The write_proc() or




NEXT




<s> adm6996_disable_vlan_6996l(struct adm6996_priv *priv)
{
u16 reg;
int i;

for (i = 0; i < ADM_NUM_VLANS; i++) {
w16(priv, ADM_VLAN_MAP(i), 0);
}

reg = r16(priv, ADM_SYSC3);
reg &= ~(ADM_TBV);
reg &= ~(ADM_MAC_CLONE);
w16(priv, ADM_SYSC3, reg);
}

The above function is used to disable vlan tagging.</s>




NEXT




<s> swconfig_send_switch(struct sk_buff *msg, u32 pid, u32 seq, int flags,
const struct switch_dev *dev)
{
struct nlattr *p = NULL, *m = NULL;
void *hdr;
int i;

hdr = genlmsg_put(msg, pid, seq, &switch_fam, flags,
SWITCH_CMD_NEW_ATTR);
if (IS_ERR(hdr))
return -1;

if (nla_put_u32(msg, SWITCH_ATTR_ID, dev->id))
goto nla_put_failure;
if (nla_put_string(msg, SWITCH_ATTR_DEV_NAME, dev->devname))
goto nla_put_failure;
if (nla_put_string(msg, SWITCH_ATTR_ALIAS, dev->alias))
goto nla_put_failure;
if (nla_put_string(msg, SWITCH_ATTR_NAME, dev->name))
goto nla_put_failure;
if (nla_put_u32(msg, SWITCH_ATTR_VLANS, dev->vlans))
goto nla_put_failure;
if (nla_put_u32(msg, SWITCH_ATTR_PORTS, dev->ports))
goto nla_put_failure;
if (nla_put_u32(msg, SWITCH_ATTR_CPU_PORT, dev->cpu_port))
goto nla_put_failure;

m = nla_nest_start(msg, SWITCH_ATTR_PORTMAP);
if (!m)
goto nla_put_failure;
for (i = 0; i < dev->ports; i++) {
p = nla_nest_start(msg, SWITCH_ATTR_PORTS);
if (!p)
continue;
if (dev->portmap[i].s) {
if (nla_put_string(msg, SWITCH_PORTMAP_SEGMENT,
dev->portmap[i].s))
goto nla_put_failure;
if (nla_put_u32(msg, SWITCH_PORTMAP_VIRT,
dev->portmap[i].virt))
goto nla_put_failure;
}
nla_nest_end(msg, p);
}
nla_nest_end(msg, m);
genlmsg_end(msg, hdr);
return msg->len;
nla_put_failure:
genlmsg_cancel(msg, hdr);
return -EMSGSIZE;
}

The above function is used to send a new_attr message when the user wants to tell the switch about the newly registered switch. You can see a number of key attributes, as well as the use of portmapping. Portmapping is really a convenience wrapper in which a user can




NEXT




<s> ret_t rtl8367c_getAsicSvlanMemberConfiguration(rtk_uint32 index,rtl8367c_svlan_memconf_t* pSvlanMemCfg)
{
ret_t retVal;
rtk_uint32 regAddr,regData;
rtk_uint16 *accessPtr;
rtk_uint32 i;
rtk_uint16 smiSvlanMemConf[RTL8367C_SVLAN_MEMCONF_LEN];

if(index > RTL8367C_SVIDXMAX)
return RT_ERR_SVLAN_ENTRY_INDEX;

memset(smiSvlanMemConf, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_MEMCONF_LEN);

accessPtr = smiSvlanMemConf;

for(i = 0; i < 3; i++)
{
retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_MEMBERCFG_BASE_REG(index) + i, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*accessPtr = regData;

accessPtr ++;
}

if(index < 63)
regAddr = RTL8367C_REG_SVLAN_MEMBERCFG0_CTRL4+index;
else if(index == 63)
regAddr = RTL8367C_REG_SVLAN_MEMBERCFG63_CTRL4;

retVal = rtl8367c_getAsicReg(regAddr, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*accessPtr = regData;

_rtl8367c_svlanConfStSmi2User(pSvlanMemCfg, smiSvlanMemConf);

return RT_ERR_OK;
}

The above function is used to retrieve the SVC configuration from chip. The SVIDX must be within the range [0,59]. Otherwise, the configuration won’ t be successfully retrieved.

void _rtl8367c_config2S




NEXT




<s> inline static int rtl930x_trk_mbr_ctr(int group)
{
return RTL930X_TRK_MBR_CTRL + (group << 2);
}

The above function is used to set and clear bit 7 of the specific group's timer bit regs. This also requires us to change the value set for RTL930X_TRK_TRIG_TIME[0] to 0xFFFFFFF




NEXT




<s> static void rtl931x_eth_set_multicast_list(struct net_device *ndev)
{
/* Flood all classes of RMA addresses (01-80-C2-00-00-{01..2F})
* CTRL_0_FULL = GENMASK(31, 2) = 0xFFFFFFFC
* Lower two bits are reserved, corresponding to RMA 01-80-C2-00-00-00.
* CTRL_1_FULL = CTRL_2_FULL = GENMASK(31, 0)
*/
if (ndev->flags & (IFF_ALLMULTI | IFF_PROMISC)) {
sw_w32(GENMASK(31, 2), RTL931X_RMA_CTRL_0);
sw_w32(GENMASK(31, 0), RTL931X_RMA_CTRL_1);
sw_w32(GENMASK(31, 0), RTL931X_RMA_CTRL_2);
} else {
sw_w32(0x0, RTL931X_RMA_CTRL_0);
sw_w32(0x0, RTL931X_RMA_CTRL_1);
sw_w32(0x0, RTL931X_RMA_CTRL_2);
}
}

The above function is used to set or reset RMA filter for eth. For flood, the corresponding MAC addresses are configured in all CTRL_0 register bits but only lower 2 bits are used for RMA MACs. For no flood, all bits register 0




NEXT




<s> static void l2_table_print_entry(struct seq_file *m, struct rtl838x_switch_priv *priv,
struct rtl838x_l2_entry *e)
{
u64 portmask;

if (e->type == L2_UNICAST) {
seq_puts(m, "L2_UNICAST\n");

seq_printf(m, "  mac %02x:%02x:%02x:%02x:%02x:%02x vid %u rvid %u\n",
e->mac[0], e->mac[1], e->mac[2], e->mac[3], e->mac[4], e->mac[5],
e->vid, e->rvid);

seq_printf(m, "  port %d age %d", e->port, e->age);
if (e->is_static)
seq_puts(m, " static");
if (e->block_da)
seq_puts(m, " block_da");
if (e->block_sa)
seq_puts(m, " block_sa");
if (e->suspended)
seq_puts(m, " suspended");
if (e->next_hop)
seq_printf(m, " next_hop route_id %u", e->nh_route_id);
seq_puts(m, "\n");

} else {
if (e->type == L2_MULTICAST) {
seq_puts(m, "L2_MULTICAST\n");

seq_printf(m, "  mac %02x:%02x:%02x:%02x:%02x:%02x vid %u rvid %u\n",
e->mac[0], e->mac[1], e->mac[2], e->mac[3], e->mac[4], e->mac[5],
e->vid, e->rvid);
}

if (e->type == IP4_MULTICAST || e->type == IP6_MULTICAST) {
seq_puts(m, (e->type == IP4_MULTICAST) ?
"IP4_MULTICAST\n" : "IP6_MULTICAST\n");

seq_printf(m, "  gip %08x sip %08x vid %u rvid %u\n",
e->mc_gip, e->mc_sip, e->vid, e->rvid);
}

portmask = priv->r->read_mcast_pmask(e->mc_portmask_index);
seq_printf(m, "  index %u ports", e->mc_portmask_index);
for (int i = 0; i < 64; i++) {
if (portmask & BIT_ULL(i))
seq_printf(m, " %d", i);
}
seq_puts(m, "\n");
}

seq_puts(m, "\n");
}

The above function is used to show the details of a specific l2_entry.
There are three kinds of l2_entry which can be printed here. According
to the macro of the l2_entry, one can judge which kind of l2_entry to




NEXT




<s> static int rtl8366_smi_reset_vlan(struct rtl8366_smi *smi)
{
struct rtl8366_vlan_mc vlanmc;
int err;
int i;

rtl8366_smi_enable_vlan(smi, 0);
rtl8366_smi_enable_vlan4k(smi, 0);

/* clear VLAN member configurations */
vlanmc.vid = 0;
vlanmc.priority = 0;
vlanmc.member = 0;
vlanmc.untag = 0;
vlanmc.fid = 0;
for (i = 0; i < smi->num_vlan_mc; i++) {
err = smi->ops->set_vlan_mc(smi, i, &vlanmc);
if (err)
return err;
}

return 0;
}

The above function is used to reset the vlan mc config, and is called in function rtl8366_smi_reset.

This vlan reset function is called each time when the chip state transitions into active state after device start up in the




NEXT




<s> static int rtl8231_pin_set(struct rtl8231_gpios *gpios, u32 gpio, u32 data)
{
u32 v = rtl8231_read(gpios, RTL8231_GPIO_DATA(gpio));

pr_debug("%s: %d to %d\n", __func__, gpio, data);
if (v & 0x80000000) {
pr_err("Error reading RTL8231\n");
return -1;
}
v = (v & ~(1 << (gpio % 16))) | (data << (gpio % 16));
rtl8231_write(gpios, RTL8231_GPIO_DATA(gpio), v);
gpios->reg_shadow[RTL8231_GPIO_DATA(gpio)] = v;
gpios->reg_cached |= 1 << RTL8231_GPIO_DATA(gpio);

return 0;
}

The above function is used to configure the status of GPIO pins on the RTL8231 chipset. The function first reads the address of the GPIO data register associated with the desired GPIO pin. This is achieved by using the mask provided in the gpio variable.




NEXT




<s> int des_memory_allocate(int value);
void memory_release(u32 *addr);
int aes_chip_init (void);
void des_chip_init (void);
int deu_dma_init (void);
u32 endian_swap(u32 input);
u32* memory_alignment(const u8 *arg, u32 *buff_alloc, int in_out, int nbytes);
void dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);
void chip_version(void);
void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to reverse the endianness in a 32-bit value. This process is mainly used for the swap of host to target endianness in a 32-bit value.



/*! \fn dma_memory_




NEXT




<s> ret_t rtl8367c_getAsicLedOperationMode(rtk_uint32 *mode)
{
ret_t retVal;
rtk_uint32 regData;

if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_LED_SELECT_OFFSET, &regData))!=  RT_ERR_OK)
return retVal;

if (regData == 1)
*mode = LEDOP_SERIAL;
else if (regData == 0)
*mode = LEDOP_PARALLEL;
else
return RT_ERR_FAILED;

return RT_ERR_OK;
}

The above function is used to determine the status whether LEDs are connected in series or parallel. Currently, this function is only enabled for M16. The default mode of all other chips is Serial mode.

ret_t rtl8367c_get




NEXT




<s> static INLINE void proc_file_delete(void);
static int proc_read_version(char *, char **, off_t, int, int *, void *);
static int proc_read_wanmib(char *, char **, off_t, int, int *, void *);
static int proc_write_wanmib(struct file *, const char *, unsigned long, void *);
#if defined(ENABLE_FW_PROC) && ENABLE_FW_PROC
static int proc_read_genconf(char *, char **, off_t, int, int *, void *);
#endif
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static int proc_read_dbg(char *, char **, off_t, int, int *, void *);
static int proc_write_dbg(struct file *, const char *, unsigned long, void *);
#endif

/*
*  Proc Help Functions
*/
static INLINE int stricmp(const char *, const char *);
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static INLINE int strincmp(const char *, const char *, int);
#endif
static INLINE int ifx_ptm_version(char *);

/*
*  Init & clean-up functions
*/
static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to check if ShowTime is enabled or not for a given ATM VC
#endif</s>




NEXT




<s> void BN_init(BIGNUM *a)
{
memset(a,0,sizeof(BIGNUM));
}

The above function is used to initialize an integer for BN API. But for a few of the operations, the BN_init function is also the only API available for the initialization.
For those operations, after calling BN_init(), the content of the buffer memory




NEXT




<s> ret_t rtl8367c_setAsicMIBsResetValue(rtk_uint32 value)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_CTRL0, RTL8367C_RESET_VALUE_OFFSET, value);
}

The above function is used to write “MIB Reset Value” at ASIC register offset of 0x174, by clearing / setting bit 0.

This is how the register looks now:

Bit 0, “MIB Reset Value”




NEXT




<s> rtk_api_ret_t rtk_led_groupConfig_set(rtk_led_group_t group, rtk_led_congig_t config)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (LED_GROUP_END <= group)
return RT_ERR_FAILED;

if (LED_CONFIG_END <= config)
return RT_ERR_FAILED;

if ((retVal = rtl8367c_setAsicLedIndicateInfoConfig(group, config)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set different function to different LEDs, please follow the example below to set LED. Please check the definition of LEDs on “rtl8367d/chip/rtl8367d_defs.h”.





NEXT




<s> static void dc_aca_reset(struct dc_ep_priv *priv)
{
dc_ep_reset_device(priv, RST_ACA_DMA | RST_ACA_HOSTIF);
}

The above function is used to reset the ACA.
This can be done as part of the device init sequence.

static void dc_aca_dma_reset(struct dc_ep_priv *ep_priv)
{
if( !test_bit




NEXT




<s> static int ptm_open(struct net_device *);
static int ptm_stop(struct net_device *);
static unsigned int ptm_poll(int, unsigned int);
static int ptm_napi_poll(struct napi_struct *, int);
static int ptm_hard_start_xmit(struct sk_buff *, struct net_device *);
static int ptm_ioctl(struct net_device *, struct ifreq *, int);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
static void ptm_tx_timeout(struct net_device *);
#else
static void ptm_tx_timeout(struct net_device *, unsigned int txqueue);
#endif

static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to set RSS key and MAC address for the pTM device.

ptm_set_rss_key()
Parameters:
-	struct net_device *		ptm_netdev

ptm_set_mac




NEXT




<s> static int new_foreach_bridge(int (*iterator)(const char *name, void *),
void *arg)
{
struct dirent **namelist;
int i, count = 0;

count = scandir(SYSFS_CLASS_NET, &namelist, isbridge, alphasort);
if (count < 0)
return -1;

for (i = 0; i < count; i++) {
if (iterator(namelist[i]->d_name, arg))
break;
}

for (i = 0; i < count; i++)
free(namelist[i]);
free(namelist);

return count;
}

The above function is used to iterate through all the bridges in the kernel at
runtime, so that the kernel does not need to support enumeration as an exported
service. A better name would probably be something other than new_foreach_bridge;
perhaps




NEXT




<s> static int __init wl_glue_init(void)
{
#ifdef CONFIG_BCM47XX
/*
* BCM47xx currently supports either SSB or BCMA bus,
* determine the used one from the info set by the
* platform setup code.
*/
switch (bcm47xx_bus_type)
{
#ifdef CONFIG_BCM47XX_SSB
case BCM47XX_BUS_TYPE_SSB:
active_bus_type = WL_GLUE_BUS_TYPE_SSB;
break;
#endif /* CONFIG_BCM47XX_SSB */

#ifdef CONFIG_BCM47XX_BCMA
case BCM47XX_BUS_TYPE_BCMA:
active_bus_type = WL_GLUE_BUS_TYPE_BCMA;
break;
#endif /* CONFIG_BCM47XX_BCMA */
}
#endif /* CONFIG_BCM47XX */

#ifdef CONFIG_BCM63XX
#ifdef CONFIG_SSB
/*
* BCM63xx currently only uses SSB, so assume that.
*/
active_bus_type = WL_GLUE_BUS_TYPE_SSB;
#endif /* CONFIG_SSB */
#endif /* CONFIG_BCM63XX */

/* do not fail here, let wl_glue_register() return -ENOSYS later */
if (active_bus_type == WL_GLUE_BUS_TYPE_UNSPEC)
pr_err("Unable to determine used system bus type\n");

return 0;
}

The above function is used to determine whether to use bcm_acp or not in WICED.
The glue kernel driver will initialize hardware, which WICED should not do.
If the active bus type is unsupported, the glue driver will initialize




NEXT




<s> static void xfgets(char *str, int size, FILE *in)
{
if (!fgets(str, size, in))
fprintf(stderr, "\nError in reading or end of file.\n");

if (!tty_stdio)
printf("%s", str);
}

The above function is used to read a string from a file.

static void xfgets(char *str, int size, FILE *in)
{
if (!fgets(str, size, in))
fprintf(stderr, "\nError in reading




NEXT




<s> static int rtl8367b_mii_write(struct mii_bus *bus, int addr, int reg, u16 val)
{
struct rtl8366_smi *smi = bus->priv;
u32 t;
int err;

err = rtl8367b_write_phy_reg(smi, addr, reg, val);
if (err)
return err;

/* flush write */
(void) rtl8367b_read_phy_reg(smi, addr, reg, &t);

return err;
}

The above function is used to write to a phy register and returns error if the PHY responds with an error code.

The following functions used to read from a phy register.

int rtl8367b_mii_read_




NEXT




<s> ret_t rtl8367c_setAsicIpMulticastVlanLeaky(rtk_uint32 port, rtk_uint32 enabled)
{
ret_t  retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IPMCAST_VLAN_LEAKY, port, enabled);

return retVal;
}

The above function is used to set IMMCAST_LEAKYVLAN in IP Multicast VLAN Filtering mode. Refer to Fig. 60 for details.

Note: After change IMMCAST_LEAKYVLAN, rtl8




NEXT




<s> static ssize_t rtl8366_read_debugfs_reg(struct file *file,
char __user *user_buf,
size_t count, loff_t *ppos)
{
struct rtl8366_smi *smi = (struct rtl8366_smi *)file->private_data;
u32 t, reg = smi->dbg_reg;
int err, len = 0;
char *buf = smi->buf;

memset(buf, '\0', sizeof(smi->buf));

err = rtl8366_smi_read_reg(smi, reg, &t);
if (err) {
len += snprintf(buf, sizeof(smi->buf),
"Read failed (reg: 0x%04x)\n", reg);
return simple_read_from_buffer(user_buf, count, ppos, buf, len);
}

len += snprintf(buf, sizeof(smi->buf), "reg = 0x%04x, val = 0x%04x\n",
reg, t);

return simple_read_from_buffer(user_buf, count, ppos, buf, len);
}

The above function is used to read a register in memory. As you notice, I want
to read an address that is stored in a variable. The problem
is that the macro, simple_read_from_buffer(), requires two parameters
that correspond to two buffers in




NEXT




<s> static int rtl8367_switch_init(struct rtl8366_smi *smi)
{
struct switch_dev *dev = &smi->sw_dev;
int err;

dev->name = "RTL8367";
dev->cpu_port = RTL8367_CPU_PORT_NUM;
dev->ports = RTL8367_NUM_PORTS;
dev->vlans = RTL8367_NUM_VIDS;
dev->ops = &rtl8367_sw_ops;
dev->alias = dev_name(smi->parent);

err = register_switch(dev, NULL);
if (err)
dev_err(smi->parent, "switch registration failed\n");

return err;
}

The above function is used to register switch devices. When system boots, kernel calls the above function to complete the registration process of the switch devices. In this way, network devices will be created according to the registration information of switch devices.

It is important to note that different




NEXT




<s> static int adm6996_gpio_remove(struct platform_device *pdev)
{
struct adm6996_priv *priv = platform_get_drvdata(pdev);

if (priv && (priv->model == ADM6996M || priv->model == ADM6996L))
unregister_switch(&priv->dev);

return 0;
}

The above function is used to unregister the switch subsystem for gpio controller. Once you are done with your GPIO control, call this function to remove the device from the kernel.</s>




NEXT




<s> void rtl839x_vlan_profile_dump(int profile)
{
u32 p[2];

if (profile < 0 || profile > 7)
return;

p[0] = sw_r32(RTL839X_VLAN_PROFILE(profile));
p[1] = sw_r32(RTL839X_VLAN_PROFILE(profile) + 4);

pr_info("VLAN profile %d: L2 learning: %d, UNKN L2MC FLD PMSK %d, \
UNKN IPMC FLD PMSK %d, UNKN IPv6MC FLD PMSK: %d",
profile, p[1] & 1, (p[1] >> 1) & 0xfff, (p[1] >> 13) & 0xfff,
(p[0]) & 0xfff);
pr_info("VLAN profile %d: raw %08x, %08x\n", profile, p[0], p[1]);
}

The above function is used to display the VLAN profile. For example, when the "sandbox" is set as VLAN profile 0, you can call rtl839x_vlan_profile_dump(0). This function is usually called during




NEXT




<s> static int proc_read_wanmib(char *, char **, off_t, int, int *, void *);
static int proc_write_wanmib(struct file *, const char *, unsigned long, void *);
#if defined(ENABLE_FW_PROC) && ENABLE_FW_PROC
static int proc_read_genconf(char *, char **, off_t, int, int *, void *);
#endif
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static int proc_read_dbg(char *, char **, off_t, int, int *, void *);
static int proc_write_dbg(struct file *, const char *, unsigned long, void *);
#endif

/*
*  Proc Help Functions
*/
static INLINE int stricmp(const char *, const char *);
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static INLINE int strincmp(const char *, const char *, int);
#endif
static INLINE int ifx_ptm_version(char *);

/*
*  Init & clean-up functions
*/
static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to check if X-data
of Showtime is loaded.
#endif

/*
*  Structure/Enuermations
*/
typedef struct {
int pid;
char *name;
} pid_name




NEXT




<s> static int __init mtdsplit_bcm_wfi_init(void)
{
register_mtd_parser(&mtdsplit_bcm_wfi_parser);
register_mtd_parser(&mtdsplit_bcm_wfi_split_parser);
register_mtd_parser(&mtdsplit_ser_wfi_parser);

return 0;
}

The above function is used to register the metadata parser and return 0 if it runs without any error.

static void __exit mtdsplit_bcm_wfi_exit(void)
{
unregister_mtd_parser(&mtdsplit_b




NEXT




<s> static inline unsigned long sb_addr_to_fpi_addr_convert(unsigned long sb_addr)
{
#define PP32_SB_ADDR_END        0xFFFF

if ( sb_addr < PP32_SB_ADDR_END) {
return (unsigned long ) SB_BUFFER(sb_addr);
}
else {
return sb_addr;
}
}

The above function is used to convert the address of a single-byte item
to the corresponding address of a two-byte item. If this is in fact a
single-byte item in the SMP buffer, it will be converted to the address
of the corresponding two




NEXT




<s> static void _rtl8367c_svlanConfStSmi2User( rtl8367c_svlan_memconf_t *pUserSt, rtk_uint16 *pSmiSt)
{

pUserSt->vs_member = (pSmiSt[0] & 0x00FF) | ((pSmiSt[3] & 0x0007) << 8);
pUserSt->vs_untag = ((pSmiSt[0] & 0xFF00) >> 8) | (((pSmiSt[3] & 0x0038) >> 3) << 8);

pUserSt->vs_fid_msti = (pSmiSt[1] & 0x000F);
pUserSt->vs_priority = (pSmiSt[1] & 0x0070) >> 4;
pUserSt->vs_force_fid = (pSmiSt[1] & 0x0080) >> 7;

pUserSt->vs_svid = (pSmiSt[2] & 0x0FFF);
pUserSt->vs_efiden = (pSmiSt[2] & 0x1000) >> 12;
pUserSt->vs_efid = (pSmiSt[2] & 0xE000) >> 13;
}

The above function is used to convert a S/W structure to H/W structure while assigning S/W structure for each S/W SVLAN_MEMC_T in user input. While H/W structure is assigned to H/W SVLAN_MEMC




NEXT




<s> rtk_api_ret_t rtk_vlan_portAcceptFrameType_get(rtk_port_t port, rtk_vlan_acceptFrameType_t *pAccept_frame_type)
{
rtk_api_ret_t retVal;
rtl8367c_accframetype   acc_frm_type;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pAccept_frame_type)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicVlanAccpetFrameType(rtk_switch_port_L2P_get(port), &acc_frm_type)) != RT_ERR_OK)
return retVal;

*pAccept_frame_type = (rtk_vlan_acceptFrameType_t)acc_frm_type;

return RT_ERR_OK;
}

The above function is used to enable or disable RGMII LTSSM automatic recovery by programming a bit in an IER.

*/
rtk_api_ret_t rtk_rgmii_recovery_disable(rtk_port_




NEXT




<s> ar8216_vtu_load_vlan(struct ar8xxx_priv *priv, u32 vid, u32 port_mask)
{
u32 op;

op = AR8216_VTU_OP_LOAD | (vid << AR8216_VTU_VID_S);
ar8216_vtu_op(priv, op, port_mask);
}

The above function is used to "load" an VLAN.

But the current implementation does not consider the following case:
I have two ports, which use the same VLAN, suppose it is VLAN 1.
Now it seems that, calling this function




NEXT




<s> static void center_item(int selected_index, int *last_top_row)
{
int toprow;

set_top_row(curses_menu, *last_top_row);
toprow = top_row(curses_menu);
if (selected_index < toprow ||
selected_index >= toprow+mwin_max_lines) {
toprow = max(selected_index-mwin_max_lines/2, 0);
if (toprow >= item_count(curses_menu)-mwin_max_lines)
toprow = item_count(curses_menu)-mwin_max_lines;
set_top_row(curses_menu, toprow);
}
set_current_item(curses_menu,
curses_menu_items[selected_index]);
*last_top_row = toprow;
post_menu(curses_menu);
refresh_all_windows(main_window);
}

The above function is used to center the selected item in a window
(set the top row to display the menu entry on the screen centered in
the window without scrolling to show the rest of the list) and to
post the change. There is a similar function for




NEXT




<s> hostapd_rrm_lm_req(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *ureq, const char *method,
struct blob_attr *msg)
{
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
struct blob_attr *tb[__LM_REQ_MAX];
struct wpabuf *buf;
u8 addr[ETH_ALEN];
int ret;
int8_t txp_used, txp_max;

txp_used = 0;
txp_max = 0;

blobmsg_parse(lm_req_policy, __LM_REQ_MAX, tb, blob_data(msg), blob_len(msg));

if (!tb[LM_REQ_ADDR])
return UBUS_STATUS_INVALID_ARGUMENT;

if (tb[LM_REQ_TX_POWER_USED])
txp_used = (int8_t) blobmsg_get_u32(tb[LM_REQ_TX_POWER_USED]);

if (tb[LM_REQ_TX_POWER_MAX])
txp_max = (int8_t) blobmsg_get_u32(tb[LM_REQ_TX_POWER_MAX]);

if (hwaddr_aton(blobmsg_data(tb[LM_REQ_ADDR]), addr))
return UBUS_STATUS_INVALID_ARGUMENT;

buf = wpabuf_alloc(5);
if (!buf)
return UBUS_STATUS_UNKNOWN_ERROR;

wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
wpabuf_put_u8(buf, WLAN_RRM_LINK_MEASUREMENT_REQUEST);
wpabuf_put_u8(buf, 1);
/* TX-Power used */
wpabuf_put_u8(buf, txp_used);
/* Max TX Power */
wpabuf_put_u8(buf, txp_max);

ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
wpabuf_head(buf), wpabuf_len(buf));

wpabuf_free(buf);
if (ret < 0)
return -ret;

return 0;
}

The above function is used to send request to hostapd_drv and it will fill
the radiotap header and send to radio. But the problem is when it sends the
radiotap header without any content. This caused a bug in hostapd that it




NEXT




<s> rtk_api_ret_t rtk_svlan_unmatch_action_get(rtk_svlan_unmatch_action_t *pAction, rtk_vlan_t *pSvid)
{
rtk_api_ret_t   retVal;
rtk_uint32      svidx;
rtl8367c_svlan_memconf_t svlanMemConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pAction || NULL == pSvid)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicSvlanIngressUnmatch(pAction)) != RT_ERR_OK)
return retVal;

if(*pAction == UNMATCH_ASSIGN)
{
if ((retVal = rtl8367c_getAsicSvlanUnmatchVlan(&svidx)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(svidx, &svlanMemConf)) != RT_ERR_OK)
return retVal;

*pSvid = svlanMemConf.vs_svid;
}

return RT_ERR_OK;
}

The above function is used to get the match S-VID value of default action.</s>




NEXT




<s> static int msp430_led(struct spi_device *spi, struct device_node *nc, u8 id)
{
struct device *dev = &spi->dev;
struct led_init_data init_data = {};
struct msp430_led *led;
enum led_default_state state;
int rc;

led = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);
if (!led)
return -ENOMEM;

led->id = id;
led->spi = spi;

init_data.fwnode = of_fwnode_handle(nc);

state = led_init_default_state_get(init_data.fwnode);
switch (state) {
case LEDS_DEFSTATE_ON:
led->cdev.brightness = MSP430_LED_BRIGHTNESS_MAX;
break;
default:
led->cdev.brightness = LED_OFF;
break;
}

msp430_brightness_set(&led->cdev, led->cdev.brightness);

led->cdev.blink_set = msp430_blink_set;
led->cdev.brightness_set_blocking = msp430_brightness_set;
led->cdev.max_brightness = MSP430_LED_BRIGHTNESS_MAX;
led->cdev.pattern_clear = msp430_pattern_clear;
led->cdev.pattern_set = msp430_pattern_set;

rc = devm_led_classdev_register_ext(dev, &led->cdev, &init_data);
if (rc < 0)
return rc;

dev_dbg(dev, "registered LED %s\n", led->cdev.name);

return 0;
}

The above function is used to create the LEDs for the MSP430 microcontroller. It takes in some parameters such as the spi device, the device node and a u8 id. The function first creates a device structure for the LED and initializes it with




NEXT




<s> static int aes_cbcmac_init(struct shash_desc *desc)
{

struct aes_ctx *mctx = crypto_shash_ctx(desc->tfm);

mctx->dbn = 0; //dbn workaround
mctx->started = 0;
mctx->byte_count = 0;
memset(mctx->hash, 0, AES_BLOCK_SIZE);

return 0;
}

The above function is used to initialize the AES CBC-MAC algorithm context. It sets the initial values for the context and starts the algorithm.

static int aes_cbcmac_transform(struct shash_desc *desc, const void *data,




NEXT




<s> static void ag71xx_ethtool_get_ringparam(struct net_device *dev,
struct ethtool_ringparam *er,
struct kernel_ethtool_ringparam *kernel_ring,
struct netlink_ext_ack *extack)
#else
static void ag71xx_ethtool_get_ringparam(struct net_device *dev,
struct ethtool_ringparam *er)
#endif
{
struct ag71xx *ag = netdev_priv(dev);

er->tx_max_pending = AG71XX_TX_RING_SIZE_MAX;
er->rx_max_pending = AG71XX_RX_RING_SIZE_MAX;
er->rx_mini_max_pending = 0;
er->rx_jumbo_max_pending = 0;

er->tx_pending = BIT(ag->tx_ring.order);
er->rx_pending = BIT(ag->rx_ring.order);
er->rx_mini_pending = 0;
er->rx_jumbo_pending = 0;

if (ag->tx_ring.desc_split)
er->tx_pending /= AG71XX_TX_RING_DS_PER_PKT;
}

The above function is used to retrieve the driver’s capability to
handle packets pending in its transmission queue, and the length
for which the driver is capable to hold on to the packets pending
in its reception queue.

Earlier, we saw how packets are transferred




NEXT




<s> static rtk_api_ret_t _rtk_int_Advidx_get(rtk_int_advType_t adv_type, rtk_uint32 *pAsic_idx)
{
rtk_uint32 asic_idx[ADV_END] =
{
INTRST_L2_LEARN,
INTRST_SPEED_CHANGE,
INTRST_SPECIAL_CONGESTION,
INTRST_PORT_LINKDOWN,
INTRST_PORT_LINKUP,
ADV_NOT_SUPPORT,
INTRST_RLDP_LOOPED,
INTRST_RLDP_RELEASED,
};

if(adv_type >= ADV_END)
return RT_ERR_INPUT;

if(asic_idx[adv_type] == ADV_NOT_SUPPORT)
return RT_ERR_CHIP_NOT_SUPPORTED;

*pAsic_idx = asic_idx[adv_type];
return RT_ERR_OK;
}

The above function is used to return the value of Asic_idx which is in INTRST macro to specify to interrupt channel for corresponding interrupt event. For example, _rtk_int_Advidx_get(0x00, &pAdvIdx) will




NEXT




<s> static int switch_vlan_open(struct inode *inode, struct file *file)
{
return single_open(file, vlan_read, 0);
}

The above function is used to create a new file object. The inode parameter is the inode of the file that you want to open. The second parameter is the file object that you want to create. The file object is a pointer to a file struct that represents a file in the




NEXT




<s> ret_t rtl8367c_setAsicI2CTxNoAckCmd(void)
{
rtk_uint32 regData;
ret_t retVal;

/* Bits [4-1] = 0b0101, tx noACK Command; Bit [0] = 1, Trigger the Command */
if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
return retVal;
regData &= 0xFFE0;
regData |= 0x000b;
if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
return retVal;

/* wait for command finished */
do{
if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
return retVal;
}while( regData != 0x0);

return RT_ERR_OK ;

}

The above function is used to set the RTL8367C’s I2C mode for ‘Tx No ACK’.

On RTL8367C hardware, we set reg 0x0214 to 0x48




NEXT




<s> static struct net_device_stats *ptm_get_stats(struct net_device *);
static int ptm_open(struct net_device *);
static int ptm_stop(struct net_device *);
static unsigned int ptm_poll(int, unsigned int);
static int ptm_napi_poll(struct napi_struct *, int);
static int ptm_hard_start_xmit(struct sk_buff *, struct net_device *);
static int ptm_ioctl(struct net_device *, struct ifreq *, int);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
static void ptm_tx_timeout(struct net_device *);
#else
static void ptm_tx_timeout(struct net_device *, unsigned int txqueue);
#endif

static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to allocate memory for input and output packets. It can be modified for additional queues.
*/

static inline void ptm_flush_rx_buf(void) {
static inline struct sk_buff* alloc_skb_rx(




NEXT




<s> void rtl839x_egress_rate_queue_limit(struct rtl838x_switch_priv *priv, int port,
int queue, u32 rate)
{
int lsb = 128 + queue * 20;
int low_byte = 8 - (lsb >> 5);
int start_bit = lsb - (low_byte << 5);
u32 high_mask = 0xfffff	>> (32 - start_bit);

pr_debug("%s: Setting egress rate on port %d, queue %d to %d\n",
__func__, port, queue, rate);
if (port >= priv->cpu_port)
return;
if (queue > 7)
return;

mutex_lock(&priv->reg_mutex);

rtl839x_read_scheduling_table(port);

sw_w32_mask(0xfffff << start_bit, (rate & 0xfffff) << start_bit,
RTL839X_TBL_ACCESS_DATA_2(low_byte));
if (high_mask)
sw_w32_mask(high_mask, (rate & 0xfffff) >> (32- start_bit),
RTL839X_TBL_ACCESS_DATA_2(low_byte - 1));

rtl839x_write_scheduling_table(port);

mutex_unlock(&priv->reg_mutex);
}

The above function is used to configure the packet forwarding rate to each port for egress.</s>




NEXT




<s> static int rtl8367b_enable_vlan(struct rtl8366_smi *smi, int enable)
{
return rtl8366_smi_rmwr(smi, RTL8367B_VLAN_CTRL_REG,
RTL8367B_VLAN_CTRL_ENABLE,
(enable) ? RTL8367B_VLAN_CTRL_ENABLE : 0);
}

The above function is used to enable/disable the virtual LAN port.
This function just reads and writes the data through the register.

The RTL8367B_VLAN_CTRL_REG is the address which store the function
control register.




NEXT




<s> show_vlan(struct switch_dev *dev, int vlan, bool all)
{
struct switch_val val;
struct switch_attr *attr;

val.port_vlan = vlan;

if (all) {
attr = swlib_lookup_attr(dev, SWLIB_ATTR_GROUP_VLAN, "ports");
if (swlib_get_attr(dev, attr, &val) < 0)
return;

if (!val.len)
return;
}

printf("VLAN %d:\n", vlan);
show_attrs(dev, dev->vlan_ops, &val);
}

The above function is used to traverse all vlan ports.

In switch device's constructor, we add a group

attribute like this:

/* Switch is created */
val.group.type = SWLIB_ATTR_GROUP_PORT;





NEXT




<s> static int rtl83xx_port_lag_join(struct dsa_switch *ds, int port,
struct net_device *lag,
struct netdev_lag_upper_info *info)
{
struct rtl838x_switch_priv *priv = ds->priv;
int i, err = 0;

if (!rtl83xx_lag_can_offload(ds, lag, info))
return -EOPNOTSUPP;

mutex_lock(&priv->reg_mutex);

for (i = 0; i < priv->n_lags; i++) {
if ((!priv->lag_devs[i]) || (priv->lag_devs[i] == lag))
break;
}
if (port >= priv->cpu_port) {
err = -EINVAL;
goto out;
}
pr_info("port_lag_join: group %d, port %d\n",i, port);
if (!priv->lag_devs[i])
priv->lag_devs[i] = lag;

if (priv->lag_primary[i] == -1) {
priv->lag_primary[i] = port;
} else
priv->is_lagmember[port] = 1;

priv->lagmembers |= (1ULL << port);

pr_debug("lag_members = %llX\n", priv->lagmembers);
err = rtl83xx_lag_add(priv->ds, i, port, info);
if (err) {
err = -EINVAL;
goto out;
}

out:
mutex_unlock(&priv->reg_mutex);

return err;
}

The above function is used to join a new port to an existing bond. This is different from the
previous join in a bond. The code below is modified:

void set_mfp(unsigned int port)
{
unsigned long tag;

if (!




NEXT




<s> rtk_api_ret_t rtk_svlan_untag_action_set(rtk_svlan_untag_action_t action, rtk_vlan_t svid)
{
rtk_api_ret_t   retVal;
rtk_uint32      i;
rtl8367c_svlan_memconf_t svlanMemConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (action >= UNTAG_END)
return RT_ERR_OUT_OF_RANGE;

if(action == UNTAG_ASSIGN)
{
if (svid > RTL8367C_VIDMAX)
return RT_ERR_SVLAN_VID;
}

if ((retVal = rtl8367c_setAsicSvlanIngressUntag((rtk_uint32)action)) != RT_ERR_OK)
return retVal;

if(action == UNTAG_ASSIGN)
{
for (i = 0; i < RTL8367C_SVIDXNO; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;

if (svid == svlanMemConf.vs_svid)
{
if ((retVal = rtl8367c_setAsicSvlanUntagVlan(i)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}
}

return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
}

return RT_ERR_OK;
}

The above function is used to specify whether to tag or untag SVLAN for packets tagged with VLAN 0 inbound, which includes:

• Do not tag (untag) SVLAN if the packets are tagged with VLAN 0.






NEXT




<s> ret_t rtl8367c_getReservedVidAction(rtk_uint32 *pVid0Action, rtk_uint32 *pVid4095Action)
{
ret_t   retVal;

if(pVid0Action == NULL)
return RT_ERR_NULL_POINTER;

if(pVid4095Action == NULL)
return RT_ERR_NULL_POINTER;

if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_VID0_TYPE_OFFSET, pVid0Action)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_VID4095_TYPE_OFFSET, pVid4095Action)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;

}

The above function is used to get the 1st-VLAN value and the reserved VLAN value. This function is not in the example code.</s>




NEXT




<s> static int bcm6348_emac_refill_rx(struct net_device *ndev)
{
struct bcm6348_emac *emac = netdev_priv(ndev);
struct bcm6348_iudma *iudma = emac->iudma;
struct platform_device *pdev = emac->pdev;
struct device *dev = &pdev->dev;

while (emac->rx_desc_count < emac->rx_ring_size) {
struct bcm6348_iudma_desc *desc;
struct sk_buff *skb;
dma_addr_t p;
int desc_idx;
u32 len_stat;

desc_idx = emac->rx_dirty_desc;
desc = &emac->rx_desc_cpu[desc_idx];

if (!emac->rx_skb[desc_idx]) {
skb = netdev_alloc_skb(ndev, emac->rx_skb_size);
if (!skb)
break;
emac->rx_skb[desc_idx] = skb;
p = dma_map_single(dev, skb->data, emac->rx_skb_size,
DMA_FROM_DEVICE);
desc->address = p;
}

len_stat = emac->rx_skb_size << DMADESC_LENGTH_SHIFT;
len_stat |= DMADESC_OWNER_MASK;
if (emac->rx_dirty_desc == emac->rx_ring_size - 1) {
len_stat |= DMADESC_WRAP_MASK;
emac->rx_dirty_desc = 0;
} else {
emac->rx_dirty_desc++;
}
wmb();
desc->len_stat = len_stat;

emac->rx_desc_count++;

/* tell dma engine we allocated one buffer */
dma_writel(iudma, 1, DMA_BUFALLOC_REG(emac->rx_chan));
}

/* If rx ring is still empty, set a timer to try allocating
* again at a later time. */
if (emac->rx_desc_count == 0 && netif_running(ndev)) {
dev_warn(dev, "unable to refill rx ring\n");
emac->rx_timeout.expires = jiffies + HZ;
add_timer(&emac->rx_timeout);
}

return 0;
}

The above function is used to re-fill the receive ring buffer. This
function is called by the hardware interrupt handler if the receive
ring is empty. DMA descriptors are allocated or copied to
emac->rx_desc_cpu[], emac->rx_




NEXT




<s> static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to notify whether LED is enabled in case of
ATM and PPPoE interfaces running on MEI in SFP-Mode.

void ifx_setTxLinkrateLedEnabled(int enabled)
{








NEXT




<s> static void handle_dump(struct ubus_request *req __attribute__((unused)),
int type __attribute__((unused)), struct blob_attr *msg)
{
struct blob_attr *tb[DUMP_ATTR_INTERFACE];
blobmsg_parse(dump_attrs, DUMP_ATTR_MAX, tb, blob_data(msg), blob_len(msg));

if (!tb[DUMP_ATTR_INTERFACE])
return;

dump = blob_memdup(tb[DUMP_ATTR_INTERFACE]);
}

The above function is used to receive the messages from U-Bus, and to parse the dump of the given interface.

In the following, we are going to use a new parameter in libubus for sending the list of commands, and for receiving the data for the




NEXT




<s> static int wlc_flag(wlc_param param, void *data, void *value)
{
int *var = *((int **) data);

*var = 1;

return 0;
}

The above function is used to assign a constant, 1, for a parameter (the value of which I don’t actually care for).

Now my question is – why do I need a void *var in this function definition. Obviously it is related to dereference




NEXT




<s> ar8xxx_sw_set_pvid(struct switch_dev *dev, int port, int vlan)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

/* make sure no invalid PVIDs get set */

if (vlan < 0 || vlan >= dev->vlans ||
port < 0 || port >= AR8X16_MAX_PORTS)
return -EINVAL;

priv->pvid[port] = vlan;
return 0;
}

The above function is used to set PVID for a specific port. We pass it an invalid
vlan ID when we are resetting the port state. This will clear the PVID entry in
priv->pvid (which we have already initialized properly in the driver'




NEXT




<s> static int wl_glue_ssb_probe(struct ssb_device *dev, const struct ssb_device_id *id)
{
void *mmio;
void *wldev;

if (!attach_cb)
{
pr_err("No attach callback registered\n");
return -ENOSYS;
}

if (dev->bus->bustype != SSB_BUSTYPE_SSB)
{
pr_err("Attaching to SSB behind PCI is not supported. Please remove the b43 ssb bridge\n");
return -EINVAL;
}

mmio = (void *) 0x18000000 + dev->core_index * 0x1000;
wldev = attach_cb(id->vendor, id->coreid, (ulong)mmio, dev, dev->irq);

if (!wldev)
{
pr_err("The attach callback failed, SSB probe aborted\n");
return -ENODEV;
}

ssb_set_drvdata(dev, wldev);
return 0;
}

The above function is used to probe wl_ssb and attaching to the associated sub-device(Wi-Fi).
First let’s get to know what is PCI and what is PCIe.
To keep the article short, let’s learn the




NEXT




<s> BigIntegerMod(result, d, m)
BigInteger result, d, m;
{
BN_CTX * ctx = BN_CTX_new();
BN_mod(result, d, m, ctx);
BN_CTX_free(ctx);
}

The above function is used to perform a modular exponentiation operation.

The first parameter to this function is the result of the operation, which is a big integer.

The second parameter is the modulus, m, which is also a big integer.






NEXT




<s> static unsigned oxnas_pcie_cfg_to_offset(
struct pci_sys_data *sys,
unsigned char bus_number,
unsigned int devfn,
int where)
{
unsigned int function = PCI_FUNC(devfn);
unsigned int slot = PCI_SLOT(devfn);
unsigned char bus_number_offset;

bus_number_offset = bus_number - sys->busnr;

/*
* We'll assume for now that the offset, function, slot, bus encoding
* should map onto linear, contiguous addresses in PCIe config space,
* albeit that the majority will be unused as only slot 0 is valid for
* any PCIe bus and most devices have only function 0
*
* Could be that PCIe in fact works by not encoding the slot number into
* the config space address as it's known that only slot 0 is valid.
* We'll have to experiment if/when we get a PCIe switch connected to
* the PCIe host
*/
return (bus_number_offset << 20) | (slot << 15) | (function << 12) |
(where & ~3);
}

The above function is used to translate slot, bus, device fn into
offset where there is no function in the definition and then from
that offset, we subtract 16*4 as there will be two 32 bit
registers per pci function and we




NEXT




<s> static inline void m_str(const char *id, const char *value) {
blobmsg_add_string(&b, id, value);
}

The above function is used to populate the blob that gets passed in blobmsg_add_field_and_blob(struct blob_buf *b, const char *
key, const char *
key, const char *value) { struct blob_buf *b




NEXT




<s> int rtl931x_l3_setup(struct rtl838x_switch_priv *priv)
{
return 0;
}

The above function is used to setup the L3 operations of the switch. But this function does nothing except returning an error code.

In the switch driver, it is only used in the RTL933x switch driver as the prototype like this:

r




NEXT




<s> static int rtl931x_set_ageing_time(unsigned long msec)
{
int t = sw_r32(RTL931X_L2_AGE_CTRL);

t &= 0x1FFFFF;
t = (t * 8) / 10;
pr_debug("L2 AGING time: %d sec\n", t);

t = (msec / 100 + 7) / 8;
t = t > 0x1FFFFF ? 0x1FFFFF : t;
sw_w32_mask(0x1FFFFF, t, RTL931X_L2_AGE_CTRL);
pr_debug("Dynamic aging for ports: %x\n", sw_r32(RTL931X_L2_PORT_AGE_CTRL));

return 0;
}

The above function is used to dynamically set aging time in SW.

#ifdef CONFIG_XFS_RTL931X
void rtl931x_clear_flush(u32 dev_id)
{
char buff[ETH




NEXT




<s> ret_t rtl8367c_setAsicPortIngressBandwidthBypass(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_SW_DUMMY0, RTL8367C_INGRESSBW_BYPASS_EN_OFFSET, enabled);
}

The above function is used to modify the ingress BW-bypass enable.

The function can make sure the enabled or disabled is correct,
but the ingress BW-bypass enable of some PHY chip is incorrect,
so the rtl8




NEXT




<s> static int bcm4908img_bootfs_ls(FILE *fp, struct bcm4908img_info *info) {
struct jffs2_unknown_node node;
struct jffs2_raw_dirent dirent;
size_t offset;
size_t bytes;
int err = 0;

for (offset = info->bootfs_offset; ; offset += (je32_to_cpu(node.totlen) + 0x03) & ~0x03) {
char name[FILENAME_MAX + 1];

if (fseek(fp, offset, SEEK_SET)) {
err = -errno;
fprintf(stderr, "Failed to fseek: %d\n", err);
return err;
}

bytes = fread(&node, 1, sizeof(node), fp);
if (bytes != sizeof(node)) {
fprintf(stderr, "Failed to read %zu bytes\n", sizeof(node));
return -EIO;
}

if (je16_to_cpu(node.magic) != JFFS2_MAGIC_BITMASK) {
break;
}

if (je16_to_cpu(node.nodetype) != JFFS2_NODETYPE_DIRENT) {
continue;
}

memcpy(&dirent, &node, sizeof(node));
bytes += fread((uint8_t *)&dirent + sizeof(node), 1, sizeof(dirent) - sizeof(node), fp);
if (bytes != sizeof(dirent)) {
fprintf(stderr, "Failed to read %zu bytes\n", sizeof(node));
return -EIO;
}

if (dirent.nsize + 1 > sizeof(name)) {
/* Keep reading & printing BUT exit with error code */
fprintf(stderr, "Too long filename\n");
err = -ENOMEM;
continue;
}

bytes = fread(name, 1, dirent.nsize, fp);
if (bytes != dirent.nsize) {
fprintf(stderr, "Failed to read filename\n");
return -EIO;
}
name[bytes] = '\0';

printf("%s\n", name);
}

return err;
}

The above function is used to dump the directories/folders of .jffs2 firmware image of BCM4908 bootfs to stdout.</s>




NEXT




<s> static void _rtl8367c_svlanConfStUser2Smi( rtl8367c_svlan_memconf_t *pUserSt, rtk_uint16 *pSmiSt)
{
pSmiSt[0] |= (pUserSt->vs_member & 0x00FF);
pSmiSt[0] |= (pUserSt->vs_untag & 0x00FF) << 8;

pSmiSt[1] |= (pUserSt->vs_fid_msti & 0x000F);
pSmiSt[1] |= (pUserSt->vs_priority & 0x0007) << 4;
pSmiSt[1] |= (pUserSt->vs_force_fid & 0x0001) << 7;

pSmiSt[2] |= (pUserSt->vs_svid & 0x0FFF);
pSmiSt[2] |= (pUserSt->vs_efiden & 0x0001) << 12;
pSmiSt[2] |= (pUserSt->vs_efid & 0x0007) << 13;

pSmiSt[3] |= ((pUserSt->vs_member & 0x0700) >> 8);
pSmiSt[3] |= ((pUserSt->vs_untag & 0x0700) >> 8) << 3;
}

The above function is used to store the SVLAN tag configuration into the chip register for SVLAN tag injection.

When VLAN is configured as SVLAN by setting the following parameters:

VLAN_ID : 0x1000
Enable SVLAN




NEXT




<s> static int __init br200_wp_probe(void)
{
if (of_machine_is_compatible("aerohive,br200-wp"))
return 1;
return 0;
}

The above function is used to detect if the device is an 5102. It is used during device driver initialization.

static int __init br200_wp_probe(void)
{
if (of_machine_is_compatible("




NEXT




<s> ret_t rtl8367c_setAsicPriorityDecision(rtk_uint32 index, rtk_uint32 prisrc, rtk_uint32 decisionPri)
{
ret_t retVal;

if(index >= PRIDEC_IDX_END )
return RT_ERR_ENTRY_INDEX;

if(prisrc >= PRIDEC_END )
return RT_ERR_QOS_SEL_PRI_SOURCE;

if(decisionPri > RTL8367C_DECISIONPRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

switch(index)
{
case PRIDEC_IDX0:
if((retVal = rtl8367c_setAsicRegBits(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_REG(prisrc), RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_MASK(prisrc), decisionPri))!=  RT_ERR_OK)
return retVal;
break;
case PRIDEC_IDX1:
if((retVal = rtl8367c_setAsicRegBits(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_REG(prisrc), RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_MASK(prisrc), decisionPri))!=  RT_ERR_OK)
return retVal;
break;
default:
break;
};

return RT_ERR_OK;


}

The above function is used to set the value of the asic QOS register
RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_REG() (or
RTL8367C_QOS_INT




NEXT




<s> ret_t rtl8367c_getAsicIGMPMcDataRX(rtk_uint32 port, rtk_uint32 *allow_mcdata)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

/* Allow Multicast data */
if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MC_DATA_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MC_DATA_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}

*allow_mcdata = value;

return RT_ERR_OK;
}

The above function is used to retrieve the Allow Multicast data bit map on the IGMP Module.

/*----------------------------------------------------------------------------*/
ret_t rtl8367c_setAsicIGMPMcDataRX(rtk_uint




NEXT




<s> struct expr *expr_alloc_symbol(struct symbol *sym)
{
struct expr *e = xcalloc(1, sizeof(*e));
e->type = E_SYMBOL;
e->left.sym = sym;
return e;
}

The above function is used to allocate a symbol. But it's not a struct. It's actually a struct of two pointers, left, and sym.

struct symbol *
get_builtin_symbol(struct symbol *name)
{
static struct




NEXT




<s> static int sha1_hmac_setkey_hw(const u8 *key, unsigned int keylen)
{
volatile struct deu_hash_t *hash = (struct deu_hash_t *) HASH_START;
int i, j;
u32 *in_key = (u32 *)key;

j = 0;

hash->KIDX |= 0x80000000; //reset keys back to 0
for (i = 0; i < keylen; i+=4)
{
hash->KIDX = j;
asm("sync");
hash->KEY = *((u32 *) in_key + j);
j++;
}

return 0;
}

The above function is used to initialize the SHA1 state for HMAC. The first byte (KIDX) in the SHA1 state is set to 1, to indicate that the next words of the SHA1 message will be the key. Then keysize worth of words




NEXT




<s> interrupt()
{
if (count) {
#ifdef OLD_TRUERAND
longjmp(env, 1);
#else
++done;
return;
#endif
}

(void) signal(SIGALRM, interrupt);
tick();
}

The above function is used to check for timeouts.  It's called once
whenever you block in select(), send(), recv or other functions.
If you're doing multihomed dialups, you also need to call it in
the first three




NEXT




<s> savepwent(tpw, pwent)
struct t_pw * tpw;
struct t_pwent *pwent;
{
tpw->pebuf.name = tpw->userbuf;
tpw->pebuf.password.data = tpw->pwbuf;
tpw->pebuf.salt.data = tpw->saltbuf;
strcpy(tpw->pebuf.name, pwent->name);
tpw->pebuf.password.len = pwent->password.len;
memcpy(tpw->pebuf.password.data, pwent->password.data, pwent->password.len);
tpw->pebuf.salt.len = pwent->salt.len;
memcpy(tpw->pebuf.salt.data, pwent->salt.data, pwent->salt.len);
tpw->pebuf.index = pwent->index;
}

The above function is used to save password in the password database of the
Linux system. The first parameter of the function is the password information structure that is
supply by me; the second parameter is the password information of the Linux system. The function
uses the p




NEXT




<s> rtk_api_ret_t rtk_trunk_mode_get(rtk_trunk_mode_t *pMode)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pMode)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicTrunkingMode((rtk_uint32 *)pMode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the trunk mode, and return the enum
rtk_trunk_mode_t as shown below in rtl8367c_api.h below:
typedef enum
{
TRUNK_STANDB




NEXT




<s> static int trelay_open(struct inode *inode, struct file *file)
{
file->private_data = inode->i_private;
return 0;
}

The above function is used to open a trelay device file. It assigns to the file pointer field the inode pointer of the device file, so subsequent read and write operations can access the device.
It is defined in Linux drivers/tty/trelay.c and it




NEXT




<s> ret_t rtl8367c_getAsicSvlanDmacCvidSel(rtk_uint32 port, rtk_uint32* pEnabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
return rtl8367c_getAsicRegBit(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_PORT0_DMACVIDSEL_OFFSET + port, pEnabled);
else
return rtl8367c_getAsicRegBit(RTL8367C_REG_SVLAN_CFG_EXT, RTL8367C_VS_PORT8_DMACVIDSEL_OFFSET + (port-8), pEnabled);
}

The above function is used to check whether 802.1q DMAC/VID translation is enabled or not on each port. This function can be used during chip startup if the administrator wants to enable 802.1q DMAC/VID translation on




NEXT




<s> ssize_t pread(int fd, void *buf, size_t count, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);

int
trx_fixup(int fd, const char *name)
{
struct mtd_info_user mtdInfo;
unsigned long len;
struct trx_header *trx;
void *ptr, *scan;
int bfd;

if (ioctl(fd, MEMGETINFO, &mtdInfo) < 0) {
fprintf(stderr, "Failed to get mtd info\n");
goto err;
}

len = mtdInfo.size;
if (mtdInfo.size <= 0) {
fprintf(stderr, "Invalid MTD device size\n");
goto err;
}

bfd = mtd_open(name, true);
ptr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, bfd, 0);
if (!ptr || (ptr == (void *) -1)) {
perror("mmap");
fprintf(stderr, "Mapping the TRX header failed\n");
goto err1;
}

trx = ptr;
if (ntohl(trx->magic) != opt_trxmagic) {
fprintf(stderr, "TRX header not found\n");
goto err;
}

scan = ptr + offsetof(struct trx_header, flag_version);
trx->crc32 = crc32buf(scan, trx->len - (scan - ptr));
msync(ptr, sizeof(struct trx_header), MS_SYNC|MS_INVALIDATE);
munmap(ptr, len);
close(bfd);
return 0;

err1:
close(bfd);
err:
return -1;
}

The above function is used to fix up the header of the flash file system on my Freerunner. The structure of the TRX header is described here, the header is located at the 126th byte of the flash file system. First, the open()




NEXT




<s> ret_t rtl8367c_getAsicStormFilterUnknownMulticastEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_STORM_UNKNOWN_MCAST_REG, port, pEnabled);
}

The above function is used to determine if storm-unaware multicast in specific port is enabled or not. The setting of this function is controlled by

- RTK_SWPORT, for SW management and the status will be displayed in the management window
- RT




NEXT




<s> ret_t rtl8367c_getAsicQeueuEmptyStatus(rtk_uint32* portmask)
{
return rtl8367c_getAsicReg(RTL8367C_REG_PORT_QEMPTY, portmask);
}

The above function is used to check if the queue is empty or full.
If the queue is full, you will not be able to enqueue any more packet to queue.
If the queue is empty, you will not be able to dequeue any packet.






NEXT




<s> static int rb4xx_cpld_gpio_set_0_7(struct rb4xx_cpld *cpld, u8 values)
{
/* GPIO 0-7 change can be sent via command + bitfield */
u8 cmd[2] = {
CPLD_CMD_WRITE_CFG, values
};
return rb4xx_cpld_cmd(cpld, &cmd, 2);
}

The above function is used to set up CPLD for a specific value in pins at GPIO0 to GPIO7. It needs some clarification from the designer why exactly this function is used. From the source code it seems that CPLD could be used to set GPIO




NEXT




<s> rtk_api_ret_t rtk_leaky_vlan_get(rtk_leaky_type_t type, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtk_uint32 port,tmp;
rtl8367c_rma_t rmacfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= LEAKY_END)
return RT_ERR_INPUT;

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if (type >= 0 && type <= LEAKY_UNDEF_GARP_2F)
{
if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.vlan_leaky;

}
else if (LEAKY_IPMULTICAST == type)
{
for (port = 0; port <= RTK_PORT_ID_MAX; port++)
{
if ((retVal = rtl8367c_getAsicIpMulticastVlanLeaky(port, &tmp)) != RT_ERR_OK)
return retVal;
if (port>0&&(tmp!=*pEnable))
return RT_ERR_FAILED;
*pEnable = tmp;
}
}
else if (LEAKY_IGMP == type)
{
if ((retVal = rtl8367c_getAsicIGMPVLANLeaky(&tmp)) != RT_ERR_OK)
return retVal;

*pEnable = tmp;
}
else if (LEAKY_CDP == type)
{
if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.vlan_leaky;
}
else if (LEAKY_CSSTP == type)
{
if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.vlan_leaky;
}
else if (LEAKY_LLDP == type)
{
if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.vlan_leaky;
}

return RT_ERR_OK;
}

The above function is used to get the enable/disable status for some system parameters

The parameter type: 0-17 :
0 :leaky VLAN
1 : unregistered (garp traffic) VLAN=2F

2-1




NEXT




<s> static inline u8 *page_data_ptr(struct nand_chip *nand, const u8 *buf,
int sect)
{
return (u8 *)buf + sect * nand->ecc.size;
}

The above function is used to access the data region in the page buffer.
Here, if we look at the NAND flash controller data sheet, we will see that the
read command can read the data region without executing the command to refresh
the internal ECC bits




NEXT




<s> ret_t rtl8367c_setAsicAprMeter(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 apridx)
{
ret_t retVal;
rtk_uint32 regAddr;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;

if(apridx > RTL8367C_PORT_QUEUE_METER_INDEX_MAX)
return RT_ERR_FILTER_METER_ID;

if(port < 8)
retVal = rtl8367c_setAsicRegBits(RTL8367C_SCHEDULE_PORT_APR_METER_REG(port, qid), RTL8367C_SCHEDULE_PORT_APR_METER_MASK(qid), apridx);
else {
regAddr = RTL8367C_REG_SCHEDULE_PORT8_APR_METER_CTRL0 + ((port-8) << 1) + (qid / 5);
retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_SCHEDULE_PORT_APR_METER_MASK(qid), apridx);
}

return retVal;
}

The above function is used to configure the apr meter for a specific scheduler port (8367C)
Notice that not all the apr meters were configurable (only 8 meter for the port0-7) and there is even no need to setup the




NEXT




<s> hostapd_bss_wps_cancel(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
int rc;
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);

rc = hostapd_wps_cancel(hapd);

if (rc != 0)
return UBUS_STATUS_NOT_SUPPORTED;

return 0;
}

The above function is used to cancel a WPS action.</s>




NEXT




<s> static void mt7620_init_data(struct fe_soc_data *data,
struct net_device *netdev)
{
struct fe_priv *priv = netdev_priv(netdev);

priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_RX_2B_OFFSET |
FE_FLAG_RX_SG_DMA | FE_FLAG_HAS_SWITCH;

netdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |
NETIF_F_HW_VLAN_CTAG_TX;
if (mt7620_get_eco() >= 5)
netdev->hw_features |= NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6 |
NETIF_F_IPV6_CSUM;
}

The above function is used to initialize fe_soc_data & netdev. In
mt7620_get_eco(), the following code segment is executed.

static void mt7620_get_eco(struct fe_soc_




NEXT




<s> static void rb4xx_gpio_set(struct gpio_chip *chip, unsigned int offset,
int value)
{
rb4xx_gpio_cpld_set(gpiochip_get_data(chip), offset, value);
}

The above function is used to write to GPIO pins. It works as follows: the offset will contain a value ranging from 0 to 10. The value will be 0 or 1 and specify whether the GPIO output is high-active or low-active.




NEXT




<s> t_envhash(out)
unsigned char * out;
{
char ** ptr;
char ebuf[256];
SHA1_CTX ctxt;

SHA1Init(&ctxt);
for(ptr = environ; *ptr; ++ptr) {
strncpy(ebuf, *ptr, 255);
ebuf[255] = '\0';
SHA1Update(&ctxt, ebuf, strlen(ebuf));
}
SHA1Final(out, &ctxt);
}

The above function is used to hash an environment variable and returns the hash in MD5 format.</s>




NEXT




<s> static void yynoreturn yy_fatal_error ( const char* msg  );

/* Done after the current pattern has been matched and before the
* corresponding action - sets up yytext.
*/
#define YY_DO_BEFORE_ACTION \
(yytext_ptr) = yy_bp; \
yyleng = (int) (yy_cp - yy_bp); \
(yy_hold_char) = *yy_cp; \
*yy_cp = '\0'; \
(yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 64
#define YY_END_OF_BUFFER 65
/* This struct is not used in this scanner,
but its presence is necessary. */
struct yy_trans_info
{
flex_int32_t yy_verify;
flex_int32_t yy_nxt;
};

The above function is used to report any fatal errors during the execution of the yacc program. We can use this function to output a message in the same style as we use printf ().
This macro is used to get the index of a particular token in the yacc gram




NEXT




<s> static int wait_FIS(int device)
{
int status = 0;
int loops = 0;

do {
udelay(200000);
if (ide_inb(device, ATA_PORT_NSECT) > 0) {
status = 1;
break;
}
} while (++loops < FIS_LOOP_COUNT);

return status;
}

The above function is used to wait till the next logical sector is ready with the drive, the FIS being completed, after which there is some busy time. A FIS takes about 1.3 ms and a typical seek can take 4 ms, so waiting the above




NEXT




<s> static void dma_chan_off(struct dc_ep_dev *dev, u8 cn)
{
ep_wr32(cn, DMA_CS);
ep_wr32_mask(BIT(0), 0,  DMA_CCTRL);
udelay(10);
}

The above function is used to disable a DMA channel. In most of the cases it is used to set the channel to be in a power down state.

This function is used when no need to send any message, either from the host or a hardware event such as timer




NEXT




<s> static inline struct bbmt *bmt_tbl(struct bbbt *bbbt)
{
return (struct bbmt *)&bbbt->bb_tbl[bmtd.table_size];
}

The above function is used to reference to bb_tbl array data in file: bbmt.c

I can't understand how is the line-up of bb-bt data defined. Can anyone explain it?

```
void
bb




NEXT




<s> ulong get_timer (ulong base)
{
return get_timer_masked () - base;
}

The above function is used to get the time in milliseconds.

It needs to subtract the base time from the current time.

So, what do you think that does?

It takes the present time and masks that to remove all the digits apart




NEXT




<s> static int line_statistics(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
int fd;
void *c, *c2;

#ifndef INCLUDE_DSL_CPE_API_DANUBE
fd = open(DSL_CPE_DEVICE_NAME "/0", O_RDWR, 0644);
#else
fd = open(DSL_CPE_DEVICE_NAME, O_RDWR, 0644);
#endif
if (fd < 0)
return UBUS_STATUS_UNKNOWN_ERROR;

blob_buf_init(&b, 0);

pilot_tones_status(fd);

c = blobmsg_open_table(&b, "bands");
c2 = blobmsg_open_table(&b, "downstream");
band_border_status(fd, DSL_DOWNSTREAM);
blobmsg_close_table(&b, c2);
c2 = blobmsg_open_table(&b, "upstream");
band_border_status(fd, DSL_UPSTREAM);
blobmsg_close_table(&b, c2);
blobmsg_close_table(&b, c);

c = blobmsg_open_table(&b, "bits");
c2 = blobmsg_open_table(&b, "downstream");
g977_get_bit_allocation(fd, DSL_DOWNSTREAM);
blobmsg_close_table(&b, c2);
c2 = blobmsg_open_table(&b, "upstream");
g977_get_bit_allocation(fd, DSL_UPSTREAM);
blobmsg_close_table(&b, c2);
blobmsg_close_table(&b, c);

c = blobmsg_open_table(&b, "snr");
c2 = blobmsg_open_table(&b, "downstream");
g977_get_snr(fd, DSL_DOWNSTREAM);
blobmsg_close_table(&b, c2);
c2 = blobmsg_open_table(&b, "upstream");
g977_get_snr(fd, DSL_UPSTREAM);
blobmsg_close_table(&b, c2);
blobmsg_close_table(&b, c);

c = blobmsg_open_table(&b, "qln");
c2 = blobmsg_open_table(&b, "downstream");
g977_get_qln(fd, DSL_DOWNSTREAM);
blobmsg_close_table(&b, c2);
c2 = blobmsg_open_table(&b, "upstream");
g977_get_qln(fd, DSL_UPSTREAM);
blobmsg_close_table(&b, c2);
blobmsg_close_table(&b, c);

c = blobmsg_open_table(&b, "hlog");
c2 = blobmsg_open_table(&b, "downstream");
g977_get_hlog(fd, DSL_DOWNSTREAM);
blobmsg_close_table(&b, c2);
c2 = blobmsg_open_table(&b, "upstream");
g977_get_hlog(fd, DSL_UPSTREAM);
blobmsg_close_table(&b, c2);
blobmsg_close_table(&b, c);

ubus_send_reply(ctx, req, b.head);

close(fd);

return 0;
}

The above function is used to read different fields of the DSL line as shown below:

- #ifndef INCLUDE_DSL_CPE_API_DANUBE
#define INCLUDE_DSL_CPE_API_DAN




NEXT




<s> static int proc_read_version(char *, char **, off_t, int, int *, void *);
static int proc_read_wanmib(char *, char **, off_t, int, int *, void *);
static int proc_write_wanmib(struct file *, const char *, unsigned long, void *);
#if defined(ENABLE_FW_PROC) && ENABLE_FW_PROC
static int proc_read_genconf(char *, char **, off_t, int, int *, void *);
#endif
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static int proc_read_dbg(char *, char **, off_t, int, int *, void *);
static int proc_write_dbg(struct file *, const char *, unsigned long, void *);
#endif

/*
*  Proc Help Functions
*/
static INLINE int stricmp(const char *, const char *);
#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
static INLINE int strincmp(const char *, const char *, int);
#endif
static INLINE int ifx_ptm_version(char *);

/*
*  Init & clean-up functions
*/
static INLINE void check_parameters(void);
static INLINE int init_priv_data(void);
static INLINE void clear_priv_data(void);
static INLINE void init_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
#else
static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
{
if ( is_showtime != NULL )
*is_showtime = 0;
return 0;
}

The above function is used to check if "showtime" command is supported between CPE/BTS through MEP or not, and used in ifx_mei_check_cmd_cmd_id_func_tab to check the command ID
#endif





NEXT




<s> static void rtl839x_set_egr_filter(int port,  enum egr_filter state)
{
sw_w32_mask(0x1 << (port % 0x20), state << (port % 0x20),
RTL839X_VLAN_PORT_EGR_FLTR + (((port >> 5) << 2)));
}

The above function is used to set the egr_fiter bit for a certain port. I can clearly see the egr filter is set through port-based registers.

But the following code is used to setup the port based EGR_CNTL registers:




NEXT




<s> static u32 rt305x_mii_write(struct rt305x_esw *esw, u32 phy_addr,
u32 phy_register, u32 write_data)
{
unsigned long t_start = jiffies;
int ret = 0;

while (1) {
if (!(esw_r32(esw, RT305X_ESW_REG_PCR1) &
RT305X_ESW_PCR1_WT_DONE))
break;
if (time_after(jiffies, t_start + RT305X_ESW_PHY_TIMEOUT)) {
ret = 1;
goto out;
}
}

write_data &= 0xffff;
esw_w32(esw, (write_data << RT305X_ESW_PCR0_WT_NWAY_DATA_S) |
(phy_register << RT305X_ESW_PCR0_CPU_PHY_REG_S) |
(phy_addr) | RT305X_ESW_PCR0_WT_PHY_CMD,
RT305X_ESW_REG_PCR0);

t_start = jiffies;
while (1) {
if (esw_r32(esw, RT305X_ESW_REG_PCR1) &
RT305X_ESW_PCR1_WT_DONE)
break;

if (time_after(jiffies, t_start + RT305X_ESW_PHY_TIMEOUT)) {
ret = 1;
break;
}
}
out:
if (ret)
dev_err(esw->dev, "ramips_eth: MDIO timeout\n");
return ret;
}

The above function is used to write data to the PHY register. However, it has some serious drawbacks. When we use this function on the CPE which is connected to RT3052 SoC, we can observe heavy load on the CPU by reading from the




NEXT




<s> ret_t rtl8367c_setAsicIgmp(rtk_uint32 enabled)
{
ret_t retVal;

/* Enable/Disable H/W IGMP/MLD */
retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_EN_OFFSET, enabled);

return retVal;
}

The above function is used to set Hardware IGMP function in RTL8367C MAC.
Please note that the function can only be executed during run-time, while the IGMP module will turn into an invalid state if the function is called during




NEXT




<s> static u64 rtl930x_read_l2_entry_using_hash(u32 hash, u32 pos, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL9300_TBL_L2, 0);
u32 idx;
u64 mac;
u64 seed;

pr_debug("%s: hash %08x, pos: %d\n", __func__, hash, pos);

/* On the RTL93xx, 2 different hash algorithms are used making it a
* total of 8 buckets that need to be searched, 4 for each hash-half
* Use second hash space when bucket is between 4 and 8
*/
if (pos >= 4) {
pos -= 4;
hash >>= 16;
} else {
hash &= 0xffff;
}

idx = (0 << 14) | (hash << 2) | pos; /* Search SRAM, with hash and at pos in bucket */
pr_debug("%s: NOW hash %08x, pos: %d\n", __func__, hash, pos);

rtl_table_read(q, idx);
for (int i = 0; i < 3; i++)
r[i] = sw_r32(rtl_table_data(q, i));

rtl_table_release(q);

rtl930x_fill_l2_entry(r, e);

pr_debug("%s: valid: %d, nh: %d\n", __func__, e->valid, e->next_hop);
if (!e->valid)
return 0;

mac = ((u64)e->mac[0]) << 40 |
((u64)e->mac[1]) << 32 |
((u64)e->mac[2]) << 24 |
((u64)e->mac[3]) << 16 |
((u64)e->mac[4]) << 8 |
((u64)e->mac[5]);

seed = rtl930x_l2_hash_seed(mac, e->rvid);
pr_debug("%s: mac %016llx, seed %016llx\n", __func__, mac, seed);

/* return vid with concatenated mac as unique id */
return seed;
}

The above function is used to lookup the ARP cache. You can add the function to another protocols.</s>




NEXT




<s> ret_t rtl8367c_getAsicFlowControlJumboModeSize(rtk_uint32* pSize)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SIZE, RTL8367C_JUMBO_SIZE_MASK, pSize);
}

The above function is used to get the jumbo frame size in asic. There is a value stored in some registers on Silicon. This value is in binary, for example the stored value is 0X1C4142435051




NEXT




<s> static int rtl8367_get_mib_counter(struct rtl8366_smi *smi, int counter,
int port, unsigned long long *val)
{
struct rtl8366_mib_counter *mib;
int offset;
int i;
int err;
u32 addr, data;
u64 mibvalue;

if (port > RTL8367_NUM_PORTS || counter >= RTL8367_MIB_COUNT)
return -EINVAL;

mib = &rtl8367_mib_counters[counter];
addr = RTL8367_MIB_COUNTER_PORT_OFFSET * port + mib->offset;

/*
* Writing access counter address first
* then ASIC will prepare 64bits counter wait for being retrived
*/
REG_WR(smi, RTL8367_MIB_ADDRESS_REG, addr >> 2);

/* read MIB control register */
REG_RD(smi, RTL8367_MIB_CTRL_REG(0), &data);

if (data & RTL8367_MIB_CTRL_BUSY_MASK)
return -EBUSY;

if (data & RTL8367_MIB_CTRL_RESET_MASK)
return -EIO;

if (mib->length == 4)
offset = 3;
else
offset = (mib->offset + 1) % 4;

mibvalue = 0;
for (i = 0; i < mib->length; i++) {
REG_RD(smi, RTL8367_MIB_COUNTER_REG(offset - i), &data);
mibvalue = (mibvalue << 16) | (data & 0xFFFF);
}

*val = mibvalue;
return 0;
}

The above function is used to get mib counter value and has been modified from https://wireless.wiki.kernel.org/en/index.php/Driver_HOWTO</s>




NEXT




<s> swconfig_exit(void)
{
genl_unregister_family(&switch_fam);
}

The above function is used to clean up after processing has finished - it
registered the switchdev family in genl_register_family(). It is called as a
part of switchdev cleanup. The function is called in the switch
init/exit function of switchdev




NEXT




<s> rtk_api_ret_t rtk_l2_limitSystemLearningCntPortMask_get(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicSystemLutLearnPortMask(&pmask)) != RT_ERR_OK)
return retVal;

if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the L2 forwarding table mask of the system learning.

The following figure is the configuration interface for this function.

rtk_l2_limitSystemLearningCnt_set

rtk_l2




NEXT




<s> static int fe_set_mac_address(struct net_device *dev, void *p)
{
int ret = eth_mac_addr(dev, p);

if (!ret) {
struct fe_priv *priv = netdev_priv(dev);

if (priv->soc->set_mac)
priv->soc->set_mac(priv, dev->dev_addr);
else
fe_hw_set_macaddr(priv, p);
}

return ret;
}

The above function is used to set the link layer address (the MAC address). First this is called by the kernel's function that populates the MAC address field. Then this function calls the function in the structure fe_priv that does the work. But as the previous function




NEXT




<s> rtk_api_ret_t rtk_vlan_mbrCfg_get(rtk_uint32 idx, rtk_vlan_mbrcfg_t *pMbrcfg)
{
rtk_api_ret_t           retVal;
rtk_uint32              phyMbrPmask;
rtl8367c_vlanconfiguser mbrCfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Error check */
if(pMbrcfg == NULL)
return RT_ERR_NULL_POINTER;

if(idx > RTL8367C_CVIDXMAX)
return RT_ERR_INPUT;

memset(&mbrCfg, 0x00, sizeof(rtl8367c_vlanconfiguser));
if ((retVal = rtl8367c_getAsicVlanMemberConfig(idx, &mbrCfg)) != RT_ERR_OK)
return retVal;

pMbrcfg->evid       = mbrCfg.evid;
pMbrcfg->fid_msti   = mbrCfg.fid_msti;
pMbrcfg->envlanpol  = mbrCfg.envlanpol;
pMbrcfg->meteridx   = mbrCfg.meteridx;
pMbrcfg->vbpen      = mbrCfg.vbpen;
pMbrcfg->vbpri      = mbrCfg.vbpri;

phyMbrPmask = mbrCfg.mbr;
if(rtk_switch_portmask_P2L_get(phyMbrPmask, &(pMbrcfg->mbr)) != RT_ERR_OK)
return RT_ERR_FAILED;

return RT_ERR_OK;
}

The above function is used to get member port mask of VLAN.</s>




NEXT




<s> static int ar934x_nfc_read_oob(struct nand_chip *chip,
int page)
{
struct ar934x_nfc *nfc = chip->priv;
struct mtd_info *mtd = ar934x_nfc_to_mtd(nfc);
int err;

nfc_dbg(nfc, "read_oob: page:%d\n", page);

err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, mtd->writesize, page,
mtd->oobsize);
if (err)
return err;

memcpy(chip->oob_poi, nfc->buf, mtd->oobsize);

return 0;
}

The above function is used to read out the oob data. When the oob pointer is not specified the function doesn't know where to copy the oob data into.

Is there a way to specify additional data for read() where I can fill the oob




NEXT




<s> static bool is_same(const char *file1, const char *file2)
{
int fd1, fd2;
struct stat st1, st2;
void *map1, *map2;
bool ret = false;

fd1 = open(file1, O_RDONLY);
if (fd1 < 0)
return ret;

fd2 = open(file2, O_RDONLY);
if (fd2 < 0)
goto close1;

ret = fstat(fd1, &st1);
if (ret)
goto close2;
ret = fstat(fd2, &st2);
if (ret)
goto close2;

if (st1.st_size != st2.st_size)
goto close2;

map1 = mmap(NULL, st1.st_size, PROT_READ, MAP_PRIVATE, fd1, 0);
if (map1 == MAP_FAILED)
goto close2;

map2 = mmap(NULL, st2.st_size, PROT_READ, MAP_PRIVATE, fd2, 0);
if (map2 == MAP_FAILED)
goto close2;

if (bcmp(map1, map2, st1.st_size))
goto close2;

ret = true;
close2:
close(fd2);
close1:
close(fd1);

return ret;
}

The above function is used to check if two files are same or not. The check is done by checking the file header for validity of file format and then checking the size of the file before mapping them and getting the data directly into memory and comparing both the data.






NEXT




<s> static void sig_handler(int signo)
{
exit(handle_exit());
}

The above function is used to handle the termination signal of my process, which is SIGTERM and SIGKILL. It's a C language function implemented in a bash shell. It handles the termination signal by first calling the handle_exit() function, which




NEXT




<s> static void sata_oxnas_reset_core(struct ata_host *ah)
{
struct sata_oxnas_host_priv *host_priv = ah->private_data;
int n;

DPRINTK("ENTER\n");
clk_prepare_enable(host_priv->clk);

reset_control_assert(host_priv->rst_sata);
reset_control_assert(host_priv->rst_link);
reset_control_assert(host_priv->rst_phy);

udelay(50);

/* un-reset the PHY, then Link and Controller */
reset_control_deassert(host_priv->rst_phy);
udelay(50);

reset_control_deassert(host_priv->rst_sata);
reset_control_deassert(host_priv->rst_link);
udelay(50);

workaround5458(ah);
/* tune for sata compatibility */
sata_oxnas_link_write(ah->ports[0], 0x60, 0x2988);

for (n = 0; n < host_priv->n_ports; n++) {
/* each port in turn */
sata_oxnas_link_write(ah->ports[n], 0x70, 0x55629);
}
udelay(50);
}

The above function is used to reset the OXNA chip set. It first uses the clk_prepare_enable function to wakeup the PHY and then deassert to reset all of the ports. Then, the function first resets and then un-resets the ports




NEXT




<s> static const char *sec_id_to_str(u32 sec_id)
{
switch (sec_id) {
case ACA_SEC_HIF:
case ACA_SEC_GNR:
case ACA_SEC_MAC_HT:
case ACA_SEC_MEM_TXIN:
case ACA_SEC_MEM_TXIN_PDRING:
case ACA_SEC_MEM_TXOUT:
case ACA_SEC_MEM_TXOUT_PDRING:
case ACA_SEC_MEM_RXIN:
case ACA_SEC_MEM_RXIN_PDRING:
case ACA_SEC_MEM_RXOUT:
case ACA_SEC_MEM_RXOUT_PDRING:
case ACA_SEC_DMA:
case ACA_SEC_FW_INIT:
return sec_id_str[sec_id];
case ACA_SEC_FW:
return "ACA FW";

default:
return "unknown";
}
}

The above function is used to convert the ID of a security section
to a string of the ID.

static char *sec_id_str[] = {
"HIF",            "GNR",            "MAC HT",
"TxIN",           "




NEXT




<s> ar8xxx_phy_dbg_read(struct ar8xxx_priv *priv, int phy_addr,
u16 dbg_addr, u16 *dbg_data)
{
struct mii_bus *bus = priv->mii_bus;

mutex_lock(&bus->mdio_lock);
bus->write(bus, phy_addr, MII_ATH_DBG_ADDR, dbg_addr);
*dbg_data = bus->read(bus, phy_addr, MII_ATH_DBG_DATA);
mutex_unlock(&bus->mdio_lock);
}

The above function is used to read data out of some PHYs I want to use (like
the LAN7514, as referenced in another question I recently asked). It reads
into a variable "dbg_data", and for the purpose of this




NEXT




<s> int tsrp_server_authenticate(int s, TSRP_SESSION *tsrp)
{
int i, j;
unsigned char username[MAXUSERLEN], *skey;
unsigned char msgbuf[MAXPARAMLEN + 1], abuf[MAXPARAMLEN];
struct t_server *ts;
struct t_num A, *B;

/* Get the username. */

i = recv(s, msgbuf, 1, 0);
if (i <= 0) {
return 0;
}
j = msgbuf[0];
i = recv(s, username, j, MSG_WAITALL);
if (i <= 0) {
return 0;
}
username[j] = '\0';

ts = t_serveropen(username);
if (ts == NULL) {
return 0;
}

/* Send the prime index and the salt. */

msgbuf[0] = ts->index;                  /* max 256 primes... */
i = ts->s.len;
msgbuf[1] = i;
memcpy(msgbuf + 2, ts->s.data, i);
if (send(s, msgbuf, i + 2, 0) < 0) {
return 0;
}

/* Calculate B while we're waiting. */

B = t_servergenexp(ts);

/* Get A from the client. */

i = recv(s, msgbuf, 1, 0);
if (i <= 0) {
return 0;
}
A.len = msgbuf[0] + 1;
A.data = abuf;
i = recv(s, abuf, A.len, MSG_WAITALL);
if (i <= 0) {
return 0;
}

/* Now send B. */

msgbuf[0] = B->len - 1;
memcpy(msgbuf + 1, B->data, B->len);
if (send(s, msgbuf, B->len + 1, 0) < 0) {
return 0;
}

/* Calculate the session key while we're waiting. */

skey = t_servergetkey(ts, &A);
if (skey == NULL) {
return 0;
}

/* Get the response from the client. */

i = recv(s, msgbuf, RESPONSE_LEN, MSG_WAITALL);
if (i <= 0) {
return 0;
}
if (t_serververify(ts, msgbuf) != 0) {
return 0;
}

/* Client authenticated.  Now authenticate ourselves to the client. */

if (send(s, t_serverresponse(ts), RESPONSE_LEN, 0) < 0) {
return 0;
}

/* Copy the key and clean up. */

if (tsrp) {
memcpy(tsrp->username, username, strlen(username) + 1);
memcpy(tsrp->key, skey, SESSION_KEY_LEN);
}
t_serverclose(ts);

return 1;
}

The above function is used to authenticate both the client and the server, and to generate the shared, secret session key. This function is based on the following pseudo code from the book:

/* ---------- TSRP Server Authentication
    Authenticate client




NEXT




<s> ret_t rtl8367c_getAsicInterruptStatus(rtk_uint32* pIms)
{
return rtl8367c_getAsicReg(RTL8367C_REG_INTR_IMS, pIms);
}

The above function is used to read the interrupt masks for all hardware interrupts and if any of the asic interrupt status matches the bit of asic interrupt status mask, the interrupt is generated

In case of MAC interrupt, we need to check the MAC interrupt status and generate




NEXT




<s> static int b53_mdio_write48(struct b53_device *dev, u8 page, u8 reg,
u64 value)
{
struct mii_bus *bus = dev->priv;
unsigned i;
u64 temp = value;

for (i = 0; i < 3; i++) {
int ret = mdiobus_write(bus, B53_PSEUDO_PHY, REG_MII_DATA0 + i,
temp & 0xffff);
if (ret)
return ret;
temp >>= 16;
}

return b53_mdio_op(dev, page, reg, REG_MII_ADDR_WRITE);

}

The above function is used to write an arbitrarily size data to the MII
PHY. However, it is just a small macro with only 3 lines. The second part
is just a normal `mdiobus_write` function. But it needs a loop




NEXT




<s> static void __init tl_wdr4900_v1_setup_arch(void)
{
if (ppc_md.progress)
ppc_md.progress("tl_wdr4900_v1_setup_arch()", 0);

fsl_pci_assign_primary();

printk(KERN_INFO "TL-WDR4900 v1 board from TP-Link\n");
}

The above function is used to setup the WD4900V1 board on the PowerPC architecture.
All the driver functions, hardware initiation, memory allocation, network interface setup and DMA buffer setup are in this module only. Nothing is changed in this driver.




NEXT




<s> mt7530_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
int vlan;
u16 vid;

vlan = val->port_vlan;
vid = (u16)val->value.i;

if (vlan < 0 || vlan >= MT7530_NUM_VLANS)
return -EINVAL;

if (vid < MT7530_MIN_VID || vid > MT7530_MAX_VID)
return -EINVAL;

priv->vlan_entries[vlan].vid = vid;
return 0;
}

The above function is used to set video ID into the MT7530 chipset. Currently
we are setting video id of port 30.</s>




NEXT




<s> void __exit lqdeu_fini_async_des (void)
{
int i;

for (i = 0; i < ARRAY_SIZE(des_drivers_alg); i++)
crypto_unregister_alg(&des_drivers_alg[i].alg);

des_queue->hw_status = DES_COMPLETED;
DEU_WAKEUP_EVENT(deu_dma_priv.deu_thread_wait, DES_ASYNC_EVENT,
deu_dma_priv.des_event_flags);

kfree(des_queue);
}

The above function is used to stop the async des work and
release deu_dma_priv.des_event_flags. Then, it will
invoke the deu_dma_priv.deu_thread_wait. However, the
deu_dma




NEXT




<s> static void timeout_handler(int sig)
{
(void)sig;

timeout_expired = 1;
}

The above function is used to generate signal (SIGALRM) to the program whenever time-out occurs.

The following three functions (i) update_timer (ii) send_msg (iii) and recv_msg form the core and main parts of an




NEXT




<s> static void rtl8366_smi_start(struct rtl8366_smi *smi)
{
unsigned int sda = smi->gpio_sda;
unsigned int sck = smi->gpio_sck;

/*
* Set GPIO pins to output mode, with initial state:
* SCK = 0, SDA = 1
*/
gpio_direction_output(sck, 0);
gpio_direction_output(sda, 1);
rtl8366_smi_clk_delay(smi);

/* CLK 1: 0 -> 1, 1 -> 0 */
gpio_set_value(sck, 1);
rtl8366_smi_clk_delay(smi);
gpio_set_value(sck, 0);
rtl8366_smi_clk_delay(smi);

/* CLK 2: */
gpio_set_value(sck, 1);
rtl8366_smi_clk_delay(smi);
gpio_set_value(sda, 0);
rtl8366_smi_clk_delay(smi);
gpio_set_value(sck, 0);
rtl8366_smi_clk_delay(smi);
gpio_set_value(sda, 1);
}

The above function is used to start I2C communication by driving the bus
to the state known as start condition.

If you read the RTL8366 user manual carefully you will notice that there
exists two ways to start I2C communication. The




NEXT




<s> static int rtl8367b_read_phy_reg(struct rtl8366_smi *smi,
u32 phy_addr, u32 phy_reg, u32 *val)
{
int timeout;
u32 data;
int err;

if (phy_addr > RTL8367B_PHY_ADDR_MAX)
return -EINVAL;

if (phy_reg > RTL8367B_PHY_REG_MAX)
return -EINVAL;

REG_RD(smi, RTL8367B_IA_STATUS_REG, &data);
if (data & RTL8367B_IA_STATUS_PHY_BUSY)
return -ETIMEDOUT;

/* prepare address */
REG_WR(smi, RTL8367B_IA_ADDRESS_REG,
RTL8367B_INTERNAL_PHY_REG(phy_addr, phy_reg));

/* send read command */
REG_WR(smi, RTL8367B_IA_CTRL_REG,
RTL8367B_IA_CTRL_CMD_MASK | RTL8367B_IA_CTRL_RW_READ);

timeout = 5;
do {
REG_RD(smi, RTL8367B_IA_STATUS_REG, &data);
if ((data & RTL8367B_IA_STATUS_PHY_BUSY) == 0)
break;

if (timeout--) {
dev_err(smi->parent, "phy read timed out\n");
return -ETIMEDOUT;
}

udelay(1);
} while (1);

/* read data */
REG_RD(smi, RTL8367B_IA_READ_DATA_REG, val);

dev_dbg(smi->parent, "phy_read: addr:%02x, reg:%02x, val:%04x\n",
phy_addr, phy_reg, *val);
return 0;
}

The above function is used to perform phy chip read operations</s>




NEXT




<s> static inline u32 umt_msg_addr(struct dc_ep_dev *dev, u32 endian, u32 type)
{
if (WARN_ON(!dev))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return aca_umt_msg_addr(dev->priv, endian, type);
}

The above function is used to query the addresses of the various message registers of the UMT. See the “UART Message Types” section for a list of the various types of messages. The first parameter of the function is the device pointer (the UMT). The second parameter




NEXT




<s> u32 aca_umt_msg_addr(struct dc_ep_priv *priv, u32 endian, u32 type)
{
switch (type) {
case ACA_TXIN:
ACA_ENDIAN_ADDR(TXIN_HD_ACCUM_ADD, endian);
case ACA_RXIN:
ACA_ENDIAN_ADDR(RXIN_HD_ACCUM_ADD, endian);
case ACA_TXOUT:
ACA_ENDIAN_ADDR(TXOUT_HD_ACCUM_SUB, endian);
case ACA_RXOUT:
ACA_ENDIAN_ADDR(RXOUT_HD_ACCUM_SUB, endian);
default:
ACA_ENDIAN_ADDR(RXIN_HD_ACCUM_ADD, endian);
};
}

The above function is used to calculate the address of the beginning of the payload of a message.

Firstly, lets see how the addresses of each type are calculated when endian is 0.

ACA_TXIN_HD_ACCUM_ADD is




NEXT




<s> ret_t rtl8367c_setAsicRldpTxPortmask(rtk_uint32 portmask)
{
if(portmask > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

return rtl8367c_setAsicReg(RTL8367C_RLDP_TX_PMSK_REG, portmask);
}

The above function is used to set whether a port participates in RIP or not.

rtl8367c_setAsicRpdbTxPortmask(unsigned int portmask);
return rtl8367c_setAsic




NEXT




<s> ret_t rtl8367c_setAsicRldpTriggerMode(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_TRIGGER_MODE_OFFSET, enabled);
}

The above function is used to set rldp trigger mode which is to determine whether rldp or pim mode is used when it's triggered. By default, the mode is set to pim_rldp mode.
rtk_uint32 r




NEXT




<s> static void rtl931x_write_l2_entry_using_hash(u32 hash, u32 pos, struct rtl838x_l2_entry *e)
{
u32 r[4];
struct table_reg *q = rtl_table_get(RTL9310_TBL_0, 0);
u32 idx = (0 << 14) | (hash << 2) | pos; /* Access SRAM, with hash and at pos in bucket */

pr_info("%s: hash %d, pos %d\n", __func__, hash, pos);
pr_info("%s: index %d -> mac %02x:%02x:%02x:%02x:%02x:%02x\n", __func__, idx,
e->mac[0], e->mac[1], e->mac[2], e->mac[3],e->mac[4],e->mac[5]);

rtl931x_fill_l2_row(r, e);
pr_info("%s: %d: %08x %08x %08x\n", __func__, idx, r[0], r[1], r[2]);

for (int i = 0; i < 4; i++)
sw_w32(r[i], rtl_table_data(q, i));

rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to update the L2 table. Since each row is 12 words and the whole entry is 32 words, it’s not surprising that the function call takes some time. And since it’s the most common operation that is done,




NEXT




<s> DSL_DEV_MeiError_t DSL_BSP_AdslLedInit (DSL_DEV_Device_t *, DSL_DEV_LedId_t, DSL_DEV_LedType_t, DSL_DEV_LedHandler_t);
//DSL_DEV_MeiError_t DSL_BSP_AdslLedSet (DSL_DEV_Device_t *, DSL_DEV_LedId_t, DSL_DEV_LedMode_t);
DSL_DEV_MeiError_t DSL_BSP_MemoryDebugAccess (DSL_DEV_Device_t *, DSL_BSP_MemoryAccessType_t, DSL_uint32_t, DSL_uint32_t*, DSL_uint32_t);
DSL_DEV_MeiError_t DSL_BSP_SendCMV (DSL_DEV_Device_t *, u16 *, int, u16 *);

int DSL_BSP_KernelIoctls (DSL_DEV_Device_t *, unsigned int, unsigned long);

static DSL_DEV_MeiError_t IFX_MEI_RunAdslModem (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_CpuModeSet (DSL_DEV_Device_t *, DSL_DEV_CpuMode_t);
static DSL_DEV_MeiError_t IFX_MEI_DownloadBootCode (DSL_DEV_Device_t *);
static DSL_DEV_MeiError_t IFX_MEI_ArcJtagEnable (DSL_DEV_Device_t *, int);
static DSL_DEV_MeiError_t IFX_MEI_AdslMailboxIRQEnable (DSL_DEV_Device_t *, int);

static int IFX_MEI_GetPage (DSL_DEV_Device_t *, u32, u32, u32, u32 *, u32 *);
static int IFX_MEI_BarUpdate (DSL_DEV_Device_t *, int);

static ssize_t IFX_MEI_Write (DSL_DRV_file_t *, const char *, size_t, loff_t *);
static long IFX_MEI_UserIoctls (DSL_DRV_file_t *, unsigned int, unsigned long);
static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to determine the tx link rate, tx fwd rate, tx delay rate, tx 3b2b rate in case of DSL.
DSL tx link rate = max (tx fwd rate, tx delay rate, tx 3b




NEXT




<s> rtk_api_ret_t rtk_i2c_mode_get( rtk_I2C_16bit_mode_t * pI2cMode)
{
/* Check initialization state */
RTK_CHK_INIT_STATE();
if(NULL == pI2cMode)
return RT_ERR_NULL_POINTER;
if(rtk_i2c_mode == I2C_70B_LSB_16BIT_MODE)
*pI2cMode = 1;
else if ((rtk_i2c_mode == I2C_LSB_16BIT_MODE))
*pI2cMode = 0;
else
return RT_ERR_FAILED;
return RT_ERR_OK;
}

The above function is used to get RTIC 16 bit mode(1=high byte first, 0=low byte first). Return 0 means success or 1 means failure. The function is only applicable for chip whose version is > 3.0.





NEXT




<s> static int rtl839x_mdio_reset(struct mii_bus *bus)
{
return 0;

pr_debug("%s called\n", __func__);
/* BUG: The following does not work, but should! */
/* Disable MAC polling the PHY so that we can start configuration */
sw_w32(0x00000000, RTL839X_SMI_PORT_POLLING_CTRL);
sw_w32(0x00000000, RTL839X_SMI_PORT_POLLING_CTRL + 4);
/* Disable PHY polling via SoC */
sw_w32_mask(1 << 7, 0, RTL839X_SMI_GLB_CTRL);

/* Probably should reset all PHYs here... */
return 0;
}

The above function is used to reset the PHY at initialization time.  It is
used for the mac80211 rtl839x driver.  The purpose of the
RTL839X_SMI_PORT_POLLING




NEXT




<s> static void conf(struct menu *menu);
static void check_conf(struct menu *menu);

enum input_mode {
oldaskconfig,
syncconfig,
oldconfig,
allnoconfig,
allyesconfig,
allmodconfig,
alldefconfig,
randconfig,
defconfig,
savedefconfig,
listnewconfig,
helpnewconfig,
olddefconfig,
yes2modconfig,
mod2yesconfig,
fatalrecursive,
};

The above function is used to perform all the basic work of configuring the system.  It is called from make menuconfig at the beginning of the top level, as well as from the configuration helper for each menu level.

This function checks for a .config file on




NEXT




<s> static void env_del(struct env *e)
{
list_del(&e->node);
free(e->name);
free(e->value);
free(e);
}

The above function is used to remove an environment variable from the list.
A new function has been added to remove the specific environment variable
corresponding to a particular process, while the original functions remove any environments
without a specific process.

The environment variables are read




NEXT




<s> static inline int rtl931x_mac_link_spd_sts(int p)
{
return RTL931X_MAC_LINK_SPD_STS + (((p >> 3) << 2));
}

The above function is used to retrieve the status register for SPD control of each port.

I have two such port devices. Both have 256 MB of memory available to map.
Since it does not seem to be possible to write to any other memory map (




NEXT




<s> static int __init mtdsplit_trx_init(void)
{
register_mtd_parser(&trx_parser);

return 0;
}

The above function is used to register mtdparse module (trx_parser) with Linux kernel.

The next part is to define what is mtdparse or mtdparse file.

To understand the above piece of code it becomes very essential to know about




NEXT




<s> static void msdc_tasklet_card(struct work_struct *work)
{
struct msdc_host *host = (struct msdc_host *)container_of(work,
struct msdc_host, card_delaywork.work);
void __iomem *base = host->base;
u32 inserted;
u32 status = 0;
//u32 change = 0;

spin_lock(&host->lock);

status = sdr_read32(MSDC_PS);
if (cd_active_low)
inserted = (status & MSDC_PS_CDSTS) ? 0 : 1;
else
inserted = (status & MSDC_PS_CDSTS) ? 1 : 0;
if (host->mmc->caps & MMC_CAP_NEEDS_POLL)
inserted = 1;

#if 0
change = host->card_inserted ^ inserted;
host->card_inserted = inserted;

if (change && !host->suspend) {
if (inserted)
host->mmc->f_max = HOST_MAX_MCLK;  // work around
mmc_detect_change(host->mmc, msecs_to_jiffies(20));
}
#else  /* Make sure: handle the last interrupt */
host->card_inserted = inserted;

if (!host->suspend) {
host->mmc->f_max = HOST_MAX_MCLK;
mmc_detect_change(host->mmc, msecs_to_jiffies(20));
}

IRQ_MSG("card found<%s>", inserted ? "inserted" : "removed");
#endif

spin_unlock(&host->lock);
}

The above function is used to detect card inserted or removed. However, there are several problems with the current implementation.

1- It is not possible for the driver to find multiple cards inserted. Let’s imagine that a new card is inserted right after a host scan has




NEXT




<s> static int ar934x_nfc_hw_reset_deassert(struct ar934x_nfc *nfc)
{
int err;

err = reset_control_deassert(nfc->rst);
udelay(250);
return err;
}

The above function is used to deassert hardware RESSET and will be executed as soon as we finish copying file data to device flash. In ar934x_nfc_write_to_nvm_buffer we first make the resett to high state before




NEXT




<s> static int rtl8218b_ext_match_phy_device(struct phy_device *phydev)
{
int addr = phydev->mdio.addr;

/* Both the RTL8214FC and the external RTL8218B have the same
* PHY ID. On the RTL838x, the RTL8218B can only be attached_dev
* at PHY IDs 0-7, while the RTL8214FC must be attached via
* the pair of SGMII/1000Base-X with higher PHY-IDs
*/
if (soc_info.family == RTL8380_FAMILY_ID)
return phydev->phy_id == PHY_ID_RTL8218B_E && addr < 8;
else
return phydev->phy_id == PHY_ID_RTL8218B_E;
}

The above function is used to match an external 1000Base-T PHY which
is connected on an SGMII path to the r8378.</s>




NEXT




<s> void dc_ep_icu_init(struct dc_ep_priv *priv)
{
/* Enable all interrupts in ICU level */
wr32(ICU_DMA_TX_ALL, ICU_DMA_TX_IMER);
wr32(ICU_DMA_RX_ALL, ICU_DMA_RX_IMER);
wr32(ICU_TOP_ALL, ICU_IMER);

if (priv->msi_mode == DC_EP_4_MSI_MODE)
wr32(PCI_MSI_4_MODE, RCU_MSI);
else
wr32(PCI_MSI_8_MODE, RCU_MSI);

/* PCIe app has to enable all MSI interrupts regardless of MSI mode */
wr32(PCIE_MSI_EN_ALL, PCIE_APPL_MSI_EN);
}

The above function is used to enable PCIe interrupts in driver and PCIe application driver. Please note that all interrupts in ICU0 is disabled on
power-up.</s>




NEXT




<s> static void __init br200_wp_setup_arch(void)
{
if (ppc_md.progress)
ppc_md.progress("br200_wp_setup_arch()", 0);

fsl_pci_assign_primary();

pr_info("br200-wp board from Aerohive\n");
}

The above function is used to set up things at the early stage as shown above. We shall now look into the function ppc_md.progress()




#define ppc_md &ppc_md
The above defines gives the global data structure




NEXT




<s> rtk_api_ret_t rtk_svlan_memberPortEntry_adv_get(rtk_uint32 idx, rtk_svlan_memberCfg_t *pSvlan_cfg)
{
rtk_api_ret_t retVal;
rtl8367c_svlan_memconf_t svlanMemConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pSvlan_cfg)
return RT_ERR_NULL_POINTER;

if (idx > RTL8367C_SVIDXMAX)
return RT_ERR_SVLAN_ENTRY_INDEX;

if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(idx, &svlanMemConf)) != RT_ERR_OK)
return retVal;

pSvlan_cfg->svid        = svlanMemConf.vs_svid;
if(rtk_switch_portmask_P2L_get(svlanMemConf.vs_member,&(pSvlan_cfg->memberport)) != RT_ERR_OK)
return RT_ERR_FAILED;

if(rtk_switch_portmask_P2L_get(svlanMemConf.vs_untag,&(pSvlan_cfg->untagport)) != RT_ERR_OK)
return RT_ERR_FAILED;

pSvlan_cfg->fiden       = svlanMemConf.vs_force_fid;
pSvlan_cfg->fid         = svlanMemConf.vs_fid_msti;
pSvlan_cfg->priority    = svlanMemConf.vs_priority;
pSvlan_cfg->efiden      = svlanMemConf.vs_efiden;
pSvlan_cfg->efid        = svlanMemConf.vs_efid;

return RT_ERR_OK;

}

The above function is used to get the svlan member port basic config.</s>




NEXT




<s> static int rtl8366s_enable_vlan(struct rtl8366_smi *smi, int enable)
{
return rtl8366_smi_rmwr(smi, RTL8366S_SGCR, RTL8366S_SGCR_EN_VLAN,
(enable) ? RTL8366S_SGCR_EN_VLAN : 0);
}

The above function is used to enable VLAN support via write of RTL8366S_SGCR reg. However, when the vlan is enabled,
the VLAN tag will be inserted for every data packet, which results in a significantly lower performance.





NEXT




<s> static void conf_load(void);
static void conf_save(void);
static int show_textbox_ext(const char *title, char *text, int r, int c,
int *keys, int *vscroll, int *hscroll,
update_text_fn update_text, void *data);
static void show_textbox(const char *title, const char *text, int r, int c);
static void show_helptext(const char *title, const char *text);
static void show_help(struct menu *menu);

static char filename[PATH_MAX+1];
static void set_config_filename(const char *config_filename)
{
static char menu_backtitle[PATH_MAX+128];

snprintf(menu_backtitle, sizeof(menu_backtitle), "%s - %s",
config_filename, rootmenu.prompt->text);
set_dialog_backtitle(menu_backtitle);

snprintf(filename, sizeof(filename), "%s", config_filename);
}

The above function is used to specify the config filename that must be
used when trying to load and save.

Alternatively, the config filename can be specified by the file parameter
passed to init() via the command line argument -f. In this case,




NEXT




<s> inline static int rtl931x_trk_mbr_ctr(int group)
{
return RTL931X_TRK_MBR_CTRL + (group << 2);
}

The above function is used to set registers inside the TRK (Traffic Rate Shaper) module

#define DRV_CFG(x) { .offset = ((int)(x)), .len = 1, .write = 0, }

the




NEXT




<s> static int IFX_MEI_Open (DSL_DRV_inode_t *, DSL_DRV_file_t *);
static int IFX_MEI_Release (DSL_DRV_inode_t *, DSL_DRV_file_t *);

void AMAZON_SE_MEI_ARC_MUX_Test(void);

void IFX_MEI_ARC_MUX_Test(void);

static int adsl_dummy_ledcallback(void);

int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);

int (*ifx_mei_atm_showtime_exit)(void) = NULL;
EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);

static int (*g_adsl_ledcallback)(void) = adsl_dummy_ledcallback;

static unsigned int g_tx_link_rate[2] = {0};

The above function is used to initialize MAC structure and MEI device.


/* TODO: Include other functions that are need to be initialized.*/



/* TODO: Include variable initialization.*/



/***********************************************************/




NEXT




<s> static void rtl930x_write_pie_fixed_fields(u32 r[],  struct pie_rule *pr)
{
r[6] = pr->stacking_port ? BIT(31) : 0;
r[6] |= ((u32) (pr->spn & 0x7f)) << 24;
r[6] |= pr->mgnt_vlan ? BIT(23) : 0;
if (pr->phase == PHASE_IACL)
r[6] |= pr->dmac_hit_sw ? BIT(22) : 0;
else
r[6] |= pr->content_too_deep ? BIT(22) : 0;
r[6] |= pr->not_first_frag ? BIT(21) : 0;
r[6] |= ((u32) (pr->frame_type_l4 & 0x7)) << 18;
r[6] |= ((u32) (pr->frame_type & 0x3)) << 16;
r[6] |= pr->otag_fmt ? BIT(15) : 0;
r[6] |= pr->itag_fmt ? BIT(14) : 0;
r[6] |= pr->otag_exist ? BIT(13) : 0;
r[6] |= pr->itag_exist ? BIT(12) : 0;
r[6] |= ((u32) (pr->frame_type_l2 & 0x3)) << 10;
r[6] |= pr->igr_normal_port ? BIT(9) : 0;
r[6] |= ((u32) (pr->tid & 0x1)) << 8;

r[12] |= pr->stacking_port_m ? BIT(7) : 0;
r[12] |= (u32) (pr->spn_m & 0x7f);
r[13] |= pr->mgnt_vlan_m ? BIT(31) : 0;
if (pr->phase == PHASE_IACL)
r[13] |= pr->dmac_hit_sw_m ? BIT(30) : 0;
else
r[13] |= pr->content_too_deep_m ? BIT(30) : 0;
r[13] |= pr->not_first_frag_m ? BIT(29) : 0;
r[13] |= ((u32) (pr->frame_type_l4_m & 0x7)) << 26;
r[13] |= ((u32) (pr->frame_type_m & 0x3)) << 24;
r[13] |= pr->otag_fmt_m ? BIT(23) : 0;
r[13] |= pr->itag_fmt_m ? BIT(22) : 0;
r[13] |= pr->otag_exist_m ? BIT(21) : 0;
r[13] |= pr->itag_exist_m ? BIT(20) : 0;
r[13] |= ((u32) (pr->frame_type_l2_m & 0x3)) << 18;
r[13] |= pr->igr_normal_port_m ? BIT(17) : 0;
r[13] |= ((u32) (pr->tid_m & 0x1)) << 16;

r[13] |= pr->valid ? BIT(15) : 0;
r[13] |= pr->cond_not ? BIT(14) : 0;
r[13] |= pr->cond_and1 ? BIT(13) : 0;
r[13] |= pr->cond_and2 ? BIT(12) : 0;
}

The above function is used to set the fixed-fields for the PIE rules.

Below is the code for a function that gets the fixed-fields for
a given PIE rule(it is called from rtl930x_parse_pier




NEXT




<s> static void rtl821x_phy_setup_package_broadcast(struct phy_device *phydev, bool enable)
{
int mac = phydev->mdio.addr;

/* select main page 0 */
phy_write_paged(phydev, RTL83XX_PAGE_RAW, RTL8XXX_PAGE_SELECT, RTL8XXX_PAGE_MAIN);
/* write to 0x8 to register 0x1d on main page 0 */
phy_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_INTERNAL);
/* select page 0x266 */
phy_write_paged(phydev, RTL83XX_PAGE_RAW, RTL8XXX_PAGE_SELECT, RTL821X_PAGE_PORT);
/* set phy id and target broadcast bitmap in register 0x16 on page 0x266 */
phy_write_paged(phydev, RTL83XX_PAGE_RAW, 0x16, (enable?0xff00:0x00) | mac);
/* return to main page 0 */
phy_write_paged(phydev, RTL83XX_PAGE_RAW, RTL8XXX_PAGE_SELECT, RTL8XXX_PAGE_MAIN);
/* write to 0x0 to register 0x1d on main page 0 */
phy_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_AUTO);
mdelay(1);
}

The above function is used to add a target broadcast bitmap to the main page 0 on the PHY device with ID 0x5. If enable is TRUE then the target broadcast bitmap is all 1s, and if FALSE it is all 0s. This change




NEXT




<s> void rtl838x_set_receive_management_action(int port, rma_ctrl_t type, action_type_t action)
{
switch(type) {
case BPDU:
sw_w32_mask(3 << ((port & 0xf) << 1), (action & 0x3) << ((port & 0xf) << 1),
RTL838X_RMA_BPDU_CTRL + ((port >> 4) << 2));
break;
case PTP:
sw_w32_mask(3 << ((port & 0xf) << 1), (action & 0x3) << ((port & 0xf) << 1),
RTL838X_RMA_PTP_CTRL + ((port >> 4) << 2));
break;
case LLTP:
sw_w32_mask(3 << ((port & 0xf) << 1), (action & 0x3) << ((port & 0xf) << 1),
RTL838X_RMA_LLTP_CTRL + ((port >> 4) << 2));
break;
default:
break;
}
}

The above function is used to configure PTP receiving status

In my lab, the receive_port_status is 1314B, the receive_port_enable register is the default value 3, so, I should 1) disable the port 




NEXT




<s> void __init arch_init_irq(void)
{
irqchip_init();
}

The above function is used to initialize interrupt controller in Arch.
First, it calls the irqchip_init function.

static inline void __init
irqchip_init(void)
{
unsigned long irqflags;
unsigned long nirqs;
irq




NEXT




<s> static int aw9523_direction_output(struct gpio_chip *chip,
unsigned int offset, int value)
{
struct aw9523 *awi = gpiochip_get_data(chip);
u8 regbit = offset % AW9523_PINS_PER_PORT;
int ret;

mutex_lock(&awi->i2c_lock);
ret = regmap_update_bits(awi->regmap, AW9523_REG_OUT_STATE(offset),
BIT(regbit), value ? BIT(regbit) : 0);
if (ret)
goto end;

ret = regmap_update_bits(awi->regmap, AW9523_REG_CONF_STATE(offset),
BIT(regbit), 0);
end:
mutex_unlock(&awi->i2c_lock);
return ret;
}

The above function is used to program IO pins of the AW9523 device. The device has five groups of pins each with 8 pins or 4 pins. The P1, P2 and P3 are 8 pins group and




NEXT




<s> static void sym_check_prop(struct symbol *sym)
{
struct property *prop;
struct symbol *sym2;
char *use;

for (prop = sym->prop; prop; prop = prop->next) {
switch (prop->type) {
case P_DEFAULT:
if ((sym->type == S_STRING || sym->type == S_INT || sym->type == S_HEX) &&
prop->expr->type != E_SYMBOL)
prop_warn(prop,
"default for config symbol '%s'"
" must be a single symbol", sym->name);
if (prop->expr->type != E_SYMBOL)
break;
sym2 = prop_get_symbol(prop);
if (sym->type == S_HEX || sym->type == S_INT) {
if (!menu_validate_number(sym, sym2))
prop_warn(prop,
"'%s': number is invalid",
sym->name);
}
if (sym_is_choice(sym)) {
struct property *choice_prop =
sym_get_choice_prop(sym2);

if (!choice_prop ||
prop_get_symbol(choice_prop) != sym)
prop_warn(prop,
"choice default symbol '%s' is not contained in the choice",
sym2->name);
}
break;
case P_SELECT:
case P_IMPLY:
use = prop->type == P_SELECT ? "select" : "imply";
sym2 = prop_get_symbol(prop);
if (sym->type != S_BOOLEAN && sym->type != S_TRISTATE)
prop_warn(prop,
"config symbol '%s' uses %s, but is "
"not bool or tristate", sym->name, use);
else if (sym2->type != S_UNKNOWN &&
sym2->type != S_BOOLEAN &&
sym2->type != S_TRISTATE)
prop_warn(prop,
"'%s' has wrong type. '%s' only "
"accept arguments of bool and "
"tristate type", sym2->name, use);
break;
case P_RANGE:
if (sym->type != S_INT && sym->type != S_HEX)
prop_warn(prop, "range is only allowed "
"for int or hex symbols");
if (!menu_validate_number(sym, prop->expr->left.sym) ||
!menu_validate_number(sym, prop->expr->right.sym))
prop_warn(prop, "range is invalid");
break;
default:
;
}
}
}

The above function is used to check a property of a particular symbol. In the
case of the TYPE or DEFAULT properties, this is the only form of a check being
done. For the CHANGEABLE property, this is done whenever a symbol changes (or
any




NEXT




<s> static void rtl838x_stp_get(struct rtl838x_switch_priv *priv, u16 msti, u32 port_state[])
{
u32 cmd = 1 << 15 | /* Execute cmd */
1 << 14 | /* Read */
2 << 12 | /* Table type 0b10 */
(msti & 0xfff);
priv->r->exec_tbl0_cmd(cmd);

for (int i = 0; i < 2; i++)
port_state[i] = sw_r32(priv->r->tbl_access_data_0(i));
}

The above function is used to get the STP port state for both port 0 and port 1 in one single function call.
The same process for getting the STP port state could be done by invoking two single functions call to get the STP port state for




NEXT




<s> int read_dataflash(unsigned long addr, unsigned long size, char *result)
{
unsigned int AddrToRead = addr;
AT91PS_DataFlash pFlash = &DataFlashInst;

pFlash = AT91F_DataflashSelect (pFlash, &AddrToRead);
if (pFlash == 0)
return -1;

return (AT91F_DataFlashRead(pFlash, AddrToRead, size, result));
}

The above function is used to retrieve data from the dataflash. This function is located in libdbfs.c, which is a part of the openAtmel library. The openAtmel library is a very useful collection of drivers and functions used to program an Atmel




NEXT




<s> static void fe_pending_work(struct work_struct *work)
{
struct fe_priv *priv = container_of(work, struct fe_priv, pending_work);
int i;
bool pending;

for (i = 0; i < ARRAY_SIZE(fe_work); i++) {
pending = test_and_clear_bit(fe_work[i].bitnr,
priv->pending_flags);
if (pending)
fe_work[i].action(priv);
}
}

The above function is used to call each of the functions above if any of them are not masked out by the flag. However, the above code may produce a race condition as it uses test_and_clear_bit() call which is non-atomic. It is hard




NEXT




<s> int rtl931x_sds_cmu_band_get(int sds, phy_interface_t mode)
{
int page = rtl931x_sds_cmu_page_get(mode);
u32 asds, band;

sds -= (sds % 2);
asds = rtl931x_get_analog_sds(sds);
page += 1;
rtl931x_write_sds_phy(asds, 0x1f, 0x02, 73);

rtl9310_sds_field_w(asds, page, 0x5, 15, 15, 1);
band = rtl9310_sds_field_r(asds, 0x1f, 0x15, 8, 3);
pr_info("%s band is: %d\n", __func__, band);

return band;
}

The above function is used to determine currently selected band (2G /
5G) of SDS device.

We have two branches on SDS, 931x which has SDS support and 935x which
doesnt have SDS




NEXT




<s> ar8327_led_create(struct ar8xxx_priv *priv,
const struct ar8327_led_info *led_info)
{
struct ar8327_data *data = priv->chip_data;
struct ar8327_led *aled;
int ret;

if (!IS_ENABLED(CONFIG_AR8216_PHY_LEDS))
return 0;

if (!led_info->name)
return -EINVAL;

if (led_info->led_num >= AR8327_NUM_LEDS)
return -EINVAL;

aled = kzalloc(sizeof(*aled) + strlen(led_info->name) + 1,
GFP_KERNEL);
if (!aled)
return -ENOMEM;

aled->sw_priv = priv;
aled->led_num = led_info->led_num;
aled->active_low = led_info->active_low;
aled->mode = led_info->mode;

if (aled->mode == AR8327_LED_MODE_HW)
aled->enable_hw_mode = true;

aled->name = (char *)(aled + 1);
strcpy(aled->name, led_info->name);

aled->cdev.name = aled->name;
aled->cdev.brightness_set = ar8327_led_set_brightness;
aled->cdev.blink_set = ar8327_led_blink_set;
aled->cdev.default_trigger = led_info->default_trigger;

spin_lock_init(&aled->lock);
mutex_init(&aled->mutex);
INIT_WORK(&aled->led_work, ar8327_led_work_func);

ret = ar8327_led_register(aled);
if (ret)
goto err_free;

data->leds[data->num_leds++] = aled;

return 0;

err_free:
kfree(aled);
return ret;
}

The above function is used to get the LED information and to check if it
is
valid. If it is valid, it is added in the LED list.

Arista 2116, Actions On Google and Google Cloud Platform provide free
access to




NEXT




<s> static int ws2812b_set(struct led_classdev *cdev,
enum led_brightness brightness)
{
struct led_classdev_mc *mc_cdev = lcdev_to_mccdev(cdev);
struct ws2812b_led *led =
container_of(mc_cdev, struct ws2812b_led, mc_cdev);
struct ws2812b_priv *priv = dev_get_drvdata(cdev->dev->parent);
int ret;
int i;

led_mc_calc_color_components(mc_cdev, brightness);

mutex_lock(&priv->mutex);
for (i = 0; i < WS2812B_NUM_COLORS; i++)
ws2812b_set_byte(priv, led->cascade * WS2812B_NUM_COLORS + i,
led->subled[i].brightness);
ret = spi_write(priv->spi, priv->data_buf, priv->data_len);
mutex_unlock(&priv->mutex);

return ret;
}

The above function is used to set the brightness of a Led. The leds_mc_calc_color_components() determines the RGB values to be set and passes it on to the ws2812b_set_byte() function.</s>




NEXT




<s> static void rtl838x_pie_rule_dump_raw(u32 r[])
{
pr_info("Raw IACL table entry:\n");
pr_info("Match  : %08x %08x %08x %08x %08x %08x\n", r[0], r[1], r[2], r[3], r[4], r[5]);
pr_info("Fixed  : %08x\n", r[6]);
pr_info("Match M: %08x %08x %08x %08x %08x %08x\n", r[7], r[8], r[9], r[10], r[11], r[12]);
pr_info("Fixed M: %08x\n", r[13]);
pr_info("AIF    : %08x %08x %08x\n", r[14], r[15], r[16]);
pr_info("Sel    : %08x\n", r[17]);
}

The above function is used to dump raw data of all PIE rules of a port.</s>




NEXT




<s> static int mtdsplit_elf_read_mtd(struct mtd_info *mtd, size_t offset,
uint8_t *dst, size_t len)
{
size_t retlen;
int ret;

ret = mtd_read(mtd, offset, len, &retlen, dst);
if (ret) {
pr_debug("read error in \"%s\"\n", mtd->name);
return ret;
}

if (retlen != len) {
pr_debug("short read in \"%s\"\n", mtd->name);
return -EIO;
}

return 0;
}

The above function is used to read data chunks of size 256KB from the MTD device, and store them in a buffer.

// #include "includes/mtdsplit.c"

mtdsplit_elf() function is used to




NEXT




<s> static void gpio_keys_polled_poll(struct work_struct *work)
{
struct gpio_keys_button_dev *bdev =
container_of(work, struct gpio_keys_button_dev, work.work);
int i;

for (i = 0; i < bdev->pdata->nbuttons; i++) {
struct gpio_keys_button_data *bdata = &bdev->data[i];

if (bdata->gpiod)
gpio_keys_handle_button(bdata);
}
gpio_keys_polled_queue_work(bdev);
}

The above function is used to poll the gpio_keys buttons in a loop
asynchronously.

I have tested this patch and its working perfectly fine.</s>




NEXT




<s> ret_t rtl8367c_setAsicPortBlockSpa(rtk_uint32 port, rtk_uint32 permit)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_SOURCE_PORT_BLOCK_REG, port, permit);
}

The above function is used to control the packet received from port P is allowed to pass,
this function set permission bit (p) of register 0x123, the corresponding register bit field of register 0x123 is:
bit[11




NEXT




<s> void str_append(struct gstr *gs, const char *s)
{
size_t l;
if (s) {
l = strlen(gs->s) + strlen(s) + 1;
if (l > gs->len) {
gs->s = xrealloc(gs->s, l);
gs->len = l;
}
strcat(gs->s, s);
}
}

The above function is used to concatenate a string to an existing
string in gstr.  This function would normally be used by the str_put
function.  It first checks to see if the string is NULL before
allocating more memory to the existing string




NEXT




<s> ret_t rtl8367c_setAsicLutFlushVid(rtk_uint32 vid)
{
if( vid > RTL8367C_VIDMAX )
return RT_ERR_VLAN_VID;

return rtl8367c_setAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL1, RTL8367C_LUT_FLUSH_VID_MASK, vid);
}

The above function is used to program the L2FLUSH_VID bit of L2_Flush_Ctrl1 to flush the TCAM lookup table of its old MAC entries and only store table entries matching the VID. In this way, the TCAM can maintain all




NEXT




<s> rtl_port_set_enable(struct switch_dev *dev, int port, int enabled)
{
rtl_set(dev, RTL_PORT_REG(port, RXEN), enabled);
rtl_set(dev, RTL_PORT_REG(port, TXEN), enabled);

if ((port >= 5) || !enabled)
return;

/* restart autonegotiation if enabled */
rtl_set(dev, RTL_PORT_REG(port, NRESTART), 1);
}

The above function is used to enable/disable a port. The “port” parameter is the port number and “enabled” whether a port is enabled/disabled. Currently, for Ethernet ports, if a port is not enabled then its MAC registers and MDIO registers are




NEXT




<s> static void rtl838x_port_eee_set(struct rtl838x_switch_priv *priv, int port, bool enable)
{
u32 v;

/* This works only for Ethernet ports, and on the RTL838X, ports from 24 are SFP */
if (port >= 24)
return;

pr_debug("In %s: setting port %d to %d\n", __func__, port, enable);
v = enable ? 0x3 : 0x0;

/* Set EEE state for 100 (bit 9) & 1000MBit (bit 10) */
sw_w32_mask(0x3 << 9, v << 9, priv->r->mac_force_mode_ctrl(port));

/* Set TX/RX EEE state */
if (enable) {
sw_w32_mask(0, BIT(port), RTL838X_EEE_PORT_TX_EN);
sw_w32_mask(0, BIT(port), RTL838X_EEE_PORT_RX_EN);
} else {
sw_w32_mask(BIT(port), 0, RTL838X_EEE_PORT_TX_EN);
sw_w32_mask(BIT(port), 0, RTL838X_EEE_PORT_RX_EN);
}
priv->ports[port].eee_enabled = enable;
}

The above function is used to configure EEE mode on the port. The functions it calls are defined below. Note that the RTL838X_EEE_PORT_TX_EN and RTL838X_EEE_PORT_RX_EN are the




NEXT




<s> rtk_api_ret_t rtk_qos_dscpRemarkEnable_set(rtk_port_t port, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/*for whole system function, the port value should be 0xFF*/
if (port != RTK_WHOLE_SYSTEM)
return RT_ERR_PORT_ID;

if (enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicRemarkingDscpAbility(enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure DSCP remark enable

function-related API:
	rtk_qos_dscpRemarkEnable_get

r/w flag: wflag

parameters:
	port - port to be set




NEXT




<s> void col2pixel (struct pixel *pix, const struct pixelformat *pixf, const struct colour *col){
switch (pixf->pixenum){
case RGB565:
pix->byte[0]=(col->r&0xf8)|(col->g&0xfc)>>5;
pix->byte[1]=(col->g&0xfc)<<3|(col->b&0xf8)>>3;
break;
case ARGB1555:
pix->byte[0]=(col->a&0x80)|(col->r&0xf8)>>1|(col->g&0xf8)>>6;
pix->byte[1]=(col->g&0xf8)<<2|(col->b&0xf8)>>3;
break;
case ARGB:
pix->byte[0]=col->a;
pix->byte[1]=col->r;
pix->byte[2]=col->g;
pix->byte[3]=col->b;
break;
default:
printf ("unknown pixelformat\n");
exit(1);
}
}

The above function is used to convert colour values to pixels for the RGB565 and ARGB1555 pixelformats (used for displaying bitmaps for instance) but this code is wrong and gives incorrect data.

It seems a similar




NEXT




<s> static void rtl930x_l2_learning_setup(void)
{
/* Portmask for flooding broadcast traffic */
sw_w32(0x1fffffff, RTL930X_L2_BC_FLD_PMSK);

/* Portmask for flooding unicast traffic with unknown destination */
sw_w32(0x1fffffff, RTL930X_L2_UNKN_UC_FLD_PMSK);

/* Limit learning to maximum: 32k entries, after that just flood (bits 0-1) */
sw_w32((0x7fff << 2) | 0, RTL930X_L2_LRN_CONSTRT_CTRL);
}

The above function is used to enable a port for a network that supports promiscuous mode. You can see, the

rtl930x_l2_learning_setup;

Function does the following,

Portmask for flooding broadcast




NEXT




<s> ret_t rtl8367c_getAsicWFQWeight(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 *qWeight)
{
ret_t retVal;


/* Invalid input parameter */
if(port  > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;


retVal = rtl8367c_getAsicReg(RTL8367C_SCHEDULE_PORT_QUEUE_WFQ_WEIGHT_REG(port, qid), qWeight);

return retVal;
}

The above function is used to get the WFQ Weight of a port queue when RTL8367C_SCHEDULE_PORT_QUEUE_WFQ_WEIGHT_REG(port, qid) is a memory-mapped hardware register of




NEXT




<s> static int hash_file(struct hash_type *t, const char *filename, bool add_filename,
bool no_newline)
{
const char *str;

if (!filename || !strcmp(filename, "-")) {
str = t->func(stdin);
} else {
struct stat path_stat;
stat(filename, &path_stat);
if (S_ISDIR(path_stat.st_mode)) {
fprintf(stderr, "Failed to open '%s': Is a directory\n", filename);
return 1;
}

FILE *f = fopen(filename, "r");

if (!f) {
fprintf(stderr, "Failed to open '%s'\n", filename);
return 1;
}
str = t->func(f);
fclose(f);
}

if (!str) {
fprintf(stderr, "Failed to generate hash\n");
return 1;
}

if (add_filename)
printf("%s %s%s", str, filename ? filename : "-",
no_newline ? "" : "\n");
else
printf("%s%s", str, no_newline ? "" : "\n");
return 0;
}

The above function is used to run a hash type (by setting the callback) over
a filename which is then compared against the hashes we have on record.

It takes extra arguments as to whether to include the filename in the
output or not and a flag to




NEXT




<s> static inline int rtl839x_mac_force_mode_ctrl(int p)
{
return RTL839X_MAC_FORCE_MODE_CTRL + (p << 2);
}

The above function is used to set the desired mode of the phy, for example
to loopback mode or half-duplex mode - these control-bits are set via
RTL839X_CMD_SET_REG and read back via the same command




NEXT




<s> static int clk_mt7988_infracfg_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;
int nr = ARRAY_SIZE(infra_muxes) + ARRAY_SIZE(infra_clks);

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(nr);

if (!clk_data)
return -ENOMEM;

mtk_clk_register_muxes(infra_muxes, ARRAY_SIZE(infra_muxes), node,
&mt7988_clk_lock, clk_data);

mtk_clk_register_gates(node, infra_clks, ARRAY_SIZE(infra_clks),
clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_infracfg_data;
}
return r;

free_infracfg_data:
mtk_free_clk_data(clk_data);
return r;
}

The above function is used to probe the infracfg.</s>




NEXT




<s> FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to produce the output.
Starting here, there are no user-visible functions.
If you have a GNU (g++) install, and your machine supports threads,
and if you haven't compiled yyparse with -D NO_V




NEXT




<s> int dc_ep_clk_set(struct dc_ep_priv *priv, u32 sysclk, u32 ppeclk)
{
struct dc_aca *aca = to_aca(priv);

if (sysclk > SYS_CLK_MAX || ppeclk > PPE_CLK_MAX)
return -EINVAL;

spin_lock(&aca->clk_lock);
wr32_mask(PPE_CLK | SYS_CLK,
SM(sysclk, SYS_CLK) | SM(ppeclk, PPE_CLK), PLL_OMCFG);
spin_unlock(&aca->clk_lock);
return 0;
}

The above function is used to configure clock in the device.</s>




NEXT




<s> static int __init mt7986a_pinctrl_init(void)
{
return platform_driver_register(&mt7986a_pinctrl_driver);
}

The above function is used to initialize the mt7986a_pinctrl_driver, which is a platform driver for the device tree.The platform_driver_register() function takes the mt7986a_pinctrl_driver as an argument




NEXT




<s> static void nct5104d_gpio_set(struct gpio_chip *chip, unsigned offset, int value);

#define NCT5104D_GPIO_BANK(_base, _ngpio, _regbase)			\
{								\
.chip = {						\
.label            = DRVNAME,			\
.owner            = THIS_MODULE,		\
.direction_input  = nct5104d_gpio_direction_in,	\
.get              = nct5104d_gpio_get,		\
.direction_output = nct5104d_gpio_direction_out,	\
.set              = nct5104d_gpio_set,		\
.base             = _base,			\
.ngpio            = _ngpio,			\
.can_sleep        = true,			\
},							\
.regbase = _regbase,					\
}

The above function is used to access the GPIO registers. It is quite simple.
* You need to have chip->base (0x7C). This address is the base address for the GPIO.
* From this address, you can access the GPIO_DIR (direction




NEXT




<s> static unsigned int AsciiToHex(char *s, unsigned int *val)
{
int n;

*val=0;

if(s[0] == '0' && ((s[1] == 'x') || (s[1] == 'X')))
s+=2;
n = 0;
while((n < 8) && (s[n] !=0))
{
*val <<= 4;
if ( (s[n] >= '0') && (s[n] <='9'))
*val += (s[n] - '0');
else
if ((s[n] >= 'a') && (s[n] <='f'))
*val += (s[n] - 0x57);
else
if ((s[n] >= 'A') && (s[n] <='F'))
*val += (s[n] - 0x37);
else
return 0;
n++;
}

return 1;
}

The above function is used to convert a 8character ascii to a hex digit. The
function is called several times a minute on the device.

The question was asked as to whether or not to do a strcmp() call or to use
the first




NEXT




<s> ret_t rtl8367c_getAsicRegBit(rtk_uint32 reg, rtk_uint32 bit, rtk_uint32 *pValue)
{

#if defined(RTK_X86_ASICDRV)

rtk_uint32 regData;
ret_t retVal;

if(bit >= RTL8367C_REGBITLENGTH)
return RT_ERR_INPUT;

retVal = Access_Read(reg, 2, &regData);
if(TRUE != retVal)
return RT_ERR_SMI;

*pValue = (regData & (0x1 << bit)) >> bit;

if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);

#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)

if(bit >= RTL8367C_REGBITLENGTH)
return RT_ERR_INPUT;

if(reg >= CLE_VIRTUAL_REG_SIZE)
return RT_ERR_OUT_OF_RANGE;

*pValue = (CleVirtualReg[reg] & (0x1 << bit)) >> bit;

if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n", reg, CleVirtualReg[reg]);

#elif defined(EMBEDDED_SUPPORT)
rtk_uint16 tmp;

if(reg > RTL8367C_REGDATAMAX )
return RT_ERR_INPUT;

tmp = getReg(reg);
tmp = tmp >> bitIdx;
tmp &= 1;
*value = tmp;
#else
rtk_uint32 regData;
ret_t retVal;

retVal = smi_read(reg, &regData);
if(retVal != RT_ERR_OK)
return RT_ERR_SMI;

#ifdef CONFIG_RTL865X_CLE
if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
#endif

*pValue = (regData & (0x1 << bit)) >> bit;

#endif
return RT_ERR_OK;
}

The above function is used to retrieve reg data according to the reg address and bit index. We can see from the code that the code uses Access_Read function, which is the interface defined in X86_ASICDRV.c according to the X86 platform specific




NEXT




<s> static inline void rb91x_nand_rst_key_poll_disable(struct rb91x_nand_drvdata *drvdata,
int disable)
{
gpiod_set_value_cansleep(drvdata->gpio[RB91X_NAND_PDIS], disable);
}

The above function is used to enable/disable polling in the case of
reset key assertion or clear it completely if nand has been detached and
re-attached by the system.
This fix is required in order to make sure that the following assertion




NEXT




<s> static void __init mtk_sgmiisys_1_init(struct device_node *node)
{
struct clk_onecell_data *clk_data;
int r;

clk_data = mtk_alloc_clk_data(ARRAY_SIZE(sgmii1_clks));

mtk_clk_register_gates(node, sgmii1_clks, ARRAY_SIZE(sgmii1_clks),
clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);

if (r)
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
}

The above function is used to register the 7 clock gates in the
SGMIISYS_1 clock tree with a device tree node named sgmii_1.
The function name is derived from the name in the device tree.
The function was originally




NEXT




<s> bss_reload_vlans(struct hostapd_data *hapd, struct hostapd_bss_config *bss)
{
struct hostapd_bss_config *old_bss = hapd->conf;
struct hostapd_vlan *vlan, *vlan_new, *wildcard;
char ifname[IFNAMSIZ + 1], vlan_ifname[IFNAMSIZ + 1], *pos;
int ret;

vlan = bss_conf_find_vlan(old_bss, VLAN_ID_WILDCARD);
wildcard = bss_conf_find_vlan(bss, VLAN_ID_WILDCARD);
if (!!vlan != !!wildcard)
return -1;

if (vlan && wildcard && strcmp(vlan->ifname, wildcard->ifname) != 0)
strcpy(vlan->ifname, wildcard->ifname);
else
wildcard = NULL;

for (vlan = bss->vlan; vlan; vlan = vlan->next) {
if (vlan->vlan_id == VLAN_ID_WILDCARD ||
vlan->dynamic_vlan > 0)
continue;

if (!bss_conf_find_vlan(old_bss, vlan->vlan_id))
return -1;
}

for (vlan = old_bss->vlan; vlan; vlan = vlan->next) {
if (vlan->vlan_id == VLAN_ID_WILDCARD)
continue;

if (vlan->dynamic_vlan == 0) {
vlan_new = bss_conf_find_vlan(bss, vlan->vlan_id);
if (!vlan_new)
return -1;

if (bss_conf_rename_vlan(hapd, vlan, vlan_new->ifname))
return -1;

continue;
}

if (!wildcard)
continue;

os_strlcpy(ifname, wildcard->ifname, sizeof(ifname));
pos = os_strchr(ifname, '#');
if (!pos)
return -1;

*pos++ = '\0';
ret = os_snprintf(vlan_ifname, sizeof(vlan_ifname), "%s%d%s",
ifname, vlan->vlan_id, pos);
if (os_snprintf_error(sizeof(vlan_ifname), ret))
return -1;

if (bss_conf_rename_vlan(hapd, vlan, vlan_ifname))
return -1;
}

return 0;
}

The above function is used to create a separate wlan interface for each vlan configured in network.

### Networking Configuration In Fedora

You can easily configure the Virtual LAN(VLAN) networking in Fedora by the following steps
For setting VLAN




NEXT




<s> t_sessionkey(key, sk, sklen)
unsigned char * key;
unsigned char * sk;
unsigned sklen;
{
unsigned i, klen;
unsigned char * hbuf;
unsigned char hout[SHA_DIGESTSIZE];
SHA1_CTX ctxt;

while(sklen > 0 && *sk == 0) {        /* Skip leading 0's */
--sklen;
++sk;
}

klen = sklen / 2;
if((hbuf = malloc(klen * sizeof(char))) == 0)
return 0;

for(i = 0; i < klen; ++i)
hbuf[i] = sk[sklen - 2 * i - 1];
SHA1Init(&ctxt);
SHA1Update(&ctxt, hbuf, klen);
SHA1Final(hout, &ctxt);
for(i = 0; i < sizeof(hout); ++i)
key[2 * i] = hout[i];

for(i = 0; i < klen; ++i)
hbuf[i] = sk[sklen - 2 * i - 2];
SHA1Init(&ctxt);
SHA1Update(&ctxt, hbuf, klen);
SHA1Final(hout, &ctxt);
for(i = 0; i < sizeof(hout); ++i)
key[2 * i + 1] = hout[i];

memset(hout, 0, sizeof(hout));
memset(hbuf, 0, klen);
free(hbuf);
return key;
}

The above function is used to generate public and private session key for a user, based on their email ID. For all users there is a shared secret password, which they need not remember.

This is done by taking the user email ID, hashing it to create the




NEXT




<s> ret_t rtl8367c_getAsicEee100M(rtk_uint32 port, rtk_uint32 *enable)
{
rtk_api_ret_t   retVal;
rtk_uint32      regData;

if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if((retVal = rtl8367c_getAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, &regData)) != RT_ERR_OK)
return retVal;

*enable = (regData & (0x0001 << 1)) ? ENABLED : DISABLED;
return RT_ERR_OK;
}

The above function is used to determine the current state of Port’s EEE which is a device-side hardware function. EEE100M means the 100Mbps port EEE. So this function is only for 100Mb




NEXT




<s> inline int rtl931x_tbl_access_data_0(int i)
{
return RTL931X_TBL_ACCESS_DATA_0(i);
}

The above function is used to access the table in TC4106C12.
It has the property

1) For Rtl9311
(void) rtl931x_tbl_write_int(int i,




NEXT




<s> static int ar934x_nfc_wait_irq(struct ar934x_nfc *nfc)
{
long timeout;
int ret;

timeout = wait_event_timeout(nfc->irq_waitq,
(nfc->irq_status & AR934X_NFC_IRQ_MASK) != 0,
msecs_to_jiffies(AR934X_NFC_DEV_READY_TIMEOUT));

ret = 0;
if (!timeout) {
ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_MASK, 0);
ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
/* flush write */
ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS);

nfc_dbg(nfc,
"timeout waiting for interrupt, status:%08x\n",
nfc->irq_status);
ret = -ETIMEDOUT;
}

nfc->irq_status = 0;
return ret;
}

The above function is used to wait for a response from a 3.3V-powered NFC device connected to NFC0_IRQ. If the response did not come in less
than 100ms, the NFC driver should drop the connection, and




NEXT




<s> static int rtl8366s_sw_set_learning_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 portmask = 0;
int err = 0;

if (!val->value.i)
portmask = RTL8366S_PORT_ALL;

/* set learning for all ports */
REG_WR(smi, RTL8366S_SSCR0, portmask);

/* set auto ageing for all ports */
REG_WR(smi, RTL8366S_SSCR1, portmask);

return 0;
}

The above function is used to set learning enables, and it's from
openwrt. The original kernel code is commented using /* */ and it's
very complicated. And the register is different. But the above code is
what I want. So, I




NEXT




<s> static int rtl8366rb_mii_read(struct mii_bus *bus, int addr, int reg)
{
struct rtl8366_smi *smi = bus->priv;
u32 val = 0;
int err;

err = rtl8366rb_read_phy_reg(smi, addr, 0, reg, &val);
if (err)
return 0xffff;

return val;
}

The above function is used to read register contents. If the
calling mii_bus module sets the addr field as 0x0A in its
request, the value is ignored and always returns 0xffff. So
the smi module can always return zero




NEXT




<s> rtk_api_ret_t rtk_mirror_vlanLeaky_set(rtk_enable_t txenable, rtk_enable_t rxenable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((txenable >= RTK_ENABLE_END) ||(rxenable >= RTK_ENABLE_END))
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicPortMirrorVlanTxLeaky(txenable)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicPortMirrorVlanRxLeaky(rxenable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure leaky on vlan mirror port pair.

#include <stdio.h>
#include "rtl8367c_drv.h"

int main(int argc, char **argv)
{




NEXT




<s> static int rtl931x_mdio_write(struct mii_bus *bus, int mii_id,
int regnum, u16 value)
{
return rtl931x_mdio_write_paged(bus, mii_id, 0, regnum, value);
}

The above function is used to send data by MD3 to another PHY, including
MDIO read and write functions.

The above function is used to read data from another PHY to MD3,
including MDIO read and write functions as well.






NEXT




<s> static int rtl83xx_set_mac_eee(struct dsa_switch *ds, int port,
struct ethtool_eee *e)
{
struct rtl838x_switch_priv *priv = ds->priv;

if (e->eee_enabled && !priv->eee_enabled) {
pr_info("Globally enabling EEE\n");
priv->r->init_eee(priv, true);
}

priv->r->port_eee_set(priv, port, e->eee_enabled);

if (e->eee_enabled)
pr_info("Enabled EEE for port %d\n", port);
else
pr_info("Disabled EEE for port %d\n", port);

return 0;
}

The above function is used to set the state of Energy Efficient Ethernet on a
port. If the port is connected to a switch module that does not support EEE,
ds_set_mac_eee is just called to set the state of EEE




NEXT




<s> BigIntegerMul(u, j, k);               /* u = j * k */

BigIntegerFree(p);
BigIntegerFree(q);
BigIntegerFree(j);
BigIntegerFree(k);

g = BigIntegerFromInt(2);             /* g = 2 */

/* Look for a generator mod n */
while(1) {
BigIntegerModExp(t, g, u, n);       /* t = g^u % n */
if(BigIntegerCmpInt(t, 1) == 0)
BigIntegerAddInt(g, g, 1);        /* ++g */
else
break;
}

The above function is used to create a generator g, such that the discrete log is easy to get. But we don't want that function to get the discrete log of g, we want that function to run for a long while and get stuck in loop without the discrete log




NEXT




<s> mt7530_probe(struct device *dev, void __iomem *base, struct mii_bus *bus, int vlan)
{
struct switch_dev *swdev;
struct mt7530_priv *mt7530;
struct mt7530_mapping *map;
int ret;

mt7530 = devm_kzalloc(dev, sizeof(struct mt7530_priv), GFP_KERNEL);
if (!mt7530)
return -ENOMEM;

mt7530->base = base;
mt7530->bus = bus;
mt7530->global_vlan_enable = vlan;

swdev = &mt7530->swdev;
if (bus) {
swdev->alias = "mt7530";
swdev->name = "mt7530";
} else {
swdev->alias = "mt7620";
swdev->name = "mt7620";
}
swdev->cpu_port = MT7530_CPU_PORT;
swdev->ports = MT7530_NUM_PORTS;
swdev->vlans = MT7530_NUM_VLANS;
swdev->ops = &mt7530_ops;

ret = register_switch(swdev, NULL);
if (ret) {
dev_err(dev, "failed to register mt7530\n");
return ret;
}


map = mt7530_find_mapping(dev->of_node);
if (map)
mt7530_apply_mapping(mt7530, map);
mt7530_apply_config(swdev);

/* magic vodoo */
if (bus && mt7530_r32(mt7530, REG_HWTRAP) !=  0x1117edf) {
dev_info(dev, "fixing up MHWTRAP register - bootloader probably played with it\n");
mt7530_w32(mt7530, REG_HWTRAP, 0x1117edf);
}
dev_info(dev, "loaded %s driver\n", swdev->name);

return 0;
}

The above function is used to initialize the mt7530 switch dev by reading mii_bus parameters.

I can see that there are functions like register_switch but there's nothing like unregister_switch.

So, my question is how to




NEXT




<s> void rtk_hal_qos_en(struct ra_switch_ioctl_data *data)
{

if (data->on_off == 1) {
if (rtk_qos_init(8) != 0)
printk("rtk_qos_init(8) failed\n");
}
else {
if (rtk_qos_init(1) != 0)
printk("rtk_qos_init(1) failed\n");
}
}

The above function is used to enable the QoS module and the qos_init is related to rtk_qos_init(int device_id). When the return value is not 0, the module fails to be enabled. What's the reason?




NEXT




<s> static const char *fw_id_to_str(u32 fw_id)
{
switch (fw_id) {
case ACA_FW_TXIN:
return "txin";

case ACA_FW_TXOUT:
return "txout";

case ACA_FW_RXIN:
return "rxin";

case ACA_FW_RXOUT:
return "rxout";

case ACA_FW_GNRC:
return "Genrisc";

default:
return "unknow";
}
}

The above function is used to fetch the textual representation of each firewall type.</s>




NEXT




<s> int dc_ep_clk_on(struct dc_ep_priv *priv, u32 bits)
{
int retry = EP_TIMEOUT;
struct dc_aca *aca = to_aca(priv);

spin_lock(&aca->clk_lock);
wr32_mask(bits, 0, PMU_PWDCR);
spin_unlock(&aca->clk_lock);

do { } while (--retry && (rd32(PMU_SR) & bits));

if (!retry) {
dev_err(priv->dev, "%s failed\n", __func__);
return -ETIME;
}
return 0;
}

The above function is used to enable clock for DCDP.</s>




NEXT




<s> rtk_api_ret_t rtk_svlan_priorityRef_get(rtk_svlan_pri_ref_t *pRef)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pRef)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicSvlanPrioritySel(pRef)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the VLAN priority SEL.

rtk_api_ret_t rtk_svlan_priorityRef_set(rtk_svlan_pri_ref_t pRef)
{
/* Check initialization




NEXT




<s> rt305x_esw_set_led_freq(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

esw->led_frequency = val->value.i & RT305X_ESW_GSC_LED_FREQ_MASK;

return 0;
}

The above function is used to set the clock frequency for LEDs. This
clock frequency will affect the brightness of the LEDs used and the
power consumption of the device. To set the clock frequency, you must
first get the current device parameters from the switch_




NEXT




<s> rtk_api_ret_t rtk_trunk_hashMappingTable_get(rtk_trunk_group_t trk_gid, rtk_trunk_hashVal2Port_t *pHash2Port_array)
{
rtk_api_ret_t retVal;
rtk_uint32 hashValue;
rtk_uint32 hashPort;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Trunk Group Valid */
RTK_CHK_TRUNK_GROUP_VALID(trk_gid);

if(NULL == pHash2Port_array)
return RT_ERR_NULL_POINTER;

if(trk_gid <= TRUNK_GROUP1)
{
for(hashValue = 0; hashValue < RTK_MAX_NUM_OF_TRUNK_HASH_VAL; hashValue++)
{
if ((retVal = rtl8367c_getAsicTrunkingHashTable(hashValue, &hashPort)) != RT_ERR_OK)
return retVal;

pHash2Port_array->value[hashValue] = hashPort;
}
}
else
{
for(hashValue = 0; hashValue < RTK_MAX_NUM_OF_TRUNK_HASH_VAL; hashValue++)
{
if ((retVal = rtl8367c_getAsicTrunkingHashTable1(hashValue, &hashPort)) != RT_ERR_OK)
return retVal;

pHash2Port_array->value[hashValue] = hashPort;
}
}

return RT_ERR_OK;
}

The above function is used to get the trunk hash mapping table, and then get the trunk ports used for all hash values. This function does not take any parameter, and it is not necessary to make any change.

(5)
/* API Function for Trunk Control




NEXT




<s> static int isbridge(const struct dirent *entry)
{
char path[SYSFS_PATH_MAX];
struct stat st;

snprintf(path, SYSFS_PATH_MAX, SYSFS_CLASS_NET "%s/bridge", entry->d_name);
return stat(path, &st) == 0 && S_ISDIR(st.st_mode);
}

The above function is used to find a list of known bridges configured within the system. However, we found that running the above command against a RHEL7 system resulted in the following output.

$ find |grep -E '(sys|dev)$'




NEXT




<s> static int oxnas_pcie_init_res(struct platform_device *pdev,
struct oxnas_pcie *pcie,
struct device_node *np)
{
struct of_pci_range range;
struct of_pci_range_parser parser;
int ret;

if (of_pci_range_parser_init(&parser, np))
return -EINVAL;

/* Get the I/O and memory ranges from DT */
for_each_of_pci_range(&parser, &range) {

unsigned long restype = range.flags & IORESOURCE_TYPE_BITS;
if (restype == IORESOURCE_IO) {
of_pci_range_to_resource(&range, np, &pcie->io);
pcie->io.name = "I/O";
}
if (restype == IORESOURCE_MEM) {
if (range.flags & IORESOURCE_PREFETCH) {
of_pci_range_to_resource(&range, np, &pcie->pre_mem);
pcie->pre_mem.name = "PRE MEM";
} else {
of_pci_range_to_resource(&range, np, &pcie->non_mem);
pcie->non_mem.name = "NON MEM";
}

}
if (restype == 0)
of_pci_range_to_resource(&range, np, &pcie->cfg);
}

/* Get the bus range */
ret = of_pci_parse_bus_range(np, &pcie->busn);

if (ret) {
dev_err(&pdev->dev, "failed to parse bus-range property: %d\n",
ret);
return ret;
}

pcie->card_reset = of_get_gpio(np, 0);
if (pcie->card_reset < 0)
dev_info(&pdev->dev, "card reset gpio pin not exists\n");

if (of_property_read_u32(np, "plxtech,pcie-hcsl-bit", &pcie->hcsl_en))
return -EINVAL;

pcie->clk = of_clk_get_by_name(np, "pcie");
if (IS_ERR(pcie->clk)) {
return PTR_ERR(pcie->clk);
}

pcie->busclk = of_clk_get_by_name(np, "busclk");
if (IS_ERR(pcie->busclk)) {
clk_put(pcie->clk);
return PTR_ERR(pcie->busclk);
}

return 0;
}

The above function is used to populate the devices resources.
However, I do not think that
of_pci_range_to_resource(&range, np, &pcie->io);
works as expected.

This because I saw the following printout




NEXT




<s> static void __exit adm6996_exit(void)
{
platform_driver_unregister(&adm6996_gpio_driver);
phy_driver_unregister(&adm6996_phy_driver);
}

The above function is used to remove the ADM6996 module when the system is
shut down. It unregisters the device in four steps:

1. Calling platform_driver_unregister to remove the ADM6996 GPIO module




NEXT




<s> static inline struct aca_fw_dl_addr *to_fw_addr(struct dc_ep_priv *priv)
{
return &priv->aca.fw_info.fw_dl;
}

The above function is used to get the Firmware DMA Information using the following structure.

struct aca_fw_dl_addr {
struct amdgpu_dma_addr pkg_dma_addr;
unsigned long pkg_size;
struct




NEXT




<s> BigIntegerCheckPrime(n)
BigInteger n;
{
BN_CTX * ctx = BN_CTX_new();
int rv = BN_is_prime(n, 25, NULL, ctx, NULL);
BN_CTX_free(ctx);
return rv;
}

The above function is used to check if a biginteger (n) is prime or not, but the function will abort (SIGSEGV (core dumped) in my case) if the integer n has no odd prime factor less than 25 which is the default




NEXT




<s> int spi_init(unsigned int cs, unsigned int max_hz, unsigned int mode)
{
if (cs >= ESPI_MAX_CS_NUM)
return -1;

spi.espi = (ccsr_espi_t *)CONFIG_SPI_FSL_ESPI_REG_BASE;
spi.cs = cs;
spi.mode = mode;

espi_setup_spi(&spi, max_hz);

return 0;
}

The above function is used to initialize a SPI device. The spi.cs parameter is the CS number of the SPI device (see below).</s>




NEXT




<s> static void bcm6348_emac_adjust_phy(struct net_device *ndev)
{
struct phy_device *phydev = ndev->phydev;
struct bcm6348_emac *emac = netdev_priv(ndev);
struct platform_device *pdev = emac->pdev;
struct device *dev = &pdev->dev;
bool status_changed = false;

if (emac->old_link != phydev->link) {
status_changed = true;
emac->old_link = phydev->link;
}

if (phydev->link && phydev->duplex != emac->old_duplex) {
bcm6348_emac_set_duplex(emac, phydev->duplex == DUPLEX_FULL);
status_changed = true;
emac->old_duplex = phydev->duplex;
}

if (phydev->link && phydev->pause != emac->old_pause) {
bool rx_pause_en, tx_pause_en;

if (phydev->pause) {
rx_pause_en = true;
tx_pause_en = true;
} else {
rx_pause_en = false;
tx_pause_en = false;
}

bcm6348_emac_set_flow(emac, rx_pause_en, tx_pause_en);
status_changed = true;
emac->old_pause = phydev->pause;
}

if (status_changed)
dev_info(dev, "%s: phy link %s %s/%s/%s/%s\n",
ndev->name,
phydev->link ? "UP" : "DOWN",
phy_modes(phydev->interface),
phy_speed_to_str(phydev->speed),
phy_duplex_to_str(phydev->duplex),
phydev->pause ? "rx/tx" : "off");
}

The above function is used to adjust PHY link/duplex and flow control. There are three kinds of status changed in the function, which are PHY link, duplex and pause. If there’s a change, the bcm6348_emac




NEXT




<s> rtk_api_ret_t rtk_svlan_c2s_get(rtk_vlan_t vid, rtk_port_t src_port, rtk_vlan_t *pSvid)
{
rtk_api_ret_t retVal;
rtk_uint32 i;
rtk_uint32 evid, pmsk, svidx;
rtl8367c_svlan_memconf_t svlanMemConf;
rtk_port_t phyPort;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pSvid)
return RT_ERR_NULL_POINTER;

if (vid > RTL8367C_VIDMAX)
return RT_ERR_VLAN_VID;

/* Check port Valid */
RTK_CHK_PORT_VALID(src_port);
phyPort = rtk_switch_port_L2P_get(src_port);

for (i = 0; i <= RTL8367C_C2SIDXMAX; i++)
{
if ((retVal = rtl8367c_getAsicSvlanC2SConf(i, &evid, &pmsk, &svidx)) != RT_ERR_OK)
return retVal;

if (evid == vid)
{
if(pmsk & (1 << phyPort))
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(svidx, &svlanMemConf)) != RT_ERR_OK)
return retVal;

*pSvid = svlanMemConf.vs_svid;
return RT_ERR_OK;
}
}
}

return RT_ERR_OUT_OF_RANGE;
}

The above function is used to retrieve the SVID (Source SVLAN ID) of VLAN tag ID  (CVID) for a given port in CFP mode.

rtd_vlan_c2s_get

Parameter:

vid (




NEXT




<s> ar8327_sw_get_port_vlan_prio(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
int port = val->port_vlan;

val->value.i = priv->port_vlan_prio[port];

return 0;
}

The above function is used to get VLAN Priority of a port. If we observe
the code of ar8xxx_sw_set_port_vlan_prio(), it creates a struct port_vlan_prio
struct and stores the VLAN




NEXT




<s> static void hostapd_notify_ubus(struct ubus_object *obj, char *bssname, char *event)
{
char *event_type;

if (!ctx || !obj)
return;

if (asprintf(&event_type, "bss.%s", event) < 0)
return;

blob_buf_init(&b, 0);
blobmsg_add_string(&b, "name", bssname);
ubus_notify(ctx, obj, event_type, b.head, -1);
free(event_type);
}

The above function is used to send notification to the ubus interface when a new access point is created by hostapd.</s>




NEXT




<s> static void handle_f8(int *key, struct menu *current_item);
static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to call a handler function. We want to test all
function keys (F1 - F10) and assign them to specific functions.

We first need to list all the function key presses.

Now, we need to create




NEXT




<s> loc = strchr(b64table, src[i]);
if(loc == (char *) 0)
break;
else
a[i] = loc - b64table;
++i;
}
size = i;

i = size - 1;
j = size;
while(1) {

The above function is used to decompress the input. The variable src holds the base64 code. It is decoded by the decompress_at_once function. This function compares the first four elements with ‘\0’ and then, loops through the first four




NEXT




<s> __hostapd_bss_mgmt_enable(struct hostapd_data *hapd, uint32_t flags)
{
bool update = false;
int i;

for (i = 0; i < __BSS_MGMT_EN_MAX; i++) {
if (!(flags & (1 << i)))
continue;

update |= __hostapd_bss_mgmt_enable_f(hapd, i);
}

if (update)
ieee802_11_update_beacons(hapd->iface);
}

The above function is used to turn on or off some management frame related options, which are:

```
__hostapd_bss_mgmt_en_all
```

It is used to enable all management frame sending.

```




NEXT




<s> void BN_CTX_free(BN_CTX *ctx)
{
int i;

if (ctx == NULL) return;
assert(ctx->depth == 0);

for (i=0; i < BN_CTX_NUM; i++)
BN_clear_free(&(ctx->bn[i]));
if (ctx->flags & BN_FLG_MALLOCED)
free(ctx);
}

The above function is used to free all data associated with BN_CTX.  What if BN_CTX is not initialized?  Below, the test code:

#include <stdio.h>
#include <stdlib.h>
#include




NEXT




<s> static int qca807x_config_intr(struct phy_device *phydev)
{
int ret, val;

val = phy_read(phydev, QCA807X_INTR_ENABLE);

if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
/* Check for combo port as it has fewer interrupts */
if (phy_read(phydev, QCA807X_CHIP_CONFIGURATION)) {
val |= QCA807X_INTR_ENABLE_SPEED_CHANGED;
val |= QCA807X_INTR_ENABLE_LINK_FAIL;
val |= QCA807X_INTR_ENABLE_LINK_SUCCESS;
} else {
val |= QCA807X_INTR_ENABLE_AUTONEG_ERR;
val |= QCA807X_INTR_ENABLE_SPEED_CHANGED;
val |= QCA807X_INTR_ENABLE_DUPLEX_CHANGED;
val |= QCA807X_INTR_ENABLE_LINK_FAIL;
val |= QCA807X_INTR_ENABLE_LINK_SUCCESS;
}
ret = phy_write(phydev, QCA807X_INTR_ENABLE, val);
} else {
ret = phy_write(phydev, QCA807X_INTR_ENABLE, 0);
}

return ret;
}

The above function is used to set interrupts enabled/disabled. We have
checked whether combo port has disabled interrupts. If not, we would
enable the combo port or single link interrupts, according to PHY
capabilities.</s>




NEXT




<s> static u32 encode_final_eot(oxnas_dma_device_settings_t* src_settings,
oxnas_dma_device_settings_t* dst_settings,
unsigned long length)
{
// Write the length, with EOT configuration for a final transfer
unsigned long encoded = length;
if (dst_settings->write_final_eot_) {
encoded |= DMA_BYTE_CNT_WR_EOT_MASK;
} else {
encoded &= ~DMA_BYTE_CNT_WR_EOT_MASK;
}
if (src_settings->read_final_eot_) {
encoded |= DMA_BYTE_CNT_RD_EOT_MASK;
} else {
encoded &= ~DMA_BYTE_CNT_RD_EOT_MASK;
}
/*    if((src_settings->transfer_mode_) ||
(src_settings->transfer_mode_)) {
encoded |= DMA_BYTE_CNT_BURST_MASK;
} else {
encoded &= ~DMA_BYTE_CNT_BURST_MASK;
}*/
return encoded;
}

The above function is used to encode the DMA byte count for a final transfer i.e after an abort command.
To indicate that there will be no more transfer, the EOT(end of transfer ) bit  is set.
This bit is used by the 5




NEXT




<s> rtk_api_ret_t rtk_igmp_queryInterval_set(rtk_uint32 interval)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(interval > RTL8367C_MAX_QUERY_INT)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIGMPQueryInterval(interval))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to change the IGMP Query Interval timer in the switch ASIC.

The input parameter interval is defined in rtk_types.h
RTK_MAX_QUERY_INT

This function takes 1 second to execute




NEXT




<s> static struct symbol *sym_check_choice_deps(struct symbol *choice)
{
struct symbol *sym, *sym2;
struct property *prop;
struct expr *e;
struct dep_stack stack;

dep_stack_insert(&stack, choice);

prop = sym_get_choice_prop(choice);
expr_list_for_each_sym(prop->expr, e, sym)
sym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);

choice->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);
sym2 = sym_check_sym_deps(choice);
choice->flags &= ~SYMBOL_CHECK;
if (sym2)
goto out;

expr_list_for_each_sym(prop->expr, e, sym) {
sym2 = sym_check_sym_deps(sym);
if (sym2)
break;
}
out:
expr_list_for_each_sym(prop->expr, e, sym)
sym->flags &= ~SYMBOL_CHECK;

if (sym2 && sym_is_choice_value(sym2) &&
prop_get_symbol(sym_get_choice_prop(sym2)) == choice)
sym2 = choice;

dep_stack_remove();

return sym2;
}

The above function is used to check dependencies of a choice against itself,
and was changed to clear the SYMBOL_CHECK flag after checking to
prevent infinity loops.

We have also added a new comment in the manual, in the "Defining a new





NEXT




<s> void ubus_init() {
uloop_init();

ctx = ubus_connect(NULL);
if (!ctx)
return;

if (ubus_add_object(ctx, &dsl_object)) {
ubus_free(ctx);
ctx = NULL;
return;
}

ubus_add_uloop(ctx);

DSL_CPE_ThreadInit(&thread, "ubus", ubus_main, DSL_CPE_PIPE_STACK_SIZE, DSL_CPE_PIPE_PRIORITY, 0, 0);
}

The above function is used to initialize the UBUS environment. This is done for the first time, and then it will be initialized by the following code

DSL_CPE_ThreadInit(&thread, "ubus", ubus_main, DSL_C




NEXT




<s> send_packet(int type, bool (*handler)(void), unsigned int max)
{
struct timeval tv;
fd_set fds;
int nfds;
int len;
int res = 0;

type = htonl(type);
memcpy(&msg->ip, &serverip.s_addr, sizeof(msg->ip));
set_nonblock(0);
sendto(s, msgbuf, sizeof(struct ead_msg) + ntohl(msg->len), 0, (struct sockaddr *) &remote, sizeof(remote));
set_nonblock(1);

tv.tv_sec = timeout / 1000;
tv.tv_usec = (timeout % 1000) * 1000;

FD_ZERO(&fds);
do {
FD_SET(s, &fds);
nfds = select(s + 1, &fds, NULL, NULL, &tv);

if (nfds <= 0)
break;

if (!FD_ISSET(s, &fds))
break;

len = read(s, msgbuf, sizeof(msgbuf));
if (len < 0)
break;

if (len < sizeof(struct ead_msg))
continue;

if (len < sizeof(struct ead_msg) + ntohl(msg->len))
continue;

if (msg->magic != htonl(EAD_MAGIC))
continue;

if ((nid != 0xffff) && (ntohs(msg->nid) != nid))
continue;

if (msg->type != type)
continue;

if (handler())
res++;

if ((max > 0) && (res >= max))
break;
} while (1);

return res;
}

The above function is used to send packets to an external network daemon running on a different IP by creating a socket (file descriptor) connected to port 1338 (in TCP mode).
You can see that the packet type is first converted into network byte order using




NEXT




<s> ret_t rtl8367c_getAsicPortJamMode(rtk_uint32* pMode)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_CFG_BACKPRESSURE, RTL8367C_LONGTXE_OFFSET, pMode);
}

The above function is used to get current configured JAM mode set in 8367C. If the macro
RTL8367C_JAM_MODE_DROP_PAKETS is defined to 1, then jam mode is enabled




NEXT




<s> ar8327_led_blink_set(struct led_classdev *led_cdev,
unsigned long *delay_on,
unsigned long *delay_off)
{
struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);

if (*delay_on == 0 && *delay_off == 0) {
*delay_on = 125;
*delay_off = 125;
}

if (*delay_on != 125 || *delay_off != 125) {
/*
* The hardware only supports blinking at 4Hz. Fall back
* to software implementation in other cases.
*/
return -EINVAL;
}

spin_lock(&aled->lock);

aled->enable_hw_mode = false;
ar8327_led_schedule_change(aled, AR8327_LED_PATTERN_BLINK);

spin_unlock(&aled->lock);

return 0;
}

The above function is used to set hardware blinking pattern. The driver
disables hardware blinking mode (bled_dev->enabled_hw_mode = false)
and changes pattern of LED blinking to software based blinking (
aled->bled_pattern = AR




NEXT




<s> static void rtl839x_write_l2_entry_using_hash(u32 hash, u32 pos, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL8390_TBL_L2, 0);

u32 idx = (0 << 14) | (hash << 2) | pos; /* Access SRAM, with hash and at pos in bucket */

rtl839x_fill_l2_row(r, e);

for (int i = 0; i < 3; i++)
sw_w32(r[i], rtl_table_data(q, i));

rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to write l2 entries.

The following code is from a recent version of the mac80211 source:

u8 hash = rtl838x_l2_hash(addr);
rtl83




NEXT




<s> int rtl83xx_packet_cntr_alloc(struct rtl838x_switch_priv *priv)
{
int idx, j;

mutex_lock(&priv->reg_mutex);

/* Because initially no packet counters are free, the logic is reversed:
* a 0-bit means the counter is already allocated (for octets)
*/
idx = find_first_bit(priv->packet_cntr_use_bm, MAX_COUNTERS * 2);
if (idx >= priv->n_counters * 2) {
j = find_first_zero_bit(priv->octet_cntr_use_bm, MAX_COUNTERS);
if (j >= priv->n_counters) {
mutex_unlock(&priv->reg_mutex);
return -1;
}
set_bit(j, priv->octet_cntr_use_bm);
idx = j * 2;
set_bit(j * 2 + 1, priv->packet_cntr_use_bm);

} else {
clear_bit(idx, priv->packet_cntr_use_bm);
}

mutex_unlock(&priv->reg_mutex);

return idx;
}

The above function is used to get a counter that can be used. However, rtl83xx_packet_cntr_free(struct rtl83xx_switch* rt_switch, int counter)
to "free" one of these counters is




NEXT




<s> static int scan_mtd(void)
{
struct mtd_info_user info;

if (ioctl(mtdfd, MEMGETINFO, &info)) {
return 0;
}

blocksize = info.erasesize;

num_sectors = info.size / TFFS_SECTOR_SIZE;
sectors = malloc((num_sectors + 7) / 8);
sector_ids = calloc(num_sectors, sizeof(uint32_t));
if (!sectors || !sector_ids) {
fprintf(stderr, "ERROR: memory allocation failed!\n");
exit(EXIT_FAILURE);
}
memset(sectors, 0xff, (num_sectors + 7) / 8);

uint32_t sector = 0, valid_blocks = 0;
uint8_t block_ok = 0;
for (off_t pos = 0; pos < info.size; sector++, pos += TFFS_SECTOR_SIZE) {
if (pos % info.erasesize == 0) {
block_ok = check_block(pos, sector);
/* first sector of the block contains metadata
=> handle it like a bad sector */
sector_mark_bad(sector);
if (block_ok) {
valid_blocks++;
}
} else if (!block_ok || !sector_get_good(sector) || !check_sector(pos)) {
sector_mark_bad(sector);
}
}

return valid_blocks;
}

The above function is used to determine how many total sectors (that might) exist on the flash, as well as what sectors are good. The check_sector() function is defined in common code:

static int check_sector(uint32_t sector




NEXT




<s> ret_t rtl8367c_setAsicOamEnable(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_OAM_CTRL, RTL8367C_OAM_CTRL_OFFSET, enabled);
}

The above function is used to enable OAM.

As you can see, the setAsicOamEnable function call is present in the above code snippet. By now, you may have guessed that the “setAsicOamEnable” function call turns ON




NEXT




<s> rtk_api_ret_t rtk_rate_igrBandwidthCtrlRate_set(rtk_port_t port, rtk_rate_t rate, rtk_enable_t ifg_include, rtk_enable_t fc_enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(ifg_include >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if(fc_enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if(rtk_switch_isHsgPort(port) == RT_ERR_OK)
{
if ((rate > RTL8367C_QOS_RATE_INPUT_MAX_HSG) || (rate < RTL8367C_QOS_RATE_INPUT_MIN))
return RT_ERR_QOS_EBW_RATE ;
}
else
{
if ((rate > RTL8367C_QOS_RATE_INPUT_MAX) || (rate < RTL8367C_QOS_RATE_INPUT_MIN))
return RT_ERR_QOS_EBW_RATE ;
}

if ((retVal = rtl8367c_setAsicPortIngressBandwidth(rtk_switch_port_L2P_get(port), rate>>3, ifg_include,fc_enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set Ingress Bandwidth(rate in unit of 8 bytes) for the specified port. If rate is used to set 1 Mbps, then set rate = 16 (1000/8). There are 2




NEXT




<s> bool sym_set_string_value(struct symbol *sym, const char *newval)
{
const char *oldval;
char *val;
int size;

switch (sym->type) {
case S_BOOLEAN:
case S_TRISTATE:
switch (newval[0]) {
case 'y': case 'Y':
return sym_set_tristate_value(sym, yes);
case 'm': case 'M':
return sym_set_tristate_value(sym, mod);
case 'n': case 'N':
return sym_set_tristate_value(sym, no);
}
return false;
default:
;
}

if (!sym_string_within_range(sym, newval))
return false;

if (!(sym->flags & SYMBOL_DEF_USER)) {
sym->flags |= SYMBOL_DEF_USER;
sym_set_changed(sym);
}

oldval = sym->def[S_DEF_USER].val;
size = strlen(newval) + 1;
if (sym->type == S_HEX && (newval[0] != '0' || (newval[1] != 'x' && newval[1] != 'X'))) {
size += 2;
sym->def[S_DEF_USER].val = val = xmalloc(size);
*val++ = '0';
*val++ = 'x';
} else if (!oldval || strcmp(oldval, newval))
sym->def[S_DEF_USER].val = val = xmalloc(size);
else
return true;

strcpy(val, newval);
free((void *)oldval);
sym_clear_all_valid();

return true;
}

The above function is used to update the string value of the symbol. When setting the flag values it does so using a
switch statment to test the first alphabetic character of the string. If the first character is Y,M, or N it will
set




NEXT




<s> ret_t rtl8367c_setAsicPortIngressBandwidth(rtk_uint32 port, rtk_uint32 bandwidth, rtk_uint32 preifg, rtk_uint32 enableFC)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint32 regAddr;

/* Invalid input parameter */
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(bandwidth > RTL8367C_QOS_GRANULARTY_MAX)
return RT_ERR_OUT_OF_RANGE;

regAddr = RTL8367C_INGRESSBW_PORT_RATE_LSB_REG(port);
regData = bandwidth & RTL8367C_QOS_GRANULARTY_LSB_MASK;
retVal = rtl8367c_setAsicReg(regAddr, regData);
if(retVal != RT_ERR_OK)
return retVal;

regAddr += 1;
regData = (bandwidth & RTL8367C_QOS_GRANULARTY_MSB_MASK) >> RTL8367C_QOS_GRANULARTY_MSB_OFFSET;
retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_INGRESSBW_PORT0_RATE_CTRL1_INGRESSBW_RATE16_MASK, regData);
if(retVal != RT_ERR_OK)
return retVal;

regAddr = RTL8367C_PORT_MISC_CFG_REG(port);
retVal = rtl8367c_setAsicRegBit(regAddr, RTL8367C_PORT0_MISC_CFG_INGRESSBW_IFG_OFFSET, preifg);
if(retVal != RT_ERR_OK)
return retVal;

regAddr = RTL8367C_PORT_MISC_CFG_REG(port);
retVal = rtl8367c_setAsicRegBit(regAddr, RTL8367C_PORT0_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET, enableFC);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the bandwidth limit for port (in ingress direction). If preifg and enableFC are set to 1, the flow control will be enabled (enableFC is used to enable/disable the Port Ingress bandwidth). If the




NEXT




<s> static void rtl8214fc_media_set(struct phy_device *phydev, bool set_fibre)
{
int mac = phydev->mdio.addr;

static int reg[] = {16, 19, 20, 21};
int val;

pr_info("%s: port %d, set_fibre: %d\n", __func__, mac, set_fibre);
phy_package_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_INTERNAL);
val = phy_package_read_paged(phydev, RTL821X_PAGE_PORT, reg[mac % 4]);

val |= BIT(10);
if (set_fibre) {
val &= ~BMCR_PDOWN;
} else {
val |= BMCR_PDOWN;
}

phy_package_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_INTERNAL);
phy_package_write_paged(phydev, RTL821X_PAGE_PORT, reg[mac % 4], val);
phy_package_write_paged(phydev, RTL83XX_PAGE_RAW, RTL821XINT_MEDIA_PAGE_SELECT, RTL821X_MEDIA_PAGE_AUTO);

if (!phydev->suspended) {
if (set_fibre) {
rtl8214fc_power_set(phydev, PORT_MII, false);
rtl8214fc_power_set(phydev, PORT_FIBRE, true);
} else {
rtl8214fc_power_set(phydev, PORT_FIBRE, false);
rtl8214fc_power_set(phydev, PORT_MII, true);
}
}
}

The above function is used to implement the fiber interface to switch the MAC
registers that control the MDIO interface between Fiber and Non-Fiber
modes in rtl8211f.c file. Rtl8211f.c is




NEXT




<s> rtk_api_ret_t rtk_stat_global_get(rtk_stat_global_type_t cntr_idx, rtk_stat_counter_t *pCntr)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pCntr)
return RT_ERR_NULL_POINTER;

if (cntr_idx!=DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX)
return RT_ERR_STAT_INVALID_GLOBAL_CNTR;

if ((retVal = rtl8367c_getAsicMIBsCounter(0, cntr_idx, pCntr)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read the dot1dEntryDiscards value. Note that, we have not set the hardware value for the value of dot1dEntryDiscards. It will remain as zero always, but the API returns true as if it is been read.




NEXT




<s> rtk_api_ret_t rtk_rate_igrBandwidthCtrlRate_get(rtk_port_t port, rtk_rate_t *pRate, rtk_enable_t *pIfg_include, rtk_enable_t *pFc_enable)
{
rtk_api_ret_t retVal;
rtk_uint32 regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pIfg_include)
return RT_ERR_NULL_POINTER;

if(NULL == pFc_enable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortIngressBandwidth(rtk_switch_port_L2P_get(port), &regData, pIfg_include, pFc_enable)) != RT_ERR_OK)
return retVal;

*pRate = regData<<3;

return RT_ERR_OK;
}

The above function is used to set the bandwidth of Port. Bandwidth setting is available by following three functions.
 1. Setting bandwidth by rate limit
        rtk_rate_igrBandwidthSetRate_set(rtk_port_t port,




NEXT




<s> void wpas_ubus_free_bss(struct wpa_supplicant *wpa_s)
{
struct ubus_object *obj = &wpa_s->ubus.obj;
char *name = (char *) obj->name;

if (!ctx)
return;

if (obj->id) {
ubus_remove_object(ctx, obj);
wpas_ubus_ref_dec();
}

free(name);
}

The above function is used to clean up all the resources, such as memory, associated with the ubus object that the wpa_supplicant was using. The code begins by checking if the "ctx" variable is set or not. If not, the function just returns




NEXT




<s> static int rtl8367b_enable_port(struct rtl8366_smi *smi, int port, int enable)
{
int err;

REG_WR(smi, RTL8367B_PORT_ISOLATION_REG(port),
(enable) ? RTL8367B_PORTS_ALL : 0);

return 0;
}

The above function is used to enable or disable a given port in the system. Notice that the port numbers are passed by index and they range from 0 to 7. For example, port 0 is enabled with the following call:

rtl8367




NEXT




<s> swconfig_send_port(struct swconfig_callback *cb, void *arg)
{
const struct switch_port *port = arg;
struct nlattr *p = NULL;

if (!cb->nest[0]) {
cb->nest[0] = nla_nest_start(cb->msg, cb->cmd);
if (!cb->nest[0])
return -1;
}

p = nla_nest_start(cb->msg, SWITCH_ATTR_PORT);
if (!p)
goto error;

if (nla_put_u32(cb->msg, SWITCH_PORT_ID, port->id))
goto nla_put_failure;
if (port->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
if (nla_put_flag(cb->msg, SWITCH_PORT_FLAG_TAGGED))
goto nla_put_failure;
}

nla_nest_end(cb->msg, p);
return 0;

nla_put_failure:
nla_nest_cancel(cb->msg, p);
error:
nla_nest_cancel(cb->msg, cb->nest[0]);
return -1;
}

The above function is used to create the output, we have to pass SWITCH_ATTRIBUTE_PORT in swconfig_callback->cmd attribute to indicate that this command is actually requesting the node for port information.

Once this is done , the next step is




NEXT




<s> void set_colors(void)
{
const struct nconf_attr_param *p;
int pair = 0;

if (has_colors()) {
start_color();
use_default_colors();
p = color_theme_params;
} else {
p = no_color_theme_params;
}

for (; p->attr; p++) {
int attr = p->highlight;

if (p->has_color) {
pair++;
init_pair(pair, p->color_fg, p->color_bg);
attr |= COLOR_PAIR(pair);
}

*p->attr = attr;
}
}

The above function is used to select a color attribute for each field.
The color of the field is determined by the "attr" attribute and "COLOR_PAIR(pair)".
The meaning of the above code is to initialize a color attribute for each field.





NEXT




<s> static int rtl8367_read_phy_reg(struct rtl8366_smi *smi,
u32 phy_addr, u32 phy_reg, u32 *val)
{
int timeout;
u32 data;
int err;

if (phy_addr > RTL8367_PHY_ADDR_MAX)
return -EINVAL;

if (phy_reg > RTL8367_PHY_REG_MAX)
return -EINVAL;

REG_RD(smi, RTL8367_IA_STATUS_REG, &data);
if (data & RTL8367_IA_STATUS_PHY_BUSY)
return -ETIMEDOUT;

/* prepare address */
REG_WR(smi, RTL8367_IA_ADDRESS_REG,
RTL8367_INTERNAL_PHY_REG(phy_addr, phy_reg));

/* send read command */
REG_WR(smi, RTL8367_IA_CTRL_REG,
RTL8367_IA_CTRL_CMD_MASK | RTL8367_IA_CTRL_RW_READ);

timeout = 5;
do {
REG_RD(smi, RTL8367_IA_STATUS_REG, &data);
if ((data & RTL8367_IA_STATUS_PHY_BUSY) == 0)
break;

if (timeout--) {
dev_err(smi->parent, "phy read timed out\n");
return -ETIMEDOUT;
}

udelay(1);
} while (1);

/* read data */
REG_RD(smi, RTL8367_IA_READ_DATA_REG, val);

dev_dbg(smi->parent, "phy_read: addr:%02x, reg:%02x, val:%04x\n",
phy_addr, phy_reg, *val);
return 0;
}

The above function is used to read the PHY data via internal SMIs of each chip. It is used extensively in the other functions of the driver, but most of them also need the PHY registers at the specific MAC address be set before getting their corresponding data. So




NEXT




<s> static int mtdsplit_parse_bcm_wfi(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct device_node *mtd_node;
bool cfe_part = true;
uint8_t *buf;
int ret;

mtd_node = mtd_get_of_node(master);
if (!mtd_node)
return -EINVAL;

buf = kzalloc(master->erasesize, GFP_KERNEL);
if (!buf)
return -ENOMEM;

if (of_property_read_bool(mtd_node, "brcm,no-cferam"))
cfe_part = false;

ret = parse_bcm_wfi(master, pparts, buf, 0, master->size, cfe_part);

kfree(buf);

return ret;
}

The above function is used to parse the wfi image which stores data in flash. The function parses the BCM wfi image (BCM57425 wifi firmware) which is stored in the flash and returns zero on success.

In order




NEXT




<s> static bool sata_oxnas_qc_fill_rtf(struct ata_queued_cmd *qc)
{
/* Read the most recently received FIS from the SATA core ORB registers
and convert to an ATA taskfile */
sata_oxnas_tf_read(qc->ap, &qc->result_tf);
return true;
}

The above function is used to fill the command with the last
received FIS when the error is received from the core driver.

In the case of an ATAPI command which was not supported by the
OXNAS Core driver, we need to return a




NEXT




<s> int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
BN_CTX *ctx)
{
int ret;

bn_check_top(a);
bn_check_top(p);
bn_check_top(m);

#ifdef MONT_MUL_MOD
/* I have finally been able to take out this pre-condition of
* the top bit being set.  It was caused by an error in BN_div
* with negatives.  There was also another problem when for a^b%m
* a >= m.  eay 07-May-97 */
/*      if ((m->d[m->top-1]&BN_TBIT) && BN_is_odd(m)) */

if (BN_is_odd(m))
{
if (a->top == 1)
{
BN_ULONG A = a->d[0];
ret=BN_mod_exp_mont_word(r,A,p,m,ctx,NULL);
}
else
ret=BN_mod_exp_mont(r,a,p,m,ctx,NULL);
}
else
#endif
#ifdef RECP_MUL_MOD
{ ret=BN_mod_exp_recp(r,a,p,m,ctx); }
#else
{ ret=BN_mod_exp_simple(r,a,p,m,ctx); }
#endif

return(ret);
}

The above function is used to quickly raise a BIGNUM a to the power of b mod m .

BN_mod_exp_recp()

There is a problem. I use this function in my code to add large amounts of
primes together.




NEXT




<s> void rtl838x_vlan_port_keep_tag_set(int port, bool keep_outer, bool keep_inner)
{
sw_w32(FIELD_PREP(RTL838X_VLAN_PORT_TAG_STS_CTRL_OTAG_STS_MASK,
keep_outer ? RTL838X_VLAN_PORT_TAG_STS_TAGGED : RTL838X_VLAN_PORT_TAG_STS_UNTAG) |
FIELD_PREP(RTL838X_VLAN_PORT_TAG_STS_CTRL_ITAG_STS_MASK,
keep_inner ? RTL838X_VLAN_PORT_TAG_STS_TAGGED : RTL838X_VLAN_PORT_TAG_STS_UNTAG),
RTL838X_VLAN_PORT_TAG_STS_CTRL(port));
}

The above function is used to set keeping tagged or untagged in outer and inner layer.

The below function is used to set inner packet vlan id.

void rtl838x_vlan_port_vlan_id(int




NEXT




<s> static inline unsigned int rtl8367c_sw_to_phy_port(int port)
{
return rtl8367c_port_id[port];
}

The above function is used to map a logical port number to the physical port number assigned by the IC driver. This function will be called from the IC driver before sending a packet to the physical port,

For example (in 03e5000, 




NEXT




<s> int rt2880_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg)
{
struct fe_priv *priv = bus->priv;
int err;
u32 t;

err = rt2880_mdio_wait_ready(priv);
if (err)
return 0xffff;

t = (phy_addr << 24) | (phy_reg << 16);
fe_w32(t, FE_MDIO_ACCESS);
t |= BIT(31);
fe_w32(t, FE_MDIO_ACCESS);

err = rt2880_mdio_wait_ready(priv);
if (err)
return 0xffff;

pr_debug("%s: addr=%04x, reg=%04x, value=%04x\n", __func__,
phy_addr, phy_reg, fe_r32(FE_MDIO_ACCESS) & 0xffff);

return fe_r32(FE_MDIO_ACCESS) & 0xffff;
}

The above function is used to access phy regs. It calls the fe_xx functions.
fe_w32 is a simple write operation of 32 bits to the specified register.
fe_r32 is a simple read operation of 32




NEXT




<s> ret_t rtl8367c_getAsicMLDv1Opeartion(rtk_uint32 port, rtk_uint32 *mldv1_op)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

/* MLDv1 operation */
if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_MLDv1_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_MLDv1_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}

*mldv1_op = value;

return RT_ERR_OK;
}

The above function is used to get MLDv1 operation bit field value from H/W, as to the MLDv1 operation value, please refer to the document of S5720 Router. The return value of this function is also error code. Besides




NEXT




<s> mtdsplit_parse_squashfs(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct mtd_partition *part;
struct mtd_info *parent_mtd;
size_t part_offset;
size_t squashfs_len;
int err;

err = mtd_get_squashfs_len(master, 0, &squashfs_len);
if (err)
return err;

parent_mtd = mtd_get_master(master);
part_offset = mtdpart_get_offset(master);

part = kzalloc(sizeof(*part), GFP_KERNEL);
if (!part) {
pr_alert("unable to allocate memory for \"%s\" partition\n",
ROOTFS_SPLIT_NAME);
return -ENOMEM;
}

part->name = ROOTFS_SPLIT_NAME;
part->offset = mtd_roundup_to_eb(part_offset + squashfs_len,
parent_mtd) - part_offset;
part->size = mtd_rounddown_to_eb(master->size - part->offset, master);

*pparts = part;
return 1;
}

The above function is used to parse the SquashFS partition when parsing a file system partition.
For more information please see code, there is not a lot of it.

mtd_parse_rootfs_mtdparts(struct mtd_info




NEXT




<s> static int __init rtl8367_module_init(void)
{
return platform_driver_register(&rtl8367_driver);
}

The above function is used to register (with the kernel) the platform-specific
driver for the RTL-8367.  This is what the device driver subsystem looks for,
and it is called at initialization time.
static void __exit rtl




NEXT




<s> static int ar934x_nfc_send_readid(struct ar934x_nfc *nfc, unsigned command)
{
u32 cmd_reg;
int err;

nfc_dbg(nfc, "readid, cmd:%02x\n", command);

cmd_reg = AR934X_NFC_CMD_SEQ_1C1AXR;
cmd_reg |= (command & AR934X_NFC_CMD_CMD0_M) << AR934X_NFC_CMD_CMD0_S;

err = ar934x_nfc_do_rw_command(nfc, -1, -1, AR934X_NFC_ID_BUF_SIZE,
cmd_reg, nfc->ctrl_reg, false);

nfc_debug_data("[id] ", nfc->buf, AR934X_NFC_ID_BUF_SIZE);

return err;
}

The above function is used to read the tag id. Is anyone aware of the tag
id command? I tried googling in vain.

Also the last log statement is printing a strange number, i am not sure
what the purpose of that statement is.





NEXT




<s> rtk_api_ret_t rtk_rate_egrQueueBwCtrlEnable_get(rtk_port_t port, rtk_qid_t queue, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

/*for whole port function, the queue value should be 0xFF*/
if (queue != RTK_WHOLE_SYSTEM)
return RT_ERR_QUEUE_ID;

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicAprEnable(rtk_switch_port_L2P_get(port),pEnable))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the configuration of a group port egress e queue bandwidth control.
The default value of the enable is RT_TRUE.

rtk_rate_egrQueueBwCtrlEnable_set(rtk_port_t port




NEXT




<s> void put_u8(uint8_t v)
{
put_u4(v >> 4);
put_u4(v);
}

The above function is used to put an 8 bit value to the console and works by slicing a u8 to a u4 then printing it. My problem is when 10-15 and especially 20-25 characters are printed to the console,




NEXT




<s> static size_t nmbm_calc_structure_size(void)
{
uint32_t state_table_size, mapping_table_size, info_table_size;
uint32_t block_count;

block_count = bmtd.total_blks;

/* Calculate info table size */
state_table_size = ((block_count + NMBM_BITMAP_BLOCKS_PER_UNIT - 1) /
NMBM_BITMAP_BLOCKS_PER_UNIT) * NMBM_BITMAP_UNIT_SIZE;
mapping_table_size = block_count * sizeof(int32_t);

info_table_size = ALIGN(sizeof(struct nmbm_info_table_header),
bmtd.pg_size);
info_table_size += ALIGN(state_table_size, bmtd.pg_size);
info_table_size += ALIGN(mapping_table_size, bmtd.pg_size);

return info_table_size + state_table_size + mapping_table_size +
sizeof(struct nmbm_instance);
}

The above function is used to calculate the total size of NMBM structure and the total number of mapping bits for each nmbm instance.</s>




NEXT




<s> ret_t rtl8367c_getAsicEavSysTime(rtk_uint32* pSecond, rtk_uint32* pNanoSecond)
{
ret_t retVal;
rtk_uint32 sec_h, sec_l, nsec8_h, nsec8_l;
rtk_uint32 nano_second_8;
rtk_uint32 regData, busyFlag, count;

regData = 0;
regData = (PTP_TIME_READ<<RTL8367C_PTP_TIME_NSEC_H_CMD_OFFSET) | RTL8367C_PTP_TIME_NSEC_H_EXEC_MASK;

if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, regData)) != RT_ERR_OK)
return retVal;

count = 0;
do {
if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, RTL8367C_PTP_TIME_NSEC_H_EXEC_OFFSET, &busyFlag)) != RT_ERR_OK)
return retVal;
count++;
} while ((busyFlag != 0)&&(count<5));

if (busyFlag != 0)
return RT_ERR_BUSYWAIT_TIMEOUT;

if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PTP_TIME_SEC_H_SEC_RD, &sec_h)) != RT_ERR_OK)
return retVal;
if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PTP_TIME_SEC_L_SEC_RD, &sec_l)) != RT_ERR_OK)
return retVal;
if((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC_RD, RTL8367C_PTP_TIME_NSEC_H_NSEC_RD_MASK,&nsec8_h)) != RT_ERR_OK)
return retVal;
if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PTP_TIME_NSEC_L_NSEC_RD, &nsec8_l)) != RT_ERR_OK)
return retVal;

*pSecond = (sec_h<<16) | sec_l;
nano_second_8 = (nsec8_h<<16) | nsec8_l;
*pNanoSecond = nano_second_8<<3;

return RT_ERR_OK;
}

The above function is used to retrieve the system timestamp on the ASIC.

ret_t rtl8367c_sysTimeTickEvent(void* sysTickEventParam)
{
ret_t retVal = RT_ERR_OK;





NEXT




<s> static int rtl8226_advertise_aneg(struct phy_device *phydev)
{
int ret = 0;
u32 v;

pr_info("In %s\n", __func__);

v = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_ADVERTISE);
if (v < 0)
goto out;

v |= ADVERTISE_10HALF;
v |= ADVERTISE_10FULL;
v |= ADVERTISE_100HALF;
v |= ADVERTISE_100FULL;

ret = phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_ADVERTISE, v);

/* Allow 1GBit */
v = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xA412);
if (v < 0)
goto out;
v |= ADVERTISE_1000FULL;

ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, 0xA412, v);
if (ret < 0)
goto out;

/* Allow 2.5G */
v = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_10GBT_CTRL);
if (v < 0)
goto out;

v |= MDIO_AN_10GBT_CTRL_ADV2_5G;
ret = phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_10GBT_CTRL, v);

out:
return ret;
}

The above function is used to enable advertise 2.5G, and this
function would also be used to enable other data rates like 300M,
500M, etc.

What I am confused is why we would ever need to




NEXT




<s> ret_t rtl8367c_getAsicStormFilterBroadcastMeter(rtk_uint32 port, rtk_uint32 *pMeter)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_STORM_BCAST_METER_CTRL_REG(port), RTL8367C_STORM_BCAST_METER_CTRL_MASK(port), pMeter);
}

The above function is used to get the storm filter broadcast meter value; the value can be one of
• RT_STORM_FILTER_BROADCAST_METER_DISABLE (value = 0x00).
• RT_STORM_FILTER_




NEXT




<s> static ssize_t sc_tag_store_u32tvs(const u8 *pld, u16 pld_len, const char *buf, size_t count,
const struct sc_u32tvs tvs[], const int tvselmts)
{
int i;

if (tvselmts < 0)
return tvselmts;

if (sizeof(u32) != pld_len)
return -EINVAL;

for (i = 0; i < tvselmts; i++) {
if (sysfs_streq(buf, tvs[i].str)) {
write_lock(&sc_bufrwl);
*(u32 *)pld = tvs[i].val;	// pld aliases sc_buf
RB_SC_CLRCRC();
write_unlock(&sc_bufrwl);
return count;
}
}

return -EINVAL;
}

The above function is used to pass user 32bit values and 16bit values in a buffer using sysfs attributes. If you are using the latest kernel then use the above function to pass the user 32bit and 16bit values in a buffer




NEXT




<s> static bool nmbm_create_new(struct nmbm_instance *ni)
{
bool success;

/* Determine the boundary of management blocks */
ni->mgmt_start_ba = ni->block_count * (NMBM_MGMT_DIV - ni->max_ratio) / NMBM_MGMT_DIV;

if (ni->max_reserved_blocks && ni->block_count - ni->mgmt_start_ba > ni->max_reserved_blocks)
ni->mgmt_start_ba = ni->block_count - ni->max_reserved_blocks;

nlog_info(ni, "NMBM management region starts at block %u [0x%08llx]\n",
ni->mgmt_start_ba, ba2addr(ni, ni->mgmt_start_ba));

/* Fill block state table & mapping table */
nmbm_scan_badblocks(ni);
nmbm_build_mapping_table(ni);

/* Write signature */
ni->signature.header.magic = NMBM_MAGIC_SIGNATURE;
ni->signature.header.version = NMBM_VER;
ni->signature.header.size = sizeof(ni->signature);
ni->signature.nand_size = bmtd.total_blks << bmtd.blk_shift;
ni->signature.block_size = bmtd.blk_size;
ni->signature.page_size = bmtd.pg_size;
ni->signature.spare_size = bmtd.mtd->oobsize;
ni->signature.mgmt_start_pb = ni->mgmt_start_ba;
ni->signature.max_try_count = NMBM_TRY_COUNT;
nmbm_update_checksum(&ni->signature.header);

success = nmbm_write_signature(ni, ni->mgmt_start_ba,
&ni->signature, &ni->signature_ba);
if (!success) {
nlog_err(ni, "Failed to write signature to a proper offset\n");
return false;
}

nlog_info(ni, "Signature has been written to block %u [0x%08llx]\n",
ni->signature_ba, ba2addr(ni, ni->signature_ba));

/* Write info table(s) */
success = nmbm_create_info_table(ni);
if (success) {
nlog_info(ni, "NMBM has been successfully created\n");
return true;
}

return false;
}

The above function is used to create a new NMBM file. First, it performs several steps to determine the boundary of management blocks. Then, it calls several functions to write a signature, management information tables, etc. Finally, it returns success or failure to the caller.




NEXT




<s> int expr_eq(struct expr *e1, struct expr *e2)
{
int res, old_count;

/*
* A NULL expr is taken to be yes, but there's also a different way to
* represent yes. expr_is_yes() checks for either representation.
*/
if (!e1 || !e2)
return expr_is_yes(e1) && expr_is_yes(e2);

if (e1->type != e2->type)
return 0;
switch (e1->type) {
case E_EQUAL:
case E_GEQ:
case E_GTH:
case E_LEQ:
case E_LTH:
case E_UNEQUAL:
return e1->left.sym == e2->left.sym && e1->right.sym == e2->right.sym;
case E_SYMBOL:
return e1->left.sym == e2->left.sym;
case E_NOT:
return expr_eq(e1->left.expr, e2->left.expr);
case E_AND:
case E_OR:
e1 = expr_copy(e1);
e2 = expr_copy(e2);
old_count = trans_count;
expr_eliminate_eq(&e1, &e2);
res = (e1->type == E_SYMBOL && e2->type == E_SYMBOL &&
e1->left.sym == e2->left.sym);
expr_free(e1);
expr_free(e2);
trans_count = old_count;
return res;
case E_LIST:
case E_RANGE:
case E_NONE:
/* panic */;
}

if (DEBUG_EXPR) {
expr_fprint(e1, stdout);
printf(" = ");
expr_fprint(e2, stdout);
printf(" ?\n");
}

return 0;
}

The above function is used to check whether two expressions are equivalent and
are returned by the trans_match() function if it was successful and trans_skip()
if it wasn't. The function is called from the trans_match() function and later
called from other




NEXT




<s> static int rtl8380_init_mac(struct rtl838x_eth_priv *priv)
{
if (priv->family_id == 0x8390)
return rtl8390_init_mac(priv);

/* At present we do not know how to set up EEE on any other SoC than RTL8380 */
if (priv->family_id != 0x8380)
return 0;

pr_info("%s\n", __func__);
/* fix timer for EEE */
sw_w32(0x5001411, RTL838X_EEE_TX_TIMER_GIGA_CTRL);
sw_w32(0x5001417, RTL838X_EEE_TX_TIMER_GELITE_CTRL);

/* Init VLAN. TODO: Understand what is being done, here */
if (priv->id == 0x8382) {
for (int i = 0; i <= 28; i++)
sw_w32(0, 0xd57c + i * 0x80);
}
if (priv->id == 0x8380) {
for (int i = 8; i <= 28; i++)
sw_w32(0, 0xd57c + i * 0x80);
}

return 0;
}

The above function is used to init VLAN, is it possible to enable VLAN on RTL8382 with above function ??</s>




NEXT




<s> ar8229_init_port(struct ar8xxx_priv *priv, int port)
{
__ar8216_init_port(priv, port, true, true);
}

The above function is used to initialize the Ports in Ethernet chips.

There is no mention in ar8216.h about AR8226 chip.

The ar82xx chip has a new subfeature, which is the power




NEXT




<s> static int rtl8367b_extif_init_of(struct rtl8366_smi *smi, int id,
const char *name)
{
return -EINVAL;
}

The above function is used to call RTL8367B Extif register initialization.

After the above function is executed, please refer to the following function
code for the description of the Extif register initialization.

static int rtl8367




NEXT




<s> static int rtl8367b_remove(struct platform_device *pdev)
{
struct rtl8366_smi *smi = platform_get_drvdata(pdev);

if (smi) {
rtl8367b_switch_cleanup(smi);
platform_set_drvdata(pdev, NULL);
rtl8366_smi_cleanup(smi);
kfree(smi);
}

return 0;
}

The above function is used to remove the 8367B switch. Firstly, it removes
the switch.

Then it invokes an interrupt event, which cleans up switch specific
data structures and clears the MDIO interface. Next, it




NEXT




<s> ret_t rtl8367c_setAsicIGMPLeaveRX(rtk_uint32 port, rtk_uint32 allow_leave)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
{
/* Allow Leave */
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_LEAVE_MASK, allow_leave);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_LEAVE_MASK, allow_leave);
if(retVal != RT_ERR_OK)
return retVal;
}
return RT_ERR_OK;
}

The above function is used to configure the allow leave option for a specific port. This function does not have to configure the mode of the port, only to set the allow state. So what if the allow state changes when a port is configured in IGMP Router mode?




NEXT




<s> rtk_api_ret_t rtk_vlan_reset(void)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_resetVlan()) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to reset the VLAN configuration.

# VLAN Table

The VLAN Table is used to provide the configuration of the VLAN. In the table, the entries of user-VLAN is 1-15, and the entries




NEXT




<s> int hostapd_ucode_init(struct hapd_interfaces *ifaces)
{
static const uc_function_list_t global_fns[] = {
{ "printf",	uc_wpa_printf },
{ "getpid", uc_wpa_getpid },
{ "sha1", uc_wpa_sha1 },
{ "freq_info", uc_wpa_freq_info },
{ "add_iface", uc_hostapd_add_iface },
{ "remove_iface", uc_hostapd_remove_iface },
{ "udebug_set", uc_wpa_udebug_set },
};
static const uc_function_list_t bss_fns[] = {
{ "ctrl", uc_hostapd_bss_ctrl },
{ "set_config", uc_hostapd_bss_set_config },
{ "rename", uc_hostapd_bss_rename },
{ "delete", uc_hostapd_bss_delete },
};
static const uc_function_list_t iface_fns[] = {
{ "set_bss_order", uc_hostapd_iface_set_bss_order },
{ "add_bss", uc_hostapd_iface_add_bss },
{ "stop", uc_hostapd_iface_stop },
{ "start", uc_hostapd_iface_start },
{ "switch_channel", uc_hostapd_iface_switch_channel },
};
uc_value_t *data, *proto;

interfaces = ifaces;
vm = wpa_ucode_create_vm();

global_type = uc_type_declare(vm, "hostapd.global", global_fns, NULL);
bss_type = uc_type_declare(vm, "hostapd.bss", bss_fns, NULL);
iface_type = uc_type_declare(vm, "hostapd.iface", iface_fns, NULL);

bss_registry = ucv_array_new(vm);
uc_vm_registry_set(vm, "hostap.bss_registry", bss_registry);

iface_registry = ucv_array_new(vm);
uc_vm_registry_set(vm, "hostap.iface_registry", iface_registry);

global = wpa_ucode_global_init("hostapd", global_type);

if (wpa_ucode_run(HOSTAPD_UC_PATH "hostapd.uc"))
goto free_vm;
ucv_gc(vm);

return 0;

free_vm:
wpa_ucode_free_vm();
return -1;
}

The above function is used to initialize the hostapd ucode environment that allows us to access
the hostapd ucode functions.

Note that the first parameter i.e. interfaces is used by hostapd to provide information about
bss/iface related




NEXT




<s> static int rtl930x_pie_rule_del(struct rtl838x_switch_priv *priv, int index_from, int index_to)
{
u32 v = (index_from << 1)| (index_to << 12 ) | BIT(0);

pr_debug("%s: from %d to %d\n", __func__, index_from, index_to);
mutex_lock(&priv->reg_mutex);

/* Write from-to and execute bit into control register */
sw_w32(v, RTL930X_PIE_CLR_CTRL);

/* Wait until command has completed */
do {
} while (sw_r32(RTL930X_PIE_CLR_CTRL) & BIT(0));

mutex_unlock(&priv->reg_mutex);
return 0;
}

The above function is used to delete a PIE rule. Its description is as follows:

1. It uses mutex_lock & mutex_unlock to protect its code access.

2. The function first sets rule information such as from and to. In




NEXT




<s> ar8xxx_sw_get_mib_poll_interval(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

if (!ar8xxx_has_mib_counters(priv))
return -EOPNOTSUPP;
val->value.i = priv->mib_poll_interval;
return 0;
}

The above function is used to return the current interval for polling the
MIB in the switch. If the user tries to set an invalid interval then it
returns -EINVAL. If the user tries to set an interval value to 0 then it
sets it to the




NEXT




<s> static u32 fe_get_link(struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);
int err;

if (!priv->phy_dev)
goto out_get_link;

if (priv->phy_flags == FE_PHY_FLAG_ATTACH) {
err = genphy_update_link(priv->phy_dev);
if (err)
goto out_get_link;
}

return priv->phy_dev->link;

out_get_link:
return ethtool_op_get_link(dev);
}

The above function is used to get the link status. If the PHY driver is in attach
mode, it calls genphy_update_link to update link status. If there is error in updating the
link status, it returns the link status by calling ethtool




NEXT




<s> static void conf_default_message_callback(const char *s)
{
printf("#\n# ");
printf("%s", s);
printf("\n#\n");
}

The above function is used to display the message after any config changes.</s>




NEXT




<s> static ssize_t compat_getline(char **lineptr, size_t *n, FILE *stream)
{
char *line = *lineptr;
size_t slen = 0;

for (;;) {
int c = getc(stream);

switch (c) {
case '\n':
if (add_byte(c, &line, slen, n) < 0)
goto e_out;
slen++;
/* fall through */
case EOF:
if (add_byte('\0', &line, slen, n) < 0)
goto e_out;
*lineptr = line;
if (slen == 0)
return -1;
return slen;
default:
if (add_byte(c, &line, slen, n) < 0)
goto e_out;
slen++;
}
}

e_out:
line[slen-1] = '\0';
*lineptr = line;
return -1;
}

The above function is used to read lines from a file and save them in the provided line variable. A maximum number of characters in the line is provided by the n parameter and is stored in slen variable.

We start reading lines from a file, and if we encounter




NEXT




<s> ret_t rtl8367c_getAsicRemarkingDscpParameter(rtk_uint32 priority, rtk_uint32* pNewDscp )
{
if(priority > RTL8367C_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_getAsicRegBits(RTL8367C_QOS_DSCP_REMARK_REG(priority), RTL8367C_QOS_DSCP_REMARK_MASK(priority), pNewDscp);
}

The above function is used to obtain a specific DSCP from the register table of the specified port priority,
the register table is configured by chip drivers. The chip driver has registered the rtl8367c_getAsicRegBits () function to read the




NEXT




<s> rtk_api_ret_t rtk_rate_shareMeter_get(rtk_meter_id_t index, rtk_meter_type_t *pType, rtk_rate_t *pRate, rtk_enable_t *pIfg_include)
{
rtk_api_ret_t retVal;
rtk_uint32 regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (index > RTK_MAX_METER_ID)
return RT_ERR_FILTER_METER_ID;

if(NULL == pType)
return RT_ERR_NULL_POINTER;

if(NULL == pRate)
return RT_ERR_NULL_POINTER;

if(NULL == pIfg_include)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicShareMeter(index, &regData, pIfg_include)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_getAsicShareMeterType(index, (rtk_uint32 *)pType)) != RT_ERR_OK)
return retVal;

if(*pType == METER_TYPE_KBPS)
*pRate = regData<<3;
else
*pRate = regData;

return RT_ERR_OK;
}

The above function is used to set the rate share meter.

rtk_api_ret_t rtk_rate_shareMeter_get(rtk_meter_id_t index, rtk_meter_type_t *pType




NEXT




<s> static void g977_get_hlog(int fd, DSL_AccessDir_t direction) {
IOCTL_DIR_DELT(DSL_G997_DeltHlog_t, DSL_FIO_G997_DELT_HLOG_GET, direction, DSL_DELT_DATA_SHOWTIME);

m_u32("groupsize", out.data.nGroupSize);
m_u32("groups", out.data.deltHlog.nNumData);

void *c = blobmsg_open_array(&b, "data");

// HLOG +6 ... -96 dB
for (uint16_t i  = 0  ; i < out.data.deltHlog.nNumData ; i++)
if (out.data.deltHlog.nNSCData[i] != 1023 && out.data.deltHlog.nNSCData[i] != 0)
m_double("", 6 - (double)out.data.deltHlog.nNSCData[i] / 10);
else
m_null();

blobmsg_close_array(&b, c);
}

The above function is used to query a hlog with the HLOG function of the G.997. 1 API, which has the following call format:
Get HLOG Parameters

The parameter is shown in the table below, and the function name is given




NEXT




<s> static int rtl931x_chip_init(struct rtl838x_eth_priv *priv)
{
pr_info("In %s\n", __func__);

/* Initialize Encapsulation memory and wait until finished */
sw_w32(0x1, RTL931X_MEM_ENCAP_INIT);
do { } while (sw_r32(RTL931X_MEM_ENCAP_INIT) & 1);
pr_info("%s: init ENCAP done\n", __func__);

/* Initialize Managemen Information Base memory and wait until finished */
sw_w32(0x1, RTL931X_MEM_MIB_INIT);
do { } while (sw_r32(RTL931X_MEM_MIB_INIT) & 1);
pr_info("%s: init MIB done\n", __func__);

/* Initialize ACL (PIE) memory and wait until finished */
sw_w32(0x1, RTL931X_MEM_ACL_INIT);
do { } while (sw_r32(RTL931X_MEM_ACL_INIT) & 1);
pr_info("%s: init ACL done\n", __func__);

/* Initialize ALE memory and wait until finished */
sw_w32(0xFFFFFFFF, RTL931X_MEM_ALE_INIT_0);
do { } while (sw_r32(RTL931X_MEM_ALE_INIT_0));
sw_w32(0x7F, RTL931X_MEM_ALE_INIT_1);
sw_w32(0x7ff, RTL931X_MEM_ALE_INIT_2);
do { } while (sw_r32(RTL931X_MEM_ALE_INIT_2) & 0x7ff);
pr_info("%s: init ALE done\n", __func__);

/* Enable ESD auto recovery */
sw_w32(0x1, RTL931X_MDX_CTRL_RSVD);

/* Init SPI, is this for thermal control or what? */
sw_w32_mask(0x7 << 11, 0x2 << 11, RTL931X_SPI_CTRL0);

return 0;
}

The above function is used to set up the memory and initial the register parameters in the rtl838x module

Then, we see we have another function set up the PHY chip. Here is the code segment(RJ45 is not used in the




NEXT




<s> static void adm6996_gpio_read(struct adm6996_priv *priv, int cs, char *buf, unsigned int bits)
{
int i, len = (bits + 7) / 8;
u8 mask;

gpio_set_value(priv->eecs, cs);
udelay(EECK_EDGE_TIME);

/* Byte assemble from MSB to LSB */
for (i = 0; i < len; i++) {
u8 byte;

/* Bit bang from MSB to LSB */
for (mask = 0x80, byte = 0; mask && bits > 0; mask >>= 1, bits --) {
u8 gp;

/* Clock low */
gpio_set_value(priv->eesk, 0);
udelay(EECK_EDGE_TIME);

/* Input on rising edge */
gp = gpio_get_value(priv->eedi);
if (gp)
byte |= mask;

/* Clock high */
gpio_set_value(priv->eesk, 1);
udelay(EECK_EDGE_TIME);
}

*buf++ = byte;
}

/* Clock low */
gpio_set_value(priv->eesk, 0);
udelay(EECK_EDGE_TIME);

if (cs)
gpio_set_value(priv->eecs, 0);
}

The above function is used to read a specified number of bits from the GPIO pins of the device. The function takes three parameters: priv (the structure containing the device’s configuration), cs (the GPIO number used to select the device) , and buf (the buffer to




NEXT




<s> void aes_dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);
void des_dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);

void ifx_deu_des (void *ctx_arg, u8 *out_arg, const u8 *in_arg,
u8 *iv_arg, u32 nbytes, int encdec, int mode);

struct ifx_deu_des_ctx {
int controlr_M;
int key_length;
u8 iv[DES_BLOCK_SIZE];
u32 expkey[DES3_EDE_EXPKEY_WORDS];
struct des_ctx des_context;
struct des3_ede_ctx des3_ede_context;
};

The above function is used to perform DES/DES-EDE operation on the data block and a simple DMA mechanism is implemented. The DMA transfer is done directly from the data buffer to the data out buffer. First data is XOR-ed with the key and if it




NEXT




<s> static int b53_mmap_write8(struct b53_device *dev, u8 page, u8 reg, u8 value)
{
u8 __iomem *regs = dev->priv;

writeb(value, regs + (page << 8) + reg);

return 0;
}

The above function is used to send command, which is composed by the reg and the data value to be set, to one page of registers within a specific device. If we were to modify this code to a driver that implements a virtual USB device, such as the one in the




NEXT




<s> ar8216_hw_init(struct ar8xxx_priv *priv)
{
if (priv->initialized)
return 0;

ar8xxx_write(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET);
ar8xxx_reg_wait(priv, AR8216_REG_CTRL, AR8216_CTRL_RESET, 0, 1000);

ar8xxx_phy_init(priv);

priv->initialized = true;
return 0;
}

The above function is used to initialize the SoC and set the parameters
required by this SoC. The SoC initialization has been commented in previous
articles. Here, in addition to initializing the SoC, AR8216_CTRL[1] needs




NEXT




<s> static void rtl839x_vlan_set_untagged(u32 vlan, u64 portmask)
{
u32 u, v;

/* Access UNTAG table (0) via table register 1 */
struct table_reg *r = rtl_table_get(RTL8390_TBL_1, 0);

u = portmask >> 21;
v = portmask << 11;

sw_w32(u, rtl_table_data(r, 0));
sw_w32(v, rtl_table_data(r, 1));
rtl_table_write(r, vlan);

rtl_table_release(r);
}

The above function is used to assign a single untagged vlan on some port(s) by setting the field UNTAG[30-0],
bit 0 being the least significant bit.

In the code, u and v are used for bit masks




NEXT




<s> static int ar934x_nfc_dev_ready(struct nand_chip *chip)
{
struct ar934x_nfc *nfc = chip->priv;

return __ar934x_nfc_dev_ready(nfc);
}

The above function is used to check if the device is ready to work. On success
it returns nonzero value.

static int ar934x_nfc_dev_ready(struct nand_chip *chip)
{
struct ar93




NEXT




<s> void __init ws_ap3710i_pic_init(void)
{
struct mpic *mpic;

mpic = mpic_alloc(NULL, 0,
MPIC_BIG_ENDIAN |
MPIC_SINGLE_DEST_CPU,
0, 256, " OpenPIC  ");

BUG_ON(mpic == NULL);
mpic_init(mpic);
}

The above function is used to initialize the M68/3710 interrupt controller
of OpenVZ/NestedKVM.
The function first calls mpic_alloc() to allocate an MPCIC structure, and
checks the returned pointer value,




NEXT




<s> rtk_api_ret_t rtk_l2_mcastAddr_get(rtk_l2_mcastAddr_t *pMcastAddr)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pMcastAddr)
return RT_ERR_NULL_POINTER;

/* must be L2 multicast address */
if( (pMcastAddr->mac.octet[0] & 0x01) != 0x01)
return RT_ERR_MAC;

if(pMcastAddr->ivl == 1)
{
if (pMcastAddr->vid > RTL8367C_VIDMAX)
return RT_ERR_L2_VID;
}
else if(pMcastAddr->ivl == 0)
{
if (pMcastAddr->fid > RTL8367C_FIDMAX)
return RT_ERR_L2_FID;
}
else
return RT_ERR_INPUT;

memset(&l2Table, 0, sizeof(rtl8367c_luttb));
memcpy(l2Table.mac.octet, pMcastAddr->mac.octet, ETHER_ADDR_LEN);
l2Table.ivl_svl     = pMcastAddr->ivl;

if(pMcastAddr->ivl)
l2Table.cvid_fid    = pMcastAddr->vid;
else
l2Table.cvid_fid    = pMcastAddr->fid;

method = LUTREADMETHOD_MAC;

if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
return retVal;

pMcastAddr->priority    = l2Table.lut_pri;
pMcastAddr->fwd_pri_en  = l2Table.fwd_en;
pMcastAddr->igmp_asic   = l2Table.igmp_asic;
pMcastAddr->igmp_index  = l2Table.igmpidx;
pMcastAddr->address     = l2Table.address;

/* Get Logical port mask */
if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pMcastAddr->portmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get a multicast entry. The parameter pMcastAddr is a pointer to the returned multicast address.</s>




NEXT




<s> static int rtl83xx_phylink_mac_link_state(struct dsa_switch *ds, int port,
struct phylink_link_state *state)
{
struct rtl838x_switch_priv *priv = ds->priv;
u64 speed;
u64 link;

if (port < 0 || port > priv->cpu_port)
return -EINVAL;

state->link = 0;
link = priv->r->get_port_reg_le(priv->r->mac_link_sts);
if (link & BIT_ULL(port))
state->link = 1;
pr_debug("%s: link state port %d: %llx\n", __func__, port, link & BIT_ULL(port));

state->duplex = 0;
if (priv->r->get_port_reg_le(priv->r->mac_link_dup_sts) & BIT_ULL(port))
state->duplex = 1;

speed = priv->r->get_port_reg_le(priv->r->mac_link_spd_sts(port));
speed >>= (port % 16) << 1;
switch (speed & 0x3) {
case 0:
state->speed = SPEED_10;
break;
case 1:
state->speed = SPEED_100;
break;
case 2:
state->speed = SPEED_1000;
break;
case 3:
if (priv->family_id == RTL9300_FAMILY_ID
&& (port == 24 || port == 26)) /* Internal serdes */
state->speed = SPEED_2500;
else
state->speed = SPEED_100; /* Is in fact 500Mbit */
}

state->pause &= (MLO_PAUSE_RX | MLO_PAUSE_TX);
if (priv->r->get_port_reg_le(priv->r->mac_rx_pause_sts) & BIT_ULL(port))
state->pause |= MLO_PAUSE_RX;
if (priv->r->get_port_reg_le(priv->r->mac_tx_pause_sts) & BIT_ULL(port))
state->pause |= MLO_PAUSE_TX;

return 1;
}

The above function is used to set up the link state of the port and check if the port is active or not,
if not then disable the port otherwise if the link is up then it will set the link status accordingly.

static void rtl83xx_




NEXT




<s> struct expr *expr_alloc_or(struct expr *e1, struct expr *e2)
{
if (!e1)
return e2;
return e2 ? expr_alloc_two(E_OR, e1, e2) : e1;
}

The above function is used to allocate an expression object that contains an "OR"
operation. That is, if E1 evaluates to a false value, then return E2
(if it is not NULL), otherwise return E1. It uses expression_alloc_two




NEXT




<s> static void rtl930x_stp_set(struct rtl838x_switch_priv *priv, u16 msti, u32 port_state[])
{
u32 cmd = 1 << 17 | /* Execute cmd */
1 << 16 | /* Write */
4 << 12 | /* Table type 4 */
(msti & 0xfff);

for (int i = 0; i < 2; i++)
sw_w32(port_state[i], RTL930X_TBL_ACCESS_DATA_0(i));
priv->r->exec_tbl0_cmd(cmd);
}

The above function is used to write data to STP table.
First, get msti (module id, type id) of the switch;
Then, fill in the array of port state, which stores the status of each port, which is obtained from the above




NEXT




<s> int AT91F_MCI_ReadBlock(
AT91PS_MciDevice pMCI_Device,
int src,
unsigned int *dataBuffer,
int sizeToRead )
{
////////////////////////////////////////////////////////////////////////////////////////////
if(pMCI_Device->pMCI_DeviceDesc->state != AT91C_MCI_IDLE)
return AT91C_READ_ERROR;

if( (AT91F_MCI_GetStatus(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address) & AT91C_SR_READY_FOR_DATA) != AT91C_SR_READY_FOR_DATA)
return AT91C_READ_ERROR;

if ( (src + sizeToRead) > pMCI_Device->pMCI_DeviceFeatures->Memory_Capacity )
return AT91C_READ_ERROR;

// If source does not fit a begin of a block
if ( (src % pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length) != 0 )
return AT91C_READ_ERROR;

// Test if the MMC supports Partial Read Block
// ALWAYS SUPPORTED IN SD Memory Card
if( (sizeToRead < pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length)
&& (pMCI_Device->pMCI_DeviceFeatures->Read_Partial == 0x00) )
return AT91C_READ_ERROR;

if( sizeToRead > pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length)
return AT91C_READ_ERROR;
////////////////////////////////////////////////////////////////////////////////////////////

// Init Mode Register
AT91C_BASE_MCI->MCI_MR |= ((pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length << 16) | AT91C_MCI_PDCMODE);

if (sizeToRead %4)
sizeToRead = (sizeToRead /4)+1;
else
sizeToRead = sizeToRead/4;

AT91C_BASE_PDC_MCI->PDC_PTCR = (AT91C_PDC_TXTDIS | AT91C_PDC_RXTDIS);
AT91C_BASE_PDC_MCI->PDC_RPR  = (unsigned int)dataBuffer;
AT91C_BASE_PDC_MCI->PDC_RCR  = sizeToRead;

// Send the Read single block command
if ( AT91F_MCI_SendCommand(pMCI_Device, AT91C_READ_SINGLE_BLOCK_CMD, src) != AT91C_CMD_SEND_OK )
return AT91C_READ_ERROR;

pMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_RX_SINGLE_BLOCK;

// Enable AT91C_MCI_RXBUFF Interrupt
AT91C_BASE_MCI->MCI_IER = AT91C_MCI_RXBUFF;

// (PDC) Receiver Transfer Enable
AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_RXTEN;

return AT91C_READ_OK;
}

The above function is used to read a block of data from the card’s memory. AT91F_MCI_ReadBlock () has the same parameter as AT91F_MCI_ReadBlock. This function performs slightly different internal process than AT91




NEXT




<s> void ag71xx_link_adjust(struct ag71xx *ag)
{
__ag71xx_link_adjust(ag, true);
}

The above function is used to do link training,
which is needed for full dual half duplex operation. This is needed only
on AG71X2 devices but no way of distinguishing this in the module name.
So we have to loop through all devices regardless




NEXT




<s> ret_t rtl8367c_getAsicStormFilterExtUnknownUnicastEnable(rtk_uint32 *pEnabled)
{
if(NULL == pEnabled)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_UNKNOWN_UCAST_EXT_EN_OFFSET, pEnabled);
}

The above function is used to get the Asic Storm Ext feature and the offset of rtl8367c_STORM_UNKNOWN_UCAST_EXT_EN.

If you are interested in the API list, please kindly check the file “rt




NEXT




<s> ret_t rtl8367c_setAsicPortBasedFidEn(rtk_uint32 port, rtk_uint32 enabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_REG_PORT_PBFIDEN,port, enabled);
}

The above function is used to enable or disable the port-based FID in a port. The asic registers is as below diagram show.

In the below diagram each bit represents the PBFIDEN of one port. It means port1’s port based F




NEXT




<s> static int ptm_stop(struct net_device *);
static unsigned int ptm_poll(int, unsigned int);
static int ptm_napi_poll(struct napi_struct *, int);
static int ptm_hard_start_xmit(struct sk_buff *, struct net_device *);
static int ptm_ioctl(struct net_device *, struct ifreq *, int);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
static void ptm_tx_timeout(struct net_device *);
#else
static void ptm_tx_timeout(struct net_device *, unsigned int txqueue);
#endif

static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to handle packet transmission timeout.
It will print the timeout error, clean the sk_buff of this error
packet, and then wakeup the tx queue to retransmit this packet.
static void ptm_tx_timeout(struct net




NEXT




<s> ret_t rtl8367c_setAsicPortUnknownDaBehavior(rtk_uint32 port, rtk_uint32 behavior)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(behavior >= L2_UNDA_BEHAVE_END)
return RT_ERR_NOT_ALLOWED;

if(port < 8)
return rtl8367c_setAsicRegBits(RTL8367C_REG_UNKNOWN_UNICAST_DA_PORT_BEHAVE, RTL8367C_Port0_ACTION_MASK << (port * 2), behavior);
else
return rtl8367c_setAsicRegBits(RTL8367C_REG_UNKNOWN_UNICAST_DA_PORT_BEHAVE_EXT, RTL8367C_PORT8_ACTION_MASK << ((port-8) * 2), behavior);
}

The above function is used to set all the ports which are not configured as the port type.  When an unknown unicast frame comes, which is not configured as the port type, the corresponding port number is taken as the default value.

If port type is configured




NEXT




<s> ar8327_cleanup(struct ar8xxx_priv *priv)
{
ar8327_leds_cleanup(priv);
}

The above function is used to clean up all the remaining resources for
this device before releasing it.

ar8327_leds_cleanup(struct ar8xxx_priv *priv)
{
if (priv->leds)
{
if




NEXT




<s> set_recv_type(pcap_t *p, bool rx)
{
#ifdef PACKET_RECV_TYPE
struct sockaddr_ll sll;
struct ifreq ifr;
int mask;
int fd;

fd = pcap_get_selectable_fd(p);
if (fd < 0)
return;

if (rx)
mask = 1 << PACKET_BROADCAST;
else
mask = 0;

setsockopt(fd, SOL_PACKET, PACKET_RECV_TYPE, &mask, sizeof(mask));
#endif
}

The above function is used to modify the packet filters at Linux 2.*.
#define SIOCGIF Index IFF_*/
set_filter(pcap_t *p)
{
struct rt_ifinfo *pIf;
bpf_




NEXT




<s> uc_hostapd_iface_stop(uc_vm_t *vm, size_t nargs)
{
struct hostapd_iface *iface = uc_fn_thisval("hostapd.iface");
int i;

if (!iface)
return NULL;

if (iface->state != HAPD_IFACE_ENABLED)
uc_hostapd_disable_iface(iface);

for (i = 0; i < iface->num_bss; i++) {
struct hostapd_data *hapd = iface->bss[i];

hostapd_drv_stop_ap(hapd);
hapd->beacon_set_done = 0;
}

return NULL;
}

The above function is used to stop the hostapd_iface_stop from iface</s>




NEXT




<s> inline void rtl839x_exec_tbl2_cmd(u32 cmd)
{
sw_w32(cmd, RTL839X_TBL_ACCESS_CTRL_2);
do { } while (sw_r32(RTL839X_TBL_ACCESS_CTRL_2) & (1 << 9));
}

The above function is used to send a command to the TBL2 engine (TBL1 used by the main CPU when no other processor is running).

For example, to do a broadcast Tx DES, write to the register (not shown here):

sw




NEXT




<s> rtk_api_ret_t rtk_svlan_c2s_del(rtk_vlan_t vid, rtk_port_t src_port)
{
rtk_api_ret_t retVal;
rtk_uint32 i;
rtk_uint32 evid, pmsk, svidx;
rtk_port_t phyPort;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (vid > RTL8367C_EVIDMAX)
return RT_ERR_VLAN_VID;

/* Check port Valid */
RTK_CHK_PORT_VALID(src_port);
phyPort = rtk_switch_port_L2P_get(src_port);

for (i = 0; i <= RTL8367C_C2SIDXMAX; i++)
{
if ((retVal = rtl8367c_getAsicSvlanC2SConf(i, &evid, &pmsk, &svidx)) != RT_ERR_OK)
return retVal;

if (evid == vid)
{
if(pmsk & (1 << phyPort))
{
pmsk = pmsk & ~(1 << phyPort);
if(pmsk == 0)
{
vid = 0;
svidx = 0;
}

if ((retVal = rtl8367c_setAsicSvlanC2SConf(i, vid, pmsk, svidx)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}
}
}

return RT_ERR_OUT_OF_RANGE;
}

The above function is used to delete the associated port of a service tagged C to S vlan entry.

It is useful when we want to change the service tagged VLAN entry associated with a specific port where it exists. First, we need to get the service




NEXT




<s> void __init tl_wdr4900_v1_pic_init(void)
{
struct mpic *mpic = mpic_alloc(NULL, 0, MPIC_BIG_ENDIAN |
MPIC_SINGLE_DEST_CPU,
0, 256, " OpenPIC  ");

BUG_ON(mpic == NULL);

mpic_init(mpic);
}

The above function is used to initialize the OpenPIC devices found in the
V1 board.

I'll attach 14 snapshots and 6 snapshots of V1 as well.

In V1, there are 2 OpenPIC devices




NEXT




<s> ret_t rtl8367c_setAsicFlowControlJumboMode(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_FLOWCTRL_JUMBO_SIZE, RTL8367C_JUMBO_MODE_OFFSET, enabled);
}

The above function is used to set jumbo frame flow control mode.
RTL8367C will flow control downstream to the NIC by setting the 7th bit of the jumbo frame size register, namely jumbo mode (rtl




NEXT




<s> hostapd_bss_transition_request(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *ureq, const char *method,
struct blob_attr *msg)
{
struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
struct blob_attr *tb[__BSS_TR_DISASSOC_MAX];
struct sta_info *sta;
u32 da_timer = 0;
u32 valid_period = 0;
u8 addr[ETH_ALEN];
u32 dialog_token = 1;
bool abridged;
bool da_imminent;
u8 mbo_reason;
u8 cell_pref;
u8 reassoc_delay;

blobmsg_parse(bss_tr_policy, __BSS_TR_DISASSOC_MAX, tb, blob_data(msg), blob_len(msg));

if (!tb[BSS_TR_ADDR])
return UBUS_STATUS_INVALID_ARGUMENT;

if (hwaddr_aton(blobmsg_data(tb[BSS_TR_ADDR]), addr))
return UBUS_STATUS_INVALID_ARGUMENT;

if (tb[BSS_TR_DA_TIMER])
da_timer = blobmsg_get_u32(tb[BSS_TR_DA_TIMER]);

if (tb[BSS_TR_VALID_PERIOD])
valid_period = blobmsg_get_u32(tb[BSS_TR_VALID_PERIOD]);

if (tb[BSS_TR_DIALOG_TOKEN])
dialog_token = blobmsg_get_u32(tb[BSS_TR_DIALOG_TOKEN]);

da_imminent = !!(tb[BSS_TR_DA_IMMINENT] && blobmsg_get_bool(tb[BSS_TR_DA_IMMINENT]));
abridged = !!(tb[BSS_TR_ABRIDGED] && blobmsg_get_bool(tb[BSS_TR_ABRIDGED]));

#ifdef CONFIG_MBO
if (tb[BSS_TR_MBO_REASON])
mbo_reason = blobmsg_get_u32(tb[BSS_TR_MBO_REASON]);

if (tb[BSS_TR_CELL_PREF])
cell_pref = blobmsg_get_u32(tb[BSS_TR_CELL_PREF]);

if (tb[BSS_TR_REASSOC_DELAY])
reassoc_delay = blobmsg_get_u32(tb[BSS_TR_REASSOC_DELAY]);
#endif

return hostapd_bss_tr_send(hapd, addr, da_imminent, abridged, da_timer, valid_period,
dialog_token, tb[BSS_TR_NEIGHBORS], mbo_reason, cell_pref, reassoc_delay);
}

The above function is used to generate and send the bss_tr_policy message on invoking the "BSS transition request" module.</s>




NEXT




<s> static int fe_get_sset_count(struct net_device *dev, int sset)
{
switch (sset) {
case ETH_SS_STATS:
return ARRAY_SIZE(fe_gdma_str);
default:
return -EOPNOTSUPP;
}
}

The above function is used to get the number of sysctl variables for
specific type of information like ETH_SS_STATS. However, the value that
I need here is the total number of sysctl variables not the number of
sysctl variables related to DMA




NEXT




<s> void expr_gstr_print(struct expr *e, struct gstr *gs)
{
expr_print(e, expr_print_gstr_helper, gs, E_NONE);
}

The above function is used to print the values on the stack, as well as the values for each expression. I had to create a helper function which basically does the same thing as the above function, except it will only print the expressions.

void expr_print_g




NEXT




<s> static int aes_cbcmac_init_tfm(struct crypto_tfm *tfm)
{
struct aes_ctx *mctx = crypto_tfm_ctx(tfm);
mctx->temp = kzalloc(AES_BLOCK_SIZE * AES_CBCMAC_DBN_TEMP_SIZE, GFP_KERNEL);
if (IS_ERR(mctx->temp)) return PTR_ERR(mctx->temp);

return 0;
}

The above function is used to initialize AES_CBCMAC transform context. mctx->temp is used as a temporary buffer used for AES encryption.

static int aes_cbcmac_update_tfm(struct crypto_tfm *tfm




NEXT




<s> ret_t rtl8367c_getAsicIGMPIsoLeaky(rtk_uint32 *pLeaky)
{
ret_t   retVal;
rtk_uint32  regData;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_PORTISO_LEAKY_OFFSET, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pLeaky = regData;
return RT_ERR_OK;
}

The above function is used to get the asic igmp leaky configuration.</s>




NEXT




<s> int dc_ep_gpio_src_set(struct dc_ep_priv *priv, u32 gpio, int val)
{
struct dc_aca *aca = to_aca(priv);

if (gpio > aca->max_gpio)
return -EINVAL;

mutex_lock(&aca->pin_lock);
if (!!val)
padc_setbit(gpio, PADC_SRC);
else
padc_clearbit(gpio, PADC_SRC);
mutex_unlock(&aca->pin_lock);
return 0;
}

The above function is used to send a PACD_SRC control bit (set high) when a source connection is made to one of the GPIO pins. The function should return and error code of 0 if the command was successful.

I'm thinking that




NEXT




<s> ret_t rtl8367c_setAsicCputagEnable(rtk_uint32 enabled)
{
if(enabled > 1)
return RT_ERR_ENABLE;

return rtl8367c_setAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_EN_OFFSET, enabled);
}

The above function is used to enable/disable Cputag in RT3082 and RT3592. In both cases, the function must return RT_ERR_ENABLE on input invalid. In RT3082, when the parameter enabled > 1




NEXT




<s> static int ip17xx_set_tagged(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);

state->add_tag &= ~(1<<val->port_vlan);
state->remove_tag &= ~(1<<val->port_vlan);

if (val->value.i == 0)
state->remove_tag |= (1<<val->port_vlan);
if (val->value.i == 1)
state->add_tag |= (1<<val->port_vlan);

return state->regs->update_state(state);
}

The above function is used to control the per port vlan tag on the PFE. In the function above you
can see that we take care of removing tag when the value passed in the val->value.i is 0 and vice-versa.

Follow




NEXT




<s> void __exit psb6970_exit(void)
{
phy_driver_unregister(&psb6970_driver);
}

The above function is used to return resources allocated in the init call as well as to unmap any internal structures that may have been created on the fly. You should call psb6970_exit in the device removal function (called when the driver is unloaded from




NEXT




<s> static void msdc_dump_rca_resp(struct msdc_host *host, u32 resp)
{
u32 status = (((resp >> 15) & 0x1) << 23) |
(((resp >> 14) & 0x1) << 22) |
(((resp >> 13) & 0x1) << 19) |
(resp & 0x1fff);

N_MSG(RSP, "[RCA] 0x%.4x", resp >> 16);
msdc_dump_card_status(host, status);
}

The above function is used to dump card status register after writing a CMD (CMD8, CMD12, CMD13). The above function calls msdc_dump_card_status(), which is defined as follows:
#if IS_ENABLED(




NEXT




<s> int rtl83xx_port_is_under(const struct net_device * dev, struct rtl838x_switch_priv *priv)
{
/* TODO: On 5.12:
* 	if(!dsa_slave_dev_check(dev)) {
*		netdev_info(dev, "%s: not a DSA device.\n", __func__);
*		return -EINVAL;
*	}
*/

for (int i = 0; i < priv->cpu_port; i++) {
if (!priv->ports[i].dp)
continue;
if (priv->ports[i].dp->slave == dev)
return i;
}

return -EINVAL;
}

The above function is used to determine if the specified port device corresponds to a specific cpu port or not, for example, if an CPU port corresponds to a DSA Device, and the function uses the following to determine whether the corresponding CPU port corresponds to a DSA Device or not




NEXT




<s> static u64 rttm_read_clocksource(struct clocksource *cs)
{
struct rttm_cs *rcs = container_of(cs, struct rttm_cs, cs);

return (u64)rttm_get_counter(rcs->to.of_base.base);
}

The above function is used to read the values of the counter. I need to understand the logic behind this, if any. It is not very clear to me whether u64 is a pointer to a u64 type or it is u64 itself. Could anyone please




NEXT




<s> void rtk_hal_qos_get_port2pri(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;
rtk_pri_t Int_pri;

ret = rtk_qos_portPri_get(data->port, &Int_pri);
if (ret != 0)
printk("rtk_qos_portPri_set failed\n");
else
printk("port%d priority = %d\n", data->port, Int_pri);
}

The above function is used to config the QoS class to port map</s>




NEXT




<s> void ar9_init(struct platform_device *pdev)
{
init_pmu();
reset_ppe(pdev);
init_ema();
init_mailbox();
clear_share_buffer();
}

The above function is used to initialize the ar9 device driver at runtime. So why don’t you guys find “ar9_init” in the sources and add the appropriate code in it to dump your desired buffers?

As for the mailbox, the “struct




NEXT




<s> static int qca807x_gpio_get_reg(unsigned int offset)
{
return QCA807X_MMD7_LED_100N_2 + (offset % 2) * 2;
}

The above function is used to initialize this LED driver for this particular board. The above function was created because the mpc8316 has 10 bits of GPIO data registers.

There are eight GPIO pins each with 11 bits available for data so




NEXT




<s> static int rtl8366rb_sw_set_learning_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 portmask = 0;
int err = 0;

if (!val->value.i)
portmask = RTL8366RB_PORT_ALL;

/* set learning for all ports */
REG_WR(smi, RTL8366RB_SSCR0, portmask);

/* set auto ageing for all ports */
REG_WR(smi, RTL8366RB_SSCR1, portmask);

return 0;
}

The above function is used to allow the switch to learn the MAC address from an
ethernet frame. In the following line, we set up a mask to make sure we are
modifying the bit positions in the RTL8366RB_SSCR0 register




NEXT




<s> static int mtdsplit_parse_bcm63xx(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct bcm_tag hdr;
loff_t offset;

if (mtd_type_is_nand(master))
return -EINVAL;

/* find bcm63xx_cfe image on erase block boundaries */
for (offset = 0; offset < master->size; offset += master->erasesize) {
if (!bcm63xx_read_image_tag(master, offset, (void *) &hdr))
return bcm63xx_parse_partitions(master, pparts,
(void *) &hdr);
}

return -EINVAL;
}

The above function is used to parse the BCM_TAG structure found within a BIOS
image located inside the first erase block on a NOR. It returns if the
BIOS_HEADER is found within the BIOS image.

# bcm




NEXT




<s> static int ar934x_nfc_send_read(struct ar934x_nfc *nfc, unsigned command,
int column, int page_addr, int len)
{
u32 cmd_reg;
int err;

nfc_dbg(nfc, "read, column=%d page=%d len=%d\n",
column, page_addr, len);

cmd_reg = (command & AR934X_NFC_CMD_CMD0_M) << AR934X_NFC_CMD_CMD0_S;

if (nfc->small_page) {
cmd_reg |= AR934X_NFC_CMD_SEQ_18;
} else {
cmd_reg |= NAND_CMD_READSTART << AR934X_NFC_CMD_CMD1_S;
cmd_reg |= AR934X_NFC_CMD_SEQ_1C5A1CXR;
}

err = ar934x_nfc_do_rw_command(nfc, column, page_addr, len,
cmd_reg, nfc->ctrl_reg, false);

nfc_debug_data("[data] ", nfc->buf, len);

return err;
}

The above function is used to read the data from the memory and then checks in

the following function, check for any data present or not.
The nfc->ctrl_reg = it's used to maintain the control register of the device.

This function




NEXT




<s> static int ssb_fbs_set(struct ssb_fbs *priv, struct device_node *node)
{
struct ssb_sprom *sprom = &priv->sprom;
const struct firmware *fw;
const char *sprom_name;
int err;

if (of_property_read_string(node, "brcm,sprom", &sprom_name))
sprom_name = NULL;

if (sprom_name) {
err = request_firmware_direct(&fw, sprom_name, priv->dev);
if (err)
dev_err(priv->dev, "%s load error\n", sprom_name);
} else {
err = -ENOENT;
}

if (err) {
sprom->revision = 0x02;
sprom->board_rev = 0x0017;
sprom->country_code = 0x00;
sprom->ant_available_bg = 0x03;
sprom->pa0b0 = 0x15ae;
sprom->pa0b1 = 0xfa85;
sprom->pa0b2 = 0xfe8d;
sprom->pa1b0 = 0xffff;
sprom->pa1b1 = 0xffff;
sprom->pa1b2 = 0xffff;
sprom->gpio0 = 0xff;
sprom->gpio1 = 0xff;
sprom->gpio2 = 0xff;
sprom->gpio3 = 0xff;
sprom->maxpwr_bg = 0x4c;
sprom->itssi_bg = 0x00;
sprom->boardflags_lo = 0x2848;
sprom->boardflags_hi = 0x0000;
priv->devid_override = false;

dev_warn(priv->dev, "using basic SPROM\n");
} else {
size_t size = min(fw->size, (size_t) SSB_FBS_MAX_SIZE);
u16 tmp_sprom[SSB_FBS_MAX_SIZE >> 1];
u32 i, j;

for (i = 0, j = 0; i < size; i += 2, j++)
tmp_sprom[j] = (fw->data[i] << 8) | fw->data[i + 1];

release_firmware(fw);
ssb_fbs_fixup(priv, tmp_sprom);
sprom_extract(priv, tmp_sprom, size >> 1);

priv->devid_override = sprom_override_devid(priv, sprom,
tmp_sprom);
}

return 0;
}

The above function is used to read and load the SPROM information to the struct ssb_sprom and make it available for the driver. Once when all the required functions such as ssb_init, probe and so on of the SPROM driver are complete,




NEXT




<s> static bool nmbm_block_walk_asc(struct nmbm_instance *ni, uint32_t ba,
uint32_t *nba, uint32_t count,
uint32_t limit)
{
int32_t nblock = count;

if (limit >= ni->block_count)
limit = ni->block_count - 1;

while (ba < limit) {
if (nmbm_get_block_state(ni, ba) == BLOCK_ST_GOOD)
nblock--;

if (nblock < 0) {
*nba = ba;
return true;
}

ba++;
}

return false;
}

The above function is used to efficiently walk a nmbm file in the ascending order,
since this is what we are interested in. At the same time there is a version of
the function that walks the opposite way (nmbm_block_walk_desc




NEXT




<s> static void item_make(struct menu *menu, char tag, const char *fmt, ...)
{
va_list ap;

if (items_num > MAX_MENU_ITEMS-1)
return;

bzero(&k_menu_items[items_num], sizeof(k_menu_items[0]));
k_menu_items[items_num].tag = tag;
k_menu_items[items_num].usrptr = menu;
if (menu != NULL)
k_menu_items[items_num].is_visible =
menu_is_visible(menu);
else
k_menu_items[items_num].is_visible = 1;

va_start(ap, fmt);
vsnprintf(k_menu_items[items_num].str,
sizeof(k_menu_items[items_num].str),
fmt, ap);
va_end(ap);

if (!k_menu_items[items_num].is_visible)
memcpy(k_menu_items[items_num].str, "XXX", 3);

curses_menu_items[items_num] = new_item(
k_menu_items[items_num].str,
k_menu_items[items_num].str);
set_item_userptr(curses_menu_items[items_num],
&k_menu_items[items_num]);
/*
if (!k_menu_items[items_num].is_visible)
item_opts_off(curses_menu_items[items_num], O_SELECTABLE);
*/

items_num++;
curses_menu_items[items_num] = NULL;
}

The above function is used to add some entries to the Curses menu based on the entries that are in the menu, i. e. "menu_is_visible()" for the Curses widget.

Note that we need to add the "XXX




NEXT




<s> static int sata_oxnas_suspend(struct platform_device *op, pm_message_t state)
{
struct ata_host *host = dev_get_drvdata(&op->dev);

return ata_host_suspend(host, state);
}

The above function is used to do any action related to suspending the device. A lot of actions are required when suspending a device. In this function we will take care of all of them. We begin by saving some driver data in the first line and then we make a




NEXT




<s> u32 sata_oxnas_link_read(struct ata_port *ap, unsigned int link_reg)
{
struct sata_oxnas_port_priv *pd = ap->private_data;
struct sata_oxnas_host_priv *hd = ap->host->private_data;
void __iomem *port_base = pd->port_base;
u32 result;
u32 patience;
unsigned long flags;

spin_lock_irqsave(&hd->phy_lock, flags);
/* accessed twice as a work around for a bug in the SATA abp bridge
* hardware (bug 6828) */
iowrite32(link_reg, port_base + LINK_RD_ADDR);
ioread32(port_base + LINK_RD_ADDR);

for (patience = 0x100000; patience > 0; --patience) {
if (ioread32(port_base + LINK_CONTROL) & 0x00000001)
break;
}
if (patience == 0)
DPRINTK("link read timed out for port %d\n", ap->port_no);

result = ioread32(port_base + LINK_DATA);
spin_unlock_irqrestore(&hd->phy_lock, flags);

return result;
}

The above function is used to set the current port's link status variable, link_reg, to the value stored in its link reg at offset LINK_REG from the IO mapped port_base. The function then gets the value of link status register from the SATA




NEXT




<s> static int check_block(off_t pos, uint32_t sector)
{
if (!check_sector(pos)) {
return 0;
}
if (read_sector(pos)) {
return 0;
}
if (read_uint64(readbuf, 0x00) != TFFS_BLOCK_HEADER_MAGIC) {
fprintf(stderr, "Warning: block without magic header. Skipping block\n");
return 0;
}
if (read_uint32(readbuf, 0x0c) != TFFS_SECTORS_PER_PAGE) {
fprintf(stderr, "Warning: block with wrong number of sectors per page. Skipping block\n");
return 0;
}

uint32_t num_hdr_bad = read_uint32(readbuf, 0x0c);
for (uint32_t i = 0; i < num_hdr_bad; i++) {
uint32_t bad = sector + read_uint64(readbuf, 0x1c + sizeof(uint64_t)*i);
sector_mark_bad(bad);
}

return 1;
}

The above function is used to check the block. The return value is set to true if check on that block sucessed or false otherwise. It is called for the blocks that are marked for check as we go through the free clusters list. We found that when we first start




NEXT




<s> ret_t rtl8367c_getAsicRldpRandomNumber(ether_addr_t *pRandNumber)
{
ret_t retVal;
rtk_uint32 regData;
rtk_int16 accessPtr[3];
rtk_uint32 i;

for(i = 0; i < 3; i++)
{
retVal = rtl8367c_getAsicReg(RTL8367C_RLDP_RAND_NUM_REG_BASE+ i, &regData);
if(retVal != RT_ERR_OK)
return retVal;

accessPtr[i] = regData;
}

memcpy(pRandNumber, accessPtr, 6);
return retVal;
}

The above function is used to get the RLDP random number. As it uses the access pointer accessPtr[i], the function returns after it reads the last register.</s>




NEXT




<s> static int rtl8367c_get_port_mib_counter(int idx, int port, unsigned long long *counter)
{
return rtk_stat_port_get(rtl8367c_sw_to_phy_port(port), idx, counter);
}

The above function is used to obtain all MIB counter of a port.
Ideally, you could retrieve the following statistics:

Counters (Index Value) Supported by Device.
15415    	Total Received Packets
13




NEXT




<s> ret_t rtl8367c_getAsicSvlanUnmatchVlan(rtk_uint32* pIndex)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_UNTAG_UNMAT_CFG, RTL8367C_VS_UNMAT_SVIDX_MASK, pIndex);
}

The above function is used to get the s-vid index associated with untagged VLANs which should be unmatched.

Here is a simplified table describing the VLAN related registers

RTL8367C VLAN register mappings






NEXT




<s> ret_t rtl8367c_setAsicFlowControlDropAll(rtk_uint32 dropall)
{
if(dropall >= RTL8367C_PAGE_NUMBER)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_CTRL0, RTL8367C_DROP_ALL_THRESHOLD_MASK, dropall);
}

The above function is used to config the drop all packet threshold with flow control control 0 register.

When we execute the following code:

{
rtk_uint32 drop, dropAll;

RT_BLD_NONE;

RT




NEXT




<s> static bool rtl930x_pie_templ_has(int t, enum template_field_id field_type)
{
for (int i = 0; i < N_FIXED_FIELDS; i++) {
enum template_field_id ft = fixed_templates[t][i];
if (field_type == ft)
return true;
}

return false;
}

The above function is used to find if a list of fixed templates (in file template_list.c) a given type of template field from a template t. For example, rtl930x_pie_templ_has(1, TEMPL_




NEXT




<s> static u8 rb4xx_nand_read_byte(struct nand_chip *chip)
{
struct rb4xx_nand *nand = chip->priv;
struct rb4xx_cpld *cpld = nand->cpld;
u8 data;
int ret;

ret = cpld->read_nand(cpld, &data, 1);
if (unlikely(ret))
return 0xff;

return data;
}

The above function is used to read the NAND data. It is an implementation of the NAND read function, nand_read_byte(), from mmc_block.h. In this case, rb4xx_read_byte() does its stuff by calling cp




NEXT




<s> rtk_api_ret_t rtk_l2_floodPortMask_get(rtk_l2_flood_type_t floood_type, rtk_portmask_t *pFlood_portmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (floood_type >= FLOOD_END)
return RT_ERR_INPUT;

if(NULL == pFlood_portmask)
return RT_ERR_NULL_POINTER;

switch (floood_type)
{
case FLOOD_UNKNOWNDA:
if ((retVal = rtl8367c_getAsicPortUnknownDaFloodingPortmask(&pmask)) != RT_ERR_OK)
return retVal;
break;
case FLOOD_UNKNOWNMC:
if ((retVal = rtl8367c_getAsicPortUnknownMulticastFloodingPortmask(&pmask)) != RT_ERR_OK)
return retVal;
break;
case FLOOD_BC:
if ((retVal = rtl8367c_getAsicPortBcastFloodingPortmask(&pmask)) != RT_ERR_OK)
return retVal;
break;
default:
break;
}

/* Get Logical port mask */
if ((retVal = rtk_switch_portmask_P2L_get(pmask, pFlood_portmask))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the logical port mask of the designated mode.
The function prototypes of the function is:

rtk_api_ret_t rtk_fdd_l2_floodPortMask_get(rtk




NEXT




<s> static int process_next_packet(struct aes_container *aes_con, struct ablkcipher_request *areq,
int state)
{
u8 *iv;
int mode, dir, err = -EINVAL;
unsigned long queue_flag;
u32 inc, nbytes, remain, chunk_size;
struct scatterlist *src = NULL;
struct scatterlist *dst = NULL;
struct crypto_ablkcipher *cipher;
struct aes_ctx *ctx;

spin_lock_irqsave(&aes_queue->lock, queue_flag);

dir = aes_con->encdec;
mode = aes_con->mode;
iv = aes_con->iv;

if (state & PROCESS_SCATTER) {
src = scatterwalk_sg_next(areq->src);
dst = scatterwalk_sg_next(areq->dst);

if (!src || !dst) {
spin_unlock_irqrestore(&aes_queue->lock, queue_flag);
return 1;
}
}
else if (state & PROCESS_NEW_PACKET) {
src = areq->src;
dst = areq->dst;
}

remain = aes_con->bytes_processed;
chunk_size = src->length;

if (remain > DEU_MAX_PACKET_SIZE)
inc = DEU_MAX_PACKET_SIZE;
else if (remain > chunk_size)
inc = chunk_size;
else
inc = remain;

remain -= inc;
aes_con->nbytes = inc;

if (state & PROCESS_SCATTER) {
aes_con->src_buf += aes_con->nbytes;
aes_con->dst_buf += aes_con->nbytes;
}

lq_sg_init(aes_con, src, dst);

nbytes = aes_con->nbytes;

//printk("debug - Line: %d, func: %s, reqsize: %d, scattersize: %d\n",
//          __LINE__, __func__, nbytes, chunk_size);

cipher = crypto_ablkcipher_reqtfm(areq);
ctx = crypto_ablkcipher_ctx(cipher);


if (aes_queue->hw_status == AES_IDLE)
aes_queue->hw_status = AES_STARTED;

aes_con->bytes_processed -= aes_con->nbytes;
err = ablkcipher_enqueue_request(&aes_queue->list, &aes_con->arequest);
if (err == -EBUSY) {
spin_unlock_irqrestore(&aes_queue->lock, queue_flag);
printk("Failed to enqueue request, ln: %d, err: %d\n",
__LINE__, err);
return -EINVAL;
}

spin_unlock_irqrestore(&aes_queue->lock, queue_flag);

err = lq_deu_aes_core(ctx, aes_con->dst_buf, aes_con->src_buf, iv, nbytes, dir, mode);
return err;

}

The above function is used to enqueue a crypt session into a packet and pass the packet to the DEU's. The hardware has a packet engine to enqueue the packet and pass it through the encryption engine.

We need to get a reference to the hardware,




NEXT




<s> static void rtl83xx_get_strings(struct dsa_switch *ds,
int port, u32 stringset, u8 *data)
{
if (stringset != ETH_SS_STATS)
return;

for (int i = 0; i < ARRAY_SIZE(rtl83xx_mib); i++)
ethtool_puts(&data, rtl83xx_mib[i].name);
}

The above function is used to export all of our MIB information to ethtool
on port 0.

static int rtl83xx_setup(struct net_device *dev)
{
int port;
int lport;

struct




NEXT




<s> int xts_aes_set_key_skcipher (struct crypto_skcipher *tfm, const u8 *in_key, unsigned int key_len)
{
struct aes_ctx *ctx = crypto_tfm_ctx(crypto_skcipher_tfm(tfm));
unsigned int keylen = (key_len / 2);

if (key_len % 2) return -EINVAL;

if (keylen != 16 && keylen != 24 && keylen != 32) {
return -EINVAL;
}

ctx->key_length = keylen;
ctx->use_tweak = 0;
DPRINTF(0, "ctx @%p, key_len %d, ctx->key_length %d\n", ctx, key_len, ctx->key_length);
memcpy ((u8 *) (ctx->buf), in_key, keylen);
memcpy ((u8 *) (ctx->tweakkey), in_key + keylen, keylen);

return 0;
}

The above function is used to set and get the key. In the above function, we convert the passed key in_key of length key_len of bytes into AES 128 or 192 or 256 bit depending on the user supplied key




NEXT




<s> struct menu *menu_get_root_menu(struct menu *menu)
{
return &rootmenu;
}

The above function is used to get the root menu which is in the static var. There we can create a custom menu structure with our own data and send it while calling the code with a root menu.</s>




NEXT




<s> static int rttm_enable_clocksource(struct clocksource *cs)
{
struct rttm_cs *rcs = container_of(cs, struct rttm_cs, cs);

rttm_disable_irq(rcs->to.of_base.base);
rttm_setup_timer(rcs->to.of_base.base);
rttm_enable_timer(rcs->to.of_base.base, RTTM_CTRL_TIMER,
rcs->to.of_clk.rate / RTTM_TICKS_PER_SEC);

return 0;
}

The above function is used to enable/start the clocksource and can be used from a clock_setup routine which typically looks like the following:

int rttm_clock_setup(struct clocksource *cs)
{
int ret = 0;





NEXT




<s> ret_t rtl8367c_setAsicSvlanUntagVlan(rtk_uint32 index)
{
if(index > RTL8367C_SVIDXMAX)
return RT_ERR_SVLAN_ENTRY_INDEX;

return rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_UNTAG_UNMAT_CFG, RTL8367C_VS_UNTAG_SVIDX_MASK, index);
}

The above function is used to modify the VS_UNTAG_SVIDX field [0–31] with the corresponding index value for a specific SVLAN entry in the SVLAN Untag Vlan table.

ret_t rtl836




NEXT




<s> void BN_free(BIGNUM *a)
{
if (a == NULL) return;
if ((a->d != NULL) && !(BN_get_flags(a,BN_FLG_STATIC_DATA)))
free(a->d);
a->flags|=BN_FLG_FREE; /* REMOVE? */
if (a->flags & BN_FLG_MALLOCED)
free(a);
}

The above function is used to free the memory allotted to BIGNUM in case the above bit is set, but in case of small memory allocation the size is 16 bytes, in this case we dont release the memory just sets the flag.

Hence my




NEXT




<s> static void rtl838x_route_write(int idx, struct rtl83xx_route *rt)
{
/* Access ROUTING table (2) via register RTL8380_TBL_1 */
struct table_reg *r = rtl_table_get(RTL8380_TBL_1, 2);

pr_debug("In %s, id %d, gw: %016llx\n", __func__, idx, rt->nh.gw);
sw_w32(rt->nh.gw >> 32, rtl_table_data(r, 0));
sw_w32(rt->nh.gw, rtl_table_data(r, 1));
rtl_table_write(r, idx);

rtl_table_release(r);
}

The above function is used to write routing entry to the RTL8380_TBL_1 register.

However, the below code doesn’t seem to work, where does it fail?

struct table_reg *r = rtl_




NEXT




<s> ead_decrypt_message(struct ead_msg *msg)
{
struct ead_msg_encrypted *enc = EAD_DATA(msg, enc);
unsigned char *data = (unsigned char *) enc;
uint32_t hash_old[5], hash_new[5];
int len = ntohl(msg->len);
int i, enclen = len;

if (!len || (len % EAD_ENC_PAD > 0))
return 0;

while (len > 0) {
rijndaelDecrypt(aes_dec_ctx, data, data);
data += 16;
len -= 16;
}

data = (unsigned char *) enc;

if (enc->pad >= EAD_ENC_PAD) {
DEBUG(2, "Invalid padding length\n");
return 0;
}

if (!ead_check_rx_iv(ntohl(enc->iv))) {
DEBUG(2, "RX IV mismatch (0x%08x <> 0x%08x)\n", ead_rx_iv, ntohl(enc->iv));
return 0;
}

for (i = 0; i < 5; i++)
hash_old[i] = ntohl(enc->hash[i]);
ead_hash_message(enc, hash_new, enclen);
if (memcmp(hash_old, hash_new, sizeof(hash_old)) != 0) {
DEBUG(2, "SHA1 mismatch (0x%08x != 0x%08x), len=%d\n", hash_old[0], hash_new[0], enclen);
return 0;
}

enclen -= enc->pad + sizeof(struct ead_msg_encrypted);
return enclen;
}

The above function is used to decrypt the message which is received as an encrypted form. At first we should need to check the encrypting length and we should make sure that the length should not be greater than the maximum possible length. Also we should check that the message




NEXT




<s> static void espi_release_bus(struct fsl_spi *fsl)
{
/* Disable the SPI hardware */
out_be32(&fsl->espi->mode,
in_be32(&fsl->espi->mode) & (~ESPI_MODE_EN));
}

The above function is used to release the SPI bus after completion of a transaction. It is also used to release a currently held SPI bus before a subsequent transaction.

The corresponding function to request and acquire the bus as defined in the driver specification is implemented here.






NEXT




<s> ret_t rtl8367c_setAsicTrunkingGroup(rtk_uint32 group, rtk_uint32 portmask)
{
if(group > RTL8367C_MAX_TRUNK_GID)
return RT_ERR_LA_TRUNK_ID;
return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_GROUP_MASK, RTL8367C_PORT_TRUNK_GROUP0_MASK_MASK << (group * 4), portmask);
}

The above function is used to update the portmask of a certain group
It seems to have a bit of error. It is a little different from the register I saw. The upper register is
32'b100000000000




NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_cfg_delAll(void)
{
rtk_uint32            i;
rtk_api_ret_t     ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

for(i = 0; i < RTL8367C_ACLRULENO; i++)
{
if((ret = rtl8367c_setAsicAclActCtrl(i, FILTER_ENACT_INIT_MASK))!= RT_ERR_OK)
return ret;
if((ret = rtl8367c_setAsicAclNot(i, DISABLED)) != RT_ERR_OK )
return ret;
}

return rtl8367c_setAsicRegBit(RTL8367C_REG_ACL_RESET_CFG, RTL8367C_ACL_RESET_CFG_OFFSET, TRUE);;
}

The above function is used to clear the specified ACL configuration.

It clears the configuration of all ACL units to the default condition.
#else
                    #error "rtl8195 family does not support this functions. "
#endif




NEXT




<s> const cipher_t *get_cipher_or_print_error(char *name)
{
const mbedtls_cipher_info_t *cipher;

cipher = mbedtls_cipher_info_from_string(upperstr(name));
if (cipher)
return cipher;

fprintf(stderr, "Error: invalid cipher: %s.\n", name);
fprintf(stderr, "Supported ciphers: \n");
for (const int *list = mbedtls_cipher_list(); *list; list++) {
cipher = mbedtls_cipher_info_from_type(*list);
if (!cipher)
continue;
fprintf(stderr, "\t%s\n", cipher->name);
}
return NULL;
}

The above function is used to check whether the cipher is supported or not,
if the cipher is supported, then the cipher_t structure is returned,
otherwise, an error message is printed and program is terminated.

To run the program,




NEXT




<s> static void write_key(mbedtls_pk_context *key, const char *path, bool pem)
{
int len = 0;

if (pem) {
if (mbedtls_pk_write_key_pem(key, (void *) buf, sizeof(buf)) == 0)
len = strlen(buf);
} else {
len = mbedtls_pk_write_key_der(key, (void *) buf, sizeof(buf));
if (len < 0)
len = 0;
}

write_file(path, len, pem, false);
}

The above function is used to dump the public or private keys to the corresponding dump file.</s>




NEXT




<s> void dc_aca_txin_sub_ack(struct dc_ep_priv *priv, u32 val)
{
wr32(val, TXIN_ACA_ACCUM_SUB);
}

The above function is used to send data to the client.

Upon first sight, it seemed pretty straight forward. However, things got complicated when the following code was discovered.

if (i == 0x04)
return;

static void




NEXT




<s> mt7530_get_port_link(struct switch_dev *dev,  int port,
struct switch_port_link *link)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
u32 speed, pmsr;

if (port < 0 || port >= MT7530_NUM_PORTS)
return -EINVAL;

pmsr = mt7530_r32(priv, 0x3008 + (0x100 * port));

link->link = pmsr & 1;
link->duplex = (pmsr >> 1) & 1;
speed = (pmsr >> 2) & 3;

switch (speed) {
case 0:
link->speed = SWITCH_PORT_SPEED_10;
break;
case 1:
link->speed = SWITCH_PORT_SPEED_100;
break;
case 2:
case 3: /* forced gige speed can be 2 or 3 */
link->speed = SWITCH_PORT_SPEED_1000;
break;
default:
link->speed = SWITCH_PORT_SPEED_UNKNOWN;
break;
}

return 0;
}

The above function is used to query the attributes of the port, and the structure parameters are:

struct switch_dev *dev: The switch device pointer.

int port: The port to be queried.

struct switch_port_link *link:




NEXT




<s> ret_t rtl8367c_setAsicLedIndicateInfoConfig(rtk_uint32 ledno, rtk_uint32 config)
{
ret_t   retVal;
CONST rtk_uint16 bits[RTL8367C_LEDGROUPNO] = {RTL8367C_LED0_CFG_MASK, RTL8367C_LED1_CFG_MASK, RTL8367C_LED2_CFG_MASK};

if(ledno >= RTL8367C_LEDGROUPNO)
return RT_ERR_OUT_OF_RANGE;

if(config >= LEDCONF_END)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_CONFIGURATION, RTL8367C_LED_CONFIG_SEL_OFFSET, 0);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_setAsicRegBits(RTL8367C_REG_LED_CONFIGURATION, bits[ledno], config);
}

The above function is used to set LED_Indicate, LED_Link_OK, LED_Netw_Link_OK configuration.
To set the LED_Netw_Link_OK LED,  it is the 1 st bit of the  LED_CONFIG




NEXT




<s> static int b53_global_reset_switch(struct switch_dev *dev)
{
struct b53_device *priv = sw_to_b53(dev);

/* reset vlans */
priv->enable_vlan = 0;
priv->enable_jumbo = 0;
priv->allow_vid_4095 = 0;

memset(priv->vlans, 0, sizeof(*priv->vlans) * dev->vlans);
memset(priv->ports, 0, sizeof(*priv->ports) * dev->ports);

return b53_switch_reset(priv);
}

The above function is used to clear out VLAN/port configuration. It
calls an internal b53 driver function b53_switch_reset which performs
some generic operations to reset the device. This is called on the
first interface activation. It should also be




NEXT




<s> void board_putc(int ch)
{
if (!UART_BASE)
return;

wait_xfered();
WRITEREG(UART_BASE + UART_FIFO_REG, ch);
wait_xfered();
}

The above function is used to put a character on the 8 line LED board which I have on my computer. It works fine even in C (there is no C++ version of the code). The reason why I had to ask such a simple question is that I got the




NEXT




<s> extern void init_ddr(int mhz);

void board_inithw(void)
{
int plla_freq;
#ifdef DEBUG
int i;
#endif	/* DEBUG */

timer_init();
uart_init();
preloader_console_init();

plla_freq = plla_set_config(CONFIG_PLLA_FREQ_MHZ);
init_ddr(plla_freq);

#ifdef DEBUG
if(test_memory(CONFIG_SYS_SDRAM_BASE)) {
puts("memory test failed\n");
} else {
puts("memory test done\n");
}
#endif /* DEBUG */
#ifdef CONFIG_SPL_BSS_DRAM_START
extern char __bss_dram_start[];
extern char __bss_dram_end[];
memset(&__bss_dram_start, 0, __bss_dram_end - __bss_dram_start);
#endif
}

The above function is used to initialize the hardware. The function call in_hw(void) in in_hw.S is used to call the board_inithw().

To use the function board_inithw(), you must make the following change.





NEXT




<s> static int __init mtdsplit_tplink_init(void)
{
register_mtd_parser(&mtdsplit_tplink_parser);

return 0;
}

The above function is used to register a custom MTD partition table parser.
register_mtd_parser()

However, the MTD subsystem will not use it to get the parsing function name. This causes the above MTD partition table parser not to be




NEXT




<s> int AT91F_MCI_Init(void)
{

///////////////////////////////////////////////////////////////////////////////////////////
//  MCI Init : common to MMC and SDCard
///////////////////////////////////////////////////////////////////////////////////////////

// Set up PIO SDC_TYPE to switch on MMC/SDCard and not DataFlash Card
AT91F_PIO_CfgOutput(AT91C_BASE_PIOB,AT91C_PIO_PB7);
AT91F_PIO_SetOutput(AT91C_BASE_PIOB,AT91C_PIO_PB7);

// Init MCI for MMC and SDCard interface
AT91F_MCI_CfgPIO();
AT91F_MCI_CfgPMC();
AT91F_PDC_Open(AT91C_BASE_PDC_MCI);

// Disable all the interrupts
AT91C_BASE_MCI->MCI_IDR = 0xFFFFFFFF;

// Init MCI Device Structures
AT91F_CfgDevice();

// Configure MCI interrupt
AT91F_AIC_ConfigureIt(AT91C_BASE_AIC,
AT91C_ID_MCI,
AT91C_AIC_PRIOR_HIGHEST,
AT91C_AIC_SRCTYPE_INT_LEVEL_SENSITIVE,
AT91F_ASM_MCI_Handler);

// Enable MCI interrupt
AT91F_AIC_EnableIt(AT91C_BASE_AIC,AT91C_ID_MCI);

// Enable Receiver
AT91F_US_EnableRx((AT91PS_USART) AT91C_BASE_DBGU);

AT91F_MCI_Configure(AT91C_BASE_MCI,
AT91C_MCI_DTOR_1MEGA_CYCLES,
AT91C_MCI_MR_PDCMODE,			// 15MHz for MCK = 60MHz (CLKDIV = 1)
AT91C_MCI_SDCARD_4BITS_SLOTA);

if(AT91F_MCI_SDCard_Init(&MCI_Device) != AT91C_INIT_OK)
return FALSE;
else
return TRUE;

}

The above function is used to initialize SDCard. You may need to change some of the parameters.

You can use the "get_sdcard" example function to test whether you have successfully initialized the SDCard.

In the function at91f




NEXT




<s> struct b53_device *b53_swconfig_switch_alloc(struct device *base, struct b53_io_ops *ops,
void *priv)
{
struct b53_device *dev;

dev = devm_kzalloc(base, sizeof(*dev), GFP_KERNEL);
if (!dev)
return NULL;

dev->dev = base;
dev->ops = ops;
dev->priv = priv;
mutex_init(&dev->reg_mutex);

return dev;
}

The above function is used to allocate instance of b53_device</s>




NEXT




<s> static inline int startswith (char *source, char *cmp)
{
return !strncmp(source, cmp, strlen(cmp));
}

The above function is used to check if the source string starts with the string cmp. Strncmp would be enough for such a check, but the function is a bit faster.

Below is the strncmp function, it is copied from the libc.




NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_init(void)
{
rtl8367c_acltemplate_t       aclTemp;
rtk_uint32                 i, j;
rtk_api_ret_t          ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((ret = rtk_filter_igrAcl_cfg_delAll()) != RT_ERR_OK)
return ret;

for(i = 0; i < RTL8367C_ACLTEMPLATENO; i++)
{
for(j = 0; j < RTL8367C_ACLRULEFIELDNO;j++)
aclTemp.field[j] = filter_templateField[i][j];

if ((ret = rtl8367c_setAsicAclTemplate(i, &aclTemp)) != RT_ERR_OK)
return ret;
}

for(i = 0; i < RTL8367C_FIELDSEL_FORMAT_NUMBER; i++)
{
if ((ret = rtl8367c_setAsicFieldSelector(i, field_selector[i][0], field_selector[i][1])) != RT_ERR_OK)
return ret;
}

RTK_SCAN_ALL_PHY_PORTMASK(i)
{
if ((ret = rtl8367c_setAsicAcl(i, TRUE)) != RT_ERR_OK)
return ret;

if ((ret = rtl8367c_setAsicAclUnmatchedPermit(i, TRUE)) != RT_ERR_OK)
return ret;
}

return RT_ERR_OK;
}

The above function is used to enable ACL. If ACL is enabled, the packet will pass through the ACL filter. The ACL filter is in IPv4 and IPv4 multicast mode currently.

rtk_api_ret_t r




NEXT




<s> static int __init rttm_probe(struct device_node *np)
{
int cpu, cpu_rollback;
struct timer_of *to;
int clkidx = num_possible_cpus();

/* Use the first n timers as per CPU clock event generators */
for_each_possible_cpu(cpu) {
to = per_cpu_ptr(&rttm_to, cpu);
to->of_irq.index = to->of_base.index = cpu;
if (timer_of_init(np, to)) {
pr_err("%s: setup of timer %d failed\n", __func__, cpu);
goto rollback;
}
rttm_setup_timer(to->of_base.base);
}

/* Activate the n'th + 1 timer as a stable CPU clocksource. */
to = &rttm_cs.to;
to->of_base.index = clkidx;
timer_of_init(np, to);
if (rttm_cs.to.of_base.base && rttm_cs.to.of_clk.rate) {
rttm_enable_clocksource(&rttm_cs.cs);
clocksource_register_hz(&rttm_cs.cs, RTTM_TICKS_PER_SEC);
sched_clock_register(rttm_read_clock, RTTM_BIT_COUNT, RTTM_TICKS_PER_SEC);
} else
pr_err("%s: setup of timer %d as clocksoure failed", __func__, clkidx);

return cpuhp_setup_state(CPUHP_AP_REALTEK_TIMER_STARTING,
"timer/realtek:online",
rttm_cpu_starting, NULL);
rollback:
pr_err("%s: timer registration failed\n", __func__);
for_each_possible_cpu(cpu_rollback) {
if (cpu_rollback == cpu)
break;
to = per_cpu_ptr(&rttm_to, cpu_rollback);
timer_of_cleanup(to);
}

return -EINVAL;
}

The above function is used to register the timer. The following function is used in order to enable the timer:

void rttm_enable_clocksource(struct clocksource *cs)
{
/* initialize timer */
WARN_ON(!cs || !cs




NEXT




<s> int ar9_start(int pp32)
{
int ret;

ret = pp32_download_code(ar9_fw_bin, sizeof(ar9_fw_bin) / sizeof(*ar9_fw_bin),
ar9_fw_data, sizeof(ar9_fw_data) / sizeof(*ar9_fw_data));
if ( ret != 0 )
return ret;

IFX_REG_W32(DBG_CTRL_RESTART, PP32_DBG_CTRL(0));

udelay(10);

return 0;
}

The above function is used to initialize the PP32.

After that, to reset the PP32, I’ve tried to write the reset control register:

pp32_reset_ctrl |= PP32_RESET_CTRL_PCS_




NEXT




<s> static void mr18_setup_qca955x_eth_serdes_cal(unsigned int sgmii_value)
{
unsigned int ethbase, pllbase, t;

ethbase = KSEG1ADDR(QCA955X_GMAC_BASE);
pllbase = KSEG1ADDR(AR71XX_PLL_BASE);

/* To Check the locking of the SGMII PLL */
t = READREG(ethbase + QCA955X_GMAC_REG_SGMII_SERDES);
t &= ~(QCA955X_SGMII_SERDES_RES_CALIBRATION_MASK <<
QCA955X_SGMII_SERDES_RES_CALIBRATION_SHIFT);
t |= (sgmii_value & QCA955X_SGMII_SERDES_RES_CALIBRATION_MASK) <<
QCA955X_SGMII_SERDES_RES_CALIBRATION_SHIFT;
WRITEREG(ethbase + QCA955X_GMAC_REG_SGMII_SERDES, t);

WRITEREG(pllbase + QCA955X_PLL_ETH_SGMII_SERDES_REG,
QCA955X_PLL_ETH_SGMII_SERDES_LOCK_DETECT |
QCA955X_PLL_ETH_SGMII_SERDES_PLL_REFCLK |
QCA955X_PLL_ETH_SGMII_SERDES_EN_PLL)
;

qca955x_device_reset_clear(QCA955X_RESET_SGMII_ANALOG);
qca955x_device_reset_clear(QCA955X_RESET_SGMII);

while (!(READREG(ethbase + QCA955X_GMAC_REG_SGMII_SERDES) &
QCA955X_SGMII_SERDES_LOCK_DETECT_STATUS))
;
}

The above function is used to set up the serializer/deserializer(SGMII)
channel in the ethereal MAC controller.

The serializer/deserializer is used for converting the data from the
Ethernet controller into serial data




NEXT




<s> static bool jffs2_dirent_valid(struct jffs2_raw_dirent *node)
{
return ((je16_to_cpu(node->magic) == JFFS2_MAGIC_BITMASK) &&
(je16_to_cpu(node->nodetype) == JFFS2_NODETYPE_DIRENT) &&
je32_to_cpu(node->ino) &&
je32_to_cpu(node->node_crc) == jffs2_dirent_crc(node));
}

The above function is used to validate a JFFS2 on-disk file system
directory entry.  I am not entirely sure this is correct for all
versions of JFFS2; it looks right to me.  Since it is a quick check,
I




NEXT




<s> ret_t rtl8367c_getAsicMIBsControl(rtk_uint32* pMask)
{
ret_t retVal;
rtk_uint32 regData;

retVal = rtl8367c_getAsicReg(RTL8367C_MIB_CTRL_REG, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pMask = regData & (RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK | RTL8367C_RESET_FLAG_MASK);

return RT_ERR_OK;
}

The above function is used to check asic register whether or not a MIB command is in progress.

#endif



if(pAsicPingPong == RTK_AID_ASIC_BOOT_AID){
if




NEXT




<s> void __init ws_ap3825i_pic_init(void)
{
struct mpic *mpic;

mpic = mpic_alloc(NULL, 0,
MPIC_BIG_ENDIAN |
MPIC_SINGLE_DEST_CPU,
0, 256, " OpenPIC  ");

BUG_ON(mpic == NULL);
mpic_init(mpic);
}

The above function is used to create the "OpenPIC"-compatible PIC
implementation and it is never called.  I don't know why it is there.

The only way to have any use for this function is to do something like:





NEXT




<s> static bool __ar934x_nfc_dev_ready(struct ar934x_nfc *nfc)
{
u32 status;

status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_STATUS);
return (status & 0xff) == 0xff;
}

The above function is used to check if NFC is ready. This function is wrong because it will report NFC ready all the time.
Why?

According to the code of ar934x_nfc_rr(nfc, AR93




NEXT




<s> static void print_symbol(FILE *out, struct menu *menu)
{
struct symbol *sym = menu->sym;
struct property *prop;

if (sym_is_choice(sym))
fprintf(out, "\nchoice\n");
else
fprintf(out, "\nconfig %s\n", sym->name);
switch (sym->type) {
case S_BOOLEAN:
fputs("  bool\n", out);
break;
case S_TRISTATE:
fputs("  tristate\n", out);
break;
case S_STRING:
fputs("  string\n", out);
break;
case S_INT:
fputs("  integer\n", out);
break;
case S_HEX:
fputs("  hex\n", out);
break;
default:
fputs("  ???\n", out);
break;
}
for (prop = sym->prop; prop; prop = prop->next) {
if (prop->menu != menu)
continue;
switch (prop->type) {
case P_PROMPT:
fputs("  prompt ", out);
print_quoted_string(out, prop->text);
if (!expr_is_yes(prop->visible.expr)) {
fputs(" if ", out);
expr_fprint(prop->visible.expr, out);
}
fputc('\n', out);
break;
case P_DEFAULT:
fputs( "  default ", out);
expr_fprint(prop->expr, out);
if (!expr_is_yes(prop->visible.expr)) {
fputs(" if ", out);
expr_fprint(prop->visible.expr, out);
}
fputc('\n', out);
break;
case P_CHOICE:
fputs("  #choice value\n", out);
break;
case P_SELECT:
fputs( "  select ", out);
expr_fprint(prop->expr, out);
fputc('\n', out);
break;
case P_IMPLY:
fputs( "  imply ", out);
expr_fprint(prop->expr, out);
fputc('\n', out);
break;
case P_RANGE:
fputs( "  range ", out);
expr_fprint(prop->expr, out);
fputc('\n', out);
break;
case P_MENU:
fputs( "  menu ", out);
print_quoted_string(out, prop->text);
fputc('\n', out);
break;
case P_SYMBOL:
fputs( "  symbol ", out);
fprintf(out, "%s\n", prop->menu->sym->name);
break;
default:
fprintf(out, "  unknown prop %d!\n", prop->type);
break;
}
}
if (menu->help) {
int len = strlen(menu->help);
while (menu->help[--len] == '\n')
menu->help[len] = 0;
fprintf(out, "  help\n%s\n", menu->help);
}
}

The above function is used to print out config file syntax
(in the new format) to file, or stdout if we have no file
to write to.

The idea is to call a function from the menu_print
function that can print properties like





NEXT




<s> ret_t rtl8367c_getAsicPortIsolationPermittedPortmask(rtk_uint32 port, rtk_uint32 *pPermitPortmask)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicReg(RTL8367C_PORT_ISOLATION_PORT_MASK_REG(port), pPermitPortmask);
}

The above function is used to read the port isolation permitted portmask. But, the regsiter name seems odd. What is the definition of Port Isolation and Permitted Portmask. If the description is not clear, please let me know and I can delete this post .




NEXT




<s> int at91_serial_putc(int ch)
{
if (ch == '\n')
at91_serial_putc('\r');
while (!AT91F_US_TxReady((AT91PS_USART)us));
AT91F_US_PutChar((AT91PS_USART)us, (char)ch);
return ch;
}

The above function is used to print each char in a string.
Since it works with an unsigned char variable, all printable ASCII characters work (i.e if printing a char instead of a string).

But, some special characters like space do not work




NEXT




<s> static void rtl930x_vlan_set_untagged(u32 vlan, u64 portmask)
{
struct table_reg *r = rtl_table_get(RTL9300_TBL_2, 0);

sw_w32(portmask << 3, rtl_table_data(r, 0));
rtl_table_write(r, vlan);
rtl_table_release(r);
}

The above function is used to add a certain port to the VLAN untagged list, so that it can see the VLAN tagged frames. While I know that the “portmask” variable might have multiple bits set in a single write to rtl_table_




NEXT




<s> rtk_api_ret_t rtk_mirror_portIso_get(rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortMirrorIsolation(pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to read the mirror iso configuration of specified ports: Port 1. The read result is: if port 1 is enabled for mirror-iso configuration, the value of parameter portMirrorIsoEnabled is TRUE. Otherwise, it is FALSE.




NEXT




<s> static void show_menu(const char *prompt, const char *instructions,
int selected_index, int *last_top_row)
{
int maxx, maxy;
WINDOW *menu_window;

current_instructions = instructions;

clear();
print_in_middle(stdscr, 1, getmaxx(stdscr),
menu_backtitle,
attr_main_heading);

wattrset(main_window, attr_main_menu_box);
box(main_window, 0, 0);
wattrset(main_window, attr_main_menu_heading);
mvwprintw(main_window, 0, 3, " %s ", prompt);
wattrset(main_window, attr_normal);

set_menu_items(curses_menu, curses_menu_items);

/* position the menu at the middle of the screen */
scale_menu(curses_menu, &maxy, &maxx);
maxx = min(maxx, mwin_max_cols-2);
maxy = mwin_max_lines;
menu_window = derwin(main_window,
maxy,
maxx,
2,
(mwin_max_cols-maxx)/2);
keypad(menu_window, TRUE);
set_menu_win(curses_menu, menu_window);
set_menu_sub(curses_menu, menu_window);

/* must reassert this after changing items, otherwise returns to a
* default of 16
*/
set_menu_format(curses_menu, maxy, 1);
center_item(selected_index, last_top_row);
set_menu_format(curses_menu, maxy, 1);

print_function_line();

/* Post the menu */
post_menu(curses_menu);
refresh_all_windows(main_window);
}

The above function is used to display the menu, and show item options.

static void select_items()
{
int selected_index;
int top_row = 0;
char text[BSTRING_SIZE];

while(!done_qu




NEXT




<s> static inline int rtl839x_trk_mbr_ctr(int group)
{
return RTL839X_TRK_MBR_CTR + (group << 3);
}

The above function is used to retrieve MAC-based rate limitation control registers’ addresses.

The following table indicates the mapping relations between Tx/Rx rings and MBR ring group bits (0-15).

* MBR Group Table - Tx Ring 




NEXT




<s> static inline void init_mailbox(void);
static inline void init_atm_tc(void);
static inline void clear_share_buffer(void);

#define IFX_PMU_MODULE_PPE_SLL01  BIT(19)
#define IFX_PMU_MODULE_PPE_TC     BIT(21)
#define IFX_PMU_MODULE_PPE_EMA    BIT(22)
#define IFX_PMU_MODULE_PPE_QSB    BIT(18)
#define IFX_PMU_MODULE_AHBS       BIT(13)
#define IFX_PMU_MODULE_DSL_DFE    BIT(9)


static inline void init_pmu(void)
{
ltq_pmu_enable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_AHBS |
IFX_PMU_MODULE_DSL_DFE);

}

The above function is used to enable all the PMU counter.

static inline void init_atm_tc(void)
{

ltq_write32(AQT_TC_C_BASE + TC_CTL0_OFF,




NEXT




<s> static void rtl838x_write_l2_entry_using_hash(u32 hash, u32 pos, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL8380_TBL_L2, 0);

u32 idx = (0 << 14) | (hash << 2) | pos; /* Access SRAM, with hash and at pos in bucket */

rtl838x_fill_l2_row(r, e);

for (int i = 0; i < 3; i++)
sw_w32(r[i], rtl_table_data(q, i));

rtl_table_write(q, idx);
rtl_table_release(q);
}

The above function is used to write a single L2 entry in RTL8380 SoC.  Because RTK L2 entry in RTL8380 has variable length (0..28 bytes per entry), it is important to know/define the




NEXT




<s> static ssize_t bcm4908img_create_align(FILE *trx, size_t cur_offset, size_t alignment) {
if (cur_offset & (alignment - 1)) {
size_t length = alignment - (cur_offset % alignment);
return bcm4908img_create_append_zeros(trx, length);
}

return 0;
}

The above function is used to create a aligned buffer and make sure that it is aligned with 512-bit boundaries as well. In reality this function is used only when generating the shared image file as part of generating code. The alignment value is set at 51




NEXT




<s> static int mt7988_pinctrl_probe(struct platform_device *pdev)
{
return mtk_moore_pinctrl_probe(pdev, &mt7988_data);
}

The above function is used to control GPIOs of the MT7988 module. It is called after the driver is loaded. Therefore, in order to control the GPIOs, we need to first load the driver using the insmod command:

$ sudo ins




NEXT




<s> rtk_api_ret_t rtk_igmp_maxGroup_get(rtk_port_t port, rtk_uint32 *pGroup)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if(pGroup == NULL)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPPortMAXGroup(rtk_switch_port_L2P_get(port), pGroup))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get MAX group number of IGMP for given Port.

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);




NEXT




<s> static void ag71xx_rings_free(struct ag71xx *ag)
{
struct ag71xx_ring *tx = &ag->tx_ring;
struct ag71xx_ring *rx = &ag->rx_ring;
int ring_size = BIT(tx->order) + BIT(rx->order);

if (tx->descs_cpu)
dma_free_coherent(&ag->pdev->dev, ring_size * AG71XX_DESC_SIZE,
tx->descs_cpu, tx->descs_dma);

kfree(tx->buf);

tx->descs_cpu = NULL;
rx->descs_cpu = NULL;
tx->buf = NULL;
rx->buf = NULL;
}

The above function is used to free descriptor buffers of the 2 rings to be created while
the port is configured. The ring size is calculated based on the RING order that is passed</s>




NEXT




<s> void mtk_bmt_detach(struct mtd_info *mtd)
{
if (bmtd.mtd != mtd)
return;

if (bmtd.debugfs_dir)
debugfs_remove_recursive(bmtd.debugfs_dir);
bmtd.debugfs_dir = NULL;

kfree(bmtd.bbt_buf);
kfree(bmtd.data_buf);

mtd->_read_oob = bmtd._read_oob;
mtd->_write_oob = bmtd._write_oob;
mtd->_erase = bmtd._erase;
mtd->_block_isbad = bmtd._block_isbad;
mtd->_block_markbad = bmtd._block_markbad;
mtd->size = bmtd.total_blks << bmtd.blk_shift;

memset(&bmtd, 0, sizeof(bmtd));
}

The above function is used to detach the mtd that has been attached by the earlier “mtk_bmt_attach” function.

However, I do not quite understand the following code in the above function:

mtd->_read_oob =




NEXT




<s> static void ag71xx_of_set(struct device_node *np, const char *prop,
u32 *reg, u32 shift, u32 mask)
{
u32 val;

if (of_property_read_u32(np, prop, &val))
return;

*reg &= ~(mask << shift);
*reg |= ((val & mask) << shift);
}

The above function is used to set up the registers in a SoC and
it can return early if the device-tree property
(reading) in question is not found.</s>




NEXT




<s> static void expr_print_gstr_helper(void *data, struct symbol *sym, const char *str)
{
struct gstr *gs = (struct gstr*)data;
const char *sym_str = NULL;

if (sym)
sym_str = sym_get_string_value(sym);

if (gs->max_width) {
unsigned extra_length = strlen(str);
const char *last_cr = strrchr(gs->s, '\n');
unsigned last_line_length;

if (sym_str)
extra_length += 4 + strlen(sym_str);

if (!last_cr)
last_cr = gs->s;

last_line_length = strlen(gs->s) - (last_cr - gs->s);

if ((last_line_length + extra_length) > gs->max_width)
str_append(gs, "\\\n");
}

str_append(gs, str);
if (sym && sym->type != S_UNKNOWN)
str_printf(gs, " [=%s]", sym_str);
}

The above function is used to print g-strings in the expressions
dialog.  It works by calling expr_get_lhs_rhs() to get the
g-string and expression that appear in the selected expr,
then walks through the expression and calls itself recurs




NEXT




<s> static int sha1_hmac_update(struct shash_desc *desc, const u8 *data,
unsigned int len)
{
struct sha1_hmac_ctx *sctx =  crypto_shash_ctx(desc->tfm);
unsigned int i, j;

j = (sctx->count >> 3) & 0x3f;
sctx->count += len << 3;
// printk("sctx->count = %d\n", sctx->count);

if ((j + len) > 63) {
memcpy (&sctx->buffer[j], data, (i = 64 - j));
sha1_hmac_transform (desc, (const u32 *)sctx->buffer);
for (; i + 63 < len; i += 64) {
sha1_hmac_transform (desc, (const u32 *)&data[i]);
}

j = 0;
}
else
i = 0;

memcpy (&sctx->buffer[j], &data[i], len - i);
return 0;
}

The above function is used to update sha-1 in OCSP client response. By using this function
the value of sctx->count can be modified to 0x806400. So, the sha1_hmac_transform will be called




NEXT




<s> rtk_api_ret_t rtk_stat_logging_counter_reset(rtk_uint32 idx)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(idx > RTL8367C_MIB_MAX_LOG_CNT_IDX)
return RT_ERR_OUT_OF_RANGE;

if((retVal = rtl8367c_setAsicMIBsResetLoggingCounter(idx)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to reset the counter of specified mib at log module.  Each mib can only be reseted once.  The counter will keep zero if it's not reseted before.  It needs to reset the counter if the counter value is 




NEXT




<s> ret_t rtl8367c_getAsicPortMirror(rtk_uint32 *pSource, rtk_uint32 *pMonitor)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_SOURCE_PORT_MASK, pSource);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_getAsicRegBits(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_MONITOR_PORT_MASK, pMonitor);
}

The above function is used to retrieve the values of the source and monitor port IDs for the in-service mirror feature.

The following function is used to write the source and monitor port IDs to be used for the in-service mirror feature.  Return value is




NEXT




<s> extern uint32_t crc32(uint32_t, const unsigned char *, unsigned int);

#define NUMBER_VECTORS   12
struct {
unsigned int start_vector[NUMBER_VECTORS];
char code[4];
unsigned int header_length;
unsigned int reserved[3];
unsigned int length;
unsigned int img_CRC;
unsigned int CRC;
} img_header;

The above function is used to calculate CRC32 sum of a data segment. The sum is stored to register R4, followed by being output to the USART. The sum is the 16-bit checksum of the CRC32 checksum (MSB first




NEXT




<s> ret_t rtl8367c_getAsicVlanTransparent(rtk_uint32 port, rtk_uint32 *pPortmask)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL0 + port, RTL8367C_VLAN_EGRESS_TRANS_CTRL0_MASK, pPortmask);
}

The above function is used to retrieve the current VLAN Transparent setting(whether set as VLAN Transparent port or not) of each port, which is a very useful function when the port is to be set as a VLAN Transparent port and to perform the Trans




NEXT




<s> static int fe_set_link_ksettings(struct net_device *ndev,
const struct ethtool_link_ksettings *cmd)
{
struct fe_priv *priv = netdev_priv(ndev);

if (!priv->phy_dev)
goto out_sset;

if (cmd->base.phy_address != priv->phy_dev->mdio.addr) {
if (priv->phy->phy_node[cmd->base.phy_address]) {
priv->phy_dev = priv->phy->phy[cmd->base.phy_address];
priv->phy_flags = FE_PHY_FLAG_PORT;
} else if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, cmd->base.phy_address)) {
priv->phy_dev = mdiobus_get_phy(priv->mii_bus, cmd->base.phy_address);
priv->phy_flags = FE_PHY_FLAG_ATTACH;
} else {
goto out_sset;
}
}

return phy_ethtool_ksettings_set(ndev->phydev, cmd);

out_sset:
return -ENODEV;
}

The above function is used to set link ksettings to the PHY. The PHY is obtained and updated as:

struct fe_priv *priv = netdev_priv(ndev);

if (!priv->phy_dev) {
if (priv




NEXT




<s> ret_t rtl8367c_setAsic1xMBOpdirConfig(rtk_uint32 opdir)
{
return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_MAC_OPDIR_OFFSET, opdir);
}

The above function is used to set DOT1x MAC Operation direction (OPDIR) in RTL8367C, bit [1:0] in Dot1x_CFG register.
1. DOT1x OPDIR=0b00




NEXT




<s> int AT91F_MCI_GetStatus(AT91PS_MciDevice pMCI_Device,unsigned int relative_card_address)
{
if (AT91F_MCI_SendCommand(pMCI_Device,
AT91C_SEND_STATUS_CMD,
relative_card_address <<16) == AT91C_CMD_SEND_OK)
return (AT91C_BASE_MCI->MCI_RSPR[0]);

return AT91C_CMD_SEND_ERROR;
}

The above function is used to send status of a card which provides details of the card. This function is used as a callback function in AT91C_StatusGet function.</s>




NEXT




<s> rtk_api_ret_t rtk_stat_logging_counter_get(rtk_uint32 idx, rtk_uint32 *pCnt)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pCnt)
return RT_ERR_NULL_POINTER;

if(idx > RTL8367C_MIB_MAX_LOG_CNT_IDX)
return RT_ERR_OUT_OF_RANGE;

if((retVal = rtl8367c_getAsicMIBsLogCounter(idx, pCnt)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the packet counter from the ASIC using the function defined in file: rtl8367c_asicTcl.c.</s>




NEXT




<s> void BN_CTX_start(BN_CTX *ctx)
{
if (ctx->depth < BN_CTX_NUM_POS)
ctx->pos[ctx->depth] = ctx->tos;
ctx->depth++;
}

The above function is used to start a multi modulo multiplication.
At each call it does little more than incrementing the size of the operation queue.

But it also sets a particular member of ctx->pos array (of pointers).

ctx->pos




NEXT




<s> static ssize_t port_egress_rate_read(struct file *filp, char __user *buffer, size_t count,
loff_t *ppos)
{
struct rtl838x_port *p = filp->private_data;
struct dsa_switch *ds = p->dp->ds;
struct rtl838x_switch_priv *priv = ds->priv;
int value;
if (priv->family_id == RTL8380_FAMILY_ID)
value = rtl838x_get_egress_rate(priv, p->dp->index);
else
value = rtl839x_get_egress_rate(priv, p->dp->index);

if (value < 0)
return -EINVAL;

return rtl838x_common_read(buffer, count, ppos, (u32)value);
}

The above function is used to read the Egress Rate value from the Switch. It uses the
private data field to get the switch type information. This value is then used to get the
appropriate function to get the Egress Rate value for the switch. If the value




NEXT




<s> void menu_add_visibility(struct expr *expr)
{
current_entry->visibility = expr_alloc_and(current_entry->visibility,
expr);
}

The above function is used to add the visibilities of a specific entry
to the expression being processed.

My problem is that if a value is added and it evaluates to false, then it
should evaluate the children and continue. So, for example, I want




NEXT




<s> static void wpas_ubus_connection_lost(struct ubus_context *ctx)
{
uloop_fd_delete(&ctx->sock);
eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
}

The above function is used to disconnect the UBus connection in the wpa_supplicant
application . It disconnects UBus by clearing the socket and then tries to
connect UBus again after one second. During the reconnection process, the application
execut




NEXT




<s> static inline int rtl8366_smi_probe_of(struct platform_device *pdev, struct rtl8366_smi *smi)
{
return -ENODEV;
}

The above function is used to verify whether OF is supported by the SoC. The code to verify the OF information is shown below.

#include

int rtl8366_smi_probe_of(struct platform_device *pdev, struct




NEXT




<s> static int mt7621_nfc_send_command(struct mt7621_nfc *nfc, u8 command)
{
struct device *dev = nfc->dev;
u32 val;
int ret;

nfi_write32(nfc, NFI_CMD, command);

ret = readl_poll_timeout_atomic(nfc->nfi_regs + NFI_STA, val,
!(val & STA_CMD), 10,
NFI_CORE_TIMEOUT);
if (ret) {
dev_warn(dev, "NFI core timed out entering command mode\n");
return -EIO;
}

return 0;
}

The above function is used to send NFC commands to ROM and ROM will only respond to these commands: NFIT_READ, NFID_READ, NFIC_READ, NFI_WR_ENABLE,
NFID_WR_ENABLE,




NEXT




<s> static int __init routerboot_init(void)
{
rb_kobj = kobject_create_and_add("mikrotik", firmware_kobj);
if (!rb_kobj)
return -ENOMEM;

register_mtd_user(&routerboot_mtd_notifier);

return 0;
}

The above function is used to initialize the routerboot subsystem. First, it creates a new kobject called "mikrotik" which is part of the firmware_kobj kernel object tree. Then, it registers the routerboot_mtd_notifier m




NEXT




<s> hostapd_vendor_elements(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct blob_attr *tb[__VENDOR_ELEMENTS_MAX];
struct hostapd_data *hapd = get_hapd_from_object(obj);
struct hostapd_bss_config *bss = hapd->conf;
struct wpabuf *elems;
const char *pos;
size_t len;

blobmsg_parse(ve_policy, __VENDOR_ELEMENTS_MAX, tb,
blob_data(msg), blob_len(msg));

if (!tb[VENDOR_ELEMENTS])
return UBUS_STATUS_INVALID_ARGUMENT;

pos = blobmsg_data(tb[VENDOR_ELEMENTS]);
len = os_strlen(pos);
if (len & 0x01)
return UBUS_STATUS_INVALID_ARGUMENT;

len /= 2;
if (len == 0) {
wpabuf_free(bss->vendor_elements);
bss->vendor_elements = NULL;
return 0;
}

elems = wpabuf_alloc(len);
if (elems == NULL)
return 1;

if (hexstr2bin(pos, wpabuf_put(elems, len), len)) {
wpabuf_free(elems);
return UBUS_STATUS_INVALID_ARGUMENT;
}

wpabuf_free(bss->vendor_elements);
bss->vendor_elements = elems;

/* update beacons if vendor elements were set successfully */
if (ieee802_11_update_beacons(hapd->iface) != 0)
return UBUS_STATUS_NOT_SUPPORTED;
return UBUS_STATUS_OK;
}

The above function is used to receive Vendor Specific Elements in the format specified by 802.11v. These Vendor Specific Elements have to be sent back as-is without processing them in any manner. Hence, we use hexstr2bin to




NEXT




<s> static void rtl839x_l2_notification_handler(struct rtl838x_eth_priv *priv)
{
struct notify_b *nb = priv->membase + sizeof(struct ring_b);
u32 e = priv->lastEvent;

while (!(nb->ring[e] & 1)) {
struct fdb_update_work *w;
struct n_event *event;
u64 mac;
int i;

w = kzalloc(sizeof(*w), GFP_ATOMIC);
if (!w) {
pr_err("Out of memory: %s", __func__);
return;
}
INIT_WORK(&w->work, rtl838x_fdb_sync);

for (i = 0; i < NOTIFY_EVENTS; i++) {
event = &nb->blocks[e].events[i];
if (!event->valid)
continue;
mac = event->mac;
if (event->type)
mac |= 1ULL << 63;
w->ndev = priv->netdev;
w->macs[i] = mac;
}

/* Hand the ring entry back to the switch */
nb->ring[e] = nb->ring[e] | 1;
e = (e + 1) % NOTIFY_BLOCKS;

w->macs[i] = 0ULL;
schedule_work(&w->work);
}
priv->lastEvent = e;
}

The above function is used to notify the MAC address when a new MAC address is learned or deleted from the switch table. It is called from rtl839x_update_fdb function called by the 802.1x tasklet.</s>




NEXT




<s> static void rijndaelKeySetupEnc(u32 rk[/*44*/], const u8 cipherKey[])
{
int i;
u32 temp;

rk[0] = GETU32(cipherKey     );
rk[1] = GETU32(cipherKey +  4);
rk[2] = GETU32(cipherKey +  8);
rk[3] = GETU32(cipherKey + 12);
for (i = 0; i < 10; i++) {
temp  = rk[3];
rk[4] = rk[0] ^
TE421(temp) ^ TE432(temp) ^ TE443(temp) ^ TE414(temp) ^
RCON(i);
rk[5] = rk[1] ^ rk[4];
rk[6] = rk[2] ^ rk[5];
rk[7] = rk[3] ^ rk[6];
rk += 4;
}
}

The above function is used to transform the given key into the final Rijndael key using the S-box. The following function transforms the input word into the final input word.

static void RIJ128StateEnc(u32 *input




NEXT




<s> sophie_germain(k, t, u);

p = BigIntegerFromInt(0);
BigIntegerMulInt(p, j, 2);            /* p = 2 * j */
BigIntegerAddInt(p, p, 1);            /* p += 1 */

q = BigIntegerFromInt(0);
BigIntegerMulInt(q, k, 2);            /* q = 2 * k */
BigIntegerAddInt(q, q, 1);            /* q += 1 */

n = BigIntegerFromInt(0);
BigIntegerMul(n, p, q);               /* n = p * q */
BigIntegerMul(u, j, k);               /* u = j * k */

BigIntegerFree(p);
BigIntegerFree(q);
BigIntegerFree(j);
BigIntegerFree(k);

g = BigIntegerFromInt(2);             /* g = 2 */

/* Look for a generator mod n */
while(1) {
BigIntegerModExp(t, g, u, n);       /* t = g^u % n */
if(BigIntegerCmpInt(t, 1) == 0)
BigIntegerAddInt(g, g, 1);        /* ++g */
else
break;
}

The above function is used to get an nth root modulo n over integers with the help of Sophie Germain prime numbers (this will be implemented later for ECC). The functions `BigIntegerFromInt()`, `BigIntegerMul()`, `BigIntegerAdd




NEXT




<s> yy_create_buffer( yyin, YY_BUF_SIZE );
}

yy_load_buffer_state(  );
}

{

int str = 0;
int ts, i;

while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
{

The above function is used to print the token values according to the input string, that is

yy_get_next_buffer(  );
}

break;

int yyin = 0;

int yyout =  )</s>




NEXT




<s> static void arc4_chip_init (void)
{
//do nothing
}

The above function is used to initialize AES accelerator during chip boot up sequence.

I’m curious about this function’s code: a function with no argument and no return value (void) is not used by standard embedded c programming, and the keyword static is




NEXT




<s> static inline int superio_enter(int base)
{
/* Don't step on other drivers' I/O space by accident. */
if (!request_muxed_region(base, 2, DRVNAME)) {
pr_err(DRVNAME "I/O address 0x%04x already in use\n", base);
return -EBUSY;
}

/* According to the datasheet the key must be send twice. */
outb(SIO_UNLOCK_KEY, base);
outb(SIO_UNLOCK_KEY, base);

return 0;
}

The above function is used to enter the super io device, it needs to check the base address and check whether it has been used. Once it is entered, a key value needs to be sent twice, and finally the key is returned.

So, under normal circumstances,




NEXT




<s> void fe_stats_update(struct fe_priv *priv)
{
struct fe_hw_stats *hwstats = priv->hw_stats;
unsigned int base = fe_reg_table[FE_REG_FE_COUNTER_BASE];
u64 stats;

u64_stats_update_begin(&hwstats->syncp);

if (IS_ENABLED(CONFIG_SOC_MT7621)) {
hwstats->rx_bytes			+= fe_r32(base);
stats					=  fe_r32(base + 0x04);
if (stats)
hwstats->rx_bytes		+= (stats << 32);
hwstats->rx_packets			+= fe_r32(base + 0x08);
hwstats->rx_overflow			+= fe_r32(base + 0x10);
hwstats->rx_fcs_errors			+= fe_r32(base + 0x14);
hwstats->rx_short_errors		+= fe_r32(base + 0x18);
hwstats->rx_long_errors			+= fe_r32(base + 0x1c);
hwstats->rx_checksum_errors		+= fe_r32(base + 0x20);
hwstats->rx_flow_control_packets	+= fe_r32(base + 0x24);
hwstats->tx_skip			+= fe_r32(base + 0x28);
hwstats->tx_collisions			+= fe_r32(base + 0x2c);
hwstats->tx_bytes			+= fe_r32(base + 0x30);
stats					=  fe_r32(base + 0x34);
if (stats)
hwstats->tx_bytes		+= (stats << 32);
hwstats->tx_packets			+= fe_r32(base + 0x38);
} else {
hwstats->tx_bytes			+= fe_r32(base);
hwstats->tx_packets			+= fe_r32(base + 0x04);
hwstats->tx_skip			+= fe_r32(base + 0x08);
hwstats->tx_collisions			+= fe_r32(base + 0x0c);
hwstats->rx_bytes			+= fe_r32(base + 0x20);
hwstats->rx_packets			+= fe_r32(base + 0x24);
hwstats->rx_overflow			+= fe_r32(base + 0x28);
hwstats->rx_fcs_errors			+= fe_r32(base + 0x2c);
hwstats->rx_short_errors		+= fe_r32(base + 0x30);
hwstats->rx_long_errors			+= fe_r32(base + 0x34);
hwstats->rx_checksum_errors		+= fe_r32(base + 0x38);
hwstats->rx_flow_control_packets	+= fe_r32(base + 0x3c);
}

u64_stats_update_end(&hwstats->syncp);
}

The above function is used to update statistics for both the MT7621 and MT7628 MAC
devices. We could have two implementations, but this would probably be a bit
inefficient. As you can see in the patch, the base stat




NEXT




<s> static void oxnas_pcie_init_hw(struct platform_device *pdev,
struct oxnas_pcie *pcie)
{
u32 version_id;
int ret;

clk_prepare_enable(pcie->busclk);

/* reset PCIe cards use hard-wired gpio pin */
if (pcie->card_reset >= 0 &&
!gpio_direction_output(pcie->card_reset, 0)) {
wmb();
mdelay(10);
/* must tri-state the pin to pull it up */
gpio_direction_input(pcie->card_reset);
wmb();
mdelay(100);
}

/* ToDo: use phy power-on port... */
regmap_update_bits(pcie->sys_ctrl, SYS_CTRL_HCSL_CTRL_REGOFFSET,
BIT(pcie->hcsl_en), BIT(pcie->hcsl_en));

/* core */
ret = device_reset(&pdev->dev);
if (ret) {
dev_err(&pdev->dev, "core reset failed %d\n", ret);
return;
}

/* Start PCIe core clocks */
clk_prepare_enable(pcie->clk);

version_id = readl_relaxed(pcie->base + PCI_CONFIG_VERSION_DEVICEID);
dev_info(&pdev->dev, "PCIe version/deviceID 0x%x\n", version_id);

if (version_id != VERSION_ID_MAGIC) {
dev_info(&pdev->dev, "PCIe controller not found\n");
pcie->haslink = 0;
return;
}

/* allow entry to L23 state */
regmap_write_bits(pcie->sys_ctrl, pcie->pcie_ctrl_offset,
PCIE_READY_ENTR_L23, PCIE_READY_ENTR_L23);

/* Set PCIe core into RootCore mode */
regmap_write_bits(pcie->sys_ctrl, pcie->pcie_ctrl_offset,
PCIE_DEVICE_TYPE_MASK, PCIE_DEVICE_TYPE_ROOT);
wmb();

/* Bring up the PCI core */
regmap_write_bits(pcie->sys_ctrl, pcie->pcie_ctrl_offset,
PCIE_LTSSM, PCIE_LTSSM);
wmb();
}

The above function is used to
1. Enable the PCIe bus clock.
2. Reset the PCIe controller using GPIO.
3. Enable the RootCore mode on the PCI controller.

Notice the use of PCI_CONFIG_VERSION_DEVICEID to




NEXT




<s> ret_t rtl8367c_getAsicRlppTrap8051(rtk_uint32 *pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLPP_8051_TRAP_OFFSET, pEnabled);
}

The above function is used to retrieve the setting for RLPP trap action, trap action is enable in hardware to process RLPP packet. There are two types of  RLPP packet processing. a) If the packet is a RLPP packet, hardware will directly




NEXT




<s> static void __exit rtc_exit (void)
{
misc_deregister(&rtc_dev);
printk(KERN_INFO "Successfully removed RTC RV5C386A driver\n");
}

The above function is used to remove the rtc rvc386a driver. As you can see on a line #3, it calls the function called misc_deregister.

misc_deregister is a API which is defined in the




NEXT




<s> static int rtl8366s_sw_set_port_led(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;
u32 mask;
u32 reg;

if (val->port_vlan >= RTL8366S_NUM_PORTS ||
(1 << val->port_vlan) == RTL8366S_PORT_UNKNOWN)
return -EINVAL;

if (val->port_vlan == RTL8366S_PORT_NUM_CPU) {
reg = RTL8366S_LED_BLINKRATE_REG;
mask = 0xF << 4;
data = val->value.i << 4;
} else {
reg = RTL8366S_LED_CTRL_REG;
mask = 0xF << (val->port_vlan * 4),
data = val->value.i << (val->port_vlan * 4);
}

return rtl8366_smi_rmwr(smi, reg, mask, data);
}

The above function is used to set port led according to port index and blink time(port led blink rate set according to the value of switch_val).</s>




NEXT




<s> const cipher_t *get_default_cipher(void)
{
return mbedtls_cipher_info_from_type (MBEDTLS_CIPHER_AES_128_CBC);
}

The above function is used to set a default cipher when no options have been selected.
In this case, the AES-128-CBC cipher will be used.</s>




NEXT




<s> u32 rtl9300_sds_mode_get(int sds_num)
{
u32 v;

if (sds_num < 0 || sds_num > 11) {
pr_err("Wrong SerDes number: %d\n", sds_num);
return 0;
}

v = sw_r32(rtl9300_sds_regs[sds_num]);
v >>= rtl9300_sds_lsb[sds_num];

return v & 0x1f;
}

The above function is used to get the mode of SerDes. But actually sometimes RTL9300 will have an error, this function only works for the most cases.

For those cases, when SDS mode is wrong, we will need to use the following




NEXT




<s> static int rfc3686_aes_encrypt(struct ablkcipher_request *areq)
{
struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);
struct aes_ctx *ctx = crypto_ablkcipher_ctx(cipher);
int ret;
u8 *info = areq->info;
u8 rfc3686_iv[16];

memcpy(rfc3686_iv, ctx->nonce, CTR_RFC3686_NONCE_SIZE);
memcpy(rfc3686_iv + CTR_RFC3686_NONCE_SIZE, info, CTR_RFC3686_IV_SIZE);

/* initialize counter portion of counter block */
*(__be32 *)(rfc3686_iv + CTR_RFC3686_NONCE_SIZE + CTR_RFC3686_IV_SIZE) =
cpu_to_be32(1);

areq->info = rfc3686_iv;
ret = lq_aes_queue_mgr(ctx, areq, areq->info, CRYPTO_DIR_ENCRYPT, 4);
areq->info = info;
return ret;
}

The above function is used to create a RFC3686 style authentication tag
in the nonce when using the LQ AES queue manager to encrypt a block
of data. The nonce, the tag, and the tagging info structure will
look




NEXT




<s> static bool swlib_match_name(struct switch_dev *dev, const char *name)
{
return (strcmp(name, dev->dev_name) == 0 ||
strcmp(name, dev->alias) == 0);
}

The above function is used to get the switch device structure for a switch_dev
. The switch_dev is populated by some other functions like switch_dev_register(),
switch_dev_register_vlan_dev() and switch_dev_unregister() and




NEXT




<s> FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to process YYtext.  It is the responsible for interpreting
and executing code in YYtext.


	void yyerror ( char *_p );

The above will call the user-defined function called Y




NEXT




<s> static int rtl8367_led_group_set_config(struct rtl8366_smi *smi,
unsigned int led, unsigned int cfg)
{
u16 mask;
u16 set;
int err;

mask = (RTL8367_LED_CONFIG_LED_CFG_M << (led * 4)) |
RTL8367_LED_CONFIG_SEL;
set = (cfg & RTL8367_LED_CONFIG_LED_CFG_M) << (led * 4);

REG_RMW(smi, RTL8367_LED_CONFIG_REG, mask, set);
return 0;
}

The above function is used to read/set the Led configuration register.</s>




NEXT




<s> static int _nvram_rehash(nvram_handle_t *h)
{
nvram_header_t *header = nvram_header(h);
char buf[] = "0xXXXXXXXX", *name, *value, *eq;

/* (Re)initialize hash table */
_nvram_free(h);

/* Parse and set "name=value\0 ... \0\0" */
name = (char *) &header[1];

for (; *name; name = value + strlen(value) + 1) {
if (!(eq = strchr(name, '=')))
break;
*eq = '\0';
value = eq + 1;
nvram_set(h, name, value);
*eq = '=';
}

/* Set special SDRAM parameters */
if (!nvram_get(h, "sdram_init")) {
sprintf(buf, "0x%04X", (uint16_t)(header->crc_ver_init >> 16));
nvram_set(h, "sdram_init", buf);
}
if (!nvram_get(h, "sdram_config")) {
sprintf(buf, "0x%04X", (uint16_t)(header->config_refresh & 0xffff));
nvram_set(h, "sdram_config", buf);
}
if (!nvram_get(h, "sdram_refresh")) {
sprintf(buf, "0x%04X",
(uint16_t)((header->config_refresh >> 16) & 0xffff));
nvram_set(h, "sdram_refresh", buf);
}
if (!nvram_get(h, "sdram_ncdl")) {
sprintf(buf, "0x%08X", header->config_ncdl);
nvram_set(h, "sdram_ncdl", buf);
}

return 0;
}

The above function is used to read and write nvram data from memory and flash.

But for the new NV1 bootloader, nvram_rehash is NOT called in the new nvram_init().
It is still called in nvram_save, which




NEXT




<s> static void mt7621_nfc_wait_pio_ready(struct mt7621_nfc *nfc)
{
struct device *dev = nfc->dev;
int ret;
u16 val;

ret = readw_poll_timeout_atomic(nfc->nfi_regs + NFI_PIO_DIRDY, val,
val & PIO_DIRDY, 10,
NFI_CORE_TIMEOUT);
if (ret < 0)
dev_err(dev, "NFI core PIO mode not ready\n");
}

The above function is used to ensure that when NFC is in PIO mode, NW_INT
and PIO_DIRDY are high.

After a read/write operation, PIO_DIRDY will be low after a delay.
If




NEXT




<s> static void expr_print_file_helper(void *data, struct symbol *sym, const char *str)
{
xfwrite(str, strlen(str), 1, data);
}

The above function is used to print a string expression onto the file named by <i>data</i>. Note that <tt><a href="#XFWRITE">xfwrite</a></tt> is called for each character in the string, thus preventing <a href="#




NEXT




<s> static void i2c_stop(void)
{
sdalo();
sclhi();
sdahi();
}

The above function is used to end a stop bit, that follows the receipt of a stop signal by the slave device.

static void i2c_start(void)
{
sclhi();
sdalo();
sdahi();
scl




NEXT




<s> static int _aw9523_gpio_get_multiple(struct aw9523 *awi, u8 regbit,
u8 *state, u8 mask)
{
u32 dir_in, val;
u8 m;
int ret;

/* Registers are 8-bits wide */
ret = regmap_read(awi->regmap, AW9523_REG_CONF_STATE(regbit), &dir_in);
if (ret)
return ret;
*state = 0;

m = mask & dir_in;
if (m) {
ret = regmap_read(awi->regmap, AW9523_REG_IN_STATE(regbit),
&val);
if (ret)
return ret;
*state |= (u8)val & m;
}

m = mask & ~dir_in;
if (m) {
ret = regmap_read(awi->regmap, AW9523_REG_OUT_STATE(regbit),
&val);
if (ret)
return ret;
*state |= (u8)val & m;
}

return 0;
}

The above function is used to fetch the value of GPIOS which is written to both OUT_CONFIG and IN_CONFIG register.

Here's the code that writes the value to the appropriate registers in case of GPIOS:

	regmap_write




NEXT




<s> ret_t rtl8367c_getAsicLedSerialOutput(rtk_uint32 *pOutput, rtk_uint32 *pPmask)
{
ret_t retVal;

if(pOutput == NULL)
return RT_ERR_NULL_POINTER;

if(pPmask == NULL)
return RT_ERR_NULL_POINTER;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SERIAL_LED_CTRL, RTL8367C_SERIAL_LED_GROUP_NUM_MASK, pOutput);
if (retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SERIAL_LED_CTRL, RTL8367C_SERIAL_LED_PORT_EN_MASK, pPmask);
if (retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the serial LED setting from ASIC
register. The inputs for the function are pointers to the 32-bit
variable to hold the setting and a 32-bit pointer to hold the mask
used for checking the port




NEXT




<s> static void gpio_keys_irq_close(struct gpio_keys_button_dev *bdev)
{
struct gpio_keys_platform_data *pdata = bdev->pdata;
size_t i;

for (i = 0; i < pdata->nbuttons; i++) {
struct gpio_keys_button_data *bdata = &bdev->data[i];

disable_irq(bdata->irq);
cancel_delayed_work_sync(&bdata->work);
}
}

The above function is used to close the interrupts related to the input device when it is ready to be closed. All buttons need to be unregistered, but buttons can have different numbers of keys.

Each button has a variable for its number of keys, from p




NEXT




<s> static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to initialize the PTM data in the driver layer.

#endif /* __ASM_ARCH_PTM_PTM_COMM.H__ */

The above function is used to initialize the PTM data in the driver layer.




NEXT




<s> static int rtl83xx_find_l2_hash_entry(struct rtl838x_switch_priv *priv, u64 seed,
bool must_exist, struct rtl838x_l2_entry *e)
{
int idx = -1;
u32 key = priv->r->l2_hash_key(priv, seed);
u64 entry;

pr_debug("%s: using key %x, for seed %016llx\n", __func__, key, seed);
/* Loop over all entries in the hash-bucket and over the second block on 93xx SoCs */
for (int i = 0; i < priv->l2_bucket_size; i++) {
entry = priv->r->read_l2_entry_using_hash(key, i, e);
pr_debug("valid %d, mac %016llx\n", e->valid, ether_addr_to_u64(&e->mac[0]));
if (must_exist && !e->valid)
continue;
if (!e->valid || ((entry & 0x0fffffffffffffffULL) == seed)) {
idx = i > 3 ? ((key >> 14) & 0xffff) | i >> 1 : ((key << 2) | i) & 0xffff;
break;
}
}

return idx;
}

The above function is used to determine if a has entry for a specific address exists. If the ‘must_exist’ is set, the function aborts if entry with the specific address does not exist. The entry number is returned as an index if an entry is found.</s>




NEXT




<s> static void dma_chan_rst(struct dc_ep_dev *dev, int cn)
{
ep_wr32(cn, DMA_CS);
ep_wr32(0x2, DMA_CCTRL);
while (ep_rd32(DMA_CCTRL) & 0x01)
udelay(10);
}

The above function is used to reset a channel, it just write the control register (DMA_CCTRL) to 0x02 and then wait a while with 10us resolution.
For normal purpose, it works, but not reliable enough to use in a




NEXT




<s> u32 rtl9300_sds_sym_err_get(int sds_num, phy_interface_t phy_mode)
{
u32 v = 0;

switch (phy_mode) {
case PHY_INTERFACE_MODE_XGMII:
break;

case PHY_INTERFACE_MODE_10GBASER:
v = rtl930x_read_sds_phy(sds_num, 5, 1);
return v & 0xff;

default:
pr_info("%s unsupported PHY-mode\n", __func__);
}

return v;
}

The above function is used to get the symbol error count (SDE) of the channel with sds_num index.

In case PHY_INTERFACE_MODE_10GBASER, the SDE is available in B1G_0_1




NEXT




<s> static int mtdsplit_parse_eva(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct mtd_partition *parts;
struct eva_image_header hdr;
size_t retlen;
unsigned long kernel_size, rootfs_offset;
int err;

err = mtd_read(master, 0, sizeof(hdr), &retlen, (void *) &hdr);
if (err)
return err;

if (retlen != sizeof(hdr))
return -EIO;

if (le32_to_cpu(hdr.magic) != EVA_MAGIC)
return -EINVAL;

kernel_size = le32_to_cpu(hdr.size) + EVA_FOOTER_SIZE;

/* rootfs starts at the next 0x10000 boundary: */
rootfs_offset = round_up(kernel_size, 0x10000);

/* skip the dummy EVA squashfs partition (with wrong endianness): */
rootfs_offset += EVA_DUMMY_SQUASHFS_SIZE;

if (rootfs_offset >= master->size)
return -EINVAL;

err = mtd_check_rootfs_magic(master, rootfs_offset, NULL);
if (err)
return err;

parts = kzalloc(EVA_NR_PARTS * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = 0;
parts[0].size = kernel_size;

parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = master->size - rootfs_offset;

*pparts = parts;
return EVA_NR_PARTS;
}

The above function is used to parse the “Electrolytic Virtual Array (EVA)”-based embedded device. EVA is another Android device, but it can be seen that the way the kernel partition is mapped onto the device depends heavily on the way that




NEXT




<s> static inline void add_data(char *ptr, int len)
{
if (ofs + len > erasesize) {
pad(erasesize);
prep_eraseblock();
}
memcpy(buf + ofs, ptr, len);
ofs += len;
}

The above function is used to write data without using fwrite or fputs, and
the fwrite function is also using memcpy to copy data to the file.
Then is it possible that the data and memory copied by memcpy function
is saved to the file in the




NEXT




<s> static int fe_start_xmit(struct sk_buff *skb, struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);
struct fe_tx_ring *ring = &priv->tx_ring;
struct net_device_stats *stats = &dev->stats;
int tx_num;
int len = skb->len;

if (fe_skb_padto(skb, priv)) {
netif_warn(priv, tx_err, dev, "tx padding failed!\n");
return NETDEV_TX_OK;
}

tx_num = fe_cal_txd_req(skb);
if (unlikely(fe_empty_txd(ring) <= tx_num)) {
netif_stop_queue(dev);
netif_err(priv, tx_queued, dev,
"Tx Ring full when queue awake!\n");
return NETDEV_TX_BUSY;
}

if (fe_tx_map_dma(skb, dev, tx_num, ring) < 0) {
stats->tx_dropped++;
} else {
stats->tx_packets++;
stats->tx_bytes += len;
}

return NETDEV_TX_OK;
}

The above function is used to transfer the packet out of the system.
The function first checks the skb’s padding and if is valid, it passes the skb to the fe_cal_txd_req() function. This function calculates the number of TX descriptors




NEXT




<s> static inline int rtl931x_mac_force_mode_ctrl(int p)
{
return RTL931X_MAC_FORCE_MODE_CTRL + (p << 2);
}

The above function is used to set up force mode of mac. force mode is to let PHY to work in specific mode,
such as 100base-fx, 10base-tx. so when mac receive frame, it will directly set PHY




NEXT




<s> ret_t rtl8367c_setAsicGreenHighPriorityTraffic(rtk_uint32 port)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_REG_HIGHPRI_INDICATOR, port, 1);
}

The above function is used to set the high priority port for traffic
in 1G high-speed ports. This function is used to call rtl8367c_setAsicGreenHighPriorityPorts to set the
prioritized traffic.





NEXT




<s> void rtl838x_config_qos(void)
{
u32 v;

pr_info("Setting up RTL838X QoS\n");
pr_info("RTL838X_PRI_SEL_TBL_CTRL(i): %08x\n", sw_r32(RTL838X_PRI_SEL_TBL_CTRL(0)));
rtl83xx_setup_default_prio2queue();

/* Enable inner (bit 12) and outer (bit 13) priority remapping from DSCP */
sw_w32_mask(0, BIT(12) | BIT(13), RTL838X_PRI_DSCP_INVLD_CTRL0);

/* Set default weight for calculating internal priority, in prio selection group 0
* Port based (prio 3), Port outer-tag (4), DSCP (5), Inner Tag (6), Outer Tag (7)
*/
v = 3 | (4 << 3) | (5 << 6) | (6 << 9) | (7 << 12);
sw_w32(v, RTL838X_PRI_SEL_TBL_CTRL(0));

/* Set the inner and outer priority one-to-one to re-marked outer dot1p priority */
v = 0;
for (int p = 0; p < 8; p++)
v |= p << (3 * p);
sw_w32(v, RTL838X_RMK_OPRI_CTRL);
sw_w32(v, RTL838X_RMK_IPRI_CTRL);

v = 0;
for (int p = 0; p < 8; p++)
v |= (dot1p_priority_remapping[p] & 0x7) << (p * 3);
sw_w32(v, RTL838X_PRI_SEL_IPRI_REMAP);

/* On all ports set scheduler type to WFQ */
for (int i = 0; i <= soc_info.cpu_port; i++)
sw_w32(0, RTL838X_SCHED_P_TYPE_CTRL(i));

/* Enable egress scheduler for CPU-Port */
sw_w32_mask(0, BIT(8), RTL838X_SCHED_LB_CTRL(soc_info.cpu_port));

/* Enable egress drop allways on */
sw_w32_mask(0, BIT(11), RTL838X_FC_P_EGR_DROP_CTRL(soc_info.cpu_port));

/* Give special trap frames priority 7 (BPDUs) and routing exceptions: */
sw_w32_mask(0, 7 << 3 | 7, RTL838X_QM_PKT2CPU_INTPRI_2);
/* Give RMA frames priority 7: */
sw_w32_mask(0, 7, RTL838X_QM_PKT2CPU_INTPRI_1);
}

The above function is used to configure the priority of the scheduler in RTL-838X switch.

void rtl83xx_setup_default_prio2queue(void)
{
u32 v;

#if CONFIG




NEXT




<s> int danube_start(int pp32)
{
int ret;

/*  download firmware   */
ret = danube_pp32_download_code(
danube_fw_bin, sizeof(danube_fw_bin) / sizeof(*danube_fw_bin),
danube_fw_data, sizeof(danube_fw_data) / sizeof(*danube_fw_data));
if ( ret != 0 )
return ret;

/*  run PP32    */
IFX_REG_W32(DBG_CTRL_START_SET(1), PP32_DBG_CTRL);

/*  idle for a while to let PP32 init itself    */
udelay(10);

return 0;
}

The above function is used to test the firmware download process,
if no problem exists, we can call PP32 directly and wait for the
message response.</s>




NEXT




<s> void menu_get_ext_help(struct menu *menu, struct gstr *help)
{
struct symbol *sym = menu->sym;
const char *help_text = nohelp_text;

if (menu_has_help(menu)) {
if (sym->name)
str_printf(help, "%s%s:\n\n", CONFIG_, sym->name);
help_text = menu_get_help(menu);
}
str_printf(help, "%s\n", help_text);
if (sym)
get_symbol_str(help, sym, NULL);
}

The above function is used to read the help for a menu option. In a game that has no help, this function would get a nohelp_text instead. The function also provides the symbol name for the function being called, if one exists. Using this, we can then




NEXT




<s> static int rtl8366rb_sw_set_port_rate_out(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

if (val->port_vlan >= RTL8366RB_NUM_PORTS)
return -EINVAL;

rtl8366_smi_rmwr(smi, RTL8366RB_EB_PREIFG_REG,
RTL8366RB_EB_PREIFG_MASK,
(RTL8366RB_QOS_DEFAULT_PREIFG << RTL8366RB_EB_PREIFG_OFFSET));

if (val->value.i > 0 && val->value.i < RTL8366RB_BDTH_SW_MAX)
val->value.i = (val->value.i - 1) / RTL8366RB_BDTH_UNIT;
else
val->value.i = RTL8366RB_BDTH_REG_DEFAULT;

return rtl8366_smi_rmwr(smi, RTL8366RB_EB_REG(val->port_vlan),
RTL8366RB_EB_BDTH_MASK, val->value.i );

}

The above function is used to set SW rate on each port which is a rate caping set.</s>




NEXT




<s> mvswitch_detach(struct phy_device *pdev)
{
struct mvswitch_priv *priv = to_mvsw(pdev);
struct net_device *dev = pdev->attached_dev;

if (!dev)
return;

dev->phy_ptr = NULL;
dev->eth_mangle_rx = NULL;
dev->eth_mangle_tx = NULL;
dev->features = priv->orig_features;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
dev->priv_flags &= ~IFF_NO_IP_ALIGN;
#else
dev->extra_priv_flags &= ~IFF_NO_IP_ALIGN;
#endif
}

The above function is used to detach a phy device from the net_device. It is used whenever the netlink connection is closed (e.g., when the module is removed, when the module is unloaded, when the device is removed). Therefore, this function




NEXT




<s> static int rtl930x_pie_rule_add(struct rtl838x_switch_priv *priv, struct pie_rule *pr)
{
int idx, block, j, t;
int min_block = 0;
int max_block = priv->n_pie_blocks / 2;

if (pr->is_egress) {
min_block = max_block;
max_block = priv->n_pie_blocks;
}
pr_debug("In %s\n", __func__);

mutex_lock(&priv->pie_mutex);

for (block = min_block; block < max_block; block++) {
for (j = 0; j < 2; j++) {
t = (sw_r32(RTL930X_PIE_BLK_TMPLTE_CTRL(block)) >> (j * 4)) & 0xf;
pr_debug("Testing block %d, template %d, template id %d\n", block, j, t);
pr_debug("%s: %08x\n",
__func__, sw_r32(RTL930X_PIE_BLK_TMPLTE_CTRL(block)));
idx = rtl930x_pie_verify_template(priv, pr, t, block);
if (idx >= 0)
break;
}
if (j < 2)
break;
}

if (block >= priv->n_pie_blocks) {
mutex_unlock(&priv->pie_mutex);
return -EOPNOTSUPP;
}

pr_debug("Using block: %d, index %d, template-id %d\n", block, idx, j);
set_bit(idx, priv->pie_use_bm);

pr->valid = true;
pr->tid = j;  /* Mapped to template number */
pr->tid_m = 0x1;
pr->id = idx;

rtl930x_pie_lookup_enable(priv, idx);
rtl930x_pie_rule_write(priv, idx, pr);

mutex_unlock(&priv->pie_mutex);
return 0;
}

The above function is used to add pie rules during driver probe


static struct pie_rule * rtl930x_pie_rule_del(struct rtl838x_switch_priv *priv, struct pie_rule *pr)





NEXT




<s> static void load(void)
{
uint32_t addr;
int ret;

ret = spi_init(0, CONFIG_SPI_MAX_HZ, SPI_MODE_0);
if (ret) {
puts("Failed to initialize SPI controller\n");
return;
}

ret = spi_claim_bus();
if (ret) {
puts("Failed to enable SPI controller\n");
return;
}

addr = do_load();

spi_release_bus();

if (addr != UINT32_MAX)
enter_image(addr);
}

The above function is used to load an executable binary using the SPI bus.

What I need some help with is the function do_load();

Here is the code in u-boot-dm368-1.1.0:

/*




NEXT




<s> int dc_ep_clk_get(struct dc_ep_priv *priv, u32 *sysclk, u32 *ppeclk)
{
u32 val;

val = rd32(PLL_OMCFG);
*sysclk = MS(val, SYS_CLK);
*ppeclk = MS(val, PPE_CLK);
return 0;
}

The above function is used to get the value of PLL(sysclk,ppeclk).

My question is, when the PLL is running, how to judge which is the current set clock: sysclk or ppeclk ?

For example, if we




NEXT




<s> ret_t rtl8367c_setAsicSvlanUplinkPortMask(rtk_uint32 portMask)
{
return rtl8367c_setAsicReg(RTL8367C_REG_SVLAN_UPLINK_PORTMASK, portMask);
}

The above function is used to set the SVLAN uplink port mask, which is used during SVLAN frame forwarding. Please refer to datasheet [26] for details.
The below function can be used to set the SVLAN ingress / egress




NEXT




<s> static void i2c_init(void)
{
/* no gpio_control for EXTIF */
// ssb_gpio_control(&ssb, sda_mask | scl_mask, 0);

gpio_set_value(sda_index, 0);
gpio_set_value(scl_index, 0);
sdahi();
sclhi();
}

The above function is used to pull down the i2c bus in between
transactions.
static void i2c_sda(void)
{
gpio_set_value(sda_index, 1);
sdahi();
}





NEXT




<s> rtk_api_ret_t rtk_filter_iprange_get(rtk_uint32 index, rtk_filter_iprange_t *pType, ipaddr_t *pUpperIp, ipaddr_t *pLowerIp)
{
rtk_api_ret_t ret;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if((NULL == pType) || (NULL == pUpperIp) || (NULL == pLowerIp))
return RT_ERR_NULL_POINTER;

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

if((ret = rtl8367c_getAsicAclIpRange(index, pType, pUpperIp, pLowerIp)) != RT_ERR_OK)
return ret;

return RT_ERR_OK;
}

The above function is used to read the ACL Rule IP Range entry. The data structure of iprange_t is:

/* Get ACL rules filter IP range info */

typedef struct
{
rtk_filter_iprange_t type




NEXT




<s> ar8216_read_port_link(struct ar8xxx_priv *priv, int port,
struct switch_port_link *link)
{
u32 status;
u32 speed;

memset(link, '\0', sizeof(*link));

status = priv->chip->read_port_status(priv, port);

link->aneg = !!(status & AR8216_PORT_STATUS_LINK_AUTO);
if (link->aneg) {
link->link = !!(status & AR8216_PORT_STATUS_LINK_UP);
} else {
link->link = true;

if (priv->get_port_link) {
int err;

err = priv->get_port_link(port);
if (err >= 0)
link->link = !!err;
}
}

if (!link->link)
return;

link->duplex = !!(status & AR8216_PORT_STATUS_DUPLEX);
link->tx_flow = !!(status & AR8216_PORT_STATUS_TXFLOW);
link->rx_flow = !!(status & AR8216_PORT_STATUS_RXFLOW);

if (link->aneg && link->duplex && priv->chip->read_port_eee_status)
link->eee = priv->chip->read_port_eee_status(priv, port);

speed = (status & AR8216_PORT_STATUS_SPEED) >>
AR8216_PORT_STATUS_SPEED_S;

switch (speed) {
case AR8216_PORT_SPEED_10M:
link->speed = SWITCH_PORT_SPEED_10;
break;
case AR8216_PORT_SPEED_100M:
link->speed = SWITCH_PORT_SPEED_100;
break;
case AR8216_PORT_SPEED_1000M:
link->speed = SWITCH_PORT_SPEED_1000;
break;
default:
link->speed = SWITCH_PORT_SPEED_UNKNOWN;
break;
}
}

The above function is used to obtain the link status, duplex,flow control status, EEE and speed of a link that is managed by the Ar8216 chip.</s>




NEXT




<s> static void rtl8367_switch_cleanup(struct rtl8366_smi *smi)
{
unregister_switch(&smi->sw_dev);
}

The above function is used to clean up a switch. The last line of the
function is a function call to
register_switch. And if we check the documentation,
we find out that both the functions are related
to switch device. And they both are used to




NEXT




<s> static void danube_init(struct platform_device *pdev)
{
volatile u32 *p = SB_RAM0_ADDR(0);
unsigned int i;

ltq_pmu_enable(IFX_PMU_MODULE_PPE_SLL01 |
IFX_PMU_MODULE_PPE_TC |
IFX_PMU_MODULE_PPE_EMA |
IFX_PMU_MODULE_PPE_QSB |
IFX_PMU_MODULE_TPE |
IFX_PMU_MODULE_DSL_DFE);

reset_ppe(pdev);

/* init ema */
IFX_REG_W32((EMA_CMD_BUF_LEN << 16) | (EMA_CMD_BASE_ADDR >> 2), EMA_CMDCFG);
IFX_REG_W32((EMA_DATA_BUF_LEN << 16) | (EMA_DATA_BASE_ADDR >> 2), EMA_DATACFG);
IFX_REG_W32(0x000000FF, EMA_IER);
IFX_REG_W32(EMA_READ_BURST | (EMA_WRITE_BURST << 2), EMA_CFG);

/* init mailbox */
IFX_REG_W32(0xFFFFFFFF, MBOX_IGU1_ISRC);
IFX_REG_W32(0x00000000, MBOX_IGU1_IER);
IFX_REG_W32(0xFFFFFFFF, MBOX_IGU3_ISRC);
IFX_REG_W32(0x00000000, MBOX_IGU3_IER);

/* init atm tc */
IFX_REG_W32(0x0000,     DREG_AT_CTRL);
IFX_REG_W32(0x0000,     DREG_AR_CTRL);
IFX_REG_W32(0x0,        DREG_AT_IDLE0);
IFX_REG_W32(0x0,        DREG_AT_IDLE1);
IFX_REG_W32(0x0,        DREG_AR_IDLE0);
IFX_REG_W32(0x0,        DREG_AR_IDLE1);
IFX_REG_W32(0x40,       RFBI_CFG);
IFX_REG_W32(0x1600,     SFSM_DBA0);
IFX_REG_W32(0x1718,     SFSM_DBA1);
IFX_REG_W32(0x1830,     SFSM_CBA0);
IFX_REG_W32(0x1844,     SFSM_CBA1);
IFX_REG_W32(0x14014,    SFSM_CFG0);
IFX_REG_W32(0x14014,    SFSM_CFG1);
IFX_REG_W32(0x1858,     FFSM_DBA0);
IFX_REG_W32(0x18AC,     FFSM_DBA1);
IFX_REG_W32(0x10006,    FFSM_CFG0);
IFX_REG_W32(0x10006,    FFSM_CFG1);
IFX_REG_W32(0x00000001, FFSM_IDLE_HEAD_BC0);
IFX_REG_W32(0x00000001, FFSM_IDLE_HEAD_BC1);

for ( i = 0; i < SB_RAM0_DWLEN + SB_RAM1_DWLEN + SB_RAM2_DWLEN + SB_RAM3_DWLEN; i++ )
IFX_REG_W32(0, p++);
}

The above function is used to initialize all the peripheral registers of the CPU. It should take place as soon as the CPU has been started.
Notice that we use volatile variable to access the peripheral registers, this is because they may be  stored in the CPU on




NEXT




<s> static void rtl838x_mac_link_up(struct phylink_config *config,
struct phy_device *phy, unsigned int mode,
phy_interface_t interface, int speed, int duplex,
bool tx_pause, bool rx_pause)
{
struct net_device *dev = container_of(config->dev, struct net_device, dev);
struct rtl838x_eth_priv *priv = netdev_priv(dev);

pr_debug("In %s\n", __func__);
/* Restart TX/RX to port */
sw_w32_mask(0, 0x03, priv->r->mac_port_ctrl(priv->cpu_port));
}

The above function is used to update the maclink status in hardware.
However in some cases the above function is not called in case PHY
get the linkup signal. For ex: PHY may be link up but the hardware is not in linkup
state.




NEXT




<s> rtk_api_ret_t rtk_l2_ipVidMcastAddr_next_get(rtk_uint32 *pAddress, rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr)
{
rtk_api_ret_t   retVal;
rtl8367c_luttb  l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Error Checking */
if ((pAddress == NULL) || (pIpVidMcastAddr == NULL))
return RT_ERR_INPUT;

if(*pAddress > RTK_MAX_LUT_ADDR_ID )
return RT_ERR_L2_L2UNI_PARAM;

memset(&l2Table, 0, sizeof(rtl8367c_luttb));
l2Table.address = *pAddress;

do
{
if ((retVal = rtl8367c_getAsicL2LookupTb(LUTREADMETHOD_NEXT_L3MC, &l2Table)) != RT_ERR_OK)
return retVal;

if(l2Table.address < *pAddress)
return RT_ERR_L2_ENTRY_NOTFOUND;

}while(l2Table.l3vidlookup == 0);

pIpVidMcastAddr->sip        = l2Table.sip;
pIpVidMcastAddr->dip        = l2Table.dip;
pIpVidMcastAddr->vid        = l2Table.l3_vid;
pIpVidMcastAddr->address    = l2Table.address;

/* Get Logical port mask */
if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pIpVidMcastAddr->portmask)) != RT_ERR_OK)
return retVal;

*pAddress = l2Table.address;

return RT_ERR_OK;
}

The above function is used to search multi-cast IP address in hardware. The parameter input is logical address of LUT and LUT entry is returned.</s>




NEXT




<s> static int esw_remove(struct platform_device *pdev)
{
struct rt305x_esw *esw = platform_get_drvdata(pdev);

if (esw) {
esw_w32(esw, ~0, RT305X_ESW_REG_IMR);
platform_set_drvdata(pdev, NULL);
}

return 0;
}

The above function is used to disable a interrupt from the device driver (or the other way - to make something to stop).
It uses the function esw_w32() which is similar to w32() but for the Ecore Switch driver (the whole code




NEXT




<s> static bool nmbm_write_signature(struct nmbm_instance *ni, uint32_t limit,
const struct nmbm_signature *signature,
uint32_t *signature_ba)
{
uint32_t ba = ni->block_count - 1;
bool success;

while (ba > limit) {
if (nmbm_get_block_state(ni, ba) != BLOCK_ST_GOOD)
goto next_block;

/* Insurance to detect unexpected bad block marked by user */
if (nmbm_check_bad_phys_block(ni, ba)) {
nmbm_set_block_state(ni, ba, BLOCK_ST_BAD);
goto next_block;
}

success = nmbm_erase_block_and_check(ni, ba);
if (!success)
goto skip_bad_block;

success = nmbm_write_repeated_data(ni, ba, signature,
sizeof(*signature));
if (success) {
*signature_ba = ba;
return true;
}

skip_bad_block:
nmbm_mark_phys_bad_block(ni, ba);
nmbm_set_block_state(ni, ba, BLOCK_ST_BAD);

next_block:
ba--;
};

return false;
}

The above function is used to write the signature to the first bad block.
The function is called from the erase_flash implementation of various
NAND flash drivers.</s>




NEXT




<s> static void sha_init(uint32_t *buf)
{
buf[0] = 0x67452301;
buf[1] = 0xefcdab89;
buf[2] = 0x98badcfe;
buf[3] = 0x10325476;
buf[4] = 0xc3d2e1f0;
}

The above function is used to initialize to zero. But in this function there is a
problem that only the last array elements are zero.

How to fix it??

static void sha_init(uint32_t *buf)
{
buf




NEXT




<s> ret_t rtl8367c_getAsicPowerSaving(rtk_uint32 phy, rtk_uint32* enable)
{
rtk_api_ret_t retVal;
rtk_uint32 phyData;

if(NULL == enable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPHYReg(phy,PHY_POWERSAVING_REG,&phyData))!=RT_ERR_OK)
return retVal;

if ((phyData & 0x0004) > 0)
*enable = 1;
else
*enable = 0;

return RT_ERR_OK;
}

The above function is used to get the current state of the Asic Power Saving Mode. The enable is a Boolean to specify if the Asic Power Saving is turned on or off.

# Code Example

The following code shows how this function is used to




NEXT




<s> static int qca807x_cable_test_report_trans(int result)
{
switch (result) {
case QCA807X_CDT_RESULTS_OK:
return ETHTOOL_A_CABLE_RESULT_CODE_OK;
case QCA807X_CDT_RESULTS_OPEN:
return ETHTOOL_A_CABLE_RESULT_CODE_OPEN;
case QCA807X_CDT_RESULTS_SAME_SHORT:
return ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT;
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI1_SAME_OK:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI2_SAME_OK:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI3_SAME_OK:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI1_SAME_OPEN:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI2_SAME_OPEN:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI3_SAME_OPEN:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI1_SAME_SHORT:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI2_SAME_SHORT:
case QCA807X_CDT_RESULTS_CROSS_SHORT_WITH_MDI3_SAME_SHORT:
return ETHTOOL_A_CABLE_RESULT_CODE_CROSS_SHORT;
default:
return ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC;
}
}

The above function is used to extract an error code from a raw
hardware error code returned from a cable test on Broadcom's qca807x
part.</s>




NEXT




<s> ar8xxx_sw_get_mib_type(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

if (!ar8xxx_has_mib_counters(priv))
return -EOPNOTSUPP;
val->value.i = priv->mib_type;
return 0;
}

The above function is used to access a mib value of "type" attribute.
What is "type" and where is it used ?
I tried to read the code and understand the whole thing but I failed.
Since I am very new to firmwares and




NEXT




<s> void spi_release_bus(void)
{
espi_release_bus(&spi);
}

The above function is used to free the spi controller from the driver that is currently driving it.

static inline int spi_wait(struct spi_device *spi)
{
int ret = 0;
if (spi->controller->spim




NEXT




<s> ret_t rtl8367c_setAsicPortEgressRateIfg(rtk_uint32 ifg)
{
ret_t retVal;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SCHEDULE_WFQ_CTRL, RTL8367C_SCHEDULE_WFQ_CTRL_OFFSET, ifg);

return retVal;
}

The above function is used to set the rate of outgoing port. It uses the register number (RTL8367C_REG_SCHEDULE_WFQ_CTRL) and the offset (RTL8367C_SCHEDULE_WF




NEXT




<s> ret_t rtl8367c_getAsicPortIngressBandwidth(rtk_uint32 port, rtk_uint32* pBandwidth, rtk_uint32* pPreifg, rtk_uint32* pEnableFC)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint32 regAddr;

/* Invalid input parameter */
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

regAddr = RTL8367C_INGRESSBW_PORT_RATE_LSB_REG(port);
retVal = rtl8367c_getAsicReg(regAddr, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pBandwidth = regData;

regAddr += 1;
retVal = rtl8367c_getAsicRegBits(regAddr, RTL8367C_INGRESSBW_PORT0_RATE_CTRL1_INGRESSBW_RATE16_MASK, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pBandwidth |= (regData << RTL8367C_QOS_GRANULARTY_MSB_OFFSET);

regAddr = RTL8367C_PORT_MISC_CFG_REG(port);
retVal = rtl8367c_getAsicRegBit(regAddr, RTL8367C_PORT0_MISC_CFG_INGRESSBW_IFG_OFFSET, pPreifg);
if(retVal != RT_ERR_OK)
return retVal;

regAddr = RTL8367C_PORT_MISC_CFG_REG(port);
retVal = rtl8367c_getAsicRegBit(regAddr, RTL8367C_PORT0_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET, pEnableFC);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the ingress queue band width for a specific port with 3 out parameters, * bandwidth, which is the port ingress band width, * preifg, which specifies if FIFO are present in ingress of the port




NEXT




<s> rtk_api_ret_t rtk_rate_stormControlPortEnable_get(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if (stormType >= STORM_GROUP_END)
return RT_ERR_SFC_UNKNOWN_GROUP;

if (NULL == pEnable)
return RT_ERR_ENABLE;

switch (stormType)
{
case STORM_GROUP_UNKNOWN_UNICAST:
if ((retVal = rtl8367c_getAsicStormFilterUnknownUnicastEnable(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_UNKNOWN_MULTICAST:
if ((retVal = rtl8367c_getAsicStormFilterUnknownMulticastEnable(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_MULTICAST:
if ((retVal = rtl8367c_getAsicStormFilterMulticastEnable(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_BROADCAST:
if ((retVal = rtl8367c_getAsicStormFilterBroadcastEnable(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;
break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to obtain the current filter status of the specified port storm group.

### Parameters

| Parameter | Description |
| port | Input port number, please refer to the parameter definition of rtk_port_t variable. |
| storm




NEXT




<s> ret_t rtl8367c_getAsicRmaLldp(rtk_uint32 *pEnabled, rtl8367c_rma_t* pRmacfg)
{
ret_t retVal;
rtk_uint32 regData;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_RMA_LLDP_EN, RTL8367C_RMA_LLDP_EN_OFFSET,pEnabled);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_RMA_CTRL_LLDP, &regData);
if(retVal != RT_ERR_OK)
return retVal;

pRmacfg->operation = ((regData >> 7) & 0x0003);
pRmacfg->discard_storm_filter = ((regData >> 6) & 0x0001);
pRmacfg->trap_priority = ((regData >> 3) & 0x0007);
pRmacfg->keep_format = ((regData >> 2) & 0x0001);
pRmacfg->vlan_leaky = ((regData >> 1) & 0x0001);
pRmacfg->portiso_leaky = (regData & 0x0001);

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, &regData);
if(retVal != RT_ERR_OK)
return retVal;

pRmacfg->trap_priority = regData;

return RT_ERR_OK;
}

The above function is used to retrieve ASIC registers to be programmed for the RMA feature.

# 7.6 Port Isolation (isolation of ports with the same type)

In a port level isolation, the switch has to be aware of the




NEXT




<s> static void rtl931x_fill_l2_row(u32 r[], struct rtl838x_l2_entry *e)
{
u32 port;

if (!e->valid) {
r[0] = r[1] = r[2] = 0;
return;
}

r[2] = BIT(31);	/* Set valid bit */

r[0] = ((u32)e->mac[0]) << 24 |
((u32)e->mac[1]) << 16 |
((u32)e->mac[2]) << 8 |
((u32)e->mac[3]);
r[1] = ((u32)e->mac[4]) << 24 |
((u32)e->mac[5]) << 16;

r[2] |= e->next_hop ? BIT(12) : 0;

if (e->type == L2_UNICAST) {
r[2] |= e->is_static ? BIT(14) : 0;
r[1] |= e->rvid & 0xfff;
r[2] |= (e->port & 0x3ff) << 20;
if (e->is_trunk) {
r[2] |= BIT(30);
port = e->stack_dev << 9 | (e->port & 0x3f);
} else {
port = (e->stack_dev & 0xf) << 6;
port |= e->port & 0x3f;
}
r[2] |= port << 20;
r[2] |= e->block_da ? BIT(15) : 0;
r[2] |= e->block_sa ? BIT(17) : 0;
r[2] |= e->suspended ? BIT(13) : 0;
r[2] |= (e->age & 0x3) << 17;
/* the UC_VID field in hardware is used for the VID or for the route id */
if (e->next_hop)
r[2] |= e->nh_route_id & 0x7ff;
else
r[2] |= e->vid & 0xfff;
} else { /* L2_MULTICAST */
r[2] |= (e->mc_portmask_index & 0x3ff) << 16;
r[2] |= e->mc_mac_index & 0x7ff;
}
}

The above function is used to write mac entries to L2 table.

I have two notes here, the first is about next_hop value.
In case next hop is configured, the last 10 bits are the route ID.
In case next_hop




NEXT




<s> void ifx_deu_aes_ofb (void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
ifx_deu_aes (ctx, dst, src, iv, nbytes, encdec, 2);
}

The above function is used to encrypt a whole buffer in one call and
return the encrypted buffer.
The encrypted message can be passed to gf1616_encode(3) and gf1616_crc_one(3




NEXT




<s> static int ag71xx_mdio_mii_read(struct mii_bus *bus, int addr, int reg)
{
struct ag71xx_mdio *am = bus->priv;
int err;
int ret;

err = ag71xx_mdio_wait_busy(am);
if (err)
return 0xffff;

regmap_write(am->mii_regmap, AG71XX_REG_MII_CMD, MII_CMD_WRITE);
regmap_write(am->mii_regmap, AG71XX_REG_MII_ADDR,
((addr & 0xff) << MII_ADDR_SHIFT) | (reg & 0xff));
regmap_write(am->mii_regmap, AG71XX_REG_MII_CMD, MII_CMD_READ);

err = ag71xx_mdio_wait_busy(am);
if (err)
return 0xffff;

regmap_read(am->mii_regmap, AG71XX_REG_MII_STATUS, &ret);
ret &= 0xffff;
regmap_write(am->mii_regmap, AG71XX_REG_MII_CMD, MII_CMD_WRITE);

DBG("mii_read: addr=%04x, reg=%04x, value=%04x\n", addr, reg, ret);

return ret;
}

The above function is used to do a read operation to the PHY registers. It has its own logic for handling errors, reading the result & checking the errors again. It can be easily seen that it assumes that the PHY it is talking to is already connected.






NEXT




<s> static void aca_txout_init(struct dc_ep_priv *priv,
struct aca_cfg_param *aca_txout)
{
u32 val = 0;
struct aca_mem_layout *mem_layout = to_mem_layout(priv);
struct aca_hif_params *hif_params = to_hif_params(priv);
struct aca_hif_param *txout_param = &hif_params->txout;

if (aca_txout->byteswap)
val = BYTE_SWAP_EN;

val |= (aca_txout->hd_size_in_dw - 1)
| SM((aca_txout->pd_size_in_dw - 1), PD_DESC_IN_DW);
wr32(val, TXOUT_CONV_CFG);

/* SoC Ring size */
val = aca_txout->soc_desc_num;
wr32(val, TXOUT_RING_CFG);

/* SoC cumulative counter address */
wr32(aca_txout->soc_cmlt_cnt_addr, GNRC_TXOUT_CMLT_CNT_ADDR);
/* SoC descriptors */
txout_param->soc_desc_base = aca_txout->soc_desc_base;
txout_param->soc_desc_num = aca_txout->soc_desc_num;

/* Ping/pong buffer */
txout_param->pp_buf_base = priv->phymem
+mem_layout->txout_host_desc_base;

txout_param->pp_buf_num = mem_layout->txout_host_dnum;

/* PD ring */
txout_param->pd_desc_base = priv->phymem
+ aca_txout->pd_desc_base;
txout_param->pd_desc_num = aca_txout->pd_desc_num;

txout_param->pd_desc_threshold = aca_txout->pp_buf_desc_num;

dev_dbg(priv->dev, "aca txout init done\n");
}

The above function is used to configure and initialize the transaction out portion of the HIF engine. Transaction out handles the physical transfer of the packets via HIF and thus has a lot of hardware registers associated with it that has to be configured and initialized.

The configuration of the




NEXT




<s> rtk_api_ret_t rtk_qos_dscpRemarkSrcSel_set(rtk_qos_dscpRmkSrc_t type)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= DSCP_RMK_SRC_END )
return RT_ERR_QOS_INT_PRIORITY;

if ((retVal = rtl8367c_setAsicRemarkingDscpSrc(type)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set dscp remarking source. There are total four (DSCP_RMK_SRC_IPTOS:IPv4), (DSCP_RMK_SRC_L3:L3 header), (DSC




NEXT




<s> void ar9_stop(int pp32)
{
IFX_REG_W32(DBG_CTRL_STOP, PP32_DBG_CTRL(0));
}

The above function is used to "STOP" the AR9004's debug registers. This causes the device to switch into RUN mode. It is therefore, possible to access any of the device registers and the registers in the peripherals.

While running the




NEXT




<s> static inline void rtl8366_debugfs_init(struct rtl8366_smi *smi) {}

The above function is used to initialize and enable debugfs for rtl8366 ethernet chip. The function is implemented as shown in the code snippet below:


#include "rtl8366_smi.h"
ex




NEXT




<s> void rtl9300_sds_tx_config(int sds, phy_interface_t phy_if)
{
/* parameters: rtl9303_80G_txParam_s2 */
int impedance = 0x8;
int pre_amp = 0x2;
int main_amp = 0x9;
int post_amp = 0x2;
int pre_en = 0x1;
int post_en = 0x1;
int page;

switch(phy_if) {
case PHY_INTERFACE_MODE_1000BASEX:
page = 0x25;
break;
case PHY_INTERFACE_MODE_HSGMII:
case PHY_INTERFACE_MODE_2500BASEX:
page = 0x29;
break;
case PHY_INTERFACE_MODE_10GBASER:
page = 0x2f;
break;
default:
pr_err("%s: unsupported PHY mode\n", __func__);
return;
}

rtl9300_sds_field_w(sds, page, 0x01, 15, 11, pre_amp);
rtl9300_sds_field_w(sds, page, 0x06,  4,  0, post_amp);
rtl9300_sds_field_w(sds, page, 0x07,  0,  0, pre_en);
rtl9300_sds_field_w(sds, page, 0x07,  3,  3, post_en);
rtl9300_sds_field_w(sds, page, 0x07,  8,  4, main_amp);
rtl9300_sds_field_w(sds, page, 0x18, 15, 12, impedance);
}

The above function is used to write pre_amp, post_amp, Main_amplifier, Pre_amp enable, postamplifier enable and output impedance in TX SDS register RG MII_PLL_25_01 ~ 1




NEXT




<s> void rtl931x_traffic_disable(int source, int dest)
{
struct table_reg *r = rtl_table_get(RTL9310_TBL_0, 6);
rtl_table_read(r, source);
sw_w32_mask(BIT(dest + 3), 0, rtl_table_data(r, 0));
rtl_table_write(r, source);
rtl_table_release(r);
}

The above function is used to diable a given flow
in the table using its position number as a source
and destination. It is assumed that both of these
are known for the entry. For a new entry we do not
want to enable it. As a result




NEXT




<s> static void md5_transform(struct md5_ctx *mctx, u32 *hash, u32 const *in)
{
int i;
volatile struct deu_hash_t *hashs = (struct deu_hash_t *) HASH_START;
unsigned long flag;

CRTCL_SECT_HASH_START;

MD5_HASH_INIT;

if (mctx->started) {
hashs->D1R = *((u32 *) hash + 0);
hashs->D2R = *((u32 *) hash + 1);
hashs->D3R = *((u32 *) hash + 2);
hashs->D4R = *((u32 *) hash + 3);
}

for (i = 0; i < 16; i++) {
hashs->MR = in[i];
//      printk("in[%d]: %08x\n", i, in[i]);
};

//wait for processing
while (hashs->controlr.BSY) {
// this will not take long
}

*((u32 *) hash + 0) = hashs->D1R;
*((u32 *) hash + 1) = hashs->D2R;
*((u32 *) hash + 2) = hashs->D3R;
*((u32 *) hash + 3) = hashs->D4R;

CRTCL_SECT_HASH_END;

mctx->started = 1;
}

The above function is used to calculate MD5 in the following example :

int main(int argc, char *argv[])
{
if (argc<2) {
printf("usage:%s file_name\n",argv[0]);
return -1




NEXT




<s> static ssize_t ubootenv_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
{
struct ubootenv_drvdata *data = to_ubootenv_drvdata(file);

if (!data->env)
return 0;
return simple_read_from_buffer(buffer, count, ppos, data->env, data->rmem->size);
}

The above function is used to read any environment value into a buffer. In this case the buffer is the address of the data received from the kernel as shown below.

int main(int argc, char **argv)
{
}
}

//reads




NEXT




<s> static int rtl8366rb_sw_get_qos_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366RB_SGCR, &data);
if (data & RTL8366RB_QOS_MASK)
val->value.i = 1;
else
val->value.i = 0;

return 0;
}

The above function is used to check the value at RTL8366RB_QOS_MASK register,
If the value is One, the Qos is enabled, If it is zero, the Qos is disabled.</s>




NEXT




<s> static void rtl838x_set_igr_filter(int port, enum igr_filter state)
{
sw_w32_mask(0x3 << ((port & 0xf)<<1), state << ((port & 0xf)<<1),
RTL838X_VLAN_PORT_IGR_FLTR + (((port >> 4) << 2)));
}

The above function is used to set igr filter on a given port. It uses 1 byte of PMD register to store igr filter state for up to 4 pmds. A mask of 0x30103010301




NEXT




<s> static char * strtotimeval(const char *str, struct timeval *tv)
{
char *s;
long fs;			/* Fractional seconds */
int i;

tv->tv_sec = strtol(str, &s, 10);
fs = 0;

if ( *s == '.' ) {
s++;

for ( i = 0 ; i < 6 ; i++ ) {
if ( !isdigit(*s) )
break;

fs *= 10;
fs += *s++ - '0';
}

for ( ; i < 6; i++ )
fs *= 10;

while ( isdigit(*s) )
s++;
}

tv->tv_usec = fs;
return s;
}

The above function is used to parse the following date string:

Sep 27 1996 23:59:59.892985

This date is used in my script:

#!/bin/




NEXT




<s> static int msdc_debug_proc_read(struct seq_file *s, void *p)
{
seq_puts(s, "\n=========================================\n");
seq_puts(s, "Index<0> + Id + Zone\n");
seq_puts(s, "-> PWR<9> WRN<8> | FIO<7> OPS<6> FUN<5> CFG<4> | INT<3> RSP<2> CMD<1> DMA<0>\n");
seq_puts(s, "-> echo 0 3 0x3ff >msdc_bebug -> host[3] debug zone set to 0x3ff\n");
seq_printf(s, "-> MSDC[0] Zone: 0x%.8x\n", sd_debug_zone[0]);
seq_printf(s, "-> MSDC[1] Zone: 0x%.8x\n", sd_debug_zone[1]);
seq_printf(s, "-> MSDC[2] Zone: 0x%.8x\n", sd_debug_zone[2]);
seq_printf(s, "-> MSDC[3] Zone: 0x%.8x\n", sd_debug_zone[3]);

seq_puts(s, "Index<3> + SDIO_PROFILE + TIME\n");
seq_puts(s, "-> echo 3 1 0x1E >msdc_bebug -> enable sdio_profile, 30s\n");
seq_printf(s, "-> SDIO_PROFILE<%d> TIME<%ds>\n", sdio_pro_enable, sdio_pro_time);
seq_puts(s, "=========================================\n\n");

return 0;
}

The above function is used to write data to msdc devices by sd_msdc_probe function.</s>




NEXT




<s> static int yy_get_next_buffer ( void );
static void yynoreturn yy_fatal_error ( const char* msg  );

/* Done after the current pattern has been matched and before the
* corresponding action - sets up yytext.
*/
#define YY_DO_BEFORE_ACTION \
(yytext_ptr) = yy_bp; \
yyleng = (int) (yy_cp - yy_bp); \
(yy_hold_char) = *yy_cp; \
*yy_cp = '\0'; \
(yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 64
#define YY_END_OF_BUFFER 65
/* This struct is not used in this scanner,
but its presence is necessary. */
struct yy_trans_info
{
flex_int32_t yy_verify;
flex_int32_t yy_nxt;
};

The above function is used to advance() the scanner within the buffer,
such that the next
input is checked for a pattern match.  A semicolon has a value
of YY_END_OF_BUFFER, which signifies that the
end of




NEXT




<s> void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb)
{
BN_ULONG *rr;

#ifdef BN_COUNT
printf(" bn_mul_normal %d * %d\n",na,nb);
#endif

if (na < nb)
{
int itmp;
BN_ULONG *ltmp;

itmp=na; na=nb; nb=itmp;
ltmp=a;   a=b;   b=ltmp;

}
rr= &(r[na]);
rr[0]=bn_mul_words(r,a,na,b[0]);

for (;;)
{
if (--nb <= 0) return;
rr[1]=bn_mul_add_words(&(r[1]),a,na,b[1]);
if (--nb <= 0) return;
rr[2]=bn_mul_add_words(&(r[2]),a,na,b[2]);
if (--nb <= 0) return;
rr[3]=bn_mul_add_words(&(r[3]),a,na,b[3]);
if (--nb <= 0) return;
rr[4]=bn_mul_add_words(&(r[4]),a,na,b[4]);
rr+=4;
r+=4;
b+=4;
}
}

The above function is used to multiply moduli for the RSA key generation function if the key size is less than 4096, or for the PKCS padding function if the key is less than 1024 bits. These two functions will need to




NEXT




<s> ret_t rtl8367c_getAsicPulbicPage(rtk_uint32 *pPageCount)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PUBLIC_PAGE_COUNTER, RTL8367C_FLOWCTRL_PUBLIC_PAGE_COUNTER_MASK, pPageCount);
}

The above function is used to get the current number of public pages in use. The bit count of the above is used to see if you have more public pages than you are actually using…which is a good way to see if you have any waste in memory. This is pretty




NEXT




<s> rtk_api_ret_t rtk_dot1x_macBasedDirection_get(rtk_dot1x_direction_t *pMac_direction)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pMac_direction)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsic1xMBOpdirConfig(pMac_direction)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the direction of a MAC address, The possible values are MAC_DIRECTION_BOTH, MAC_DIRECTION_TO_MCAST, MAC_DIRECTION_TO_UCAST. MAC_DIRECTION_




NEXT




<s> ret_t rtl8367c_setAsicLedSerialOutput(rtk_uint32 output, rtk_uint32 pmask)
{
ret_t retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SERIAL_LED_CTRL, RTL8367C_SERIAL_LED_GROUP_NUM_MASK, output);
if (retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SERIAL_LED_CTRL, RTL8367C_SERIAL_LED_PORT_EN_MASK, pmask);
if (retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the serial output to one or more port.

The function call is:
ret_t retVal;
retVal = rtl8367c_setAsicLedSerialOutput(1<<3, 1




NEXT




<s> static void bmemcpys64(void *av, const void *bv, size_t frombits, size_t nbits)
{
uint64_t buf = 0;
const uint8_t *b = bv;
size_t frombyte = frombits / 8, tobyte = (frombits + nbits) / 8;

memcpy(&buf, &b[frombyte], tobyte - frombyte + 1);
buf = cpu_to_be64(be64_to_cpu(buf) << (frombits % 8));

bmemcpy(av, &buf, nbits);
}

The above function is used to copy 64 bit objects.

Note that bcopy uses the bmemcpy primitive function.

There is also a bmemmove function that can shift and copy data, and
bzero is essentially a specialized version of bcopy with




NEXT




<s> static int ptm_hard_start_xmit(struct sk_buff *, struct net_device *);
static int ptm_ioctl(struct net_device *, struct ifreq *, int);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
static void ptm_tx_timeout(struct net_device *);
#else
static void ptm_tx_timeout(struct net_device *, unsigned int txqueue);
#endif

static inline struct sk_buff* alloc_skb_rx(void);
static inline struct sk_buff* alloc_skb_tx(unsigned int);
static inline struct sk_buff *get_skb_pointer(unsigned int);
static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to initializse the priovate data (ptm_priv_data).
The global static struct ptm_priv_data is used to store global ptm information ,
which include the following functions:

   int rxdone




NEXT




<s> static bool is_end_of_str(char c)
{
return !c;
}

The above function is used to tell whether or not a particular function should stop copying elements of a string into a dynamically allocated string.

This code has the disadvantage of returning a false positive for EOF, so that function termination is aborted prematurely




NEXT




<s> struct expr *expr_alloc_and(struct expr *e1, struct expr *e2)
{
if (!e1)
return e2;
return e2 ? expr_alloc_two(E_AND, e1, e2) : e1;
}

The above function is used to allocate a new expression with the binary operator `AND` in the expression tree.

I had to implement this recursively in C for my job a few years ago from a Java implementation. I was surprised how similar the two versions of the code




NEXT




<s> static int rb4xx_ooblayout_free(struct mtd_info *mtd, int section,
struct mtd_oob_region *oobregion)
{
switch (section) {
case 0:
oobregion->offset = 0;
oobregion->length = 4;
return 0;
case 1:
oobregion->offset = 4;
oobregion->length = 1;
return 0;
case 2:
oobregion->offset = 6;
oobregion->length = 2;
return 0;
case 3:
oobregion->offset = 11;
oobregion->length = 2;
return 0;
default:
return -ERANGE;
}
}

The above function is used to calculate the offset and the length of the OOB region in the memory layout of the NAND. In the case of the Rb4xx, there are four OOB regions. Each one of these regions has a unique offset and length. The




NEXT




<s> void hostapd_ucode_add_bss(struct hostapd_data *hapd)
{
uc_value_t *val;

if (wpa_ucode_call_prepare("bss_add"))
return;

val = hostapd_ucode_bss_get_uval(hapd);
uc_value_push(ucv_get(ucv_string_new(hapd->conf->iface)));
uc_value_push(ucv_get(val));
ucv_put(wpa_ucode_call(2));
ucv_gc(vm);
}

The above function is used to actually start operating on a particular interface. What this function actually does is set up some parameters and finally calls a function in the driver to actually start.</s>




NEXT




<s> static void dma_byte_enable(struct dc_ep_dev *dev, int enable)
{
if (enable)
ep_wr32_mask(0, BIT(9), DMA_CTRL);
else
ep_wr32_mask(BIT(9), 0, DMA_CTRL);
}

The above function is used to enable/disable the DMA data transfer in the endpoints. The byte data transfer is enabled/disabled using this function.</s>




NEXT




<s> static void mailbox_tx_handler(unsigned int queue_bitmap)
{
int i;
int bit;

/* only get valid queues */
queue_bitmap &= g_atm_priv_data.conn_table;

for ( i = 0, bit = 1; i < MAX_PVC_NUMBER; i++, bit <<= 1 ) {
if (queue_bitmap & bit)
free_tx_ring(i);
}
}

The above function is used to free Tx queue. The above function can be called by both of PVC and SVC.

There is another function which is very similar to the above function but it can only be called by PVC. The similar function is pvc




NEXT




<s> struct myloader_info * __init myloader_get_info(void)
{
struct mylo_system_params *sysp;
struct mylo_board_params *boardp;
struct mylo_partition_table *parts;

if (myloader_found)
return &myloader_info;

sysp = (struct mylo_system_params *)(SYS_PARAMS_ADDR);
boardp = (struct mylo_board_params *)(BOARD_PARAMS_ADDR);
parts = (struct mylo_partition_table *)(PART_TABLE_ADDR);

printk(KERN_DEBUG "MyLoader: sysp=%08x, boardp=%08x, parts=%08x\n",
sysp->magic, boardp->magic, parts->magic);

/* Check for some magic numbers */
if (sysp->magic != MYLO_MAGIC_SYS_PARAMS ||
boardp->magic != MYLO_MAGIC_BOARD_PARAMS ||
le32_to_cpu(parts->magic) != MYLO_MAGIC_PARTITIONS)
return NULL;

printk(KERN_DEBUG "MyLoader: id=%04x:%04x, sub_id=%04x:%04x\n",
sysp->vid, sysp->did, sysp->svid, sysp->sdid);

myloader_info.vid = sysp->vid;
myloader_info.did = sysp->did;
myloader_info.svid = sysp->svid;
myloader_info.sdid = sysp->sdid;

memcpy(myloader_info.macs, boardp->addr, sizeof(myloader_info.macs));

myloader_found = 1;

return &myloader_info;
}

The above function is used to determine if MyLoader is present on the firmware of the embedded device. If MyLoader is detected the following function populates the relevant fields in the struct myloader_info with the appropriate values found in the SYS_PARAMS and BOARD




NEXT




<s> static enum dsa_tag_protocol rtl83xx_get_tag_protocol(struct dsa_switch *ds,
int port,
enum dsa_tag_protocol mprot)
{
/* The switch does not tag the frames, instead internally the header
* structure for each packet is tagged accordingly.
*/
return DSA_TAG_PROTO_TRAILER;
}

The above function is used to retrieve all incoming frames.

For outgoing frames, we should use this function when we use the

ds->tag_tx
in the set_tagged macro

This is only the case for unregistered DMA
because




NEXT




<s> int BN_is_bit_set(const BIGNUM *a, int n)
{
int i,j;

if (n < 0) return(0);
i=n/BN_BITS2;
j=n%BN_BITS2;
if (a->top <= i) return(0);
return((a->d[i]&(((BN_ULONG)1)<<j))?1:0);
}

The above function is used to chec if the ith bit i BN_BITS2-th bit after the ith bit has been set or not, and return 0 or 1.</s>




NEXT




<s> ret_t rtl8367c_getAsicOamEnable(rtk_uint32 *pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_OAM_CTRL, RTL8367C_OAM_CTRL_OFFSET, pEnabled);
}

The above function is used to read OAM enable bit. The OAM enable bit is bit[7] of Reg 0x56C, which means to enable OAM function just set bit[7] high or bit[7] value is 1. In




NEXT




<s> be32dec(const void *buf)
{
const uint8_t *p = buf;

return (((uint32_t) be16dec(p)) << 16) | be16dec(p + 2);
}

The above function is used to decoding a UDP packet. In the above program is using be16dec().
My question is that can I can change be16dec() to be32dec() to handle the second part of the packet instead of two separate




NEXT




<s> int dc_ep_gpio_set(struct dc_ep_priv *priv, u32 gpio, int val)
{
struct dc_aca *aca = to_aca(priv);

if (gpio > aca->max_gpio)
return -EINVAL;

dc_ep_gpio_dir(priv, gpio, GPIO_DIR_OUT);

if (val)
wr32(BIT(gpio), GPIO_OUTSET);
else
wr32(BIT(gpio), GPIO_OUTCLR);
return 0;
}

The above function is used to set a GPIO pin to a certain value.

The parameter values are as follows:

priv: A pointer to the data structure of the current DC_ep module

gpio: The GPIO number to be set

val: The




NEXT




<s> static int rtl8366s_remove(struct platform_device *pdev)
{
struct rtl8366_smi *smi = platform_get_drvdata(pdev);

if (smi) {
rtl8366s_switch_cleanup(smi);
platform_set_drvdata(pdev, NULL);
rtl8366_smi_cleanup(smi);
kfree(smi);
}

return 0;
}

The above function is used to release all resources occupied by the switch driver when the driver is being removed.</s>




NEXT




<s> ret_t rtl8367c_getAsicAclTemplate(rtk_uint32 index, rtl8367c_acltemplate_t *pAclType)
{
ret_t retVal;
rtk_uint32 i;
rtk_uint32 regData, regAddr;

if(index >= RTL8367C_ACLTEMPLATENO)
return RT_ERR_OUT_OF_RANGE;

regAddr = RTL8367C_ACL_RULE_TEMPLATE_CTRL_REG(index);

for(i = 0; i < (RTL8367C_ACLRULEFIELDNO/2); i++)
{
retVal = rtl8367c_getAsicReg(regAddr + i,&regData);
if(retVal != RT_ERR_OK)
return retVal;

pAclType->field[i*2] = regData & 0xFF;
pAclType->field[i*2 + 1] = (regData >> 8) & 0xFF;
}

return RT_ERR_OK;
}

The above function is used to get asic ACL template.</s>




NEXT




<s> static int rtl838x_eth_remove(struct platform_device *pdev)
{
struct net_device *dev = platform_get_drvdata(pdev);
struct rtl838x_eth_priv *priv = netdev_priv(dev);

if (dev) {
pr_info("Removing platform driver for rtl838x-eth\n");
rtl838x_mdio_remove(priv);
rtl838x_hw_stop(priv);

netif_tx_stop_all_queues(dev);

for (int i = 0; i < priv->rxrings; i++)
netif_napi_del(&priv->rx_qs[i].napi);

unregister_netdev(dev);
free_netdev(dev);
}

return 0;
}

The above function is used to unregister the net device, clean up PHY and free the net device.
When there comes a need to unattach the ethernet device (most commonly happens when a module is unloaded), the ‘rtl8139_




NEXT




<s> static void button_hotplug_work(struct work_struct *work)
{
struct bh_event *event = container_of(work, struct bh_event, work);
int ret = 0;

event->skb = alloc_skb(BH_SKB_SIZE, GFP_KERNEL);
if (!event->skb)
goto out_free_event;

ret = bh_event_add_var(event, 0, "%s@", event->action);
if (ret)
goto out_free_skb;

ret = button_hotplug_fill_event(event);
if (ret)
goto out_free_skb;

NETLINK_CB(event->skb).dst_group = 1;
broadcast_uevent(event->skb, 0, 1, GFP_KERNEL);

out_free_skb:
if (ret) {
pr_err(PFX "work error %d\n", ret);
kfree_skb(event->skb);
}
out_free_event:
kfree(event);
}

The above function is used to set up the button_hotplug_work workqueue function in the button_hotplug driver. The workqueue function is responsible for allocating memory for the event structure, filling in the necessary information about the event, and then sending the event to




NEXT




<s> static int bcm6348_setup_cfg_access(int type, unsigned int busn,
unsigned int devfn, int where)
{
struct bcm6348_pci *priv = &bcm6348_pci;
unsigned int slot, func, reg;
u32 val;

slot = PCI_SLOT(devfn);
func = PCI_FUNC(devfn);
reg = where >> 2;

/* sanity check */
if (slot > (MPI_L2PCFG_DEVNUM_MASK >> MPI_L2PCFG_DEVNUM_SHIFT))
return 1;

if (func > (MPI_L2PCFG_FUNC_MASK >> MPI_L2PCFG_FUNC_SHIFT))
return 1;

if (reg > (MPI_L2PCFG_REG_MASK >> MPI_L2PCFG_REG_SHIFT))
return 1;

/* ok, setup config access */
val = (reg << MPI_L2PCFG_REG_SHIFT);
val |= (func << MPI_L2PCFG_FUNC_SHIFT);
val |= (slot << MPI_L2PCFG_DEVNUM_SHIFT);
val |= MPI_L2PCFG_CFG_USEREG_MASK;
val |= MPI_L2PCFG_CFG_SEL_MASK;
/* type 0 cycle for local bus, type 1 cycle for anything else */
if (type != 0) {
/* FIXME: how to specify bus ??? */
val |= (1 << MPI_L2PCFG_CFG_TYPE_SHIFT);
}
__raw_writel(val, priv->pci + MPI_L2PCFG_REG);

return 0;
}

The above function is used to configure some registers in the PCI controller. The above code is wrong since the variable ”type” used as a parameter to the function is not initialized anywhere. This is a security vulnerability in the kernel which can be exploited by a local user or




NEXT




<s> static int esw_get_port_pvid(struct switch_dev *dev, int port, int *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

if (port >= RT305X_ESW_NUM_PORTS)
return -EINVAL;

*val = esw_get_pvid(esw, port);

return 0;
}

The above function is used to read a port pvid from the switch. However, the function is not used in the switch driver anywhere.

I've already submitted the corresponding patch (in a patch series), which adds support for reading / setting port's default v




NEXT




<s> static char *eval_clause(const char *str, size_t len, int argc, char *argv[])
{
char *tmp, *name, *res, *endptr, *prev, *p;
int new_argc = 0;
char *new_argv[FUNCTION_MAX_ARGS];
int nest = 0;
int i;
unsigned long n;

tmp = xstrndup(str, len);

/*
* If variable name is '1', '2', etc.  It is generally an argument
* from a user-function call (i.e. local-scope variable).  If not
* available, then look-up global-scope variables.
*/
n = strtoul(tmp, &endptr, 10);
if (!*endptr && n > 0 && n <= argc) {
res = xstrdup(argv[n - 1]);
goto free_tmp;
}

prev = p = tmp;

/*
* Split into tokens
* The function name and arguments are separated by a comma.
* For example, if the function call is like this:
*   $(foo,$(x),$(y))
*
* The input string for this helper should be:
*   foo,$(x),$(y)
*
* and split into:
*   new_argv[0] = 'foo'
*   new_argv[1] = '$(x)'
*   new_argv[2] = '$(y)'
*/
while (*p) {
if (nest == 0 && *p == ',') {
*p = 0;
if (new_argc >= FUNCTION_MAX_ARGS)
pperror("too many function arguments");
new_argv[new_argc++] = prev;
prev = p + 1;
} else if (*p == '(') {
nest++;
} else if (*p == ')') {
nest--;
}

p++;
}
new_argv[new_argc++] = prev;

/*
* Shift arguments
* new_argv[0] represents a function name or a variable name.  Put it
* into 'name', then shift the rest of the arguments.  This simplifies
* 'const' handling.
*/
name = expand_string_with_args(new_argv[0], argc, argv);
new_argc--;
for (i = 0; i < new_argc; i++)
new_argv[i] = expand_string_with_args(new_argv[i + 1],
argc, argv);

/* Search for variables */
res = variable_expand(name, new_argc, new_argv);
if (res)
goto free;

/* Look for built-in functions */
res = function_expand(name, new_argc, new_argv);
if (res)
goto free;

/* Last, try environment variable */
if (new_argc == 0) {
res = env_expand(name);
if (res)
goto free;
}

res = xstrdup("");
free:
for (i = 0; i < new_argc; i++)
free(new_argv[i]);
free(name);
free_tmp:
free(tmp);

return res;
}

The above function is used to replace variables and functions in shell
script or function. It first splits string into tokens using the
commas (`,`) as the delimiter. The first token becomes the function name
and the rest become the function arguments. After splitting strings




NEXT




<s> static int ar934x_nfc_wait_done(struct ar934x_nfc *nfc)
{
int ret;

if (ar934x_nfc_use_irq(nfc))
ret = ar934x_nfc_wait_irq(nfc);
else
ret = ar934x_nfc_wait_dev_ready(nfc);

if (ret)
return ret;

return ar934x_nfc_wait_dma_ready(nfc);
}

The above function is used to wait for the host controller until the
transaction finished: If the controller is using an irq, it can wait for
an irq to arrive. Otherwise the function waits for the device ready bit.
If the NFC is configured to perform 




NEXT




<s> rtl_get_cpuport(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
val->value.i = dev->cpu_port;
return 0;
}

The above function is used to get the CPU port of a given switch device. The switch device is passed as the dev parameter, the switch attribute that defines the CPU port is passed as the attr parameter, and the return variable val is used to store the CPU port number. The




NEXT




<s> static inline void rttm_set_counter(void __iomem *base, unsigned int counter)
{
iowrite32(counter, base + RTTM_CNT);
}

The above function is used to set various counters in a Rockchip RK3288 processor. The source line is generated by a GCC compiler by compiling the file:

rk3288-defcon.c
The __iomem




NEXT




<s> static void ddr_poll_until_not_busy(void)
{
volatile UINT reg_tmp = 0;
volatile UINT busy = 1;

//Extra read to put in delay before starting to poll...
reg_tmp = *(volatile UINT *) C_DDR_STAT_REG;      // read

//POLL DDR_STAT register until no longer busy
//!!! Ideally have a timeout on this.
while (busy == 1) {
reg_tmp = *(volatile UINT *) C_DDR_STAT_REG;      // read

//when bit 31 is clear - core is no longer busy
if ((reg_tmp & 0x80000000) == 0x00000000) {
busy = 0;
}
}
}

The above function is used to poll for the next read/write in the DDR memory area.</s>




NEXT




<s> static void nmbm_init_structure(struct nmbm_instance *ni)
{
uint32_t pages_per_block, blocks_per_chip;
uintptr_t ptr;

pages_per_block = bmtd.blk_size / bmtd.pg_size;
blocks_per_chip = bmtd.total_blks;

ni->rawpage_size = bmtd.pg_size + bmtd.mtd->oobsize;
ni->rawblock_size = pages_per_block * ni->rawpage_size;
ni->rawchip_size = blocks_per_chip * ni->rawblock_size;

/* Calculate number of block this chip */
ni->block_count = blocks_per_chip;

/* Calculate info table size */
ni->state_table_size = ((ni->block_count + NMBM_BITMAP_BLOCKS_PER_UNIT - 1) /
NMBM_BITMAP_BLOCKS_PER_UNIT) * NMBM_BITMAP_UNIT_SIZE;
ni->mapping_table_size = ni->block_count * sizeof(*ni->block_mapping);

ni->info_table_size = ALIGN(sizeof(ni->info_table),
bmtd.pg_size);
ni->info_table.state_table_off = ni->info_table_size;

ni->info_table_size += ALIGN(ni->state_table_size,
bmtd.pg_size);
ni->info_table.mapping_table_off = ni->info_table_size;

ni->info_table_size += ALIGN(ni->mapping_table_size,
bmtd.pg_size);

ni->info_table_spare_blocks = nmbm_get_spare_block_count(
size2blk(ni, ni->info_table_size));

/* Assign memory to members */
ptr = (uintptr_t)ni + sizeof(*ni);

ni->info_table_cache = (void *)ptr;
ptr += ni->info_table_size;

ni->block_state = (void *)ptr;
ptr += ni->state_table_size;

ni->block_mapping = (void *)ptr;
ptr += ni->mapping_table_size;

ni->page_cache = bmtd.data_buf;

/* Initialize block state table */
ni->block_state_changed = 0;
memset(ni->block_state, 0xff, ni->state_table_size);

/* Initialize block mapping table */
ni->block_mapping_changed = 0;
}

The above function is used to initialize the structure of bmtd struct. The fields are as follow.
static void *page_cache;
the page cache.
static struct nmbm_instance ni;
the nmbm data struct.
//static unsigned




NEXT




<s> static int ip17xx_set_enable_vlan(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int enable;

enable = val->value.i;
if (state->vlan_enabled == enable) {
// Do not change any state.
return 0;
}
state->vlan_enabled = enable;

// Otherwise, if we are switching state, set fields to a known default.
ip17xx_reset_vlan_config(state);

return state->regs->set_vlan_mode(state);
}

The above function is used to enable the VLAN feature from the front panel GUI.
So the logic is: if the function return 0, then the vlan was already enabled and no further action is needed. Else, then enable vlan and reset the V




NEXT




<s> ar8xxx_sw_set_mirror_source_port(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

mutex_lock(&priv->reg_mutex);
priv->source_port = val->value.i;
priv->chip->set_mirror_regs(priv);
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to set the mirror source port.  It does a mutex-protected function-call through the ar8xxx sublayer to update the chip’s registers.</s>




NEXT




<s> int ctr_basic_aes_decrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int dec_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = dec_bytes = walk.nbytes) && (walk.nbytes >= AES_BLOCK_SIZE)) {
dec_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_ctr(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, dec_bytes, CRYPTO_DIR_DECRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

/* to handle remaining bytes < AES_BLOCK_SIZE */
if (walk.nbytes) {
ifx_deu_aes_ctr(ctx, walk.dst.virt.addr, walk.src.virt.addr,
walk.iv, walk.nbytes, CRYPTO_DIR_DECRYPT, 0);
err = skcipher_walk_done(&walk, 0);
}

return err;
}

The above function is used to decrypt data. The function is called as follows:

err = ctr_walk(req);
err = skcipher_walk_virt(&walk, req, false);

If we look at walk.nbytes and




NEXT




<s> static int rtl83xx_port_bridge_join(struct dsa_switch *ds, int port,
struct net_device *bridge)
{
struct rtl838x_switch_priv *priv = ds->priv;
u64 port_bitmap = BIT_ULL(priv->cpu_port), v;

pr_debug("%s %x: %d %llx", __func__, (u32)priv, port, port_bitmap);

if (priv->is_lagmember[port]) {
pr_debug("%s: %d is lag slave. ignore\n", __func__, port);
return 0;
}

mutex_lock(&priv->reg_mutex);
for (int i = 0; i < ds->num_ports; i++) {
/* Add this port to the port matrix of the other ports in the
* same bridge. If the port is disabled, port matrix is kept
* and not being setup until the port becomes enabled.
*/
if (dsa_is_user_port(ds, i) && !priv->is_lagmember[i] && i != port) {
if (dsa_to_port(ds, i)->bridge_dev != bridge)
continue;
if (priv->ports[i].enable)
priv->r->traffic_enable(i, port);

priv->ports[i].pm |= BIT_ULL(port);
port_bitmap |= BIT_ULL(i);
}
}

/* Add all other ports to this port matrix. */
if (priv->ports[port].enable) {
priv->r->traffic_enable(priv->cpu_port, port);
v = priv->r->traffic_get(port);
v |= port_bitmap;
priv->r->traffic_set(port, v);
}
priv->ports[port].pm |= port_bitmap;

if (priv->r->set_static_move_action)
priv->r->set_static_move_action(port, false);

mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to call by other functions such as update_port_for_all_port_bridge(), which is used by
netif_carrier_on. In the context of netif_carrier_on(), a new bridge instance (e.




NEXT




<s> void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
{
int i;
struct nand_chip *chip = mtd->priv;

for (i = 0; i < len; i++)
buf[i] = readb(chip->IO_ADDR_R);
}

The above function is used to read from the NAND device in a
straightforward manner.
The function name is self-explanatory. Let’s discuss how to read data
from a NAND flash chip.
Reading data from a NAND flash




NEXT




<s> static void rt3883_init_data(struct fe_soc_data *data,
struct net_device *netdev)
{
struct fe_priv *priv = netdev_priv(netdev);

priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_PADDING_BUG |
FE_FLAG_JUMBO_FRAME | FE_FLAG_CALIBRATE_CLK;
netdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |
NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_TX;
}

The above function is used to initialise some values for the fe device and
also to initialise other members. After initializing the data, we call the function
fe0_phy_set from the file arch/arm/mach-fe/phy/phy-




NEXT




<s> static void do_ppe_tasklet(unsigned long);
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
DECLARE_TASKLET(g_dma_tasklet, do_ppe_tasklet, 0);
#else
DECLARE_TASKLET_OLD(g_dma_tasklet, do_ppe_tasklet);
#endif

/*
*  QSB & HTU setting functions
*/
static void set_qsb(struct atm_vcc *, struct atm_qos *, unsigned int);
static void qsb_global_set(void);
static inline void set_htu_entry(unsigned int, unsigned int, unsigned int, int, int);
static inline void clear_htu_entry(unsigned int);
static void validate_oam_htu_entry(void);
static void invalidate_oam_htu_entry(void);

/*
*  look up for connection ID
*/
static inline int find_vpi(unsigned int);
static inline int find_vpivci(unsigned int, unsigned int);
static inline int find_vcc(struct atm_vcc *);

static inline int ifx_atm_version(const struct ltq_atm_ops *ops, char *);

/*
*  Init & clean-up functions
*/
static inline void check_parameters(void);
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline void init_rx_tables(void);
static inline void init_tx_tables(void);

/*
*  Exteranl Function
*/
#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
extern void ifx_push_oam(unsigned char *);
#else
static inline void ifx_push_oam(unsigned char *dummy) {}

The above function is used to push oam data into the rxtx ring buffer in the
PPE for further processing.
*/

/* Extern functions needed when not compiled into the kernel */
#else
#define IFX_PUSH_OAM




NEXT




<s> static int mt7621_nfc_wait_write_completion(struct mt7621_nfc *nfc,
struct nand_chip *nand)
{
struct device *dev = nfc->dev;
u16 val;
int ret;

ret = readw_poll_timeout_atomic(nfc->nfi_regs + NFI_ADDRCNTR, val,
((val & SEC_CNTR_M) >> SEC_CNTR_S) >= nand->ecc.steps, 10,
NFI_CORE_TIMEOUT);

if (ret) {
dev_warn(dev, "NFI core write operation timed out\n");
return -ETIMEDOUT;
}

return ret;
}

The above function is used to wait for the completion of the write operation on the NFI core. Since this method works on polling mode, it will continuously access the target location, and can not be canceled. The reason is that the address counter in the NFI_




NEXT




<s> static struct trelay *trelay_find(struct net_device *dev)
{
struct trelay *tr;

list_for_each_entry(tr, &trelay_devs, list) {
if (tr->dev1 == dev || tr->dev2 == dev)
return tr;
}
return NULL;
}

The above function is used to search for a trelay pointer based on the
input device it references. But the pointer is also added to the
trelay_devs list in trelay_insert(). Is it necessary to duplicate this
search?

It looks




NEXT




<s> static void rtl83xx_fib_event_work_do(struct work_struct *work)
{
struct rtl83xx_fib_event_work *fib_work =
container_of(work, struct rtl83xx_fib_event_work, work);
struct rtl838x_switch_priv *priv = fib_work->priv;
struct fib_rule *rule;
int err;

/* Protect internal structures from changes */
rtnl_lock();
pr_debug("%s: doing work, event %ld\n", __func__, fib_work->event);
switch (fib_work->event) {
case FIB_EVENT_ENTRY_ADD:
case FIB_EVENT_ENTRY_REPLACE:
case FIB_EVENT_ENTRY_APPEND:
if (fib_work->is_fib6) {
err = rtl83xx_fib6_add(priv, &fib_work->fen6_info);
} else {
err = rtl83xx_fib4_add(priv, &fib_work->fen_info);
fib_info_put(fib_work->fen_info.fi);
}
if (err)
pr_err("%s: FIB4 failed\n", __func__);
break;
case FIB_EVENT_ENTRY_DEL:
rtl83xx_fib4_del(priv, &fib_work->fen_info);
fib_info_put(fib_work->fen_info.fi);
break;
case FIB_EVENT_RULE_ADD:
case FIB_EVENT_RULE_DEL:
rule = fib_work->fr_info.rule;
if (!fib4_rule_default(rule))
pr_err("%s: FIB4 default rule failed\n", __func__);
fib_rule_put(rule);
break;
}
rtnl_unlock();
kfree(fib_work);
}

The above function is used to process the FIB events by the
switching device. The event handler processes the fib4 or fib6
FIB entry add, or remove action. The event handler also processes
the fib4 or fib6 routing rule add, or




NEXT




<s> static u16 get_bmt_index(struct bbmt *bmt)
{
int i = 0;

while (bmt[i].block != BMT_TBL_DEF_VAL) {
if (bmt[i].mapped == BMT_MAPPED)
return i;
i++;
}
return 0;
}

The above function is used to get the index of the Bitmap Map Table where the bbt is mapped. But in actual situation it’s not getting incremented and still remaining at #0. Can any one please help me, where I’ve gone wrong. Thanks in




NEXT




<s> ret_t rtl8367c_setAsicPortSmallIpg(rtk_uint32 port, rtk_uint32 enable)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_PORT_SMALL_IPG_REG(port), RTL8367C_PORT0_MISC_CFG_SMALL_TAG_IPG_OFFSET, enable);
}

The above function is used to set the corresponding port ASIC small IPG configuration. The code below shows how to use this function:

main.c (Code Extract)

rtk_uint32 ret_val;

ret_val = r




NEXT




<s> static int b53_mdio_read48(struct b53_device *dev, u8 page, u8 reg, u64 *val)
{
struct mii_bus *bus = dev->priv;
u64 temp = 0;
int i;
int ret;

ret = b53_mdio_op(dev, page, reg, REG_MII_ADDR_READ);
if (ret)
return ret;

for (i = 2; i >= 0; i--) {
temp <<= 16;
temp |= mdiobus_read(bus, B53_PSEUDO_PHY, REG_MII_DATA0 + i);
}

*val = temp;

return 0;
}

The above function is used to access the MII 48-bit registers of a B550M-A WiFi motherboard (AMD B670 chipset). From the code above, it is clear that the device uses a three-word write




NEXT




<s> static irqreturn_t button_handle_irq(int irq, void *_bdata)
{
struct gpio_keys_button_data *bdata =
(struct gpio_keys_button_data *) _bdata;

mod_delayed_work(system_wq, &bdata->work,
msecs_to_jiffies(bdata->software_debounce));

return IRQ_HANDLED;
}

The above function is used to handle the IRQ from the buttons and there is a
work_struct, that gets scheduled based on the value set to the de-bounce
timer. This function then gets called every 100ms. So, we have both




NEXT




<s> static int mt7621_nfc_exec_instr(struct nand_chip *nand,
const struct nand_op_instr *instr)
{
struct mt7621_nfc *nfc = nand_get_controller_data(nand);

switch (instr->type) {
case NAND_OP_CMD_INSTR:
mt7621_nfc_hw_reset(nfc);
nfi_write16(nfc, NFI_CNFG, CNFG_OP_CUSTOM << CNFG_OP_MODE_S);
return mt7621_nfc_send_command(nfc, instr->ctx.cmd.opcode);
case NAND_OP_ADDR_INSTR:
return mt7621_nfc_send_address(nfc, instr->ctx.addr.addrs,
instr->ctx.addr.naddrs);
case NAND_OP_DATA_IN_INSTR:
mt7621_nfc_read_data(nfc, instr->ctx.data.buf.in,
instr->ctx.data.len);
return 0;
case NAND_OP_DATA_OUT_INSTR:
mt7621_nfc_write_data(nfc, instr->ctx.data.buf.out,
instr->ctx.data.len);
return 0;
case NAND_OP_WAITRDY_INSTR:
return mt7621_nfc_dev_ready(nfc,
instr->ctx.waitrdy.timeout_ms);
default:
WARN_ONCE(1, "unsupported NAND instruction type: %d\n",
instr->type);

return -EINVAL;
}
}

The above function is used to invoke the operations of the MT7621 NAND flash. It is responsible for
performing certain operations such as sending commands, reading/writing data, and enabling an
interrupt. The NAND flash performs the following operations for reading/




NEXT




<s> static void band_plan_status(int fd, profile_t *profile) {
#if (INCLUDE_DSL_CPE_API_VDSL_SUPPORT == 1)
IOCTL(DSL_BandPlanStatus_t, DSL_FIO_BAND_PLAN_STATUS_GET)

switch (out.data.nProfile) {
case DSL_PROFILE_8A:
*profile = PROFILE_8A;
break;
case DSL_PROFILE_8B:
*profile = PROFILE_8B;
break;
case DSL_PROFILE_8C:
*profile = PROFILE_8C;
break;
case DSL_PROFILE_8D:
*profile = PROFILE_8D;
break;
case DSL_PROFILE_12A:
*profile = PROFILE_12A;
break;
case DSL_PROFILE_12B:
*profile = PROFILE_12B;
break;
case DSL_PROFILE_17A:
*profile = PROFILE_17A;
break;
case DSL_PROFILE_30A:
*profile = PROFILE_30A;
break;
case DSL_PROFILE_35B:
*profile = PROFILE_35B;
break;
default:
*profile = PROFILE_UNKNOWN;
break;
};

const char *str;
switch (*profile) {
STR_CASE(PROFILE_8A, "8a")
STR_CASE(PROFILE_8B, "8b")
STR_CASE(PROFILE_8C, "8c")
STR_CASE(PROFILE_8D, "8d")
STR_CASE(PROFILE_12A, "12a")
STR_CASE(PROFILE_12B, "12b")
STR_CASE(PROFILE_17A, "17a")
STR_CASE(PROFILE_30A, "30a")
STR_CASE(PROFILE_35B, "35b")
default:
str = NULL;
break;
};
if (str)
m_str("profile", str);
#endif
}

The above function is used to retrieve/monitor the band profile in operation. When this function is used to get the band profile for a given line, it is recommended to use the function "band_plan_status_get_mode" before this, so that the function "




NEXT




<s> mt7530_set_port_mirror_rx(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

priv->port_entries[val->port_vlan].mirror_rx = val->value.i;

return 0;
}

The above function is used to set the mirror receiving capability for VLAN.</s>




NEXT




<s> ret_t rtl8367c_setAsicVlanIngressFilter(rtk_uint32 port, rtk_uint32 enabled)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_VLAN_INGRESS_REG, port, enabled);
}

The above function is used to do the ingress filtering of the VLAN frame into the ASIC. Please refer to RTL8367C datasheet page 49.

However, I am confused, since the API's parameter "port




NEXT




<s> ret_t rtl8367c_getAsicIGMPReportLeaveFlood(rtk_uint32 *pFlood)
{
ret_t   retVal;
rtk_uint32  regData;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG3, RTL8367C_REPORT_LEAVE_FORWARD_MASK, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pFlood = regData;
return RT_ERR_OK;
}

The above function is used to get the value of whether IGMP report leave and non member group to flood out.
We add the interface, ige.h to the Makefile as "c"
Compile the code by this command: "make -f r




NEXT




<s> static int rtl931x_mdio_read_paged(struct mii_bus *bus, int mii_id, u16 page, int regnum)
{
u32 val;
int err, v;
struct rtl838x_eth_priv *priv = bus->priv;

pr_debug("%s: In here, port %d\n", __func__, mii_id);
if (priv->phy_is_internal[mii_id]) {
v = rtl931x_read_sds_phy(priv->sds_id[mii_id], page, regnum);
if (v < 0) {
err = v;
} else {
err = 0;
val = v;
}
} else {
if (regnum & (MII_ADDR_C45 | MII_ADDR_C22_MMD)) {
err = rtl931x_read_mmd_phy(mii_id,
mdiobus_c45_devad(regnum),
regnum, &val);
pr_debug("MMD: %d dev %x register %x read %x, err %d\n", mii_id,
mdiobus_c45_devad(regnum), mdiobus_c45_regad(regnum),
val, err);
} else {
err = rtl931x_read_phy(mii_id, page, regnum, &val);
pr_debug("PHY: %d register %x read %x, err %d\n", mii_id, regnum, val, err);
}
}

if (err)
return err;

return val;
}

The above function is used to read MII register. The function is called by mii_bus.mdio_read_paged().

We could write a function for each MMIO device (mii_eth.c) but the function is just small




NEXT




<s> static int __init mtdsplit_wrgg_init(void)
{
register_mtd_parser(&mtdsplit_wrgg_parser);

return 0;
}

The above function is used to register the function which parses the mtd device and creates the internal memory mappings.

The function register_mtd_parser(…) is defined in the /drivers/mtd/mapper/cfi.c




NEXT




<s> void hostapd_ubus_free_iface(struct hostapd_iface *iface)
{
if (!ctx)
return;
}

The above function is used to free up resources allocated for an interface. Note that the entire struct hostapd_iface is not freed here. Only fields pointers to memory allocated by ubus_json_alloc() are freed.

As the struct hostapd_




NEXT




<s> static void mt7621_nfc_read_data(struct mt7621_nfc *nfc, u8 *buf, u32 len)
{
while (((uintptr_t)buf & 3) && len) {
*buf = mt7621_nfc_pio_read(nfc, true);
buf++;
len--;
}

while (len >= 4) {
*(u32 *)buf = mt7621_nfc_pio_read(nfc, false);
buf += 4;
len -= 4;
}

while (len) {
*buf = mt7621_nfc_pio_read(nfc, true);
buf++;
len--;
}
}

The above function is used to read an nfc frame from its memory buffer. If (len < 4) the len would be a negative number. How can I deal this case?

I tried with some ways, it seems it just need to jump out of the




NEXT




<s> static int rtl8367c_set_pvid( int port, int pvid)
{
u32 prio=0;

if (port >= RTL8367C_NUM_PORTS)
return -EINVAL;

return rtk_vlan_portPvid_set(rtl8367c_sw_to_phy_port(port),pvid,prio);
}

The above function is used to set/get the Port-based VLAN ID. This function supports all port numbers.

This function can be implemented in the form of RTK APIs, as follows:


static int rtl8367c_




NEXT




<s> ret_t rtl8367c_setAsicPortUnmatchedSaBehavior(rtk_uint32 behavior)
{
if(behavior >= L2_BEHAVE_SA_END)
return RT_ERR_NOT_ALLOWED;

return rtl8367c_setAsicRegBits(RTL8367C_PORT_SECURIT_CTRL_REG, RTL8367C_UNMATCHED_SA_BEHAVE_MASK, behavior);
}

The above function is used to set the behavior of the unmatched source address in different fields in RTL8367C. The possible values of the unmatched source address are shown in the following table.

Table 66: Possible Unmatched Source Address




NEXT




<s> rtk_api_ret_t rtk_vlan_realKeepRemarkEnable_set(rtk_enable_t enabled)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(enabled >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setRealKeepRemarkEn((rtk_uint32)enabled)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the vlan real keepremark enable, here only the API is given to simplify understanding for the beginners. You can find below code snippet for enabling real keepremark function

/* Enable the function */
rtk_enable_




NEXT




<s> static int bcm6348_emac_poll(struct napi_struct *napi, int budget)
{
struct bcm6348_emac *emac = container_of(napi, struct bcm6348_emac,
napi);
struct bcm6348_iudma *iudma = emac->iudma;
struct net_device *ndev = emac->net_dev;
int rx_work_done;

/* ack interrupts */
dmac_writel(iudma, DMAC_IR_PKTDONE_MASK, DMAC_IR_REG,
emac->rx_chan);
dmac_writel(iudma, DMAC_IR_PKTDONE_MASK, DMAC_IR_REG,
emac->tx_chan);

/* reclaim sent skb */
bcm6348_emac_tx_reclaim(ndev, 0);

spin_lock(&emac->rx_lock);
rx_work_done = bcm6348_emac_receive_queue(ndev, budget);
spin_unlock(&emac->rx_lock);

if (rx_work_done >= budget) {
/* rx queue is not yet empty/clean */
return rx_work_done;
}

/* no more packet in rx/tx queue, remove device from poll
* queue */
napi_complete_done(napi, rx_work_done);

/* restore rx/tx interrupt */
dmac_writel(iudma, DMAC_IR_PKTDONE_MASK, DMAC_IRMASK_REG,
emac->rx_chan);
dmac_writel(iudma, DMAC_IR_PKTDONE_MASK, DMAC_IRMASK_REG,
emac->tx_chan);

return rx_work_done;
}

The above function is used to handle receive and transmit packets from/to
bcm6348. There are two functions to handle transmit/receive, bcm6348_emac_receive_queue and
bcm6348_




NEXT




<s> static int sc_tag_cpufreq_ath79_arraysize(void)
{
int idx_max;

if (ATH79_SOC_AR7161 == ath79_soc)
idx_max = RB_CPU_FREQ_IDX_ATH79_7X_AR7161_MAX+1;
else if (soc_is_ar724x())
idx_max = RB_CPU_FREQ_IDX_ATH79_7X_AR724X_MAX+1;
else if (soc_is_ar9344())
idx_max = RB_CPU_FREQ_IDX_ATH79_9X_AR9334_MAX+1;
else if (soc_is_qca953x())
idx_max = RB_CPU_FREQ_IDX_ATH79_9X_QCA953X_MAX+1;
else if (soc_is_qca9556())
idx_max = RB_CPU_FREQ_IDX_ATH79_9X_QCA9556_MAX+1;
else if (soc_is_qca9558())
idx_max = RB_CPU_FREQ_IDX_ATH79_9X_QCA9558_MAX+1;
else
idx_max = -EOPNOTSUPP;

return idx_max;
}

The above function is used to get the CPU frequency array size used by the function cpuclock_table()
in file cpuclock.c and also the table itself in file cpuclock.dat. This is because, as you can clearly
see in the above function, there




NEXT




<s> rtk_api_ret_t rtk_igmp_state_get(rtk_enable_t *pEnabled)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(pEnabled == NULL)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIgmp(pEnabled))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to query the igmp state when operating in SNC environment.</s>




NEXT




<s> static inline void nfi_write32(struct mt7621_nfc *nfc, u32 reg, u32 val)
{
writel(val, nfc->nfi_regs + reg);
}

The above function is used to write 32 bit data to NFI hardware.
This function was written with the intention to perform only one write
to NFI hardware.

However this cannot be guaranteed. For example:

if (is_irq_enabled




NEXT




<s> void rtl839x_set_receive_management_action(int port, rma_ctrl_t type, action_type_t action)
{
switch(type) {
case BPDU:
sw_w32_mask(3 << ((port & 0xf) << 1), (action & 0x3) << ((port & 0xf) << 1),
RTL839X_RMA_BPDU_CTRL + ((port >> 4) << 2));
break;
case PTP:
sw_w32_mask(3 << ((port & 0xf) << 1), (action & 0x3) << ((port & 0xf) << 1),
RTL839X_RMA_PTP_CTRL + ((port >> 4) << 2));
break;
case LLTP:
sw_w32_mask(3 << ((port & 0xf) << 1), (action & 0x3) << ((port & 0xf) << 1),
RTL839X_RMA_LLTP_CTRL + ((port >> 4) << 2));
break;
default:
break;
}
}

The above function is used to modify the RMA register. Its input type is enumerate by rma_ctrl_t and its input action is enumerate by action_type_t. rma_ctrl_t include BPDU, PTPI, LLTP;




NEXT




<s> rtk_api_ret_t rtk_l2_ipMcastAddr_del(rtk_l2_ipMcastAddr_t *pIpMcastAddr)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Error Checking */
if (pIpMcastAddr == NULL)
return RT_ERR_INPUT;

if( (pIpMcastAddr->dip & 0xF0000000) != 0xE0000000)
return RT_ERR_INPUT;

memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
l2Table.sip = pIpMcastAddr->sip;
l2Table.dip = pIpMcastAddr->dip;
l2Table.l3lookup = 1;
l2Table.l3vidlookup = 0;
method = LUTREADMETHOD_MAC;
retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
if (RT_ERR_OK == retVal)
{
l2Table.sip = pIpMcastAddr->sip;
l2Table.dip = pIpMcastAddr->dip;
l2Table.mbr = 0;
l2Table.nosalearn = 0;
l2Table.l3lookup = 1;
l2Table.l3vidlookup = 0;
l2Table.lut_pri = 0;
l2Table.fwd_en  = 0;
if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
return retVal;

pIpMcastAddr->address = l2Table.address;
return RT_ERR_OK;
}
else
return retVal;
}

The above function is used to delete mcast entry. It's similar as the insert functions on the aspect that both functions share the same data structure. The difference is that L2 mcast entry needs to be inserted as LUT 0 entry or LUT 1 entry




NEXT




<s> ar8327_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
u8 *vt = &priv->vlan_table[val->port_vlan];
int i;

*vt = 0;
for (i = 0; i < val->len; i++) {
struct switch_port *p = &val->value.ports[i];

if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
if (val->port_vlan == priv->pvid[p->id]) {
priv->vlan_tagged |= (1 << p->id);
}
} else {
priv->vlan_tagged &= ~(1 << p->id);
priv->pvid[p->id] = val->port_vlan;
}

*vt |= 1 << p->id;
}
return 0;
}

The above function is used to configure switch port's vlan membership. I am using AR8216. The structure definition for switch_port is:
struct switch_port
{
uint16_t id; /* The port id
uint8_




NEXT




<s> static int rtl83xx_port_fdb_add(struct dsa_switch *ds, int port,
const unsigned char *addr, u16 vid)
{
struct rtl838x_switch_priv *priv = ds->priv;
u64 mac = ether_addr_to_u64(addr);
struct rtl838x_l2_entry e;
int err = 0, idx;
u64 seed = priv->r->l2_hash_seed(mac, vid);

if (priv->is_lagmember[port]) {
pr_debug("%s: %d is lag slave. ignore\n", __func__, port);
return 0;
}

mutex_lock(&priv->reg_mutex);

idx = rtl83xx_find_l2_hash_entry(priv, seed, false, &e);

/* Found an existing or empty entry */
if (idx >= 0) {
rtl83xx_setup_l2_uc_entry(&e, port, vid, mac);
priv->r->write_l2_entry_using_hash(idx >> 2, idx & 0x3, &e);
goto out;
}

/* Hash buckets full, try CAM */
idx = rtl83xx_find_l2_cam_entry(priv, seed, false, &e);

if (idx >= 0) {
rtl83xx_setup_l2_uc_entry(&e, port, vid, mac);
priv->r->write_cam(idx, &e);
goto out;
}

err = -ENOTSUPP;

out:
mutex_unlock(&priv->reg_mutex);

return err;
}

The above function is used to add FDB entry.

This rtl838x_port_fdb_add code add FDB entry if that entry is
not exist in the ROM. However, there is a problem.

After the r




NEXT




<s> IFX_MEI_InitDevice (int num)
{
DSL_DEV_Device_t *pDev;
u32 temp;
pDev = &dsl_devices[num];
if (pDev == NULL)
return -ENOMEM;
pDev->pPriv = &sDanube_Mei_Private[num];
memset (pDev->pPriv, 0, sizeof (ifx_mei_device_private_t));

memset (&DSL_DEV_PRIVATE(pDev)->
adsl_mem_info[0], 0,
sizeof (smmu_mem_info_t) * MAX_BAR_REGISTERS);

if (num == 0) {
pDev->nIrq[IFX_DFEIR]      = LTQ_MEI_INT;
pDev->nIrq[IFX_DYING_GASP] = LTQ_MEI_DYING_GASP_INT;
pDev->base_address = KSEG1 + LTQ_MEI_BASE_ADDR;

/* Power up MEI */
#ifdef CONFIG_LANTIQ_AMAZON_SE
*LTQ_PMU_PWDCR &= ~(1 << 9);  // enable dsl
*LTQ_PMU_PWDCR &= ~(1 << 15); // enable AHB base
#endif
temp = ltq_r32(LTQ_PMU_PWDCR);
temp &= 0xffff7dbe;
ltq_w32(temp, LTQ_PMU_PWDCR);
}
pDev->nInUse = 0;
DSL_DEV_PRIVATE(pDev)->modem_ready = 0;
DSL_DEV_PRIVATE(pDev)->arcmsgav = 0;

MEI_INIT_WAKELIST ("arcq", DSL_DEV_PRIVATE(pDev)->wait_queue_arcmsgav);	// for ARCMSGAV
MEI_INIT_WAKELIST ("arcr", DSL_DEV_PRIVATE(pDev)->wait_queue_modemready);	// for arc modem ready

MEI_MUTEX_INIT (DSL_DEV_PRIVATE(pDev)->mei_cmv_sema, 1);	// semaphore initialization, mutex
#if 0
MEI_MASK_AND_ACK_IRQ (pDev->nIrq[IFX_DFEIR]);
MEI_MASK_AND_ACK_IRQ (pDev->nIrq[IFX_DYING_GASP]);
#endif
if (request_irq (pDev->nIrq[IFX_DFEIR], IFX_MEI_IrqHandle, 0, "DFEIR", pDev) != 0) {
IFX_MEI_EMSG ("request_irq %d failed!\n", pDev->nIrq[IFX_DFEIR]);
return -1;
}
/*if (request_irq (pDev->nIrq[IFX_DYING_GASP], IFX_MEI_Dying_Gasp_IrqHandle, 0, "DYING_GASP", pDev) != 0) {
IFX_MEI_EMSG ("request_irq %d failed!\n", pDev->nIrq[IFX_DYING_GASP]);
return -1;
}*/
//	IFX_MEI_DMSG("Device %d initialized. IER %#x\n", num, bsp_get_irq_ier(pDev->nIrq[IFX_DYING_GASP]));
return 0;
}

The above function is used to initialize an MEI device.
The first step is to initialize the data members defined in struct DSL_DEV_Device_t. A pointer to a structure which stores the private information of an MEI device is allocated and linked to the D




NEXT




<s> static inline void fe_hw_set_macaddr(struct fe_priv *priv, unsigned char *mac)
{
unsigned long flags;

spin_lock_irqsave(&priv->page_lock, flags);
fe_w32((mac[0] << 8) | mac[1], FE_GDMA1_MAC_ADRH);
fe_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
FE_GDMA1_MAC_ADRL);
spin_unlock_irqrestore(&priv->page_lock, flags);
}

The above function is used to program the DMA Mac Address. However I see the
following issues.

1] DMA registers have a fixed address space. In 865X, it is mapped to
A0000000 (for S




NEXT




<s> ar8327_get_pad_cfg(struct ar8327_pad_cfg *cfg)
{
u32 t;

if (!cfg)
return 0;

t = 0;
switch (cfg->mode) {
case AR8327_PAD_NC:
break;

case AR8327_PAD_MAC2MAC_MII:
t = AR8327_PAD_MAC_MII_EN;
if (cfg->rxclk_sel)
t |= AR8327_PAD_MAC_MII_RXCLK_SEL;
if (cfg->txclk_sel)
t |= AR8327_PAD_MAC_MII_TXCLK_SEL;
break;

case AR8327_PAD_MAC2MAC_GMII:
t = AR8327_PAD_MAC_GMII_EN;
if (cfg->rxclk_sel)
t |= AR8327_PAD_MAC_GMII_RXCLK_SEL;
if (cfg->txclk_sel)
t |= AR8327_PAD_MAC_GMII_TXCLK_SEL;
break;

case AR8327_PAD_MAC_SGMII:
t = AR8327_PAD_SGMII_EN;

/*
* WAR for the QUalcomm Atheros AP136 board.
* It seems that RGMII TX/RX delay settings needs to be
* applied for SGMII mode as well, The ethernet is not
* reliable without this.
*/
t |= cfg->txclk_delay_sel << AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S;
t |= cfg->rxclk_delay_sel << AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S;
if (cfg->rxclk_delay_en)
t |= AR8327_PAD_RGMII_RXCLK_DELAY_EN;
if (cfg->txclk_delay_en)
t |= AR8327_PAD_RGMII_TXCLK_DELAY_EN;

if (cfg->sgmii_delay_en)
t |= AR8327_PAD_SGMII_DELAY_EN;

break;

case AR8327_PAD_MAC2PHY_MII:
t = AR8327_PAD_PHY_MII_EN;
if (cfg->rxclk_sel)
t |= AR8327_PAD_PHY_MII_RXCLK_SEL;
if (cfg->txclk_sel)
t |= AR8327_PAD_PHY_MII_TXCLK_SEL;
break;

case AR8327_PAD_MAC2PHY_GMII:
t = AR8327_PAD_PHY_GMII_EN;
if (cfg->pipe_rxclk_sel)
t |= AR8327_PAD_PHY_GMII_PIPE_RXCLK_SEL;
if (cfg->rxclk_sel)
t |= AR8327_PAD_PHY_GMII_RXCLK_SEL;
if (cfg->txclk_sel)
t |= AR8327_PAD_PHY_GMII_TXCLK_SEL;
break;

case AR8327_PAD_MAC_RGMII:
t = AR8327_PAD_RGMII_EN;
t |= cfg->txclk_delay_sel << AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S;
t |= cfg->rxclk_delay_sel << AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S;
if (cfg->rxclk_delay_en)
t |= AR8327_PAD_RGMII_RXCLK_DELAY_EN;
if (cfg->txclk_delay_en)
t |= AR8327_PAD_RGMII_TXCLK_DELAY_EN;
break;

case AR8327_PAD_PHY_GMII:
t = AR8327_PAD_PHYX_GMII_EN;
break;

case AR8327_PAD_PHY_RGMII:
t = AR8327_PAD_PHYX_RGMII_EN;
break;

case AR8327_PAD_PHY_MII:
t = AR8327_PAD_PHYX_MII_EN;
break;
}

return t;
}

The above function is used to set the MAC pad control register when the device is in a specific operational mode [MAC2MAC, MAC2PHY, MAC_SGMII, MAC2PHY_SGMII, etc.] This function is called in the following functions.





NEXT




<s> static void ath79_mii_ctrl_set_speed(struct ag71xx *ag)
{
unsigned int mii_speed;
u32 t;

if (!ag->mii_base)
return;

switch (ag->speed) {
case SPEED_10:
mii_speed =  AR71XX_MII_CTRL_SPEED_10;
break;
case SPEED_100:
mii_speed =  AR71XX_MII_CTRL_SPEED_100;
break;
case SPEED_1000:
mii_speed =  AR71XX_MII_CTRL_SPEED_1000;
break;
default:
BUG();
}

t = __raw_readl(ag->mii_base);
t &= ~(AR71XX_MII_CTRL_SPEED_MASK << AR71XX_MII_CTRL_SPEED_SHIFT);
t |= mii_speed << AR71XX_MII_CTRL_SPEED_SHIFT;
__raw_writel(t, ag->mii_base);
}

The above function is used to set the MII speed based on
the passed in device speed. AR71XX-based systems do not
allow you to change the MII speed directly; instead, they
provide a MII_CTRL_SPEED register (




NEXT




<s> set_error(int errcode, const char *fmt, ...)
{
va_list ap;

free(last_error.msg);

last_error.code = errcode;
last_error.msg = NULL;

if (fmt) {
va_start(ap, fmt);
xvasprintf(&last_error.msg, fmt, ap);
va_end(ap);
}
}

The above function is used to store the latest error that has occurred within a function. If you wish to view this error in C then use the following variable "errno"(declared earlier). This will tell you what error code occurred. So before the function returns there must be




NEXT




<s> ar8xxx_probe_switch(struct ar8xxx_priv *priv)
{
const struct ar8xxx_chip *chip;
struct switch_dev *swdev;
int ret;

chip = priv->chip;

swdev = &priv->dev;
swdev->cpu_port = AR8216_PORT_CPU;
swdev->name = chip->name;
swdev->vlans = chip->vlans;
swdev->ports = chip->ports;
swdev->ops = chip->swops;

ret = ar8xxx_mib_init(priv);
if (ret)
return ret;

return 0;
}

The above function is used to initialize the VLANs and the ports
in the switch driver, after loading the chip drivers. (for e.g. in
`driver/net/ar8xxx`.</s>




NEXT




<s> ret_t rtl8367c_getAsicEeeGiga(rtk_uint32 port, rtk_uint32 *enable)
{
rtk_api_ret_t   retVal;
rtk_uint32      regData;

if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if((retVal = rtl8367c_getAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, &regData)) != RT_ERR_OK)
return retVal;

*enable = (regData & (0x0001 << 2)) ? ENABLED : DISABLED;
return RT_ERR_OK;
}

The above function is used to determine the EEE state according to the PHY OCP register.

rtl8367c_setAsicEeeGiga function

ret_t rtl8367c_setAsicEee




NEXT




<s> static bool is_dir(const char *path)
{
struct stat st;

if (stat(path, &st))
return false;

return S_ISDIR(st.st_mode);
}

The above function is used to check whether a directory is an actual
directory or not.

#if !HAVE_IS_DIR
static bool is_dir(const char *path)
{
struct stat st;

if (stat(path,




NEXT




<s> static void psb6970_remove(struct phy_device *pdev)
{
struct psb6970_priv *priv = pdev->priv;

if (!priv)
return;

if (pdev->mdio.addr == 0)
unregister_switch(&priv->dev);
kfree(priv);
}

The above function is used to completely free the resources obtained in the initialization function.</s>




NEXT




<s> static AT91S_DataFlashStatus AT91F_DataFlashContinuousRead(
AT91PS_DataFlash pDataFlash,
int src,
unsigned char *dataBuffer,
int sizeToRead )
{
AT91S_DataFlashStatus status;
/* Test the size to read in the device */
if ( (src + sizeToRead) > (pDataFlash->pDevice->pages_size * (pDataFlash->pDevice->pages_number)))
return AT91C_DATAFLASH_MEMORY_OVERFLOW;

pDataFlash->pDataFlashDesc->rx_data_pt = dataBuffer;
pDataFlash->pDataFlashDesc->rx_data_size = sizeToRead;
pDataFlash->pDataFlashDesc->tx_data_pt = dataBuffer;
pDataFlash->pDataFlashDesc->tx_data_size = sizeToRead;

status = AT91F_DataFlashSendCommand(pDataFlash, DB_CONTINUOUS_ARRAY_READ, 8, src);
/* Send the command to the dataflash */
return(status);
}

The above function is used to read the data directly from the dataflah.
The data is read continuously after it is set.</s>




NEXT




<s> static void rb91x_nand_write_buf(struct nand_chip *chip, const u8 *buf, int len)
{
rb91x_nand_write(chip->priv, buf, len);
}

The above function is used to write one page of data to the rb91x nand chip through rb91x_nand_write.The rb91x_nand_write function is also called in the read phase,which is used to write one




NEXT




<s> static int __fe_tx_dma_map_page(struct fe_tx_ring *ring, struct fe_map_state *st,
struct page *page, size_t offset, size_t size)
{
struct device *dev = st->dev;
struct fe_tx_buf *tx_buf;
dma_addr_t mapped_addr;

mapped_addr = dma_map_page(dev, page, offset, size, DMA_TO_DEVICE);
if (unlikely(dma_mapping_error(dev, mapped_addr)))
return -EIO;

if (st->i && !(st->i & 1))
fe_tx_dma_write_desc(ring, st);

tx_buf = &ring->tx_buf[st->ring_idx];
if (st->i & 1) {
st->txd.txd3 = mapped_addr;
st->txd.txd2 |= TX_DMA_PLEN1(size);
dma_unmap_addr_set(tx_buf, dma_addr1, mapped_addr);
dma_unmap_len_set(tx_buf, dma_len1, size);
} else {
tx_buf->skb = (struct sk_buff *)DMA_DUMMY_DESC;
st->txd.txd1 = mapped_addr;
st->txd.txd2 = TX_DMA_PLEN0(size);
dma_unmap_addr_set(tx_buf, dma_addr0, mapped_addr);
dma_unmap_len_set(tx_buf, dma_len0, size);
}
st->i++;

return 0;
}

The above function is used to map pages to the ring buffers, either directly to the DMA engine or from the cache to the engine.  You can probably tell that the 802.11 code for using the ring buffers is just as bad or worse than what is




NEXT




<s> static void rtl839x_hw_en_rxtx(struct rtl838x_eth_priv *priv)
{
/* Setup CPU-Port: RX Buffer */
sw_w32((DEFAULT_MTU << 5) | RX_TRUNCATE_EN_83XX, priv->r->dma_if_ctrl);

/* Enable Notify, RX done, RX overflow and TX done interrupts */
sw_w32(0x007fffff, priv->r->dma_if_intr_msk); /* Notify IRQ! */

/* Enable DMA */
sw_w32_mask(0, RX_EN | TX_EN, priv->r->dma_if_ctrl);

/* Restart TX/RX to CPU port, enable CRC checking */
sw_w32_mask(0x0, 0x3 | BIT(3), priv->r->mac_port_ctrl(priv->cpu_port));

/* CPU port joins Lookup Miss Flooding Portmask */
/* TODO: The code below should also work for the RTL838x */
sw_w32(0x28000, RTL839X_TBL_ACCESS_L2_CTRL);
sw_w32_mask(0, 0x80000000, RTL839X_TBL_ACCESS_L2_DATA(0));
sw_w32(0x38000, RTL839X_TBL_ACCESS_L2_CTRL);

/* Force CPU port link up */
sw_w32_mask(0, 3, priv->r->mac_force_mode_ctrl + priv->cpu_port * 4);
}

The above function is used to configure the RTL839x hardware to do data reception from an external device and to send data to the external device. A hardware interrupt is used to notify the processor of an incoming packet. The function uses the following macros to read and




NEXT




<s> rtl8306_probe(struct phy_device *pdev)
{
struct rtl_priv *priv;

list_for_each_entry(priv, &phydevs, list) {
/*
* share one rtl_priv instance between virtual phy
* devices on the same bus
*/
if (priv->bus == pdev->mdio.bus)
goto found;
}
priv = kzalloc(sizeof(struct rtl_priv), GFP_KERNEL);
if (!priv)
return -ENOMEM;

priv->bus = pdev->mdio.bus;

found:
pdev->priv = priv;
return 0;
}

The above function is used to create the phy devices.
The phy_dev_register function calls rtl8306_probe inside.
Now it's necessary to add following declaration in r8125_dev.h:

//




NEXT




<s> static inline size_t special_min(size_t a, size_t b)
{
return a == 0 ? b : (a < b ? a : b);
}

The above function is used to return the minimum between two values. In this
case, the parameters’ values are compared. If one of the parameters is 0,
then the other parameter is returned. Otherwise, if both values are greater
than zero, then the lesser




NEXT




<s> static int ar934x_nfc_setup_hwecc(struct ar934x_nfc *nfc)
{
struct nand_chip *nand = &nfc->nand_chip;
struct mtd_info *mtd = nand_to_mtd(nand);
u32 ecc_cap;
u32 ecc_thres;
struct mtd_oob_region oobregion;

switch (mtd->writesize) {
case 2048:
/*
* Writing a subpage separately is not supported, because
* the controller only does ECC on full-page accesses.
*/

nand->ecc.size = 512;
nand->ecc.bytes = 7;
nand->ecc.strength = 4;
mtd_set_ooblayout(mtd, &ar934x_nfc_ecclayout_ops);
break;

default:
dev_err(nfc->parent,
"hardware ECC is not available for %d byte pages\n",
mtd->writesize);
return -EINVAL;
}

BUG_ON(!mtd->ooblayout->ecc);

switch (nand->ecc.strength) {
case 4:
ecc_cap = AR934X_NFC_ECC_CTRL_ECC_CAP_4;
ecc_thres = 4;
break;

default:
dev_err(nfc->parent, "unsupported ECC strength %u\n",
nand->ecc.strength);
return -EINVAL;
}

nfc->ecc_thres = ecc_thres;
mtd->ooblayout->ecc(mtd, 0, &oobregion);
nfc->ecc_oob_pos = oobregion.offset;

nfc->ecc_ctrl_reg = ecc_cap << AR934X_NFC_ECC_CTRL_ECC_CAP_S;
nfc->ecc_ctrl_reg |= ecc_thres << AR934X_NFC_ECC_CTRL_ERR_THRES_S;

nfc->ecc_offset_reg = mtd->writesize + nfc->ecc_oob_pos;

nand->ecc.read_page = ar934x_nfc_read_page;
nand->ecc.read_page_raw = ar934x_nfc_read_page_raw;
nand->ecc.write_page = ar934x_nfc_write_page;
nand->ecc.write_page_raw = ar934x_nfc_write_page_raw;
nand->ecc.read_oob = ar934x_nfc_read_oob;
nand->ecc.write_oob = ar934x_nfc_write_oob;

return 0;
}

The above function is used to setup ECC features if we are using hardware ECC. It is based on earlier ar9170_nfc_setup_hwecc function.

For details on the ECC setup and the rest of the driver implementation,




NEXT




<s> rtk_api_ret_t rtk_igmp_currentGroup_get(rtk_port_t port, rtk_uint32 *pGroup)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if(pGroup == NULL)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPPortCurrentGroup(rtk_switch_port_L2P_get(port), pGroup))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the current group of rtk_port port.

If this API is mis-used, an exception or chips fault may occur.
Therefore, user shall call this API only with a port that is in operational state except the ports




NEXT




<s> static void rtl8366_smi_write_bits(struct rtl8366_smi *smi, u32 data, u32 len)
{
unsigned int sda = smi->gpio_sda;
unsigned int sck = smi->gpio_sck;

for (; len > 0; len--) {
rtl8366_smi_clk_delay(smi);

/* prepare data */
gpio_set_value(sda, !!(data & ( 1 << (len - 1))));
rtl8366_smi_clk_delay(smi);

/* clocking */
gpio_set_value(sck, 1);
rtl8366_smi_clk_delay(smi);
gpio_set_value(sck, 0);
}
}

The above function is used to set bits to the SMISR register. But I donÂ’t know how to call it. I tried it in this way.</s>




NEXT




<s> static int rtl8367_enable_vlan4k(struct rtl8366_smi *smi, int enable)
{
return 0;
}

The above function is used to enable/disable vlan4k on HEX2.

The default value of enable argument is 1.

Note that this function should not be replaced by “switch_set_vlan_mode(smi, vlanc




NEXT




<s> int ecb_aes_decrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int dec_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = dec_bytes = walk.nbytes)) {
dec_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_ecb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
NULL, dec_bytes, CRYPTO_DIR_DECRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

return err;
}

The above function is used to process data in ecb mode. A lot of people asked, if that function is called for ecb decryption is it ok or we need any protection about data?

If the caller is secure (I know it is very hard in some




NEXT




<s> static int rt2880_mdio_wait_ready(struct fe_priv *priv)
{
int retries;

retries = FE_MDIO_RETRY;
while (1) {
u32 t;

t = fe_r32(FE_MDIO_ACCESS);
if ((t & BIT(31)) == 0)
return 0;

if (retries-- == 0)
break;

udelay(1);
}

dev_err(priv->dev, "MDIO operation timed out\n");
return -ETIMEDOUT;
}

The above function is used to check if the mdio operation has completed and ready.
In my case, this code is using for programming/reading data via fe_pll_mdio. But it seems never return and always go into the retries loop or infinite




NEXT




<s> static void ar934x_nfc_send_cmd(struct ar934x_nfc *nfc, unsigned command)
{
u32 cmd_reg;

cmd_reg = AR934X_NFC_CMD_INPUT_SEL_SIU | AR934X_NFC_CMD_ADDR_SEL_0 |
AR934X_NFC_CMD_SEQ_1C;
cmd_reg |= (command & AR934X_NFC_CMD_CMD0_M) << AR934X_NFC_CMD_CMD0_S;

ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);

ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
ar934x_nfc_wait_dev_ready(nfc);
}

The above function is used to perform some arbitrary NFC command and wait for the result of the command to be valid.  For some reason the AR9285/AR934x devices don't work very well and the function to control the NFC will




NEXT




<s> ret_t rtl8367c_getAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 *pRegData )
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint32 busyFlag,checkCounter;
rtk_uint32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
/*Check internal phy access busy or not*/
/*retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_INDRECT_ACCESS_STATUS, RTL8367C_INDRECT_ACCESS_STATUS_OFFSET,&busyFlag);*/
retVal = rtl8367c_getAsicReg(RTL8367C_REG_INDRECT_ACCESS_STATUS,&busyFlag);
if(retVal != RT_ERR_OK)
return retVal;

if(busyFlag)
return RT_ERR_BUSYWAIT_TIMEOUT;

/* OCP prefix */
ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_GPHY_OCP_MSB_0, RTL8367C_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix)) != RT_ERR_OK)
return retVal;

/*prepare access address*/
ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
regData = RTL8367C_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367C_PHY_OFFSET) | ocpAddr5_1;
retVal = rtl8367c_setAsicReg(RTL8367C_REG_INDRECT_ACCESS_ADDRESS, regData);
if(retVal != RT_ERR_OK)
return retVal;

/*Set READ Command*/
retVal = rtl8367c_setAsicReg(RTL8367C_REG_INDRECT_ACCESS_CTRL, RTL8367C_CMD_MASK );
if(retVal != RT_ERR_OK)
return retVal;

checkCounter = 100;
while(checkCounter)
{
retVal = rtl8367c_getAsicReg(RTL8367C_REG_INDRECT_ACCESS_STATUS,&busyFlag);
if((retVal != RT_ERR_OK) || busyFlag)
{
checkCounter --;
if(0 == checkCounter)
return RT_ERR_FAILED;
}
else
{
checkCounter = 0;
}
}

/*get PHY register*/
retVal = rtl8367c_getAsicReg(RTL8367C_REG_INDRECT_ACCESS_READ_DATA, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*pRegData = regData;

return RT_ERR_OK;
}

The above function is used to access the register of phy using OCP.</s>




NEXT




<s> static int rtl8367b_get_mib_counter(struct rtl8366_smi *smi, int counter,
int port, unsigned long long *val)
{
struct rtl8366_mib_counter *mib;
int offset;
int i;
int err;
u32 addr, data;
u64 mibvalue;

if (port > RTL8367B_NUM_PORTS ||
counter >= RTL8367B_NUM_MIB_COUNTERS)
return -EINVAL;

mib = &rtl8367b_mib_counters[counter];
addr = RTL8367B_MIB_COUNTER_PORT_OFFSET * port + mib->offset;

/*
* Writing access counter address first
* then ASIC will prepare 64bits counter wait for being retrived
*/
REG_WR(smi, RTL8367B_MIB_ADDRESS_REG, addr >> 2);

/* read MIB control register */
REG_RD(smi, RTL8367B_MIB_CTRL0_REG(0), &data);

if (data & RTL8367B_MIB_CTRL0_BUSY_MASK)
return -EBUSY;

if (data & RTL8367B_MIB_CTRL0_RESET_MASK)
return -EIO;

if (mib->length == 4)
offset = 3;
else
offset = (mib->offset + 1) % 4;

mibvalue = 0;
for (i = 0; i < mib->length; i++) {
REG_RD(smi, RTL8367B_MIB_COUNTER_REG(offset - i), &data);
mibvalue = (mibvalue << 16) | (data & 0xFFFF);
}

*val = mibvalue;
return 0;
}

The above function is used to get the counters of different ports and different mibs (like pkts rx, tx, etc. etc.).</s>




NEXT




<s> static int b53_spi_read32(struct b53_device *dev, u8 page, u8 reg, u32 *val)
{
int ret = b53_spi_read(dev, page, reg, (u8 *)val, 4);

if (!ret)
*val = le32_to_cpu(*val);

return ret;
}

The above function is used to read 32bit values from the B53 device. The function first tries to do a SPI read (using a separate, lower-level b53_spi_read function) to get the 32-bit value. If




NEXT




<s> int nvram_to_staging(void)
{
int fdmtd, fdstg, stat;
char *mtd = nvram_find_mtd();
char buf[nvram_part_size];

stat = -1;

if( (mtd != NULL) && (nvram_part_size > 0) )
{
if( (fdmtd = open(mtd, O_RDONLY)) > -1 )
{
if( read(fdmtd, buf, sizeof(buf)) == sizeof(buf) )
{
if((fdstg = open(NVRAM_STAGING, O_WRONLY | O_CREAT, 0600)) > -1)
{
write(fdstg, buf, sizeof(buf));
fsync(fdstg);
close(fdstg);

stat = 0;
}
}

close(fdmtd);
}
}

free(mtd);
return stat;
}

The above function is used to create nvram_staging file if missing and
write data from nvram to nvram_staging if the file does exist, so
that the device may be properly shut down.</s>




NEXT




<s> static void AT91F_SpuriousHandler()
{
puts("ISI");
while (1);
}

The above function is used to handle spurious interrupts of type ISI (Interrupt Spurious). In this post I will explain why we need to deal with spurious interrupts in our code.

Interrupts are used to notify software to handle some event occurred




NEXT




<s> static int rtl8367b_mii_read(struct mii_bus *bus, int addr, int reg)
{
struct rtl8366_smi *smi = bus->priv;
u32 val = 0;
int err;

err = rtl8367b_read_phy_reg(smi, addr, reg, &val);
if (err)
return 0xffff;

return val;
}

The above function is used to access a physical interface of an Ethernet network
module with a MII-like bus. The function returns the error code of the read operation,
and if successful, the value read will be returned. The driver should implement a
platform




NEXT




<s> static int md5_final(struct shash_desc *desc, u8 *out)
{
struct md5_ctx *mctx = shash_desc_ctx(desc);
const unsigned int offset = mctx->byte_count & 0x3f;
char *p = (char *)mctx->block + offset;
int padding = 56 - (offset + 1);
//volatile struct deu_hash_t *hashs = (struct deu_hash_t *) HASH_START;
//unsigned long flag;

*p++ = 0x80;
if (padding < 0) {
memset(p, 0x00, padding + sizeof (u64));
md5_transform_helper(mctx);
p = (char *)mctx->block;
padding = 56;
}

memset(p, 0, padding);
mctx->block[14] = le32_to_cpu(mctx->byte_count << 3);
mctx->block[15] = le32_to_cpu(mctx->byte_count >> 29);

md5_transform(mctx, mctx->hash, mctx->block);

memcpy(out, mctx->hash, MD5_DIGEST_SIZE);

// Wipe context
memset(mctx, 0, sizeof(*mctx));

return 0;
}

The above function is used to finalize a md5 hashing operation and get the corresponding MD5 hash. It finalizes the MD5 input and then invokes the
md5_transform() to compute the MD5 digest of the finalized input. Please have a look




NEXT




<s> void MD5_Final (hash, mdContext)
unsigned char hash[];
MD5_CTX *mdContext;
{
UINT4 in[16];
int mdi;
unsigned int i, ii;
unsigned int padLen;

/* save number of bits */
in[14] = mdContext->i[0];
in[15] = mdContext->i[1];

/* compute number of bytes mod 64 */
mdi = (int)((mdContext->i[0] >> 3) & 0x3F);

/* pad out to 56 mod 64 */
padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
MD5_Update (mdContext, PADDING, padLen);

/* append length in bits and transform */
for (i = 0, ii = 0; i < 14; i++, ii += 4)
in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
(((UINT4)mdContext->in[ii+2]) << 16) |
(((UINT4)mdContext->in[ii+1]) << 8) |
((UINT4)mdContext->in[ii]);
Transform (mdContext->buf, in);

/* store buffer in digest */
for (i = 0, ii = 0; i < 4; i++, ii += 4) {
mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xFF);
mdContext->digest[ii+1] =
(unsigned char)((mdContext->buf[i] >> 8) & 0xFF);
mdContext->digest[ii+2] =
(unsigned char)((mdContext->buf[i] >> 16) & 0xFF);
mdContext->digest[ii+3] =
(unsigned char)((mdContext->buf[i] >> 24) & 0xFF);
}
memcpy(hash, mdContext->digest, 16);
}

The above function is used to process the final bits and to store them in the digest.</s>




NEXT




<s> static int aw9523_pmx_get_groups(struct pinctrl_dev *pctl, unsigned int sel,
const char * const **groups,
unsigned int * const num_groups)
{
*groups = aw9523_pmx[sel].grps;
*num_groups = aw9523_pmx[sel].num_grps;
return 0;
}

The above function is used to determine the number of groups available for a given select line. The groups of groups is provided as an array.</s>




NEXT




<s> static int rtl8366s_sw_set_green_port(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
return rtl8366s_set_green_port(smi, val->port_vlan, val->value.i);
}

The above function is used to control port priority and the green
port of a switch chip. The rtl8366s chip has three different green
ports, which are set by the MAC-ID, VLAN, and QOS. As this function
controls




NEXT




<s> ret_t rtl8367c_setAsicI2CRxOneCharCmd(rtk_uint8 *pValue)
{
rtk_uint32 regData;
ret_t retVal;

/* Bits [4-1] = 0b0011, Rx one char; Bit [0] = 1, Trigger the Command */
if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
return retVal;
regData &= 0xFFE0;
regData |= 0x0007;
if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
return retVal;

/* wait for command finished */
do{
if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
return retVal;
}while( (regData & 0x1) != 0x0);

*pValue = (rtk_uint8)(regData >> 8);
return RT_ERR_OK ;

}

The above function is used to control  whether it is ready for reading one char,  because some IIC devices would write a trigger to a device. After the device has received this trigger, it will reply the command. So we need some logic here to check whether the receiver




NEXT




<s> ret_t rtl8367c_getAsicUnknownIPv6MulticastBehavior(rtk_uint32 port, rtk_uint32 *pBehave)
{
if(port >  RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_UNKNOWN_IPV6_MULTICAST_REG(port), RTL8367C_UNKNOWN_IPV6_MULTICAST_MASK(port), pBehave);
}

The above function is used to get Asic unknown IPv6 multicast behavior in RTL8367C. This time it is defined in asicReg.c:

ret_t rtl8367c_getAsicUnknownIP




NEXT




<s> rtk_api_ret_t rtk_int_status_get(rtk_int_status_t* pStatusMask)
{
rtk_api_ret_t   retVal;
rtk_uint32          ims_mask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pStatusMask)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicInterruptStatus(&ims_mask)) != RT_ERR_OK)
return retVal;

pStatusMask->value[0] = (ims_mask & 0x00000FFF);
return RT_ERR_OK;
}

The above function is used to get the current status of each status bit.
If the interrupt status bit is 1 means that there are packets that match the corresponding table that interrupt the ASIC.</s>




NEXT




<s> void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to print the last match in C, Perl, Python, and
Ruby.
*/
#endif

/* Push back on string stream. */
#ifndef yyunput
#ifdef __cplusplus
static void




NEXT




<s> int BN_cmp(const BIGNUM *a, const BIGNUM *b)
{
int i;
int gt,lt;
BN_ULONG t1,t2;

if ((a == NULL) || (b == NULL))
{
if (a != NULL)
return(-1);
else if (b != NULL)
return(1);
else
return(0);
}

bn_check_top(a);
bn_check_top(b);

if (a->neg != b->neg)
{
if (a->neg)
return(-1);
else    return(1);
}
if (a->neg == 0)
{ gt=1; lt= -1; }
else    { gt= -1; lt=1; }

if (a->top > b->top) return(gt);
if (a->top < b->top) return(lt);
for (i=a->top-1; i>=0; i--)
{
t1=a->d[i];
t2=b->d[i];
if (t1 > t2) return(gt);
if (t1 < t2) return(lt);
}
return(0);
}

The above function is used to compare two BIGNUM objects which are to be interpreted as signed integer values, returning a value < 0, 0 or > 0 if a is smaller than, equal to, or larger than b, respectively.</s>




NEXT




<s> static int setPhy(struct ip17xx_state *state, reg mii, u16 value)
{
int err;

if (!REG_SUPP(mii))
return -EFAULT;
err = ip_phy_write(state, mii.p, mii.m, value);
if (err < 0)
return err;
mdelay(2);
getPhy(state, mii);
return 0;
}

The above function is used to write a value in the PHY registers. This is needed when the function setPhy() is called from another module.

We get to know the IP phy is a customised one and needs 2ms for it to refresh or




NEXT




<s> rtk_api_ret_t rtk_l2_limitLearningCnt_set(rtk_port_t port, rtk_mac_cnt_t mac_cnt)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if (mac_cnt > rtk_switch_maxLutAddrNumber_get())
return RT_ERR_LIMITED_L2ENTRY_NUM;

if ((retVal = rtl8367c_setAsicLutLearnLimitNo(rtk_switch_port_L2P_get(port), mac_cnt)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the maximum the MAC address learning counters.
When this function is executed, the L2MAC table will be cleared. If there are already MAC addresses learned, the values in other fields will be kept.
The L2 table maximum number




NEXT




<s> ret_t rtl8367c_getAsicSvlanLookupType(rtk_uint32* pType)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_SVLAN_LOOKUP_TYPE, RTL8367C_SVLAN_LOOKUP_TYPE_OFFSET, pType);
}

The above function is used to find out what type of lookup algorithm for SVLAN is implemented on ASIC.
In my case,
after debugging for a while, the type is SVLAN_LOOKUP_TYPE_IPQOS = 0 which is Q




NEXT




<s> ar8xxx_mib_flush(struct ar8xxx_priv *priv)
{
return ar8xxx_mib_op(priv, AR8216_MIB_FUNC_FLUSH);
}

The above function is used to flush the counters. Is that necessary if
I’m programming everything with the mbufs? That means I only use the
counters in a single run, in case of a failure. I’m not sure when I have





NEXT




<s> static int rtl8366rb_sw_get_mirror_monitor_port(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366RB_PMCR, &data);
val->value.i = (data & RTL8366RB_PMCR_MONITOR_PORT_MASK) >> 4;

return 0;
}

The above function is used to read the monitor port that is used to bypass
and mirror the packet. To configure the monitor port, we will need to
write to the Monitor Register, RTL8366RB_PMCR. See the spec
(https




NEXT




<s> static int b53_global_reset_mib(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct b53_device *priv = sw_to_b53(dev);
u8 gc;

b53_read8(priv, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, &gc);

b53_write8(priv, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, gc | GC_RESET_MIB);
mdelay(1);
b53_write8(priv, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, gc & ~GC_RESET_MIB);
mdelay(1);

return 0;
}

The above function is used to reset counters and flush stats as well as flush buffers.
This is done mainly due to lack of appropriate support to implement the MPCS function
on the B53 devices.

However, as this function has no locks at the




NEXT




<s> void dc_aca_event_addr_get(struct dc_ep_priv *priv,
struct aca_event_reg_addr *regs)
{
regs->txin_acc_sub = TXIN_ACA_ACCUM_SUB;
regs->txout_acc_add = TXOUT_ACA_ACCUM_ADD;
regs->rxin_acc_sub = RXIN_ACA_ACCUM_SUB;
regs->rxout_acc_add = RXOUT_ACA_ACCUM_ADD;
}

The above function is used to set TX and RX addr registers for ACA engine and
the corresponding hardware is as below:

typedef unsigned int uint32_t;
/*!
 * @brief ACA register set 0x0000




NEXT




<s> static void fe_set_msglevel(struct net_device *dev, u32 value)
{
struct fe_priv *priv = netdev_priv(dev);

priv->msg_enable = value;
}

The above function is used to enable/disable the message level of the
device. It can be called from user space to change the message level.

The driver supports 18 message levels, defined as follows:

1: TX/RX packet processing
2




NEXT




<s> bool sym_is_changeable(struct symbol *sym)
{
return sym->visible > sym->rev_dep.tri;
}

The above function is used to check whether a symbol is changeable?

How can I know my code is really changeable before I change it?

Actually there are two functions in sym.c, one is `sym_is_changeable()`





NEXT




<s> int putc(int c)
{
return at91_serial_putc(c);
}

The above function is used to implement printf and it is declared in stdio.h which is included at the beginning of the file.
Therefore, in the function at91_serial_putc, it prints the content inside the braces.

The first




NEXT




<s> old_signal = signal (SIGINT, sig_catch);
#endif

#ifdef USE_SGTTY
new_modes.sg_flags &= ~ECHO;
#else
new_modes.c_iflag &= ~IGNCR;
new_modes.c_iflag |= ICRNL;
new_modes.c_oflag |= OPOST|ONLCR;
new_modes.c_lflag &= ~(ECHO|ECHOE|ECHOK);
new_modes.c_lflag |= ICANON|ECHONL;
#endif

if (STTY (fileno (fp), &new_modes))
goto out;

/*
* the prompt is output, and the response read without
* echoing.  the trailing newline must be removed.  if
* the fgets() returns an error, a NULL pointer is
* returned.
*/

if (fputs (prompt, stdout) == EOF)
goto out;

(void) fflush (stdout);

if (fgets (buf, maxlen, fp) == buf) {
if ((cp = strchr (buf, '\n')))
*cp = '\0';
else
buf[maxlen - 1] = '\0';

#ifdef USE_SGTTY
putc ('\n', stdout);
#endif
}

The above function is used to prompt user to enter something (such as the name of a file he wants to read, or any information to store). It contains following errors:
1. A simple mistake (the function fflush is used for stdout rather than stderr)




NEXT




<s> static void ag71xx_dump_dma_regs(struct ag71xx *ag)
{
DBG("%s: dma_tx_ctrl=%08x, dma_tx_desc=%08x, dma_tx_status=%08x\n",
ag->dev->name,
ag71xx_rr(ag, AG71XX_REG_TX_CTRL),
ag71xx_rr(ag, AG71XX_REG_TX_DESC),
ag71xx_rr(ag, AG71XX_REG_TX_STATUS));

DBG("%s: dma_rx_ctrl=%08x, dma_rx_desc=%08x, dma_rx_status=%08x\n",
ag->dev->name,
ag71xx_rr(ag, AG71XX_REG_RX_CTRL),
ag71xx_rr(ag, AG71XX_REG_RX_DESC),
ag71xx_rr(ag, AG71XX_REG_RX_STATUS));
}

The above function is used to dump certain DMA registers.</s>




NEXT




<s> static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
int port,
struct switch_port_link *link)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data = 0;
u32 speed;

if (port >= RTL8367B_NUM_PORTS)
return -EINVAL;

rtl8366_smi_read_reg(smi, RTL8367B_PORT_STATUS_REG(port), &data);

link->link = !!(data & RTL8367B_PORT_STATUS_LINK);
if (!link->link)
return 0;

link->duplex = !!(data & RTL8367B_PORT_STATUS_DUPLEX);
link->rx_flow = !!(data & RTL8367B_PORT_STATUS_RXPAUSE);
link->tx_flow = !!(data & RTL8367B_PORT_STATUS_TXPAUSE);
link->aneg = !!(data & RTL8367B_PORT_STATUS_NWAY);

speed = (data & RTL8367B_PORT_STATUS_SPEED_MASK);
switch (speed) {
case 0:
link->speed = SWITCH_PORT_SPEED_10;
break;
case 1:
link->speed = SWITCH_PORT_SPEED_100;
break;
case 2:
link->speed = SWITCH_PORT_SPEED_1000;
break;
default:
link->speed = SWITCH_PORT_SPEED_UNKNOWN;
break;
}

return 0;
}

The above function is used to get link information for specified physical port. It calls smi_read_reg() function which is defined in rtl8366b_smi.c.
static int rtl8366_smi_read_




NEXT




<s> ret_t rtl8367c_getAsicRemarkingDscp2Dscp(rtk_uint32 dscp, rtk_uint32 *pRmkDscp)
{
if(dscp > RTL8367C_DSCPMAX)
return RT_ERR_QOS_DSCP_VALUE;

return rtl8367c_getAsicRegBits(RTL8367C_QOS_DSCP_TO_DSCP_REG(dscp), RTL8367C_QOS_DSCP_TO_DSCP_MASK(dscp), pRmkDscp);

}

The above function is used to write the value of the field in the table RTL8367C_QOS_DSCP_TO_DSCP_REG(dscp) in the second level lookup table. The address of the table is defined




NEXT




<s> unsigned int mii_mgr_read(unsigned int phy_addr,unsigned int phy_register,unsigned int *read_data)
{
struct mii_bus *bus = _gsw->bus;

mutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);

*read_data = bus->read(bus, phy_addr, phy_register);

mutex_unlock(&bus->mdio_lock);

return 0;
}

The above function is used to read a register from the Ethernet card and is only used for the first Ethernet card to have the EEHB interrupts.

The first time that the function is used, when "phy_addr = 0"




NEXT




<s> static void aca_basic_init(struct dc_ep_priv *priv)
{
u32 addr, mask;

/* Low 32 is RX, High 32 is TX */
wr32(0x1, UMT_ORDER_CFG);
/* TXIN/TXOUT/RXIN/RXOUT All Controlled by Genrisc */
wr32(0xF, HOST_TYPE);
/* Enable Host Gate CLK */
wr32(0x4000, HT_GCLK_ENABLE);
/* Host Page/MASK */
mask = ~priv->memsize + 1;
addr = mask | ((priv->phymem & mask) >> 16);
wr32(addr, AHB_ARB_HP_REG);
wr32(addr, OCP_ARB_ACC_PAGE_REG);
/* Stop all functions first */
wr32(0, GNRC_EN_TASK_BITMAP);

/* Enable XBAR */
aca_xbar_ia_reject_clr(priv, ACA_ACC_IA04);
aca_xbar_ia_reject_clr(priv, ACA_M_IA06);

dev_dbg(priv->dev, "aca basic config done\n");
}

The above function is used to reset the device, configure register and finally
enable ACATX. This function does a very simple and crude allocation. The ACATX
uses the whole memory of the SoC, so 0-ffffffff needs to be protected by




NEXT




<s> static void udebug_printf_hook(int level, const char *fmt, va_list ap)
{
udebug_entry_init(&ud_log);
udebug_entry_vprintf(&ud_log, fmt, ap);
udebug_entry_add(&ud_log);
}

The above function is used to hook our own printf function into the system. You should replace g_print() or g_printf(), or g_stprintf(), accordingly. When you want to dump the contents of a variable or anything just put a

g_print





NEXT




<s> ret_t rtl8367c_setAsicVlanMemberConfig(rtk_uint32 index, rtl8367c_vlanconfiguser *pVlanCg)
{
ret_t  retVal;
rtk_uint32 regAddr;
rtk_uint32 regData;
rtk_uint16 *tableAddr;
rtk_uint32 page_idx;
rtk_uint16 smi_vlancfg[RTL8367C_VLAN_MBRCFG_LEN];

/* Error Checking  */
if(index > RTL8367C_CVIDXMAX)
return RT_ERR_VLAN_ENTRY_NOT_FOUND;

if(pVlanCg->evid > RTL8367C_EVIDMAX)
return RT_ERR_INPUT;


if(pVlanCg->mbr > RTL8367C_PORTMASK)
return RT_ERR_PORT_MASK;

if(pVlanCg->fid_msti > RTL8367C_FIDMAX)
return RT_ERR_L2_FID;

if(pVlanCg->meteridx > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(pVlanCg->vbpri > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

memset(smi_vlancfg, 0x00, sizeof(rtk_uint16) * RTL8367C_VLAN_MBRCFG_LEN);
_rtl8367c_VlanMCStUser2Smi(pVlanCg, smi_vlancfg);
tableAddr = smi_vlancfg;

for(page_idx = 0; page_idx < 4; page_idx++)  /* 4 pages per VLAN Member Config */
{
regAddr = RTL8367C_VLAN_MEMBER_CONFIGURATION_BASE + (index * 4) + page_idx;
regData = *tableAddr;

retVal = rtl8367c_setAsicReg(regAddr, regData);
if(retVal != RT_ERR_OK)
return retVal;

tableAddr++;
}

return RT_ERR_OK;
}

The above function is used to set the VLAN Membership Configuration which is also known as member set or Port Assignment. There are four 16bit VLANMBRCFG registers for each VLAN. VLAN MBRC is 16 word long structure and one




NEXT




<s> static int i2c_outb(int c)
{
int i;
int ack;

/* assert: scl is low */
for (i = 7; i >= 0; i--) {
if (c & ( 1 << i )) {
sdahi();
} else {
sdalo();
}
if (sclhi() < 0) { /* timed out */
sdahi(); /* we don't want to block the net */
return -ETIMEDOUT;
};
scllo();
}
sdahi();
if (sclhi() < 0) {
return -ETIMEDOUT;
};
/* read ack: SDA should be pulled down by slave */
ack = getsda() == 0;	/* ack: sda is pulled low ->success.	 */
scllo();

if (rtc_debug)
printk(KERN_DEBUG "i2c_outb(0x%02x) -> %s\n",
c, ack ? "ACK": "NAK");

return ack;		/* return 1 if device acked	 */
/* assert: scl is low (sda undef) */
}

The above function is used to write a 8-bit data to the slave device over I2C bus.

If the device did not ack the data, it means that the receiver did not receive the byte from I2C bus due to bus contention from




NEXT




<s> static int wlc_int(wlc_param param, void *data, void *value)
{
int *var = *((int **) data);
int *val = (int *) value;

if ((param & PARAM_MODE) == SET) {
*var = *val;
} else if ((param & PARAM_MODE) == GET) {
*val = *var;
}

return 0;
}

The above function is used to set and get values of WL_V_INT type params like the tx-ampdu-disable parameter. How can I get more info on the format of this function?

Also, for example consider the line in the below link




NEXT




<s> static int b53_srab_read64(struct b53_device *dev, u8 page, u8 reg, u64 *val)
{
u8 __iomem *regs = dev->priv;
int ret = 0;

ret = b53_srab_request_grant(dev);
if (ret)
goto err;

ret = b53_srab_op(dev, page, reg, 0);
if (ret)
goto err;

*val = readl(regs + B53_SRAB_RD_L);
*val += (u64)readl(regs + B53_SRAB_RD_H) << 32;

err:
b53_srab_release_grant(dev);

return ret;
}

The above function is used to read 64 bits of an SRAB register. It first asks the SRAB controller for a grant, then issues an operation to the controller, and finally reads from the registers. There are two registers read – one contains low 32 bits




NEXT




<s> int serial_console_getc(void)
{
while ((in_8(reg_base + (UART_LSR << reg_shift)) & UART_LSR_DR) == 0);
return in_8(reg_base);
}

The above function is used to get the character typed by the user from keyboard in serial console. However this function will stuck after one character is fetched (i.e. will not get the next character from the keyboard).
To overcome this issue, following code will be used




NEXT




<s> void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to copy the character that was left most
after the rule we matched. That may be in yytext, or it may be in yytext and we
need to advance the text_ptr.

*/
#endif

#ifndef Y




NEXT




<s> ar8216_phy_read(struct ar8xxx_priv *priv, int addr, int regnum)
{
u32 t, val = 0xffff;
int err;

if (addr >= AR8216_NUM_PORTS)
return 0xffff;
t = (regnum << AR8216_MDIO_CTRL_REG_ADDR_S) |
(addr << AR8216_MDIO_CTRL_PHY_ADDR_S) |
AR8216_MDIO_CTRL_MASTER_EN |
AR8216_MDIO_CTRL_BUSY |
AR8216_MDIO_CTRL_CMD_READ;

ar8xxx_write(priv, AR8216_REG_MDIO_CTRL, t);
err = ar8xxx_reg_wait(priv, AR8216_REG_MDIO_CTRL,
AR8216_MDIO_CTRL_BUSY, 0, 5);
if (!err)
val = ar8xxx_read(priv, AR8216_REG_MDIO_CTRL);

return val & AR8216_MDIO_CTRL_DATA_M;
}

The above function is used to read register value from AR8216 device. However, I don’t know why there are some value written into the function arguments. As you can see, the arguments are actually unused in ar8216_phy_read().




NEXT




<s> static int rtl8366s_sw_reset_mibs(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

return rtl8366_smi_rmwr(smi, RTL8366S_MIB_CTRL_REG, 0, (1 << 2));
}

The above function is used to reset the device statistics, which is triggered by the set of switch attributes that has the following structure:

switch_attr_r8366s_sw_reset_mibs =
{
.name = "sw_




NEXT




<s> static void rtl83xx_setup_bpdu_traps(struct rtl838x_switch_priv *priv)
{
for (int i = 0; i < priv->cpu_port; i++)
priv->r->set_receive_management_action(i, BPDU, TRAP2CPU);
}

The above function is used to turn BPDU frames from being forwarded (they usually are) to being trapped.  While the default behavior on the RTL838x is to trap BPDUs coming into the CPU port directly, they generally get sent out the




NEXT




<s> ret_t rtl8367c_getAsicFlowControlSharedDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SHARE_OFF, RTL8367C_FLOWCTRL_FCOFF_SHARE_OFF_MASK, pOffThreshold);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SHARE_ON, RTL8367C_FLOWCTRL_FCOFF_SHARE_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to get off and on offloads shared threshold values.

The above function works but it crashes with rtems sometimes . After searching why it crashes, I found that we need to use the following macro before accessing the register with asic




NEXT




<s> rtk_api_ret_t rtk_cpu_acceptLength_get(rtk_cpu_rx_length_t *pLength)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pLength)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicCputagRxMinLength(pLength)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the CPU's Rx length.</s>




NEXT




<s> static irqreturn_t bcm6348_emac_isr_mac(int irq, void *dev_id)
{
struct net_device *ndev = dev_id;
struct bcm6348_emac *emac = netdev_priv(ndev);
u32 stat;

stat = emac_readl(emac, ENET_IR_REG);
if (!(stat & ENET_IR_MIB))
return IRQ_NONE;

/* clear & mask interrupt */
emac_writel(emac, ENET_IR_MIB, ENET_IR_REG);
emac_writel(emac, 0, ENET_IRMASK_REG);

return IRQ_HANDLED;
}

The above function is used to handle the MAC-related interrupts of the Ethernet port.

This function clears the interrupt register using the command

emac_writel(emac, ENET_IR_MIB, ENET_IR_




NEXT




<s> static int rtl8367b_set_vlan_4k(struct rtl8366_smi *smi,
const struct rtl8366_vlan_4k *vlan4k)
{
u32 data[RTL8367B_TA_VLAN_NUM_WORDS];
int err;
int i;

if (vlan4k->vid >= RTL8367B_NUM_VIDS ||
vlan4k->member > RTL8367B_TA_VLAN0_MEMBER_MASK ||
vlan4k->untag > RTL8367B_UNTAG_MASK ||
vlan4k->fid > RTL8367B_FIDMAX)
return -EINVAL;

memset(data, 0, sizeof(data));

data[0] = (vlan4k->member & RTL8367B_TA_VLAN0_MEMBER_MASK) <<
RTL8367B_TA_VLAN0_MEMBER_SHIFT;
data[0] |= (vlan4k->untag & RTL8367B_TA_VLAN0_UNTAG_MASK) <<
RTL8367B_TA_VLAN0_UNTAG_SHIFT;
data[1] = (vlan4k->fid & RTL8367B_TA_VLAN1_FID_MASK) <<
RTL8367B_TA_VLAN1_FID_SHIFT;

for (i = 0; i < ARRAY_SIZE(data); i++)
REG_WR(smi, RTL8367B_TA_WRDATA_REG(i), data[i]);

/* write VID */
REG_WR(smi, RTL8367B_TA_ADDR_REG,
vlan4k->vid & RTL8367B_TA_VLAN_VID_MASK);

/* write table access control word */
REG_WR(smi, RTL8367B_TA_CTRL_REG, RTL8367B_TA_CTRL_CVLAN_WRITE);

return 0;
}

The above function is used to configure the VLAN tag of RTL8367B.

For a general packet that has passed VLAN 4k, the VLAN field and Etype
field should be parsed to decide its packet type. In this case




NEXT




<s> static int nmbm_read_phys_page(struct nmbm_instance *ni, uint64_t addr,
void *data, void *oob)
{
int tries, ret;

for (tries = 0; tries < NMBM_TRY_COUNT; tries++) {
struct mtd_oob_ops ops = {
.mode = MTD_OPS_PLACE_OOB,
.oobbuf = oob,
.datbuf = data,
};

if (data)
ops.len = bmtd.pg_size;
if (oob)
ops.ooblen = mtd_oobavail(bmtd.mtd, &ops);

ret = bmtd._read_oob(bmtd.mtd, addr, &ops);
if (ret == -EUCLEAN)
return min_t(u32, bmtd.mtd->bitflip_threshold + 1,
bmtd.mtd->ecc_strength);
if (ret >= 0)
return 0;
}

if (ret != -EBADMSG)
nlog_err(ni, "Page read failed at address 0x%08llx\n", addr);

return ret;
}

The above function is used to read a physcal page. If the page is marked as cleaned by OOB ECC, or read error happens, the return value will be -ECLEAN. The function is only called to validate an erase operation or flash the data




NEXT




<s> YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
{ \
if ( ! YY_CURRENT_BUFFER ){ \
yyensure_buffer_stack (); \
YY_CURRENT_BUFFER_LVALUE =    \
yy_create_buffer( yyin, YY_BUF_SIZE ); \
} \
YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
}

The above function is used to ensure that the current buffer has been allocated. This function is used to store the state of the current buffer used by scan functions.
#define YY_NEVER_INTERACTIVE 0
#define YY_ALWAYS_INTER




NEXT




<s> static int rtl83xx_stats_flower(struct rtl838x_switch_priv *priv,
struct flow_cls_offload * cls_flower)
{
struct rtl83xx_flow *flow;
unsigned long lastused = 0;
int total_packets, new_packets;

pr_debug("%s: \n", __func__);
flow = rhashtable_lookup_fast(&priv->tc_ht, &cls_flower->cookie, tc_ht_params);
if (!flow)
return -1;

if (flow->rule.packet_cntr >= 0) {
total_packets = priv->r->packet_cntr_read(flow->rule.packet_cntr);
pr_debug("Total packets: %d\n", total_packets);
new_packets = total_packets - flow->rule.last_packet_cnt;
flow->rule.last_packet_cnt = total_packets;
}

/* TODO: We need a second PIE rule to count the bytes */
flow_stats_update(&cls_flower->stats, 100 * new_packets, new_packets, 0, lastused,
FLOW_ACTION_HW_STATS_IMMEDIATE);

return 0;
}

The above function is used to update the flow stats on every packet we classify/update in the
flow table.


int main(void) {

return 0;
}</s>




NEXT




<s> static void adm6996_gpio_adclk(struct adm6996_priv *priv, int clocks)
{
int i;
for (i = 0; i < clocks; i++) {
/* Clock high */
gpio_set_value(priv->eesk, 1);
udelay(EECK_EDGE_TIME);

/* Clock low */
gpio_set_value(priv->eesk, 0);
udelay(EECK_EDGE_TIME);
}
}

The above function is used to configure and clock data lines between GPIO and
ADM6996. This can be used to switch the SDO pin of ADM6996 for test or to
simulate a bad or missing GPIO connection.</s>




NEXT




<s> hostapd_rrm_nr_set(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
static const struct blobmsg_policy nr_e_policy[] = {
{ .type = BLOBMSG_TYPE_STRING },
{ .type = BLOBMSG_TYPE_STRING },
{ .type = BLOBMSG_TYPE_STRING },
};
struct hostapd_data *hapd = get_hapd_from_object(obj);
struct blob_attr *tb_l[__NR_SET_LIST_MAX];
struct blob_attr *tb[ARRAY_SIZE(nr_e_policy)];
struct blob_attr *cur;
int rem;

hostapd_rrm_nr_enable(hapd);

blobmsg_parse(nr_set_policy, __NR_SET_LIST_MAX, tb_l, blob_data(msg), blob_len(msg));
if (!tb_l[NR_SET_LIST])
return UBUS_STATUS_INVALID_ARGUMENT;

hostapd_rrm_nr_clear(hapd);
blobmsg_for_each_attr(cur, tb_l[NR_SET_LIST], rem) {
struct wpa_ssid_value ssid;
struct wpabuf *data;
u8 bssid[ETH_ALEN];
char *s, *nr_s;

blobmsg_parse_array(nr_e_policy, ARRAY_SIZE(nr_e_policy), tb, blobmsg_data(cur), blobmsg_data_len(cur));
if (!tb[0] || !tb[1] || !tb[2])
goto invalid;

/* Neighbor Report binary */
nr_s = blobmsg_get_string(tb[2]);
data = wpabuf_parse_bin(nr_s);
if (!data)
goto invalid;

/* BSSID */
s = blobmsg_get_string(tb[0]);
if (strlen(s) == 0) {
/* Copy BSSID from neighbor report */
if (hwaddr_compact_aton(nr_s, bssid))
goto invalid;
} else if (hwaddr_aton(s, bssid)) {
goto invalid;
}

/* SSID */
s = blobmsg_get_string(tb[1]);
if (strlen(s) == 0) {
/* Copy SSID from hostapd BSS conf */
memcpy(&ssid, &hapd->conf->ssid, sizeof(ssid));
} else {
ssid.ssid_len = strlen(s);
if (ssid.ssid_len > sizeof(ssid.ssid))
goto invalid;

memcpy(&ssid, s, ssid.ssid_len);
}

hostapd_neighbor_set(hapd, bssid, &ssid, data, NULL, NULL, 0, 0);
wpabuf_free(data);
continue;

invalid:
return UBUS_STATUS_INVALID_ARGUMENT;
}

return 0;
}

The above function is used to parse and set the attribute values for the Neighbor Report. When the function is called and parses the input blob, if the set_list attribute is not specified, then it returns UBUS_STATUS_INVALID_ARGUMENT.

For




NEXT




<s> static int ip17xx_apply(struct switch_dev *dev)
{
struct ip17xx_state *state = get_state(dev);

if (REG_SUPP(state->regs->MII_REGISTER_EN)) {
int val = getPhy(state, state->regs->MII_REGISTER_EN);
if (val < 0) {
return val;
}
val |= (1<<state->regs->MII_REGISTER_EN_BIT);
return setPhy(state, state->regs->MII_REGISTER_EN, val);
}
return 0;
}

The above function is used to apply (set) bits for the register of the PHY.</s>




NEXT




<s> rtk_api_ret_t rtk_cpu_tagPort_set(rtk_port_t port, rtk_cpu_insert_t mode)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if (mode >= CPU_INSERT_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicCputagPortmask(1<<rtk_switch_port_L2P_get(port))) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicCputagTrapPort(rtk_switch_port_L2P_get(port))) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicCputagInsertMode(mode)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the CPU-insert tag control register.

rtl8367c_setAsicCputagInsertMode

Function:
Set the CPU-insert tag insert mode.

Parameters:
mode: set insert




NEXT




<s> void put_u32(uint32_t v)
{
put_u16(v >> 16);
put_u16(v);
}

The above function is used to write
32-bit values in the serial port for the
s-records.

As a consequence of this, the following is
the code to parse these s-records, by
reading 4 bytes,
swapping




NEXT




<s> static void aca_fw_parse(struct dc_ep_priv *priv, const char *data,
const char *fw_base, int fw_num)
{
int i;
size_t size;
u32 id, offset, addr;
struct aca_int_hdr *hdr;
struct aca_fw_dl_addr *fw_dl = to_fw_addr(priv);

fw_dl->fw_num = fw_num;

for (i = 0; i < fw_dl->fw_num; i++) {
hdr = (struct aca_int_hdr *)(data + i * sizeof(*hdr));
id = be32_to_cpu(hdr->id);
offset = be32_to_cpu(hdr->offset);
size = be32_to_cpu(hdr->size);
addr = be32_to_cpu(hdr->load_addr);

fw_dl->fw_addr[i].fw_id = id;
fw_dl->fw_addr[i].fw_load_addr = addr;
fw_dl->fw_addr[i].fw_size = size;
fw_dl->fw_addr[i].fw_base = fw_base + offset;
dev_dbg(priv->dev,
"aca %s fw offset 0x%x size %zd loc 0x%x fw base %p\n",
fw_id_to_str(id), offset, size, addr, fw_base + offset);
}
}

The above function is used to parse and load all the firmwares required
for ACA devices. The firmwares for the ACA devices are stored as
a large image in the form of a single binary dump. The
struct aca_fw_dl_




NEXT




<s> static inline void mt7621_nfc_hw_init(struct mt7621_nfc *nfc)
{
u32 acccon;

/*
* CNRNB: nand ready/busy register
* -------------------------------
* 7:4: timeout register for polling the NAND busy/ready signal
* 0  : poll the status of the busy/ready signal after [7:4]*16 cycles.
*/
nfi_write16(nfc, NFI_CNRNB, CB2R_TIME_M | STR_CNRNB);

mt7621_nfc_hw_reset(nfc);

/* Apply default access timing */
acccon = ACCTIMING(ACCCON_POECS_DEF, ACCCON_PRECS_DEF, ACCCON_C2R_DEF,
ACCCON_W2R_DEF, ACCCON_WH_DEF, ACCCON_WST_DEF,
ACCCON_RLT_DEF);

nfi_write32(nfc, NFI_ACCCON, acccon);
}

The above function is used to reset the nfc hardware.

The following are parts of NFI_ACCCON structure</s>




NEXT




<s> static int wlc_bssmax(wlc_param param, void *data, void *value)
{
int *val = (int *) value;
char *iov = *((char **) data);
int ret = -1;

if (param & GET) {
ret = wl_iovar_get(interface, iov, wlbuf, BUFSIZE);
if (!ret) {
if (strstr(wlbuf, "mbss4"))
*val = 4;
else if (strstr(wlbuf, "mbss16"))
*val = 16;
else
*val = 1;
}
}

return ret;
}

The above function is used to get information on the number of SSIDs supported for an AP. The iovar used is “bssmax” and is configured through IOL. The following example shows how to change the maximum number of SSIDs.

WL_IOL




NEXT




<s> static int rtl8366s_set_green_port(struct rtl8366_smi *smi, int port, int enable)
{
int err;
u32 phyData;

if (port >= RTL8366S_NUM_PORTS)
return -EINVAL;

err = rtl8366s_read_phy_reg(smi, port, 0, RTL8366S_PHY_POWER_SAVING_CTRL_REG, &phyData);
if (err)
return err;

if (enable)
phyData |= RTL8366S_PHY_POWER_SAVING_MASK;
else
phyData &= ~RTL8366S_PHY_POWER_SAVING_MASK;

err = rtl8366s_write_phy_reg(smi, port, 0, RTL8366S_PHY_POWER_SAVING_CTRL_REG, phyData);
if (err)
return err;

return 0;
}

The above function is used to enable or disable power saving on a green port. The corresponding power saving setting was implemented by the Ethernet PHY.</s>




NEXT




<s> static void rtl838x_mac_link_down(struct phylink_config *config,
unsigned int mode,
phy_interface_t interface)
{
struct net_device *dev = container_of(config->dev, struct net_device, dev);
struct rtl838x_eth_priv *priv = netdev_priv(dev);

pr_debug("In %s\n", __func__);
/* Stop TX/RX to port */
sw_w32_mask(0x03, 0, priv->r->mac_port_ctrl(priv->cpu_port));
}

The above function is used to control the link status.
When link is down, stop the MAC port which is linked.
Due to this function is not used in this project, we just redefine
it to print a msg to confirm it has been called.





NEXT




<s> static inline struct aes_container *aes_container_cast (
struct ablkcipher_request *areq)
{
return container_of(areq, struct aes_container, arequest);
}

The above function is used to get an struct aes_container* whose ablkcipher_request type is areq. Is aes_container really struct aes_container* ? If so, what about the pointer type 'struct aes_container *' ?




NEXT




<s> ar8xxx_set_age_time(struct ar8xxx_priv *priv, int reg)
{
u32 age_time = ar8xxx_age_time_val(priv->arl_age_time);
ar8xxx_rmw(priv, reg, AR8216_ATU_CTRL_AGE_TIME, age_time << AR8216_ATU_CTRL_AGE_TIME_S);
}

The above function is used to program to set the time interval between the switch sending an age packet and receiving the age packet through ARP; ARP aging. During testing, when aging is configured, ARP will take a few minutes to work due to the delay in the timer




NEXT




<s> static int b53_phy_read_status(struct phy_device *phydev)
{
struct b53_device *priv = phydev->priv;

if (is5325(priv) || is5365(priv))
phydev->speed = 100;
else
phydev->speed = 1000;

phydev->duplex = DUPLEX_FULL;
phydev->link = 1;
phydev->state = PHY_RUNNING;

netif_carrier_on(phydev->attached_dev);
phydev->adjust_link(phydev->attached_dev);

return 0;
}

The above function is used to handle the B53 PHY's interrupts.  It is only
responsible for reading in the PHY interrupt register to determine what the
interrupts are for.  This interrupt register is in the same place as the one





NEXT




<s> static inline int dma_busy(void)
{
return readl(SATA_DMA_REGS_BASE + DMA_CTRL_STATUS)
& DMA_CTRL_STATUS_IN_PROGRESS;
}

The above function is used to test if the outgoing DMA operation is in
progress. If you use dma_enable() and then test dma_busy() in your
application but the result of dma_busy() = 1, the dma




NEXT




<s> static int psb6970_fixup(struct phy_device *dev)
{
struct mii_bus *bus = dev->mdio.bus;
u16 reg;

/* look for the switch on the bus */
reg = bus->read(bus, PHYADDR(PSB6970_CI1)) & PSB6970_CI1_MASK;
if (reg != PSB6970_CI1_VAL)
return 0;

dev->phy_id = (reg << 16);
dev->phy_id |= bus->read(bus, PHYADDR(PSB6970_CI0)) & PSB6970_CI0_MASK;

return 0;
}

The above function is used to get switch ID, the ID is the combination of port address and internal switch ID.

Let’s take two examples:
Port#0x1 port switch#0xAB
Port#0x2 port switch#0xCD




NEXT




<s> rtk_api_ret_t rtk_igmp_ReportLeaveFwdAction_set(rtk_igmp_ReportLeaveFwdAct_t action)
{
rtk_api_ret_t   retVal;
rtk_uint32      regData;

/* Check initialization state */
RTK_CHK_INIT_STATE();

switch(action)
{
case IGMP_REPORT_LEAVE_TO_ROUTER:
regData = 1;
break;
case IGMP_REPORT_LEAVE_TO_ALLPORT:
regData = 2;
break;
case IGMP_REPORT_LEAVE_TO_ROUTER_PORT_ADV:
regData = 3;
break;
default:
return RT_ERR_INPUT;
}

if ((retVal = rtl8367c_setAsicIGMPReportLeaveFlood(regData))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable or disable the report of Multicast/IGMP Leave at egress ports.

- When this function passes RT_ERR_OK, It means that the operation is successful.
- When this function passed RT_ERR_INPUT




NEXT




<s> static int proc_write_mem(struct file *, const char *, unsigned long, void *);
static int proc_read_pp32(char *, char **, off_t, int, int *, void *);
static int proc_write_pp32(struct file *, const char *, unsigned long, void *);
static int stricmp(const char *, const char *);
static int strincmp(const char *, const char *, int);
static int get_token(char **, char **, int *, int *);
static int get_number(char **, int *, int);
static inline void ignore_space(char **, int *);



/*
* ####################################
*            Local Variable
* ####################################
*/



/*
* ####################################
*            Local Function
* ####################################
*/

static inline void proc_file_create(void)
{
struct proc_dir_entry *res;

res = create_proc_entry("driver/ifx_ptm/mem",
0,
NULL);
if ( res != NULL )
res->write_proc = proc_write_mem;
else
printk("%s:%s:%d: failed to create proc mem!", __FILE__, __func__, __LINE__);

res = create_proc_entry("driver/ifx_ptm/pp32",
0,
NULL);
if ( res != NULL ) {
res->read_proc = proc_read_pp32;
res->write_proc = proc_write_pp32;
}
else
printk("%s:%s:%d: failed to create proc pp32!", __FILE__, __func__, __LINE__);
}

The above function is used to write or read a block of memory. The address is expressed as “base address” and “offset”. The address can be written or read.

The function creates a file in the proc directory and creates new files to be used by this code




NEXT




<s> static inline int rtl839x_mac_link_spd_sts(int p)
{
return RTL839X_MAC_LINK_SPD_STS(p);
}

The above function is used to test the link status of RTL839x devices which are used in the products. In this function,
I found RTL839X_MAC_LINK_STAD_25MBPS which is defined as:





NEXT




<s> static inline int rtl838x_mac_force_mode_ctrl(int p)
{
return RTL838X_MAC_FORCE_MODE_CTRL + (p << 2);
}

The above function is used to select physical device number for 802_3
promiscuous mode setting from the below list and the default is zero.

	#define RTL838X_MAC_FORCE_MODE_CTRL_1




NEXT




<s> rtk_api_ret_t rtk_port_macForceLink_set(rtk_port_t port, rtk_port_mac_ability_t *pPortability)
{
rtk_api_ret_t retVal;
rtl8367c_port_ability_t ability;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_IS_UTP(port);

if(NULL == pPortability)
return RT_ERR_NULL_POINTER;

if (pPortability->forcemode >1|| pPortability->speed > 2 || pPortability->duplex > 1 ||
pPortability->link > 1 || pPortability->nway > 1 || pPortability->txpause > 1 || pPortability->rxpause > 1)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_getAsicPortForceLink(rtk_switch_port_L2P_get(port), &ability)) != RT_ERR_OK)
return retVal;

ability.forcemode = pPortability->forcemode;
ability.speed     = pPortability->speed;
ability.duplex    = pPortability->duplex;
ability.link      = pPortability->link;
ability.nway      = pPortability->nway;
ability.txpause   = pPortability->txpause;
ability.rxpause   = pPortability->rxpause;

if ((retVal = rtl8367c_setAsicPortForceLink(rtk_switch_port_L2P_get(port), &ability)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure forced mode of a user selectable port.

*Parameter*

*port* : port index

*ability* : structure of rtk_port_mac_ability_t, with the forced mode information for the user




NEXT




<s> define_machine(firebox_t10) {
.name			= "P1010 RDB",
.probe			= firebox_t10_probe,
.setup_arch		= firebox_t10_setup_arch,
.init_IRQ		= firebox_t10_pic_init,
#ifdef CONFIG_PCI
.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
.pcibios_fixup_phb      = fsl_pcibios_fixup_phb,
#endif
.get_irq		= mpic_get_irq,
.calibrate_decr		= generic_calibrate_decr,
.progress		= udbg_progress,
};

The above function is used to probe the FB for t10. I dont think it will run on Firebox 5000, but this is what the code looks like.

In addition, you need to setup your environment variables for the FPGA




NEXT




<s> rtk_api_ret_t rtk_rldp_portConfig_get(rtk_port_t port, rtk_rldp_portConfig_t *pPortConfig)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk;
rtk_portmask_t logicalPmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicRldpTxPortmask(&pmsk))!=RT_ERR_OK)
return retVal;

if ((retVal = rtk_switch_portmask_P2L_get(pmsk, &logicalPmask)) != RT_ERR_OK)
return retVal;


if (logicalPmask.bits[0] & (1<<port))
{
pPortConfig->tx_enable = ENABLED;
}
else
{
pPortConfig->tx_enable = DISABLED;
}

return RT_ERR_OK;
} /* end of rtk_rldp_portConfig_get */

The above function is used to get the tx enable flag of rx/tx port, and then
judge the  bit of bitmask PMSK

/* Check validation for Rx port */

RTK_CHK_PORT_VALID(rx_port




NEXT




<s> int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
register int i;
int max,min;
BN_ULONG *ap,*bp,*rp,carry,t1;
const BIGNUM *tmp;

bn_check_top(a);
bn_check_top(b);

if (a->top < b->top)
{ tmp=a; a=b; b=tmp; }
max=a->top;
min=b->top;

if (bn_wexpand(r,max+1) == NULL)
return(0);

r->top=max;


ap=a->d;
bp=b->d;
rp=r->d;
carry=0;

carry=bn_add_words(rp,ap,bp,min);
rp+=min;
ap+=min;
bp+=min;
i=min;

if (carry)
{
while (i < max)
{
i++;
t1= *(ap++);
if ((*(rp++)=(t1+1)&BN_MASK2) >= t1)
{
carry=0;
break;
}
}
if ((i >= max) && carry)
{
*(rp++)=1;
r->top++;
}
}
if (rp != ap)
{
for (; i<max; i++)
*(rp++)= *(ap++);
}
/* memcpy(rp,ap,sizeof(*ap)*(max-i));*/
return(1);
}

The above function is used to add BIGNUM to BIGNUM modulo the modulus n.</s>




NEXT




<s> int BN_mod(BIGNUM *rem, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
{
#if 0 /* The old slow way */
int i,nm,nd;
BIGNUM *dv;

if (BN_ucmp(m,d) < 0)
return((BN_copy(rem,m) == NULL)?0:1);

BN_CTX_start(ctx);
dv=BN_CTX_get(ctx);

if (!BN_copy(rem,m)) goto err;

nm=BN_num_bits(rem);
nd=BN_num_bits(d);
if (!BN_lshift(dv,d,nm-nd)) goto err;
for (i=nm-nd; i>=0; i--)
{
if (BN_cmp(rem,dv) >= 0)
{
if (!BN_sub(rem,rem,dv)) goto err;
}
if (!BN_rshift1(dv,dv)) goto err;
}
BN_CTX_end(ctx);
return(1);
err:
BN_CTX_end(ctx);
return(0);
#else
return(BN_div(NULL,rem,m,d,ctx));
#endif
}

The above function is used to do this...

#include "mod.h"
int main(void)
{
unsigned int n;
uint8_t i;
BIGNUM *h, *h1;

/* h1 = 




NEXT




<s> ret_t rtl8367c_getAsicAclAct(rtk_uint32 index, rtl8367c_acl_act_t *pAclAct)
{
rtk_uint16 aclActSmi[RTL8367C_ACL_ACT_TABLE_LEN];
ret_t retVal;
rtk_uint32 regAddr, regData;
rtk_uint16 *tableAddr;
rtk_uint32 i;

if(index > RTL8367C_ACLRULEMAX)
return RT_ERR_OUT_OF_RANGE;

memset(aclActSmi, 0x00, sizeof(rtk_uint16) * RTL8367C_ACL_ACT_TABLE_LEN);

/* Write ACS_ADR register for data bits */
regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
regData = index;
retVal = rtl8367c_setAsicReg(regAddr, regData);
if(retVal != RT_ERR_OK)
return retVal;

/* Write ACS_CMD register */
regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_READ, TB_TARGET_ACLACT);
retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK, regData);
if(retVal != RT_ERR_OK)
return retVal;

/* Read Data Bits */
regAddr = RTL8367C_TABLE_ACCESS_RDDATA_BASE;
tableAddr = aclActSmi;
for(i = 0; i < RTL8367C_ACLACTTBLEN; i++)
{
retVal = rtl8367c_getAsicReg(regAddr, &regData);
if(retVal != RT_ERR_OK)
return retVal;

*tableAddr = regData;

regAddr ++;
tableAddr ++;
}

#ifdef CONFIG_RTL8367C_ASICDRV_TEST
memcpy(aclActSmi, &Rtl8370sVirtualAclActTable[index][0], sizeof(rtk_uint16) * RTL8367C_ACL_ACT_TABLE_LEN);
#endif

_rtl8367c_aclActStSmi2User(pAclAct, aclActSmi);

return RT_ERR_OK;
}

The above function is used to get the ACL Actions Table SMIs. Here, we assume that the SMIs have a valid structure. This function first accesses ACS_ADR register with the ACL Actions table index. Then, it writes 8 A




NEXT




<s> ret_t rtl8367c_setAsicEavMacAddress(ether_addr_t mac)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint8 *accessPtr;
rtk_uint32 i;

accessPtr =  (rtk_uint8*)&mac;

regData = *accessPtr;
accessPtr ++;
regData = (regData << 8) | *accessPtr;
accessPtr ++;
for(i = 0; i <=2; i++)
{
retVal = rtl8367c_setAsicReg(RTL8367C_REG_MAC_ADDR_H - i, regData);
if(retVal != RT_ERR_OK)
return retVal;

regData = *accessPtr;
accessPtr ++;
regData = (regData << 8) | *accessPtr;
accessPtr ++;
}

return retVal;
}

The above function is used to set EAV mac address. EAV means Explicit Address Vector. Actually EAV is the mac address field which is used in RP packet.

The original code uses the function rtl8367c_setAsicReg




NEXT




<s> int dc_aca_init(struct dc_ep_priv *priv, struct aca_param *param,
struct aca_modem_param *mdm)
{
int ret;
struct dc_aca *aca = to_aca(priv);

dc_aca_clk_on(priv);
dc_aca_reset(priv);

ret = aca_fetch_fw(priv);
if (ret) {
dev_err(priv->dev,
"could not fetch firmware files %d\n", ret);
dc_aca_clk_off(priv);
return ret;
}

aca_mem_clear(priv);
aca_dma_init(priv);
aca_basic_init(priv);
aca_fw_download(priv);
aca_hif_param_init(priv);
aca_txin_init(priv, &param->aca_txin);
aca_txout_init(priv, &param->aca_txout);
aca_rxout_init(priv, &param->aca_rxout);
aca_rxin_init(priv, &param->aca_rxin);
aca_hif_param_init_done(priv);
aca_mdm_init(priv, mdm);
#ifdef CONFIG_SOC_TYPE_XWAY
aca_grx330_init(priv);
#endif
aca->initialized = true;
dev_info(priv->dev, "aca init done\n");
return 0;
}

The above function is used to initialize the ACA (Atom ACE) HW/FW on boot. It was
only checking some pre-computed values when it failed, i.e., in release builds, it
returned 0; while in debug




NEXT




<s> static int rtcl_838x_set_rate(int clk_idx, const struct rtcl_reg_set *reg)
{
unsigned long irqflags;
/*
* Runtime of this function (including locking)
* CPU: up to 14000 cycles / up to 56 us at 250 MHz (half default speed)
*/
spin_lock_irqsave(&rtcl_ccu->lock, irqflags);
rtcl_838x_sram_set_rate(clk_idx, reg->ctrl0, reg->ctrl1);
spin_unlock_irqrestore(&rtcl_ccu->lock, irqflags);

return 0;
}

The above function is used to set clock divider for each clock of rtcl_ccu

Here, I made the following assumptions on the function for the below analysis

1.  All the global variables in the source code are initialized correctly – The functions rtcl




NEXT




<s> rt305x_esw_set_bc_status(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

esw->bc_storm_protect = val->value.i & RT305X_ESW_GSC_BC_STROM_MASK;

return 0;
}

The above function is used to set the stormprotect field.

And during the regulator probe function the rtc3xx_set_gsc function also set
the stormprotect field by calling the above function

static int rtc305x




NEXT




<s> bool rtl838x_decode_tag(struct p_hdr *h, struct dsa_tag *t)
{
/* cpu_tag[0] is reserved. Fields are off-by-one */
t->reason = h->cpu_tag[4] & 0xf;
t->queue = (h->cpu_tag[1] & 0xe0) >> 5;
t->port = h->cpu_tag[1] & 0x1f;
t->crc_error = t->reason == 13;

pr_debug("Reason: %d\n", t->reason);
if (t->reason != 6) /* NIC_RX_REASON_SPECIAL_TRAP */
t->l2_offloaded = 1;
else
t->l2_offloaded = 0;

return t->l2_offloaded;
}

The above function is used to decode rtl838x tag.</s>




NEXT




<s> rtk_api_ret_t rtk_svlan_servicePort_del(rtk_port_t port)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicSvlanUplinkPortMask(&pmsk)) != RT_ERR_OK)
return retVal;

pmsk = pmsk & ~(1<<rtk_switch_port_L2P_get(port));

if ((retVal = rtl8367c_setAsicSvlanUplinkPortMask(pmsk)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to delete a port from uplink port list. And the API will not do any check upon VLAN tag (eg, SVLAN or CVID or PVID).

This API is not used in rtl8367c in




NEXT




<s> int ssb_get_fallback_sprom(struct ssb_bus *bus, struct ssb_sprom *out)
{
struct ssb_fbs *pos;
u32 pci_bus, pci_dev;

if (bus->bustype != SSB_BUSTYPE_PCI)
return -ENOENT;

pci_bus = bus->host_pci->bus->number;
pci_dev = PCI_SLOT(bus->host_pci->devfn);

list_for_each_entry(pos, &ssb_fbs_list, list) {
if (pos->pci_bus != pci_bus ||
pos->pci_dev != pci_dev)
continue;

if (pos->devid_override)
bus->host_pci->device = pos->sprom.dev_id;

memcpy(out, &pos->sprom, sizeof(struct ssb_sprom));
dev_info(pos->dev, "requested by [%x:%x]",
pos->pci_bus, pos->pci_dev);

return 0;
}

pr_err("unable to fill SPROM for [%x:%x]\n", pci_bus, pci_dev);

return -EINVAL;
}

The above function is used to determine the value for SPROM of a
particular device. If no fallback info has been provided, this will
fall back to look for device entries for the given device id and PCI
bus. If no matching device entry is found




NEXT




<s> ret_t rtl8367c_getAsicCputagPriorityRemapping(rtk_uint32 srcPri, rtk_uint32 *pNewPri)
{
if(srcPri > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_getAsicRegBits(RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_REG(srcPri), RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_MASK(srcPri), pNewPri);
}

The above function is used to query the mapping table of Priority.
If Source Priority can not be found in that table, that function returns RT_ERR_QOS_INT_PRIORITY, and it indicates the following:
- Source Priority exceeds




NEXT




<s> int ctr_rfc3686_aes_set_key (struct crypto_tfm *tfm, const uint8_t *in_key, unsigned int key_len)
{
struct aes_ctx *ctx = crypto_tfm_ctx(tfm);

//printk("ctr_rfc3686_aes_set_key in %s\n", __FILE__);

memcpy(ctx->nonce, in_key + (key_len - CTR_RFC3686_NONCE_SIZE),
CTR_RFC3686_NONCE_SIZE);

key_len -= CTR_RFC3686_NONCE_SIZE; // remove 4 bytes of nonce

if (key_len != 16 && key_len != 24 && key_len != 32) {
return -EINVAL;
}

ctx->key_length = key_len;
ctx->use_tweak = 0;

memcpy ((u8 *) (ctx->buf), in_key, key_len);

return 0;
}

The above function is used to configure the IV that is to include the nonce as discussed earlier, and the algorithm identifier information. This function receives the pointer to the key, and nonce and the length of the key in bytes (`key_len`). When the key




NEXT




<s> mt7530_get_port_pvid(struct switch_dev *dev, int port, int *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);

if (port >= MT7530_NUM_PORTS)
return -EINVAL;

*val = mt7530_r32(priv, REG_ESW_PORT_PPBV1(port));
*val &= 0xfff;

return 0;
}

The above function is used to get the current pvid for a specific port. And the function MT7530_ESW_SET_PORT_PVID() used to set the current pvid is defined below:</s>




NEXT




<s> static int espi_xfer(struct fsl_spi *fsl, const struct spi_transfer *msg, int n)
{
ccsr_espi_t *espi = fsl->espi;
size_t len = spi_message_len(msg, n);

if (len > ESPI_MAX_DATA_TRANSFER_LEN)
return -1;

/* clear the RXCNT and TXCNT */
out_be32(&espi->mode, in_be32(&espi->mode) & (~ESPI_MODE_EN));
out_be32(&espi->mode, in_be32(&espi->mode) | ESPI_MODE_EN);
out_be32(&espi->com, ESPI_COM_CS(fsl->cs) | ESPI_COM_TRANLEN(len - 1));

int last_msg = n - 1;
int tx_msg = -1, rx_msg = -1;
size_t tx_len = 0, rx_len = 0, tx_pos = 0, rx_pos = 0;

while (true) {
if (tx_pos == tx_len && tx_msg < last_msg) {
tx_msg++;
tx_pos = 0;
tx_len = msg[tx_msg].len;
}
if (rx_pos == rx_len && rx_msg < last_msg) {
rx_msg++;
rx_pos = 0;
rx_len = msg[rx_msg].len;
}
if (rx_pos == rx_len)
break;

const uint8_t *tx_buf = msg[tx_msg].tx_buf;
uint8_t *rx_buf = msg[rx_msg].rx_buf;

uint32_t event = in_be32(&espi->event);

/* TX */
if ((event & ESPI_EV_TNF) && tx_len > 0) {
uint8_t v = 0;
if (tx_buf)
v = tx_buf[tx_pos];
out_8((uint8_t *)&espi->tx, v);
tx_pos++;
}

/* RX */
if (event & ESPI_EV_RNE) {
uint8_t v = in_8((uint8_t *)&espi->rx);
if (rx_buf)
rx_buf[rx_pos] = v;
rx_pos++;
}
}

return 0;
}

The above function is used to implement the transmission (XFR) of spi data. Before the XFR, the control register should be configured according to the following picture. This article will briefly explain the settings.

First set cs0 and cs1 to 1 and




NEXT




<s> static u32 fe_get_msglevel(struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);

return priv->msg_enable;
}

The above function is used to return the message level from
the private structure. In the private struct, the value of the
variable is defaulted to 0. This is done because every message
is printed by default. Hence if the message level set to 0,




NEXT




<s> void hexdump1(unsigned char *buf, unsigned int len)
{
print_hex_dump(KERN_CONT, "", DUMP_PREFIX_OFFSET,
16, 1,
buf, len, false);
}

The above function is used to dump some data from kernel buffer.

It has been used to dump 16 bytes of data. When buffer size is bigger than 16, the

data will be displayed like following as I know (maybe not). For example




NEXT




<s> static int bcma_fbs_probe(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct device_node *node = dev->of_node;
struct bcma_fbs *priv;
unsigned long flags;
u8 mac[ETH_ALEN];

priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
if (!priv)
return -ENOMEM;

priv->dev = dev;

bcma_fbs_set(priv, node);

of_property_read_u32(node, "pci-bus", &priv->pci_bus);
of_property_read_u32(node, "pci-dev", &priv->pci_dev);

of_get_mac_address(node, mac);
if (is_valid_ether_addr(mac)) {
dev_info(dev, "mtd mac %pM\n", mac);
} else {
eth_random_addr(mac);
dev_info(dev, "random mac %pM\n", mac);
}

memcpy(priv->sprom.il0mac, mac, ETH_ALEN);
memcpy(priv->sprom.et0mac, mac, ETH_ALEN);
memcpy(priv->sprom.et1mac, mac, ETH_ALEN);
memcpy(priv->sprom.et2mac, mac, ETH_ALEN);

spin_lock_irqsave(&bcma_fbs_lock, flags);
list_add(&priv->list, &bcma_fbs_list);
spin_unlock_irqrestore(&bcma_fbs_lock, flags);

dev_info(dev, "registered SPROM for [%x:%x]\n",
priv->pci_bus, priv->pci_dev);

return 0;
}

The above function is used to probe for the SPROM device.</s>




NEXT




<s> ret_t rtl8367c_setAsicStormFilterMulticastEnable(rtk_uint32 port, rtk_uint32 enabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_STORM_MCAST_REG, port, enabled);
}

The above function is used to set the multicast setting of the Storm filter. The function only set the bit of the port specified by the port parameter.

The following shows how to set all ports of the Storm filter to disable multicast.

ret_




NEXT




<s> char * nvram_find_mtd(void)
{
FILE *fp;
int i, part_size;
char dev[PATH_MAX];
char *path = NULL;
struct stat s;

if ((fp = fopen("/proc/mtd", "r")))
{
while( fgets(dev, sizeof(dev), fp) )
{
if( strstr(dev, "nvram") && sscanf(dev, "mtd%d: %08x", &i, &part_size) )
{
nvram_part_size = part_size;

sprintf(dev, "/dev/mtdblock%d", i);
if( stat(dev, &s) > -1 && (s.st_mode & S_IFBLK) )
{
if( (path = (char *) malloc(strlen(dev)+1)) != NULL )
{
strncpy(path, dev, strlen(dev)+1);
break;
}
}
}
}
fclose(fp);
}

return path;
}

The above function is used to find out the name of device where nvram image is placed.

Below image shows the implementation of NVRAM,

#include<fcntl.h>

#include <sys/types.h>






NEXT




<s> static int aca_soc_desc_free(int dev)
{
dma_addr_t phy_addr;
void *base;
size_t size;

if (dev < 0 || dev > (DC_EP_MAX_PEER + 1))
return -EINVAL;

/* TXIN */
base = aca_soc_hd_desc[dev].txin.base;
phy_addr = aca_soc_hd_desc[dev].txin.phy_base;
size = aca_soc_hd_desc[dev].txin.size;
dma_free_coherent(NULL, size, base, phy_addr);

/* TXOUT */
base = aca_soc_hd_desc[dev].txout.base;
phy_addr = aca_soc_hd_desc[dev].txout.phy_base;
size = aca_soc_hd_desc[dev].txout.size;
dma_free_coherent(NULL, size, base, phy_addr);

/* RXOUT */
base = aca_soc_hd_desc[dev].rxout.base;
phy_addr = aca_soc_hd_desc[dev].rxout.phy_base;
size = aca_soc_hd_desc[dev].rxout.size;
dma_free_coherent(NULL, size, base, phy_addr);
return 0;
}

The above function is used to allocate memory for the descriptor ring of an ACA device.
When an ACA device is created, it must first be opened and the necessary resources must be allocated.  This
function performs these tasks.

The function takes the following parameters




NEXT




<s> static void ar934x_nfc_send_erase(struct ar934x_nfc *nfc, unsigned command,
int column, int page_addr)
{
u32 addr0, addr1;
u32 ctrl_reg;
u32 cmd_reg;

ar934x_nfc_get_addr(nfc, column, page_addr, &addr0, &addr1);

ctrl_reg = nfc->ctrl_reg;
if (nfc->small_page) {
/* override number of address cycles for the erase command */
ctrl_reg &= ~(AR934X_NFC_CTRL_ADDR_CYCLE0_M <<
AR934X_NFC_CTRL_ADDR_CYCLE0_S);
ctrl_reg &= ~(AR934X_NFC_CTRL_ADDR_CYCLE1_M <<
AR934X_NFC_CTRL_ADDR_CYCLE1_S);
ctrl_reg &= ~(AR934X_NFC_CTRL_SMALL_PAGE);
ctrl_reg |= (nfc->addr_count0 + 1) <<
AR934X_NFC_CTRL_ADDR_CYCLE0_S;
}

cmd_reg = NAND_CMD_ERASE1 << AR934X_NFC_CMD_CMD0_S;
cmd_reg |= command << AR934X_NFC_CMD_CMD1_S;
cmd_reg |= AR934X_NFC_CMD_SEQ_ERASE;

nfc_dbg(nfc, "erase page %d, a0:%08x a1:%08x cmd:%08x ctrl:%08x\n",
page_addr, addr0, addr1, cmd_reg, ctrl_reg);

ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, ctrl_reg);
ar934x_nfc_wr(nfc, AR934X_NFC_REG_ADDR0_0, addr0);
ar934x_nfc_wr(nfc, AR934X_NFC_REG_ADDR0_1, addr1);

ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
ar934x_nfc_wait_dev_ready(nfc);
}

The above function is used to send erase command to the NAND driver.

Here is the function I used to verify if this command was working by
comparing the checksum and the calculated checksum on a raw file.

static int verify_rawfile




NEXT




<s> void put_array(const void *p, size_t l)
{
const uint8_t *c = p;
size_t i;
for (i = 0; i < l; i++) {
put_u8(c[i]);
putchar(' ');
}
putchar('\n');
}

The above function is used to display an array in octal number, and putchar('\n') is used to make the data output onto a separate line.

However, I want to put all the data into one line.
How to make putchar('\n')




NEXT




<s> static int b53_srab_write64(struct b53_device *dev, u8 page, u8 reg,
u64 value)
{
u8 __iomem *regs = dev->priv;
int ret = 0;

ret = b53_srab_request_grant(dev);
if (ret)
goto err;

writel((u32)value, regs + B53_SRAB_WD_L);
writel((u32)(value >> 32), regs + B53_SRAB_WD_H);

ret = b53_srab_op(dev, page, reg, B53_SRAB_CMDSTAT_WRITE);

err:
b53_srab_release_grant(dev);

return ret;
}

The above function is used to store a 64 bit integer, which is just 16 bytes in
length, a small amount. This function does very little, it performs a BAR
request to obtain access to the device specific registers, and then writes the





NEXT




<s> void rtl930x_traffic_set(int source, u64 dest_matrix)
{
struct table_reg *r = rtl_table_get(RTL9300_TBL_0, 6);

sw_w32((dest_matrix << 3), rtl_table_data(r, 0));
rtl_table_write(r, source);
rtl_table_release(r);
}

The above function is used to set the traffic matrix. The rtl930x driver has only one way to handle the traffic matrix. All the traffic to destination "dest_matrix" will be sent to source "source".

Note the first parameter is an integer




NEXT




<s> static int rtl83xx_port_bridge_flags(struct dsa_switch *ds, int port, struct switchdev_brport_flags flags, struct netlink_ext_ack *extack)
{
struct rtl838x_switch_priv *priv = ds->priv;

pr_debug("%s: %d %lX\n", __func__, port, flags.val);
if (priv->r->enable_learning && (flags.mask & BR_LEARNING))
priv->r->enable_learning(port, !!(flags.val & BR_LEARNING));

if (priv->r->enable_flood && (flags.mask & BR_FLOOD))
priv->r->enable_flood(port, !!(flags.val & BR_FLOOD));

if (priv->r->enable_mcast_flood && (flags.mask & BR_MCAST_FLOOD))
priv->r->enable_mcast_flood(port, !!(flags.val & BR_MCAST_FLOOD));

if (priv->r->enable_bcast_flood && (flags.mask & BR_BCAST_FLOOD))
priv->r->enable_bcast_flood(port, !!(flags.val & BR_BCAST_FLOOD));

return 0;
}

The above function is used to set different type of flags on specific port, currently we just set the enable_flood and enable_learning for all the port. Please note the enable_flood and enable_learning are in the rtl838x-




NEXT




<s> static AT91S_DataFlashStatus AT91F_DataFlashWriteBuffer(
AT91PS_DataFlash pDataFlash,
unsigned char BufferCommand,
unsigned char *dataBuffer,
unsigned int bufferAddress,
int SizeToWrite )
{
int cmdsize;
/* Test if the buffer command is legal */
if ((BufferCommand != DB_BUF1_WRITE) && (BufferCommand != DB_BUF2_WRITE))
return AT91C_DATAFLASH_BAD_COMMAND;

/* buffer address must be lower than page size */
if (bufferAddress > pDataFlash->pDevice->pages_size)
return AT91C_DATAFLASH_BAD_ADDRESS;

/* Send first Write Command */
pDataFlash->pDataFlashDesc->command[0] = BufferCommand;
pDataFlash->pDataFlashDesc->command[1] = 0;
if (pDataFlash->pDevice->pages_number >= 16384)
{
pDataFlash->pDataFlashDesc->command[2] = 0;
pDataFlash->pDataFlashDesc->command[3] = (unsigned char)(((unsigned int)(bufferAddress &  pDataFlash->pDevice->byte_mask)) >> 8) ;
pDataFlash->pDataFlashDesc->command[4] = (unsigned char)((unsigned int)bufferAddress  & 0x00FF) ;
cmdsize = 5;
}
else
{
pDataFlash->pDataFlashDesc->command[2] = (unsigned char)(((unsigned int)(bufferAddress &  pDataFlash->pDevice->byte_mask)) >> 8) ;
pDataFlash->pDataFlashDesc->command[3] = (unsigned char)((unsigned int)bufferAddress  & 0x00FF) ;
pDataFlash->pDataFlashDesc->command[4] = 0;
cmdsize = 4;
}

pDataFlash->pDataFlashDesc->tx_cmd_pt 	 = pDataFlash->pDataFlashDesc->command ;
pDataFlash->pDataFlashDesc->tx_cmd_size  = cmdsize ;
pDataFlash->pDataFlashDesc->rx_cmd_pt 	 = pDataFlash->pDataFlashDesc->command ;
pDataFlash->pDataFlashDesc->rx_cmd_size  = cmdsize ;

pDataFlash->pDataFlashDesc->rx_data_pt 	 = dataBuffer ;
pDataFlash->pDataFlashDesc->tx_data_pt 	 = dataBuffer ;
pDataFlash->pDataFlashDesc->rx_data_size = SizeToWrite ;
pDataFlash->pDataFlashDesc->tx_data_size = SizeToWrite ;

return AT91F_SpiWrite(pDataFlash->pDataFlashDesc);
}

The above function is used to perform a multiple byte write to the DataFlash. The
function is called by the following code fragment found in at91sam9r3.c:

AT91S_DataFlashStatus AT91F_Data




NEXT




<s> rtl8306_remove(struct phy_device *pdev)
{
struct rtl_priv *priv = pdev->priv;
unregister_switch(&priv->dev);
kfree(priv);
}

The above function is used to unregister a switch interface. Can this unregister function be added to the RTL8305E switch driver? It is currently only used in the RTL8306E switch driver. Also, I know that the above function




NEXT




<s> ret_t rtl8367c_getAsicRldpLeaveLoopedPortmask(rtk_uint32 *pPortmask)
{
return rtl8367c_getAsicReg(RTL8367C_REG_RLDP_RELEASED_INDICATOR, pPortmask);
}

The above function is used to read the RLDP RELEASED INDICATOR Register, and will return a value indicating whether or not the current link has detected that an upstream port has released its RLDP loop.

ret_t rtl83




NEXT




<s> static void rttm_setup_timer(void __iomem *base)
{
RTTM_DEBUG(base);
rttm_stop_timer(base);
rttm_set_period(base, 0);
}

The above function is used to switch off all rttm timers in the system.

If the rttm timer period is 0 which will also disable all
other rttms except the following:

[*]
The PWM driver with its




NEXT




<s> rtk_api_ret_t rtk_i2c_init(void)
{
rtk_uint32 retVal;
switch_chip_t ChipID;
/* probe switch */
if((retVal = rtk_switch_probe(&ChipID)) != RT_ERR_OK)
return retVal;

if( ChipID == CHIP_RTL8370B )
{
/*set GPIO8, GPIO9, OpenDrain as I2C, clock = 252KHZ   */
if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, 0x5c3f)) != RT_ERR_OK)
return retVal;
}
else
return RT_ERR_FAILED;
return  RT_ERR_OK;
}

The above function is used to set GPIO8, GPIO9 and OpenDrain as I2C for RTL8370B, in fact on RTL8190F there are only 2 I2C pins(GPIO6 and GPIO7).




NEXT




<s> static void aca_dma_port_init(struct dc_ep_priv *priv)
{
u32 val;

/* Only one port /port 0 */
wr32(0, ADMA_PS);
val = rd32(ADMA_PCTRL);
set_mask_bit(val, 1, 1, PCTRL_RXBL16);
set_mask_bit(val, 1, 1, PCTRL_TXBL16);
set_mask_bit(val, 0, 3, PCTRL_RXBL);
set_mask_bit(val, 0, 3, PCTRL_TXBL);

set_mask_bit(val, 0, 3, PCTRL_TXENDI);
set_mask_bit(val, 0, 3, PCTRL_RXENDI);
wr32(val, ADMA_PCTRL);
}

The above function is used to set the ACA DMA port characteristics, the function has 2 parameters, the first one is the address of structure of dc_ep_priv, the second parameter is the type of port 0 or 1, which is 0.





NEXT




<s> static inline void esw_rmw_raw(struct rt305x_esw *esw, unsigned reg,
unsigned long mask, unsigned long val)
{
unsigned long t;

t = __raw_readl(esw->base + reg) & ~mask;
__raw_writel(t | val, esw->base + reg);
}

The above function is used to implement the read modify write
functionality of the eeprom on the Ralink RT305x SOC. This
function is also used to modify any global register on the
RT305x.

It can




NEXT




<s> static int b53_mdio_read8(struct b53_device *dev, u8 page, u8 reg, u8 *val)
{
struct mii_bus *bus = dev->priv;
int ret;

ret = b53_mdio_op(dev, page, reg, REG_MII_ADDR_READ);
if (ret)
return ret;

*val = mdiobus_read(bus, B53_PSEUDO_PHY, REG_MII_DATA0) & 0xff;

return 0;
}

The above function is used to read 8 bits of data from the MII bus. The struct mii_bus *bus is pointed to by the dev->priv variable. The struct mii_bus object is required when accessing the MII bus.







NEXT




<s> rtk_api_ret_t rtk_ptp_mac_get(rtk_mac_t *pMac)
{
rtk_api_ret_t retVal;
ether_addr_t sw_mac;

if((retVal=rtl8367c_getAsicEavMacAddress(&sw_mac))!=RT_ERR_OK)
return retVal;

memcpy(pMac->octet, sw_mac.octet, ETHER_ADDR_LEN);

return RT_ERR_OK;
}

The above function is used to retrieve the hardware MAC address.

What about setting a custom MAC address, however? After a bunch of trial and error I came up with the following function:

rtk_api_ret_t setMacAddress(unsigned char *




NEXT




<s> static bool rtl931x_pie_templ_has(int t, enum template_field_id field_type)
{
for (int i = 0; i < N_FIXED_FIELDS_RTL931X; i++) {
enum template_field_id ft = fixed_templates[t][i];
if (field_type == ft)
return true;
}

return false;
}

The above function is used to check the given Template ID in the fixed_templates array (for the rtl931x module) if it contains the given field_typ.

I modified the function as:

static bool rtl931x_




NEXT




<s> static u64 rtl931x_l2_hash_seed(u64 mac, u32 vid)
{
u64 v = vid;

v <<= 48;
v |= mac;

return v;
}

The above function is used to determine the hash value of a given MAC and VID (if necessary). Since the RTL931X only supports a single Hash table, it is necessary that all possible values hash out to the same bucket/slot in the table. This




NEXT




<s> void spl_block_load_image(void)
{
int err;
block_dev_desc_t * device;

device = spl_get_block_device();
#ifdef CONFIG_SPL_OS_BOOT
if (spl_start_uboot() || block_load_image_raw_os(device))
#endif
{
err = block_load_image_raw(device,
CONFIG_SYS_BLOCK_RAW_MODE_U_BOOT_SECTOR);
if (err)
hang();
}
}

The above function is used to load image from block device. For testing, image to be loaded should be appended starting from the u_boot_sector. Below is the command used.

# cd /boot/uboot

# hexdump -v




NEXT




<s> static void phy_init(struct fe_priv *priv, struct phy_device *phy)
{
phy_attach(priv->netdev, dev_name(&phy->mdio.dev), PHY_INTERFACE_MODE_MII);

phy->autoneg = AUTONEG_ENABLE;
phy->speed = 0;
phy->duplex = 0;

phy_set_max_speed(phy, IS_ENABLED(CONFIG_NET_RALINK_MDIO_MT7620) ?
SPEED_1000 :
SPEED_100);
linkmode_copy(phy->advertising, phy->supported);
linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phy->advertising);

phy_start_aneg(phy);
}

The above function is used to initialize the PHY device. Once the function
is executed, the phy device is fully enabled.

In the code where the phy is first created, the phy is not enabled yet.
Instead, a dummy device node




NEXT




<s> static int rtl8366rb_sw_reset_mibs(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);

return rtl8366_smi_rmwr(smi, RTL8366RB_MIB_CTRL_REG, 0,
RTL8366RB_MIB_CTRL_GLOBAL_RESET);
}

The above function is used to reset some counters in the MIBUs (Management
Information Bases).

The smi_rmwr() function looks like:

int rtl8366_smi_rmwr(struct rtl83




NEXT




<s> static void rtl930x_pie_lookup_enable(struct rtl838x_switch_priv *priv, int index)
{
int block = index / PIE_BLOCK_SIZE;

sw_w32_mask(0, BIT(block), RTL930X_PIE_BLK_LOOKUP_CTRL);
}

The above function is used to enable PIE lookup table. The parameter index is used to identify which PIE lookup table to use; index is an integer value from 0 to 127. When index is 0, PIE block 0 is used, when




NEXT




<s> send_command(const char *command)
{
struct ead_msg_cmd *cmd = EAD_ENC_DATA(msg, cmd);

msg->type = htonl(EAD_TYPE_SEND_CMD);
cmd->type = htons(EAD_CMD_NORMAL);
cmd->timeout = htons(10);
strncpy((char *)cmd->data, command, 1024);
ead_encrypt_message(msg, sizeof(struct ead_msg_cmd) + strlen(command) + 1);
return send_packet(EAD_TYPE_RESULT_CMD, handle_cmd_data, 1);
}

The above function is used to send a command, the EAD_TYPE_SEND_CMD</s>




NEXT




<s> static void ppe_rxout_send(struct dc_ep_dev *dev,
u8 __iomem *ppe_sb_base, int num)
{
int i;
struct aca_dma_desc_2dw desc;

memset(&desc, 0, sizeof(desc));
desc.status.field.own = 0;
desc.status.field.sop = 1;
desc.status.field.eop = 1;
desc.status.field.meta_data0 = 0x3;
desc.status.field.meta_data1 = 0x7f;
desc.status.field.data_len = 127;
desc.data_pointer = 0x26200000;

for (i = 0; i < num; i++) {
desc.data_pointer += roundup(desc.status.field.data_len, 4);
ep_mem_write(ppe_sb_base + i * sizeof(desc),
(void *)&desc, sizeof(desc));
}

ep_wr32(num, RXOUT_ACA_ACCUM_ADD);
}

The above function is used to send packets out of the ppe to the sw.

I think the ppe does the following:

1. Increment the accum_add register (which is part of the PPE).
2. Increment the rx_




NEXT




<s> add_switch(struct nl_msg *msg, void *arg)
{
struct swlib_scan_arg *sa = arg;
struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
struct switch_dev *dev;
const char *name;
const char *alias;

if (nla_parse(tb, SWITCH_ATTR_MAX, genlmsg_attrdata(gnlh, 0), genlmsg_attrlen(gnlh, 0), NULL) < 0)
goto done;

if (!tb[SWITCH_ATTR_DEV_NAME])
goto done;

name = nla_get_string(tb[SWITCH_ATTR_DEV_NAME]);
alias = nla_get_string(tb[SWITCH_ATTR_ALIAS]);

if (sa->name && (strcmp(name, sa->name) != 0) && (strcmp(alias, sa->name) != 0))
goto done;

dev = swlib_alloc(sizeof(struct switch_dev));
if (!dev)
goto done;

strncpy(dev->dev_name, name, IFNAMSIZ - 1);
dev->alias = strdup(alias);
if (tb[SWITCH_ATTR_ID])
dev->id = nla_get_u32(tb[SWITCH_ATTR_ID]);
if (tb[SWITCH_ATTR_NAME])
dev->name = strdup(nla_get_string(tb[SWITCH_ATTR_NAME]));
if (tb[SWITCH_ATTR_PORTS])
dev->ports = nla_get_u32(tb[SWITCH_ATTR_PORTS]);
if (tb[SWITCH_ATTR_VLANS])
dev->vlans = nla_get_u32(tb[SWITCH_ATTR_VLANS]);
if (tb[SWITCH_ATTR_CPU_PORT])
dev->cpu_port = nla_get_u32(tb[SWITCH_ATTR_CPU_PORT]);
if (tb[SWITCH_ATTR_PORTMAP])
add_port_map(dev, tb[SWITCH_ATTR_PORTMAP]);

if (!sa->head) {
sa->head = dev;
sa->ptr = dev;
} else {
sa->ptr->next = dev;
sa->ptr = dev;
}

refcount++;
done:
return NL_SKIP;
}

The above function is used to scan and add in the newly added switch information in to the scan table. This function uses the below NL_MSG.

nl_send_msg(struct nl_msg *msg, int to)
nl_parse(struct nl_




NEXT




<s> ssize_t routerboot_tag_show_u32s(const u8 *pld, u16 pld_len, char *buf)
{
char *out = buf;
u32 *data;	// cpu-endian

/* Caller ensures pld_len > 0 */
if (pld_len % sizeof(*data))
return -EINVAL;

data = (u32 *)pld;

do {
out += sprintf(out, "0x%08x\n", *data);
data++;
} while ((pld_len -= sizeof(*data)));

return out - buf;
}

The above function is used to print out the values of every u32 in pld.

So, the problem is, it seems that router-boot.S is miscalculating pld_len to 48 bytes when sending a msg, while router




NEXT




<s> void rtk_hal_qos_get_queue_weight(struct ra_switch_ioctl_data *data)
{
int i;
rtk_api_ret_t ret;
rtk_qos_queue_weights_t qweights;

ret = rtk_qos_schedulingQueue_get(data->port, &qweights);
if (ret != 0)
printk("rtk_qos_schedulingQueue_get failed\n");
else {
printk("=== Port%d queue weight ===\n", data->port);
for (i = 0; i < 8; i++)
printk("qweights.weights[%d] = %d\n",i ,qweights.weights[i]);
}
}

The above function is used to print the weights for all the 8 queues.</s>




NEXT




<s> static void __exit dc_ep_test_exit(void)
{
int i;
int dev_num;
u32 func = ACA_ALL_EN;
struct dc_ep_dev *dev;

if (dc_ep_dev_num_get(&dev_num)) {
pr_err("%s failed to get total device number\n", __func__);
return;
}
pr_info("%s: total %d EPs found\n", __func__, dev_num);
for (i = 0; i < dev_num; i++) {
dev = &pcie_dev[i];
free_irq(dev->irq, dev);
dev->hw_ops->aca_stop(dev, &func, 1);
dev->hw_ops->clk_off(dev, PMU_EMA);
if (dc_ep_dev_info_release(i)) {
pr_info("%s failed to release pcie ep %d information\n",
__func__, i);
}
aca_soc_desc_free(i);
}
}

The above function is used to free resources required to test PMA and ACA
functions.

Drivers/net/dma/ac_accel_dma.c --
dc_ep_test_prepare(struct device_driver *ddri);





NEXT




<s> ret_t rtl8367c_setAsicIGMPv1Opeartion(rtk_uint32 port, rtk_uint32 igmpv1_op)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(igmpv1_op >= PROTOCOL_OP_END)
return RT_ERR_INPUT;

/* IGMPv1 operation */
if(port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV1_OP_MASK, igmpv1_op);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV1_OP_MASK, igmpv1_op);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set the IGMP v1 operation. If a value is invalid, the return code is RT_ERR_INVALID.

Apart from the above function, all IGMP related functions are almost same as SSDT_IGMP




NEXT




<s> static int qca807x_read_fiber_status(struct phy_device *phydev)
{
int ss, err, lpa, old_link = phydev->link;

/* Update the link, but return if there was an error */
err = genphy_update_link(phydev);
if (err)
return err;

/* why bother the PHY if nothing can have changed */
if (phydev->autoneg == AUTONEG_ENABLE && old_link && phydev->link)
return 0;

phydev->speed = SPEED_UNKNOWN;
phydev->duplex = DUPLEX_UNKNOWN;
phydev->pause = 0;
phydev->asym_pause = 0;

if (phydev->autoneg == AUTONEG_ENABLE && phydev->autoneg_complete) {
lpa = phy_read(phydev, MII_LPA);
if (lpa < 0)
return lpa;

linkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
phydev->lp_advertising, lpa & LPA_LPACK);
linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,
phydev->lp_advertising, lpa & LPA_1000XFULL);
linkmode_mod_bit(ETHTOOL_LINK_MODE_Pause_BIT,
phydev->lp_advertising, lpa & LPA_1000XPAUSE);
linkmode_mod_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
phydev->lp_advertising,
lpa & LPA_1000XPAUSE_ASYM);

phy_resolve_aneg_linkmode(phydev);
}

/* Read the QCA807x PHY-Specific Status register fiber page,
* which indicates the speed and duplex that the PHY is actually
* using, irrespective of whether we are in autoneg mode or not.
*/
ss = phy_read(phydev, QCA807X_PHY_SPECIFIC_STATUS);
if (ss < 0)
return ss;

if (ss & QCA807X_SS_SPEED_AND_DUPLEX_RESOLVED) {
switch (FIELD_GET(QCA807X_SS_SPEED_MASK, ss)) {
case QCA807X_SS_SPEED_100:
phydev->speed = SPEED_100;
break;
case QCA807X_SS_SPEED_1000:
phydev->speed = SPEED_1000;
break;
}

if (ss & QCA807X_SS_DUPLEX)
phydev->duplex = DUPLEX_FULL;
else
phydev->duplex = DUPLEX_HALF;
}

return 0;
}

The above function is used to report fiber status to
the upper layer when the QCA807x PHY is in operation.

To ensure that, we can enable it from the Linux mainline
by modifying qca807x_phy.




NEXT




<s> static bool nmbm_search_info_table(struct nmbm_instance *ni, uint32_t ba,
uint32_t limit, uint32_t *table_start_ba,
uint32_t *table_end_ba,
uint32_t *write_count,
uint32_t *mapping_blocks_top_ba,
bool table_loaded)
{
bool success;

while (ba < limit - size2blk(ni, ni->info_table_size)) {
success = nmbm_try_load_info_table(ni, ba, table_end_ba,
write_count,
mapping_blocks_top_ba,
table_loaded);
if (success) {
*table_start_ba = ba;
return true;
}

ba++;
}

return false;
}

The above function is used to search for the infotable of a given
BA address. The information contained in the information
structure includes:

1.  the offset of the infotable with respect to the first block

2.  the size of the




NEXT




<s> rtk_api_ret_t rtk_dot1x_portBasedAuthStatus_get(rtk_port_t port, rtk_dot1x_auth_status_t *pPort_auth)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPort_auth)
return RT_ERR_NULL_POINTER;

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsic1xPBAuthConfig(rtk_switch_port_L2P_get(port), pPort_auth)) != RT_ERR_OK)
return retVal;
return RT_ERR_OK;
}

The above function is used to read portBasedAuthStatus which defined at dot1x_port_st.h.

## Description

This function reads the specified port based auth status.

## Parameters

@port @arg port is the port id.




NEXT




<s> int rtl8366_sw_set_vlan_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
int err;

if (attr->ofs > 2)
return -EINVAL;

if (attr->ofs == 1)
err = rtl8366_smi_enable_vlan(smi, val->value.i);
else
err = rtl8366_smi_enable_vlan4k(smi, val->value.i);

return err;
}

The above function is used to set "enable" field in SMI Vlan struct. Enable is a one-bit field used to indicate whether or not the port is a Vlan enabled port. If 1, the corresponding port is to be enabled. If 0,




NEXT




<s> module_init(ar8216_init);

static void __exit ar8216_exit(void)
{
mdio_driver_unregister(&ar8xxx_mdio_driver);
phy_drivers_unregister(ar8xxx_phy_driver,
ARRAY_SIZE(ar8xxx_phy_driver));
}

The above function is used to clean up when the module that contains it
is removed.


mdio_driver_unregister, phy_drivers_unregister

I wonder why these drivers are not being used anymore.


MD010




NEXT




<s> ret_t rtl8367c_getAsicIGMPLeaveRX(rtk_uint32 port, rtk_uint32 *allow_leave)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
{
/* Allow Leave */
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_LEAVE_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_LEAVE_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}

*allow_leave = value;

return RT_ERR_OK;
}

The above function is used to get the MCAST allow leave status from PROMISCUOUS port which is used by the MCAST leave
macro.

The following are the changes to be made in the MCAST member of the VLAN table which will be




NEXT




<s> static void aca_dma_ch_off(struct dc_ep_priv *priv)
{
int i;
struct dc_aca *aca = to_aca(priv);

/* Shared between OS and ACA FW. Stop ACA first */
for (i = 0; i < aca->adma_chans; i++) {
wr32(i, ADMA_CS);
wr32_mask(BIT(CCTRL_ONOFF), 0, ADMA_CCTRL);
while (rd32(ADMA_CCTRL) & BIT(CCTRL_ONOFF))
;
}
dev_dbg(priv->dev, "aca dma channel done\n");
}

The above function is used to stop ACANODE channels. In the code I
wanted to check whether we already stopped the channel. There's no
clean way to do this, since the "onoff" bit gets cleared only if
"run" bit




NEXT




<s> static inline void ag71xx_dump_intr(struct ag71xx *ag, char *label, u32 intr)
{
DBG("%s: %s intr=%08x %s%s%s%s%s%s\n",
ag->dev->name, label, intr,
(intr & AG71XX_INT_TX_PS) ? "TXPS " : "",
(intr & AG71XX_INT_TX_UR) ? "TXUR " : "",
(intr & AG71XX_INT_TX_BE) ? "TXBE " : "",
(intr & AG71XX_INT_RX_PR) ? "RXPR " : "",
(intr & AG71XX_INT_RX_OF) ? "RXOF " : "",
(intr & AG71XX_INT_RX_BE) ? "RXBE " : "");
}

The above function is used to display interrupt info of the adapter, it is called when
interrupt handler(ag71xx_handle_interrupt) is called to display the interrupts happened on the device.
To debug interrupt of the adapter, I copied the ag71




NEXT




<s> ret_t rtl8367c_setAsicAprEnable(rtk_uint32 port, rtk_uint32 aprEnable)
{
ret_t retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

retVal = rtl8367c_setAsicRegBit(RTL8367C_SCHEDULE_APR_CTRL_REG, RTL8367C_SCHEDULE_APR_CTRL_OFFSET(port), aprEnable);

return retVal;
}

The above function is used to set enable of apr on an port.
There are three kinds of aprs.

- 1. apr0 —- use by cpu port only (only used by cpu port)
- 2. apr1 —- use by




NEXT




<s> static int rtl8366rb_sw_set_mirror_source_port(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

data = RTL8366RB_PMCR_SOURCE_PORT(val->value.i);

return rtl8366_smi_rmwr(smi, RTL8366RB_PMCR, RTL8366RB_PMCR_SOURCE_PORT_MASK, data);
}

The above function is used to set the mirror source port. In
rtl8367rb_sw_set_mirror_source_port function in firmware, it calls this function.

The function was not checked during validation, I didn't




NEXT




<s> rtk_api_ret_t rtk_dot1x_portBasedDirection_get(rtk_port_t port, rtk_dot1x_direction_t *pPort_direction)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPort_direction)
return RT_ERR_NULL_POINTER;

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsic1xPBOpdirConfig(rtk_switch_port_L2P_get(port), pPort_direction)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the dot1x port direction.

Example:

rtk_dot1x_portBasedDirection_set(RTK_PORT0,RTK_STD_802_1X_PORT_TO_




NEXT




<s> extern void ltq_mask_and_ack_irq(struct irq_data *d);
static void inline MEI_MASK_AND_ACK_IRQ(int x)
{
struct irq_data d;
d.hwirq = x;
ltq_mask_and_ack_irq(&d);
}

The above function is used to clear all pending interrupts on an
interrupt line.

# Why not use it?

Consider the following C code:

MEI_MASK_AND_ACK_IRQ(irq); // some_other_function();




NEXT




<s> ret_t rtl8367c_setAsicFlowControlPortPrivateThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_PORT_PRIVATE_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_PORT_PRIVATE_ON_MASK, onThreshold);

return retVal;
}

The above function is used to write onThreshold and offThreshold values to the bits of the RTL8367C_FLOWCTRL_PORT_PRIVATE_ON and RTL8367C_FLOWCTRL_PORT_PRIVATE_OFF registers




NEXT




<s> swconfig_get_pvid(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
if (val->port_vlan >= dev->ports)
return -EINVAL;

if (!dev->ops->get_port_pvid)
return -EOPNOTSUPP;

return dev->ops->get_port_pvid(dev, val->port_vlan, &val->value.i);
}

The above function is used to get PVID of the
specified pval.

swconfig_set_port_trunk(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{





NEXT




<s> static void rtl930x_set_l3_router_mac(u32 idx, struct rtl93xx_rt_mac *m)
{
u32 v, w;
/* Read L3_ROUTER_MAC table (0) via register RTL9300_TBL_1 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_1, 0);

/* The table has a size of 7 registers, 64 entries */
v = BIT(20); /* mac entry valid, port type is 0: individual */
v |= (m->p_id & 0x3f) << 13;
v |= (m->vid & 0xfff); /* Set the interface_id to the vlan id */

w = m->vid_mask;
w |= (m->p_id_mask & 0x3f) << 13;

sw_w32(v, rtl_table_data(r, 0));
sw_w32(w, rtl_table_data(r, 3));

/* Set MAC address, L3_INTF (bit 12 in register 1) needs to be 0 */
sw_w32((u32)(m->mac), rtl_table_data(r, 2));
sw_w32(m->mac >> 32, rtl_table_data(r, 1));

/* Set MAC address mask, BMSK_L3_INTF (bit 12 in register 5) needs to be 0 */
sw_w32((u32)(m->mac_mask >> 32), rtl_table_data(r, 4));
sw_w32((u32)m->mac_mask, rtl_table_data(r, 5));

sw_w32(m->action & 0x7, rtl_table_data(r, 6));

pr_debug("%s writing index %d: %08x %08x %08x %08x %08x %08x %08x\n", __func__, idx,
sw_r32(rtl_table_data(r, 0)), sw_r32(rtl_table_data(r, 1)), sw_r32(rtl_table_data(r, 2)),
sw_r32(rtl_table_data(r, 3)), sw_r32(rtl_table_data(r, 4)), sw_r32(rtl_table_data(r, 5)),
sw_r32(rtl_table_data(r, 6))
);
rtl_table_write(r, idx);
rtl_table_release(r);
}

The above function is used to write the L3_route table. Currently it only covers one entry.</s>




NEXT




<s> static int add_byte(int c, char **lineptr, size_t slen, size_t *n)
{
char *nline;
size_t new_size = slen + 1;
if (new_size > *n) {
new_size += LINE_GROWTH - 1;
new_size *= 2;
nline = xrealloc(*lineptr, new_size);
if (!nline)
return -1;

*lineptr = nline;
*n = new_size;
}

(*lineptr)[slen] = c;

return 0;
}

The above function is used to copy strings that we dynamically allocate to an array of size ‘new_size’. One of these strings is a line from an input file in order to be saved to a file that will be used later; see line_to_file().





NEXT




<s> ret_t rtl8367c_getAsicRemarkingDscpSrc(rtk_uint32 *pType)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_RMK_CFG_SEL_CTRL, RTL8367C_RMK_DSCP_CFG_SEL_MASK, pType);
}

The above function is used to retrieve the DSCP Source of Asic Remarking Configuration Settings


typedef enum DSCP_Config_Type
{
    rtl8367c_RmKDscpUdpP4




NEXT




<s> static inline void reset_deassert_device(struct dc_ep_dev *dev, u32 bits)
{
if (WARN_ON(!dev))
return;
if (WARN_ON(!dev->priv))
return;

dc_ep_deassert_device(dev->priv, bits);
}

The above function is used to deassert a device. There are a few different
deassert bits, but those aren't the concern here.

The point is, we want to be able to deassert and reassert a device that was
deasserted by




NEXT




<s> rtk_api_ret_t rtk_port_sgmiiNway_set(rtk_port_t port, rtk_enable_t state)
{
rtk_uint32 ext_id;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
if(rtk_switch_isSgmiiPort(port) != RT_ERR_OK)
return RT_ERR_PORT_ID;

if(state >= RTK_ENABLE_END)
return RT_ERR_INPUT;

ext_id = port - 15;
return rtl8367c_setSgmiiNway(ext_id, (rtk_uint32)state);
}

The above function is used to set SGMII N-way.

<b>Call sequence</b>

rtk_port_sgmiiNway_get()
rtk_port_sgmiiNway_set()

<




NEXT




<s> static inline void rtl839x_exec_tbl0_cmd(u32 cmd)
{
sw_w32(cmd, RTL839X_TBL_ACCESS_CTRL_0);
do { } while (sw_r32(RTL839X_TBL_ACCESS_CTRL_0) & BIT(16));
}

The above function is used to set Tbl0 access ctrl 0. The Tbl0 access ctrl 0
controls the address to which the Tbl0 will be written. The function first
writes the address to the cmd register of the Tbl0 access ctrl




NEXT




<s> static void aca_xbar_ia_reject_set(struct dc_ep_priv *priv, int ia_id)
{
u32 val;
int timeout = 1000;
struct device *dev = priv->dev;

/* Set reject bit */
wr32(XBAR_CTRL_REJECT, ACA_AGENT_CTRL(ia_id));

/* Poll burst, readex, resp_waiting, req_active */
val = XBAR_STAT_REQ_ACTIVE | XBAR_STAT_RESP_WAITING
| XBAR_STAT_BURST | XBAR_STAT_READEX;
while (--timeout && !!(rd32(ACA_AGENT_STATUS(ia_id)) & val))
udelay(1);

if (timeout <= 0) {
dev_dbg(dev,
"ACA XBAR IA: %d reset timeout, pending on 0x%x\n",
ia_id, rd32(ACA_AGENT_STATUS(ia_id)));
return;
}
}

The above function is used to set IA status REJECT, and if the status is still not cleared after 1ms,
it will cause the IA to reset.

Why is the timeout so small? The original value should be 200ms,




NEXT




<s> BIGNUM *BN_mod_inverse(BIGNUM *in, BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
{
BIGNUM *A,*B,*X,*Y,*M,*D,*R=NULL;
BIGNUM *T,*ret=NULL;
int sign;

bn_check_top(a);
bn_check_top(n);

BN_CTX_start(ctx);
A = BN_CTX_get(ctx);
B = BN_CTX_get(ctx);
X = BN_CTX_get(ctx);
D = BN_CTX_get(ctx);
M = BN_CTX_get(ctx);
Y = BN_CTX_get(ctx);
if (Y == NULL) goto err;

if (in == NULL)
R=BN_new();
else
R=in;
if (R == NULL) goto err;

BN_zero(X);
BN_one(Y);
if (BN_copy(A,a) == NULL) goto err;
if (BN_copy(B,n) == NULL) goto err;
sign=1;

while (!BN_is_zero(B))
{
if (!BN_div(D,M,A,B,ctx)) goto err;
T=A;
A=B;
B=M;
/* T has a struct, M does not */

if (!BN_mul(T,D,X,ctx)) goto err;
if (!BN_add(T,T,Y)) goto err;
M=Y;
Y=X;
X=T;
sign= -sign;
}
if (sign < 0)
{
if (!BN_sub(Y,n,Y)) goto err;
}

if (BN_is_one(A))
{ if (!BN_mod(R,Y,n,ctx)) goto err; }
else
{
goto err;
}
ret=R;
err:
if ((ret == NULL) && (in == NULL)) BN_free(R);
BN_CTX_end(ctx);
return(ret);
}

The above function is used to find the **multiplicative inverse****a_mod_n of an integer number **a****modulo n. Let’s assume n is a prime, then **a_mod_n** is also the modular multiplicative inverse




NEXT




<s> draw_box(WINDOW * win, int y, int x, int height, int width,
chtype box, chtype border)
{
int i, j;

wattrset(win, 0);
for (i = 0; i < height; i++) {
wmove(win, y + i, x);
for (j = 0; j < width; j++)
if (!i && !j)
waddch(win, border | ACS_ULCORNER);
else if (i == height - 1 && !j)
waddch(win, border | ACS_LLCORNER);
else if (!i && j == width - 1)
waddch(win, box | ACS_URCORNER);
else if (i == height - 1 && j == width - 1)
waddch(win, box | ACS_LRCORNER);
else if (!i)
waddch(win, border | ACS_HLINE);
else if (i == height - 1)
waddch(win, box | ACS_HLINE);
else if (!j)
waddch(win, border | ACS_VLINE);
else if (j == width - 1)
waddch(win, box | ACS_VLINE);
else
waddch(win, box | ' ');
}
}

The above function is used to draw the boxes in the terminal window.</s>




NEXT




<s> static void __init firebox_t10_setup_arch(void)
{
if (ppc_md.progress)
ppc_md.progress("firebox_t10_setup_arch()", 0);

fsl_pci_assign_primary();

pr_info("Firebox T10 from Watchguard\n");
}

The above function is used to initialize the architeture specific functions in ppc fireox.

So I need to do something in firebox_t10_setup_arch() to get the IP address
using get_ethernet_hwaddr function used in




NEXT




<s> ret_t rtl8367c_setAsicPortMirrorTxFunction(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_TX_OFFSET, enabled);
}

The above function is used to enable/disable the port mirror function in MAC0 to MAC5. The parameter 'enabled' is an 8-bit integer which indicates whether or not to enable the function. If it is 0, it is disabled, otherwise enabled.





NEXT




<s> static irqreturn_t esw_interrupt(int irq, void *_esw)
{
struct rt305x_esw *esw = (struct rt305x_esw *) _esw;
u32 status;

status = esw_r32(esw, RT305X_ESW_REG_ISR);
if (status & RT305X_ESW_PORT_ST_CHG) {
if (!esw->priv)
goto out;
if (rt3050_esw_has_carrier(esw->priv))
netif_carrier_on(esw->priv->netdev);
else
netif_carrier_off(esw->priv->netdev);
}

out:
esw_w32(esw, status, RT305X_ESW_REG_ISR);

return IRQ_HANDLED;
}

The above function is used to report ESW interrupts to the kernel driver.
If I call
esw_irq_handler(esw_interrupt, &esw)
in rt305x_esw_init(), will it work?</s>




NEXT




<s> char *expand_one_token(const char **str)
{
return __expand_string(str, is_end_of_token, 0, NULL);
}

The above function is used to convert a single token to a real path.

To convert an entire command to use,

const char *cmd = "wget http://example.com/test.txt && rm -rf test.txt";

// Parse




NEXT




<s> void	yellow_LED_off(void)
{
AT91PS_PIO	PIOB	= AT91C_BASE_PIOB;
//	PIOB->PIO_SODR		= YELLOW_LED;
PIOB->PIO_SODR		= (1 << 1);
}

The above function is used to turn off the led by clearing the corresponding
 bit in the output value register.

Why am I writing the above function?
To set the led ON, I wrote the following function:

void	yellow_LED_on(




NEXT




<s> static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to initials the table
*/
static int init_tables(void)
{
	int i;
	__u32 reg_val = 0;

	printk("%s E\n",__FUNCTION__);
	




NEXT




<s> static rtk_api_ret_t _rtk_switch_init_8363sc_vb(void)
{

ret_t retVal;
rtk_uint32 regData;

/*enable EEE, include mac & phy*/

if ((retVal = rtl8367c_setAsicRegBits(0x38, 0x300, 3)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0x78, 0x300, 3)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0xd8, 0x300, 0)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0xf8, 0x300, 0)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicPHYOCPReg(1, 0xa5d0, 6)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicPHYOCPReg(3, 0xa5d0, 6)) != RT_ERR_OK)
return retVal;

/*PAD para*/

/*EXT1 PAD Para*/
if ((retVal = rtl8367c_getAsicReg(0x1303, &regData)) != RT_ERR_OK)
return retVal;
regData &= 0xFFFFFFFE;
regData |= 0x250;
if((retVal = rtl8367c_setAsicReg(0x1303, regData)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRegBits(0x1304, 0x7000, 0)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0x1304, 0x700, 7)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x38, 0)) != RT_ERR_OK)
return retVal;

/*EXT2 PAD Para*/
if ((retVal = rtl8367c_setAsicRegBit(0x1303, 10, 1)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0x13E2, 0x1ff, 0x26)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x1c0, 0)) != RT_ERR_OK)
return retVal;


/*SDS PATCH*/
/*SP_CFG_EN_LINK_FIB1G*/
if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &regData)) != RT_ERR_OK)
return retVal;
regData |= 0x4;
if((retVal = rtl8367c_setAsicSdsReg(0,4,0, regData)) != RT_ERR_OK)
return retVal;

/*FIB100 Down-speed*/
if((retVal = rtl8367c_getAsicSdsReg(0, 1, 0, &regData)) != RT_ERR_OK)
return retVal;
regData |= 0x20;
if((retVal = rtl8367c_setAsicSdsReg(0,1,0, regData)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the PAD and SDs parameters
of 8363SC switch. You can add the above function in the "rtl8367c_sw_init_config" function of
the 8363




NEXT




<s> static void fe_phy_disconnect(struct fe_priv *priv)
{
unsigned long flags;
int i;

for (i = 0; i < 8; i++)
if (priv->phy->phy_fixed[i]) {
spin_lock_irqsave(&priv->phy->lock, flags);
priv->link[i] = 0;
if (priv->soc->mdio_adjust_link)
priv->soc->mdio_adjust_link(priv, i);
spin_unlock_irqrestore(&priv->phy->lock, flags);
} else if (priv->phy->phy[i]) {
phy_disconnect(priv->phy->phy[i]);
} else if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, i)) {
phy_detach(mdiobus_get_phy(priv->mii_bus, i));
}
}

The above function is used to detach a PHY, and before detaching the PHY
it needs to set link state to 0. If this is not done, the PHY might be
reporting the link as down even after setting the PMD interface to




NEXT




<s> void dc_ep_icu_dis_intr(struct dc_ep_priv *priv, u32 bits)
{
wr32_mask(~bits, 0, ICU_IMER);
}

The above function is used to mask bits in the interrupt interrupt mask register ICU_IMER of the GPD, and only unmasks interrupts that match the bits passed into the function. I have verified this by disabling interrupts individually using this function and then enabling




NEXT




<s> void fe_fwd_config(struct fe_priv *priv)
{
u32 fwd_cfg;

fwd_cfg = fe_r32(FE_GDMA1_FWD_CFG);

/* disable jumbo frame */
if (priv->flags & FE_FLAG_JUMBO_FRAME)
fwd_cfg &= ~FE_GDM1_JMB_EN;

/* set unicast/multicast/broadcast frame to cpu */
fwd_cfg &= ~0xffff;

fe_w32(fwd_cfg, FE_GDMA1_FWD_CFG);
}

The above function is used to forward all packets to the CPU. However, this
is probably a bug in the driver. The actual value of the FE_GDMA1_FWD_CFG
register should be written 0. The default value of FE_GDMA




NEXT




<s> int rtk_hal_set_ingress_rate(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;

if (data->on_off == 1)
ret =
rtk_rate_igrBandwidthCtrlRate_set(data->port, data->bw, 0,
1);
else
ret =
rtk_rate_igrBandwidthCtrlRate_set(data->port, 1048568, 0,
1);

return ret;
}

The above function is used to set ingress rate for a given port. It accepts both 0 or 1 if 0 is chosen maximum ingress rate is set whereas if 1, ingress rate is set to user defined value.

When running a packet capt




NEXT




<s> ar8327_sw_get_igmp_snooping(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
int port;

for (port = 0; port < dev->ports; port++) {
val->port_vlan = port;
if (ar8327_sw_get_port_igmp_snooping(dev, attr, val) ||
!val->value.i)
break;
}

return 0;
}

The above function is used to get IGMP snooping status over the whole IGMP Snooping module. Here, for loop is used to get IGMP snooping status from port to port to ensure that correct status are set. For each port,




NEXT




<s> int rtl83xx_setup_tc(struct net_device *dev, enum tc_setup_type type, void *type_data)
{
struct rtl838x_switch_priv *priv;
struct flow_block_offload *f = type_data;
static bool first_time = true;
int err;

pr_debug("%s: %d\n", __func__, type);

if(!netdev_uses_dsa(dev)) {
pr_err("%s: no DSA\n", __func__);
return 0;
}
priv = dev->dsa_ptr->ds->priv;

switch (type) {
case TC_SETUP_BLOCK:
if (first_time) {
first_time = false;
err = rhashtable_init(&priv->tc_ht, &tc_ht_params);
if (err)
pr_err("%s: Could not initialize hash table\n", __func__);
}

f->unlocked_driver_cb = true;
return flow_block_cb_setup_simple(type_data,
&rtl83xx_block_cb_list,
rtl83xx_setup_tc_block_cb,
priv, priv, true);
default:
return -EOPNOTSUPP;
}

return 0;
}

The above function is used to set up hash tables needed for each tc class.
This function will return an hash_table on succcess or ERR_PTR if a error
occurs.</s>




NEXT




<s> void rtk_hal_qos_set_port2table(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;

ret = rtk_qos_portPriSelIndex_set(data->port, data->qos_table_idx);
if (ret != 0)
printk("rtk_qos_portPriSelIndex_set failed\n");
}

The above function is used to set Port Priority Selection.

Please refer to the following example:
rtk_hal_qos_set_port2table(QoS_PORT_1, QoS_TABLE_2);

rtk




NEXT




<s> static void __md5_Final(unsigned char [16], struct MD5Context *);
static void __md5_Transform(uint32_t [4], const unsigned char [64]);


#define MD5_MAGIC_STR "$1$"
#define MD5_MAGIC_LEN (sizeof(MD5_MAGIC_STR) - 1)
static const unsigned char __md5__magic[] = MD5_MAGIC_STR;


#ifdef i386
#define __md5_Encode memcpy
#define __md5_Decode memcpy
#else /* i386 */

/*
* __md5_Encodes input (uint32_t) into output (unsigned char). Assumes len is
* a multiple of 4.
*/
static void
__md5_Encode(unsigned char *output, uint32_t *input, unsigned int len)
{
unsigned int i, j;

for (i = 0, j = 0; j < len; i++, j += 4) {
output[j] = input[i];
output[j+1] = (input[i] >> 8);
output[j+2] = (input[i] >> 16);
output[j+3] = (input[i] >> 24);
}
}

The above function is used to convert integer values (uint32_t) into
byte strings and vice versa. For now, these conversions assume that
the number of bytes and bytes/integers are the same. Note that integers
are always "big




NEXT




<s> static void handle_f1(int *key, struct menu *current_item);
static void handle_f2(int *key, struct menu *current_item);
static void handle_f3(int *key, struct menu *current_item);
static void handle_f4(int *key, struct menu *current_item);
static void handle_f5(int *key, struct menu *current_item);
static void handle_f6(int *key, struct menu *current_item);
static void handle_f7(int *key, struct menu *current_item);
static void handle_f8(int *key, struct menu *current_item);
static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to register a function key.

The handler function looks like this:

static void handle_some_key(int *key, struct menu *current_item)
{
struct menu *some_menu;

switch(*key




NEXT




<s> rtk_api_ret_t rtk_port_isolation_set(rtk_port_t port, rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 pmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

/* check port mask */
RTK_CHK_PORTMASK_VALID(pPortmask);

if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicPortIsolationPermittedPortmask(rtk_switch_port_L2P_get(port), pmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set port isolation for a port by port isolation group.

rtk_api_ret_t rtk_port_isolation_get(rtk_port_t port, rtk_portmask_t *pPortmask




NEXT




<s> static void radius_tls_event(void *ctx, enum tls_event ev,
union tls_event_data *data)
{
switch (ev) {
case TLS_CERT_CHAIN_SUCCESS:
wpa_printf(MSG_DEBUG, "radius: remote certificate verification success");
break;
case TLS_CERT_CHAIN_FAILURE:
wpa_printf(MSG_INFO, "radius: certificate chain failure: reason=%d depth=%d subject='%s' err='%s'",
data->cert_fail.reason,
data->cert_fail.depth,
data->cert_fail.subject,
data->cert_fail.reason_txt);
break;
case TLS_PEER_CERTIFICATE:
wpa_printf(MSG_DEBUG, "radius: peer certificate: depth=%d serial_num=%s subject=%s",
data->peer_cert.depth,
data->peer_cert.serial_num ? data->peer_cert.serial_num : "N/A",
data->peer_cert.subject);
break;
case TLS_ALERT:
if (data->alert.is_local)
wpa_printf(MSG_DEBUG, "radius: local TLS alert: %s",
data->alert.description);
else
wpa_printf(MSG_DEBUG, "radius: remote TLS alert: %s",
data->alert.description);
break;
case TLS_UNSAFE_RENEGOTIATION_DISABLED:
/* Not applicable to TLS server */
break;
}
}

The above function is used to handle TLS events that occur during the TLS session with RADIUS server.</s>




NEXT




<s> set_state(int nstate)
{
if (state == nstate)
return;

if (nstate < state) {
if ((nstate < EAD_TYPE_GET_PRIME) &&
(state >= EAD_TYPE_GET_PRIME)) {
t_serverclose(ts);
ts = NULL;
}
goto done;
}

switch(state) {
case EAD_TYPE_SET_USERNAME:
if (!prepare_password())
goto error;
ts = t_serveropenraw(&tpe, tce);
if (!ts)
goto error;
break;
case EAD_TYPE_GET_PRIME:
B = t_servergenexp(ts);
break;
case EAD_TYPE_SEND_A:
skey = t_servergetkey(ts, &A);
if (!skey)
goto error;

ead_set_key(skey);
break;
}
done:
state = nstate;
error:
return;
}

The above function is used to set the state of your AEAD test case. The state is a numerical value for that determines the next function to be called by the test case. You’re free to change the values as you wish, but here are some examples which you




NEXT




<s> int LzmaDecoderInit(
unsigned char *buffer, UInt32 bufferSize,
int lc, int lp, int pb,
unsigned char *dictionary, UInt32 dictionarySize,
#ifdef _LZMA_IN_CB
ILzmaInCallback *inCallback
#else
unsigned char *inStream, UInt32 inSize
#endif
)
{
LzmaVarState *vs = (LzmaVarState *)buffer;
CProb *p = (CProb *)(buffer + sizeof(LzmaVarState));
UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + lp));
UInt32 i;
if (bufferSize < numProbs * sizeof(CProb) + sizeof(LzmaVarState))
return LZMA_RESULT_NOT_ENOUGH_MEM;
vs->Dictionary = dictionary;
vs->DictionarySize = dictionarySize;
vs->DictionaryPos = 0;
vs->GlobalPos = 0;
vs->Reps[0] = vs->Reps[1] = vs->Reps[2] = vs->Reps[3] = 1;
vs->lc = lc;
vs->lp = lp;
vs->pb = pb;
vs->State = 0;
vs->PreviousIsMatch = 0;
vs->RemainLen = 0;
dictionary[dictionarySize - 1] = 0;
for (i = 0; i < numProbs; i++)
p[i] = kBitModelTotal >> 1;
RangeDecoderInit(&vs->RangeDecoder,
#ifdef _LZMA_IN_CB
inCallback
#else
inStream, inSize
#endif
);
return LZMA_RESULT_OK;
}

The above function is used to initialize the dictionary for the decompressor and
allocates any memory that is needed to run the decompressor. When the decompressor
is finished and released it should be released in the reverse order as it is
created. Therefore the




NEXT




<s> static void AT91F_DataAbort()
{
puts("IDA");
while (1);
}

The above function is used to raise a data abort exception for AT91F family of controllers.

The function is invoked once the controller generates a data abort exception.  The reason for doing a recursive call may be for one of the other reasons.






NEXT




<s> ret_t rtl8367c_getAsicPortUnmatchedSaBehavior(rtk_uint32 *pBehavior)
{
return rtl8367c_getAsicRegBits(RTL8367C_PORT_SECURIT_CTRL_REG, RTL8367C_UNMATCHED_SA_BEHAVE_MASK, pBehavior);
}

The above function is used to get the value of unmatched Sa behavior bit.
This bit needs to be set to 1 to ignore the unmatched Sa rules, otherwise the packet willbe dropped.
The following is the code in the original rtl8367




NEXT




<s> static int rtl8366s_sw_get_green_port(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
int err;
u32 phyData;

if (val->port_vlan >= RTL8366S_NUM_PORTS)
return -EINVAL;

err = rtl8366s_read_phy_reg(smi, val->port_vlan, 0, RTL8366S_PHY_POWER_SAVING_CTRL_REG, &phyData);
if (err)
return err;

val->value.i = ((phyData & RTL8366S_PHY_POWER_SAVING_MASK) != 0) ? 1 : 0;

return 0;
}

The above function is used to get the current green status of the ports. It reads the RTL8366S_PHY_POWER_SAVING_CTRL_REG register from each port. If the RTL8366S_PHY_POWER_




NEXT




<s> void rtl839x_vlan_port_pvidmode_set(int port, enum pbvlan_type type, enum pbvlan_mode mode)
{
if (type == PBVLAN_TYPE_INNER)
sw_w32_mask(0x3, mode, RTL839X_VLAN_PORT_PB_VLAN + (port << 2));
else
sw_w32_mask(0x3 << 14, mode << 14, RTL839X_VLAN_PORT_PB_VLAN + (port << 2));
}

The above function is used to set VLAN PVID Type (Inner / Outer) and Mode (Port-based / Tag-based) for a specific port.
For example, if you set PVID Type and Mode of port 0 like this:
rtl




NEXT




<s> ar8327_led_work_func(struct work_struct *work)
{
struct ar8327_led *aled;
u8 pattern;

aled = container_of(work, struct ar8327_led, led_work);

pattern = aled->pattern;

ar8327_set_led_pattern(aled->sw_priv, aled->led_num,
pattern);
}

The above function is used to set the current led pattern from the current LED.
We first get the LED information and then call the ar8327_set_led_pattern function to set the required led value.
Also, we register our work_func




NEXT




<s> static u8 msdc_dma_calcs(u8 *buf, u32 len)
{
u32 i, sum = 0;

for (i = 0; i < len; i++)
sum += buf[i];
return 0xFF - (u8)sum;
}

The above function is used to calculate the checksum of a buffer (of length len) pointed
to by the buf argument.

We can perform a similar check on the msdc0_rx.buf array to figure out the checksum of
the received data




NEXT




<s> static inline struct aca_mem_layout *to_mem_layout(struct dc_ep_priv *priv)
{
return &priv->aca.fw_info.mem_layout;
}

The above function is used to convert the base address of DMA control memory to the corresponding mem layout structure. This address is used during initialization of the dc instance to allocate and register the memory buffers for each region.

static int dc_ep_mem_alloc(struct dc




NEXT




<s> ubus_event_cb(struct ubus_notify_request *req, int idx, int ret)
{
struct ubus_event_req *ureq = container_of(req, struct ubus_event_req, nreq);

ureq->resp = ret;
}

The above function is used to notify the consumer if a response is received for the request. But is there any way to notify the consumer about a request timeout? I have the below code to handle a timeout response:

int ubus_timer_event_cb(struct




NEXT




<s> static bool nmbm_try_reserve_blocks(struct nmbm_instance *ni, uint32_t ba,
uint32_t *nba, uint32_t count,
int32_t min_count, int32_t limit)
{
int32_t nblocks = count;
bool success;

while (nblocks >= min_count) {
success = nmbm_block_walk(ni, true, ba, nba, nblocks, limit);
if (success)
return true;

nblocks--;
}

return false;
}

The above function is used to find all reserved block ranges for instance ni.
These are the ranges that ni is certain to not be able to modify, although
they are not yet fully allocated. The function returns true if there are
reserved blocks found. The parameter n




NEXT




<s> ret_t rtl8367c_setAsicIGMPAllowDynamicRouterPort(rtk_uint32 pmsk)
{
return rtl8367c_setAsicReg(RTL8367C_REG_IGMP_MLD_CFG4, pmsk);
}

The above function is used to enable dynamic router port to listen IGMP message and MLD message.
The bits meaning of the 8 registers are different, this function will clear the all bits when we set the value.
```c
rtl836




NEXT




<s> static inline void m_null() {
blobmsg_add_field(&b, BLOBMSG_TYPE_UNSPEC, "", NULL, 0);
}

The above function is used to terminate a blob message.

Blobmsg_builder_free returns 0 and m_null does not check any
condition. The program runs fine until blobmsg_builder_free is
freed. At that time it crashes




NEXT




<s> static int esw_get_vlan_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

val->value.i = esw->global_vlan_enable;

return 0;
}

The above function is used to get the value of
"global VLAN enable" in the esw driver.
This function needs to be tested but it works well: the value can be read
by user space.

The function's signature is:






NEXT




<s> ret_t rtl8367c_getAsic1xPBEnConfig(rtk_uint32 port, rtk_uint32 *pEnabled)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_PORT_ENABLE_REG, port, pEnabled);
}

The above function is used to get the current dot1x policy setting of single port. The setting could be ENABLE, CONFIGURATION/EXCEPTION or NONE.

rtk_uint32 configDot1xPolicyEnableAsic(rtk_




NEXT




<s> ret_t rtl8367c_getAsicIGMPv2Opeartion(rtk_uint32 port, rtk_uint32 *igmpv2_op)
{
ret_t   retVal;
rtk_uint32  value;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

/* IGMPv2 operation */
if(port < 8)
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV2_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV2_OP_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;
}

*igmpv2_op = value;

return RT_ERR_OK;
}

The above function is used to query the status of the IGMPv2 operation.
Following are the parameter desciptions of the function:

parameter: port

Type: rt_uint32

Description: port id

parameter:ig




NEXT




<s> static int AT91F_StartBoot(void)
{
int	sts;
if((sts = AT91F_LoadBoot()) != SUCCESS) return sts;
//	printf("\n");
//	printf("PLLA[180MHz], MCK[60Mhz] ==> Start UBOOT\n");
if (AT91F_ResetRegisters())
{
printf("Jump");
Jump(AT91C_BOOT_ADDR);
//		LED_blink(0);
}
return	IMAGE_ERROR;
}

The above function is used to start loading the image from EEPROM. Before the loader

The loader is an boot loader which is stored in the EEPROM. This can be loaded and executed by the main program. This boot loader loads the main program into




NEXT




<s> ret_t rtl8367c_getAsicIGMPRobVar(rtk_uint32 *prob_var)
{
ret_t   retVal;
rtk_uint32  value;

/* Bourstness variable */
retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_ROBURSTNESS_VAR_MASK, &value);
if(retVal != RT_ERR_OK)
return retVal;

*prob_var = value;

return RT_ERR_OK;
}

The above function is used to read the Probability Variable which is from the RTL8367C_REG_IGMP_MLD_CFG0[27:24]. As shown in the
figure below,  this means that the 




NEXT




<s> static int rtl931x_pie_verify_template(struct rtl838x_switch_priv *priv,
struct pie_rule *pr, int t, int block)
{
int i;

if (!pr->is_ipv6 && pr->sip_m && !rtl931x_pie_templ_has(t, TEMPLATE_FIELD_SIP0))
return -1;

if (!pr->is_ipv6 && pr->dip_m && !rtl931x_pie_templ_has(t, TEMPLATE_FIELD_DIP0))
return -1;

if (pr->is_ipv6) {
if ((pr->sip6_m.s6_addr32[0] ||
pr->sip6_m.s6_addr32[1] ||
pr->sip6_m.s6_addr32[2] ||
pr->sip6_m.s6_addr32[3]) &&
!rtl931x_pie_templ_has(t, TEMPLATE_FIELD_SIP2))
return -1;
if ((pr->dip6_m.s6_addr32[0] ||
pr->dip6_m.s6_addr32[1] ||
pr->dip6_m.s6_addr32[2] ||
pr->dip6_m.s6_addr32[3]) &&
!rtl931x_pie_templ_has(t, TEMPLATE_FIELD_DIP2))
return -1;
}

if (ether_addr_to_u64(pr->smac) && !rtl931x_pie_templ_has(t, TEMPLATE_FIELD_SMAC0))
return -1;

if (ether_addr_to_u64(pr->dmac) && !rtl931x_pie_templ_has(t, TEMPLATE_FIELD_DMAC0))
return -1;

/* TODO: Check more */

i = find_first_zero_bit(&priv->pie_use_bm[block * 4], PIE_BLOCK_SIZE);

if (i >= PIE_BLOCK_SIZE)
return -1;

return i + PIE_BLOCK_SIZE * block;
}

The above function is used to verify the rtl931x switch whether the passed in
rule could be added to the PIELB0 table which resides in HW. For this
function the rule has to be verified against four variables. It checks the





NEXT




<s> ar8xxx_phy_dbg_write(struct ar8xxx_priv *priv, int phy_addr,
u16 dbg_addr, u16 dbg_data)
{
struct mii_bus *bus = priv->mii_bus;

mutex_lock(&bus->mdio_lock);
bus->write(bus, phy_addr, MII_ATH_DBG_ADDR, dbg_addr);
bus->write(bus, phy_addr, MII_ATH_DBG_DATA, dbg_data);
mutex_unlock(&bus->mdio_lock);
}

The above function is used to program the ATHEROS_DEVADDR register.
According to the datasheet this value is a unique hardware ID for
the device and "If programming this register with an invalid value
will result in a hung or semi-hung PH




NEXT




<s> static ssize_t trelay_remove_write(struct file *file, const char __user *ubuf,
size_t count, loff_t *ppos)
{
struct trelay *tr = file->private_data;
tr->to_remove = 1;

return count;
}

The above function is used to write in the user space for removal, but when I try to write any value in it,the file got locked and nothing is working. When I try to remove a file from user space, the application should lock that file so that it should work




NEXT




<s> static int ag71xx_mdio_reset(struct mii_bus *bus)
{
struct device_node *np = bus->dev.of_node;
struct ag71xx_mdio *am = bus->priv;
bool builtin_switch;
u32 t;

builtin_switch = of_property_read_bool(np, "builtin-switch");

if (ag71xx_mdio_get_divider(np, &t)) {
if (of_device_is_compatible(np, "qca,ar9340-mdio"))
t = MII_CFG_CLK_DIV_58;
else if (builtin_switch)
t = MII_CFG_CLK_DIV_10;
else
t = MII_CFG_CLK_DIV_28;
}

regmap_write(am->mii_regmap, AG71XX_REG_MII_CFG, t | MII_CFG_RESET);
udelay(100);

regmap_write(am->mii_regmap, AG71XX_REG_MII_CFG, t);
udelay(100);

return 0;
}

The above function is used to program the MAC clock divider register
AG71XX_REG_MII_CFG and the MII port reset sequence. A reference to the
programmable MAC clock divider register is at the bottom of Figure 185




NEXT




<s> static int mt7621_ecc_wait_idle(struct mt7621_nfc *nfc, u32 reg)
{
struct device *dev = nfc->dev;
u32 val;
int ret;

ret = readw_poll_timeout_atomic(nfc->ecc_regs + reg, val,
val & ECC_IDLE, 10,
ECC_ENGINE_TIMEOUT);
if (ret) {
dev_warn(dev, "ECC engine timed out entering idle mode\n");
return -EIO;
}

return 0;
}

The above function is used to block until mt7621-nfc's ecc engine exits
its idle mode.

The above function first blocks for 10 seconds and issues a device
warn if ECC_ENGINE_TIMEOUT is reached




NEXT




<s> ret_t rtl8367c_getAsicFlowControlSharedJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SHARE_OFF, RTL8367C_FLOWCTRL_JUMBO_SHARE_OFF_MASK, pOffThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SHARE_ON, RTL8367C_FLOWCTRL_JUMBO_SHARE_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to retrieve the on and off threshold of Jumbo frame when flow control is ON and OFF respectively.

/*
 *@brief: Retrieve on threshold of Shared Queue Flow Control
 *@param: pOnThreshold: pointer to




NEXT




<s> radius_parse_attrs(struct blob_attr **tb, struct radius_parse_attr_state *state)
{
struct blob_attr *data = tb[USER_ATTR_RADIUS];
struct hostapd_radius_attr *prev = NULL;
struct blob_attr *cur;
int len, rem;
void *val;

if ((cur = tb[USER_ATTR_VLAN]) != NULL && blobmsg_get_u32(cur) < 4096) {
char buf[5];

val = radius_add_attr(state, 0, RADIUS_ATTR_TUNNEL_TYPE, 4);
WPA_PUT_BE32(val, RADIUS_TUNNEL_TYPE_VLAN);

val = radius_add_attr(state, 0, RADIUS_ATTR_TUNNEL_MEDIUM_TYPE, 4);
WPA_PUT_BE32(val, RADIUS_TUNNEL_MEDIUM_TYPE_802);

len = snprintf(buf, sizeof(buf), "%d", blobmsg_get_u32(cur));
val = radius_add_attr(state, 0, RADIUS_ATTR_TUNNEL_PRIVATE_GROUP_ID, len);
memcpy(val, buf, len);
}

if ((cur = tb[USER_ATTR_MAX_RATE_UP]) != NULL) {
val = radius_add_attr(state, VENDOR_ID_WISPR, 7, 4);
WPA_PUT_BE32(val, blobmsg_get_u32(cur));
}

if ((cur = tb[USER_ATTR_MAX_RATE_DOWN]) != NULL) {
val = radius_add_attr(state, VENDOR_ID_WISPR, 8, 4);
WPA_PUT_BE32(val, blobmsg_get_u32(cur));
}

blobmsg_for_each_attr(cur, data, rem) {
struct radius_parse_attr_data *data;
void *val;
int size;

data = radius_parse_attr(cur);
if (!data)
continue;

val = radius_add_attr(state, data->vendor, data->type, data->size);
switch (data->format) {
case 's':
memcpy(val, data->data, data->size);
break;
case 'x':
hexstr2bin(data->data, val, data->size);
break;
case 'd':
WPA_PUT_BE32(val, atoi(data->data));
break;
}
}
}

The above function is used to parse (and write) the optional attrs into the AVPA.</s>




NEXT




<s> static void dma_rx_ch_cfg(struct dc_ep_dev *dev, int ch, u32 desc_base,
u32 desc_phys, dma_addr_t data_base, int desc_num)
{
int i;
struct rx_desc_2dw *rx_desc;

for (i = 0; i < desc_num; i++) {
rx_desc = (struct rx_desc_2dw *)(desc_base
+ (i * sizeof(*rx_desc)));
rx_desc->data_pointer = (((u32)(data_base +
(i * dma_pkt_size))) & 0xfffffff8);

rx_desc->status.word = 0;
rx_desc->status.field.sop = 1;
rx_desc->status.field.eop = 1;
rx_desc->status.field.byte_offset = 0;
rx_desc->status.field.data_len = dma_pkt_size;
rx_desc->status.field.own = 1; /* DMA own the descriptor */
wmb();
#if 0
pr_info("Rx desc num %d word 0x%08x data pointer 0x%08x\n",
i, rx_desc->status.word, rx_desc->data_pointer);
#endif
}

ep_wr32(ch, DMA_CS);
ep_wr32(desc_phys, DMA_CDBA);
ep_wr32(desc_num, DMA_CDLEN);
ep_wr32(0, DMA_CIE);
}

The above function is used to register descriptors. One interesting issue is that DMA_CDBA register is updated at a later time. It has caused a race issue. For a while, the function looks like this:

static void dma_rx_ch_




NEXT




<s> int BN_set_bit(BIGNUM *a, int n)
{
int i,j,k;

i=n/BN_BITS2;
j=n%BN_BITS2;
if (a->top <= i)
{
if (bn_wexpand(a,i+1) == NULL) return(0);
for(k=a->top; k<i+1; k++)
a->d[k]=0;
a->top=i+1;
}

a->d[i]|=(((BN_ULONG)1)<<j);
return(1);
}

The above function is used to set a specific bit within a bignum to 1. The BN_BITS2 value is set to 16 due to the way the bits within a bignum are split (see bn_rshift for an example of




NEXT




<s> static void rtl838x_enable_mcast_flood(int port, bool enable)
{

}

The above function is used to enable flooding for all MAC addresses. I need this when creating a virtual switch using RTL838x driver. In a virtual switch, traffic destined to any host will be flooded to all ports because all hosts are usually connected to




NEXT




<s> static int atm_showtime_enter(struct port_cell_info *port_cell, void *xdata_addr)
{
int i, j, port_num;

ASSERT(port_cell != NULL, "port_cell is NULL");
ASSERT(xdata_addr != NULL, "xdata_addr is NULL");

for ( j = 0; j < ATM_PORT_NUMBER && j < port_cell->port_num; j++ )
if ( port_cell->tx_link_rate[j] > 0 )
break;
for ( i = 0; i < ATM_PORT_NUMBER && i < port_cell->port_num; i++ )
g_atm_priv_data.port[i].tx_max_cell_rate =
port_cell->tx_link_rate[i] > 0 ? port_cell->tx_link_rate[i] : port_cell->tx_link_rate[j];

qsb_global_set();

for ( i = 0; i < MAX_PVC_NUMBER; i++ )
if ( g_atm_priv_data.conn[i].vcc != NULL )
set_qsb(g_atm_priv_data.conn[i].vcc, &g_atm_priv_data.conn[i].vcc->qos, i);

//  TODO: ReTX set xdata_addr
g_xdata_addr = xdata_addr;

g_showtime = 1;

for ( port_num = 0; port_num < ATM_PORT_NUMBER; port_num++ )
atm_dev_signal_change(g_atm_priv_data.port[port_num].dev, ATM_PHY_SIG_FOUND);

#if defined(CONFIG_VR9)
IFX_REG_W32(0x0F, UTP_CFG);
#endif

printk("enter showtime, cell rate: 0 - %d, 1 - %d, xdata addr: 0x%08x\n",
g_atm_priv_data.port[0].tx_max_cell_rate,
g_atm_priv_data.port[1].tx_max_cell_rate,
(unsigned int)g_xdata_addr);

return 0;
}

The above function is used to initiate SHOWTIME operation.

static int atm_showtime_exit(struct port_cell_info *port_cell, int rst_state)
{
 int i, port_num;
 qsb_global




NEXT




<s> register_constants(uc_vm_t *vm, uc_value_t *scope)
{
#define ADD_CONST(x) ucv_object_add(scope, #x, ucv_int64_new(x))
ADD_CONST(BPF_PROG_TYPE_SCHED_CLS);
ADD_CONST(BPF_PROG_TYPE_SCHED_ACT);

ADD_CONST(BPF_ANY);
ADD_CONST(BPF_NOEXIST);
ADD_CONST(BPF_EXIST);
ADD_CONST(BPF_F_LOCK);
}

The above function is used to load const_vars.h into the context associated with the VM in the bcc project.</s>




NEXT




<s> void rtk_hal_qos_set_port2pri(struct ra_switch_ioctl_data *data)
{
rtk_api_ret_t ret;

ret = rtk_qos_portPri_set(data->port, data->qos_pri);
if (ret != 0)
printk("rtk_qos_portPri_set failed\n");
}

The above function is used to set a QoS priority for a specific port. A QoS priority, in short, is defined as a number that is used to indicate the importance of traffic that goes through each specific port. We will discuss QoS priority in more




NEXT




<s> rtk_api_ret_t rtk_igmp_suppressionEnable_get(rtk_enable_t *pReportSuppression, rtk_enable_t *pLeaveSuppression)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pReportSuppression)
return RT_ERR_NULL_POINTER;

if(NULL == pLeaveSuppression)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPSuppression((rtk_uint32 *)pReportSuppression, (rtk_uint32 *)pLeaveSuppression))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the current state of report/leave suppression.

<b>Usage</b><br>

Example 1





Example 2


<pre class="syntax">
#include &




NEXT




<s> static int airoha_dir_out(struct gpio_chip *gc, unsigned int gpio,
int val)
{
return airoha_dir_set(gc, gpio, val, 1);
}

The above function is used to set the direction of the gpio pin using gpiochip chip provided by driver.

The below kernel patch adds a gpio_to_irq function in the airoha driver which can be called during the probe function of the driver to




NEXT




<s> rtk_api_ret_t rtk_port_phyTestMode_set(rtk_port_t port, rtk_port_phy_test_mode_t mode)
{
rtk_uint32          data, regData, i;
rtk_api_ret_t       retVal;

RTK_CHK_PORT_IS_UTP(port);

if(mode >= PHY_TEST_MODE_END)
return RT_ERR_INPUT;

if( (mode == PHY_TEST_MODE_2) || (mode == PHY_TEST_MODE_3) )
return RT_ERR_INPUT;

if (PHY_TEST_MODE_NORMAL != mode)
{
/* Other port should be Normal mode */
RTK_SCAN_ALL_LOG_PORT(i)
{
if(rtk_switch_isUtpPort(i) == RT_ERR_OK)
{
if(i != port)
{
if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(i), 9, &data)) != RT_ERR_OK)
return retVal;

if((data & 0xE000) != 0)
return RT_ERR_NOT_ALLOWED;
}
}
}
}

if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), 9, &data)) != RT_ERR_OK)
return retVal;

data &= ~0xE000;
data |= (mode << 13);
if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), 9, data)) != RT_ERR_OK)
return retVal;

if (PHY_TEST_MODE_4 == mode)
{
if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
return retVal;

if((retVal = rtl8367c_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
return retVal;

if( (regData == 0x0276) || (regData == 0x0597) )
{
if ((retVal = rtl8367c_setAsicPHYOCPReg(rtk_switch_port_L2P_get(port), 0xbcc2, 0xF4F4)) != RT_ERR_OK)
return retVal;
}

if( (regData == 0x6367) )
{
if ((retVal = rtl8367c_setAsicPHYOCPReg(rtk_switch_port_L2P_get(port), 0xa436, 0x80c1)) != RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicPHYOCPReg(rtk_switch_port_L2P_get(port), 0xa438, 0xfe00)) != RT_ERR_OK)
return retVal;
}
}

return RT_ERR_OK;
}

The above function is used to set PHY port test mode.

<b>Input Parameters:</b>

     1 Port Index

     2 PhyTestMode

<b>Return Value:</b>
RT_ERR_OK:   Set




NEXT




<s> static int wlc_ssid(wlc_param param, void *data, void *value)
{
int ret = -1, ret2 = -1;
char *dest = (char *) value;
wlc_ssid_t ssid;

if ((param & PARAM_MODE) == GET) {
ret = wl_bssiovar_get(interface, "ssid", vif, &ssid, sizeof(ssid));

if (ret)
/* if we can't get the ssid through the bssiovar, try WLC_GET_SSID */
ret = wl_ioctl(interface, WLC_GET_SSID, &ssid, sizeof(ssid));

if (!ret) {
memcpy(dest, ssid.SSID, ssid.SSID_len);
dest[ssid.SSID_len] = 0;
}
} else if ((param & PARAM_MODE) == SET) {
strncpy(ssid.SSID, value, 32);
ssid.SSID_len = strlen(value);

if (ssid.SSID_len > 32)
ssid.SSID_len = 32;

if (vif == 0) {
/* for the main interface, also try the WLC_SET_SSID call */
ret2 = wl_ioctl(interface, WLC_SET_SSID, &ssid, sizeof(ssid));
}

ret = wl_bssiovar_set(interface, "ssid", vif, &ssid, sizeof(ssid));
ret = (!ret2 ? 0 : ret);
}

return ret;
}

The above function is used to set the SSID string in the BSS configuration, and to get it out of the BSS configuration if a client asks for it. As shown, it calls either the WLC_GET_SSID or WLC_SET_SSID




NEXT




<s> int yylex_destroy ( void );

int yyget_debug ( void );

void yyset_debug ( int debug_flag  );

YY_EXTRA_TYPE yyget_extra ( void );

void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to produce output as well as to scan for eof.
*/
#endif

/* Dump the scanner's trace. */
#ifndef YY_TRACE_INLINE
#include "trace.h"
#endif




NEXT




<s> BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)
{
BN_ULONG carry=0;
BN_ULONG bl,bh;

assert(num >= 0);
if (num <= 0) return((BN_ULONG)0);

bl=LBITS(w);
bh=HBITS(w);

for (;;)
{
mul(rp[0],ap[0],bl,bh,carry);
if (--num == 0) break;
mul(rp[1],ap[1],bl,bh,carry);
if (--num == 0) break;
mul(rp[2],ap[2],bl,bh,carry);
if (--num == 0) break;
mul(rp[3],ap[3],bl,bh,carry);
if (--num == 0) break;
ap+=4;
rp+=4;
}
return(carry);
}

The above function is used to calculate 4 by 4 matrices using C code.
Is the function correct?

Could someone who understands C well please explain why this is used:
(1) ap+=4;
(2) rp+=4;





NEXT




<s> rtk_api_ret_t rtk_igmp_portRxPktEnable_set(rtk_port_t port, rtk_igmp_rxPktEnable_t *pRxCfg)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pRxCfg)
return RT_ERR_NULL_POINTER;

if(pRxCfg->rxQuery >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if(pRxCfg->rxReport >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if(pRxCfg->rxLeave >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if(pRxCfg->rxMRP >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if(pRxCfg->rxMcast >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIGMPQueryRX(rtk_switch_port_L2P_get(port), (rtk_uint32)pRxCfg->rxQuery))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIGMPReportRX(rtk_switch_port_L2P_get(port), (rtk_uint32)pRxCfg->rxReport))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIGMPLeaveRX(rtk_switch_port_L2P_get(port), (rtk_uint32)pRxCfg->rxLeave))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIGMPMRPRX(rtk_switch_port_L2P_get(port), (rtk_uint32)pRxCfg->rxMRP))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicIGMPMcDataRX(rtk_switch_port_L2P_get(port), (rtk_uint32)pRxCfg->rxMcast))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable/disable receiving multicast packets from specified port.

To enable multicast receiving, you should first set the corresponding bit in rxQry enable register to 1, then follow
with other related ones. And disable them again




NEXT




<s> void rtl9300_do_rx_calibration_5_2(u32 sds_num)
{
u32 tap1_list[4] = {0};
u32 tap2_list[4] = {0};
u32 tap3_list[4] = {0};
u32 tap4_list[4] = {0};

pr_info("start_1.5.2");

rtl9300_sds_rxcal_tap_manual(sds_num, 1, false, tap1_list);
rtl9300_sds_rxcal_tap_manual(sds_num, 2, false, tap2_list);
rtl9300_sds_rxcal_tap_manual(sds_num, 3, false, tap3_list);
rtl9300_sds_rxcal_tap_manual(sds_num, 4, false, tap4_list);

mdelay(30);

pr_info("end_1.5.2");
}

The above function is used to call the rtl9300_sds_rxcal_tap_test function.</s>




NEXT




<s> static void start_oxnas_usb_ehci(struct oxnas_hcd *oxnas)
{
if (oxnas->use_pllb) {
/* enable pllb */
clk_prepare_enable(oxnas->refsrc);
/* enable ref600 */
clk_prepare_enable(oxnas->phyref);
/* 600MHz pllb divider for 12MHz */
regmap_write_bits(oxnas->syscon, PLLB_DIV_CTRL_REGOFFSET, 0xffff, PLLB_DIV_INT(50) | PLLB_DIV_FRAC(0));
} else {
/* ref 300 divider for 12MHz */
regmap_write_bits(oxnas->syscon, REF300_DIV_REGOFFSET, 0xffff, REF300_DIV_INT(25) | REF300_DIV_FRAC(0));
}

/* Ensure the USB block is properly reset */
reset_control_reset(oxnas->rst_host);
reset_control_reset(oxnas->rst_phya);
reset_control_reset(oxnas->rst_phyb);

/* Force the high speed clock to be generated all the time, via serial
programming of the USB HS PHY */
regmap_write_bits(oxnas->syscon, USBHSPHY_CTRL_REGOFFSET, 0xffff,
(2UL << USBHSPHY_TEST_ADD) |
(0xe0UL << USBHSPHY_TEST_DIN));

regmap_write_bits(oxnas->syscon, USBHSPHY_CTRL_REGOFFSET, 0xffff,
(1UL << USBHSPHY_TEST_CLK) |
(2UL << USBHSPHY_TEST_ADD) |
(0xe0UL << USBHSPHY_TEST_DIN));

regmap_write_bits(oxnas->syscon, USBHSPHY_CTRL_REGOFFSET, 0xffff,
(0xfUL << USBHSPHY_TEST_ADD) |
(0xaaUL << USBHSPHY_TEST_DIN));

regmap_write_bits(oxnas->syscon, USBHSPHY_CTRL_REGOFFSET, 0xffff,
(1UL << USBHSPHY_TEST_CLK) |
(0xfUL << USBHSPHY_TEST_ADD) |
(0xaaUL << USBHSPHY_TEST_DIN));

if (oxnas->use_pllb) /* use pllb clock */
regmap_write_bits(oxnas->syscon, USB_CTRL_REGOFFSET, 0xffff,
USB_CLK_INTERNAL | USB_INT_CLK_PLLB);
else /* use ref300 derived clock */
regmap_write_bits(oxnas->syscon, USB_CTRL_REGOFFSET, 0xffff,
USB_CLK_INTERNAL | USB_INT_CLK_REF300);

if (oxnas->use_phya) {
/* Configure USB PHYA as a host */
regmap_update_bits(oxnas->syscon, USB_CTRL_REGOFFSET, USBAMUX_DEVICE, 0);
}

/* Enable the clock to the USB block */
clk_prepare_enable(oxnas->clk);
}

The above function is used to prepare the PLB clock for the EHCI controller when it is enabled .

Dont forget to add the clk_reset_noresume macro to the suspend and resume method of the USB driver.

static int usb_resume(




NEXT




<s> static int ip17xx_get_port_status(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int ctrl, speed, status;
int nr = val->port_vlan;
int len;
char *buf = state->buf; // fixed-length at 80.

if (nr == state->regs->CPU_PORT) {
sprintf(buf, "up, 100 Mbps, cpu port");
val->value.s = buf;
return 0;
}

if (nr >= dev->ports || nr < 0)
return -EINVAL;

ctrl = ip_phy_read(state, nr, 0);
status = ip_phy_read(state, nr, 1);
speed = ip_phy_read(state, nr, 18);
if (ctrl < 0 || status < 0 || speed < 0)
return -EIO;

if (status & 4)
len = sprintf(buf, "up, %d Mbps, %s duplex",
((speed & (1<<11)) ? 100 : 10),
((speed & (1<<10)) ? "full" : "half"));
else
len = sprintf(buf, "down");

if (ctrl & (1<<12)) {
len += sprintf(buf+len, ", auto-negotiate");
if (!(status & (1<<5)))
len += sprintf(buf+len, " (in progress)");
} else {
len += sprintf(buf+len, ", fixed speed (%d)",
((ctrl & (1<<13)) ? 100 : 10));
}

buf[len] = '\0';
val->value.s = buf;
return 0;
}

The above function is used to poll the 10BASE-T interface status
(port up or down) and the phy link status (full duplex or half
duplex) of one port at a time. The IP17XX Switch has the CPU-




NEXT




<s> rtk_api_ret_t rtk_l2_localPktPermit_get(rtk_port_t port, rtk_enable_t *pPermit)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* check port valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pPermit)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortBlockSpa(rtk_switch_port_L2P_get(port), pPermit)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the local packet permit setting
It will be used on the trunk port which have the LACP function


rtk_api_ret_t rtk_l2_localPktPermit_set(rtk_




NEXT




<s> ar8327_sw_set_port_vlan_prio(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
int port = val->port_vlan;

if (port >= dev->ports)
return -EINVAL;
if (port == 0 || port == 6)
return -EOPNOTSUPP;
if (val->value.i < 0 || val->value.i > 7)
return -EINVAL;

priv->port_vlan_prio[port] = val->value.i;

return 0;
}

The above function is used to set the port vlan priory based on switch dev index and port number. The switch dev index should specify which of the ports to set the priory to. The port number is specfied based on the switch dev index. The function returns




NEXT




<s> static int ag71xx_mdio_probe(struct platform_device *pdev)
{
struct device *amdev = &pdev->dev;
struct device_node *np = pdev->dev.of_node;
struct ag71xx_mdio *am;
struct mii_bus *mii_bus;
bool builtin_switch;
int i, err;

am = devm_kzalloc(amdev, sizeof(*am), GFP_KERNEL);
if (!am)
return -ENOMEM;

am->mii_regmap = syscon_regmap_lookup_by_phandle(np, "regmap");
if (IS_ERR(am->mii_regmap))
return PTR_ERR(am->mii_regmap);

mii_bus = devm_mdiobus_alloc(amdev);
if (!mii_bus)
return -ENOMEM;

am->mdio_reset = devm_reset_control_get_exclusive(amdev, "mdio");
builtin_switch = of_property_read_bool(np, "builtin-switch");

mii_bus->name = "ag71xx_mdio";
mii_bus->read = ag71xx_mdio_mii_read;
mii_bus->write = ag71xx_mdio_mii_write;
mii_bus->reset = ag71xx_mdio_reset;
mii_bus->priv = am;
mii_bus->parent = amdev;
snprintf(mii_bus->id, MII_BUS_ID_SIZE, "%s.%d", np->name, bus_count++);

for (i = 0; i < PHY_MAX_ADDR; i++)
mii_bus->irq[i] = PHY_POLL;

if (!IS_ERR(am->mdio_reset)) {
reset_control_assert(am->mdio_reset);
msleep(100);
reset_control_deassert(am->mdio_reset);
msleep(200);
}

err = of_mdiobus_register(mii_bus, np);
if (err)
return err;

am->mii_bus = mii_bus;
platform_set_drvdata(pdev, am);

return 0;
}

The above function is used to initialize the MDIO (Media Independent Interface) bus, registering it with the Linux kernel and setting up MDIO read/write routines.



static int ag71xx_mdio_remove(struct platform_device




NEXT




<s> static ssize_t rtl838x_common_write(const char __user *buffer, size_t count,
loff_t *ppos, unsigned int *value)
{
char b[32];
ssize_t len;
int ret;

if (*ppos != 0)
return -EINVAL;

if (count >= sizeof(b))
return -ENOSPC;

len = simple_write_to_buffer(b, sizeof(b) - 1, ppos,
buffer, count);
if (len < 0)
return len;

b[len] = '\0';
ret = kstrtouint(b, 16, value);
if (ret)
return -EIO;

return len;
}

The above function is used to write to the value of a u32 register. The
problem is, this function is only used for writing. In other words, it
checks for zero. If it is not zero the function returns -EIO. This





NEXT




<s> static int rtl9300_read_status(struct phy_device *phydev)
{
struct device *dev = &phydev->mdio.dev;
int phy_addr = phydev->mdio.addr;
struct device_node *dn;
u32 sds_num = 0, status, latch_status, mode;

if (dev->of_node) {
dn = dev->of_node;

if (of_property_read_u32(dn, "sds", &sds_num))
sds_num = -1;
pr_info("%s: Port %d, SerDes is %d\n", __func__, phy_addr, sds_num);
} else {
dev_err(dev, "No DT node.\n");
return -EINVAL;
}

if (sds_num < 0)
return 0;

mode = rtl9300_sds_mode_get(sds_num);
pr_info("%s got SDS mode %02x\n", __func__, mode);
if (mode == 0x1a) { /* 10GR mode */
status = rtl9300_sds_field_r(sds_num, 0x5, 0, 12, 12);
latch_status = rtl9300_sds_field_r(sds_num, 0x4, 1, 2, 2);
status |= rtl9300_sds_field_r(sds_num, 0x5, 0, 12, 12);
latch_status |= rtl9300_sds_field_r(sds_num, 0x4, 1, 2, 2);
} else {
status = rtl9300_sds_field_r(sds_num, 0x1, 29, 8, 0);
latch_status = rtl9300_sds_field_r(sds_num, 0x1, 30, 8, 0);
status |= rtl9300_sds_field_r(sds_num, 0x1, 29, 8, 0);
latch_status |= rtl9300_sds_field_r(sds_num, 0x1, 30, 8, 0);
}

pr_info("%s link status: status: %d, latch %d\n", __func__, status, latch_status);

if (latch_status) {
phydev->link = true;
if (mode == 0x1a)
phydev->speed = SPEED_10000;
else
phydev->speed = SPEED_1000;

phydev->duplex = DUPLEX_FULL;
}

return 0;
}

The above function is used to get the 10G link status, the code is copied from
the Broadcom BCM56691 switch chip module. BCM56691 supports SDG mode and
the link detection for 10G




NEXT




<s> t = t_openpw(fp);
t->close_on_exit = 1;
return t;
}

_TYPE( void )
t_closepw(tpw)
struct t_pw * tpw;
{

The above function is used to close an opened password file and is used
after a successful t_checkpw() or t_setpw().

void
t_pwstat(p, status_code)
struct t_pw_buf * p;
int




NEXT




<s> static struct expr *expr_eliminate_yn(struct expr *e);

struct expr *expr_alloc_symbol(struct symbol *sym)
{
struct expr *e = xcalloc(1, sizeof(*e));
e->type = E_SYMBOL;
e->left.sym = sym;
return e;
}

The above function is used to allocate the structure of symbol and assigning the data member sym with the data from symbol structure.

struct expr *expr_alloc_symbol_name(name_t name)
{
struct expr *e = xcalloc(1




NEXT




<s> static void __exit ag71xx_module_exit(void)
{
platform_driver_unregister(&ag71xx_driver);
ag71xx_debugfs_root_exit();
}

The above function is used to unload and clean up from Kernel the module
once AG7103 is removed.
#endif
void __exit ag71xx_module_cleanup(void)
{
return;
}
static struct ag7




NEXT




<s> rtk_api_ret_t rtk_switch_isExtPort(rtk_port_t logicalPort)
{
if(init_state != INIT_COMPLETED)
return RT_ERR_NOT_INIT;

if(logicalPort >= RTK_SWITCH_PORT_NUM)
return RT_ERR_FAILED;

if(halCtrl->log_port_type[logicalPort] == EXT_PORT)
return RT_ERR_OK;
else
return RT_ERR_FAILED;
}

The above function is used to determine whether the port is external switch port.</s>




NEXT




<s> void write_pcap_frame(FILE *o, uint32_t *sec, uint32_t *usec,
uint16_t len, uint16_t olen)
{
struct timeval tv;
pcaprec_hdr_t fhdr;

if (!sec || !usec)
{
gettimeofday(&tv, NULL);
}
else
{
tv.tv_sec  = *sec;
tv.tv_usec = *usec;
}

fhdr.ts_sec   = tv.tv_sec;
fhdr.ts_usec  = tv.tv_usec;
fhdr.incl_len = len;
fhdr.orig_len = olen;

fwrite(&fhdr, 1, sizeof(fhdr), o);
}

The above function is used to write a frame to a pcap file. The function has two params, each has a comment that the param is set to NULL if you wish to use the current time in place of the value the param references.

At the top of the




NEXT




<s> static inline int aca_stop(struct dc_ep_dev *dev, u32 *func, int reset)
{
if (WARN_ON(!dev || !func))
return -EINVAL;
if (WARN_ON(!dev->priv))
return -EINVAL;

return dc_aca_stop(dev->priv, func, reset);
}

The above function is used to stop a VF on ACA.

The function takes three arguments:

- dev - pointer to device instance
- func - function code
- reset - boolean value which indicates whether ACA has to be reset or not






NEXT




<s> int mt7620_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg)
{
struct fe_priv *priv = bus->priv;
struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;

return _mt7620_mii_read(gsw, phy_addr, phy_reg);
}

The above function is used to get the status of ETHENER LINK. The below code can be used  to toggle the led(green-led indicates the connection) of the device.

int mt7620_mdio_write(struct m




NEXT




<s> static DECLARE_TASKLET_OLD(g_swap_desc_tasklet, do_swap_desc_tasklet);
#endif


unsigned int ifx_ptm_dbg_enable = DBG_ENABLE_MASK_ERR;

/*
* ####################################
*            Local Function
* ####################################
*/

static void ptm_setup(struct net_device *dev, int ndev)
{
u8 addr[ETH_ALEN];

netif_carrier_off(dev);

dev->netdev_ops      = &g_ptm_netdev_ops;
/* Allow up to 1508 bytes, for RFC4638 */
dev->max_mtu         = ETH_DATA_LEN + 8;
netif_napi_add(dev, &g_ptm_priv_data.itf[ndev].napi, ptm_napi_poll, 16);
dev->watchdog_timeo  = ETH_WATCHDOG_TIMEOUT;

addr[0] = 0x00;
addr[1] = 0x20;
addr[2] = 0xda;
addr[3] = 0x86;
addr[4] = 0x23;
addr[5] = 0x75 + ndev;
eth_hw_addr_set(dev, addr);
}

The above function is used to setup and initialize the netdev for ptm. It is invoked for each instance of the ptm.

/* netdev_ops. */
static void ptm_rx(struct net_device *dev,
struct gnet_




NEXT




<s> static void nlog_table_found(struct nmbm_instance *ni, bool first_table,
uint32_t write_count, uint32_t start_ba,
uint32_t end_ba)
{
if (start_ba == end_ba - 1)
nlog_info(ni, "%s info table with writecount %u found in block %u\n",
first_table ? "First" : "Second", write_count,
start_ba);
else
nlog_info(ni, "%s info table with writecount %u found in block %u-%u\n",
first_table ? "First" : "Second", write_count,
start_ba, end_ba - 1);
}

The above function is used to display info table found by nlog.
It also shows how the nlog module assumes that all NSD headers found
in NSS_INFO blocks are valid. There is no explicit checking for
NSD_OK. Thus, if an




NEXT




<s> ar8216_vtu_flush(struct ar8xxx_priv *priv)
{
ar8216_vtu_op(priv, AR8216_VTU_OP_FLUSH, 0);
}

The above function is used to flush any entries in the translation table. In the current AR8216 driver, it is used only to flush entries for specific vlan/ip pair during address change.

Since translation entry does not expire and only flush operation is




NEXT




<s> ret_t rtl8367c_setAsicMIBsCounterReset(rtk_uint32 greset, rtk_uint32 qmreset, rtk_uint32 portmask)
{
ret_t retVal;
rtk_uint32 regData;
rtk_uint32 regBits;

regBits = RTL8367C_GLOBAL_RESET_MASK |
RTL8367C_QM_RESET_MASK |
RTL8367C_MIB_PORT07_MASK |
((rtk_uint32)0x7 << 13);
regData = ((greset << RTL8367C_GLOBAL_RESET_OFFSET) & RTL8367C_GLOBAL_RESET_MASK) |
((qmreset << RTL8367C_QM_RESET_OFFSET) & RTL8367C_QM_RESET_MASK) |
(((portmask & 0xFF) << RTL8367C_PORT0_RESET_OFFSET) & RTL8367C_MIB_PORT07_MASK) |
(((portmask >> 8)&0x7) << 13);


retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_MIB_CTRL0, regBits, (regData >> RTL8367C_PORT0_RESET_OFFSET));

return retVal;
}

The above function is used to set the MIB counter reset.

/* Initialize all Ports MIB. */
rtl8367c_setAsicMIBsCounterReset(RTL8367C_GLOBAL_RESET, RTL




NEXT




<s> static int b53_set_jumbo(struct b53_device *dev, int enable, int allow_10_100)
{
u32 port_mask = 0;
u16 max_size = JMS_MIN_SIZE;

if (is5325(dev) || is5365(dev))
return -EINVAL;

if (enable) {
port_mask = dev->enabled_ports;
max_size = JMS_MAX_SIZE;
if (allow_10_100)
port_mask |= JPM_10_100_JUMBO_EN;
}

b53_write32(dev, B53_JUMBO_PAGE, dev->jumbo_pm_reg, port_mask);
return b53_write16(dev, B53_JUMBO_PAGE, dev->jumbo_size_reg, max_size);
}

The above function is used to enable/disable Jumbo packets using B53, but it fails to build JP for both 1000Mbps and 100Mbps if the network interface is down.

We use the following




NEXT




<s> rtk_api_ret_t rtk_ptp_refTimeEnable_get(rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_getAsicEavSysTimeCtrl(pEnable))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the enable value of the system reference time function.

A description of its parameters are as follows:

• pEnable is used to return the enable value of the system reference time function.

The following is the corresponding API reference




NEXT




<s> static char *do_filename(int argc, char *argv[])
{
return xstrdup(current_file->name);
}

The above function is used to fetch a filename.

You can't change a filename in an existing file as of

2012-08-27

so as of then, that was a problem.

That function was designed for




NEXT




<s> void set_ddr_timing(unsigned int w, unsigned int i)
{
unsigned int reg;
unsigned int wnow = 16;
unsigned int inow = 32;

/* reset all timing controls to known value (31) */
writel(DDR_PHY_TIMING_W_RST | DDR_PHY_TIMING_I_RST, DDR_PHY_TIMING);
writel(DDR_PHY_TIMING_W_RST | DDR_PHY_TIMING_I_RST | DDR_PHY_TIMING_CK,
DDR_PHY_TIMING);
writel(DDR_PHY_TIMING_W_RST | DDR_PHY_TIMING_I_RST, DDR_PHY_TIMING);

/* step up or down read delay to the requested value */
while (wnow != w) {
if (wnow < w) {
reg = DDR_PHY_TIMING_INC;
wnow++;
} else {
reg = 0;
wnow--;
}
writel(DDR_PHY_TIMING_W_CE | reg, DDR_PHY_TIMING);
writel(DDR_PHY_TIMING_CK | DDR_PHY_TIMING_W_CE | reg,
DDR_PHY_TIMING);
writel(DDR_PHY_TIMING_W_CE | reg, DDR_PHY_TIMING);
}

/* now write delay */
while (inow != i) {
if (inow < i) {
reg = DDR_PHY_TIMING_INC;
inow++;
} else {
reg = 0;
inow--;
}
writel(DDR_PHY_TIMING_I_CE | reg, DDR_PHY_TIMING);
writel(DDR_PHY_TIMING_CK | DDR_PHY_TIMING_I_CE | reg,
DDR_PHY_TIMING);
writel(DDR_PHY_TIMING_I_CE | reg, DDR_PHY_TIMING);
}
}

The above function is used to set the write and read delay timings in the DDR
timing registers. The values to be set can either be set by reading back from
the registers the present value and stepping the appropriate register up or down
towards the desired




NEXT




<s> void init_gsw(void)
{
rtl8367s_hw_init();
set_rtl8367s_sgmii();
set_rtl8367s_rgmii();
}

The above function is used to perform the hardware initialization of the RTL8367S, including initializations such as initialization of registers, interrupts, and initializations for the internal hardware to access the Ethernet port registers, including the SGMII/RGMM




NEXT




<s> int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx)
{
int max,al;
int ret = 0;
BIGNUM *tmp,*rr;

#ifdef BN_COUNT
printf("BN_sqr %d * %d\n",a->top,a->top);
#endif
bn_check_top(a);

al=a->top;
if (al <= 0)
{
r->top=0;
return(1);
}

BN_CTX_start(ctx);
rr=(a != r) ? r : BN_CTX_get(ctx);
tmp=BN_CTX_get(ctx);
if (tmp == NULL) goto err;

max=(al+al);
if (bn_wexpand(rr,max+1) == NULL) goto err;

r->neg=0;
if (al == 4)
{
#ifndef BN_SQR_COMBA
BN_ULONG t[8];
bn_sqr_normal(rr->d,a->d,4,t);
#else
bn_sqr_comba4(rr->d,a->d);
#endif
}
else if (al == 8)
{
#ifndef BN_SQR_COMBA
BN_ULONG t[16];
bn_sqr_normal(rr->d,a->d,8,t);
#else
bn_sqr_comba8(rr->d,a->d);
#endif
}
else
{
if (bn_wexpand(tmp,max) == NULL) goto err;
bn_sqr_normal(rr->d,a->d,al,tmp->d);
}

rr->top=max;
if ((max > 0) && (rr->d[max-1] == 0)) rr->top--;
if (rr != r) BN_copy(r,rr);
ret = 1;
err:
BN_CTX_end(ctx);
return(ret);
}

The above function is used to square bignums. There is a slight problem, though. If you’ve got $n$ bits and are squaring, you’ll take at least $O(n)$ time with a straightforward approach. This is because the square of




NEXT




<s> IFX_MEI_InitDevNode (int num)
{
if (num == 0) {
if ((dev_major = register_chrdev (dev_major, IFX_MEI_DEVNAME, &bsp_mei_operations)) < 0) {
IFX_MEI_EMSG ("register_chrdev(%d %s) failed!\n", dev_major, IFX_MEI_DEVNAME);
return -ENODEV;
}
}
return 0;
}

The above function is used to initialize the device node of /sys/class/misc/mei. Its prototype is as follows:

ifx_bsp_ifx_bsp_mei_operations *dev_major;
The first parameter of




NEXT




<s> static int ip175c_reset(struct ip17xx_state *state);

static const struct register_mappings IP178C = {
.NAME = "IP178C",
.MODEL_NO = 0x18,
.VLAN_DEFAULT_TAG_REG = {
{30,3},{30,4},{30,5},{30,6},{30,7},{30,8},
{30,9},{30,10},{30,11},
},

.ADD_TAG_REG = {30,12},
.ADD_TAG_BIT = {0,1,2,3,4,5,6,7,8},
.REMOVE_TAG_REG = {30,13},
.REMOVE_TAG_BIT = {4,5,6,7,8,9,10,11,12},

.SIMPLE_VLAN_REGISTERS = 1,

.VLAN_LOOKUP_REG = {31,0},// +N
.VLAN_LOOKUP_REG_5 = NOTSUPPORTED, // not used with SIMPLE_VLAN_REGISTERS
.VLAN_LOOKUP_EVEN_BIT = {0,1,2,3,4,5,6,7,8},
.VLAN_LOOKUP_ODD_BIT = {0,1,2,3,4,5,6,7,8},

.TAG_VLAN_MASK_REG = {30,14}, // +N
.TAG_VLAN_MASK_EVEN_BIT = {0,1,2,3,4,5,6,7,8},
.TAG_VLAN_MASK_ODD_BIT = {0,1,2,3,4,5,6,7,8},

.RESET_VAL = 0x55AA,
.RESET_REG = {30,0},
.MODE_VAL = 0,
.MODE_REG = NOTSUPPORTED,

.ROUTER_CONTROL_REG = {30,30},
.ROUTER_EN_BIT = 11,
.NUMLAN_GROUPS_MAX = 8,
.NUMLAN_GROUPS_BIT = 8, // {0-2}

.VLAN_CONTROL_REG = {30,13},
.TAG_VLAN_BIT = 3,

.CPU_PORT = 8,
.NUM_PORTS = 9,

.MII_REGISTER_EN = NOTSUPPORTED,

.update_state = ip175c_update_state,
.set_vlan_mode = ip175c_set_vlan_mode,
.reset = ip175c_reset,
};

The above function is used to initialize the static data for this chip on this system. This is how any
additional register mappings may be defined. (see ip175c.c, register_mappings_get(), for an
alternate mapping setup scheme




NEXT




<s> ret_t rtl8367c_getAsicIGMPdynamicRouterPort1(rtk_uint32 *port, rtk_uint32 *timer)
{
ret_t   retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_DYNAMIC_ROUTER_PORT, RTL8367C_D_ROUTER_PORT_1_MASK, port);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_DYNAMIC_ROUTER_PORT, RTL8367C_D_ROUTER_PORT_TMR_1_MASK, timer);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to access dynamic router port and timer, but the function seems always has RT_ERR_OK even if the access fail.

Could anyone tell me  why the getAsicRegBits always return RT_ERR_OK?</s>




NEXT




<s> rtk_api_ret_t rtk_l2_limitSystemLearningCntAction_get(rtk_l2_limitLearnCntAction_t *pAction)
{
rtk_api_ret_t retVal;
rtk_uint32 action;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pAction)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicSystemLutLearnOverAct(&action)) != RT_ERR_OK)
return retVal;

if ( 1 == action )
*pAction = LIMIT_LEARN_CNT_ACTION_DROP;
else if ( 0 == action )
*pAction = LIMIT_LEARN_CNT_ACTION_FORWARD;
else if ( 2 == action )
*pAction = LIMIT_LEARN_CNT_ACTION_TO_CPU;
else
*pAction = action;

return RT_ERR_OK;
}

The above function is used to retrieve the limit learning counter action on a per-port basis.

For the code example, refer to the following:

rtk_l2_limitSystemLearningCntAction_get</s>




NEXT




<s> static int rtl8366rb_get_mib_counter(struct rtl8366_smi *smi, int counter,
int port, unsigned long long *val)
{
int i;
int err;
u32 addr, data;
u64 mibvalue;

if (port > RTL8366RB_NUM_PORTS || counter >= RTL8366RB_MIB_COUNT)
return -EINVAL;

addr = RTL8366RB_MIB_COUNTER_BASE +
RTL8366RB_MIB_COUNTER_PORT_OFFSET * (port) +
rtl8366rb_mib_counters[counter].offset;

/*
* Writing access counter address first
* then ASIC will prepare 64bits counter wait for being retrived
*/
data = 0; /* writing data will be discard by ASIC */
err = rtl8366_smi_write_reg(smi, addr, data);
if (err)
return err;

/* read MIB control register */
err =  rtl8366_smi_read_reg(smi, RTL8366RB_MIB_CTRL_REG, &data);
if (err)
return err;

if (data & RTL8366RB_MIB_CTRL_BUSY_MASK)
return -EBUSY;

if (data & RTL8366RB_MIB_CTRL_RESET_MASK)
return -EIO;

mibvalue = 0;
for (i = rtl8366rb_mib_counters[counter].length; i > 0; i--) {
err = rtl8366_smi_read_reg(smi, addr + (i - 1), &data);
if (err)
return err;

mibvalue = (mibvalue << 16) | (data & 0xFFFF);
}

*val = mibvalue;
return 0;
}

The above function is used to get any of the 16 MIB counters. Currently these counters include bytes received and transmitted, as well as number of packets received and transmitted. The driver currently does not use any other MIB counters. You can find




NEXT




<s> static inline struct aca_pdmem_layout *to_pdmem_layout(struct dc_ep_priv *priv)
{
return &priv->aca.fw_info.pdmem_layout;
}

The above function is used to get a pointer to the ACA PDMEM layout. The PDMEM layout defines the size of various PDMEM buffers as well as the location in PDMEM where they are stored. You can find the PDMEM layout associated with a specific device ID by




NEXT




<s> static int ltq_atm_remove(struct platform_device *pdev)
{
int port_num;
struct ltq_atm_ops *ops = platform_get_drvdata(pdev);

ifx_mei_atm_showtime_enter = NULL;
ifx_mei_atm_showtime_exit  = NULL;

invalidate_oam_htu_entry();

ops->stop(0);

free_irq(PPE_MAILBOX_IGU1_INT, &g_atm_priv_data);

for ( port_num = 0; port_num < ATM_PORT_NUMBER; port_num++ )
atm_dev_deregister(g_atm_priv_data.port[port_num].dev);

ops->shutdown();

clear_priv_data();

return 0;
}

The above function is used to remove the LTQ ATM driver.

static struct platform_driver driver = {
};
static struct platform_device device = {
};

platform_driver_register(&driver);
platform_device_register(&device




NEXT




<s> static inline void sata_oxnas_clear_raid_error(struct ata_host *ah)
{
return;
};

The above function is used to clear the state of an error on a SATA drive. I’d previously checked for a bit mask before calling this function but have since learned that the kernel doesn’t require an SATA drive to be in the “error state.” It appears




NEXT




<s> rtk_api_ret_t rtk_i2c_gpioPinGroup_get( rtk_I2C_gpio_pin_t * pPins_group )
{
rtk_uint32 retVal;
/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pPins_group)
return RT_ERR_NULL_POINTER;
if( (retVal = rtl8367c_getAsicI2CGpioPinGroup(pPins_group) ) != RT_ERR_OK )
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the GPIO pin group setting.

Returned Value:
  1 - RT_ERR_OK   function completed OK
 < 1 - error code see "Returned Value (Error Code)"

Parameter:
 *
p




NEXT




<s> static int rtl839x_pie_rule_read(struct rtl838x_switch_priv *priv, int idx, struct  pie_rule *pr)
{
/* Read IACL table (2) via register 0 */
struct table_reg *q = rtl_table_get(RTL8380_TBL_0, 2);
u32 r[17];
int block = idx / PIE_BLOCK_SIZE;
u32 t_select = sw_r32(RTL839X_ACL_BLK_TMPLTE_CTRL(block));

memset(pr, 0, sizeof(*pr));
rtl_table_read(q, idx);
for (int i = 0; i < 17; i++)
r[i] = sw_r32(rtl_table_data(q, i));

rtl_table_release(q);

rtl839x_read_pie_fixed_fields(r, pr);
if (!pr->valid)
return 0;

pr_debug("%s: template_selectors %08x, tid: %d\n", __func__, t_select, pr->tid);
rtl839x_pie_rule_dump_raw(r);

rtl839x_read_pie_templated(r, pr, fixed_templates[(t_select >> (pr->tid * 3)) & 0x7]);

rtl839x_read_pie_action(r, pr);

return 0;
}

The above function is used to read rules stored in an IACL table.  In
the read_and_update_rules function (later), the above function is called
to read the rules from the IACL tables.   These tables are loaded by the




NEXT




<s> static int esw_probe(struct platform_device *pdev)
{
struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
struct device_node *np = pdev->dev.of_node;
const __be32 *port_map, *port_disable, *reg_init;
struct rt305x_esw *esw;

esw = devm_kzalloc(&pdev->dev, sizeof(*esw), GFP_KERNEL);
if (!esw)
return -ENOMEM;

esw->dev = &pdev->dev;
esw->irq = irq_of_parse_and_map(np, 0);
esw->base = devm_ioremap_resource(&pdev->dev, res);
if (IS_ERR(esw->base))
return PTR_ERR(esw->base);

port_map = of_get_property(np, "mediatek,portmap", NULL);
if (port_map)
esw->port_map = be32_to_cpu(*port_map);

port_disable = of_get_property(np, "mediatek,portdisable", NULL);
if (port_disable)
esw->port_disable = be32_to_cpu(*port_disable);

reg_init = of_get_property(np, "ralink,fct2", NULL);
if (reg_init)
esw->reg_initval_fct2 = be32_to_cpu(*reg_init);

reg_init = of_get_property(np, "ralink,fpa2", NULL);
if (reg_init)
esw->reg_initval_fpa2 = be32_to_cpu(*reg_init);

reg_init = of_get_property(np, "mediatek,led_polarity", NULL);
if (reg_init)
esw->reg_led_polarity = be32_to_cpu(*reg_init);

reg_init = of_get_property(np, "mediatek,led_source", NULL);
if (reg_init)
esw->reg_led_source = be32_to_cpu(*reg_init);

esw->rst_ephy = devm_reset_control_get_exclusive(&pdev->dev, "ephy");
if (IS_ERR(esw->rst_ephy)) {
dev_err(esw->dev, "failed to get EPHY reset: %pe\n", esw->rst_ephy);
esw->rst_ephy = NULL;
}

spin_lock_init(&esw->reg_rw_lock);
platform_set_drvdata(pdev, esw);

return 0;
}

The above function is used to probe the register for RTL8101CU RTL8101EU and RTL8139RU. The function parses the properties from the device tree and initialize the registers with the values provided.






NEXT




<s> static void ag71xx_hw_disable(struct ag71xx *ag)
{
netif_stop_queue(ag->dev);

ag71xx_hw_stop(ag);
ag71xx_dma_reset(ag);

napi_disable(&ag->napi);
del_timer_sync(&ag->oom_timer);

ag71xx_rings_cleanup(ag);
}

The above function is used to disable a AG71xx net device.  To avoid
race conditions and to ensure the proper ordering of the operations,
we need to take the appropriate lock. The lock is taken in
ag71xx_stop_queue which




NEXT




<s> static void rtl930x_get_l3_nexthop(int idx, u16 *dmac_id, u16 *interface)
{
u32 v;
/* Read L3_NEXTHOP table (3) via register RTL9300_TBL_1 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_1, 3);

rtl_table_read(r, idx);
/* The table has a size of 1 register */
v = sw_r32(rtl_table_data(r, 0));
rtl_table_release(r);

*dmac_id = (v >> 7) & 0x7fff;
*interface = v & 0x7f;
}

The above function is used to convert the hardware packet ID and hardware port
number of L3_NEXTHOP table in the lookup table to the 4711 compatible values of
Dst MAC and interface to be used with 4711.





NEXT




<s> void ehci_set_usbmode(int index)
{
#define  or_txttfill_tuning	_reserved_1_[0]
u32 tmp;

__ehci_set_usbmode(index);

tmp = ehci_readl(&ghcor->or_txfilltuning);
tmp &= ~0x00ff0000;
tmp |= 0x003f0000; /* set burst pre load count to 0x40 (63 * 4 bytes)  */
tmp |= 0x16; /* set sheduler overhead to 22 * 1.267us (HS) or 22 * 6.33us (FS/LS)*/
ehci_writel(&ghcor->or_txfilltuning, tmp);

tmp = ehci_readl(&ghcor->or_txttfill_tuning);
tmp |= 0x2; /* set sheduler overhead to 2 * 6.333us */
ehci_writel(&ghcor->or_txttfill_tuning, tmp);
}

The above function is used to set the USB mode,
however, I find:
a) the parameter "index" is not used
b) the read/write data to register "ghcor->x" are not correct!
So how to setup the USB




NEXT




<s> be32dec_vect(uint32_t *dst, const unsigned char *src, size_t len)
{
size_t i;

for (i = 0; i < len / 4; i++)
dst[i] = be32dec(src + i * 4);
}

The above function is used to turn big-endian binary into 4-byte big-endian integers, such as Unix timestamps in packets. A very similar function existed before, but there was no way to pass in a byte source and get a 




NEXT




<s> mt7530_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
{
struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
u8 member = 0;
u8 etags = 0;
int i;

if (val->port_vlan < 0 || val->port_vlan >= MT7530_NUM_VLANS ||
val->len > MT7530_NUM_PORTS)
return -EINVAL;

for (i = 0; i < val->len; i++) {
struct switch_port *p = &val->value.ports[i];

if (p->id >= MT7530_NUM_PORTS)
return -EINVAL;

member |= BIT(p->id);

if (p->flags & BIT(SWITCH_PORT_FLAG_TAGGED))
etags |= BIT(p->id);
}
priv->vlan_entries[val->port_vlan].member = member;
priv->vlan_entries[val->port_vlan].etags = etags;

return 0;
}

The above function is used to set VLAN members for the specified VLAN id.

On the other hand, the get_vlan_entries function is used to get all registered VLANs from the hardware at bootup. Following is the implementation of the function :




NEXT




<s> rtk_api_ret_t rtk_rate_stormControlExtMeterIdx_get(rtk_rate_storm_group_t stormType, rtk_uint32 *pIndex)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (stormType >= STORM_GROUP_END)
return RT_ERR_SFC_UNKNOWN_GROUP;

if(NULL == pIndex)
return RT_ERR_NULL_POINTER;

switch (stormType)
{
case STORM_GROUP_UNKNOWN_UNICAST:
if ((retVal = rtl8367c_getAsicStormFilterExtUnknownUnicastMeter(pIndex))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_UNKNOWN_MULTICAST:
if ((retVal = rtl8367c_getAsicStormFilterExtUnknownMulticastMeter(pIndex))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_MULTICAST:
if ((retVal = rtl8367c_getAsicStormFilterExtMulticastMeter(pIndex))!=RT_ERR_OK)
return retVal;
break;
case STORM_GROUP_BROADCAST:
if ((retVal = rtl8367c_getAsicStormFilterExtBroadcastMeter(pIndex))!=RT_ERR_OK)
return retVal;
break;
default:
break;
}

return RT_ERR_OK;
}

The above function is used to configure rtl8367c’s storm control meter’s index and can only be configured when the following condition is true:

* The configuration interface is egress interface and is not CGDM port;
* The e




NEXT




<s> hostapd_notify_response(struct ubus_context *ctx, struct ubus_object *obj,
struct ubus_request_data *req, const char *method,
struct blob_attr *msg)
{
struct blob_attr *tb[__NOTIFY_MAX];
struct hostapd_data *hapd = get_hapd_from_object(obj);
struct wpabuf *elems;
const char *pos;
size_t len;

blobmsg_parse(notify_policy, __NOTIFY_MAX, tb,
blob_data(msg), blob_len(msg));

if (!tb[NOTIFY_RESPONSE])
return UBUS_STATUS_INVALID_ARGUMENT;

hapd->ubus.notify_response = blobmsg_get_u32(tb[NOTIFY_RESPONSE]);

return UBUS_STATUS_OK;
}

The above function is used to parse the notification. It retrieves the
response field from the notification that holds the value returned by
the client. If the notification doesn’t have the response field, it
returns an error. If the client does not have the permission to




NEXT




<s> rt305x_esw_get_led_freq(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

val->value.i = esw->led_frequency;

return 0;
}

The above function is used to set/get rt305x_esw LED driving frequency.

The function is called as follows.

1. To set the driving frequency, we call rt305x_esw_set_led() function




NEXT




<s> static void rtl83xx_phylink_validate(struct dsa_switch *ds, int port,
unsigned long *supported,
struct phylink_link_state *state)
{
struct rtl838x_switch_priv *priv = ds->priv;
__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };

pr_debug("In %s port %d, state is %d", __func__, port, state->interface);

if (!phy_interface_mode_is_rgmii(state->interface) &&
state->interface != PHY_INTERFACE_MODE_NA &&
state->interface != PHY_INTERFACE_MODE_1000BASEX &&
state->interface != PHY_INTERFACE_MODE_MII &&
state->interface != PHY_INTERFACE_MODE_REVMII &&
state->interface != PHY_INTERFACE_MODE_GMII &&
state->interface != PHY_INTERFACE_MODE_QSGMII &&
state->interface != PHY_INTERFACE_MODE_INTERNAL &&
state->interface != PHY_INTERFACE_MODE_SGMII) {
bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
dev_err(ds->dev,
"Unsupported interface: %d for port %d\n",
state->interface, port);
return;
}

/* Allow all the expected bits */
phylink_set(mask, Autoneg);
phylink_set_port_modes(mask);
phylink_set(mask, Pause);
phylink_set(mask, Asym_Pause);

/* With the exclusion of MII and Reverse MII, we support Gigabit,
* including Half duplex
*/
if (state->interface != PHY_INTERFACE_MODE_MII &&
state->interface != PHY_INTERFACE_MODE_REVMII) {
phylink_set(mask, 1000baseT_Full);
phylink_set(mask, 1000baseT_Half);
}

/* On both the 8380 and 8382, ports 24-27 are SFP ports */
if (port >= 24 && port <= 27 && priv->family_id == RTL8380_FAMILY_ID)
phylink_set(mask, 1000baseX_Full);

/* On the RTL839x family of SoCs, ports 48 to 51 are SFP ports */
if (port >= 48 && port <= 51 && priv->family_id == RTL8390_FAMILY_ID)
phylink_set(mask, 1000baseX_Full);

phylink_set(mask, 10baseT_Half);
phylink_set(mask, 10baseT_Full);
phylink_set(mask, 100baseT_Half);
phylink_set(mask, 100baseT_Full);

bitmap_and(supported, supported, mask,
__ETHTOOL_LINK_MODE_MASK_NBITS);
bitmap_and(state->advertising, state->advertising, mask,
__ETHTOOL_LINK_MODE_MASK_NBITS);
}

The above function is used to verify that no unsupported modes of link setting are requested at boot time by setting the rtl83xx_phylink_validate() function as the phylink_validate callback.</s>




NEXT




<s> static int ag71xx_mdio_wait_busy(struct ag71xx_mdio *am)
{
int i;

for (i = 0; i < AG71XX_MDIO_RETRY; i++) {
u32 busy;

udelay(AG71XX_MDIO_DELAY);

regmap_read(am->mii_regmap, AG71XX_REG_MII_IND, &busy);
if (!busy)
return 0;

udelay(AG71XX_MDIO_DELAY);
}

pr_err("%s: MDIO operation timed out\n", am->mii_bus->name);

return -ETIMEDOUT;
}

The above function is used to wait for the chipset to finish the previous MDI operation, which is blocking.

Below is the code snippet of how ag71xx module init its MDIO bus device.

int ag71xx_mdio




NEXT




<s> ret_t rtl8367c_setAsicFlowControlEgressPortIndep(rtk_uint32 port, rtk_uint32 enable)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_setAsicRegBit(RTL8367C_REG_PORT0_MISC_CFG + (port *0x20), RTL8367C_PORT0_MISC_CFG_FLOWCTRL_INDEP_OFFSET,enable);
}

The above function is used to set the RTL8367C_PORT0_MISC_CFG port,bit-22.I have tested that changing this bit,will force the traffic of the related port,to be sent under IEEE80




NEXT




<s> adm6996_perform_reset (struct adm6996_priv *priv)
{
int i;

/* initialize port and vlan settings */
for (i = 0; i < ADM_NUM_PORTS - 1; i++) {
w16(priv, adm_portcfg[i], ADM_PORTCFG_INIT |
ADM_PORTCFG_PVID(0));
}
w16(priv, adm_portcfg[5], ADM_PORTCFG_CPU);

if (priv->model == ADM6996M || priv->model == ADM6996FC) {
/* reset all PHY ports */
for (i = 0; i < ADM_PHY_PORTS; i++) {
w16(priv, ADM_PHY_PORT(i), ADM_PHYCFG_INIT);
}
}

priv->enable_vlan = 0;
priv->vlan_enabled = 0;

for (i = 0; i < ADM_NUM_PORTS; i++) {
priv->pvid[i] = 0;
}

for (i = 0; i < ADM_NUM_VLANS; i++) {
priv->vlan_id[i] = i;
priv->vlan_table[i] = 0;
priv->vlan_tagged[i] = 0;
}

if (priv->model == ADM6996M) {
/* Clear VLAN priority map so prio's are unused */
w16 (priv, ADM_VLAN_PRIOMAP, 0);

adm6996_disable_vlan(priv);
adm6996_apply_port_pvids(priv);
} else if (priv->model == ADM6996L) {
/* Clear VLAN priority map so prio's are unused */
w16 (priv, ADM_VLAN_PRIOMAP, 0);

adm6996_disable_vlan_6996l(priv);
adm6996_apply_port_pvids(priv);
}
}

The above function is used to reset the NIC and clear all the settings for the device to be used by an application to re-provision the device to meet their requirement.
To reset the device, make use of the adm_dev_reset() function as it makes




NEXT




<s> int rtl_table_write(struct table_reg *r, int idx)
{
return rtl_table_exec(r, true, idx);
}

The above function is used to write something to specified index
of a Table. An example of that is like we set the frequency of
TX antenna and RX antenna in order to achieve TX-RX isolation.</s>




NEXT




<s> void bn_sqr_words(BN_ULONG *r, BN_ULONG *a, int n)
{
assert(n >= 0);
if (n <= 0) return;
for (;;)
{
sqr64(r[0],r[1],a[0]);
if (--n == 0) break;

sqr64(r[2],r[3],a[1]);
if (--n == 0) break;

sqr64(r[4],r[5],a[2]);
if (--n == 0) break;

sqr64(r[6],r[7],a[3]);
if (--n == 0) break;

a+=4;
r+=8;
}
}

The above function is used to square a block of 64-bit data. It is called with n ≥ 0, the number of 64-bit blocks to square. The two arguments a and r both point to zero-initialized data which is to be




NEXT




<s> BigIntegerModInt(d, m)
BigInteger d;
unsigned int m;
{
return BN_mod_word(d, m);
}

The above function is used to reduce the contents of a BigInteger d to a value that is no greater than m-1. For that reason, it could be modified to return a value that is at most m/2, since we could just add m/2 later.




NEXT




<s> void rtk_hal_set_port_trunk(struct ra_switch_ioctl_data *data)
{

rtk_api_ret_t ret;
rtk_portmask_t member;
int i;

RTK_PORTMASK_CLEAR(member);
for (i = 0; i < 4; i++) {
if (data->port_map & (1 << i))
RTK_PORTMASK_PORT_SET(member, i);
}

ret = rtk_trunk_port_set(TRUNK_GROUP0, &member);
if (ret != RT_ERR_OK)
printk("rtk_trunk_port_set failed\n");

ret = rtk_trunk_distributionAlgorithm_set(RTK_WHOLE_SYSTEM, 0x7F);
if (ret != RT_ERR_OK)
printk("rtk_trunk_distributionAlgorithm_set failed\n");
}

The above function is used to create a trunk group and add members to it.

At first, the rtk_trunk_distributionAlgorithm_set function sets the trunk
port distribution algorithm for every member of group 0 to the static hashing
algorithm.




NEXT




<s> static int mt7621_ecc_correct_check(struct mt7621_nfc *nfc, u8 *sector_buf,
u8 *fdm_buf, u32 sect)
{
struct nand_chip *nand = &nfc->nand;
u32 decnum, num_error_bits, fdm_end_bits;
u32 error_locations, error_bit_loc;
u32 error_byte_pos, error_bit_pos;
int bitflips = 0;
u32 i;

decnum = ecc_read32(nfc, ECC_DECENUM);
num_error_bits = (decnum >> (sect << ERRNUM_S)) & ERRNUM_M;
fdm_end_bits = (nand->ecc.size + NFI_FDM_SIZE) << 3;

if (!num_error_bits)
return 0;

if (num_error_bits == ERRNUM_M)
return -1;

for (i = 0; i < num_error_bits; i++) {
error_locations = ecc_read32(nfc, ECC_DECEL(i / 2));
error_bit_loc = (error_locations >> ((i % 2) * DEC_EL_ODD_S)) &
DEC_EL_M;
error_byte_pos = error_bit_loc >> DEC_EL_BYTE_POS_S;
error_bit_pos = error_bit_loc & DEC_EL_BIT_POS_M;

if (error_bit_loc < (nand->ecc.size << 3)) {
if (sector_buf) {
sector_buf[error_byte_pos] ^=
(1 << error_bit_pos);
}
} else if (error_bit_loc < fdm_end_bits) {
if (fdm_buf) {
fdm_buf[error_byte_pos - nand->ecc.size] ^=
(1 << error_bit_pos);
}
}

bitflips++;
}

return bitflips;
}

The above function is used to check the number of bit-flips in the ecc sector and also to modify the ecc decumulator according to the bit-flips.

int mt7621_ecc_run_fdmfix2(struct mt




NEXT




<s> subsys_initcall(nct5104d_gpio_init);

static void __exit nct5104d_gpio_exit(void)
{
platform_device_unregister(nct5104d_gpio_pdev);
platform_driver_unregister(&nct5104d_gpio_driver);
}

The above function is used to initialize the NCT5104D GPIO driver on kernel boot up. The __init keyword means that the current function will only be compiled if CONFIG_NCT5104D is defined, otherwise the compiled image will not contain the




NEXT




<s> pwinit()
{
if(syspw == NULL) {
if((syspw = t_openpwbyname(DEFAULT_PASSWD)) == NULL)
return -1;
syspw->state = FILE_NIS;
}
return 0;
}

The above function is used to initialize a passwords file structure.

Now, let us try to do things in a different way. Instead of creating the file structure, what if I could read the password directly, using the nm_getpwnam() from the




NEXT




<s> static inline int rtl838x_mac_port_ctrl(int p)
{
return RTL838X_MAC_PORT_CTRL(p);
}

The above function is used to return the port control value for a specific port. The macro is then used to write the value back into the MAC register. Port control allows each port in a given MAC to be configured for full duplex or half duplex use. The bits in




NEXT




<s> ret_t rtl8367c_getAsicFlowControlPortPrivateJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF_MASK, pOffThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to obtain both the off and on threshold, but the first parameter is defined as unsigned int. So I'm wondering whether this would return an expected result if we use the above function ?</s>




NEXT




<s> static int mt7621_nfc_write_page_raw(struct nand_chip *nand,
const uint8_t *buf, int oob_required,
int page)
{
struct mt7621_nfc *nfc = nand_get_controller_data(nand);
int i;

nand_prog_page_begin_op(nand, page, 0, NULL, 0);

nfi_write16(nfc, NFI_CNFG, (CNFG_OP_CUSTOM << CNFG_OP_MODE_S));

nfi_write16(nfc, NFI_CON,
CON_NFI_BWR | (nand->ecc.steps << CON_NFI_SEC_S));

for (i = 0; i < nand->ecc.steps; i++) {
/* Write data */
if (buf)
mt7621_nfc_write_data(nfc, page_data_ptr(nand, buf, i),
nand->ecc.size);
else
mt7621_nfc_write_data_empty(nfc, nand->ecc.size);

/* Write FDM */
mt7621_nfc_write_data(nfc, oob_fdm_ptr(nand, i),
NFI_FDM_SIZE);

/* Write dummy ECC parity data */
mt7621_nfc_write_data_empty(nfc, nfc->spare_per_sector -
NFI_FDM_SIZE);
}

mt7621_nfc_wait_write_completion(nfc, nand);

nfi_write16(nfc, NFI_CON, 0);

return nand_prog_page_end_op(nand);
}

The above function is used to write a page from the nand. The steps involved
are (taking a look at what is been done inside):

1. set some parameters and begin a page write operation.
2. write the data to be written in an




NEXT




<s> static inline void ecc_write32(struct mt7621_nfc *nfc, u32 reg, u32 val)
{
return writel(val, nfc->ecc_regs + reg);
}

The above function is used to write register to ecc region in the MT7621 WiFi (aka Mediatek MT7622). This register can be accessed by the function call ecc_write32(). The ecc_write32() function write the




NEXT




<s> ret_t rtl8367c_setAsicForceGroupLed(rtk_uint32 groupmask, rtk_uint32 mode)
{
ret_t retVal;
rtk_uint32 i,bitmask;
CONST rtk_uint16 bits[3]= {0x0004,0x0010,0x0040};

/* Invalid input parameter */
if(groupmask > RTL8367C_LEDGROUPMASK)
return RT_ERR_OUT_OF_RANGE;

if(mode >= LEDFORCEMODE_END)
return RT_ERR_OUT_OF_RANGE;

bitmask = 0;
for(i = 0; i <  RTL8367C_LEDGROUPNO; i++)
{
if(groupmask & (1 << i))
{
bitmask = bitmask | bits[i];
}

}

retVal = rtl8367c_setAsicRegBits(RTL8367C_LED_FORCE_CTRL, RTL8367C_LED_FORCE_MODE_MASK, bitmask);

retVal = rtl8367c_setAsicRegBits(RTL8367C_LED_FORCE_CTRL, RTL8367C_FORCE_MODE_MASK, mode);

if(LEDFORCEMODE_NORMAL == mode)
retVal = rtl8367c_setAsicRegBits(RTL8367C_LED_FORCE_CTRL, RTL8367C_LED_FORCE_MODE_MASK, 0);

return retVal;
}

The above function is used to enable the LED group force ON and OFF to groupmask group and set mode bitmask LED force mode.

The function is implemented as below:

Function setAsicForceGroupLed (parameters)

1. Check if group




NEXT




<s> static void rtl931x_set_egr_filter(int port,  enum egr_filter state)
{
sw_w32_mask(0x1 << (port % 0x20), state << (port % 0x20),
RTL931X_VLAN_PORT_EGR_FLTR + (((port >> 5) << 2)));
}

The above function is used to set the EGR filter for an egress queue. There can be a total of of 0x20 outgoing traffic and each queue can have 0x128 egress filter rules. The hardware registers that have to be adjusted




NEXT




<s> static void rtl931x_vlan_tables_read(u32 vlan, struct rtl838x_vlan_info *info)
{
u32 v, w, x, y;
/* Read VLAN table (3) via register 0 */
struct table_reg *r = rtl_table_get(RTL9310_TBL_0, 3);

rtl_table_read(r, vlan);
v = sw_r32(rtl_table_data(r, 0));
w = sw_r32(rtl_table_data(r, 1));
x = sw_r32(rtl_table_data(r, 2));
y = sw_r32(rtl_table_data(r, 3));
rtl_table_release(r);

pr_debug("VLAN_READ %d: %08x %08x %08x %08x\n", vlan, v, w, x, y);
info->tagged_ports = ((u64) v) << 25 | (w >> 7);
info->profile_id = (x >> 16) & 0xf;
info->fid = w & 0x7f;				/* AKA MSTI depending on context */
info->hash_uc_fid = !!(x & BIT(31));
info->hash_mc_fid = !!(x & BIT(30));
info->if_id = (x >> 20) & 0x3ff;
info->profile_id = (x >> 16) & 0xf;
info->multicast_grp_mask = x & 0xffff;
if (x & BIT(31))
info->l2_tunnel_list_id = y >> 18;
else
info->l2_tunnel_list_id = -1;
pr_debug("%s read tagged %016llx, profile-id %d, uc %d, mc %d, intf-id %d\n", __func__,
info->tagged_ports, info->profile_id, info->hash_uc_fid, info->hash_mc_fid,
info->if_id);

/* Read UNTAG table via table register 3 */
r = rtl_table_get(RTL9310_TBL_3, 0);
rtl_table_read(r, vlan);
v = ((u64)sw_r32(rtl_table_data(r, 0))) << 25;
v |= sw_r32(rtl_table_data(r, 1)) >> 7;
rtl_table_release(r);

info->untagged_ports = v;
}

The above function is used to pull VLAN data for an I/F or tagged IFS from a table on the RTL931x chip.

If the function is modified to read the table starting from index 1,
it would read the table




NEXT




<s> ar8229_init_globals(struct ar8xxx_priv *priv)
{

/* Enable CPU port, and disable mirror port */
ar8xxx_write(priv, AR8216_REG_GLOBAL_CPUPORT,
AR8216_GLOBAL_CPUPORT_EN |
(15 << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));

/* Setup TAG priority mapping */
ar8xxx_write(priv, AR8216_REG_TAG_PRIORITY, 0xfa50);

/* Enable aging, MAC replacing */
ar8xxx_write(priv, AR8216_REG_ATU_CTRL,
0x2b /* 5 min age time */ |
AR8216_ATU_CTRL_AGE_EN |
AR8216_ATU_CTRL_LEARN_CHANGE);

/* Enable ARP frame acknowledge */
ar8xxx_reg_set(priv, AR8229_REG_QM_CTRL,
AR8229_QM_CTRL_ARP_EN);

/*
* Enable Broadcast/unknown multicast and unicast frames
* transmitted to the CPU port.
*/
ar8xxx_reg_set(priv, AR8216_REG_FLOOD_MASK,
AR8229_FLOOD_MASK_BC_DP(0) |
AR8229_FLOOD_MASK_MC_DP(0) |
AR8229_FLOOD_MASK_UC_DP(0));

/* setup MTU */
ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
AR8236_GCTRL_MTU, AR8236_GCTRL_MTU);

/* Enable MIB counters */
ar8xxx_reg_set(priv, AR8216_REG_MIB_FUNC,
AR8236_MIB_EN);

/* setup Service TAG */
ar8xxx_rmw(priv, AR8216_REG_SERVICE_TAG, AR8216_SERVICE_TAG_M, 0);
}

The above function is used to initialize the global registers on boot up
of the device.</s>




NEXT




<s> int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to read a buffer of characters and scan across the
buffer for the next occurrency of the pattern the current token is based off of.
This is used to read the lexical element the parser has just read in the input.
*/</s>




NEXT




<s> void MD5_Init (mdContext)
MD5_CTX *mdContext;
{
mdContext->i[0] = mdContext->i[1] = (UINT4)0;

/* Load magic initialization constants.
*/
mdContext->buf[0] = (UINT4)0x67452301;
mdContext->buf[1] = (UINT4)0xefcdab89;
mdContext->buf[2] = (UINT4)0x98badcfe;
mdContext->buf[3] = (UINT4)0x10325476;
}

The above function is used to initialize the private variables to their initial values.

1996 Mobius Software Co., Ltd.
1996 Yukisada Masanori</s>




NEXT




<s> static int md5_init(struct shash_desc *desc)
{
struct md5_ctx *mctx = shash_desc_ctx(desc);
//volatile struct deu_hash_t *hash = (struct deu_hash_t *) HASH_START;

mctx->byte_count = 0;
mctx->started = 0;
return 0;
}

The above function is used to initialize the state of the SHA512 algorithm. The state is initialized by setting all four 32-bit words of the state vector to zero.

## What is mctx in hash_init?

mctx is a




NEXT




<s> static void sata_oxnas_postreset(struct ata_link *link, unsigned int *classes)
{
struct ata_port *ap = link->ap;
struct sata_oxnas_host_priv *hd = ap->host->private_data;

unsigned int dev;

DPRINTK("ENTER\n");
ata_std_postreset(link, classes);

/* turn on phy error detection by removing the masks */
sata_oxnas_link_write(ap->host->ports[0], 0x0c, 0x30003);
if (hd->n_ports > 1)
sata_oxnas_link_write(ap->host->ports[1], 0x0c, 0x30003);

/* bail out if no device is present */
if (classes[0] == ATA_DEV_NONE && classes[1] == ATA_DEV_NONE) {
DPRINTK("EXIT, no device\n");
return;
}

/* go through all the devices and configure them */
for (dev = 0; dev < ATA_MAX_DEVICES; ++dev) {
if (ap->link.device[dev].class == ATA_DEV_ATA)
sata_oxnas_dev_config(&(ap->link.device[dev]));
}

DPRINTK("EXIT\n");
}

The above function is used to reattach to a previously configured port after the reset has been cleared. It is called inside ata_dev_config_start().

The following function is used to read from devices attached to the given port:

static void *s




NEXT




<s> static uint32_t do_load(void)
{
image_header_t header;
uint32_t ih_size, ih_load, ih_ep;

if (spi_nor_read_id())
return UINT32_MAX;

puts("Reading image header...\n");
if (spi_nor_read_data(&header, CONFIG_IMAGE_OFFSET, sizeof(header)))
return UINT32_MAX;

if (!check_image_header(&header))
return UINT32_MAX;

header.ih_name[sizeof(header.ih_name) - 1] = 0;
ih_size = be32_to_cpu(header.ih_size);
ih_load = be32_to_cpu(header.ih_load);
ih_ep = be32_to_cpu(header.ih_ep);

put_with_label("Image Name:   ", puts, (const char *)header.ih_name);
put_with_label("Data Size:    ", put_u32, ih_size);
put_with_label("Load Address: ", put_u32, ih_load);
put_with_label("Entry Point:  ", put_u32, ih_ep);

puts("Reading image data...\n");
void *loadaddr = (void *)ih_load;
if (spi_nor_read_data(loadaddr, CONFIG_IMAGE_OFFSET + sizeof(header),
ih_size))
return false;

flush_cache(loadaddr, ih_size);

return ih_ep;
}

The above function is used to read the image data and its related information from the NOR flash using SPI. The first step is to read the image header which contains essential information about the image stored in the NOR flash. This information includes the image name, data size, load




NEXT




<s> static void rtl931x_set_igr_filter(int port, enum igr_filter state)
{
sw_w32_mask(0x3 << ((port & 0xf)<<1), state << ((port & 0xf)<<1),
RTL931X_VLAN_PORT_IGR_FLTR + (((port >> 4) << 2)));
}

The above function is used to set igr_filter bits on specific port in RTL931X.
According to the definition,
The 8 bit field is port select 4-11.
0b1 igr filter enable
0b




NEXT




<s> ssize_t routerboot_tag_show_string(const u8 *pld, u16 pld_len, char *buf)
{
return scnprintf(buf, pld_len+1, "%s\n", pld);
}

The above function is used to show the string returned by the server-side router-boot script in the case of a “string” type. If you look in your boot script, you might see something like (the actual contents will be the value used by the webapp in




NEXT




<s> ret_t rtl8367c_getAsicMeterExceedStatus(rtk_uint32 index, rtk_uint32* pStatus)
{
if(index > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(index < 32)
return rtl8367c_getAsicRegBit(RTL8367C_METER_OVERRATE_INDICATOR_REG(index), RTL8367C_METER_EXCEED_OFFSET(index), pStatus);
else
return rtl8367c_getAsicRegBit(RTL8367C_REG_METER_OVERRATE_INDICATOR2 + ((index - 32) >> 4), RTL8367C_METER_EXCEED_OFFSET(index), pStatus);
}

The above function is used to detect the alarm.</s>




NEXT




<s> ret_t rtl8367c_getAsicVlanIngressFilter(rtk_uint32 port, rtk_uint32 *pEnable)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_VLAN_INGRESS_REG, port, pEnable);
}

The above function is used to retrieve the port enable. For each register, it can be defined as follows:

typedef struct
{
rt_uint32 bit:1;
rt_uint32 bit:
…
rt_uint32




NEXT




<s> rtk_api_ret_t rtk_ptp_portTimestamp_get( rtk_port_t port, rtk_ptp_msgType_t type, rtk_ptp_info_t *pInfo)
{
rtk_api_ret_t retVal;
rtl8367c_ptp_time_stamp_t time;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port is PTP port */
RTK_CHK_PORT_IS_PTP(port);

if ((retVal = rtl8367c_getAsicEavPortTimeStamp(rtk_switch_port_L2P_get(port), type, &time)) != RT_ERR_OK)
return retVal;

pInfo->sequenceId = time.sequence_id;
pInfo->timeStamp.sec = time.second;
pInfo->timeStamp.nsec = time.nano_second;

return RT_ERR_OK;
}

The above function is used to get the PTP port timestamp of hardware.

### Note

rtk_ptp_msgType_t type only support to rtl8367c_ptp_msgType_setSync.

To use




NEXT




<s> int mtd_check_rootfs_magic(struct mtd_info *mtd, size_t offset,
enum mtdsplit_part_type *type)
{
u32 magic;
size_t retlen;
int ret;

ret = mtd_read(mtd, offset, sizeof(magic), &retlen,
(unsigned char *) &magic);
if (ret)
return ret;

if (retlen != sizeof(magic))
return -EIO;

if (le32_to_cpu(magic) == SQUASHFS_MAGIC) {
if (type)
*type = MTDSPLIT_PART_TYPE_SQUASHFS;
return 0;
} else if (magic == 0x19852003) {
if (type)
*type = MTDSPLIT_PART_TYPE_JFFS2;
return 0;
} else if (be32_to_cpu(magic) == UBI_EC_MAGIC) {
if (type)
*type = MTDSPLIT_PART_TYPE_UBI;
return 0;
}

return -EINVAL;
}

The above function is used to check the first block for the signature (magic value) of a squashfs or ext4 file system.

Here is an extract of its source code:

static int mtd_check_ec(struct mtd_info




NEXT




<s> static void bcm6348_emac_disable_mac(struct bcm6348_emac *emac)
{
int limit;
u32 val;

val = emac_readl(emac, ENET_CTL_REG);
val |= ENET_CTL_DISABLE_MASK;
emac_writel(emac, val, ENET_CTL_REG);

limit = 1000;
do {
val = emac_readl(emac, ENET_CTL_REG);
if (!(val & ENET_CTL_DISABLE_MASK))
break;
udelay(1);
} while (limit--);
}

The above function is used to disable the RMII mac functionality
during initialization process when the chip is booted up. During
initialization process, the emac does not have a valid vlan ID, in
order to make the RMII mac functionality disabled




NEXT




<s> static int lzma_decompress(unsigned char *outStream)
{
SizeT ip, op;
int ret;

lzma_state.Probs = (CProb *) workspace;

ret = LzmaDecode(&lzma_state, lzma_data, lzma_datasize, &ip, outStream,
lzma_outsize, &op);

if (ret != LZMA_RESULT_OK) {
int i;

DBG("LzmaDecode error %d at %08x, osize:%d ip:%d op:%d\n",
ret, lzma_data + ip, lzma_outsize, ip, op);

for (i = 0; i < 16; i++)
DBG("%02x ", lzma_data[ip + i]);

DBG("\n");
}

return ret;
}

The above function is used to perform decoding. The function that calls lzma_decompress is a wrapper called lzma_uncompress:

static int lzma_uncompress(unsigned char *outStream)
{
int ret;






NEXT




<s> static void udebug_netlink_hook(int tx, const void *data, size_t len)
{
struct {
uint16_t pkttype;
uint16_t arphdr;
uint16_t _pad[5];
uint16_t proto;
} hdr = {
.pkttype = host_to_be16(tx ? 7 : 6),
.arphdr = host_to_be16(824),
.proto = host_to_be16(16),
};
const struct nlmsghdr *nlh = data;
const struct genlmsghdr *gnlh = data + NLMSG_HDRLEN;
struct udebug_buf *buf = &ud_nl[!!tx];

if (nlh->nlmsg_type == 0x10)
buf = &ud_nl[2];
else if (!tx && gnlh->cmd == NL80211_CMD_FRAME &&
!(udebug_buf_flags(buf) & UDEBUG_FLAG_RX_FRAME))
return;

if (!udebug_buf_valid(buf))
return;

udebug_entry_init(buf);
udebug_entry_append(buf, &hdr, sizeof(hdr));
udebug_entry_append(buf, data, len);
udebug_entry_add(buf);
}

The above function is used to send messages from the kernel to Netlink userspace via a socket sendmsg(2) system call or using a Netlink message queue mq_send(3) call.</s>




NEXT




<s> static void rtl83xx_enable_phy_polling(struct rtl838x_switch_priv *priv)
{
u64 v = 0;

msleep(1000);
/* Enable all ports with a PHY, including the SFP-ports */
for (int i = 0; i < priv->cpu_port; i++) {
if (priv->ports[i].phy)
v |= BIT_ULL(i);
}

pr_info("%s: %16llx\n", __func__, v);
priv->r->set_port_reg_le(v, priv->r->smi_poll_ctrl);

/* PHY update complete, there is no global PHY polling enable bit on the 9300 */
if (priv->family_id == RTL8390_FAMILY_ID)
sw_w32_mask(0, BIT(7), RTL839X_SMI_GLB_CTRL);
else if(priv->family_id == RTL9300_FAMILY_ID)
sw_w32_mask(0, 0x8000, RTL838X_SMI_GLB_CTRL);
}

The above function is used to enable PHY polling. When PHY polling is enabled via this function, each port will use CPU RMII to communicate with PHY.

Unlike the 8212, 8712, 8




NEXT




<s> static void variable_del(struct variable *v)
{
list_del(&v->node);
free(v->name);
free(v->value);
free(v);
}

The above function is used to remove a variable from the list. Since the name and value is stored in 2 string, its freed using free() function. The list_del() is also used to remove the node from the list.

static int variable_add(




NEXT




<s> static void ws2812b_remove(struct spi_device *spi)
#else
static int ws2812b_remove(struct spi_device *spi)
#endif
{
struct ws2812b_priv *priv = spi_get_drvdata(spi);
int cur_led;

for (cur_led = priv->num_leds - 1; cur_led >= 0; cur_led--)
led_classdev_multicolor_unregister(&priv->leds[cur_led].mc_cdev);
kfree(priv->data_buf);
mutex_destroy(&priv->mutex);

#if LINUX_VERSION_CODE < KERNEL_VERSION(5,18,0)
return 0;
#endif
}

The above function is used to remove the leds if needed for some reason. It is called by the Kconfig script which is basically the entry point of the driver and registers the callback functions for the driver. The function first finds the current led number and starts unregistering the




NEXT




<s> static int proc_write_pp32(struct file *, const char *, unsigned long, void *);
static int stricmp(const char *, const char *);
static int strincmp(const char *, const char *, int);
static int get_token(char **, char **, int *, int *);
static int get_number(char **, int *, int);
static inline void ignore_space(char **, int *);



/*
* ####################################
*            Local Variable
* ####################################
*/



/*
* ####################################
*            Local Function
* ####################################
*/

static inline void proc_file_create(void)
{
struct proc_dir_entry *res;

res = create_proc_entry("driver/ifx_ptm/mem",
0,
NULL);
if ( res != NULL )
res->write_proc = proc_write_mem;
else
printk("%s:%s:%d: failed to create proc mem!", __FILE__, __func__, __LINE__);

res = create_proc_entry("driver/ifx_ptm/pp32",
0,
NULL);
if ( res != NULL ) {
res->read_proc = proc_read_pp32;
res->write_proc = proc_write_pp32;
}
else
printk("%s:%s:%d: failed to create proc pp32!", __FILE__, __func__, __LINE__);
}

The above function is used to creat proc directory and proc file. It is created during initialization because it is executed by the function
driver_init() which is executed in module init().




static int proc_write_mem(struct file *filep,




NEXT




<s> static void ip17xx_reset_vlan_config(struct ip17xx_state *state)
{
int i;

state->remove_tag = (state->vlan_enabled ? ((1<<state->regs->NUM_PORTS)-1) : 0x0000);
state->add_tag = 0x0000;
for (i = 0; i < MAX_VLANS; i++) {
state->vlans[i].ports = 0x0000;
state->vlans[i].tag = (i ? i : 16);
}
for (i = 0; i < MAX_PORTS; i++)
state->ports[i].pvid = 0;
}

The above function is used to reset the VLAN config for the 17xx series switches. Looking at it, the remove_tag and add_tag masks are set to zero, which means that all VLANS are removed. If you don’t want this




NEXT




<s> static void qca807x_sfp_remove(void *upstream)
{
struct phy_device *phydev = upstream;

/* Select copper page */
phy_set_bits(phydev,
QCA807X_CHIP_CONFIGURATION,
QCA807X_BT_BX_REG_SEL);

phydev->port = PORT_TP;
}

The above function is used to reset the MAC when the
board goes with cable connection
(see: qca807x_sfp_tx_setup()).

If we don't reset before, the NIC cannot go MAC link up
proper




NEXT




<s> rtk_api_ret_t rtk_mirror_override_set(rtk_enable_t rxMirror, rtk_enable_t txMirror, rtk_enable_t aclMirror)
{
rtk_api_ret_t retVal;

if( (rxMirror >= RTK_ENABLE_END) || (txMirror >= RTK_ENABLE_END) || (aclMirror >= RTK_ENABLE_END))
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicPortMirrorOverride((rtk_uint32)rxMirror, (rtk_uint32)txMirror, (rtk_uint32)aclMirror)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set mirror of all traffic on an ingress or egress port to a given port. It has been found that this function could be optimized by eliminating the unnecessary condition check of parameter value. When port 1 is selected as RX/




NEXT




<s> static u64 rtl839x_read_l2_entry_using_hash(u32 hash, u32 pos, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL8390_TBL_L2, 0);
u32 idx = (0 << 14) | (hash << 2) | pos; /* Search SRAM, with hash and at pos in bucket */

rtl_table_read(q, idx);
for (int i = 0; i < 3; i++)
r[i] = sw_r32(rtl_table_data(q, i));

rtl_table_release(q);

rtl839x_fill_l2_entry(r, e);
if (!e->valid)
return 0;

return rtl839x_l2_hash_seed(ether_addr_to_u64(&e->mac[0]), e->rvid);
}

The above function is used to lookup the MAC address or the ARP cache entry in HASH table. As the address of the
MAC address in memory is defined by ether_addr_to_u64() API which take the MAC address as parameter and return a




NEXT




<s> static int mt7621_nfc_read_page_hwecc(struct nand_chip *nand, uint8_t *buf,
int oob_required, int page)
{
struct mt7621_nfc *nfc = nand_get_controller_data(nand);
struct mtd_info *mtd = nand_to_mtd(nand);
int bitflips = 0, ret = 0;
int rc, i;

nand_read_page_op(nand, page, 0, NULL, 0);

nfi_write16(nfc, NFI_CNFG, (CNFG_OP_CUSTOM << CNFG_OP_MODE_S) |
CNFG_READ_MODE | CNFG_AUTO_FMT_EN | CNFG_HW_ECC_EN);

mt7621_ecc_decoder_op(nfc, true);

nfi_write16(nfc, NFI_CON,
CON_NFI_BRD | (nand->ecc.steps << CON_NFI_SEC_S));

for (i = 0; i < nand->ecc.steps; i++) {
if (buf)
mt7621_nfc_read_data(nfc, page_data_ptr(nand, buf, i),
nand->ecc.size);
else
mt7621_nfc_read_data_discard(nfc, nand->ecc.size);

rc = mt7621_ecc_decoder_wait_done(nfc, i);

mt7621_nfc_read_sector_fdm(nfc, i);

if (rc < 0) {
ret = -EIO;
continue;
}

rc = mt7621_ecc_correct_check(nfc,
buf ? page_data_ptr(nand, buf, i) : NULL,
oob_fdm_ptr(nand, i), i);

if (rc < 0) {
dev_dbg(nfc->dev,
"Uncorrectable ECC error at page %d.%d\n",
page, i);
bitflips = nand->ecc.strength + 1;
mtd->ecc_stats.failed++;
} else {
if (rc > bitflips)
bitflips = rc;
mtd->ecc_stats.corrected += rc;
}
}

mt7621_ecc_decoder_op(nfc, false);

nfi_write16(nfc, NFI_CON, 0);

if (ret < 0)
return ret;

return bitflips;
}

The above function is used to read the page data. The page data is first written to a NFI memory. In the ECC controller, the NFI read write address is set to the ECC buffer address. Here, the 16-bit word is set using




NEXT




<s> static int rtl8366s_set_vlan_mc(struct rtl8366_smi *smi, u32 index,
const struct rtl8366_vlan_mc *vlanmc)
{
u32 data[2];
int err;
int i;

if (index >= RTL8366S_NUM_VLANS ||
vlanmc->vid >= RTL8366S_NUM_VIDS ||
vlanmc->priority > RTL8366S_PRIORITYMAX ||
vlanmc->member > RTL8366S_VLAN_MEMBER_MASK ||
vlanmc->untag > RTL8366S_VLAN_UNTAG_MASK ||
vlanmc->fid > RTL8366S_FIDMAX)
return -EINVAL;

data[0] = (vlanmc->vid & RTL8366S_VLAN_VID_MASK) |
((vlanmc->priority & RTL8366S_VLAN_PRIORITY_MASK) <<
RTL8366S_VLAN_PRIORITY_SHIFT);
data[1] = (vlanmc->member & RTL8366S_VLAN_MEMBER_MASK) |
((vlanmc->untag & RTL8366S_VLAN_UNTAG_MASK) <<
RTL8366S_VLAN_UNTAG_SHIFT) |
((vlanmc->fid & RTL8366S_VLAN_FID_MASK) <<
RTL8366S_VLAN_FID_SHIFT);

for (i = 0; i < 2; i++) {
err = rtl8366_smi_write_reg(smi,
RTL8366S_VLAN_MC_BASE(index) + i,
data[i]);
if (err)
return err;
}

return 0;
}

The above function is used to set the multi-cast group configuration.</s>




NEXT




<s> static int rtl83xx_parse_fwd(struct rtl838x_switch_priv *priv,
const struct flow_action_entry *act, struct rtl83xx_flow *flow)
{
struct net_device *dev = act->dev;
int port;

port = rtl83xx_port_is_under(dev, priv);
if (port < 0) {
netdev_info(dev, "%s: not a DSA device.\n", __func__);
return -EINVAL;
}

flow->rule.fwd_sel = true;
flow->rule.fwd_data = port;
pr_debug("Using port index: %d\n", port);
rtl83xx_flow_bypass_all(flow);

return 0;
}

The above function is used to set the switch flow to FORWARD instead of DROP. The function will get the port index and send it to
rtl83xx_flow_bypass_all.

Dedicated driver port
=====================





NEXT




<s> ret_t rtl8367c_setAsicSvlanIngressUntag(rtk_uint32 mode)
{
return rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UNTAG_MASK, mode);
}

The above function is used to define the untagged SVLAN traffic into ingress untagged VLAN ID based on VLAN tag to be forwarded.

In order to check the forwarding information based on the SVLAN attribute information, the following function should be




NEXT




<s> static void rtl839x_vlan_fwd_on_inner(int port, bool is_set)
{
if (is_set)
rtl839x_mask_port_reg_be(BIT_ULL(port), 0ULL, RTL839X_VLAN_PORT_FWD);
else
rtl839x_mask_port_reg_be(0ULL, BIT_ULL(port), RTL839X_VLAN_PORT_FWD);
}

The above function is used to enable VLAN forwarding on inner packet.
It is called for inner tagged packet forwarding when the VLAN tag is
recognized and packet is in inner path. But for inner packet without
VLAN tag, this function is NOT




NEXT




<s> rtk_uint32 rtk_switch_maxMeterId_get(void)
{
if(init_state != INIT_COMPLETED)
return 0x00;

return (halCtrl->max_meter_id);
}

The above function is used to check if the current driver is running on a non x5g based switch.

rtk_uint32 rtk_switch_isPortFpgaBased_get(void)

{
switch(halCtrl->type




NEXT




<s> static int rtl839x_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
{
return rtl839x_mdio_read_paged(bus, mii_id, 0, regnum);
}

The above function is used to read MII regs in MIDL bus. This bug is
triggered in case of "invalid regnum" since it returns "mii_if_err(-1)"
immediately. So the original sequence like this:




NEXT




<s> static void __md5_Transform(uint32_t [4], const unsigned char [64]);


#define MD5_MAGIC_STR "$1$"
#define MD5_MAGIC_LEN (sizeof(MD5_MAGIC_STR) - 1)
static const unsigned char __md5__magic[] = MD5_MAGIC_STR;


#ifdef i386
#define __md5_Encode memcpy
#define __md5_Decode memcpy
#else /* i386 */

/*
* __md5_Encodes input (uint32_t) into output (unsigned char). Assumes len is
* a multiple of 4.
*/
static void
__md5_Encode(unsigned char *output, uint32_t *input, unsigned int len)
{
unsigned int i, j;

for (i = 0, j = 0; j < len; i++, j += 4) {
output[j] = input[i];
output[j+1] = (input[i] >> 8);
output[j+2] = (input[i] >> 16);
output[j+3] = (input[i] >> 24);
}
}

The above function is used to transform a uint32_t array into an unsign
character array. The following defines a __md5_Decode function that
performs the inverse operation:
*/
static void
__md5_Decode(uint32_




NEXT




<s> static int ip17xx_set_phy(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int new_reg = val->value.i;

if (new_reg < 0 || new_reg > 31)
state->proc_mii.p = (u16)-1;
else
state->proc_mii.p = (u16)new_reg;
return 0;
}

The above function is used to set p-value (which is equal to the mii register address) in the state data of a switch chip. The switch chip stores the register value of this p-value in its own data structure and performs register access via this p-value




NEXT




<s> rtk_api_ret_t rtk_port_phyEnableAll_set(rtk_enable_t enable)
{
rtk_api_ret_t retVal;
rtk_uint32 data;
rtk_uint32 port;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicPortEnableAll(enable)) != RT_ERR_OK)
return retVal;

RTK_SCAN_ALL_LOG_PORT(port)
{
if(rtk_switch_isUtpPort(port) == RT_ERR_OK)
{
if ((retVal = rtk_port_phyReg_get(port, PHY_CONTROL_REG, &data)) != RT_ERR_OK)
return retVal;

if (ENABLED == enable)
{
data &= 0xF7FF;
data |= 0x0200;
}
else
{
data |= 0x0800;
}

if ((retVal = rtk_port_phyReg_set(port, PHY_CONTROL_REG, data)) != RT_ERR_OK)
return retVal;
}
}

return RT_ERR_OK;

}

The above function is used to enable the interface to all ports without interrupting the interface when the function phyEnable is supported. The input parameter enables is used to set the interface of the enabled port or disabled port. If the supported function is phyEnable, you can use




NEXT




<s> int BN_add_word(BIGNUM *a, BN_ULONG w)
{
BN_ULONG l;
int i;

if (a->neg)
{
a->neg=0;
i=BN_sub_word(a,w);
if (!BN_is_zero(a))
a->neg=!(a->neg);
return(i);
}
w&=BN_MASK2;
if (bn_wexpand(a,a->top+1) == NULL) return(0);
i=0;
for (;;)
{
l=(a->d[i]+(BN_ULONG)w)&BN_MASK2;
a->d[i]=l;
if (w > l)
w=1;
else
break;
i++;
}
if (i >= a->top)
a->top++;
return(1);
}

The above function is used to add a "word" into the "a" number represented through BIGNUM structure.

You can see that the word w is limited to just 2^31 bits.

In an unsigned long long data type we can store




NEXT




<s> static void fe_tx_dma_write_desc(struct fe_tx_ring *ring, struct fe_map_state *st)
{
fe_set_txd(&st->txd, &ring->tx_dma[st->ring_idx]);
memset(&st->txd, 0, sizeof(st->txd));
st->txd.txd4 = st->def_txd4;
st->ring_idx = NEXT_TX_DESP_IDX(st->ring_idx);
}

The above function is used to perform a DMA write and then set up some DMA registers.

The following code has an obvious bug:

fe_dma_stop(&ring->dma_txd) was written in an optimised style of

> while(




NEXT




<s> static int rtl8367b_get_mc_index(struct rtl8366_smi *smi, int port, int *val)
{
u32 data;
int err;

if (port >= RTL8367B_NUM_PORTS)
return -EINVAL;

REG_RD(smi, RTL8367B_VLAN_PVID_CTRL_REG(port), &data);

*val = (data >> RTL8367B_VLAN_PVID_CTRL_SHIFT(port)) &
RTL8367B_VLAN_PVID_CTRL_MASK;

return 0;
}

The above function is used to get the MC index from vlan_pvid_ctrl register.</s>




NEXT




<s> static struct expr *rewrite_m(struct expr *e)
{
if (!e)
return e;

switch (e->type) {
case E_NOT:
e->left.expr = rewrite_m(e->left.expr);
break;
case E_OR:
case E_AND:
e->left.expr = rewrite_m(e->left.expr);
e->right.expr = rewrite_m(e->right.expr);
break;
case E_SYMBOL:
/* change 'm' into 'm' && MODULES */
if (e->left.sym == &symbol_mod)
return expr_alloc_and(e, expr_alloc_symbol(modules_sym));
break;
default:
break;
}
return e;
}

The above function is used to produce a valid module expression. You can
see in the code that it does not contain any statements but all
expressions.
So here below, I've added a statement:

    case E_SYMBOL:
/* change '




NEXT




<s> ret_t rtl8367c_setAsicEavPortInterruptStatus(rtk_uint32 port, rtk_uint32 ims)
{

if(port > RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(port < 5)
return rtl8367c_setAsicRegBits(RTL8367C_EAV_PORT_CFG_REG(port), RTL8367C_PTP_INTR_MASK,ims);
else if(port == 5)
return rtl8367c_setAsicRegBits(RTL8367C_REG_P5_EAV_CFG, RTL8367C_PTP_INTR_MASK,ims);
else if(port == 6)
return rtl8367c_setAsicRegBits(RTL8367C_REG_P6_EAV_CFG, RTL8367C_PTP_INTR_MASK,ims);
else if(port == 7)
return rtl8367c_setAsicRegBits(RTL8367C_REG_P7_EAV_CFG, RTL8367C_PTP_INTR_MASK,ims);
else if(port == 8)
return rtl8367c_setAsicRegBits(RTL8367C_REG_P8_EAV_CFG, RTL8367C_PTP_INTR_MASK,ims);
else if(port == 9)
return rtl8367c_setAsicRegBits(RTL8367C_REG_P9_EAV_CFG, RTL8367C_PTP_INTR_MASK,ims);

return RT_ERR_OK;
}

The above function is used to set Interrupt Status for ASIC EAV Port.

rtk_uint32 ims;
rtl8367c_setAsicEavPortInterruptStatus(0, 0xffffffff);





NEXT




<s> static struct hash_type *get_hash_type(const char *name)
{
int i;

for (i = 0; i < ARRAY_SIZE(types); i++) {
struct hash_type *t = &types[i];

if (!strcmp(t->name, name))
return t;
}
return NULL;
}

The above function is used to get a struct hash_type based on the string passed to it, in the following function it is passed as the argument for a case statement:

switch_type_name:
{
case “string”:
set = string;




NEXT




<s> ret_t rtl8367c_getAsicGreenHighPriorityTraffic(rtk_uint32 port, rtk_uint32* pIndicator)
{
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBit(RTL8367C_REG_HIGHPRI_INDICATOR, port, pIndicator);
}

The above function is used to read the High-Priority Indicator from green mode. However, to enable green-mode, the high-priority indicator shall be first-set on all of the ports and after that the global configuration of the Green Mode shall be enabled (setting ‘




NEXT




<s> uc_value_t *wpa_ucode_call(size_t nargs)
{
if (uc_vm_call(&vm, true, nargs) != EXCEPTION_NONE)
return NULL;

if (!gc_timer.pending)
uloop_timeout_set(&gc_timer, 10);

return uc_vm_stack_pop(&vm);
}

The above function is used to call code generated by Dynamorio, which is an extension to Linux kernel that can intercept, instrument, and profile usermode programs.

The first argument to "uc_vm_call" is a pointer to the Dynamorio user




NEXT




<s> int des_setkey(struct crypto_tfm *tfm, const u8 *key,
unsigned int keylen)
{
struct ifx_deu_des_ctx *dctx = crypto_tfm_ctx(tfm);
int err;

//printk("setkey in %s\n", __FILE__);

err = des_expand_key(&dctx->des_context, key, keylen);
if (err == -ENOKEY) {
if (crypto_tfm_get_flags(tfm) & CRYPTO_TFM_REQ_FORBID_WEAK_KEYS)
err = -EINVAL;
else
err = 0;
}

dctx->controlr_M = 0;   // des
dctx->key_length = keylen;

memcpy ((u8 *) (dctx->expkey), key, keylen);

if (err)
memset(dctx, 0, sizeof(*dctx));

return err;
}

The above function is used to set encryption key and then to expand it .

The code looks like what I have suggested . This code is in archives in form of an executable file.</s>




NEXT




<s> static void rtl839x_write_pie_action(u32 r[],  struct pie_rule *pr)
{
if (pr->drop) {
r[13] |= 0x9;	/* Set ACT_MASK_FWD & FWD_ACT = DROP */
r[13] |= BIT(3);
} else {
r[13] |= pr->fwd_sel ? BIT(3) : 0;
r[13] |= pr->fwd_act;
}
r[13] |= pr->bypass_sel ? BIT(11) : 0;
r[13] |= pr->mpls_sel ? BIT(10) : 0;
r[13] |= pr->nopri_sel ? BIT(9) : 0;
r[13] |= pr->ovid_sel ? BIT(8) : 0;
r[13] |= pr->ivid_sel ? BIT(7) : 0;
r[13] |= pr->meter_sel ? BIT(6) : 0;
r[13] |= pr->mir_sel ? BIT(5) : 0;
r[13] |= pr->log_sel ? BIT(4) : 0;

r[14] |= ((u32)(pr->fwd_data & 0x3fff)) << 18;
r[14] |= pr->log_octets ? BIT(17) : 0;
r[14] |= ((u32)(pr->log_data & 0x7ff)) << 4;
r[14] |= (pr->mir_data & 0x3) << 3;
r[14] |= ((u32)(pr->meter_data >> 7)) & 0x7;
r[15] |= (u32)(pr->meter_data) << 26;
r[15] |= ((u32)(pr->ivid_act) << 23) & 0x3;
r[15] |= ((u32)(pr->ivid_data) << 9) & 0xfff;
r[15] |= ((u32)(pr->ovid_act) << 6) & 0x3;
r[15] |= ((u32)(pr->ovid_data) >> 4) & 0xff;
r[16] |= ((u32)(pr->ovid_data) & 0xf) << 28;
r[16] |= ((u32)(pr->nopri_data) & 0x7) << 20;
r[16] |= ((u32)(pr->mpls_act) & 0x7) << 20;
r[16] |= ((u32)(pr->mpls_lib_idx) & 0x7) << 20;
r[16] |= pr->bypass_all ? BIT(9) : 0;
r[16] |= pr->bypass_igr_stp ? BIT(8) : 0;
r[16] |= pr->bypass_ibc_sc ? BIT(7) : 0;
}

The above function is used to write the PIE table to the PIE register.</s>




NEXT




<s> handle_set_username(struct ead_packet *pkt, int len, int *nstate)
{
struct ead_msg *msg = &pkt->msg;
struct ead_msg_user *user = EAD_DATA(msg, user);

set_state(EAD_TYPE_SET_USERNAME); /* clear old state */
strncpy(username, user->username, sizeof(username));
username[sizeof(username) - 1] = 0;

msg = &pktbuf->msg;
msg->len = 0;

*nstate = EAD_TYPE_GET_PRIME;
return true;
}

The above function is used to handle the SET_USERNAME call while in SET_USERNAME state.

When in RAND_CHECK_DONE state, we handle the SET_USERNAME call by calling handle_set_username() with the same data. This




NEXT




<s> ret_t rtl8367c_setAsicIGMPSuppression(rtk_uint32 report_supp_enabled, rtk_uint32 leave_supp_enabled)
{
ret_t   retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_REPORT_SUPPRESSION_MASK, report_supp_enabled);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_LEAVE_SUPPRESSION_MASK, leave_supp_enabled);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure whether or not to ignore report messages based on what has been received so far, or ignore leave messages based on what has been received so far.

I need to understand more about the IGMP-V4 and MLD processes but




NEXT




<s> bss_conf_find_vlan(struct hostapd_bss_config *bss, int id)
{
struct hostapd_vlan *vlan;

for (vlan = bss->vlan; vlan; vlan = vlan->next)
if (vlan->vlan_id == id)
return vlan;

return NULL;
}

The above function is used to search for a VLAN configuration based on its ID.

# 4.4.8. CLI commands

The command
clir_vlan_delete all v <vlan_id>
is used to delete the




NEXT




<s> void free_ctx(ctx_t *ctx)
{
if (ctx) {
mbedtls_cipher_free(ctx);
free(ctx);
}
}

The above function is used to destroy a Cipher context. Calling this function will automatically free associated memory of the Cipher context, and therefore avoids memory leaks. The Cipher context shall be no longer used after this call.

Parameters

ctx
[




NEXT




<s> const char *item_str(void)
{
return item_cur->node.str;
}

The above function is used to display the name of any string or item in the world. The variable item_cur is a pointer to the item of interest. Its type is struct item_struct. The return value is item_cur->node.str. Thus, the above




NEXT




<s> ret_t rtl8367c_setAsicForceLed(rtk_uint32 port, rtk_uint32 group, rtk_uint32 mode)
{
rtk_uint16 regAddr;
ret_t retVal;

/* Invalid input parameter */
if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(group >= RTL8367C_LEDGROUPNO)
return RT_ERR_OUT_OF_RANGE;

if(mode >= LEDFORCEMODE_END)
return RT_ERR_OUT_OF_RANGE;
/* Set Related Registers */
if(port < 8){
regAddr = RTL8367C_LED_FORCE_MODE_BASE + (group << 1);
if((retVal = rtl8367c_setAsicRegBits(regAddr, 0x3 << (port * 2), mode)) != RT_ERR_OK)
return retVal;
}else if(port >= 8){
regAddr = RTL8367C_REG_CPU_FORCE_LED0_CFG1 + (group << 1);
if((retVal = rtl8367c_setAsicRegBits(regAddr, 0x3 << ((port-8) * 2), mode)) != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set Asic Force Led, it should be called under the flow control.
The value of port is between the 0~15, the value of group is between the 0~15.
The value of Mode is one of




NEXT




<s> ret_t rtl8367c_getAsicFlowControlEgressPortIndep(rtk_uint32 port, rtk_uint32 *pEnable)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_PORT0_MISC_CFG + (port *0x20),RTL8367C_PORT0_MISC_CFG_FLOWCTRL_INDEP_OFFSET,pEnable);
}

The above function is used to enable/disable flow control in asic. But, if there exists a packet with Ethernet header size greater than 1514 bytes, the L3 header will be copied to packet buffer memory. But, because the RTL8




NEXT




<s> void at91_init_uarts(void)
{
int i;

port_detected = 0;
AT91F_DBGU_CfgPIO();
AT91F_US0_CfgPIO();
AT91F_US0_CfgPMC();

for(i=0; i<MAX_UARTS; i++) {
us = usa[i];
AT91F_US_ResetRx((AT91PS_USART)us);
AT91F_US_ResetTx((AT91PS_USART)us);

// Configure DBGU
AT91F_US_Configure(
(AT91PS_USART)us, // DBGU base address
AT91C_MASTER_CLOCK,            // 60 MHz
AT91C_US_ASYNC_MODE,           // mode Register to be programmed
115200,                        // baudrate to be programmed
0                              // timeguard to be programmed
);

// Enable Transmitter
AT91F_US_EnableTx((AT91PS_USART)us);
// Enable Receiver
AT91F_US_EnableRx((AT91PS_USART)us);
}
us = usa[0];
}

The above function is used to config the USART peripheral of AT91SAM devices. By using this function, I hope it can help to accelerate the process of learning serial communication</s>




NEXT




<s> ret_t rtl8367c_getAsicPortUnknownDaFloodingPortmask(rtk_uint32 *pPortmask)
{
return rtl8367c_getAsicReg(RTL8367C_UNUCAST_FLOADING_PMSK_REG, pPortmask);
}

The above function is used to get the mask of the unknown Da flooding port of 8367.

By default the bit 0 is the first port in the HW port list.

So port 0, 1, 2, 




NEXT




<s> hostapd_rrm_print_nr(struct hostapd_neighbor_entry *nr)
{
const u8 *data;
char *str;
int len;

blobmsg_printf(&b, "", MACSTR, MAC2STR(nr->bssid));

str = blobmsg_alloc_string_buffer(&b, "", nr->ssid.ssid_len + 1);
memcpy(str, nr->ssid.ssid, nr->ssid.ssid_len);
str[nr->ssid.ssid_len] = 0;
blobmsg_add_string_buffer(&b);

len = wpabuf_len(nr->nr);
str = blobmsg_alloc_string_buffer(&b, "", 2 * len + 1);
wpa_snprintf_hex(str, 2 * len + 1, wpabuf_head_u8(nr->nr), len);
blobmsg_add_string_buffer(&b);
}

The above function is used to print the beacon report. When I check the code for the beacon structure, the buffer for the ssid is 32 whereas I set the ssid to be of length 9 only. I am not sure whether the issue is at




NEXT




<s> void ase_stop(int pp32)
{
/*  halt PP32   */
IFX_REG_W32(DBG_CTRL_STOP, PP32_DBG_CTRL);
}

The above function is used to stop the target system.

The following file can be used to halt the target system using the PSC module.

/boot/asm/arch/ppc405xx/hal_ppc4xx/hal_ps




NEXT




<s> ret_t rtl8367c_setAsicI2CcheckRxAck(void)
{
rtk_uint32 regData;
ret_t retVal;
rtk_uint32 count = 0;

do{
count++;
if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_SLV_ACK_FLAG_OFFSET, &regData)) != RT_ERR_OK)
return retVal;
}while( (regData != 0x1) && (count < TIMEROUT_FOR_MICROSEMI) );

if(regData != 0x1)
return RT_ERR_FAILED;
else
return RT_ERR_OK;
}

The above function is used to verify ACK is returned from target IC after I2C data transmission. As I said in the previous post, this check is not always necessary. The function should be only triggered when I2C speed is set at 400KHz




NEXT




<s> static int ip_phy_read(struct ip17xx_state *state, int port, int reg)
{
int val = mdiobus_read(state->mii_bus, port, reg);
if (val < 0)
pr_warn("IP17xx: Unable to get MII register %d,%d: error %d\n", port, reg, -val);
#ifdef DUMP_MII_IO
else
pr_debug("IP17xx: Read MII(%d,%d) -> %04x\n", port, reg, val);
#endif
return val;
}

The above function is used to read the value of the phy register, when you try to compile the code it
complains.

mdiobus_read(..mii_bus,..) is not declared.

I found this in the




NEXT




<s> rtk_api_ret_t rtk_igmp_bypassGroupRange_set(rtk_igmp_bypassGroup_t group, rtk_enable_t enabled)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(group >= IGMP_BYPASS_GROUP_END)
return RT_ERR_INPUT;

if(enabled >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIGMPBypassGroup(group, enabled))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to bypass a group on the input port.
The rtk_igmp_bypassGroupRange_set() function can be used to config or disable the bypass of many IGMP groups at the same time.
Use it in




NEXT




<s> void rtl8380_get_version(struct rtl838x_switch_priv *priv)
{
u32 rw_save, info_save;
u32 info;

rw_save = sw_r32(RTL838X_INT_RW_CTRL);
sw_w32(rw_save | 0x3, RTL838X_INT_RW_CTRL);

info_save = sw_r32(RTL838X_CHIP_INFO);
sw_w32(info_save | 0xA0000000, RTL838X_CHIP_INFO);

info = sw_r32(RTL838X_CHIP_INFO);
sw_w32(info_save, RTL838X_CHIP_INFO);
sw_w32(rw_save, RTL838X_INT_RW_CTRL);

if ((info & 0xFFFF) == 0x6275) {
if (((info >> 16) & 0x1F) == 0x1)
priv->version = RTL8380_VERSION_A;
else if (((info >> 16) & 0x1F) == 0x2)
priv->version = RTL8380_VERSION_B;
else
priv->version = RTL8380_VERSION_B;
} else {
priv->version = '-';
}
}

The above function is used to get the correct chip version from chip’s chip info register.

In order to use the function the chip should be flashed with the binary with proper chip version. The binary with chip version 8380_B_1.




NEXT




<s> void put_u16(uint16_t v)
{
put_u8(v >> 8);
put_u8(v);
}

The above function is used to print a uint16_t as two uint8_t.
The below function is used to parse a uint8_t from a uint16_t stream.

uint8_t
get_u8()
{




NEXT




<s> ar8xxx_sw_get_pvid(struct switch_dev *dev, int port, int *vlan)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);

if (port < 0 || port >= AR8X16_MAX_PORTS)
return -EINVAL;

*vlan = priv->pvid[port];
return 0;
}

The above function is used to get private VLAN tag (PVID, VLAN ID, VID) mapped to the input port.

In a switch port, we can assign a VID by using 802.1Q Trunking, Egress




NEXT




<s> int rtl838x_read_phy(u32 port, u32 page, u32 reg, u32 *val)
{
int err;
u32 v;
u32 park_page;

if (port > 31) {
*val = 0xffff;
return 0;
}

if (page > 4095 || reg > 31)
return -ENOTSUPP;

mutex_lock(&smi_lock);

err = rtl838x_smi_wait_op(100000);
if (err)
goto errout;

sw_w32_mask(0xffff0000, port << 16, RTL838X_SMI_ACCESS_PHY_CTRL_2);

park_page = sw_r32(RTL838X_SMI_ACCESS_PHY_CTRL_1) & ((0x1f << 15) | 0x2);
v = reg << 20 | page << 3;
sw_w32(v | park_page, RTL838X_SMI_ACCESS_PHY_CTRL_1);
sw_w32_mask(0, 1, RTL838X_SMI_ACCESS_PHY_CTRL_1);

err = rtl838x_smi_wait_op(100000);
if (err)
goto errout;

*val = sw_r32(RTL838X_SMI_ACCESS_PHY_CTRL_2) & 0xffff;

err = 0;

errout:
mutex_unlock(&smi_lock);

return err;
}

The above function is used to issue read requests. It takes 4 parameters:

> port – the Ethernet port
> page – the memory mapped register page
> reg – the memory mapped register offset field
> val – pointer to the output of the reading




NEXT




<s> IFX_MEI_LongWordWrite (u32 ul_address, u32 ul_data)
{
IFX_MEI_WRITE_REGISTER_L (ul_data, ul_address);
wmb();
return;
}

The above function is used to write a MEI register (4 byte).

The first line is just a function to do actual write; the IFX_MEI_WRITE_REGISTER_L function is the original function we wrote in the previous post.






NEXT




<s> ar8327_sw_set_port_igmp_snooping(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
int port = val->port_vlan;

if (port >= dev->ports)
return -EINVAL;

mutex_lock(&priv->reg_mutex);
ar8327_set_port_igmp(priv, port, val->value.i);
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to enable or disable IGMP snooping feature for a given port. This feature helps in handling Multicast packets at hardware level and thereby enhances the port utilization.</s>




NEXT




<s> static int rb4xx_gpio_probe(struct platform_device *pdev)
{
struct device *dev = &pdev->dev;
struct device *parent = dev->parent;
struct rb4xx_gpio *gpio;
u32 val;

if (!parent)
return -ENODEV;

gpio = devm_kzalloc(dev, sizeof(*gpio), GFP_KERNEL);
if (!gpio)
return -ENOMEM;

platform_set_drvdata(pdev, gpio);
gpio->cpld	= dev_get_drvdata(parent);
gpio->dev	= dev;
gpio->values	= 0;
mutex_init(&gpio->lock);

gpio->chip.label		= "rb4xx-gpio";
gpio->chip.parent		= dev;
gpio->chip.owner		= THIS_MODULE;
gpio->chip.get_direction	= rb4xx_gpio_get_direction;
gpio->chip.direction_input	= rb4xx_gpio_direction_input;
gpio->chip.direction_output	= rb4xx_gpio_direction_output;
gpio->chip.get			= rb4xx_gpio_get;
gpio->chip.set			= rb4xx_gpio_set;
gpio->chip.ngpio		= 9;
gpio->chip.base			= -1;
gpio->chip.can_sleep		= 1;

if (!of_property_read_u32(dev->of_node, "base", &val))
gpio->chip.base = val;

return gpiochip_add_data(&gpio->chip, gpio);
}

The above function is used to add GPIO to device tree driver.

Static int __init rb4xx_gpio_init(void)
{
struct platform_driver *driver = NULL;

driver = platform_driver_register(&rb4xx_gpio




NEXT




<s> int AT91F_MCI_MMC_GetAllOCR (AT91PS_MciDevice pMCI_Device)
{
unsigned int	response =0x0;

while(1)
{
response = AT91F_MCI_SendCommand(pMCI_Device,
AT91C_MMC_SEND_OP_COND_CMD,
AT91C_MMC_HOST_VOLTAGE_RANGE);
if (response != AT91C_CMD_SEND_OK)
return AT91C_INIT_ERROR;

response = AT91C_BASE_MCI->MCI_RSPR[0];

if ( (response & AT91C_CARD_POWER_UP_BUSY) == AT91C_CARD_POWER_UP_BUSY)
return(response);
}
}

The above function is used to retrieve the card’s Operational Characteristics from the host driver, if you are interested to see how the card’s Operational Characteristics are retrieved from the host driver using “AT91F_MCI_MMC_Get




NEXT




<s> rtk_api_ret_t rtk_qos_dscpRemark_get(rtk_pri_t int_pri, rtk_dscp_t *pDscp)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (int_pri > RTK_PRIMAX )
return RT_ERR_QOS_INT_PRIORITY;

if ((retVal = rtl8367c_getAsicRemarkingDscpParameter(int_pri, pDscp)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the DSCP mapping relationship.

rtk_api_ret_t rtk_qos_dscpRemark_set(rtk_pri_t int_pri, rtk_dscp




NEXT




<s> static char *expand_string_with_args(const char *in, int argc, char *argv[]);
static char *expand_string(const char *in);

static void __attribute__((noreturn)) pperror(const char *format, ...)
{
va_list ap;

fprintf(stderr, "%s:%d: ", current_file->name, yylineno);
va_start(ap, format);
vfprintf(stderr, format, ap);
va_end(ap);
fprintf(stderr, "\n");

exit(1);
}

The above function is used to print error messages during the parse process. It's used in yyerror and other functions.

static char *expand_string(const char *in)
{

char *buf, *ptr1, *ptr2;





NEXT




<s> static void ag71xx_ring_rx_clean(struct ag71xx *ag)
{
struct ag71xx_ring *ring = &ag->rx_ring;
int ring_size = BIT(ring->order);
int i;

if (!ring->buf)
return;

for (i = 0; i < ring_size; i++)
if (ring->buf[i].rx_buf) {
dma_unmap_single(&ag->pdev->dev, ring->buf[i].dma_addr,
ag->rx_buf_size, DMA_FROM_DEVICE);
skb_free_frag(ring->buf[i].rx_buf);
}
}

The above function is used to clean up the incoming packets. It iterates over the array of all frames of this ring and free their buf.

int ag71xx_rx_clean(struct ag71xx *ag)
{
int rc;





NEXT




<s> static int mt7621_nfc_set_spare_per_sector(struct mt7621_nfc *nfc)
{
struct nand_chip *nand = &nfc->nand;
struct mtd_info *mtd = nand_to_mtd(nand);
u32 size;
int i;

size = nand->ecc.bytes + NFI_FDM_SIZE;

/* Find the closest supported spare size */
for (i = 0; i < ARRAY_SIZE(mt7621_nfi_spare_size); i++) {
if (mt7621_nfi_spare_size[i] >= size)
break;
}

if (unlikely(i >= ARRAY_SIZE(mt7621_nfi_spare_size))) {
dev_err(nfc->dev, "OOB size (%u) is not supported\n",
mtd->oobsize);
return -EINVAL;
}

nfc->spare_per_sector = mt7621_nfi_spare_size[i];

return i;
}

The above function is used to setup spares to be used for erasing.</s>




NEXT




<s> rtk_api_ret_t rtk_switch_portMaxPktLen_get(rtk_port_t port, rtk_switch_maxPktLen_linkSpeed_t speed, rtk_uint32 *pCfgId)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(speed >= MAXPKTLEN_LINK_SPEED_END)
return RT_ERR_INPUT;

if(NULL == pCfgId)
return RT_ERR_NULL_POINTER;

if((retVal = rtl8367c_getAsicMaxLength(rtk_switch_port_L2P_get(port), (rtk_uint32)speed, pCfgId)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get Max Packet Length. The API is called by the HNDCP application which uses maximum packet length to configure HNDCP module.

As seen in the implementation, the API is calling internal function rtl8367c_




NEXT




<s> rtl_get_ports(struct switch_dev *dev, struct switch_val *val)
{
unsigned int i, mask;

mask = rtl_get(dev, RTL_VLAN_REG(val->port_vlan, PORTMASK));
for (i = 0; i < RTL8306_NUM_PORTS; i++) {
struct switch_port *port;

if (!(mask & (1 << i)))
continue;

port = &val->value.ports[val->len];
port->id = i;
if (rtl_get(dev, RTL_PORT_REG(i, TAG_INSERT)) == 2 || i == dev->cpu_port)
port->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
val->len++;
}

return 0;
}

The above function is used to populate switch_val member val->value.ports with port_id, which is a field defined in struct switch_port:

rtl_get(dev, RTL_PORT_REG(i, TAG_INSERT))




NEXT




<s> static void bcm6348_int_cfg_writel(u32 val, u32 reg)
{
struct bcm6348_pci *priv = &bcm6348_pci;
u32 tmp;

tmp = reg & MPI_PCICFGCTL_CFGADDR_MASK;
tmp |= MPI_PCICFGCTL_WRITEEN_MASK;
__raw_writel(tmp, priv->pci + MPI_PCICFGCTL_REG);
__raw_writel(val, priv->pci + MPI_PCICFGDATA_REG);
}

The above function is used to write specific registers in our PCIe controller. I have implemented this one by using inline assembly. As we know that writing register values can be done by __raw_write_reg(address, value) it also uses inline assembly. I used it




NEXT




<s> void Uart16550Put(uint8 byte)
{
while ((UART16550_READ(OFS_LINE_STATUS) &0x20) == 0);
UART16550_WRITE(OFS_SEND_BUFFER, byte);
}

The above function is used to transmit a byte from the microprocessor via the UART to the PC over a serial cable.
After we've sent a byte, we need to check the status to see if the microprocessor can send another byte. To do that, we




NEXT




<s> rtk_api_ret_t rtk_igmp_state_set(rtk_enable_t enabled)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (enabled >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIgmp(enabled))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable/disable igmp snooping features. If the
parameter of “enabled” equals RTK_ENABLE_ENABLE, it means enable igmp snooping
features, and vice versa.

Notice that, after enabling




NEXT




<s> static int b53_port_set_link(struct switch_dev *sw_dev, int port,
struct switch_port_link *link)
{
struct b53_device *dev = sw_to_b53(sw_dev);

/*
* TODO: BCM63XX requires special handling as it can have external phys
* and ports might be GE or only FE
*/
if (is63xx(dev))
return -ENOTSUPP;

if (port == sw_dev->cpu_port)
return -EINVAL;

if (!(BIT(port) & dev->enabled_ports))
return -EINVAL;

if (link->speed == SWITCH_PORT_SPEED_1000 &&
(is5325(dev) || is5365(dev)))
return -EINVAL;

if (link->speed == SWITCH_PORT_SPEED_1000 && !link->duplex)
return -EINVAL;

return switch_generic_set_link(sw_dev, port, link);
}

The above function is used to set the speed-duplex of the ports for different SoCs e.g. BCM5315/5325/5336/5365/5103.

We do not




NEXT




<s> ret_t rtl8367c_setAsicIGMPv2Opeartion(rtk_uint32 port, rtk_uint32 igmpv2_op)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(igmpv2_op >= PROTOCOL_OP_END)
return RT_ERR_INPUT;

/* IGMPv2 operation */
if(port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV2_OP_MASK, igmpv2_op);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV2_OP_MASK, igmpv2_op);
if(retVal != RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

The above function is used to set the IGMPv2 operation feature. The parameter <port> is the logical port ID of the port which the feature is performed on.

A list of supported IGMPv2 operation is shown as below:
```




NEXT




<s> swconfig_trig_led_event(struct switch_led_trigger *sw_trig,
struct led_classdev *led_cdev)
{
struct swconfig_trig_data *trig_data;
u32 port_mask;
bool link;
u8 speed_mask, mode;
enum led_brightness led_base, led_blink;

trig_data = led_cdev->trigger_data;
if (!trig_data)
return;

read_lock(&trig_data->lock);
port_mask = trig_data->port_mask;
speed_mask = trig_data->speed_mask;
mode = trig_data->mode;
read_unlock(&trig_data->lock);

link = !!(sw_trig->port_link & port_mask);
if (!link) {
if (trig_data->prev_brightness != LED_OFF)
swconfig_trig_set_brightness(trig_data, LED_OFF); /* and stop */
}
else {
unsigned long traffic;
int speedok;	/* link speed flag */
int i;

led_base = LED_FULL;
led_blink = LED_OFF;
traffic = 0;
speedok = 0;
for (i = 0; i < SWCONFIG_LED_NUM_PORTS; i++) {
if (port_mask & (1 << i)) {
if (sw_trig->link_speed[i] & speed_mask) {
traffic += ((mode & SWCONFIG_LED_MODE_TX) ?
sw_trig->port_tx_traffic[i] : 0) +
((mode & SWCONFIG_LED_MODE_RX) ?
sw_trig->port_rx_traffic[i] : 0);
speedok = 1;
}
}
}

if (speedok) {
/* At least one port speed matches speed_mask */
if (!(mode & SWCONFIG_LED_MODE_LINK)) {
led_base = LED_OFF;
led_blink = LED_FULL;
}

if (trig_data->prev_brightness != led_base)
swconfig_trig_set_brightness(trig_data,
led_base);
else if (traffic != trig_data->prev_traffic)
swconfig_trig_set_brightness(trig_data,
led_blink);
} else if (trig_data->prev_brightness != LED_OFF)
swconfig_trig_set_brightness(trig_data, LED_OFF);

trig_data->prev_traffic = traffic;
}

trig_data->prev_link = link;
}

The above function is used to update status of leds as per configured values and then it updates trig_data and prev_brightness status of swconfig_led_trigger

To enable support for this please make below change in dts file

swconfig




NEXT




<s> static int rtl8367_set_mc_index(struct rtl8366_smi *smi, int port, int index)
{
if (port >= RTL8367_NUM_PORTS || index >= RTL8367_NUM_VLANS)
return -EINVAL;

return rtl8366_smi_rmwr(smi, RTL8367_VLAN_PVID_CTRL_REG(port),
RTL8367_VLAN_PVID_CTRL_MASK <<
RTL8367_VLAN_PVID_CTRL_SHIFT(port),
(index & RTL8367_VLAN_PVID_CTRL_MASK) <<
RTL8367_VLAN_PVID_CTRL_SHIFT(port));
}

The above function is used to set the MAC address of one of ports as a member of a multicast group. However, as pointed out in Chapter 3.2.2 of RTL8367B SDK Manual, the default configuration of RTL




NEXT




<s> psb6970_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct psb6970_priv *priv = to_psb6970(dev);
val->value.i = priv->vlan_id[val->port_vlan];
return 0;
}

The above function is used to retrieve the vid value (from the
current priv->vlan_id) for the specified virtual port (val->port_vlan). It
returns that value (in "val->value.i) as 32-bit integer




NEXT




<s> static int gpio_rb91x_key_direction_output(struct gpio_chip *gc, unsigned offset,
int value)
{
switch (offset) {
case GPIO_RB91X_KEY_NAND:
case GPIO_RB91X_KEY_PDIS:
gpio_rb91x_key_set(gc, offset, value);
return 0;
default:
return -EINVAL;
}
}

The above function is used to set the direction of the output pin of the specified GPIO. The following is a more in-depth analysis of this function.

1. Function definition

static int gpio_rb91x_key_direction_output(struct




NEXT




<s> static void ag71xx_of_bit(struct device_node *np, const char *prop,
u32 *reg, u32 mask)
{
u32 val;

if (of_property_read_u32(np, prop, &val))
return;

if (val)
*reg |= mask;
else
*reg &= ~mask;
}

The above function is used to either enable or disable PCI-E link in
PCIe device. In the patch added by Gilles, below function is used to
enable/disable the link -
ag71xx_link_enable(&ag71xx_dev




NEXT




<s> static int __init mtdsplit_squashfs_init(void)
{
register_mtd_parser(&mtdsplit_squashfs_parser);

return 0;
}

The above function is used to register an MTD parser with the system. In this case it’s the mtsplit_squashfs parser that’s being used to handle the split-squash file system images. This parser works by making use of the




NEXT




<s> static int rtl93xx_set_features(struct net_device *dev, netdev_features_t features)
{
struct rtl838x_eth_priv *priv = netdev_priv(dev);

if ((features ^ dev->features) & NETIF_F_RXCSUM) {
if (!(features & NETIF_F_RXCSUM))
sw_w32_mask(BIT(4), 0, priv->r->mac_port_ctrl(priv->cpu_port));
else
sw_w32_mask(0, BIT(4), priv->r->mac_port_ctrl(priv->cpu_port));
}

return 0;
}

The above function is used to set the features which in turn will set the MAC control register port setting which controls the checksum offload feature.</s>




NEXT




<s> ret_t rtl8367c_getAsicMaxLengthCfg(rtk_uint32 cfgId, rtk_uint32 *pMaxLength)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_MAX_LEN_RX_TX_CFG0 + cfgId, RTL8367C_MAX_LEN_RX_TX_CFG0_MASK, pMaxLength);
}

The above function is used to get maximum length for each interface(port). So if we need to configure maximum length for any interface then we have to know the above function very well.

Now as you may know that rtl8367c_getAsic




NEXT




<s> static int rtl838x_mdio_write_paged(struct mii_bus *bus, int mii_id, u16 page,
int regnum, u16 value)
{
u32 offset = 0;
struct rtl838x_eth_priv *priv = bus->priv;
int err;

if (mii_id >= 24 && mii_id <= 27 && priv->id == 0x8380) {
if (mii_id == 26)
offset = 0x100;
sw_w32(value, RTL838X_SDS4_FIB_REG0 + offset + (regnum << 2));
return 0;
}

if (regnum & (MII_ADDR_C45 | MII_ADDR_C22_MMD)) {
err = rtl838x_write_mmd_phy(mii_id, mdiobus_c45_devad(regnum),
regnum, value);
pr_debug("MMD: %d dev %x register %x write %x, err %d\n", mii_id,
mdiobus_c45_devad(regnum), mdiobus_c45_regad(regnum),
value, err);

return err;
}
err = rtl838x_write_phy(mii_id, page, regnum, value);
pr_debug("PHY: %d register %x write %x, err %d\n", mii_id, regnum, value, err);

return err;
}

The above function is used to set a register in an attached RTL830x,
RTL838x, or RTL833x chipset. It is used by RTL830x/RTL833x in combination




NEXT




<s> void ifx_deu_aes_cbc (void *ctx, uint8_t *dst, const uint8_t *src,
uint8_t *iv, size_t nbytes, int encdec, int inplace)
{
ifx_deu_aes (ctx, dst, src, iv, nbytes, encdec, 1);
}

The above function is used to perform a CBC encryption or decryption on nbytes
of data and the last nwords of iv are used as the counter. If the encryption
or decryption is in place then the last nwords of iv must be zero because nbytes




NEXT




<s> rtk_api_ret_t rtk_trap_rmaKeepFormat_get(rtk_trap_type_t type, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtl8367c_rma_t rmacfg;
rtk_uint32 tmp;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= TRAP_END)
return RT_ERR_INPUT;

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if (type >= 0 && type <= TRAP_UNDEF_GARP_2F)
{
if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.keep_format;
}
else if (type == TRAP_CDP)
{
if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.keep_format;
}
else if (type == TRAP_CSSTP)
{
if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.keep_format;
}
else if (type == TRAP_LLDP)
{
if ((retVal = rtl8367c_getAsicRmaLldp(&tmp,&rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.keep_format;
}
else
return RT_ERR_INPUT;

return RT_ERR_OK;
}

The above function is used to get the device's trap information. The parameter type refers to the specified table and the function will return the specified fields. The specific information needs to be consulted as needed.</s>




NEXT




<s> rtk_api_ret_t rtk_cpu_priRemap_set(rtk_pri_t int_pri, rtk_pri_t new_pri)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (new_pri > RTL8367C_PRIMAX || int_pri > RTL8367C_PRIMAX)
return  RT_ERR_VLAN_PRIORITY;

if ((retVal = rtl8367c_setAsicCputagPriorityRemapping(int_pri, new_pri)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to remap VLAN Priority assigned to the ports. Note, the VLAN must be configured first to a port that the port can have a remap priority.

// For remapping VLAN Priority 0 to VLAN Priority




NEXT




<s> rtk_api_ret_t rtk_vlan_init(void)
{
rtk_api_ret_t retVal;
rtk_uint32 i;
rtl8367c_user_vlan4kentry vlan4K;
rtl8367c_vlanconfiguser vlanMC;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Clean Database */
memset(vlan_mbrCfgVid, 0x00, sizeof(rtk_vlan_t) * RTL8367C_CVIDXNO);
memset(vlan_mbrCfgUsage, 0x00, sizeof(vlan_mbrCfgType_t) * RTL8367C_CVIDXNO);

/* clean 32 VLAN member configuration */
for (i = 0; i <= RTL8367C_CVIDXMAX; i++)
{
vlanMC.evid = 0;
vlanMC.mbr = 0;
vlanMC.fid_msti = 0;
vlanMC.envlanpol = 0;
vlanMC.meteridx = 0;
vlanMC.vbpen = 0;
vlanMC.vbpri = 0;
if ((retVal = rtl8367c_setAsicVlanMemberConfig(i, &vlanMC)) != RT_ERR_OK)
return retVal;
}

/* Set a default VLAN with vid 1 to 4K table for all ports */
memset(&vlan4K, 0, sizeof(rtl8367c_user_vlan4kentry));
vlan4K.vid = 1;
vlan4K.mbr = RTK_PHY_PORTMASK_ALL;
vlan4K.untag = RTK_PHY_PORTMASK_ALL;
vlan4K.fid_msti = 0;
if ((retVal = rtl8367c_setAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
return retVal;

/* Also set the default VLAN to 32 member configuration index 0 */
memset(&vlanMC, 0, sizeof(rtl8367c_vlanconfiguser));
vlanMC.evid = 1;
vlanMC.mbr = RTK_PHY_PORTMASK_ALL;
vlanMC.fid_msti = 0;
if ((retVal = rtl8367c_setAsicVlanMemberConfig(0, &vlanMC)) != RT_ERR_OK)
return retVal;

/* Set all ports PVID to default VLAN and tag-mode to original */
RTK_SCAN_ALL_PHY_PORTMASK(i)
{
if ((retVal = rtl8367c_setAsicVlanPortBasedVID(i, 0, 0)) != RT_ERR_OK)
return retVal;
if ((retVal = rtl8367c_setAsicVlanEgressTagMode(i, EG_TAG_MODE_ORI)) != RT_ERR_OK)
return retVal;
}

/* Updata Databse */
vlan_mbrCfgUsage[0] = MBRCFG_USED_BY_VLAN;
vlan_mbrCfgVid[0] = 1;

/* Enable Ingress filter */
RTK_SCAN_ALL_PHY_PORTMASK(i)
{
if ((retVal = rtl8367c_setAsicVlanIngressFilter(i, ENABLED)) != RT_ERR_OK)
return retVal;
}

/* enable VLAN */
if ((retVal = rtl8367c_setAsicVlanFilter(ENABLED)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to initialize the VLAN database. We first initialize the 32 member configuration and all VLAN_ID table entries for all ports. Then we enable the Ingress filter for MAC address and enable VLAN.

rtk_api_ret




NEXT




<s> static int wlc_pmk(wlc_param param, void *data, void *value)
{
int ret = -1;
char *str = (char *) value;
wsec_pmk_t pmk;

/* driver doesn't support GET */

if ((param & PARAM_MODE) == SET) {
strncpy(pmk.key, str, WSEC_MAX_PSK_LEN);
pmk.key_len = strlen(str);

if (pmk.key_len > WSEC_MAX_PSK_LEN)
pmk.key_len = WSEC_MAX_PSK_LEN;

pmk.flags = WSEC_PASSPHRASE;

ret = wl_ioctl(interface, WLC_SET_WSEC_PMK, &pmk, sizeof(pmk));
}

return ret;
}

The above function is used to set/get the PMK value.
static int wlc_pmk_set(wlc_param param, void *data, void *value)
{
int ret = -1;
char *str = (char *)




NEXT




<s> void des_chip_init (void);
int deu_dma_init (void);
u32 endian_swap(u32 input);
u32* memory_alignment(const u8 *arg, u32 *buff_alloc, int in_out, int nbytes);
void dma_memory_copy(u32 *outcopy, u32 *out_dma, u8 *out_arg, int nbytes);
void chip_version(void);
void deu_dma_priv_init(void);
void __exit ifxdeu_fini_dma(void);

#define DES_3DES_START  IFX_DES_CON
#define AES_START       IFX_AES_CON
#define CLC_START       IFX_DEU_CLK

/* Variables definition */
int ifx_danube_pre_1_4;
u8 *g_dma_page_ptr = NULL;
u8 *g_dma_block = NULL;
u8 *g_dma_block2 = NULL;

deu_drv_priv_t deu_dma_priv;


/*! \fn u32 endian_swap(u32 input)
*  \ingroup BOARD_SPECIFIC_FUNCTIONS
*  \brief function is not used
*  \param input Data input to be swapped
*  \return input
*/

u32 endian_swap(u32 input)
{
return input;
}

The above function is used to swap the endianess of the input arguments
on the LSB-byte, e.g.

1001 0000 (original)  -->  0000 1001 (swapped




NEXT




<s> static int qca807x_gpio(struct phy_device *phydev)
{
struct device *dev = &phydev->mdio.dev;
struct qca807x_gpio_priv *priv;
struct gpio_chip *gc;

priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
if (!priv)
return -ENOMEM;

priv->phy = phydev;

gc = devm_kzalloc(dev, sizeof(*gc), GFP_KERNEL);
if (!gc)
return -ENOMEM;

gc->label = dev_name(dev);
gc->base = -1;
gc->ngpio = 2;
gc->parent = dev;
gc->owner = THIS_MODULE;
gc->can_sleep = true;
gc->get_direction = qca807x_gpio_get_direction;
gc->direction_output = qca807x_gpio_dir_out;
gc->get = qca807x_gpio_get;
gc->set = qca807x_gpio_set;

return devm_gpiochip_add_data(dev, gc, priv);
}

The above function is used to allocate GPIOs for MDIO interface of a PHY driver. This function is called from the MDIO driver initialization code as shown below:

static int qca807x_phy_init(struct phy_device *phy




NEXT




<s> static inline uint32_t get_walk_size(uint32_t entry_len)
{
return (entry_len + 3) & ~0x03;
}

The above function is used to determine the size of the next
page-walk to perform in the TLB. The `get_walk_size` function looks at
the value of the entry_len parameter passed to the function to determine
the amount of memory that is




NEXT




<s> static int b53_spi_prepare_reg_read(struct spi_device *spi, u8 reg)
{
u8 rxbuf;
int retry_count;
int ret;

ret = b53_spi_read_reg(spi, reg, &rxbuf, 1);
if (ret)
return ret;

for (retry_count = 0; retry_count < 10; retry_count++) {
ret = b53_spi_read_reg(spi, B53_SPI_STATUS, &rxbuf, 1);
if (ret)
return ret;

if (rxbuf & B53_SPI_CMD_RACK)
break;

mdelay(1);
}

if (retry_count == 10)
return -EIO;

return 0;
}

The above function is used to check that a buffer read after it has been written by the B53 will be available to read. The “retry_count” variable is to catch B53s with latent issues.

If you see the “retry_count




NEXT




<s> ar8216_mangle_tx(struct net_device *dev, struct sk_buff *skb)
{
struct ar8xxx_priv *priv = dev->phy_ptr;
unsigned char *buf;

if (unlikely(!priv))
goto error;

if (!priv->vlan)
goto send;

if (unlikely(skb_headroom(skb) < 2)) {
if (pskb_expand_head(skb, 2, 0, GFP_ATOMIC) < 0)
goto error;
}

buf = skb_push(skb, 2);
buf[0] = 0x10;
buf[1] = 0x80;

send:
return skb;

error:
dev_kfree_skb_any(skb);
return NULL;
}

The above function is used to mangle VLAN tag when the packets are in transmission, thus the name mangle_tx.

The new skb created by this function is passed to the hardware driver to transmit through the wire. And the hardware driver will use the VLAN




NEXT




<s> adm6996_read_gpio_reg(struct adm6996_priv *priv, enum admreg reg)
{
/* cmd: 01 10 T DD R RRRRRR */
u8 bits[6] = {
0xFF, 0xFF, 0xFF, 0xFF,
(0x06 << 4) | ((0 & 0x01) << 3 | (reg&64)>>6),
((reg&63)<<2)
};

u8 rbits[4];

/* Enable GPIO outputs with all pins to 0 */
gpio_direction_output(priv->eecs, 0);
gpio_direction_output(priv->eesk, 0);
gpio_direction_output(priv->eedi, 0);

adm6996_gpio_write(priv, 0, bits, 46);
gpio_direction_input(priv->eedi);
adm6996_gpio_adclk(priv, 2);
adm6996_gpio_read(priv, 0, rbits, 32);

/* Extra clock(s) required per datasheet */
adm6996_gpio_adclk(priv, 2);

/* Disable GPIO outputs */
gpio_direction_input(priv->eecs);
gpio_direction_input(priv->eesk);

/* EEPROM has 16-bit registers, but pumps out two registers in one request */
return (reg & 0x01 ?  (rbits[0]<<8) | rbits[1] : (rbits[2]<<8) | (rbits[3]));
}

The above function is used to read register using gpio pins only.
The function starts with setting all gpio pines to 0 and then calls adm_gpio_wr</s>




NEXT




<s> static int show_all_key_value_pairs(struct tffs_key_name_table *key_names)
{
uint8_t has_value = 0;
struct tffs_entry tmp;

for (uint32_t i = 0; i < key_names->size; i++) {
if (find_entry(key_names->entries[i].id, &tmp)) {
printf("%s=", (const char *)key_names->entries[i].val);
print_entry_value(&tmp);
printf("\n");
has_value++;
free(tmp.val);
}
}

if (!has_value) {
fprintf(stderr, "ERROR: no values found!\n");
return EXIT_FAILURE;
}

return EXIT_SUCCESS;
}

The above function is used to verify that all of the entries in the
.dat file have values associated with each of them. If an entry is
found to not have a value, the program will issue an error
message, and then terminate. After the program has




NEXT




<s> static bool nmbm_try_load_info_table(struct nmbm_instance *ni, uint32_t ba,
uint32_t *eba, uint32_t *write_count,
uint32_t *mapping_blocks_top_ba,
bool table_loaded)
{
struct nmbm_info_table_header *ifthdr = (void *)ni->info_table_cache;
uint8_t *off = ni->info_table_cache;
uint32_t limit = ba + size2blk(ni, ni->info_table_size);
uint32_t start_ba = 0, chunksize, sizeremain = ni->info_table_size;
bool success, checkhdr = true;
int ret;

while (sizeremain && ba < limit) {
if (nmbm_get_block_state(ni, ba) != BLOCK_ST_GOOD)
goto next_block;

if (nmbm_check_bad_phys_block(ni, ba)) {
nmbm_set_block_state(ni, ba, BLOCK_ST_BAD);
goto next_block;
}

chunksize = sizeremain;
if (chunksize > bmtd.blk_size)
chunksize = bmtd.blk_size;

/* Assume block with ECC error has no info table data */
ret = nmbn_read_data(ni, ba2addr(ni, ba), off, chunksize);
if (ret < 0)
goto skip_bad_block;
else if (ret > 0)
return false;

if (checkhdr) {
success = nmbm_check_info_table_header(ni, off);
if (!success)
return false;

start_ba = ba;
checkhdr = false;
}

off += chunksize;
sizeremain -= chunksize;

goto next_block;

skip_bad_block:
/* Only mark bad in memory */
nmbm_set_block_state(ni, ba, BLOCK_ST_BAD);

next_block:
ba++;
}

if (sizeremain)
return false;

success = nmbm_check_header(ni->info_table_cache, ni->info_table_size);
if (!success)
return false;

*eba = ba;
*write_count = ifthdr->write_count;

success = nmbm_check_info_table(ni, start_ba, ba, ni->info_table_cache,
mapping_blocks_top_ba);
if (!success)
return false;

if (!table_loaded || ifthdr->write_count > ni->info_table.write_count) {
memcpy(&ni->info_table, ifthdr, sizeof(ni->info_table));
memcpy(ni->block_state,
(uint8_t *)ifthdr + ifthdr->state_table_off,
ni->state_table_size);
memcpy(ni->block_mapping,
(uint8_t *)ifthdr + ifthdr->mapping_table_off,
ni->mapping_table_size);
ni->info_table.write_count = ifthdr->write_count;
}

return true;
}

The above function is used to load an in-memory data into the kernel’s cache and
then into the nand chip.
The offsets in the “info_table_cache” structure are set to the offset within the
cache, the function checks the content




NEXT




<s> static void sata_oxnas_thaw(struct ata_port *ap)
{
struct sata_oxnas_host_priv *hd = ap->host->private_data;

DPRINTK("\n");
hd->port_frozen &= ~BIT(ap->port_no);
smp_wmb();
}

The above function is used to clear the bit that marks the port if
frozen.

I can think of 3 scenarios when this could happen:

1. 2 ports connected to the port but sata_oxnas_thaw has not been




NEXT




<s> static inline void oxnas_register_set_mask(void __iomem *p, unsigned mask)
{
u32 val = readl_relaxed(p);

val |= mask;
writel_relaxed(val, p);
}

The above function is used to set the mask register in a device. It takes two arguments: a pointer to a device register and a mask. It writes the mask to the register by reading the current register value, ORing the mask with that value, and writing the result back




NEXT




<s> static inline void dmac_writel(struct bcm6348_iudma *iudma, u32 val, u32 off,
int chan)
{
__raw_writel(val, iudma->dma_chan + chan * DMA_CHAN_WIDTH + off);
}

The above function is used to write to a register in a dma channel
using iudma->dma_chan structure, but as per the following
snippet, iudma->dma_chan is a pointer to the bcm6348_dma structure




NEXT




<s> static int b53_srab_write32(struct b53_device *dev, u8 page, u8 reg,
u32 value)
{
u8 __iomem *regs = dev->priv;
int ret = 0;

ret = b53_srab_request_grant(dev);
if (ret)
goto err;

writel(value, regs + B53_SRAB_WD_L);

ret = b53_srab_op(dev, page, reg, B53_SRAB_CMDSTAT_WRITE);

err:
b53_srab_release_grant(dev);

return ret;

}

The above function is used to write an address with value using SRAM access bus.

The b53_srab_request_grant() function is a critical one. If we don’t use it, the b53_srab_op()




NEXT




<s> IFX_MEI_HaltArc (DSL_DEV_Device_t * pDev)
{
u32 arc_debug_data = 0x0;

//      Switch arc control from JTAG mode to MEI mode
IFX_MEI_ControlModeSet (pDev, MEI_MASTER_MODE);
_IFX_MEI_DBGLongWordRead (pDev, MEI_DEBUG_DEC_AUX_MASK,
ARC_DEBUG, &arc_debug_data);
arc_debug_data |= ARC_DEBUG_HALT;
_IFX_MEI_DBGLongWordWrite (pDev, MEI_DEBUG_DEC_AUX_MASK,
ARC_DEBUG, arc_debug_data);
//      Switch arc control from MEI mode to JTAG mode
IFX_MEI_ControlModeSet (pDev, JTAG_MASTER_MODE);

MEI_WAIT (10);

return DSL_DEV_MEI_ERR_SUCCESS;
}

The above function is used to halt the arc in JTAG mode. I cannot find any documentation on ARC_DEBUG mask for the control register so i am guessing the arc status. I am not completely sure about the actual value here but it has worked for me.</s>




NEXT




<s> static struct wlc_call *find_cmd(char *name)
{
int found = 0, i = 0;

while (!found && (i < wlc_calls_size)) {
if (strcmp(name, wlc_calls[i].name) == 0)
found = 1;
else
i++;
}

return (struct wlc_call *) (found ? &wlc_calls[i] : NULL);
}

The above function is used to check if there exists such command which can be executed from command prompt
using which we can call a web link or a web app.</s>




NEXT




<s> static uint16_t jboot_checksum(uint16_t start_val, uint16_t *data, int size)
{
uint32_t counter = start_val;
uint16_t *ptr = data;

while (size > 1) {
counter += *ptr;
++ptr;
while (counter >> 16)
counter = (uint16_t) counter + (counter >> 16);
size -= 2;
}
if (size > 0) {
counter += *(uint8_t *) ptr;
counter -= 0xFF;
}
while (counter >> 16)
counter = (uint16_t) counter + (counter >> 16);
return counter;
}

The above function is used to create the checksum based on the first 64 bytes which are stored in little endian values.

For Jboot, the start value is always 0x19b6

Example 1:
Start value = 




NEXT




<s> yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{

The above function is used to replace:

#define yylex () parsela()

So instead of using yyparse(), call yylex() directly.

This change was necessary because I modified yyparse() to support a "debug"
flag




NEXT




<s> static void printf_output(void *arg, char *s, int l)
{
int i;

// special termination call
if ((l==1) && (s[0] == '\0')) return;

for (i=0; i< l; i++) {
board_putc(s[i]);
if (s[i] == '\n') board_putc('\r');
}
}

The above function is used to print a string to the serial output. Board_putc is defined in libbsp.a. It will, on different boards, translate that into one of many different function calls.</s>




NEXT




<s> hostapd_bss_del_ban(void *eloop_data, void *user_ctx)
{
struct ubus_banned_client *ban = eloop_data;
struct hostapd_data *hapd = user_ctx;

avl_delete(&hapd->ubus.banned, &ban->avl);
free(ban);
}

The above function is used to remove banned clients from the avl tree that hold bss.c, avl tree also holds bss_list head and is a part of ban structure. The avl tree is also used for searching banned clients. Now the issue is with




NEXT




<s> rtl_set_page(struct rtl_priv *priv, unsigned int page)
{
struct mii_bus *bus = priv->bus;
u16 pgsel;

if (priv->fixup)
return;

if (priv->page == page)
return;

BUG_ON(page > RTL8306_NUM_PAGES);
pgsel = bus->read(bus, 0, RTL8306_REG_PAGE);
pgsel &= ~(RTL8306_REG_PAGE_LO | RTL8306_REG_PAGE_HI);
if (page & (1 << 0))
pgsel |= RTL8306_REG_PAGE_LO;
if (!(page & (1 << 1))) /* bit is inverted */
pgsel |= RTL8306_REG_PAGE_HI;
bus->write(bus, 0, RTL8306_REG_PAGE, pgsel);
}

The above function is used to change page in RTL8306 switch.
When we use this to change from page 2 to page 0, the switch is not
connected as its page is 0.

How to correct this:

We




NEXT




<s> static int igmp_open(struct inode *inode, struct file *file)
{
return single_open(file, igmp_show, 0);
}

The above function is used to open the /proc/igmp pseudo file. The igmp_show function gets the current value of the kernel parameter.

Then a check is done with the following:
if ( igmp_num(kernel_param) == 




NEXT




<s> static void msdc_deinit_hw(struct msdc_host *host)
{
void __iomem *base = host->base;

/* Disable and clear all interrupts */
sdr_clr_bits(MSDC_INTEN, sdr_read32(MSDC_INTEN));
sdr_write32(MSDC_INT, sdr_read32(MSDC_INT));

/* Disable card detection */
msdc_enable_cd_irq(host, 0);
// msdc_set_power_mode(host, MMC_POWER_OFF);   /* make sure power down */ /* --- by chhung */
}

The above function is used to deinitialize hardware registers.
For example, the “base” variable points to the memory address of MSDC hardware registers:

struct msdc_host msdc_host0;
void __iomem *base = m




NEXT




<s> size_t spi_max_xfer(void)
{
return ESPI_MAX_DATA_TRANSFER_LEN;
}

The above function is used to find out the supported transfer length when the ESPI device is put in FIFO mode and the host is in blocking mode.

The max transfer length is defined inside the ecs_spi.h header.

ESPI_MAX




NEXT




<s> static int b53_mmap_read32(struct b53_device *dev, u8 page, u8 reg, u32 *val)
{
u8 __iomem *regs = dev->priv;

if (WARN_ON(reg % 4))
return -EINVAL;

if (dev->pdata && dev->pdata->big_endian)
*val = readl_be(regs + (page << 8) + reg);
else
*val = readl(regs + (page << 8) + reg);

return 0;
}

The above function is used to read registers from the device by the
kernel. The value read is stored in the parameter val.</s>




NEXT




<s> static void conf_write_symbol(FILE *fp, struct symbol *sym,
struct conf_printer *printer, void *printer_arg)
{
const char *str;

switch (sym->type) {
case S_UNKNOWN:
break;
case S_STRING:
str = sym_get_string_value(sym);
str = sym_escape_string_value(str);
printer->print_symbol(fp, sym, str, printer_arg);
free((void *)str);
break;
default:
str = sym_get_string_value(sym);
printer->print_symbol(fp, sym, str, printer_arg);
}
}

The above function is used to write strings to stdout when we type
'lsmod | less'. I was wondering how I can do the same to send it to a
script to store the string somewhere.

Currently I'm trying to use sysctl to




NEXT




<s> void AT91F_WaitKeyPressed(void)
{
int c;
puts("KEY");
c = getc();
putc('\n');
}

The above function is used to wait for a KEY press and return the char corresponding to the key

It should have been called with an ASCII number between 1 and 0x20, where each number corresponds to
a key on the keypad.




NEXT




<s> ret_t rtl8367c_setAsicIpMulticastPortIsoLeaky(rtk_uint32 port, rtk_uint32 enabled)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

retVal = rtl8367c_setAsicRegBits(RTL8367C_IPMCAST_PORTISO_LEAKY_REG, (0x0001 << port), enabled);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable/disable the given port for IP multicast port isolation leaky mode.

Note that RTL8367C supports up to 5 ports for IP multicast port isolation mode. Other 3 ports have to be




NEXT




<s> void drawrect(void *videoram, struct rect *r, const struct pixelformat *pixf, const struct vidsize *vids){
int x,y,corwidth, bpp = 0, tocopy = 1;
struct pixel pix;
unsigned char *pmem = videoram;
corwidth = r->width;	// actually only "corrected" for 4 Bit

if (pixf->pixenum!=CLUT4&&pixf->pixenum!=CLUT8){
switch (pixf->pixenum){
case ARGB1555:
case RGB565:
bpp = 16;
tocopy = 2;
break;
case ARGB:
bpp = 32;
tocopy = 4;
break;
default:
printf ("drawrect: unknown pixelformat(%d) bpp:%d\n",pixf->pixenum,pixf->bpp);
exit(1);
}
col2pixel(&pix,pixf,r->col);
} else {
switch (pixf->pixenum){	// CLUT = Colour LookUp Table (palette)
case CLUT4:	// take red value as index in this case
pix.byte[0]=(r->col->r)<<4|(r->col->r&0xf);	// slightly cryptic... "rect->colour->red"
corwidth>>=1;	// we copy bytes
bpp=4;
tocopy=1;
break;
case CLUT8:
pix.byte[0]=(r->col->r&0xff);
bpp=8;
tocopy=1;
break;
}
}
pmem=videoram+((((r->y*vids->width)+r->x)*bpp)>>3);
for (y=0;y<r->height;y++){
int offset = 0;
for (x=0;x<corwidth;x++){
memcpy (pmem+offset,pix.byte,tocopy);
offset+=tocopy;
}
pmem +=((vids->width*bpp)>>3);	// skip one whole line, actually should be taken from "fix-info"
}
}

The above function is used to draw a rectangle (r), using the given color. It actually makes a call to the function called col2pixel() which does a lookup in the given palette. The function above deals with only 8 different color and you need to set it




NEXT




<s> static int ltq_mei_probe(struct platform_device *pdev)
{
int i = 0;
static struct class *dsl_class;

pr_info("IFX MEI Version %ld.%02ld.%02ld\n", bsp_mei_version.major, bsp_mei_version.minor, bsp_mei_version.revision);

for (i = 0; i < BSP_MAX_DEVICES; i++) {
if (IFX_MEI_InitDevice (i) != 0) {
IFX_MEI_EMSG("Init device fail!\n");
return -EIO;
}
IFX_MEI_InitDevNode (i);
}
for (i = 0; i <= DSL_BSP_CB_LAST ; i++)
dsl_bsp_event_callback[i].function = NULL;

#ifdef CONFIG_LTQ_MEI_FW_LOOPBACK
IFX_MEI_DMSG("Start loopback test...\n");
DFE_Loopback_Test ();
#endif
dsl_class = class_create(THIS_MODULE, "ifx_mei");
device_create(dsl_class, NULL, MKDEV(MEI_MAJOR, 0), NULL, "ifx_mei");
return 0;
}

The above function is used to initialize the interface when the ltq_mei driver is loaded. During initialization, first the following function is called:

static int ltq_mei_probe(struct platform_device *pdev)

Afterwards,




NEXT




<s> static void ag71xx_dma_reset(struct ag71xx *ag)
{
u32 val;
int i;

ag71xx_dump_dma_regs(ag);

/* stop RX and TX */
ag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);
ag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);

/*
* give the hardware some time to really stop all rx/tx activity
* clearing the descriptors too early causes random memory corruption
*/
mdelay(1);

/* clear descriptor addresses */
ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->stop_desc_dma);
ag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->stop_desc_dma);

/* clear pending RX/TX interrupts */
for (i = 0; i < 256; i++) {
ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);
ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);
}

/* clear pending errors */
ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE | RX_STATUS_OF);
ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE | TX_STATUS_UR);

val = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
if (val)
pr_alert("%s: unable to clear DMA Rx status: %08x\n",
ag->dev->name, val);

val = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);

/* mask out reserved bits */
val &= ~0xff000000;

if (val)
pr_alert("%s: unable to clear DMA Tx status: %08x\n",
ag->dev->name, val);

ag71xx_dump_dma_regs(ag);
}

The above function is used to completely reset DMARX and DMATX
operations (used in suspend and error recovery). In this function you
note that we are clearing the DMA descriptors, clearing the interrupt
pending registers, and clearing the error status of each of the




NEXT




<s> static int rtl8366rb_switch_init(struct rtl8366_smi *smi)
{
struct switch_dev *dev = &smi->sw_dev;
int err;

dev->name = "RTL8366RB";
dev->cpu_port = RTL8366RB_PORT_NUM_CPU;
dev->ports = RTL8366RB_NUM_PORTS;
dev->vlans = RTL8366RB_NUM_VIDS;
dev->ops = &rtl8366_ops;
dev->alias = dev_name(smi->parent);

err = register_switch(dev, NULL);
if (err)
dev_err(smi->parent, "switch registration failed\n");

return err;
}

The above function is used to register device. It takes device's name, device_alias as parameters and then calls 'dev_name' function to initialize alias.

static char *dev_name(struct pci_dev *dev)
static char *dev_




NEXT




<s> void sata_oxnas_checkforhotplug(struct ata_port *ap)
{
DPRINTK("ENTER\n");

ata_ehi_hotplugged(&ap->link.eh_info);
ata_port_freeze(ap);
}

The above function is used to enable hot-plug for OXNAS, if plug is detected by ehd and hotplug is enabled, the function calls ata_port_freeze().

The above function will put the OXNAS SATA devices in




NEXT




<s> uc_bpf_set_debug_handler(uc_vm_t *vm, size_t nargs)
{
uc_value_t *handler = uc_fn_arg(0);

if (handler && !ucv_is_callable(handler))
err_return(EINVAL, NULL);

debug_vm = vm;
libbpf_set_print(handler ? uc_bpf_debug_print : NULL);

ucv_array_set(registry, 0, ucv_get(handler));

return NULL;
}

The above function is used to set a custom debug handler for the BPF programs.</s>




NEXT




<s> static inline int get_tx_desc(unsigned int, unsigned int *);

/*
*  Mailbox handler and signal function
*/
static irqreturn_t mailbox_irq_handler(int, void *);

/*
*  Tasklet to Handle Swap Descriptors
*/
static void do_swap_desc_tasklet(unsigned long);


/*
*  Init & clean-up functions
*/
static inline int init_priv_data(void);
static inline void clear_priv_data(void);
static inline int init_tables(void);
static inline void clear_tables(void);

static int g_wanqos_en = 0;

static int g_queue_gamma_map[4];

static struct ptm_priv_data g_ptm_priv_data;

static struct net_device_ops g_ptm_netdev_ops = {
.ndo_get_stats       = ptm_get_stats,
.ndo_open            = ptm_open,
.ndo_stop            = ptm_stop,
.ndo_start_xmit      = ptm_hard_start_xmit,
.ndo_validate_addr   = eth_validate_addr,
.ndo_set_mac_address = eth_mac_addr,
.ndo_do_ioctl        = ptm_ioctl,
.ndo_tx_timeout      = ptm_tx_timeout,
};

The above function is used to create a queue pair to assign the RX and TX queues in NIC driver.

This function get called in netdev_setup, if the network
driver wants to setup queue for the adapter. NM queue pair
support is




NEXT




<s> void rtl9300_sds_rxcal_3_1(int sds_num, phy_interface_t phy_mode)
{
pr_info("start_1.3.1");

/* ##1.3.1 */
if (phy_mode != PHY_INTERFACE_MODE_10GBASER && phy_mode != PHY_INTERFACE_MODE_1000BASEX)
rtl9300_sds_field_w(sds_num, 0x2e, 0xc, 8, 8, 0);

rtl9300_sds_field_w(sds_num, 0x2e, 0x17, 7, 7, 0x0);
rtl9300_sds_rxcal_leq_manual(sds_num, false, 0);

pr_info("end_1.3.1");
}

The above function is used to disable the differential amplifier. This is
necessary for the calibration of the loop equalization stage. This code is
only enabled when phy_mode is PHY_INTERFACE_MODE_10GBASER or
PHY_




NEXT




<s> static int ip175d_reset(struct ip17xx_state *state);

static const struct register_mappings IP175D = {
.NAME = "IP175D",
.MODEL_NO = 0x18,

// The IP175D has a completely different interface, so we leave most
// of the registers undefined and switch to different code paths.

.VLAN_DEFAULT_TAG_REG = {
NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,
NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,NOTSUPPORTED,
},

.ADD_TAG_REG = NOTSUPPORTED,
.REMOVE_TAG_REG = NOTSUPPORTED,

.SIMPLE_VLAN_REGISTERS = 0,

.VLAN_LOOKUP_REG = NOTSUPPORTED,
.VLAN_LOOKUP_REG_5 = NOTSUPPORTED,
.TAG_VLAN_MASK_REG = NOTSUPPORTED,

.RESET_VAL = 0x175D,
.RESET_REG = {20,2},
.MODE_REG = NOTSUPPORTED,

.ROUTER_CONTROL_REG = NOTSUPPORTED,
.ROUTER_EN_BIT = -1,
.NUMLAN_GROUPS_BIT = -1,

.VLAN_CONTROL_REG = NOTSUPPORTED,
.TAG_VLAN_BIT = -1,

.NUM_PORTS = 6,
.CPU_PORT = 5,

.MII_REGISTER_EN = NOTSUPPORTED,

.update_state = ip175d_update_state,
.set_vlan_mode = ip175d_set_vlan_mode,
.reset = ip175d_reset,
};

The above function is used to set the vlan mode of the IP175D.</s>




NEXT




<s> void variable_all_del(void)
{
struct variable *v, *tmp;

list_for_each_entry_safe(v, tmp, &variable_list, node)
variable_del(v);
}

The above function is used to destroy variable list. it works fine with kubuntu, ubuntu 11.04 and ubuntu 10.04 but doesn't work in ubuntu 7.10.</s>




NEXT




<s> static netdev_features_t rtl838x_fix_features(struct net_device *dev,
netdev_features_t features)
{
return features;
}

The above function is used to adjust net device features. 802.11AC standard supports
MCS0-MCS15 and is backward compatible to the legacy 802.11n devices.
MCS0-MCS1 were




NEXT




<s> static void rtl93xx_phylink_mac_link_up(struct dsa_switch *ds, int port,
unsigned int mode,
phy_interface_t interface,
struct phy_device *phydev,
int speed, int duplex,
bool tx_pause, bool rx_pause)
{
struct rtl838x_switch_priv *priv = ds->priv;

/* Restart TX/RX to port */
sw_w32_mask(0, 0x3, priv->r->mac_port_ctrl(port));
/* TODO: Set speed/duplex/pauses */
}

The above function is used to re-set the state of an MAC port to the link up
state.
The speed/duplex state is not actually written to the MAC at this time, because
of the known errata #93699.
The




NEXT




<s> ar8xxx_sw_get_mirror_source_port(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
val->value.i = priv->source_port;
return 0;
}

The above function is used to get the current mirror
source port index set in the switch.

Mirror source_port (0-23) is set by doing below sequence

set mirror_id 0 source_port XX

set mirror_enable




NEXT




<s> wpas_ucode_iface_get_uval(struct wpa_supplicant *wpa_s)
{
uc_value_t *val;

if (wpa_s->ucode.idx)
return wpa_ucode_registry_get(iface_registry, wpa_s->ucode.idx);

val = uc_resource_new(iface_type, wpa_s);
wpa_s->ucode.idx = wpa_ucode_registry_add(iface_registry, val);

return val;
}

The above function is used to get interface specific code which can be used with a specific interface of a wifi device.
I am not able to find a reference from this function to iface_uval_get.
Could someone point it out so that i can find




NEXT




<s> blobmsg_add_macaddr(struct blob_buf *buf, const char *name, const u8 *addr)
{
char *s;

s = blobmsg_alloc_string_buffer(buf, name, 20);
sprintf(s, MACSTR, MAC2STR(addr));
blobmsg_add_string_buffer(buf);
}

The above function is used to add string formatted mac address into blob message. So I want to make some changes in above function. Now in blobmsg_add_macaddr(struct blob_buf *buf, const char *name, const u8 *addr) I




NEXT




<s> static ssize_t sc_tag_store_boolts(const u8 *pld, u16 pld_len, const char *buf, size_t count,
const struct sc_boolts *bts)
{
u32 data;	// cpu-endian

if (sizeof(data) != pld_len)
return -EINVAL;

if (sysfs_streq(buf, bts->strfalse))
data = 0;
else if (sysfs_streq(buf, bts->strtrue))
data = 1;
else
return -EINVAL;

write_lock(&sc_bufrwl);
*(u32 *)pld = data;		// pld aliases sc_buf
RB_SC_CLRCRC();
write_unlock(&sc_bufrwl);

return count;
}

The above function is used to initialize the boolean bit.

```
static ssize_t sc_tag_store_boolts(const u8 *pld, u16 pld_len,
        const char *buf, size_t count




NEXT




<s> rtk_api_ret_t rtk_qos_dscpRemark2Dscp_get(rtk_dscp_t dscp, rtk_dscp_t *pDscp)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (dscp > RTK_DSCPMAX)
return RT_ERR_QOS_DSCP_VALUE;

if ((retVal = rtl8367c_getAsicRemarkingDscp2Dscp(dscp, pDscp)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get the DSCP mapping of DSCP remarking:
remarking DSCP=8 -> output DSCP

In the rtl8367c_getAsicRemarkingDscp2Dsc




NEXT




<s> static void __init red_15w_rev1_setup_arch(void)
{
if (ppc_md.progress)
ppc_md.progress("red_15w_rev1_setup_arch()", 0);

fsl_pci_assign_primary();

pr_info("RED 15w Rev.1 from Sophos\n");
}

The above function is used to help display information when the computer is booting.  It is not in iteself harmful to the computer or its functions.  When it is disabled, the system runs a bit faster, but a bit less secure.</s>




NEXT




<s> conf_write_heading(FILE *fp, struct conf_printer *printer, void *printer_arg)
{
char buf[256];

snprintf(buf, sizeof(buf),
"\n"
"Automatically generated file; DO NOT EDIT.\n"
"%s\n",
rootmenu.prompt->text);

printer->print_comment(fp, buf, printer_arg);
}

The above function is used to print this comment:

Automatically generated file; DO NOT EDIT.

The comment is meant to inform the user that this file is automatically generated, and that the user shouldn't edit it (otherwise future versions of the module might




NEXT




<s> void rtk_hal_clear_vlan(void)
{
rtk_api_ret_t ret;

ret =  rtk_vlan_reset();
if (ret != RT_ERR_OK)
printk("rtk_vlan_reset failed\n");
}

The above function is used to clear VLAN/Port/PVID setting in the HW/SW.
There is also a macro defined as:#define HAL_VLAN_FLUSH
If this macro is defined and RTK_HAL_WITH_FLASH




NEXT




<s> static void expr_eliminate_dups1(enum expr_type type, struct expr **ep1, struct expr **ep2)
{
#define e1 (*ep1)
#define e2 (*ep2)
struct expr *tmp;

/* Recurse down to leaves */

if (e1->type == type) {
expr_eliminate_dups1(type, &e1->left.expr, &e2);
expr_eliminate_dups1(type, &e1->right.expr, &e2);
return;
}
if (e2->type == type) {
expr_eliminate_dups1(type, &e1, &e2->left.expr);
expr_eliminate_dups1(type, &e1, &e2->right.expr);
return;
}

/* e1 and e2 are leaves. Compare and process them. */

if (e1 == e2)
return;

switch (e1->type) {
case E_OR: case E_AND:
expr_eliminate_dups1(e1->type, &e1, &e1);
default:
;
}

switch (type) {
case E_OR:
tmp = expr_join_or(e1, e2);
if (tmp) {
expr_free(e1); expr_free(e2);
e1 = expr_alloc_symbol(&symbol_no);
e2 = tmp;
trans_count++;
}
break;
case E_AND:
tmp = expr_join_and(e1, e2);
if (tmp) {
expr_free(e1); expr_free(e2);
e1 = expr_alloc_symbol(&symbol_yes);
e2 = tmp;
trans_count++;
}
break;
default:
;
}
#undef e1
#undef e2
}

The above function is used to eliminate duplicate ORs and ANDs from
expressions produced by the AND and OR post-processors.  Once there are no
redundant conjunctions or disjunctions, the expression is flattened into an
expression




NEXT




<s> ret_t rtl8367c_setAsicFieldSelector(rtk_uint32 index, rtk_uint32 format, rtk_uint32 offset)
{
rtk_uint32 regData;

if(index > RTL8367C_FIELDSEL_FORMAT_NUMBER)
return RT_ERR_OUT_OF_RANGE;

if(format >= FIELDSEL_FORMAT_END)
return RT_ERR_OUT_OF_RANGE;

regData = (((format << RTL8367C_FIELD_SELECTOR_FORMAT_OFFSET) & RTL8367C_FIELD_SELECTOR_FORMAT_MASK ) |
((offset << RTL8367C_FIELD_SELECTOR_OFFSET_OFFSET) & RTL8367C_FIELD_SELECTOR_OFFSET_MASK ));

return rtl8367c_setAsicReg(RTL8367C_FIELD_SELECTOR_REG(index), regData);
}

The above function is used to set a field selector.

rtk_uint32 rtl8367c_getAsicFieldSelector(rtk_uint32 index, rtk_uint32 format, rtk_uint32 offset




NEXT




<s> static unsigned long rtcl_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
{
struct rtcl_clk *clk = rtcl_hw_to_clk(hw);
unsigned int ctrl0, ctrl1, div1, div2, cmu_ncode_in;
unsigned int cmu_sel_prediv, cmu_sel_div4, cmu_divn2, cmu_divn2_selb, cmu_divn3_sel;

if ((clk->idx >= CLK_COUNT) || (!rtcl_ccu) || (rtcl_ccu->soc >= SOC_COUNT))
return 0;

ctrl0 = read_sw(rtcl_regs[rtcl_ccu->soc][REG_CTRL0][clk->idx]);
ctrl1 = read_sw(rtcl_regs[rtcl_ccu->soc][REG_CTRL1][clk->idx]);

cmu_sel_prediv = 1 << RTL_PLL_CTRL0_CMU_SEL_PREDIV(ctrl0);
cmu_sel_div4 = RTL_PLL_CTRL0_CMU_SEL_DIV4(ctrl0) ? 4 : 1;
cmu_ncode_in = RTL_PLL_CTRL0_CMU_NCODE_IN(ctrl0) + 4;
cmu_divn2 = RTL_PLL_CTRL0_CMU_DIVN2(ctrl0) + 4;

switch (rtcl_ccu->soc) {
case SOC_RTL838X:
if ((ctrl0 == 0) && (ctrl1 == 0) && (clk->idx == CLK_LXB))
return 200000000;

cmu_divn2_selb = RTL838X_PLL_CTRL1_CMU_DIVN2_SELB(ctrl1);
cmu_divn3_sel = rtcl_divn3[RTL838X_PLL_CTRL1_CMU_DIVN3_SEL(ctrl1)];
break;
case SOC_RTL839X:
cmu_divn2_selb = RTL839X_PLL_CTRL1_CMU_DIVN2_SELB(ctrl1);
cmu_divn3_sel = rtcl_divn3[RTL839X_PLL_CTRL1_CMU_DIVN3_SEL(ctrl1)];
break;
}
div1 = cmu_divn2_selb ? cmu_divn3_sel : cmu_divn2;
div2 = rtcl_xdiv[clk->idx];

return (((parent_rate / 16) * cmu_ncode_in) / (div1 * div2)) *
cmu_sel_prediv * cmu_sel_div4 * 16;
}

The above function is used to recalculate the new clock rate when the parent clock rate is changed.</s>




NEXT




<s> static int adm6996_gpio_probe(struct platform_device *pdev)
{
struct adm6996_gpio_platform_data *pdata = pdev->dev.platform_data;
struct adm6996_priv *priv;
int ret;

if (!pdata)
return -EINVAL;

priv = devm_kzalloc(&pdev->dev, sizeof(struct adm6996_priv), GFP_KERNEL);
if (!priv)
return -ENOMEM;

mutex_init(&priv->reg_mutex);
mutex_init(&priv->mib_lock);

priv->eecs = pdata->eecs;
priv->eedi = pdata->eedi;
priv->eesk = pdata->eesk;

priv->model = pdata->model;
priv->read = adm6996_read_gpio_reg;
priv->write = adm6996_write_gpio_reg;

ret = devm_gpio_request(&pdev->dev, priv->eecs, "adm_eecs");
if (ret)
return ret;
ret = devm_gpio_request(&pdev->dev, priv->eedi, "adm_eedi");
if (ret)
return ret;
ret = devm_gpio_request(&pdev->dev, priv->eesk, "adm_eesk");
if (ret)
return ret;

ret = adm6996_switch_init(priv, dev_name(&pdev->dev), NULL);
if (ret < 0)
return ret;

platform_set_drvdata(pdev, priv);

return 0;
}

The above function is used to create the file ops of the sysfs entry /proc/driver/adm6996/gpio

static const struct file_operations adm6996_gpio_fops = {
.owner = THIS_MODULE,




NEXT




<s> ret_t rtl8367c_getAsicRma(rtk_uint32 index, rtl8367c_rma_t* pRmacfg)
{
ret_t retVal;
rtk_uint32 regData;

if(index > RTL8367C_RMAMAX)
return RT_ERR_RMA_ADDR;

if( (index >= 0x4 && index <= 0x7) || (index >= 0x9 && index <= 0x0C) || (0x0F == index))
index = 0x04;
else if((index >= 0x13 && index <= 0x17) || (0x19 == index) || (index >= 0x1B && index <= 0x1f))
index = 0x13;
else if(index >= 0x22 && index <= 0x2F)
index = 0x22;

retVal = rtl8367c_getAsicReg(RTL8367C_REG_RMA_CTRL00+index, &regData);
if(retVal != RT_ERR_OK)
return retVal;

pRmacfg->operation = ((regData >> 7) & 0x0003);
pRmacfg->discard_storm_filter = ((regData >> 6) & 0x0001);
pRmacfg->trap_priority = ((regData >> 3) & 0x0007);
pRmacfg->keep_format = ((regData >> 2) & 0x0001);
pRmacfg->vlan_leaky = ((regData >> 1) & 0x0001);
pRmacfg->portiso_leaky = (regData & 0x0001);


retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, &regData);
if(retVal != RT_ERR_OK)
return retVal;

pRmacfg->trap_priority = regData;

return RT_ERR_OK;
}

The above function is used to get RMA0(reg: RMA_CTRL00) and RMA1(reg: RMA_CTRL00).


#if CONFIG_RMA_LEAKY_VLAN
  retVal = r




NEXT




<s> rtk_api_ret_t rtk_l2_table_clear(void)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if ((retVal = rtl8367c_setAsicLutFlushAll()) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to clear out the L2 Address Table (LAT). The function calls the ASIC's clear all address table function.

Note:

RTL8367C: This function is called through the API rt_cfg_




NEXT




<s> t_nextfield(fp, s, max)
FILE * fp;
char * s;
unsigned max;
{
int c, count = 0;

while((c = getc(fp)) != EOF) {
if(c == '\n') {
ungetc(c, fp);
break;
}
else if(c == FSEPARATOR)
break;
if(count < max - 1) {
*s++ = c;
++count;
}
}
*s++ = '\0';
return count;
}

The above function is used to parse the field of input
stream, it is mainly used in the analysis of input
stream data file, when the value of max is greater
than 0, the function will read in a fixed length of
data into the field. When




NEXT




<s> static void rtk_hal_enable_igmpsnoop(int hw_on)
{
rtk_api_ret_t ret;
rtk_portmask_t pmask;

ret = rtk_igmp_init();
if (hw_on == 1) {
RTK_PORTMASK_CLEAR(pmask);
RTK_PORTMASK_PORT_SET(pmask, EXT_PORT0);
ret |= rtk_igmp_static_router_port_set(&pmask);
ret |= rtk_igmp_protocol_set(UTP_PORT4, PROTOCOL_IGMPv1, IGMP_ACTION_FORWARD);
ret |= rtk_igmp_protocol_set(UTP_PORT4, PROTOCOL_IGMPv2, IGMP_ACTION_FORWARD);
ret |= rtk_igmp_protocol_set(UTP_PORT4, PROTOCOL_MLDv1, IGMP_ACTION_FORWARD);
ret |= rtk_igmp_protocol_set(EXT_PORT1, PROTOCOL_IGMPv1, IGMP_ACTION_FORWARD);
ret |= rtk_igmp_protocol_set(EXT_PORT1, PROTOCOL_IGMPv2, IGMP_ACTION_FORWARD);
ret |= rtk_igmp_protocol_set(EXT_PORT1, PROTOCOL_MLDv1, IGMP_ACTION_FORWARD);
ret |= rtk_igmp_protocol_set(UTP_PORT0, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
ret |= rtk_igmp_protocol_set(UTP_PORT1, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
ret |= rtk_igmp_protocol_set(UTP_PORT2, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
ret |= rtk_igmp_protocol_set(UTP_PORT3, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
ret |= rtk_igmp_protocol_set(EXT_PORT0, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);

ret |= rtk_leaky_vlan_set(LEAKY_IPMULTICAST, ENABLED);
ret |= rtk_l2_ipMcastForwardRouterPort_set(DISABLED);
/* drop unknown multicast packets*/
/* ret |= rtk_trap_unknownMcastPktAction_set(UTP_PORT4, MCAST_IPV4, MCAST_ACTION_DROP);*/
} else {
RTK_PORTMASK_CLEAR(pmask);
RTK_PORTMASK_PORT_SET(pmask, EXT_PORT0);
RTK_PORTMASK_PORT_SET(pmask, EXT_PORT1);
ret |= rtk_igmp_protocol_set(UTP_PORT0, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
ret |= rtk_igmp_protocol_set(UTP_PORT1, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
ret |= rtk_igmp_protocol_set(UTP_PORT2, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
ret |= rtk_igmp_protocol_set(UTP_PORT3, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
ret |= rtk_igmp_protocol_set(EXT_PORT0, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);

ret |= rtk_igmp_static_router_port_set(&pmask);
}

if(ret != RT_ERR_OK)
printk("enable switch igmpsnoop failed\n");

}

The above function is used to control switch igmpsnoop setting by calling rtk_igmp_static_router_port_set() and rtk_igmp_protocol_set() function to set all ports as forwarding ports.</s>




NEXT




<s> wait_handler(struct nl_msg *msg, void *arg)
{
int *finished = arg;

*finished = 1;
return NL_STOP;
}

The above function is used to indicate that the netlink message handling chain has finished handling the given message. If this function is called, all further handlers in the chain will not be executed and none of the other handlers in the chain are required to handle this message. Some




NEXT




<s> swconfig_set_link(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
if (!dev->ops->set_port_link)
return -EOPNOTSUPP;

return dev->ops->set_port_link(dev, val->port_vlan, val->value.link);
}

The above function is used to set the link status of a port on a switch. However, it is not a mandatory function and therefore it may not be available on all switch drivers.

Therefore, the function first checks if the driver has the set_port_link




NEXT




<s> rtk_api_ret_t rtk_leaky_portIsolation_get(rtk_leaky_type_t type, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;
rtk_uint32 port, tmp;
rtl8367c_rma_t rmacfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (type >= LEAKY_END)
return RT_ERR_INPUT;

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if (type >= 0 && type <= LEAKY_UNDEF_GARP_2F)
{
if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.portiso_leaky;

}
else if (LEAKY_IPMULTICAST == type)
{
for (port = 0; port < RTK_MAX_NUM_OF_PORT; port++)
{
if ((retVal = rtl8367c_getAsicIpMulticastPortIsoLeaky(port, &tmp)) != RT_ERR_OK)
return retVal;
if (port > 0 &&(tmp != *pEnable))
return RT_ERR_FAILED;
*pEnable = tmp;
}
}
else if (LEAKY_IGMP == type)
{
if ((retVal = rtl8367c_getAsicIGMPIsoLeaky(&tmp)) != RT_ERR_OK)
return retVal;

*pEnable = tmp;
}
else if (LEAKY_CDP == type)
{
if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.portiso_leaky;
}
else if (LEAKY_CSSTP == type)
{
if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.portiso_leaky;
}
else if (LEAKY_LLDP == type)
{
if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
return retVal;

*pEnable = rmacfg.portiso_leaky;
}


return RT_ERR_OK;
}

The above function is used to retrieve the operation mode of leaky port isolation.


void rtk_leaky_portIsolation_set(rtk_leaky_type_t type, rtk_enable_t enable)
{
rtk




NEXT




<s> static void sata_oxnas_irq_clear(struct ata_port *ap)
{
struct sata_oxnas_port_priv *port_priv = ap->private_data;

/* clear pending interrupts */
iowrite32(~0, port_priv->port_base + INT_CLEAR);
iowrite32(COREINT_END, port_priv->core_base + CORE_INT_CLEAR);
}

The above function is used to clear the interrupt status of the port. As part of
processing a command, we need to query the interrupt status at certain points and
clear the bits that are no longer part of the current command. This will leave only
the ones that are




NEXT




<s> extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);

static int g_showtime = 0;
static void *g_xdata_addr = NULL;


#define ENABLE_TMP_DBG                          0

unsigned long cgu_get_pp32_clock(void)
{
struct clk *c = clk_get_ppe();
unsigned long rate = clk_get_rate(c);
clk_put(c);
return rate;
}

The above function is used to get the pp32 clock.


static inline u32 cgu_get_ref_clock(struct atm_dev *dev)
{
#if ENABLE_TMP_DBG
	printk("\n===%s




NEXT




<s> int __init ssb_fbs_register(void)
{
return platform_driver_register(&ssb_fbs_driver);
}

The above function is used to register ssb as a driver.

The following function is used to print the driver information of ssb


void __exit ssb_fbs_unregister(void)
{
platform_driver_unregister(&ssb_




NEXT




<s> static void __exit rtl8366s_module_exit(void)
{
platform_driver_unregister(&rtl8366s_driver);
}

The above function is used to exit the module from the system. When the module is being exited, it will unregister the rtl8366s_driver from the system by
using the platform_driver_unregister. When the platform_driver gets unregister




NEXT




<s> void ide_output_data(int device, const ulong *sect_buf, int words)
{
/* Only permit accesses to disks found to be present during ide_preinit() */
if (!disk_present[device]) {
return;
}

/* Select the required internal SATA drive */
device_select(device);

/* Start the DMA channel sending data from the passed buffer to the SATA core */
dma_start_write(sect_buf, words << 2);

/* Don't know why we need this delay, but without it the wait for DMA not
busy times soemtimes out, e.g. when saving environment to second disk */
udelay(1000);

/* Wait for DMA to finish */
if (!wait_dma_not_busy(device)) {
printf("Timed out of wait for DMA channel for SATA device %d to have in-progress clear\n",
device);
}

/* Sata core should finish after DMA */
if (wait_not_busy(device, 30)) {
printf("Timed out of wait for SATA device %d to have BUSY clear\n",
device);
}
if (!wait_no_error(device)) {
printf("oxnas_sata_output_data() Wait for ATA no-error timed-out\n");
}
}

The above function is used to control an Artec 1012A SATA controller:</s>




NEXT




<s> static int wlc_wdsmac(wlc_param param, void *data, void *value)
{
unsigned char mac[6];
int ret = 0;

ret = wl_ioctl(interface, WLC_WDS_GET_REMOTE_HWADDR, &mac, 6);
if (ret == 0)
my_ether_ntoa(mac, value);

return ret;
}

The above function is used to return the mac address of my WDS bridge. Is this the correct function for the above task? If so, how do I modify my code to retrieve the mac address of my bridge. Please help .

Note that if my bridges mac




NEXT




<s> append_expanded_string(yytext);
YY_BREAK
case 56:
YY_RULE_SETUP
{
append_string(yytext, yyleng);
}

The above function is used to append a single string to the buffer.

I’ve added this capability to the parser, but I have a few issues with it:
1) I have to parse all of the tokens that are possible after the current token is seen.




NEXT




<s> ret_t rtl8367c_setAsicPriorityToQIDMappingTable(rtk_uint32 index, rtk_uint32 priority, rtk_uint32 qid )
{
if(index >= RTL8367C_QUEUENO)
return RT_ERR_QUEUE_NUM;

if(priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

if(qid > RTL8367C_QIDMAX)
return RT_ERR_QUEUE_ID;

return rtl8367c_setAsicRegBits(RTL8367C_QOS_1Q_PRIORITY_TO_QID_REG(index, priority), RTL8367C_QOS_1Q_PRIORITY_TO_QID_MASK(priority), qid);
}

The above function is used to set a certain Queue Index to a single priority in priority mapping
table. The priority mapping table is shown in RTLX_QOS_PRM_QUEUE_RESOURCE_PRIORITY_MAP structure.
The priority mapping




NEXT




<s> int ecb_aes_encrypt(struct skcipher_request *req)
{
struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
struct skcipher_walk walk;
int err;
unsigned int enc_bytes, nbytes;

err = skcipher_walk_virt(&walk, req, false);

while ((nbytes = enc_bytes = walk.nbytes)) {
enc_bytes -= (nbytes % AES_BLOCK_SIZE);
ifx_deu_aes_ecb(ctx, walk.dst.virt.addr, walk.src.virt.addr,
NULL, enc_bytes, CRYPTO_DIR_ENCRYPT, 0);
nbytes &= AES_BLOCK_SIZE - 1;
err = skcipher_walk_done(&walk, nbytes);
}

return err;
}

The above function is used to setup ecrypt context and cipher bytes.
This function returns a status code which is the status code
from cryptodev_aes_ecb()
This function is called by device context for setup with given parameters in order
to




NEXT




<s> ret_t rtl8367c_setAsicPHYReg(rtk_uint32 phyNo, rtk_uint32 phyAddr, rtk_uint32 phyData )
{
rtk_uint32 ocp_addr;

if(phyAddr > RTL8367C_PHY_REGNOMAX)
return RT_ERR_PHY_REG_ID;

ocp_addr = 0xa400 + phyAddr*2;

return rtl8367c_setAsicPHYOCPReg(phyNo, ocp_addr, phyData);
}

The above function is used to set PHY register and to use setAsicPHYReg, we need specify register address, data and PHY. But actually the rtl8367c_getAsicPHYReg function only can get the PHY register value from




NEXT




<s> void rtl9300_sds_set(int sds_num, u32 mode)
{
pr_info("%s %d\n", __func__, mode);
if (sds_num < 0 || sds_num > 11) {
pr_err("Wrong SerDes number: %d\n", sds_num);
return;
}

sw_w32_mask(0x1f << rtl9300_sds_lsb[sds_num], mode << rtl9300_sds_lsb[sds_num],
rtl9300_sds_regs[sds_num]);
mdelay(10);

pr_debug("%s: 194:%08x 198:%08x 2a0:%08x 2a4:%08x\n", __func__,
sw_r32(0x194), sw_r32(0x198), sw_r32(0x2a0), sw_r32(0x2a4));
}

The above function is used to enable Tx/Rx paging. I need to
enable rx paging in my application when it is transmitting on a specific sds
because the sds is disabled once transmit starts on the sds in
rtl930




NEXT




<s> static void dma_chan_on(struct dc_ep_dev *dev, u8 cn)
{
ep_wr32(cn, DMA_CS);
ep_wr32_mask(0, BIT(0), DMA_CCTRL);
}

The above function is used to turn on a DMA channel
(by setting the appropriate bit in a DMA channel’s CCTRL register).
It does this by masking both CCTRL and DMA_CS, setting the mask
(set bit means turned on in this particular




NEXT




<s> static inline u32 nfi_read32(struct mt7621_nfc *nfc, u32 reg)
{
return readl(nfc->nfi_regs + reg);
}

The above function is used to access data from a GPIO pin. The above function is found in the below file, please download it to fully understand the function.

```
include/configs/ath79_mt7621.h
```




NEXT




<s> static inline uint8_t read_uint8(void *buf, ptrdiff_t off)
{
return *(uint8_t *)(buf + off);
}

The above function is used to read a byte at offset 'offset' from 'buf'.

Does '&' have to be removed from the code or the above function is already using pointer arithmetic?

How is the above function defined in C++? I




NEXT




<s> static int sata_oxnas_scr_write_port(struct ata_port *ap, unsigned int sc_reg,
u32 val)
{
sata_oxnas_link_write(ap, 0x20 + (sc_reg * 4), val);
return 0;
}

The above function is used to write to a SATA controller’s SC Registers. This is done by reading their address register (0x53 + (sc_reg * 4) for the case above), and masking out the upper byte. The result of




NEXT




<s> static s8 sprom_extract_antgain(u8 sprom_revision, const u16 *in, u16 offset,
u16 mask, u16 shift)
{
u16 v;
u8 gain;

v = in[SPOFF(offset)];
gain = (v & mask) >> shift;
if (gain == 0xFF)
gain = 2; /* If unset use 2dBm */
if (sprom_revision == 1) {
/* Convert to Q5.2 */
gain <<= 2;
} else {
/* Q5.2 Fractional part is stored in 0xC0 */
gain = ((gain & 0xC0) >> 6) | ((gain & 0x3F) << 2);
}

return (s8)gain;
}

The above function is used to extract the Antenna Gain value in the
SPROM.</s>




NEXT




<s> ret_t rtl8367c_getAsicStormFilterUnknownUnicastMeter(rtk_uint32 port, rtk_uint32 *pMeter)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

return rtl8367c_getAsicRegBits(RTL8367C_STORM_UNDA_METER_CTRL_REG(port), RTL8367C_STORM_UNDA_METER_CTRL_MASK(port), pMeter);
}

The above function is used to request the storm filter meter threshold value. The threshold value is calculated by the following expression:

Threshold = 32 - Meter
For example, if the value returned is 3, the threshold is 30
if the value returned




NEXT




<s> static int cybertan_parse_partitions(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct firmware_header header;
struct trx_header *theader;
struct uimage_header *uheader;
struct mtd_partition *trx_parts;
size_t retlen;
unsigned int kernel_len;
int ret;

trx_parts = kcalloc(TRX_PARTS, sizeof(struct mtd_partition),
GFP_KERNEL);
if (!trx_parts) {
ret = -ENOMEM;
goto out;
}

ret = mtd_read(master, 0, sizeof(header),
&retlen, (uint8_t *)&header);
if (ret)
goto free_parts;

if (retlen != sizeof(header)) {
ret = -EIO;
goto free_parts;
}

theader = &header.trx;
if (theader->magic != cpu_to_le32(TRX_MAGIC)) {
printk(KERN_NOTICE "%s: no TRX header found\n", master->name);
goto free_parts;
}

uheader = &header.uimage;
if (uheader->ih_magic != cpu_to_be32(IH_MAGIC)) {
printk(KERN_NOTICE "%s: no uImage found\n", master->name);
goto free_parts;
}

kernel_len = le32_to_cpu(theader->offsets[1]) +
sizeof(struct cybertan_header);

trx_parts[0].name = "header";
trx_parts[0].offset = 0;
trx_parts[0].size = offsetof(struct firmware_header, uimage);
trx_parts[0].mask_flags = 0;

trx_parts[1].name = "kernel";
trx_parts[1].offset = trx_parts[0].offset + trx_parts[0].size;
trx_parts[1].size = kernel_len - trx_parts[0].size;
trx_parts[1].mask_flags = 0;

trx_parts[2].name = "rootfs";
trx_parts[2].offset = trx_parts[1].offset + trx_parts[1].size;
trx_parts[2].size = master->size - trx_parts[1].size - trx_parts[0].size;
trx_parts[2].mask_flags = 0;

*pparts = trx_parts;
return TRX_PARTS;

free_parts:
kfree(trx_parts);
out:
return ret;
}

The above function is used to parse the partitions of the board’s MTD region. It’s important to note that the firmware structure is broken down into some important parts. First a simple header followed by the header itself. These structures are required to read the kernel




NEXT




<s> IFX_MEI_DMAWrite (DSL_DEV_Device_t * pDev, u32 destaddr,
u32 * databuff, u32 databuffsize)
{
u32 *p = databuff;
u32 temp;

if (destaddr & 3)
return DSL_DEV_MEI_ERR_FAILURE;

//      Set the write transfer address
IFX_MEI_LongWordWriteOffset (pDev, ME_DX_AD, destaddr);

//      Write the data pushed across DMA
while (databuffsize--) {
temp = *p;
if (destaddr == MEI_TO_ARC_MAILBOX)
MEI_HALF_WORD_SWAP (temp);
IFX_MEI_LongWordWriteOffset (pDev, (u32) ME_DX_DATA, temp);
p++;
}

return DSL_DEV_MEI_ERR_SUCCESS;

}

The above function is used to write data to a specific address. In this case the databuffer contains

- Destination address
- pointer to the data
- length of the data

From the previous post, we know that the value in mailbox
will




NEXT




<s> static bool aw9523_is_reg_hole(unsigned int reg)
{
return (reg > AW9523_REG_PORT_MODE(AW9523_PINS_PER_PORT) &&
reg < AW9523_REG_SOFT_RESET) ||
(reg > AW9523_REG_INTR_DIS(AW9523_PINS_PER_PORT) &&
reg < AW9523_REG_CHIPID);
}

The above function is used to determine whether the input “reg” is a  reserved
and noncontiguous I2C address or not. The output is “true” if reg is not the
address of a reserved I2C register. The output is “false




NEXT




<s> void wpa_ucode_free_vm(void)
{
if (!vm.config)
return;

uc_search_path_free(&vm.config->module_search_path);
uc_vm_free(&vm);
registry = NULL;
vm = (uc_vm_t){};
}

The above function is used to free the memory allocated for Unified Code in EAPOL packets. It also resets the vm variable, which contains the configuration options for Unified Code.

uc_config_t* uc_config_copy(uc_config




NEXT




<s> rtk_api_ret_t rtk_igmp_tableFullAction_get(rtk_igmp_tableFullAction_t *pAction)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pAction)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicIGMPTableFullOP((rtk_uint32 *)pAction))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve current IGMP Table Full Action status.
The parameter Action represents the current IGMP Table Full Action status.</s>




NEXT




<s> void rtl9300_sds_rxcal_3_2(int sds_num, phy_interface_t phy_mode)
{
u32 sum10 = 0, avg10, int10;
int dac_long_cable_offset;
bool eq_hold_enabled;
int i;

if (phy_mode == PHY_INTERFACE_MODE_10GBASER || phy_mode == PHY_INTERFACE_MODE_1000BASEX) {
/* rtl9300_rxCaliConf_serdes_myParam */
dac_long_cable_offset = 3;
eq_hold_enabled = true;
} else {
/* rtl9300_rxCaliConf_phy_myParam */
dac_long_cable_offset = 0;
eq_hold_enabled = false;
}

if (phy_mode == PHY_INTERFACE_MODE_1000BASEX)
pr_warn("%s: LEQ only valid for 10GR!\n", __func__);

pr_info("start_1.3.2");

for(i = 0; i < 10; i++) {
sum10 += rtl9300_sds_rxcal_leq_read(sds_num);
mdelay(10);
}

avg10 = (sum10 / 10) + (((sum10 % 10) >= 5) ? 1 : 0);
int10 = sum10 / 10;

pr_info("sum10:%u, avg10:%u, int10:%u", sum10, avg10, int10);

if (phy_mode == PHY_INTERFACE_MODE_10GBASER || phy_mode == PHY_INTERFACE_MODE_1000BASEX) {
if (dac_long_cable_offset) {
rtl9300_sds_rxcal_leq_offset_manual(sds_num, 1, dac_long_cable_offset);
rtl9300_sds_field_w(sds_num, 0x2e, 0x17, 7, 7, eq_hold_enabled);
if (phy_mode == PHY_INTERFACE_MODE_10GBASER)
rtl9300_sds_rxcal_leq_manual(sds_num, true, avg10);
} else {
if (sum10 >= 5) {
rtl9300_sds_rxcal_leq_offset_manual(sds_num, 1, 3);
rtl9300_sds_field_w(sds_num, 0x2e, 0x17, 7, 7, 0x1);
if (phy_mode == PHY_INTERFACE_MODE_10GBASER)
rtl9300_sds_rxcal_leq_manual(sds_num, true, avg10);
} else {
rtl9300_sds_rxcal_leq_offset_manual(sds_num, 1, 0);
rtl9300_sds_field_w(sds_num, 0x2e, 0x17, 7, 7, 0x1);
if (phy_mode == PHY_INTERFACE_MODE_10GBASER)
rtl9300_sds_rxcal_leq_manual(sds_num, true, avg10);
}
}
}

pr_info("Sds:%u LEQ = %u",sds_num, rtl9300_sds_rxcal_leq_read(sds_num));

pr_info("end_1.3.2");
}

The above function is used to set the Long Cable Equalization(LEQ)
value of PHY(10/100/1000TX & 10/100/1000BASE-X)

Here




NEXT




<s> t_rewindpw(tpw);

while(t_nextfield(tpw->instream, username, MAXUSERLEN) > 0) {
#ifdef ENABLE_YP
if(tpw->state == FILE_NIS && *username == '+') {
if(strlen(username) == 1 || strcmp(user, username+1) == 0) {
nisent = _yp_gettpnam(user);    /* Entry is +username or + */
if(nisent != NULL) {
savepwent(tpw, &nisent->tp);
return &tpw->pebuf;
}
}
}
#endif
if(strcmp(user, username) == 0)
if(t_nextfield(tpw->instream, passbuf, MAXB64PARAMLEN) > 0 &&
(tpw->pebuf.password.len = t_fromb64(tpw->pwbuf, passbuf)) > 0 &&
t_nextfield(tpw->instream, saltstr, MAXB64SALTLEN) > 0 &&
(tpw->pebuf.salt.len = t_fromb64(tpw->saltbuf, saltstr)) > 0 &&
t_nextfield(tpw->instream, indexbuf, 16) > 0 &&
(tpw->pebuf.index = atoi(indexbuf)) > 0) {
strcpy(tpw->userbuf, username);
tpw->pebuf.name = tpw->userbuf;
tpw->pebuf.password.data = tpw->pwbuf;
tpw->pebuf.salt.data = tpw->saltbuf;
t_nextline(tpw->instream);
return &tpw->pebuf;
}
if(t_nextline(tpw->instream) < 0)
return NULL;
}

The above function is used to read entries from a PAM file as found in /etc/pam.d.  This is a file-by-file search and must be modified to search the entire NIS domain first before performing a local file system search.  The




NEXT




<s> ret_t rtl8367c_setAsicRldpLoopStatePara(rtk_uint32 retryCount, rtk_uint32 retryPeriod)
{
ret_t retVal;

if(retryCount > 0xFF)
return RT_ERR_OUT_OF_RANGE;

if(retryPeriod > RTL8367C_REGDATAMAX)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_RLDP_RETRY_COUNT_REG, RTL8367C_RLDP_RETRY_COUNT_LOOPSTATE_MASK, retryCount);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_setAsicReg(RTL8367C_RLDP_RETRY_PERIOD_LOOPSTATE_REG, retryPeriod);
}

The above function is used to set the loop state parameters. According to the documentations, the retry count and retry period are 8 bits each, and the valid range is 0 to 0xFF. Actually, the parameters defined in the driver are 32 bits,




NEXT




<s> static int bcm6318_pcie_can_access(struct pci_bus *bus, int devfn)
{
struct bcm6318_pcie *priv = &bcm6318_pcie;

switch (bus->number) {
case PCIE_BUS_BRIDGE:
return PCI_SLOT(devfn) == 0;
case PCIE_BUS_DEVICE:
if (PCI_SLOT(devfn) == 0)
return __raw_readl(priv->base + PCIE_DLSTATUS_REG)
& DLSTATUS_PHYLINKUP;
fallthrough;
default:
return false;
}
}

The above function is used to see if a device on the PCI bus is accessible by the PCI host (root controller) br0g0. This has two return path, if you're PCI host on PCI bus number 0 (PCIE_BUS_BRIDGE




NEXT




<s> static int mtdsplit_cfe_bootfs_parse(struct mtd_info *mtd,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct jffs2_raw_dirent node;
enum mtdsplit_part_type type;
struct mtd_partition *parts;
size_t rootfs_offset;
size_t retlen;
size_t offset;
int err;

/* Don't parse backup partitions */
if (strcmp(mtd->name, "firmware"))
return -EINVAL;

/* Find the end of JFFS2 bootfs partition */
offset = 0;
do {
err = mtd_read(mtd, offset, sizeof(node), &retlen, (void *)&node);
if (err || retlen != sizeof(node))
break;

if (je16_to_cpu(node.magic) != JFFS2_MAGIC_BITMASK)
break;

offset += je32_to_cpu(node.totlen);
offset = (offset + 0x3) & ~0x3;
} while (offset < mtd->size);

/* Find rootfs partition that follows the bootfs */
err = mtd_find_rootfs_from(mtd, mtd->erasesize, mtd->size, &rootfs_offset, &type);
if (err)
return err;

parts = kzalloc(NR_PARTS * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

parts[0].name = "bootfs";
parts[0].offset = 0;
parts[0].size = rootfs_offset;

if (type == MTDSPLIT_PART_TYPE_UBI)
parts[1].name = UBI_PART_NAME;
else
parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = mtd->size - rootfs_offset;

*pparts = parts;

return NR_PARTS;
}

The above function is used to parse the cfe U-Boot for UBI. UBI stands for Unified block
interface which is a memory mapping device for flash translation layer (FTL) based solid
state disk (SSD). If you want to learn more about




NEXT




<s> ret_t rtl8367c_setAsicLutAgeTimerSpeed(rtk_uint32 timer, rtk_uint32 speed)
{
if(timer>RTL8367C_LUT_AGETIMERMAX)
return RT_ERR_OUT_OF_RANGE;

if(speed >RTL8367C_LUT_AGESPEEDMAX)
return RT_ERR_OUT_OF_RANGE;

return rtl8367c_setAsicRegBits(RTL8367C_REG_LUT_CFG, RTL8367C_AGE_TIMER_MASK | RTL8367C_AGE_SPEED_MASK, (timer << RTL8367C_AGE_TIMER_OFFSET) | (speed << RTL8367C_AGE_SPEED_OFFSET));
}

The above function is used to configure LUT.</s>




NEXT




<s> static inline void rttm_disable_timer(void __iomem *base)
{
iowrite32(0, base + RTTM_CTRL);
}

The above function is used to disable the real-time timer.

static inline void rttm_enable_timer(void __iomem *base)
{
u32 val;

val = ioread32(base + RTTM




NEXT




<s> swconfig_lock(void)
{
mutex_lock(&swdevs_lock);
}

The above function is used to take a lock on “swdevs”.
But in arch/arm/net/s3c_hw_switch/s3c_hw_switch.dts
We define
/dev/switch{
composite =&




NEXT




<s> static int vlan_read(struct seq_file *seq, void *v)
{
rtk_hal_dump_vlan();
return 0;
}

The above function is used to dump all the entries in the VLAN_FILTER_TYPE table. We will call this function for every VLAN_FILTER_TYPE entry in our code. Now for reading and processing the incoming Ethernet packets, we have the following procedure:




NEXT




<s> struct property *sym_get_choice_prop(struct symbol *sym)
{
struct property *prop;

for_all_choices(sym, prop)
return prop;
return NULL;
}

The above function is used to find the first (i.e. the lowest) symbol that has a
choice property.  Unfortunately the for each choice loop causes the
incremental parser to be called for each symbol and the incremental
parser does a complete scan of




NEXT




<s> static void rtl838x_fill_l2_row(u32 r[], struct rtl838x_l2_entry *e)
{
u64 mac = ether_addr_to_u64(e->mac);

if (!e->valid) {
r[0] = r[1] = r[2] = 0;
return;
}

r[0] = e->is_ip_mc ? BIT(22) : 0;
r[0] |= e->is_ipv6_mc ? BIT(21) : 0;

if (!e->is_ip_mc && !e->is_ipv6_mc) {
r[1] = mac >> 20;
r[2] = (mac & 0xfffff) << 12;

/* Is it a unicast entry? check multicast bit */
if (!(e->mac[0] & 1)) {
r[0] |= e->is_static ? BIT(19) : 0;
r[0] |= (e->port & 0x3f) << 12;
r[0] |= e->vid;
r[1] |= e->block_da ? BIT(30) : 0;
r[1] |= e->block_sa ? BIT(31) : 0;
r[1] |= e->suspended ? BIT(29) : 0;
r[2] |= e->rvid & 0xfff;
if (e->next_hop) {
r[1] |= BIT(28);
r[0] |= e->nh_vlan_target ? BIT(9) : 0;
r[0] |= e->nh_route_id & 0x1ff;
}
r[0] |= (e->age & 0x3) << 17;
} else { /* L2 Multicast */
r[0] |= (e->mc_portmask_index & 0x1ff) << 12;
r[2] |= e->rvid & 0xfff;
r[0] |= e->vid & 0xfff;
pr_debug("FILL MC: %08x %08x %08x\n", r[0], r[1], r[2]);
}
} else { /* IPv4 and IPv6 multicast */
r[0] |= (e->mc_portmask_index & 0x1ff) << 12;
r[1] = e->mc_gip >> 20;
r[2] = e->mc_gip << 12;
r[2] |= e->rvid;
}
}

The above function is used to get a MAC address value so that it can be saved to
the register in the NPU. The value of a MAC address is stored to a u64 integer data
type. The value of the u64 data type is calculated using




NEXT




<s> rtk_api_ret_t rtk_vlan_stg_set(rtk_vlan_t vid, rtk_stp_msti_id_t stg)
{
rtk_api_ret_t retVal;
rtl8367c_user_vlan4kentry vlan4K;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* vid must be 0~4095 */
if (vid > RTL8367C_VIDMAX)
return RT_ERR_VLAN_VID;

/* priority must be 0~15 */
if (stg > RTL8367C_MSTIMAX)
return RT_ERR_MSTI;

/* update 4K table */
vlan4K.vid = vid;
if ((retVal = rtl8367c_getAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
return retVal;

vlan4K.fid_msti= stg;
if ((retVal = rtl8367c_setAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set a stp instance of the specified vlantag.</s>




NEXT




<s> static void rtl8366_smi_reset(struct rtl8366_smi *smi, bool active)
{
if (active)
reset_control_assert(smi->reset);
else
reset_control_deassert(smi->reset);
}

The above function is used to enable (by asserting the ROM power gating reset)
or disable (by asserting the ROM power gating sleep) the NOR ROM for the MAC
chip.

I cannot understand a why there is two power




NEXT




<s> ead_send_packet_clone(struct ead_packet *pkt)
{
u16_t len, sum;

memcpy(pktbuf, pkt, offsetof(struct ead_packet, msg));
memcpy(pktbuf->eh.ether_shost, ethmac, 6);
memcpy(pktbuf->eh.ether_dhost, pkt->eh.ether_shost, 6);

/* ip header */
len = sizeof(struct ead_packet) - sizeof(struct ether_header) + ntohl(pktbuf->msg.len);
pktbuf->len[0] = len >> 8;
pktbuf->len[1] = len & 0xff;
memcpy(pktbuf->srcipaddr, &pkt->msg.ip, 4);
memcpy(pktbuf->destipaddr, pkt->srcipaddr, 4);

/* ip checksum */
pktbuf->ipchksum = 0;
sum = chksum(0, (void *) &pktbuf->vhl, UIP_IPH_LEN);
if (sum == 0)
sum = 0xffff;
pktbuf->ipchksum = htons(~sum);

/* udp header */
pktbuf->srcport = pkt->destport;
pktbuf->destport = pkt->srcport;

/* udp checksum */
len -= UIP_IPH_LEN;
pktbuf->udplen = htons(len);
pktbuf->udpchksum = 0;
sum = len + UIP_PROTO_UDP;
sum = chksum(sum, (void *) &pktbuf->srcipaddr[0], 8); /* src, dest ip */
sum = chksum(sum, (void *) &pktbuf->srcport, len);
if (sum == 0)
sum = 0xffff;
pktbuf->udpchksum = htons(~sum);
pcap_sendpacket(pcap_fp, (void *) pktbuf, sizeof(struct ead_packet) + ntohl(pktbuf->msg.len));
}

The above function is used to generate a new eth_header, udp_header, ip_header and checksum the packet to be sent to destination. The send a packet to the specified ip and port through pcap driver(http://www.tcpdump.org/)




NEXT




<s> static int esw_set_port_pvid(struct switch_dev *dev, int port, int val)
{
struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);

if (port >= RT305X_ESW_NUM_PORTS)
return -EINVAL;

esw->ports[port].pvid = val;

return 0;
}

The above function is used to set the PVID for a specific port. It takes two arguments, the first being the switch device on which to operate, and the second being the port to set the PVID for. It then assigns the given value to the pvid variable




NEXT




<s> EXPORT_SYMBOL(b53_swconfig_switch_detect);

int b53_swconfig_switch_register(struct b53_device *dev)
{
int ret;

if (dev->pdata) {
dev->chip_id = dev->pdata->chip_id;
dev->enabled_ports = dev->pdata->enabled_ports;
dev->sw_dev.alias = dev->pdata->alias;
}

if (!dev->chip_id && b53_swconfig_switch_detect(dev))
return -EINVAL;

ret = b53_switch_init(dev);
if (ret)
return ret;

pr_info("found switch: %s, rev %i\n", dev->sw_dev.name, dev->core_rev);

return register_switch(&dev->sw_dev, NULL);
}

The above function is used to register switch with kernel and you can see the function is called by a b53 driver.

static int b53_swconfig_port_get_info(int port, struct phy_device *dev)
{





NEXT




<s> static struct device_node *mux_parent_adapter(struct device *dev, struct rtl9300_mux *mux)
{
struct device_node *node = dev->of_node;
struct device_node *parent_np;
struct i2c_adapter *parent;

parent_np = of_parse_phandle(node, "i2c-parent", 0);
if (!parent_np) {
dev_err(dev, "Cannot parse i2c-parent\n");
return ERR_PTR(-ENODEV);
}
parent = of_find_i2c_adapter_by_node(parent_np);
of_node_put(parent_np);
if (!parent)
return ERR_PTR(-EPROBE_DEFER);

if (!(of_device_is_compatible(parent_np, "realtek,rtl9300-i2c") ||
of_device_is_compatible(parent_np, "realtek,rtl9310-i2c"))){
dev_err(dev, "I2C parent not an RTL9300 I2C controller\n");
return ERR_PTR(-ENODEV);
}

mux->parent = parent;
mux->i2c = (struct rtl9300_i2c *)i2c_get_adapdata(parent);
mux->base = mux->i2c->base;

return parent_np;
}

The above function is used to parse the mux i2c controller as parent controller.
Once mux is parsed, i2c_new_device will call mx_parent_adapter for each
"rk29XX-mx" mux device node to




NEXT




<s> static void fe_phy_link_adjust(struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);
unsigned long flags;
int i;

spin_lock_irqsave(&priv->phy->lock, flags);
for (i = 0; i < 8; i++) {
if (priv->phy->phy_node[i]) {
struct phy_device *phydev = priv->phy->phy[i];
int status_change = 0;

if (phydev->link)
if (priv->phy->duplex[i] != phydev->duplex ||
priv->phy->speed[i] != phydev->speed)
status_change = 1;

if (phydev->link != priv->link[i])
status_change = 1;

switch (phydev->speed) {
case SPEED_1000:
case SPEED_100:
case SPEED_10:
priv->link[i] = phydev->link;
priv->phy->duplex[i] = phydev->duplex;
priv->phy->speed[i] = phydev->speed;

if (status_change &&
priv->soc->mdio_adjust_link)
priv->soc->mdio_adjust_link(priv, i);
break;
}
}
}
spin_unlock_irqrestore(&priv->phy->lock, flags);
}

The above function is used to adjust the MDIO link parameters that are exposed by FE device. It loops over all MDIO links present and checks whether there has been any status change. A flag variable is maintained to check if the link status has changed or not. If the link




NEXT




<s> int fe_set_clock_cycle(struct fe_priv *priv)
{
unsigned long sysclk = priv->sysclk;

sysclk /= FE_US_CYC_CNT_DIVISOR;
sysclk <<= FE_US_CYC_CNT_SHIFT;

fe_w32((fe_r32(FE_FE_GLO_CFG) &
~(FE_US_CYC_CNT_MASK << FE_US_CYC_CNT_SHIFT)) |
sysclk,
FE_FE_GLO_CFG);
return 0;
}

The above function is used to set the global clock cycle of the FPGA. It is used only for the FPGA.</s>




NEXT




<s> void fe_set_ethtool_ops(struct net_device *netdev)
{
struct fe_priv *priv = netdev_priv(netdev);
struct fe_soc_data *soc = priv->soc;

if (soc->reg_table[FE_REG_FE_COUNTER_BASE]) {
fe_ethtool_ops.get_strings = fe_get_strings;
fe_ethtool_ops.get_sset_count = fe_get_sset_count;
fe_ethtool_ops.get_ethtool_stats = fe_get_ethtool_stats;
}

netdev->ethtool_ops = &fe_ethtool_ops;
}

The above function is used to set ethtool_ops function pointers once the data structure is fully initialized. So, if you take a look at the init function above, it is setting those function pointers to NULL. Later on, in fe_set_etht




NEXT




<s> static void unmap_block_nmbm(u16 block)
{
struct nmbm_instance *ni = bmtd.ni;
int start, offset;
int new_block;

if (block >= ni->data_block_count)
return;

start = block;
offset = 0;
while (ni->block_mapping[start] >= ni->mapping_blocks_ba) {
start--;
offset++;
if (start < 0)
return;
}

if (!offset)
return;

new_block = ni->block_mapping[start] + offset;
nmbm_set_block_state(ni, new_block, BLOCK_ST_GOOD);
ni->block_mapping[block] = new_block;
ni->block_mapping_changed++;

new_block = ni->signature_ba - 1;
for (block = 0; block < ni->data_block_count; block++) {
int cur = ni->block_mapping[block];

if (cur < ni->mapping_blocks_ba)
continue;

if (cur <= new_block)
new_block = cur - 1;
}

ni->mapping_blocks_top_ba = new_block;

nmbm_update_info_table(ni);
}

The above function is used to move a data block which is not a signature block or mapping block. The only data block allowed to be moved is the first one. The function simply checks if the new data block is a valid mapping block and, if yes, updates the mapping to




NEXT




<s> ret_t rtl8367c_setAsicFlowControlPortDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_OFF, RTL8367C_FLOWCTRL_FCOFF_PORT_OFF_MASK, offThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_ON, RTL8367C_FLOWCTRL_FCOFF_PORT_ON_MASK, onThreshold);

return retVal;
}

The above function is used to define the flow control packet threshold value for flow control drop or flow control enable for flow port 0 to flow port 3. As mentioned in the flow control section, the flow control function will check if the given packet contains flow control function, if




NEXT




<s> static void abort_query(int sig)
{
exit(1);
}

The above function is used to terminate the database in case we got a signal.
If we look at the code again, it’s obvious that the only signal we are looking
out for is SIGINT (from the keyboard).

struct sigaction act;





NEXT




<s> static int b53_spi_remove(struct spi_device *spi)
{
struct b53_device *dev = spi_get_drvdata(spi);

if (dev)
b53_switch_remove(dev);

return 0;
}

The above function is used to remove B53 device driver from Linux kernel.

First, it retrieves the pointer, dev, to the b53_device structure by using spi_get_drvdata() function.

Then, it calls the remove




NEXT




<s> static int ag71xx_fill_dma_desc(struct ag71xx_ring *ring, u32 addr, int len)
{
int i;
struct ag71xx_desc *desc;
int ring_mask = BIT(ring->order) - 1;
int ndesc = 0;
int split = ring->desc_split;

if (!split)
split = len;

while (len > 0) {
unsigned int cur_len = len;

i = (ring->curr + ndesc) & ring_mask;
desc = ag71xx_ring_desc(ring, i);

if (!ag71xx_desc_empty(desc))
return -1;

if (cur_len > split) {
cur_len = split;

/*
* TX will hang if DMA transfers <= 4 bytes,
* make sure next segment is more than 4 bytes long.
*/
if (len <= split + 4)
cur_len -= 4;
}

desc->data = addr;
addr += cur_len;
len -= cur_len;

if (len > 0)
cur_len |= DESC_MORE;

/* prevent early tx attempt of this descriptor */
if (!ndesc)
cur_len |= DESC_EMPTY;

desc->ctrl = cur_len;
ndesc++;
}

return ndesc;
}

The above function is used to fill the tx and rx ring descriptors. If the
size of the data we are transmitting exceeds the DMA limit, we need to
split it into multiple segments, since we can only control the DMA engine
with one descriptor per segment




NEXT




<s> static bool is_present(const char *path)
{
struct stat st;

return !stat(path, &st);
}

The above function is used to check if a specified file exists in your current
directory.

You can copy this function into your source code and just call 1.6.3. 1.

```
if (is_present( &quot;




NEXT




<s> unsigned long raw_truerand();

void
t_initrand()
{
SHA1_CTX ctxt;
#ifdef USE_FTIME
struct timeb t;
#else
struct timeval t;
#endif
int i, r=0;

if(initialized)
return;

initialized = 1;

i = open("/dev/urandom", O_RDONLY);
if(i > 0) {
r += read(i, preseed.devrand, sizeof(preseed.devrand));
close(i);
}

/* Resort to truerand only if desperate for some Real entropy */
if(r == 0)
preseed.trand1 = raw_truerand();

#ifdef USE_FTIME
ftime(&t);
#else
gettimeofday(&t, NULL);
#endif

#ifdef USE_FTIME
preseed.sec = t.time;
preseed.usec = t.millitm;
#else
preseed.sec = t.tv_sec;
preseed.usec = t.tv_usec;
#endif
preseed.pid = getpid();
preseed.ppid = getppid();
t_envhash(preseed.envh);
t_fshash(preseed.fsh);

if(r == 0)
preseed.trand2 = raw_truerand();

SHA1Init(&ctxt);
SHA1Update(&ctxt, (unsigned char *) &preseed, sizeof(preseed));
SHA1Final(randpool, &ctxt);
outpos = 0;
memset((unsigned char *) &preseed, 0, sizeof(preseed));
memset((unsigned char *) &ctxt, 0, sizeof(ctxt));
}

The above function is used to initialize the entropy collector in the PAM modules, and it is called by an open_memstream().  For the seed function, I am using the time stamp of the process that the pam module is running in.  Also, I am




NEXT




<s> SHA256_Pad(SHA256_CTX * ctx)
{
size_t r;

/* Figure out how many bytes we have buffered. */
r = (ctx->count >> 3) & 0x3f;

/* Pad to 56 mod 64, transforming if we finish a block en route. */
if (r < 56) {
/* Pad to 56 mod 64. */
memcpy(&ctx->buf[r], PAD, 56 - r);
} else {
/* Finish the current block and mix. */
memcpy(&ctx->buf[r], PAD, 64 - r);
SHA256_Transform(ctx->state, ctx->buf);

/* The start of the final block is all zeroes. */
memset(&ctx->buf[0], 0, 56);
}

/* Add the terminating bit-count. */
be64enc(&ctx->buf[56], ctx->count);

/* Mix in the final block. */
SHA256_Transform(ctx->state, ctx->buf);
}

The above function is used to pad the data, before encryption is performed using SHA-256. So what? Why would these characters (‘\x64’) be injected into a browser in the payload of a phishing page? This is an example of




NEXT




<s> rtk_api_ret_t rtk_vlan_mbrCfg_set(rtk_uint32 idx, rtk_vlan_mbrcfg_t *pMbrcfg)
{
rtk_api_ret_t           retVal;
rtk_uint32              phyMbrPmask;
rtl8367c_vlanconfiguser mbrCfg;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Error check */
if(pMbrcfg == NULL)
return RT_ERR_NULL_POINTER;

if(idx > RTL8367C_CVIDXMAX)
return RT_ERR_INPUT;

if(pMbrcfg->evid > RTL8367C_EVIDMAX)
return RT_ERR_INPUT;

if(pMbrcfg->fid_msti > RTL8367C_FIDMAX)
return RT_ERR_L2_FID;

if(pMbrcfg->envlanpol >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if(pMbrcfg->meteridx > RTK_MAX_METER_ID)
return RT_ERR_FILTER_METER_ID;

if(pMbrcfg->vbpen >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if(pMbrcfg->vbpri > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

/* Check port mask valid */
RTK_CHK_PORTMASK_VALID(&(pMbrcfg->mbr));

mbrCfg.evid         = pMbrcfg->evid;
mbrCfg.fid_msti     = pMbrcfg->fid_msti;
mbrCfg.envlanpol    = pMbrcfg->envlanpol;
mbrCfg.meteridx     = pMbrcfg->meteridx;
mbrCfg.vbpen        = pMbrcfg->vbpen;
mbrCfg.vbpri        = pMbrcfg->vbpri;

if(rtk_switch_portmask_L2P_get(&(pMbrcfg->mbr), &phyMbrPmask) != RT_ERR_OK)
return RT_ERR_FAILED;

mbrCfg.mbr = phyMbrPmask;

if ((retVal = rtl8367c_setAsicVlanMemberConfig(idx, &mbrCfg)) != RT_ERR_OK)
return retVal;

/* Update Database */
if( (mbrCfg.evid == 0) && (mbrCfg.mbr == 0) )
{
vlan_mbrCfgUsage[idx] = MBRCFG_UNUSED;
vlan_mbrCfgVid[idx] = 0;
}
else
{
vlan_mbrCfgUsage[idx] = MBRCFG_USED_BY_VLAN;
vlan_mbrCfgVid[idx] = mbrCfg.evid;
}

return RT_ERR_OK;

}

The above function is used to configure an VID/FID group as the member VLAN in specific CVID. This function has no special requirements for the inputs that are passed to it. The function only determines the validity of the input parameters, and will check the value




NEXT




<s> ret_t rtl8367c_setAsicEavPriRemapping(rtk_uint32 srcpriority, rtk_uint32 priority)
{
if(srcpriority > RTL8367C_PRIMAX || priority > RTL8367C_PRIMAX)
return RT_ERR_QOS_INT_PRIORITY;

return rtl8367c_setAsicRegBits(RTL8367C_EAV_PRIORITY_REMAPPING_REG(srcpriority), RTL8367C_EAV_PRIORITY_REMAPPING_MASK(srcpriority),priority);
}

The above function is used to set up the priority remapping when the source LIF is the ingress port LIF. In this case, the source VLAN for QoS is taken to be the input VLAN, the VLAN is taken from the incoming packet,




NEXT




<s> static u32 encode_start(u32 ctrl_status)
{
return ctrl_status & ~DMA_CTRL_STATUS_PAUSE;
}

The above function is used to encode the data for the DMA control reg

The function above does encoding of the DMA control register data.
The data from the DMA register was saved previously on a variable

DMA_REG.DMA_CTRL_REG = DMA_CTRL




NEXT




<s> static void rtl838x_enable_flood(int port, bool enable)
{
/* 0: Forward
* 1: Disable
* 2: to CPU
* 3: Copy to CPU
*/
sw_w32_mask(0x3, enable ? 0 : 1,
RTL838X_L2_PORT_LRN_CONSTRT + (port << 2));
}

The above function is used to to enable or disable “flood”
(LRN_CONSTRT) on the L2 Switch.

A switch’s table entry which represents a MAC address is called “flow” in QCA’s
soft




NEXT




<s> nvram_header_t * nvram_header(nvram_handle_t *h)
{
return (nvram_header_t *) &h->mmap[h->offset];
}

The above function is used to find the nvram_header_t structure.

I used the f_lseek and f_read to read the data at specific pointer in the file, but how to calculate the pointer?

#define NVRAM_BLOCK




NEXT




<s> static bool aca_hif_param_init_check(struct dc_ep_priv *priv)
{
u32 addr;
int timeout = ACA_LOOP_CNT;
u32 offset = offsetof(struct aca_hif_params, magic);
struct aca_fw_param *fw_param = to_aca_fw_param(priv);

/* addr = rd32(ACA_HIF_LOC_POS);*/
addr = fw_param->init_addr;
while (--timeout && (rd32(addr + offset) != ACA_MAGIC))
udelay(1);

if (timeout <= 0) {
dev_err(priv->dev, "aca hif params init failed\n");
return false;
}

return true;
}

The above function is used to check whether or not the hif_params has been initialized successfully. To do so, aca_hif_param_init_check is called from aca_hif_init function in aca_hw.c. In the




NEXT




<s> rtk_api_ret_t rtk_port_sgmiiLinkStatus_get(rtk_port_t port, rtk_data_t *pSignalDetect, rtk_data_t *pSync, rtk_port_linkStatus_t *pLink)
{
rtk_uint32 ext_id;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
if(rtk_switch_isSgmiiPort(port) != RT_ERR_OK)
return RT_ERR_PORT_ID;

if(NULL == pSignalDetect)
return RT_ERR_NULL_POINTER;

if(NULL == pSync)
return RT_ERR_NULL_POINTER;

if(NULL == pLink)
return RT_ERR_NULL_POINTER;

ext_id = port - 15;
return rtl8367c_getSdsLinkStatus(ext_id, (rtk_uint32 *)pSignalDetect, (rtk_uint32 *)pSync, (rtk_uint32 *)pLink);
}

The above function is used to get the SGMII link status and return it to the caller, which includes data detect, sync and port link status.

A flow chart of this function is shown as Figure 11-4.

Figure 11-




NEXT




<s> static int rb91x_nand_remove(struct platform_device *pdev)
{
struct rb91x_nand_drvdata *drvdata = platform_get_drvdata(pdev);

rb91x_nand_release(drvdata);

return 0;
}

The above function is used to do some release operations on driver related data when the driver is being removed.

Let's see how to use it:

First register a function in system_exit function through the module_exit function.

static init_fn




NEXT




<s> static int rtl83xx_fib_event(struct notifier_block *this, unsigned long event, void *ptr)
{
struct fib_notifier_info *info = ptr;
struct rtl838x_switch_priv *priv;
struct rtl83xx_fib_event_work *fib_work;

if ((info->family != AF_INET && info->family != AF_INET6 &&
info->family != RTNL_FAMILY_IPMR &&
info->family != RTNL_FAMILY_IP6MR))
return NOTIFY_DONE;

priv = container_of(this, struct rtl838x_switch_priv, fib_nb);

fib_work = kzalloc(sizeof(*fib_work), GFP_ATOMIC);
if (!fib_work)
return NOTIFY_BAD;

INIT_WORK(&fib_work->work, rtl83xx_fib_event_work_do);
fib_work->priv = priv;
fib_work->event = event;
fib_work->is_fib6 = false;

switch (event) {
case FIB_EVENT_ENTRY_ADD:
case FIB_EVENT_ENTRY_REPLACE:
case FIB_EVENT_ENTRY_APPEND:
case FIB_EVENT_ENTRY_DEL:
pr_debug("%s: FIB_ENTRY ADD/DEL, event %ld\n", __func__, event);
if (info->family == AF_INET) {
struct fib_entry_notifier_info *fen_info = ptr;

if (fen_info->fi->fib_nh_is_v6) {
NL_SET_ERR_MSG_MOD(info->extack,
"IPv6 gateway with IPv4 route is not supported");
kfree(fib_work);
return notifier_from_errno(-EINVAL);
}

memcpy(&fib_work->fen_info, ptr, sizeof(fib_work->fen_info));
/* Take referece on fib_info to prevent it from being
* freed while work is queued. Release it afterwards.
*/
fib_info_hold(fib_work->fen_info.fi);

} else if (info->family == AF_INET6) {
//struct fib6_entry_notifier_info *fen6_info = ptr;
pr_warn("%s: FIB_RULE ADD/DEL for IPv6 not supported\n", __func__);
kfree(fib_work);
return NOTIFY_DONE;
}
break;

case FIB_EVENT_RULE_ADD:
case FIB_EVENT_RULE_DEL:
pr_debug("%s: FIB_RULE ADD/DEL, event: %ld\n", __func__, event);
memcpy(&fib_work->fr_info, ptr, sizeof(fib_work->fr_info));
fib_rule_get(fib_work->fr_info.rule);
break;
}

schedule_work(&fib_work->work);

return NOTIFY_DONE;
}

The above function is used to process the RULE_ADD and ENTRY_ADD/ENTRY_DELETE events and call a function
rtl83xx_fib_event_work_do() in rtl83xx_dev_init(). The function below




NEXT




<s> static void rb91x_nand_cmd_ctrl(struct nand_chip *chip, int cmd,
unsigned int ctrl)
{
struct rb91x_nand_drvdata *drvdata = chip->priv;

if (ctrl & NAND_CTRL_CHANGE) {
gpiod_set_value_cansleep(drvdata->gpio[RB91X_NAND_CLE],
(ctrl & NAND_CLE) ? 1 : 0);
gpiod_set_value_cansleep(drvdata->gpio[RB91X_NAND_ALE],
(ctrl & NAND_ALE) ? 1 : 0);
gpiod_set_value_cansleep(drvdata->gpio[RB91X_NAND_NCE],
(ctrl & NAND_NCE) ? 1 : 0);
}

if (cmd != NAND_CMD_NONE) {
u8 t = cmd;

rb91x_nand_write(drvdata, &t, 1);
}
}

The above function is used to control nand related gpio signals. The argument,
cmd is used to select control signals and the argument, ctrl is used to set
the value of those signals.</s>




NEXT




<s> ar8327_vtu_op(struct ar8xxx_priv *priv, u32 op, u32 val)
{
if (ar8216_wait_bit(priv, AR8327_REG_VTU_FUNC1,
AR8327_VTU_FUNC1_BUSY, 0))
return;

if ((op & AR8327_VTU_FUNC1_OP) == AR8327_VTU_FUNC1_OP_LOAD)
ar8xxx_write(priv, AR8327_REG_VTU_FUNC0, val);

op |= AR8327_VTU_FUNC1_BUSY;
ar8xxx_write(priv, AR8327_REG_VTU_FUNC1, op);
}

The above function is used to load a new configuration, while the code around it
is used to ensure that the VTU is in a known state before and after the
configuration is loaded. The issue is that no VTU state is protected against
concurrent accesses from other




NEXT




<s> static int rtl8367_sw_set_max_length(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 max_len;

switch (val->value.i) {
case 0:
max_len = RTL8367_SWC0_MAX_LENGTH_1522;
break;
case 1:
max_len = RTL8367_SWC0_MAX_LENGTH_1536;
break;
case 2:
max_len = RTL8367_SWC0_MAX_LENGTH_1552;
break;
case 3:
max_len = RTL8367_SWC0_MAX_LENGTH_16000;
break;
default:
return -EINVAL;
}

return rtl8366_smi_rmwr(smi, RTL8367_SWC0_REG,
RTL8367_SWC0_MAX_LENGTH_MASK, max_len);
}

The above function is used to set the maximum allowed packet size, and it was used for setting the max length of IPv6 to 16000.</s>




NEXT




<s> static int do_exit(void);
static void setup_windows(void);
static void search_conf(void);

typedef void (*function_key_handler_t)(int *key, struct menu *menu);
static void handle_f1(int *key, struct menu *current_item);
static void handle_f2(int *key, struct menu *current_item);
static void handle_f3(int *key, struct menu *current_item);
static void handle_f4(int *key, struct menu *current_item);
static void handle_f5(int *key, struct menu *current_item);
static void handle_f6(int *key, struct menu *current_item);
static void handle_f7(int *key, struct menu *current_item);
static void handle_f8(int *key, struct menu *current_item);
static void handle_f9(int *key, struct menu *current_item);

struct function_keys {
const char *key_str;
const char *func;
function_key key;
function_key_handler_t handler;
};

The above function is used to display the function keys and their functions.
If you want to add new functions, you should add it to the array.</s>




NEXT




<s> ret_t rtl8367c_getAsicFlowControlSharedThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
{
ret_t retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_SHARE_OFF, RTL8367C_FLOWCTRL_SHARE_OFF_MASK, pOffThreshold);

if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_SHARE_ON, RTL8367C_FLOWCTRL_SHARE_ON_MASK, pOnThreshold);

return retVal;
}

The above function is used to get the flow control shared threshold.
In order to implement flow control shared threshold, 8367C_FLOWCTRL_SHARE_ON_MASK and 8367C_FLOWCTRL_SHARE_OFF




NEXT




<s> void ddr_setup(int mhz)
{
static const T_DDR_TIMING_PARAMETERS *ddr_timing_parameters =
&C_TP_DDR2_25_CL6_1GB;
static const T_DDR_CONFIG_PARAMETERS *ddr_config_parameters =
&C_CP_DDR2_25_CL6;

//Bring core out of Reset
*(volatile UINT *) C_DDR_BLKEN_REG = C_BLKEN_DDR_ON;

//DDR TIMING INITIALISTION
ddr_timing_initialisation(ddr_timing_parameters);

//DDR NORMAL INITIALISATION
ddr_normal_initialisation(ddr_config_parameters, mhz);

// route all writes through one client
*(volatile UINT *) C_DDR_TRANSACTION_ROUTING = (0
<< DDR_ROUTE_CPU0_INSTR_SHIFT)
| (1 << DDR_ROUTE_CPU0_RDDATA_SHIFT)
| (3 << DDR_ROUTE_CPU0_WRDATA_SHIFT)
| (2 << DDR_ROUTE_CPU1_INSTR_SHIFT)
| (3 << DDR_ROUTE_CPU1_RDDATA_SHIFT)
| (3 << DDR_ROUTE_CPU1_WRDATA_SHIFT);

//Bring all clients out of reset
*(volatile UINT *) C_DDR_BLKEN_REG = C_BLKEN_DDR_ON + 0x0000FFFF;

}

The above function is used to setup the internal DDR registers so that
access to it will be consistent.

NOTE: On reset, the register values get loaded, so it is no problem to call
this function from anywhere in the application except the Reset ISR




NEXT




<s> static int mtdsplit_parse_tplink(struct mtd_info *master,
const struct mtd_partition **pparts,
struct mtd_part_parser_data *data)
{
struct tplink_fw_header hdr;
size_t hdr_len, retlen, kernel_size;
size_t rootfs_offset;
struct mtd_partition *parts;
int err;

hdr_len = sizeof(hdr);
err = mtd_read(master, 0, hdr_len, &retlen, (void *) &hdr);
if (err)
return err;

if (retlen != hdr_len)
return -EIO;

switch (le32_to_cpu(hdr.version)) {
case 1:
if (be32_to_cpu(hdr.v1.kernel_ofs) != sizeof(hdr))
return -EINVAL;

kernel_size = sizeof(hdr) + be32_to_cpu(hdr.v1.kernel_len);
rootfs_offset = be32_to_cpu(hdr.v1.rootfs_ofs);
break;
case 2:
case 3:
if (be32_to_cpu(hdr.v2.kernel_ofs) != sizeof(hdr))
return -EINVAL;

kernel_size = sizeof(hdr) + be32_to_cpu(hdr.v2.kernel_len);
rootfs_offset = be32_to_cpu(hdr.v2.rootfs_ofs);
break;
default:
return -EINVAL;
}

if (kernel_size > master->size)
return -EINVAL;

/* Find the rootfs */
err = mtd_check_rootfs_magic(master, rootfs_offset, NULL);
if (err) {
/*
* The size in the header might cover the rootfs as well.
* Start the search from an arbitrary offset.
*/
err = mtd_find_rootfs_from(master, TPLINK_MIN_ROOTFS_OFFS,
master->size, &rootfs_offset, NULL);
if (err)
return err;
}

parts = kzalloc(TPLINK_NR_PARTS * sizeof(*parts), GFP_KERNEL);
if (!parts)
return -ENOMEM;

parts[0].name = KERNEL_PART_NAME;
parts[0].offset = 0;
parts[0].size = kernel_size;

parts[1].name = ROOTFS_PART_NAME;
parts[1].offset = rootfs_offset;
parts[1].size = master->size - rootfs_offset;

*pparts = parts;
return TPLINK_NR_PARTS;
}

The above function is used to get the partition information from a firmware file as a source in order to create the partition scheme.
Now write an entry for the above partition scheme in the device-tree.

TPLINK_153:
kernel@8




NEXT




<s> static void *item_data(void)
{
ITEM *cur;
struct mitem *mcur;

cur = current_item(curses_menu);
if (!cur)
return NULL;
mcur = (struct mitem *) item_userptr(cur);
return mcur->usrptr;

}

The above function is used to return user-defined data associated with an item and this function should be created by the menu creator. It is expected that a prototype for the above function is also defined for all the menu functions.

When a menu function is called, either through




NEXT




<s> static int b53_spi_write8(struct b53_device *dev, u8 page, u8 reg, u8 value)
{
struct spi_device *spi = dev->priv;
int ret;
u8 txbuf[3];

ret = b53_prepare_reg_access(spi, page);
if (ret)
return ret;

txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
txbuf[1] = reg;
txbuf[2] = value;

return spi_write(spi, txbuf, sizeof(txbuf));
}

The above function is used to write bytes through SPI interface. The B53_SPI_CMD_NORMAL indicates that this is a normal write. This bit will be set to 0, if the page is not set to zero. B53_SPI_CMD_




NEXT




<s> static inline void m_u32(const char *id, uint32_t value) {
blobmsg_add_u64(&b, id, value);
}

The above function is used to add a u32 into the blobmsg_builder_data_t b (from libblobmsg) with the same data type, here in blobmsg a u64 is considered.

The blobmsg documentation says this, (http




NEXT




<s> rtk_api_ret_t rtk_igmp_suppressionEnable_set(rtk_enable_t reportSuppression, rtk_enable_t leaveSuppression)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(reportSuppression >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if(leaveSuppression >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIGMPSuppression((rtk_uint32)reportSuppression, (rtk_uint32)leaveSuppression))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to enable or disable the report/leave suppression
on Router Advertisement message.
This is a sample of how to call the above function.

/* This sample will disable the report/leave suppression. */
if(




NEXT




<s> static AT91S_DataFlashStatus AT91F_DataFlashSendCommand(
AT91PS_DataFlash pDataFlash,
unsigned char OpCode,
unsigned int CmdSize,
unsigned int DataflashAddress)
{
unsigned int adr;

/* process the address to obtain page address and byte address */
adr = ((DataflashAddress / (pDataFlash->pDevice->pages_size))
<< pDataFlash->pDevice->page_offset) +
(DataflashAddress % (pDataFlash->pDevice->pages_size));

/* fill the  command  buffer */
pDataFlash->pDataFlashDesc->command[0] = OpCode;
if (pDataFlash->pDevice->pages_number >= 16384)
{
pDataFlash->pDataFlashDesc->command[1] = (unsigned char)((adr & 0x0F000000) >> 24);
pDataFlash->pDataFlashDesc->command[2] = (unsigned char)((adr & 0x00FF0000) >> 16);
pDataFlash->pDataFlashDesc->command[3] = (unsigned char)((adr & 0x0000FF00) >> 8);
pDataFlash->pDataFlashDesc->command[4] = (unsigned char)(adr & 0x000000FF);
}
else
{
pDataFlash->pDataFlashDesc->command[1] = (unsigned char)((adr & 0x00FF0000) >> 16);
pDataFlash->pDataFlashDesc->command[2] = (unsigned char)((adr & 0x0000FF00) >> 8);
pDataFlash->pDataFlashDesc->command[3] = (unsigned char)(adr & 0x000000FF) ;
pDataFlash->pDataFlashDesc->command[4] = 0;
}
pDataFlash->pDataFlashDesc->command[5] = 0;
pDataFlash->pDataFlashDesc->command[6] = 0;
pDataFlash->pDataFlashDesc->command[7] = 0;

/* Initialize the SpiData structure for the spi write fuction */
pDataFlash->pDataFlashDesc->tx_cmd_pt   =  pDataFlash->pDataFlashDesc->command ;
pDataFlash->pDataFlashDesc->tx_cmd_size =  CmdSize ;
pDataFlash->pDataFlashDesc->rx_cmd_pt   =  pDataFlash->pDataFlashDesc->command ;
pDataFlash->pDataFlashDesc->rx_cmd_size =  CmdSize ;

return AT91F_SpiWrite(pDataFlash->pDataFlashDesc);
}

The above function is used to send commands to AT91S_DataFlash device.This function is defined in C header file: AT91S_datFlash.h.
Following is a screenshot of datflash structure and its definition:
Note




NEXT




<s> void rtl839x_pie_rule_dump_raw(u32 r[])
{
pr_info("Raw IACL table entry:\n");
pr_info("Match  : %08x %08x %08x %08x %08x %08x\n", r[0], r[1], r[2], r[3], r[4], r[5]);
pr_info("Fixed  : %06x\n", r[6] >> 8);
pr_info("Match M: %08x %08x %08x %08x %08x %08x\n",
(r[6] << 24) | (r[7] >> 8), (r[7] << 24) | (r[8] >> 8), (r[8] << 24) | (r[9] >> 8),
(r[9] << 24) | (r[10] >> 8), (r[10] << 24) | (r[11] >> 8),
(r[11] << 24) | (r[12] >> 8));
pr_info("R[13]:   %08x\n", r[13]);
pr_info("Fixed M: %06x\n", ((r[12] << 16) | (r[13] >> 16)) & 0xffffff);
pr_info("Valid / not / and1 / and2 : %1x\n", (r[13] >> 12) & 0xf);
pr_info("r 13-16: %08x %08x %08x %08x\n", r[13], r[14], r[15], r[16]);
}

The above function is used to dump the raw content of IACL entries when we are trying to dump out IACL table. Since it has only been using for debug, I didn’t modify it.

But when I was trying to find an approach dump the




NEXT




<s> rtk_api_ret_t rtk_i2c_mode_set( rtk_I2C_16bit_mode_t i2cmode )
{
if(i2cmode >= I2C_Mode_END)
{
return RT_ERR_INPUT;
}
else if(i2cmode == I2C_70B_LSB_16BIT_MODE)
{
rtk_i2c_mode = I2C_70B_LSB_16BIT_MODE;

return RT_ERR_OK;
}
else if( i2cmode == I2C_LSB_16BIT_MODE)
{
rtk_i2c_mode = I2C_LSB_16BIT_MODE;
return RT_ERR_OK;
}
else
return RT_ERR_FAILED;

return RT_ERR_OK;
}

The above function is used to set I/O mode for MCU's I2C module.

The default value is RT_2X_IO_4, refer to RT2X_I2C.h for definitions.

Please refer to r




NEXT




<s> rtk_api_ret_t rtk_ptp_portIntStatus_set(rtk_port_t port, rtk_ptp_intStatus_t statusMask)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check port is PTP port */
RTK_CHK_PORT_IS_PTP(port);

if ((retVal = rtl8367c_setAsicEavPortInterruptStatus(rtk_switch_port_L2P_get(port), statusMask))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the PTP port interrupt in port.</s>




NEXT




<s> static int md5_hmac_update(struct shash_desc *desc, const u8 *data, unsigned int len)
{
struct md5_hmac_ctx *mctx = crypto_shash_ctx(desc->tfm);
const u32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);

mctx->byte_count += len;

if (avail > len) {
memcpy((char *)mctx->block + (sizeof(mctx->block) - avail),
data, len);
return 0;
}

memcpy((char *)mctx->block + (sizeof(mctx->block) - avail),
data, avail);

md5_hmac_transform(desc, mctx->block);
data += avail;
len -= avail;

while (len >= sizeof(mctx->block)) {
memcpy(mctx->block, data, sizeof(mctx->block));
md5_hmac_transform(desc, mctx->block);
data += sizeof(mctx->block);
len -= sizeof(mctx->block);
}

memcpy(mctx->block, data, len);
return 0;
}

The above function is used to update hash in HMAC. It copies data from first
available block and then call sha1_transform() for each block
of data.

The above function can be optimized by splitting into two functions
md5_hmac_




NEXT




<s> ret_t rtl8367c_getAsicSvlanIngressUnmatch(rtk_uint32* pMode)
{
return rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UNMAT_MASK, pMode);

}

The above function is used to read the corresponding bit of the corresponding register(RTL8367C_REG_SVLAN_CFG) to return the value of the SVLAN unmatched mode in ASIC 1(RTL8367C_VS




NEXT




<s> ret_t rtl8367c_setAsicI2CTxOneCharCmd(rtk_uint8 oneChar)
{
rtk_uint32 regData;
ret_t retVal;

/* Bits [4-1] = 0b0010, tx one char; Bit [0] = 1, Trigger the Command */
if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
return retVal;

regData &= 0xFFE0;
regData |= 0x0005;
regData &= 0x00FF;
regData |= (rtk_uint16) (oneChar << 8);

if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
return retVal;


/* wait for command finished */
do{
if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
return retVal;
}while( regData != 0x0);

return RT_ERR_OK ;
}

The above function is used to send one character command to the ASIC.
For example, in order to set the I2C frequency divider, the following
code is used.

retVal = rtl8367c_setAsicI2




NEXT




<s> ret_t rtl8367c_getAsicRegBits(rtk_uint32 reg, rtk_uint32 bits, rtk_uint32 *pValue)
{

#if defined(RTK_X86_ASICDRV)

rtk_uint32 regData;
ret_t retVal;
rtk_uint32 bitsShift;

if(bits >= (1 << RTL8367C_REGBITLENGTH) )
return RT_ERR_INPUT;

bitsShift = 0;
while(!(bits & (1 << bitsShift)))
{
bitsShift++;
if(bitsShift >= RTL8367C_REGBITLENGTH)
return RT_ERR_INPUT;
}

retVal = Access_Read(reg, 2, &regData);
if(TRUE != retVal)
return RT_ERR_SMI;

*pValue = (regData & bits) >> bitsShift;

if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);

#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)
rtk_uint32 bitsShift;

if(bits >= (1 << RTL8367C_REGBITLENGTH) )
return RT_ERR_INPUT;

bitsShift = 0;
while(!(bits & (1 << bitsShift)))
{
bitsShift++;
if(bitsShift >= RTL8367C_REGBITLENGTH)
return RT_ERR_INPUT;
}

if(reg >= CLE_VIRTUAL_REG_SIZE)
return RT_ERR_OUT_OF_RANGE;

*pValue = (CleVirtualReg[reg] & bits) >> bitsShift;

if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n", reg, CleVirtualReg[reg]);

#elif defined(EMBEDDED_SUPPORT)
rtk_uint32 regData;
rtk_uint32 bitsShift;

if(reg > RTL8367C_REGDATAMAX )
return RT_ERR_INPUT;

if(bits >= (1UL << RTL8367C_REGBITLENGTH) )
return RT_ERR_INPUT;

bitsShift = 0;
while(!(bits & (1UL << bitsShift)))
{
bitsShift++;
if(bitsShift >= RTL8367C_REGBITLENGTH)
return RT_ERR_INPUT;
}

regData = getReg(reg);
*value = (regData & bits) >> bitsShift;

#else
rtk_uint32 regData;
ret_t retVal;
rtk_uint32 bitsShift;

if(bits>= (1<<RTL8367C_REGBITLENGTH) )
return RT_ERR_INPUT;

bitsShift = 0;
while(!(bits & (1 << bitsShift)))
{
bitsShift++;
if(bitsShift >= RTL8367C_REGBITLENGTH)
return RT_ERR_INPUT;
}

retVal = smi_read(reg, &regData);
if(retVal != RT_ERR_OK) return RT_ERR_SMI;

*pValue = (regData & bits) >> bitsShift;
#ifdef CONFIG_RTL865X_CLE
if(0x8367B == cleDebuggingDisplay)
PRINT("R[0x%4.4x]=0x%4.4x\n",reg, regData);
#endif

#endif
return RT_ERR_OK;
}

The above function is used to return the corresponding bit mask value according to the address register and bit mask values ​​passed in.

#if defined(RTK_X86_ASICDRV)

rtk_int32 rtl83




NEXT




<s> void conf_set_message_callback(void (*fn)(const char *s))
{
conf_message_callback = fn;
}

The above function is used to set the callback to receive message from the backend of zcs.
The callback will be executed in event handler of backend task.

This function will only be called by backend task.
When backend get message form cgi(or other),




NEXT




<s> void close_led(struct led **led)
{
fclose((*led)->controlfd);
free((*led)->sysfspath);
free((*led));
(*led)=NULL;
}

The above function is used to close a led, but for some reason the (led)
pointer is still pointing to the old led address before closing it. So when
the second call is made to open_led() at startup.txt, instead of creating a
new




NEXT




<s> rtk_api_ret_t rtk_trunk_trafficPause_set(rtk_trunk_group_t trk_gid, rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Trunk Group Valid */
RTK_CHK_TRUNK_GROUP_VALID(trk_gid);

if(enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicTrunkingFc((rtk_uint32)trk_gid, (rtk_uint32)enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to control port traffic flow for trunk group.
When enabled, the port trunk traffic flow is paused.

Below is the sample code to control port traffic flow in trunk group
-----------------------------------------------------------
rtk_api_ret_t




NEXT




<s> ret_t rtl8367c_setAsicIGMPBypassStormCTRL(rtk_uint32 bypass)
{
ret_t   retVal;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_DISCARD_STORM_FILTER_OFFSET, bypass);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the IGMP bypass storm control. By setting this mode all IGMP and MLD packets will be dropped. For IGMP snooping applications, this function is supposed to be called when there are lots of IGMP




NEXT




<s> store_port_val(struct nl_msg *msg, struct nlattr *nla, struct switch_val *val)
{
struct nlattr *p;
int ports = val->attr->dev->ports;
int err = 0;
int remaining;

if (!val->value.ports)
val->value.ports = malloc(sizeof(struct switch_port) * ports);

nla_for_each_nested(p, nla, remaining) {
struct nlattr *tb[SWITCH_PORT_ATTR_MAX+1];
struct switch_port *port;

if (val->len >= ports)
break;

err = nla_parse_nested(tb, SWITCH_PORT_ATTR_MAX, p, port_policy);
if (err < 0)
goto out;

if (!tb[SWITCH_PORT_ID])
continue;

port = &val->value.ports[val->len];
port->id = nla_get_u32(tb[SWITCH_PORT_ID]);
port->flags = 0;
if (tb[SWITCH_PORT_FLAG_TAGGED])
port->flags |= SWLIB_PORT_FLAG_TAGGED;

val->len++;
}

out:
return err;
}

The above function is used to parse the received port data in a packet. The received port data is parsed and saved in the struct switch_port[] array. This data will be used in the following section to process the received data.</s>




NEXT




<s> static int aw9523_probe(struct i2c_client *client,
const struct i2c_device_id *id)
{
struct device *dev = &client->dev;
struct pinctrl_desc *pdesc;
struct aw9523 *awi;
int ret;

awi = devm_kzalloc(dev, sizeof(*awi), GFP_KERNEL);
if (!awi)
return -ENOMEM;

i2c_set_clientdata(client, awi);

awi->dev = dev;
awi->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
if (IS_ERR(awi->reset_gpio))
return PTR_ERR(awi->reset_gpio);
gpiod_set_consumer_name(awi->reset_gpio, "aw9523 reset");

awi->regmap = devm_regmap_init_i2c(client, &aw9523_regmap);
if (IS_ERR(awi->regmap))
return PTR_ERR(awi->regmap);

awi->vio_vreg = devm_regulator_get_optional(dev, "vio");
if (IS_ERR(awi->vio_vreg)) {
if (PTR_ERR(awi->vio_vreg) == -EPROBE_DEFER)
return -EPROBE_DEFER;
awi->vio_vreg = NULL;
} else {
ret = regulator_enable(awi->vio_vreg);
if (ret)
return ret;
}

mutex_init(&awi->i2c_lock);
lockdep_set_subclass(&awi->i2c_lock,
i2c_adapter_depth(client->adapter));

pdesc = devm_kzalloc(dev, sizeof(*pdesc), GFP_KERNEL);
if (!pdesc)
return -ENOMEM;

ret = aw9523_hw_init(awi);
if (ret)
goto err_disable_vregs;

pdesc->name = dev_name(dev);
pdesc->owner = THIS_MODULE;
pdesc->pctlops = &aw9523_pinctrl_ops;
pdesc->pmxops  = &aw9523_pinmux_ops;
pdesc->confops = &aw9523_pinconf_ops;
pdesc->pins = aw9523_pins;
pdesc->npins = ARRAY_SIZE(aw9523_pins);

ret = aw9523_init_gpiochip(awi, pdesc->npins);
if (ret)
goto err_disable_vregs;

if (client->irq) {
ret = aw9523_init_irq(awi, client->irq);
if (ret)
goto err_disable_vregs;
}

awi->pctl = devm_pinctrl_register(dev, pdesc, awi);
if (IS_ERR(awi->pctl)) {
ret = PTR_ERR(awi->pctl);
dev_err(dev, "Cannot register pinctrl: %d", ret);
goto err_disable_vregs;
}

ret = devm_gpiochip_add_data(dev, &awi->gpio, awi);
if (ret)
goto err_disable_vregs;

return ret;

err_disable_vregs:
if (awi->vio_vreg)
regulator_disable(awi->vio_vreg);
mutex_destroy(&awi->i2c_lock);
return ret;
}

The above function is used to probe a new aw9523 device.

If no new devices are plugged in after the kernel boots up,
the probe function will automatically return after scanning through
the whole hardware table, and the i2c device will




NEXT




<s> void env_write_dep(FILE *f, const char *autoconfig_name)
{
struct env *e, *tmp;

list_for_each_entry_safe(e, tmp, &env_list, node) {
fprintf(f, "ifneq \"$(%s)\" \"%s\"\n", e->name, e->value);
fprintf(f, "%s: FORCE\n", autoconfig_name);
fprintf(f, "endif\n");
env_del(e);
}
}

The above function is used to generate a script that will take care of
overriding the environment based on some specific rules like
depended on external scripts or on some kind of system configuration.
The function will create a Makefile-compatible script that will first try





NEXT




<s> static void __expr_eliminate_eq(enum expr_type type, struct expr **ep1, struct expr **ep2)
{
/* Recurse down to leaves */

if (e1->type == type) {
__expr_eliminate_eq(type, &e1->left.expr, &e2);
__expr_eliminate_eq(type, &e1->right.expr, &e2);
return;
}
if (e2->type == type) {
__expr_eliminate_eq(type, &e1, &e2->left.expr);
__expr_eliminate_eq(type, &e1, &e2->right.expr);
return;
}

/* e1 and e2 are leaves. Compare them. */

if (e1->type == E_SYMBOL && e2->type == E_SYMBOL &&
e1->left.sym == e2->left.sym &&
(e1->left.sym == &symbol_yes || e1->left.sym == &symbol_no))
return;
if (!expr_eq(e1, e2))
return;

/* e1 and e2 are equal leaves. Prepare them for elimination. */

trans_count++;
expr_free(e1); expr_free(e2);
switch (type) {
case E_OR:
e1 = expr_alloc_symbol(&symbol_no);
e2 = expr_alloc_symbol(&symbol_no);
break;
case E_AND:
e1 = expr_alloc_symbol(&symbol_yes);
e2 = expr_alloc_symbol(&symbol_yes);
break;
default:
;
}
}

The above function is used to handle any equation such as a=b, which may or may not have been resolved already by the symbolic analysis during the expression translation process.
It's use is shown below:

/* Make the symbolic expression a = b simpl




NEXT




<s> void board_inithw(void)
{
int plla_freq;
#ifdef DEBUG
int i;
#endif	/* DEBUG */

timer_init();
uart_init();
preloader_console_init();

plla_freq = plla_set_config(CONFIG_PLLA_FREQ_MHZ);
init_ddr(plla_freq);

#ifdef DEBUG
if(test_memory(CONFIG_SYS_SDRAM_BASE)) {
puts("memory test failed\n");
} else {
puts("memory test done\n");
}
#endif /* DEBUG */
#ifdef CONFIG_SPL_BSS_DRAM_START
extern char __bss_dram_start[];
extern char __bss_dram_end[];
memset(&__bss_dram_start, 0, __bss_dram_end - __bss_dram_start);
#endif
}

The above function is used to set some of the registers in the PLPA (Programmable Logic PLL Array) that are set up during the pre-initialisation. The PLPA provides flexible clocking solutions. The clock frequency provided by the PLPA to different on




NEXT




<s> static int ag71xx_mdio_mii_write(struct mii_bus *bus, int addr, int reg, u16 val)
{
struct ag71xx_mdio *am = bus->priv;

DBG("mii_write: addr=%04x, reg=%04x, value=%04x\n", addr, reg, val);

regmap_write(am->mii_regmap, AG71XX_REG_MII_ADDR,
((addr & 0xff) << MII_ADDR_SHIFT) | (reg & 0xff));
regmap_write(am->mii_regmap, AG71XX_REG_MII_CTRL, val);

ag71xx_mdio_wait_busy(am);

return 0;
}

The above function is used to check if NWay_4 or NWay_6 are supported by the PHY before we do any configuration.

NWay_4 and NWay_6 are special modes of MII operation using four or more media




NEXT




<s> static AT91S_DataFlashStatus AT91F_DataFlashWaitReady(
AT91PS_DataflashDesc pDataFlashDesc,
unsigned int timeout)
{
pDataFlashDesc->DataFlash_state = IDLE;
do {
AT91F_DataFlashGetStatus(pDataFlashDesc);
timeout--;
}
while(((pDataFlashDesc->DataFlash_state & 0x80) != 0x80) && (timeout > 0));

if((pDataFlashDesc->DataFlash_state & 0x80) != 0x80)
return AT91C_DATAFLASH_ERROR;

return AT91C_DATAFLASH_OK;
}

The above function is used to wait for the completion of some operation on a specific
dataflash chip. However it doesn't do any polling to make it more efficient,
hence there is a timeout.
If the operation was successful, then the DataFlash




NEXT




<s> static int rtl8393_serdes_probe(struct phy_device *phydev)
{
int addr = phydev->mdio.addr;

pr_info("%s: id: %d\n", __func__, addr);
if (soc_info.family != RTL8390_FAMILY_ID)
return -ENODEV;

if (addr < 24)
return -ENODEV;

return rtl8390_configure_serdes(phydev);
}

The above function is used to parse the phy device id in order to check whether it is RTL8393PHY or not.
Please refer to RTL8393PHY datasheet on how to do programming for the RTL8393




NEXT




<s> static ssize_t mtd_next_eb(struct mtd_info *mtd, size_t offset)
{
return mtd_rounddown_to_eb(offset, mtd) + mtd->erasesize;
}

The above function is used to calculate the flash device erase block (eb) boundaries.

However, I have noticed this function not work correctly when offset has too small value.
I have checked from the function mtd_rounddown_to_eb as below:




NEXT




<s> rtk_api_ret_t rtk_port_macLocalLoopbackEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(NULL == pEnable)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicPortLoopback(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to get loopback status. The code is as listed below:

<rtl8367c_api.c>
static rtk_enable_t enable;
...
if ((retVal = rtl836




NEXT




<s> ar8327_set_port_igmp(struct ar8xxx_priv *priv, int port, int enable)
{
int reg_frame_ack = AR8327_REG_FRAME_ACK_CTRL(port);
u32 val_frame_ack = (AR8327_FRAME_ACK_CTRL_IGMP_MLD |
AR8327_FRAME_ACK_CTRL_IGMP_JOIN |
AR8327_FRAME_ACK_CTRL_IGMP_LEAVE) <<
AR8327_FRAME_ACK_CTRL_S(port);

if (enable) {
ar8xxx_rmw(priv, AR8327_REG_FWD_CTRL1,
BIT(port) << AR8327_FWD_CTRL1_MC_FLOOD_S,
BIT(port) << AR8327_FWD_CTRL1_IGMP_S);
ar8xxx_reg_set(priv, reg_frame_ack, val_frame_ack);
} else {
ar8xxx_rmw(priv, AR8327_REG_FWD_CTRL1,
BIT(port) << AR8327_FWD_CTRL1_IGMP_S,
BIT(port) << AR8327_FWD_CTRL1_MC_FLOOD_S);
ar8xxx_reg_clear(priv, reg_frame_ack, val_frame_ack);
}
}

The above function is used to enable port for MLD joins / leave messages and will set appropriate bit in FWD_CTRL1 when enabled.

The FWD_CTRL1 register of AR8327 is described below :

Register Description

Bit




NEXT




<s> BigIntegerBitLen(b)
BigInteger b;
{
return BN_num_bits(b);
}

The above function is used to return the number of bits in the b object. It is used a number of times in the library.

When working with very large numbers it is necessary sometimes for bignum library to support very very long bignums (eg: 




NEXT




<s> int rtl839x_read_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 *val)
{
int err = 0;
u32 v;

/* Take bug on RTL839x Rev <= C into account */
if (port >= RTL839X_CPU_PORT)
return -EIO;

mutex_lock(&smi_lock);

/* Set PHY to access */
sw_w32_mask(0xffff << 16, port << 16, RTL839X_PHYREG_DATA_CTRL);

/* Set MMD device number and register to write to */
sw_w32(devnum << 16 | (regnum & 0xffff), RTL839X_PHYREG_MMD_CTRL);

v = BIT(2) | BIT(0); /* MMD-access | EXEC */
sw_w32(v, RTL839X_PHYREG_ACCESS_CTRL);

err = rtl839x_smi_wait_op(100000);
if (err)
goto errout;

/* There is no error-checking via BIT 1 of v, as it does not seem to be set correctly */
*val = (sw_r32(RTL839X_PHYREG_DATA_CTRL) & 0xffff);
pr_debug("%s: port %d, regnum: %x, val: %x (err %d)\n", __func__, port, regnum, *val, err);

errout:
mutex_unlock(&smi_lock);

return err;
}

The above function is used to write to the MMD registers of RTL839x based PCI card.
But, I had already done this by using `phy_write()' and other standard functions. (This `phy_write()' did not work in




NEXT




<s> ar8216_init_globals(struct ar8xxx_priv *priv)
{
/* standard atheros magic */
ar8xxx_write(priv, 0x38, 0xc000050e);

ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
AR8216_GCTRL_MTU, 1518 + 8 + 2);
}

The above function is used to configure the globale parameters of AR7241
(in this case MAC MTU size and 2 byte PCS address header size). As you
can observe the AR7241 is configured via AR8216_




NEXT




<s> rtk_api_ret_t rtk_svlan_tpidEntry_get(rtk_svlan_tpid_t *pSvlan_tag_id)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pSvlan_tag_id)
return RT_ERR_NULL_POINTER;

if ((retVal = rtl8367c_getAsicSvlanTpid(pSvlan_tag_id)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the SVLAN_TPID_VALUE.

rtk_api_ret_t rtk_svlan_tpidEntry_set(rtk_svlan_tpid_t lTpid)
{
rt




NEXT




<s> static void en7523_register_clocks(struct device *dev, struct clk_hw_onecell_data *clk_data,
void __iomem *base, void __iomem *np_base)
{
struct clk_hw *hw;
u32 rate;
int i;

for (i = 0; i < ARRAY_SIZE(en7523_base_clks); i++) {
const struct en_clk_desc *desc = &en7523_base_clks[i];

rate = en7523_get_base_rate(base, i);
rate /= en7523_get_div(base, i);

hw = clk_hw_register_fixed_rate(dev, desc->name, NULL, 0, rate);
if (IS_ERR(hw)) {
pr_err("Failed to register clk %s: %ld\n",
desc->name, PTR_ERR(hw));
continue;
}

clk_data->hws[desc->id] = hw;
}

hw = en7523_register_pcie_clk(dev, np_base);
clk_data->hws[EN7523_CLK_PCIE] = hw;

clk_data->num = EN7523_NUM_CLOCKS;
}

The above function is used to setup clocks on EN7523. This function setup
the PLLs and registers the clocks for the platform.</s>




NEXT




<s> int hostapd_ubus_notify_bss_transition_query(
struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 reason,
const u8 *candidate_list, u16 candidate_list_len)
{
#ifdef CONFIG_WNM_AP
struct ubus_event_req ureq = {};
char *cl_str;
u16 i;

if (!hapd->ubus.obj.has_subscribers)
return 0;

if (!addr)
return 0;

blob_buf_init(&b, 0);
blobmsg_add_macaddr(&b, "address", addr);
blobmsg_add_u8(&b, "dialog-token", dialog_token);
blobmsg_add_u8(&b, "reason", reason);
hostapd_ubus_notify_bss_transition_add_candidate_list(candidate_list, candidate_list_len);

if (!hapd->ubus.notify_response) {
ubus_notify(ctx, &hapd->ubus.obj, "bss-transition-query", b.head, -1);
return 0;
}

if (ubus_notify_async(ctx, &hapd->ubus.obj, "bss-transition-query", b.head, &ureq.nreq))
return 0;

ureq.nreq.status_cb = ubus_event_cb;
ubus_complete_request(ctx, &ureq.nreq.req, 100);

return ureq.resp;
#endif
}

The above function is used to notify Ubus via ubus_notify() that we are going
to try to transition to channel 36 if a station tries to send 802.11n frames that
were not previously 802.11




NEXT




<s> ret_t rtl8367c_setAsicRma(rtk_uint32 index, rtl8367c_rma_t* pRmacfg)
{
rtk_uint32 regData = 0;
ret_t retVal;

if(index > RTL8367C_RMAMAX)
return RT_ERR_RMA_ADDR;

regData |= (pRmacfg->portiso_leaky & 0x0001);
regData |= ((pRmacfg->vlan_leaky & 0x0001) << 1);
regData |= ((pRmacfg->keep_format & 0x0001) << 2);
regData |= ((pRmacfg->trap_priority & 0x0007) << 3);
regData |= ((pRmacfg->discard_storm_filter & 0x0001) << 6);
regData |= ((pRmacfg->operation & 0x0003) << 7);

if( (index >= 0x4 && index <= 0x7) || (index >= 0x9 && index <= 0x0C) || (0x0F == index))
index = 0x04;
else if((index >= 0x13 && index <= 0x17) || (0x19 == index) || (index >= 0x1B && index <= 0x1f))
index = 0x13;
else if(index >= 0x22 && index <= 0x2F)
index = 0x22;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, pRmacfg->trap_priority);
if(retVal != RT_ERR_OK)
return retVal;

return rtl8367c_setAsicReg(RTL8367C_REG_RMA_CTRL00+index, regData);
}

The above function is used to config RMA setting.

In the function, we pass the index of the RMA module. And the first byte has the index value in four bit field. (see below)

The parameter portiso_leaky is to specify




NEXT




<s> static int mt7981_pinctrl_probe(struct platform_device *pdev)
{
return mtk_moore_pinctrl_probe(pdev, &mt7981_data);
}

The above function is used to control GPIOs on MT7981.
This function will call mt7981_pinctrl_populate_pins_state() (see below),
which will call mt7981_pinctrl




NEXT




<s> void rtl8380_sds_rst(int mac)
{
u32 offset = (mac == 24) ? 0 : 0x100;

sw_w32_mask(1 << 11, 0, RTL838X_SDS4_FIB_REG0 + offset);
sw_w32_mask(0x3, 0, RTL838X_SDS4_REG28 + offset);
sw_w32_mask(0x3, 0x3, RTL838X_SDS4_REG28 + offset);
sw_w32_mask(0, 0x1 << 6, RTL838X_SDS4_DUMMY0 + offset);
sw_w32_mask(0x1 << 6, 0, RTL838X_SDS4_DUMMY0 + offset);
pr_debug("SERDES reset: %d\n", mac);
}

The above function is used to reset SERDES in the case of any MAC.

The above code should be changed as follows,

In rtl8380_sds_rst, replace with these commands.

For Mac # 1




NEXT




<s> int dc_ep_pinmux_set(struct dc_ep_priv *priv, u32 gpio, int func)
{
struct dc_aca *aca = to_aca(priv);

if (gpio > aca->max_gpio)
return -EINVAL;

if (func >= MUX_FUNC_RES)
return -EINVAL;

mutex_lock(&aca->pin_lock);
wr32_mask(PADC_MUX_M, func, PADC_MUX(gpio));
mutex_unlock(&aca->pin_lock);
return 0;
}

The above function is used to configure the pin_mux setting for any given GPIO. The function is called inside the
config_adc_pins.c which sets the pin_mux of ADC input pins as a part of platform initialization. This code
is




NEXT




<s> static void rtl8380_phy_reset(struct phy_device *phydev)
{
phy_modify(phydev, 0, BMCR_RESET, BMCR_RESET);
}

The above function is used to manually reset the PHY of rtl8380 by
putting a hard reset on the PHY and reading the MAC status register
to make sure that the PHY has been hard-reset.

If a board is using




NEXT




<s> ret_t rtl8367c_getAsicPortMirrorVlanRxLeaky(rtk_uint32* pEnabled)
{
return rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_RX_VLAN_LEAKY_OFFSET, pEnabled);
}

The above function is used to get the bit value of RTL8367C_REG_MIRROR_CTRL2
(i.e. MIRROR_RX_VLAN_LEAKY_BITS), and set the port mirror le




NEXT




<s> static void mt7621_nfc_pio_write(struct mt7621_nfc *nfc, u32 val, bool bw)
{
u32 reg;

reg = (nfi_read32(nfc, NFI_STA) & STA_NFI_FSM_M) >> STA_NFI_FSM_S;
if (reg != STA_FSM_CUSTOM_DATA) {
reg = nfi_read16(nfc, NFI_CNFG);
reg &= ~(CNFG_READ_MODE | CNFG_BYTE_RW);
if (bw)
reg |= CNFG_BYTE_RW;
nfi_write16(nfc, NFI_CNFG, reg);

nfi_write16(nfc, NFI_CON, CON_NFI_SEC_M | CON_NFI_BWR);
nfi_write16(nfc, NFI_STRDATA, STR_DATA);
}

mt7621_nfc_wait_pio_ready(nfc);
nfi_write32(nfc, NFI_DATAW, val);
}

The above function is used to write data to the PI. Note that the "CON_NFI_BWR" value is calculated using the data
"MT7621_NFI_REG_BWR" defined by the "MT7621_




NEXT




<s> static int psb6970_probe(struct phy_device *pdev)
{
return 0;
}

The above function is used to configure the device.

However, you don’t need to have a deep knowledge of any system architecture! Instead, we have created a small collection of tools to help you work with the SBCs. The kernel debugging tool is located




NEXT




<s> static int rtl930x_route_lookup_hw(struct rtl83xx_route *rt)
{
u32 ip4_m, v;
struct in6_addr ip6_m;

if (rt->attr.type == 1 || rt->attr.type == 3) /* Hardware only supports UC routes */
return -1;

sw_w32_mask(0x3 << 19, rt->attr.type, RTL930X_L3_HW_LU_KEY_CTRL);
if (rt->attr.type) { /* IPv6 */
rtl930x_net6_mask(rt->prefix_len, &ip6_m);
for (int i = 0; i < 4; i++)
sw_w32(rt->dst_ip6.s6_addr32[0] & ip6_m.s6_addr32[0],
RTL930X_L3_HW_LU_KEY_IP_CTRL + (i << 2));
} else { /* IPv4 */
ip4_m = inet_make_mask(rt->prefix_len);
sw_w32(0, RTL930X_L3_HW_LU_KEY_IP_CTRL);
sw_w32(0, RTL930X_L3_HW_LU_KEY_IP_CTRL + 4);
sw_w32(0, RTL930X_L3_HW_LU_KEY_IP_CTRL + 8);
v = rt->dst_ip & ip4_m;
pr_info("%s: searching for %pI4\n", __func__, &v);
sw_w32(v, RTL930X_L3_HW_LU_KEY_IP_CTRL + 12);
}

/* Execute CAM lookup in SoC */
sw_w32(BIT(15), RTL930X_L3_HW_LU_CTRL);

/* Wait until execute bit clears and result is ready */
do {
v = sw_r32(RTL930X_L3_HW_LU_CTRL);
} while (v & BIT(15));

pr_info("%s: found: %d, index: %d\n", __func__, !!(v & BIT(14)), v & 0x1ff);

/* Test if search successful (BIT 14 set) */
if (v & BIT(14))
return v & 0x1ff;

return -1;
}

The above function is used to lookup all the prefixes in the HW
prefix
table (1K). Every prefix in the HW table has a pointer that
points to a
DX entry (64 entries) which contains the hardware counters and
flags




NEXT




<s> ar8216_set_mirror_regs(struct ar8xxx_priv *priv)
{
int port;

/* reset all mirror registers */
ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CPUPORT,
AR8216_GLOBAL_CPUPORT_MIRROR_PORT,
(0xF << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));
for (port = 0; port < AR8216_NUM_PORTS; port++) {
ar8xxx_reg_clear(priv, AR8216_REG_PORT_CTRL(port),
AR8216_PORT_CTRL_MIRROR_RX);

ar8xxx_reg_clear(priv, AR8216_REG_PORT_CTRL(port),
AR8216_PORT_CTRL_MIRROR_TX);
}

/* now enable mirroring if necessary */
if (priv->source_port >= AR8216_NUM_PORTS ||
priv->monitor_port >= AR8216_NUM_PORTS ||
priv->source_port == priv->monitor_port) {
return;
}

ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CPUPORT,
AR8216_GLOBAL_CPUPORT_MIRROR_PORT,
(priv->monitor_port << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));

if (priv->mirror_rx)
ar8xxx_reg_set(priv, AR8216_REG_PORT_CTRL(priv->source_port),
AR8216_PORT_CTRL_MIRROR_RX);

if (priv->mirror_tx)
ar8xxx_reg_set(priv, AR8216_REG_PORT_CTRL(priv->source_port),
AR8216_PORT_CTRL_MIRROR_TX);
}

The above function is used to set the mirror registers which determine where the CPU port mirrors
frames to. It should only be invoked by the CPU port driver.

It is a bit complicated because we are setting up both TX and RX mirroring, and each




NEXT




<s> static void rtl83xx_port_set_salrn(struct rtl838x_switch_priv *priv,
int port, bool enable)
{
int shift = SALRN_PORT_SHIFT(port);
int val = enable ? SALRN_MODE_HARDWARE : SALRN_MODE_DISABLED;

sw_w32_mask(SALRN_MODE_MASK << shift, val << shift,
priv->r->l2_port_new_salrn(port));
}

The above function is used to set the salrn mode (hardware or s/w) of
particular port. What I understand from this is that, for particular
port 'port', you can set the s/w salrn mode by modifying the salrn




NEXT




<s> static int rtl8366_set_pvid(struct rtl8366_smi *smi, unsigned port,
unsigned vid)
{
struct rtl8366_vlan_mc vlanmc;
struct rtl8366_vlan_4k vlan4k;
int err;
int i;

/* Try to find an existing MC entry for this VID */
for (i = 0; i < smi->num_vlan_mc; i++) {
err = smi->ops->get_vlan_mc(smi, i, &vlanmc);
if (err)
return err;

if (vid == vlanmc.vid) {
err = smi->ops->set_vlan_mc(smi, i, &vlanmc);
if (err)
return err;

err = smi->ops->set_mc_index(smi, port, i);
return err;
}
}

/* We have no MC entry for this VID, try to find an empty one */
for (i = 0; i < smi->num_vlan_mc; i++) {
err = smi->ops->get_vlan_mc(smi, i, &vlanmc);
if (err)
return err;

if (vlanmc.vid == 0 && vlanmc.member == 0) {
/* Update the entry from the 4K table */
err = smi->ops->get_vlan_4k(smi, vid, &vlan4k);
if (err)
return err;

vlanmc.vid = vid;
vlanmc.member = vlan4k.member;
vlanmc.untag = vlan4k.untag;
vlanmc.fid = vlan4k.fid;
err = smi->ops->set_vlan_mc(smi, i, &vlanmc);
if (err)
return err;

err = smi->ops->set_mc_index(smi, port, i);
return err;
}
}

/* MC table is full, try to find an unused entry and replace it */
for (i = 0; i < smi->num_vlan_mc; i++) {
int used;

err = rtl8366_mc_is_used(smi, i, &used);
if (err)
return err;

if (!used) {
/* Update the entry from the 4K table */
err = smi->ops->get_vlan_4k(smi, vid, &vlan4k);
if (err)
return err;

vlanmc.vid = vid;
vlanmc.member = vlan4k.member;
vlanmc.untag = vlan4k.untag;
vlanmc.fid = vlan4k.fid;
err = smi->ops->set_vlan_mc(smi, i, &vlanmc);
if (err)
return err;

err = smi->ops->set_mc_index(smi, port, i);
return err;
}
}

dev_err(smi->parent,
"all VLAN member configurations are in use\n");

return -ENOSPC;
}

The above function is used to look up in the MC or 4k table the PVID. While writing the code, if you find anything that needs to be improved, do let us know by commenting below. The rtl8366 driver contains the full source




NEXT




<s> rtk_api_ret_t rtk_led_blinkRate_set(rtk_led_blink_rate_t blinkRate)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (blinkRate >= LED_BLINKRATE_END)
return RT_ERR_FAILED;

if ((retVal = rtl8367c_setAsicLedBlinkRate(blinkRate)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the LED blink rate, the parameter blinkRate is from LED_BLINKRATE_0 to LED_BLINKRATE_MAX.
After this set, the hardware blink rate will change immediately, user can get current rate with the following function




NEXT




<s> int rtl931x_write_mmd_phy(u32 port, u32 devnum, u32 regnum, u32 val)
{
int err = 0;
u32 v;
int type = (regnum & MII_ADDR_C45)?2:1;
u64 pm;

mutex_lock(&smi_lock);

/* Set PHY to access via port-mask */
pm = (u64)1 << port;
sw_w32((u32)pm, RTL931X_SMI_INDRT_ACCESS_CTRL_2);
sw_w32((u32)(pm >> 32), RTL931X_SMI_INDRT_ACCESS_CTRL_2 + 4);

/* Set data to write */
sw_w32_mask(0xffff, val, RTL931X_SMI_INDRT_ACCESS_CTRL_3);

/* Set MMD device number and register to write to */
sw_w32(devnum << 16 | mdiobus_c45_regad(regnum), RTL931X_SMI_INDRT_ACCESS_MMD_CTRL);

v = BIT(4) | type << 2 | BIT(0); /* WRITE | MMD-access-type | EXEC */
sw_w32(v, RTL931X_SMI_INDRT_ACCESS_CTRL_0);

do {
v = sw_r32(RTL931X_SMI_INDRT_ACCESS_CTRL_0);
} while (v & BIT(0));

pr_debug("%s: port %d, dev: %x, regnum: %x, val: %x (err %d)\n", __func__,
port, devnum, mdiobus_c45_regad(regnum), val, err);
mutex_unlock(&smi_lock);

return err;
}

The above function is used to write the given value to MMD phy reg by using the
following sequence
1. MMD_WRITE(MII, devnum, mdiobus_c45_regad(regnum), val)






NEXT




<s> swconfig_done(struct netlink_callback *cb)
{
return 0;
}

The above function is used to configure swconfig. The swconfig can be configured with the help of two types:

1) Using swconf tool
2) By netlink callbacks.

While the first method is pretty simple, the latter one needs a lot




NEXT




<s> static long rtc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
long ret;
ret = rtc_do_ioctl(cmd, arg);
return ret;
}

The above function is used to make rtc calls from sysfs but I want to get these values rtc_do_ioctl which rtc_ioctl calls.The values in /sys/class/rtc/rtc0/value_of_reg are not accurate, the




NEXT




<s> int dram_init(void)
{
gd->ram_size = dram_size((long int *)CONFIG_SYS_SDRAM_BASE,
CONFIG_MAX_SDRAM_SIZE);
return 0;
}

The above function is used to determine the amount of DRAM being used/
available.

This has caused a problem for me in that my 2.2.25 kernel is not capable
of booting the uImage from a 2.4.2




NEXT




<s> static int rtl9300_i2c_mux_deselect(struct i2c_mux_core *muxc, u32 chan)
{
return 0;
}

The above function is used to select a particular i2c channel when multiple
i2c hardware channels are present. If some i2c channels are not configured,
rtl9300_i2c_mux_deselect() will always return 0




NEXT




<s> static unsigned esw_get_port_disable(struct rt305x_esw *esw)
{
unsigned reg;

reg = esw_r32(esw, RT305X_ESW_REG_POC0);
return (reg >> RT305X_ESW_POC0_DIS_PORT_S) &
RT305X_ESW_POC0_DIS_PORT_M;
}

The above function is used to set the number of disabled port.
static void esw_set_port_disable(struct rt305x_esw *esw, int num)
{
unsigned reg;

reg = esw_r3




NEXT




<s> static int ar934x_nfc_ooblayout_ecc(struct mtd_info *mtd, int section,
struct mtd_oob_region *oobregion)
{
if (section)
return -ERANGE;

oobregion->offset = 20;
oobregion->length = 28;

return 0;
}

The above function is used to obtain the NAND flash
out of band data in AR934x chip. The out of band data in NAND flash is
divided into two parts. Each NAND flash device has 168 bytes of OOB data




NEXT




<s> ret_t rtl8367c_getAsicLedOutputEnable(rtk_uint32 *ptr_enabled)
{
ret_t retVal;
rtk_uint32 regdata;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_LED_IO_DISABLE_OFFSET, &regdata);
if (retVal != RT_ERR_OK)
return retVal;

if (regdata == 1)
*ptr_enabled = 0;
else
*ptr_enabled = 1;

return RT_ERR_OK;
}

The above function is used to determine if the LED outputs are enabled in LED output
mode (the LED outputs are disabled on power up and reset, in LED output mode) This information is
available in the RTL8367C register model:


//




NEXT




<s> ret_t rtl8367c_setAsicIGMPReportRX(rtk_uint32 port, rtk_uint32 allow_report)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

if(port < 8)
{
/* Allow Report */
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_REPORT_MASK, allow_report);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_REPORT_MASK, allow_report);
if(retVal != RT_ERR_OK)
return retVal;
}
return RT_ERR_OK;
}

The above function is used to get the status of the report mode of the port selected.
The return of the function will indicates if port can send report to upstream or not.


static rtk_bool_t set_igmp_port_state(




NEXT




<s> rtk_api_ret_t rtk_svlan_l2mc2s_add(rtk_mac_t mac, rtk_mac_t macMsk, rtk_vlan_t svid)
{
rtk_api_ret_t retVal, i;
rtk_uint32 empty_idx;
rtk_uint32 svidx, l2add, l2Mask;
rtl8367c_svlan_memconf_t svlanMemConf;
rtl8367c_svlan_mc2s_t svlanMC2SConf;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (svid > RTL8367C_VIDMAX)
return RT_ERR_SVLAN_VID;

if (mac.octet[0]!= 1&&mac.octet[1]!=0)
return RT_ERR_INPUT;

l2add = (mac.octet[2] << 24) | (mac.octet[3] << 16) | (mac.octet[4] << 8) | mac.octet[5];
l2Mask = (macMsk.octet[2] << 24) | (macMsk.octet[3] << 16) | (macMsk.octet[4] << 8) | macMsk.octet[5];

svidx = 0xFFFF;

for (i = 0; i < RTL8367C_SVIDXNO; i++)
{
if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
return retVal;

if (svid == svlanMemConf.vs_svid)
{
svidx = i;
break;
}
}

if (0xFFFF == svidx)
return RT_ERR_SVLAN_ENTRY_NOT_FOUND;

empty_idx = 0xFFFF;

for (i = RTL8367C_MC2SIDXMAX; i >=0; i--)
{
if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;

if (TRUE == svlanMC2SConf.valid)
{
if (svlanMC2SConf.format == SVLAN_MC2S_MODE_MAC &&
svlanMC2SConf.sdata==l2add&&
svlanMC2SConf.smask==l2Mask)
{
svlanMC2SConf.svidx = svidx;
if ((retVal = rtl8367c_setAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;
}
}
else
{
empty_idx = i;
}
}

if (empty_idx!=0xFFFF)
{
svlanMC2SConf.valid = TRUE;
svlanMC2SConf.svidx = svidx;
svlanMC2SConf.format = SVLAN_MC2S_MODE_MAC;
svlanMC2SConf.sdata = l2add;
svlanMC2SConf.smask = l2Mask;

if ((retVal = rtl8367c_setAsicSvlanMC2SConf(empty_idx, &svlanMC2SConf)) != RT_ERR_OK)
return retVal;
return RT_ERR_OK;
}

return RT_ERR_OUT_OF_RANGE;
}

The above function is used to add new mac to svlan for multicast in SVID.
It will first check if SVID exists ,if not , then it will create SVID.

If SVID  exists , it will check if SVID is full




NEXT




<s> static int b53_mmap_read48(struct b53_device *dev, u8 page, u8 reg, u64 *val)
{
if (WARN_ON(reg % 2))
return -EINVAL;

if (reg % 4) {
u16 lo;
u32 hi;

b53_mmap_read16(dev, page, reg, &lo);
b53_mmap_read32(dev, page, reg + 2, &hi);

*val = ((u64)hi << 16) | lo;
} else {
u32 lo;
u16 hi;

b53_mmap_read32(dev, page, reg, &lo);
b53_mmap_read16(dev, page, reg + 4, &hi);

*val = ((u64)hi << 32) | lo;
}

return 0;
}

The above function is used to read register data from the device memory.</s>




NEXT




<s> static void conf_message(const char *fmt, ...)
__attribute__ ((format (printf, 1, 2)));

static const char *conf_filename;
static int conf_lineno, conf_warnings;

static void conf_warning(const char *fmt, ...)
{
va_list ap;
va_start(ap, fmt);
fprintf(stderr, "%s:%d:warning: ", conf_filename, conf_lineno);
vfprintf(stderr, fmt, ap);
fprintf(stderr, "\n");
va_end(ap);
conf_warnings++;
}

The above function is used to report non-fatal errors, and also by the C
preprocessor whenever it finds something that should be treated as a
warning (when warnings are enabled, of course). In other words, conf_warning is
an alias for fprintf to




NEXT




<s> EXPORT_SYMBOL_GPL(rtl8366_smi_cleanup);

#ifdef CONFIG_OF
static void rtl8366_smi_reset(struct rtl8366_smi *smi, bool active)
{
if (active)
reset_control_assert(smi->reset);
else
reset_control_deassert(smi->reset);
}

The above function is used to reset the SMI chip and it's usage is
exactly the same as in the above snip.

#else /* CONFIG_OF */

#ifdef CONFIG_PM

static void rtl8366_




NEXT




<s> kconfig_print_comment(FILE *fp, const char *value, void *arg)
{
const char *p = value;
size_t l;

for (;;) {
l = strcspn(p, "\n");
fprintf(fp, "#");
if (l) {
fprintf(fp, " ");
xfwrite(p, l, 1, fp);
p += l;
}
fprintf(fp, "\n");
if (*p++ == '\0')
break;
}
}

The above function is used to print comments, which are defined with a comment symbol, for example:
CONFIG_XXX=</s>




NEXT




<s> static int ubootenv_probe(struct platform_device *pdev)
{
struct ubootenv_drvdata *data = &drvdata;
struct device *dev = &pdev->dev;
struct device_node *np;

/* enforce single instance */
if (data->env)
return -EINVAL;

np = of_parse_phandle(dev->of_node, "memory-region", 0);
if (!np)
return -ENODEV;

data->rmem = of_reserved_mem_lookup(np);
of_node_put(np);
if (!data->rmem)
return -ENODEV;

if (!data->rmem->size || (data->rmem->size > ULONG_MAX))
return -EINVAL;

if (!PAGE_ALIGNED(data->rmem->base) || !PAGE_ALIGNED(data->rmem->size))
return -EINVAL;

data->env = devm_memremap(&pdev->dev, data->rmem->base, data->rmem->size, MEMREMAP_WB);
platform_set_drvdata(pdev, data);

data->misc.parent = &pdev->dev;
return misc_register(&data->misc);
}

The above function is used to setup the U-Boot configuration in the
ARM devices. But this function is called by the ubootenv module. But
when we try to use misc_register, the function returns with -22 as
error.

Any




NEXT




<s> int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
* section 1.
*/

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
* we now use fwrite().
*/
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)

The above function is used to print the characters the user has just typed in.
That's where the terminating '\0' is added. This is required to be a 'do { ... }
while (0)' construct, to avoid warnings like these:
warning




NEXT




<s> static int rtl83xx_vlan_filtering(struct dsa_switch *ds, int port,
bool vlan_filtering,
struct netlink_ext_ack *extack)
{
struct rtl838x_switch_priv *priv = ds->priv;

pr_debug("%s: port %d\n", __func__, port);
mutex_lock(&priv->reg_mutex);

if (vlan_filtering) {
/* Enable ingress and egress filtering
* The VLAN_PORT_IGR_FILTER register uses 2 bits for each port to define
* the filter action:
* 0: Always Forward
* 1: Drop packet
* 2: Trap packet to CPU port
* The Egress filter used 1 bit per state (0: DISABLED, 1: ENABLED)
*/
if (port != priv->cpu_port) {
priv->r->set_vlan_igr_filter(port, IGR_DROP);
priv->r->set_vlan_egr_filter(port, EGR_ENABLE);
}
else {
priv->r->set_vlan_igr_filter(port, IGR_TRAP);
priv->r->set_vlan_egr_filter(port, EGR_DISABLE);
}

} else {
/* Disable ingress and egress filtering */
if (port != priv->cpu_port)
priv->r->set_vlan_igr_filter(port, IGR_FORWARD);

priv->r->set_vlan_egr_filter(port, EGR_DISABLE);
}

/* Do we need to do something to the CPU-Port, too? */
mutex_unlock(&priv->reg_mutex);

return 0;
}

The above function is used to control the egress/ingress filtering of the switch using RTL838x MAC-specific functions.</s>




NEXT




<s> ret_t rtl8367c_getAsicShareMeterType(rtk_uint32 index, rtk_uint32 *pType)
{
rtk_uint32 reg;

if(index > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(NULL == pType)
return RT_ERR_NULL_POINTER;

if(index < 32)
reg = RTL8367C_REG_METER_MODE_SETTING0 + (index / 16);
else
reg = RTL8367C_REG_METER_MODE_SETTING2 + ((index - 32) / 16);
return rtl8367c_getAsicRegBit(reg, index % 16, pType);
}

The above function is used to get the type of meter number index. However, if I want to know whether the meter index number is for flow meter or meter, how can I do it?

ret_t rtl8367c_checkAsicFlow




NEXT




<s> int item_n(void)
{
int n = 0;
struct dialog_list *p;

for (p = item_head; p; p = p->next) {
if (p == item_cur)
return n;
n++;
}
return 0;
}

The above function is used to get its index in the item list.

1 Reply

‎08-30-2021 03:41 AM
8 Views

```
static int
item_n(void




NEXT




<s> static void rtk_hal_dump_mib(void)
{

printk("==================%8s%8s%8s%8s%8s%8s%8s\n", "Port0", "Port1",
"Port2", "Port3", "Port4", "Port16", "Port17");
/* Get TX Unicast Pkts */
printk("TX Unicast Pkts  :");
rtk_dump_mib_type(STAT_IfOutUcastPkts);
/* Get TX Multicast Pkts */
printk("TX Multicast Pkts:");
rtk_dump_mib_type(STAT_IfOutMulticastPkts);
/* Get TX BroadCast Pkts */
printk("TX BroadCast Pkts:");
rtk_dump_mib_type(STAT_IfOutBroadcastPkts);
/* Get TX Collisions */
/* Get TX Puase Frames */
printk("TX Pause Frames  :");
rtk_dump_mib_type(STAT_Dot3OutPauseFrames);
/* Get TX Drop Events */
/* Get RX Unicast Pkts */
printk("RX Unicast Pkts  :");
rtk_dump_mib_type(STAT_IfInUcastPkts);
/* Get RX Multicast Pkts */
printk("RX Multicast Pkts:");
rtk_dump_mib_type(STAT_IfInMulticastPkts);
/* Get RX Broadcast Pkts */
printk("RX Broadcast Pkts:");
rtk_dump_mib_type(STAT_IfInBroadcastPkts);
/* Get RX FCS Erros */
printk("RX FCS Errors    :");
rtk_dump_mib_type(STAT_Dot3StatsFCSErrors);
/* Get RX Undersize Pkts */
printk("RX Undersize Pkts:");
rtk_dump_mib_type(STAT_EtherStatsUnderSizePkts);
/* Get RX Discard Pkts */
printk("RX Discard Pkts  :");
rtk_dump_mib_type(STAT_Dot1dTpPortInDiscards);
/* Get RX Fragments */
printk("RX Fragments     :");
rtk_dump_mib_type(STAT_EtherStatsFragments);
/* Get RX Oversize Pkts */
printk("RX Oversize Pkts :");
rtk_dump_mib_type(STAT_EtherOversizeStats);
/* Get RX Jabbers */
printk("RX Jabbers       :");
rtk_dump_mib_type(STAT_EtherStatsJabbers);
/* Get RX Pause Frames */
printk("RX Pause Frames  :");
rtk_dump_mib_type(STAT_Dot3InPauseFrames);
/* clear MIB */
rtk_stat_global_reset();

}

The above function is used to get and dump the mib value by read rtk's mib file.</s>




NEXT




<s> static inline void rttm_enable_timer(void __iomem *base, u32 mode, u32 divisor)
{
iowrite32(RTTM_CTRL_ENABLE | mode | divisor, base + RTTM_CTRL);
}

The above function is used to enable the timer as stated in the function
comment

What could have been an easily understood function can become confusing because of the
inconsistent use of braces. This is a classic case of the dangling else problem. The use




NEXT




<s> rtk_api_ret_t rtk_rldp_portStatus_get(rtk_port_t port, rtk_rldp_portStatus_t *pPortStatus)
{
rtk_api_ret_t retVal;
rtk_uint32 pmsk;
rtk_portmask_t logicalPmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if ((retVal = rtl8367c_getAsicRldpLoopedPortmask(&pmsk))!=RT_ERR_OK)
return retVal;
if ((retVal = rtk_switch_portmask_P2L_get(pmsk, &logicalPmask)) != RT_ERR_OK)
return retVal;

if (logicalPmask.bits[0] & (1<<port))
{
pPortStatus->loop_status = RTK_RLDP_LOOPSTS_LOOPING;
}
else
{
pPortStatus->loop_status  = RTK_RLDP_LOOPSTS_NONE;
}

if ((retVal = rtl8367c_getAsicRldpEnterLoopedPortmask(&pmsk))!=RT_ERR_OK)
return retVal;
if ((retVal = rtk_switch_portmask_P2L_get(pmsk, &logicalPmask)) != RT_ERR_OK)
return retVal;

if (logicalPmask.bits[0] & (1<<port))
{
pPortStatus->loop_enter = RTK_RLDP_LOOPSTS_LOOPING;
}
else
{
pPortStatus->loop_enter  = RTK_RLDP_LOOPSTS_NONE;
}

if ((retVal = rtl8367c_getAsicRldpLeaveLoopedPortmask(&pmsk))!=RT_ERR_OK)
return retVal;
if ((retVal = rtk_switch_portmask_P2L_get(pmsk, &logicalPmask)) != RT_ERR_OK)
return retVal;

if (logicalPmask.bits[0] & (1<<port))
{
pPortStatus->loop_leave = RTK_RLDP_LOOPSTS_LOOPING;
}
else
{
pPortStatus->loop_leave  = RTK_RLDP_LOOPSTS_NONE;
}

return RT_ERR_OK;
}

The above function is used to configure the Port Status for Port 1 in 8367C.

The code to use the above function is:

rtk_port_t port = 1;
rtk_rldp_portStatus




NEXT




<s> static int wlc_afterburner(wlc_param param, void *data, void *value)
{
int *val = (int *) value;
int ret = 0;

if ((param & PARAM_MODE) == GET) {
ret = wl_iovar_get(interface, "afterburner", val, sizeof(int));
} else {
wl_iovar_setint(interface, "wlfeatureflag", (*val ? 3 : 0));
ret = wl_iovar_setint(interface, "afterburner", (*val ? 1 : 0));
wl_iovar_setint(interface, "afterburner_override", *val);
}

return ret;
}

The above function is used to get/set the afterburner functionality for the Atheros wireless driver by applying appropriate bitmaps to the WMI commands.

The wl_ioctl_afterburner function is defined as below:

int
wl_ioctl




NEXT




<s> int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,
BN_MONT_CTX *mont, BN_CTX *ctx)
{
BIGNUM *tmp,*tmp2;
int ret=0;

BN_CTX_start(ctx);
tmp = BN_CTX_get(ctx);
tmp2 = BN_CTX_get(ctx);
if (tmp == NULL || tmp2 == NULL) goto err;

bn_check_top(tmp);
bn_check_top(tmp2);

if (a == b)
{
if (!BN_sqr(tmp,a,ctx)) goto err;
}
else
{
if (!BN_mul(tmp,a,b,ctx)) goto err;
}
/* reduce from aRR to aR */
if (!BN_from_montgomery(r,tmp,mont,ctx)) goto err;
ret=1;
err:
BN_CTX_end(ctx);
return(ret);
}

The above function is used to reduce the the Montgomery form of the first
product from aRR to aR and is called by mod_mul() to reduce and then
modulo the result to get a reduced form of the product.

## Using pre-comp




NEXT




<s> ret_t rtl8367c_setAsicSvlanEgressUnassign(rtk_uint32 enabled)
{
return rtl8367c_setAsicRegBit(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UIFSEG_OFFSET, enabled);
}

The above function is used to set the corresponding bits in SVLAN_CFG
register. In VS mode it means to enable/disable the SVLAN tags to be
removed before tag-comparator.

ret_t rtl8367c_get




NEXT




<s> static u32 rtl8231_read(struct rtl8231_gpios *gpios, u32 reg)
{
u32 t = 0, n = 0;

reg &= 0x1f;

/* Calculate read register address */
t = (gpios->smi_bus_id << 2) | (reg << 7);

/* Set execution bit: cleared when operation completed */
t |= 1;

/* Start execution */
sw_w32(t, gpios->ext_gpio_indrt_access);
do {
udelay(1);
t = sw_r32(gpios->ext_gpio_indrt_access);
n++;
} while ((t & 1) && (n < USEC_TIMEOUT));

if (n >= USEC_TIMEOUT)
return 0x80000000;

pr_debug("%s: %x, %x, %x\n", __func__, gpios->smi_bus_id,
reg, (t & 0xffff0000) >> 16);

return (t & 0xffff0000) >> 16;
}

The above function is used to access SMI function of the SoC.</s>




NEXT




<s> t_getprecount()
{
return (sizeof(pre_params) / sizeof(struct pre_struct));
}

The above function is used to retrieve the number of  precondition objects in a simulation. The number of preconditions in a simulation is the number of precondition structs in the Pre_params[] array.

You might want to retrieve this number during initialisation of your




NEXT




<s> static void srg_led_disable(struct i2c_client *client)
{
struct srg_led_ctrl *sysled_ctrl = i2c_get_clientdata(client);
int i;

for (i = 1; i < 10; i++)
srg_led_i2c_write(sysled_ctrl, i, 0);
}

The above function is used to toggle the LEDs. It’s called from the gpio event handler which is tied to the TP button. This function is also used to disable all of the LEDs.

# Static void toggle_button_event_handler




NEXT




<s> rtk_api_ret_t rtk_cpu_awarePort_set(rtk_portmask_t *pPortmask)
{
rtk_api_ret_t retVal;
rtk_uint32 phyMbrPmask;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Check Valid port mask */
if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

/* Check port mask valid */
RTK_CHK_PORTMASK_VALID(pPortmask);

if(rtk_switch_portmask_L2P_get(pPortmask, &phyMbrPmask) != RT_ERR_OK)
return RT_ERR_FAILED;

if ((retVal = rtl8367c_setAsicCputagPortmask(phyMbrPmask)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the cpu port mask, the api function is as follows:

```
rtk_api_ret_t rtk_cpu_awarePort_set(rtk_portmask_t *pPortmask);
``




NEXT




<s> rtk_api_ret_t rtk_mirror_override_get(rtk_enable_t *pRxMirror, rtk_enable_t *pTxMirror, rtk_enable_t *pAclMirror)
{
rtk_api_ret_t retVal;

if( (pRxMirror == NULL) || (pTxMirror == NULL) || (pAclMirror == NULL))
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_getAsicPortMirrorOverride((rtk_uint32 *)pRxMirror, (rtk_uint32 *)pTxMirror, (rtk_uint32 *)pAclMirror)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to retrieve the mirror override settings of the port.

The return parameter of the function can be set as:

RT_ERR_OK: Successful
RT_ERR_ENABLE: The input port pointer is NULL.
RT_ERR




NEXT




<s> void menu_add_entry(struct symbol *sym)
{
struct menu *menu;

menu = xmalloc(sizeof(*menu));
memset(menu, 0, sizeof(*menu));
menu->sym = sym;
menu->parent = current_menu;
menu->file = current_file;
menu->lineno = zconf_lineno();

*last_entry_ptr = menu;
last_entry_ptr = &menu->next;
current_entry = menu;
if (sym)
menu_add_symbol(P_SYMBOL, sym, NULL);
}

The above function is used to insert new menu into the menu list of the current file.</s>




NEXT




<s> ret_t rtl8367c_getAsicLedGroupMode(rtk_uint32* pMode)
{
ret_t retVal;
rtk_uint32 regData;

retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LED_CONFIGURATION, RTL8367C_LED_CONFIG_SEL_OFFSET, &regData);
if(retVal != RT_ERR_OK)
return retVal;

if(regData!=1)
return RT_ERR_FAILED;

return rtl8367c_getAsicRegBits(RTL8367C_REG_LED_CONFIGURATION, RTL8367C_DATA_LED_MASK, pMode);
}

The above function is used to read the currently used asic led group mode. Please refer the function rtl8367c_getPortLedGroupMode() to read more detail about led group mode.

rtl8367c_getAs




NEXT




<s> enum rtl8366_type rtl8366_smi_detect(struct rtl8366_platform_data *pdata)
{
static struct rtl8366_smi smi;
enum rtl8366_type type = RTL8366_TYPE_UNKNOWN;
u32 reg = 0;

memset(&smi, 0, sizeof(smi));
smi.gpio_sda = pdata->gpio_sda;
smi.gpio_sck = pdata->gpio_sck;
smi.clk_delay = 10;
smi.cmd_read  = 0xa9;
smi.cmd_write = 0xa8;

if (__rtl8366_smi_init(&smi, "rtl8366"))
goto out;

if (rtl8366_smi_read_reg(&smi, 0x5c, &reg))
goto cleanup;

switch(reg) {
case 0x6027:
printk("Found an RTL8366S switch\n");
type = RTL8366_TYPE_S;
break;
case 0x5937:
printk("Found an RTL8366RB switch\n");
type = RTL8366_TYPE_RB;
break;
default:
printk("Found an Unknown RTL8366 switch (id=0x%04x)\n", reg);
break;
}

cleanup:
__rtl8366_smi_cleanup(&smi);
out:
return type;
}

The above function is used to detect whether this EES is an RTL8372B type switch or RTL8366B switch by analyzing the chip id.

For example, the RTL8372B has 0x6




NEXT




<s> static inline unsigned int ag71xx_max_frame_len(unsigned int mtu)
{
return ETH_SWITCH_HEADER_LEN + ETH_HLEN + VLAN_HLEN + mtu + ETH_FCS_LEN;
}

The above function is used to calculate the maximum amount of data that a
driver can transfer in a frame. We currently have two choices, to either set
the maximum frame length to 1492 or 2046 to ensure maximum performance.

There




NEXT




<s> static int rtl8367b_sw_get_max_length(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8367B_SWC0_REG, &data);
val->value.i = (data & RTL8367B_SWC0_MAX_LENGTH_MASK) >>
RTL8367B_SWC0_MAX_LENGTH_SHIFT;

return 0;
}

The above function is used to return the maximum length of the frame in octets. A valid response to this function in switch is 3, which is the maximum frame size of 3 octets.

Please refer to related chapters for the details of setting the maximum frame




NEXT




<s> static int bnrand(int pseudorand, BIGNUM *rnd, int bits, int top, int bottom)
{
unsigned char *buf=NULL;
int ret=0,bit,bytes,mask;

if (bits == 0)
{
BN_zero(rnd);
return 1;
}

bytes=(bits+7)/8;
bit=(bits-1)%8;
mask=0xff<<bit;

buf=(unsigned char *)malloc(bytes);
if (buf == NULL)
{
goto err;
}

/* make a random number and set the top and bottom bits */
/* this ignores the pseudorand flag */

t_random(buf, bytes);

if (top)
{
if (bit == 0)
{
buf[0]=1;
buf[1]|=0x80;
}
else
{
buf[0]|=(3<<(bit-1));
buf[0]&= ~(mask<<1);
}
}
else
{
buf[0]|=(1<<bit);
buf[0]&= ~(mask<<1);
}
if (bottom) /* set bottom bits to whatever odd is */
buf[bytes-1]|=1;
if (!BN_bin2bn(buf,bytes,rnd)) goto err;
ret=1;
err:
if (buf != NULL)
{
memset(buf,0,bytes);
free(buf);
}
return(ret);
}

The above function is used to create random data that has top and bottom bits set to a given value. The function takes the random buffer to be created in bytes. It will fill the buffer and then set the top and bottom bits.

If pseudorand is false the




NEXT




<s> static void adm6996_remove(struct phy_device *pdev)
{
struct adm6996_priv *priv = phy_to_adm(pdev);

if (priv && (priv->model == ADM6996M || priv->model == ADM6996L))
unregister_switch(&priv->dev);
}

The above function is used to destroy a private object while the system
is in a shut down state. I believe that it is a system_shutdown_pre and
therefore we do not need to put a call to sysfs_remove_bin_file() in




NEXT




<s> static void print_item(WINDOW * win, int choice, int selected)
{
int i;
char *list_item = malloc(list_width + 1);

strncpy(list_item, item_str(), list_width - item_x);
list_item[list_width - item_x] = '\0';

/* Clear 'residue' of last item */
wattrset(win, dlg.menubox.atr);
wmove(win, choice, 0);
for (i = 0; i < list_width; i++)
waddch(win, ' ');

wmove(win, choice, check_x);
wattrset(win, selected ? dlg.check_selected.atr
: dlg.check.atr);
if (!item_is_tag(':'))
wprintw(win, "(%c)", item_is_tag('X') ? 'X' : ' ');

wattrset(win, selected ? dlg.tag_selected.atr : dlg.tag.atr);
mvwaddch(win, choice, item_x, list_item[0]);
wattrset(win, selected ? dlg.item_selected.atr : dlg.item.atr);
waddstr(win, list_item + 1);
if (selected) {
wmove(win, choice, check_x + 1);
wrefresh(win);
}
free(list_item);
}

The above function is used to display the text string and the
check mark of items in a choice list.

As each item is defined in the list, the list structure maintains
a list of the items and their status so they can be displayed in their
pro




NEXT




<s> void item_set_tag(char tag)
{
item_cur->node.tag = tag;
}

The above function is used to set one of two possible tags attached to the item.

So, it would be possible to have a new table and set up tags for all possible items and have this check what item is currently in use and then look up the associated value and




NEXT




<s> int dc_ep_gpio_pupd_set(struct dc_ep_priv *priv, u32 gpio, u32 val)
{
struct dc_aca *aca = to_aca(priv);

if (gpio > aca->max_gpio)
return -EINVAL;

/* Not support for both enabled */
if (val >= GPIO_PUPD_BOTH)
return -EINVAL;

mutex_lock(&aca->pin_lock);
switch (val) {
case GPIO_PUPD_DISABLE:
padc_clearbit(gpio, PADC_PUEN);
padc_clearbit(gpio, PADC_PDEN);
break;
case GPIO_PULL_UP:
padc_setbit(gpio, PADC_PUEN);
padc_clearbit(gpio, PADC_PDEN);
break;
case GPIO_PULL_DOWN:
padc_setbit(gpio, PADC_PDEN);
padc_clearbit(gpio, PADC_PUEN);
break;
default:
break;
}
mutex_unlock(&aca->pin_lock);
return 0;
}

The above function is used to configure GPIO pin pudding on the dc-aca-bridge.
The dc-aca-bridge is a part of the DP (Display Port)
subsystem in this case. It is implemented as a DMA channel
driver and registers




NEXT




<s> ret_t rtl8367c_setAsicFlowControlSharedDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
{
ret_t retVal;

if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SHARE_OFF, RTL8367C_FLOWCTRL_FCOFF_SHARE_OFF_MASK, offThreshold);
if(retVal != RT_ERR_OK)
return retVal;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SHARE_ON, RTL8367C_FLOWCTRL_FCOFF_SHARE_ON_MASK, onThreshold);

return retVal;
}

The above function is used to do setting shared memory table when setting shared threshold on flow control. Since the value of the memory table is read from shared memory table and there would be a delay to take effect, it is not easy to debug the issue. There exists a way to




NEXT




<s> static u64 rtl838x_read_l2_entry_using_hash(u32 hash, u32 pos, struct rtl838x_l2_entry *e)
{
u32 r[3];
struct table_reg *q = rtl_table_get(RTL8380_TBL_L2, 0); /* Access L2 Table 0 */
u32 idx = (0 << 14) | (hash << 2) | pos; /* Search SRAM, with hash and at pos in bucket */

rtl_table_read(q, idx);
for (int i = 0; i < 3; i++)
r[i] = sw_r32(rtl_table_data(q, i));

rtl_table_release(q);

rtl838x_fill_l2_entry(r, e);
if (!e->valid)
return 0;

return (((u64) r[1]) << 32) | (r[2]);  /* mac and vid concatenated as hash seed */
}

The above function is used to get the RMAC and RVIDs from a
hash, and is used to build an index into the ARP table.

static u64 rtl838x_read_arp_entry_using_hash(u




NEXT




<s> static int rtl8214fc_suspend(struct phy_device *phydev)
{
rtl8214fc_power_set(phydev, PORT_MII, false);
rtl8214fc_power_set(phydev, PORT_FIBRE, false);

return 0;
}

The above function is used to turn off power supply to
PHY when it does not do phy read/write operation .

What if PHY is not power on during PHY read and write
operation ?

I modified it like below :
static int r




NEXT




<s> static int ag71xx_buffer_size(struct ag71xx *ag)
{
return ag->rx_buf_size +
SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
}

The above function is used to determine the size of the software RX buffer.
The calculation is simple, the driver allocates a pre-defined chunk of memory,
adds in the overhead of a struct sk_buff (60 bytes)
and aligns to




NEXT




<s> static void msdc_enable_cd_irq(struct msdc_host *host, int enable)
{
struct msdc_hw *hw = host->hw;
void __iomem *base = host->base;

/* for sdio, not set */
if ((hw->flags & MSDC_CD_PIN_EN) == 0) {
/* Pull down card detection pin since it is not avaiable */
/*
if (hw->config_gpio_pin)
hw->config_gpio_pin(MSDC_CD_PIN, GPIO_PULL_DOWN);
*/
sdr_clr_bits(MSDC_PS, MSDC_PS_CDEN);
sdr_clr_bits(MSDC_INTEN, MSDC_INTEN_CDSC);
sdr_clr_bits(SDC_CFG, SDC_CFG_INSWKUP);
return;
}

N_MSG(CFG, "CD IRQ Eanable(%d)", enable);

if (enable) {
/* card detection circuit relies on the core power so that the core power
* shouldn't be turned off. Here adds a reference count to keep
* the core power alive.
*/
//msdc_vcore_on(host); //did in msdc_init_hw()

if (hw->config_gpio_pin) /* NULL */
hw->config_gpio_pin(MSDC_CD_PIN, GPIO_PULL_UP);

sdr_set_field(MSDC_PS, MSDC_PS_CDDEBOUNCE, DEFAULT_DEBOUNCE);
sdr_set_bits(MSDC_PS, MSDC_PS_CDEN);
sdr_set_bits(MSDC_INTEN, MSDC_INTEN_CDSC);
sdr_set_bits(SDC_CFG, SDC_CFG_INSWKUP);  /* not in document! Fix me */
} else {
if (hw->config_gpio_pin) /* NULL */
hw->config_gpio_pin(MSDC_CD_PIN, GPIO_PULL_DOWN);

sdr_clr_bits(SDC_CFG, SDC_CFG_INSWKUP);
sdr_clr_bits(MSDC_PS, MSDC_PS_CDEN);
sdr_clr_bits(MSDC_INTEN, MSDC_INTEN_CDSC);

/* Here decreases a reference count to core power since card
* detection circuit is shutdown.
*/
//msdc_vcore_off(host);
}
}

The above function is used to control whether enable host's interrupt signal line SDCLK-IRQ and SDIOCLK-IRQ.</s>




NEXT




<s> hostapd_rrm_nr_clear(struct hostapd_data *hapd)
{
struct hostapd_neighbor_entry *nr;

restart:
dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry, list) {
if (!memcmp(nr->bssid, hapd->own_addr, ETH_ALEN))
continue;

hostapd_neighbor_remove(hapd, nr->bssid, &nr->ssid);
goto restart;
}
}

The above function is used to clear the neighbor db.

The problem in the code comes in the line:

if (!memcmp(nr->bssid, hapd->own_addr, ETH_ALEN))
continue;

which is




NEXT




<s> u64 rtl839x_get_port_reg_be(int reg)
{
u64 v = sw_r32(reg);

v <<= 32;
v |= sw_r32(reg + 4);

return v;
}

The above function is used to read the 32 bit values in the RTL8390/8392
(it may work for more devices if the registers layout is similar), and
it returns them as a 64 bit value in one call




NEXT




<s> ret_t rtl8367c_setAsicAclIpRange(rtk_uint32 index, rtk_uint32 type, ipaddr_t upperIp, ipaddr_t lowerIp)
{
ret_t retVal;
rtk_uint32 regData;
ipaddr_t ipData;

if(index > RTL8367C_ACLRANGEMAX)
return RT_ERR_OUT_OF_RANGE;

retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL4 + index*5, RTL8367C_ACL_IP_RANGE_ENTRY0_CTRL4_MASK, type);
if(retVal != RT_ERR_OK)
return retVal;

ipData = upperIp;

regData = ipData & 0xFFFF;
retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL2 + index*5, regData);
if(retVal != RT_ERR_OK)
return retVal;

regData = (ipData>>16) & 0xFFFF;
retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL3 + index*5, regData);
if(retVal != RT_ERR_OK)
return retVal;

ipData = lowerIp;

regData = ipData & 0xFFFF;
retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL0 + index*5, regData);
if(retVal != RT_ERR_OK)
return retVal;

regData = (ipData>>16) & 0xFFFF;
retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL1 + index*5, regData);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure Asic ACL IP range table.
The register which configured is ACL_IP_RANGE_ENTRYx_CTRLx.
This register is used to store the upper and lower ip range address of certain ACL ip address range.




NEXT




<s> static int rb91x_ooblayout_free(struct mtd_info *mtd, int section,
struct mtd_oob_region *oobregion)
{
switch (section) {
case 0:
oobregion->offset = 0;
oobregion->length = 4;
return 0;
case 1:
oobregion->offset = 4;
oobregion->length = 1;
return 0;
case 2:
oobregion->offset = 6;
oobregion->length = 2;
return 0;
case 3:
oobregion->offset = 11;
oobregion->length = 2;
return 0;
default:
return -ERANGE;
}
}

The above function is used to set the OOB layout and length for the Nand. It is required when the Nand does not conform to the MTD OOB layout guidelines specified in NAND flash memory specification version 1.12 by NAND Working Committee (




NEXT




<s> static int radius_init(struct radius_state *s)
{
memset(s, 0, sizeof(*s));
radius_userdata_init(&s->phase1);
radius_userdata_init(&s->phase2);
}

The above function is used to initialize the radius_state data structure and the user data structures associated with it. The radius_userdata_init function is used to initialize the user data structure associated with the radius_state data structure.

The radius_userdata_init




NEXT




<s> unsigned long cgu_get_pp32_clock(void)
{
struct clk *c = clk_get_ppe();
unsigned long rate = clk_get_rate(c);
clk_put(c);
return rate;
}

The above function is used to read the clock signal from the CGU register.

The first argument to the function is a pointer to a buffer that stores the data structure for the CGU. The second argument is a pointer to a buffer that stores the command for the C




NEXT




<s> int RangeDecoderBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
{
int mi = 1;
int i;
#ifdef _LZMA_LOC_OPT
RC_INIT_VAR
#endif
for(i = numLevels; i > 0; i--)
{
#ifdef _LZMA_LOC_OPT
CProb *prob = probs + mi;
RC_GET_BIT(prob, mi)
#else
mi = (mi + mi) + RangeDecoderBitDecode(probs + mi, rd);
#endif
}
#ifdef _LZMA_LOC_OPT
RC_FLUSH_VAR
#endif
return mi - (1 << numLevels);
}

The above function is used to decode an index of the form:

index = (index_1 << numLevels) + index_lower_level

where index_1 and index_lower_level are each represented as a range tree of depth 1




NEXT




<s> ar8327_vtu_load_vlan(struct ar8xxx_priv *priv, u32 vid, u32 port_mask)
{
u32 op;
u32 val;
int i;

op = AR8327_VTU_FUNC1_OP_LOAD | (vid << AR8327_VTU_FUNC1_VID_S);
val = AR8327_VTU_FUNC0_VALID | AR8327_VTU_FUNC0_IVL;
for (i = 0; i < AR8327_NUM_PORTS; i++) {
u32 mode;

if ((port_mask & BIT(i)) == 0)
mode = AR8327_VTU_FUNC0_EG_MODE_NOT;
else if (priv->vlan == 0)
mode = AR8327_VTU_FUNC0_EG_MODE_KEEP;
else if ((priv->vlan_tagged & BIT(i)) || (priv->vlan_id[priv->pvid[i]] != vid))
mode = AR8327_VTU_FUNC0_EG_MODE_TAG;
else
mode = AR8327_VTU_FUNC0_EG_MODE_UNTAG;

val |= mode << AR8327_VTU_FUNC0_EG_MODE_S(i);
}
ar8327_vtu_op(priv, op, val);
}

The above function is used to configure outgoing VLANs on each port. If the mode is tagged or non-tagged, a mask is created and fed to the VLAN table.</s>




NEXT




<s> swlib_free_attributes(struct switch_attr **head)
{
struct switch_attr *a = *head;
struct switch_attr *next;

while (a) {
next = a->next;
free(a->name);
free(a->description);
free(a);
a = next;
}
*head = NULL;
}

The above function is used to free the switch attributes linked list. The first parameter is a pointer to a pointer that points to the first node of the linked list. The linked list contains information about the switch attributes, such as the name and description of the attribute.

The




NEXT




<s> swlib_free(struct switch_dev *dev)
{
swlib_free_attributes(&dev->ops);
swlib_free_attributes(&dev->port_ops);
swlib_free_attributes(&dev->vlan_ops);
swlib_free_port_map(dev);
free(dev->name);
free(dev->alias);
free(dev);

if (--refcount == 0)
swlib_priv_free();
}

The above function is used to dispose all the allocated memory in the struct switch_dev.The refcount variable keeps track of the number of times the struct switch_dev is referenced, in the case of the reference count reaching 0, the allocated memory is freed.




NEXT




<s> static void pad(int size)
{
if ((ofs % size == 0) && (ofs < erasesize))
return;

if (ofs < erasesize) {
memset(buf + ofs, 0xff, (size - (ofs % size)));
ofs += (size - (ofs % size));
}
ofs = ofs % erasesize;
if (ofs == 0) {
while (mtd_block_is_bad(outfd, mtdofs) && (mtdofs < mtdsize)) {
if (!quiet)
fprintf(stderr, "\nSkipping bad block at 0x%08x   ", mtdofs);

mtdofs += erasesize;

/* Move the file pointer along over the bad block. */
lseek(outfd, erasesize, SEEK_CUR);
}
mtd_erase_block(outfd, mtdofs);
write(outfd, buf, erasesize);
mtdofs += erasesize;
}
}

The above function is used to ensure that the writes on the
partitions (mtdfs) are correctly padded. The erasesize (mtdsize
in previous code) is the erasise size i.e. the
size (0x30




NEXT




<s> static int fe_stop(struct net_device *dev)
{
struct fe_priv *priv = netdev_priv(dev);
unsigned long flags;
int i;

netif_tx_disable(dev);
fe_int_disable(priv->soc->tx_int | priv->soc->rx_int);
napi_disable(&priv->rx_napi);

if (priv->phy)
priv->phy->stop(priv);

spin_lock_irqsave(&priv->page_lock, flags);

fe_reg_w32(fe_reg_r32(FE_REG_PDMA_GLO_CFG) &
~(FE_TX_WB_DDONE | FE_RX_DMA_EN | FE_TX_DMA_EN),
FE_REG_PDMA_GLO_CFG);
spin_unlock_irqrestore(&priv->page_lock, flags);

/* wait dma stop */
for (i = 0; i < 10; i++) {
if (fe_reg_r32(FE_REG_PDMA_GLO_CFG) &
(FE_TX_DMA_BUSY | FE_RX_DMA_BUSY)) {
msleep(20);
continue;
}
break;
}

fe_free_dma(priv);

return 0;
}

The above function is used to stop the fe device. When the device is stopped, it sets the bit corresponding to the power-down flag of each peripheral through the register FE_REG_PDMA_GLO_CFG. This register is used to set and clear the




NEXT




<s> static void _rtl8367c_svlanMc2sStSmi2User(rtl8367c_svlan_mc2s_t *pUserSt, rtk_uint16 *pSmiSt)
{
pUserSt->svidx = (pSmiSt[0] & 0x003F);
pUserSt->format = (pSmiSt[0] & 0x0040) >> 6;
pUserSt->valid = (pSmiSt[0] & 0x0080) >> 7;

pUserSt->smask = pSmiSt[1] | (pSmiSt[2] << 16);
pUserSt->sdata = pSmiSt[3] | (pSmiSt[4] << 16);
}

The above function is used to set static entries. But the value of valid bit is lost.

If you check the register document of RTL8367C/RTL8367B, bit19 of _REM_SET_WST




NEXT




<s> void rtl839x_set_egress_queue(int port, int queue)
{
sw_w32(queue << ((port % 10) *3), RTL839X_QM_PORT_QNUM(port));
}

The above function is used to set the egress queue (aka port queue) of an rtl839x based device for a queue.
An rtl839x device has 10 queues, 0-9.
You can use this




NEXT




<s> static int rtl8366_smi_wait_for_ack(struct rtl8366_smi *smi)
{
int retry_cnt;

retry_cnt = 0;
do {
u32 ack;

rtl8366_smi_read_bits(smi, 1, &ack);
if (ack == 0)
break;

if (++retry_cnt > RTL8366_SMI_ACK_RETRY_COUNT) {
dev_err(smi->parent, "ACK timeout\n");
return -ETIMEDOUT;
}
} while (1);

return 0;
}

The above function is used to detect SMI request acknowledge, as in the case of Ethernet PHY. If an SMI has been executed, this function is called to detect whether the corresponding function has been executed to the completion. Note that in RTL811




NEXT




<s> static bool rtl839x_pie_templ_has(int t, enum template_field_id field_type)
{
for (int i = 0; i < N_FIXED_FIELDS; i++) {
enum template_field_id ft = fixed_templates[t][i];
if (field_type == ft)
return true;
}

return false;
}

The above function is used to find a template that has a certain type of field, and if such a template does not exist, a new one is created and the fields of the template with the new type of field is added to it:
// Add one field in [n




NEXT




<s> rtk_api_ret_t rtk_l2_addr_next_get(rtk_l2_read_method_t read_method, rtk_port_t port, rtk_uint32 *pAddress, rtk_l2_ucastAddr_t *pL2_data)
{
rtk_api_ret_t   retVal;
rtk_uint32      method;
rtl8367c_luttb  l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* Error Checking */
if ((pL2_data == NULL) || (pAddress == NULL))
return RT_ERR_MAC;

if(read_method == READMETHOD_NEXT_L2UC)
method = LUTREADMETHOD_NEXT_L2UC;
else if(read_method == READMETHOD_NEXT_L2UCSPA)
method = LUTREADMETHOD_NEXT_L2UCSPA;
else
return RT_ERR_INPUT;

/* Check Port Valid */
RTK_CHK_PORT_VALID(port);

if(*pAddress > RTK_MAX_LUT_ADDR_ID )
return RT_ERR_L2_L2UNI_PARAM;

memset(&l2Table, 0, sizeof(rtl8367c_luttb));
l2Table.address = *pAddress;

if(read_method == READMETHOD_NEXT_L2UCSPA)
l2Table.spa = rtk_switch_port_L2P_get(port);

if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
return retVal;

if(l2Table.address < *pAddress)
return RT_ERR_L2_ENTRY_NOTFOUND;

memcpy(pL2_data->mac.octet, l2Table.mac.octet, ETHER_ADDR_LEN);
pL2_data->port      = rtk_switch_port_P2L_get(l2Table.spa);
pL2_data->fid       = l2Table.fid;
pL2_data->efid      = l2Table.efid;
pL2_data->ivl       = l2Table.ivl_svl;
pL2_data->cvid      = l2Table.cvid_fid;
pL2_data->is_static = l2Table.nosalearn;
pL2_data->auth      = l2Table.auth;
pL2_data->sa_block  = l2Table.sa_block;
pL2_data->da_block  = l2Table.da_block;
pL2_data->priority  = l2Table.lut_pri;
pL2_data->sa_pri_en = l2Table.sa_en;
pL2_data->fwd_pri_en= l2Table.fwd_en;
pL2_data->address   = l2Table.address;

*pAddress = l2Table.address;

return RT_ERR_OK;

}

The above function is used to do address search and obtain next address.


Example 1:

void rtl8367c_l2_addr_next_get_example(void)
{


}</s>




NEXT




<s> void dc_aca_info_init(struct dc_ep_priv *priv)
{
struct dc_aca *aca = to_aca(priv);

aca->initialized = false;
spin_lock_init(&aca->clk_lock);
spin_lock_init(&aca->rcu_lock);
mutex_init(&aca->pin_lock);
aca->max_gpio = aca_max_gpio(priv);
}

The above function is used to initialize the ACA. We take a struct which is used by the driver to define the registers of each component. All the hardware dependent stuff is defined in the struct_dma_data.

For this, we define a struct_dma_




NEXT




<s> static int rtl8367b_sw_set_max_length(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 max_len;

switch (val->value.i) {
case 0:
max_len = RTL8367B_SWC0_MAX_LENGTH_1522;
break;
case 1:
max_len = RTL8367B_SWC0_MAX_LENGTH_1536;
break;
case 2:
max_len = RTL8367B_SWC0_MAX_LENGTH_1552;
break;
case 3:
max_len = RTL8367B_SWC0_MAX_LENGTH_16000;
break;
default:
return -EINVAL;
}

return rtl8366_smi_rmwr(smi, RTL8367B_SWC0_REG,
RTL8367B_SWC0_MAX_LENGTH_MASK, max_len);
}

The above function is used to change the maximum packet length of incoming
packets. The maximum packet length of incoming packets is used to determine
when to block a packet. A packet with longer size than the configured maximum
length would be dropped by the device. The setting of




NEXT




<s> static int gpio_rb91x_key_direction_input(struct gpio_chip *gc, unsigned offset)
{
switch (offset) {
case GPIO_RB91X_KEY_POLL:
return 0;
default:
return -EINVAL;
}
}

The above function is used to tell the kernel that the GPIO pin at offset
GPIO_RB91X_KEY_POLL is configured as an input GPIO. As we want to use
it as a timer tick input, we need to register our GPIO input device





NEXT




<s> static void rtl838x_pie_init(struct rtl838x_switch_priv *priv)
{
u32 template_selectors;

mutex_init(&priv->pie_mutex);

/* Enable ACL lookup on all ports, including CPU_PORT */
for (int i = 0; i <= priv->cpu_port; i++)
sw_w32(1, RTL838X_ACL_PORT_LOOKUP_CTRL(i));

/* Power on all PIE blocks */
for (int i = 0; i < priv->n_pie_blocks; i++)
sw_w32_mask(0, BIT(i), RTL838X_ACL_BLK_PWR_CTRL);

/* Include IPG in metering */
sw_w32(1, RTL838X_METER_GLB_CTRL);

/* Delete all present rules */
rtl838x_pie_rule_del(priv, 0, priv->n_pie_blocks * PIE_BLOCK_SIZE - 1);

/* Routing bypasses source port filter: disable write-protection, first */
sw_w32_mask(0, 3, RTL838X_INT_RW_CTRL);
sw_w32_mask(0, 1, RTL838X_DMY_REG27);
sw_w32_mask(3, 0, RTL838X_INT_RW_CTRL);

/* Enable predefined templates 0, 1 and 2 for even blocks */
template_selectors = 0 | (1 << 3) | (2 << 6);
for (int i = 0; i < 6; i += 2)
sw_w32(template_selectors, RTL838X_ACL_BLK_TMPLTE_CTRL(i));

/* Enable predefined templates 0, 3 and 4 (IPv6 support) for odd blocks */
template_selectors = 0 | (3 << 3) | (4 << 6);
for (int i = 1; i < priv->n_pie_blocks; i += 2)
sw_w32(template_selectors, RTL838X_ACL_BLK_TMPLTE_CTRL(i));

/* Group each pair of physical blocks together to a logical block */
sw_w32(0b10101010101, RTL838X_ACL_BLK_GROUP_CTRL);
}

The above function is used to initialize the RTL838x switch’s PIE ACL engine. It will program all the required registers to enable the PIE ACL engine and the RTL838x will be able to utilize the PIE ACL




NEXT




<s> static int rtl8366rb_sw_get_learning_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

rtl8366_smi_read_reg(smi, RTL8366RB_SSCR0, &data);
val->value.i = !data;

return 0;
}

The above function is used to get the learning enable status from RTL8366. When it runs, it reads the value of register SSCR0 of RTL8366 switch by rtl8366_smi_read_reg API




NEXT




<s> static int rtl8366s_sw_set_max_length(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
char length_code;

switch (val->value.i) {
case 0:
length_code = RTL8366S_SGCR_MAX_LENGTH_1522;
break;
case 1:
length_code = RTL8366S_SGCR_MAX_LENGTH_1536;
break;
case 2:
length_code = RTL8366S_SGCR_MAX_LENGTH_1552;
break;
case 3:
length_code = RTL8366S_SGCR_MAX_LENGTH_16000;
break;
default:
return -EINVAL;
}

return rtl8366_smi_rmwr(smi, RTL8366S_SGCR,
RTL8366S_SGCR_MAX_LENGTH_MASK,
length_code);
}

The above function is used to change the maximum length for the SGMII.
Since the maximum length of the link is set from 16000 up to 1522, we first
have to check how much we can increase the max length.




NEXT




<s> static void nlog_table_creation(struct nmbm_instance *ni, bool main_table,
uint32_t start_ba, uint32_t end_ba)
{
if (start_ba == end_ba - 1)
nlog_info(ni, "%s info table has been written to block %u\n",
main_table ? "Main" : "Backup", start_ba);
else
nlog_info(ni, "%s info table has been written to block %u-%u\n",
main_table ? "Main" : "Backup", start_ba, end_ba - 1);
}

The above function is used to inform the user that the NFS log table was
copied successfully into specified area, where the first log can be
found. This code seems to be working properly in the original
netapp kernel, but there the code is in a very




NEXT




<s> rtk_api_ret_t rtk_dot1x_macBasedAuthMac_del(rtk_port_t port, rtk_mac_t *pAuth_mac, rtk_fid_t fid)
{
rtk_api_ret_t retVal;
rtk_uint32 method;
rtl8367c_luttb l2Table;

/* Check initialization state */
RTK_CHK_INIT_STATE();

/* must be unicast address */
if ((pAuth_mac == NULL) || (pAuth_mac->octet[0] & 0x1))
return RT_ERR_MAC;

/* Check port Valid */
RTK_CHK_PORT_VALID(port);

if (fid > RTL8367C_FIDMAX)
return RT_ERR_L2_FID;

memset(&l2Table, 0, sizeof(rtl8367c_luttb));

/* fill key (MAC,FID) to get L2 entry */
memcpy(l2Table.mac.octet, pAuth_mac->octet, ETHER_ADDR_LEN);
l2Table.fid = fid;
method = LUTREADMETHOD_MAC;
retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
if (RT_ERR_OK == retVal)
{
if (l2Table.spa != rtk_switch_port_L2P_get(port))
return RT_ERR_DOT1X_MAC_PORT_MISMATCH;

memcpy(l2Table.mac.octet, pAuth_mac->octet, ETHER_ADDR_LEN);
l2Table.fid = fid;
l2Table.auth = 0;
retVal = rtl8367c_setAsicL2LookupTb(&l2Table);
return retVal;
}
else
return retVal;

}

The above function is used to delete a MAC-Base authentication entry. The following example illustrates how to delete a MAC-Base authentication entry:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>




NEXT




<s> static int rtl8367_get_vlan_4k(struct rtl8366_smi *smi, u32 vid,
struct rtl8366_vlan_4k *vlan4k)
{
u32 data[RTL8367_TA_VLAN_DATA_SIZE];
int err;
int i;

memset(vlan4k, '\0', sizeof(struct rtl8366_vlan_4k));

if (vid >= RTL8367_NUM_VIDS)
return -EINVAL;

/* write VID */
REG_WR(smi, RTL8367_TA_ADDR_REG, vid);

/* write table access control word */
REG_WR(smi, RTL8367_TA_CTRL_REG, RTL8367_TA_CTRL_CVLAN_READ);

for (i = 0; i < ARRAY_SIZE(data); i++)
REG_RD(smi, RTL8367_TA_DATA_REG(i), &data[i]);

vlan4k->vid = vid;
vlan4k->member = (data[0] >> RTL8367_TA_VLAN_MEMBER_SHIFT) &
RTL8367_TA_VLAN_MEMBER_MASK;
vlan4k->fid = (data[1] >> RTL8367_TA_VLAN_FID_SHIFT) &
RTL8367_TA_VLAN_FID_MASK;
vlan4k->untag = (data[2] >> RTL8367_TA_VLAN_UNTAG1_SHIFT) &
RTL8367_TA_VLAN_UNTAG1_MASK;
vlan4k->untag |= ((data[3] >> RTL8367_TA_VLAN_UNTAG2_SHIFT) &
RTL8367_TA_VLAN_UNTAG2_MASK) << 2;

return 0;
}

The above function is used to access VLAN table 4K. It contains 2 bugs.

Bug 1: If VLAN table 4K isn’t configured in table access control word, there
is no response to the table access command.





NEXT




<s> void rtl839x_traffic_disable(int source, int dest)
{
rtl839x_mask_port_reg_be(BIT_ULL(dest), 0, rtl839x_port_iso_ctrl(source));
}

The above function is used to mask out port_iso_ctrl registers when traffic on port 0/1 is disabled using the following function


void rtl839x_port_traffic_disable(int port)
{
uint32_




NEXT




<s> static inline void oxnas_register_clear_mask(void __iomem *p, unsigned mask)
{
u32 val = readl_relaxed(p);

val &= ~mask;
writel_relaxed(val, p);
}

The above function is used to write to clear bits in a register where the register is assumed to have some bits reserved (masked-off).

In order to find out the mask the value of the register is written to and then the mask is applied and then finally the




NEXT




<s> ret_t rtl8367c_setAsicIGMPVLANLeaky(rtk_uint32 leaky)
{
ret_t   retVal;

retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_VLAN_LEAKY_OFFSET, leaky);
if(retVal != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to set the VLAN Leaky function. In the example, a single member vlan can only go out from a single port, so the value should set to 1. The VLAN Leaky function is controlled by the bit[11]




NEXT




<s> static int ip17xx_set_pvid(struct switch_dev *dev, int port, int val)
{
struct ip17xx_state *state = get_state(dev);

if (val < 0 || val >= MAX_VLANS)
return -EINVAL;

state->ports[port].pvid = val;
return state->regs->update_state(state);
}

The above function is used to set a port vlan id (PVID) of a specified port of a switch port group. The range of this id value is 0 to 4095. The default value is 1.

The main difference between `




NEXT




<s> void rtl930x_traffic_disable(int source, int dest)
{
struct table_reg *r = rtl_table_get(RTL9300_TBL_0, 6);
rtl_table_read(r, source);
sw_w32_mask(BIT(dest + 3), 0, rtl_table_data(r, 0));
rtl_table_write(r, source);
rtl_table_release(r);
}

The above function is used to disable receiving traffic for
the Rx buffer of a given MAC address on the rtl930x driver. It
may not work correctly on hardware that supports QoS (Quality of
Service) functionality. The bug in r




NEXT




<s> ar8327_leds_cleanup(struct ar8xxx_priv *priv)
{
struct ar8327_data *data = priv->chip_data;
unsigned i;

if (!IS_ENABLED(CONFIG_AR8216_PHY_LEDS))
return;

for (i = 0; i < data->num_leds; i++) {
struct ar8327_led *aled;

aled = data->leds[i];
ar8327_led_destroy(aled);
}

kfree(data->leds);
}

The above function is used to cleanup the led data if the chip is not
attached to a led driver.

In the probe callback of the led driver, it will call
ar8327_chip_attach(struct ar8xxx_priv *priv




NEXT




<s> psb6970_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
struct switch_val *val)
{
struct psb6970_priv *priv = to_psb6970(dev);
priv->vlan = !!val->value.i;
return 0;
}

The above function is used to set and read vlan capability using EEPROM
commands. I think if that capability is set to 1 in this function EEPROM
is updated and then switch_read() will not read updated capability from
EEPROM




NEXT




<s> rtk_uint32 rtk_switch_port_L2P_get(rtk_port_t logicalPort)
{
if(init_state != INIT_COMPLETED)
return UNDEFINE_PHY_PORT;

if(logicalPort >= RTK_SWITCH_PORT_NUM)
return UNDEFINE_PHY_PORT;

return (halCtrl->l2p_port[logicalPort]);
}

The above function is used to get the physical port number of the logical port.</s>




NEXT




<s> ret_t rtl8367c_getAsicPortUnknownDaBehavior(rtk_uint32 port, rtk_uint32 *pBehavior)
{
if(port >= RTL8367C_PORTNO)
return RT_ERR_PORT_ID;

if(port < 8)
return rtl8367c_getAsicRegBits(RTL8367C_REG_UNKNOWN_UNICAST_DA_PORT_BEHAVE, RTL8367C_Port0_ACTION_MASK << (port * 2), pBehavior);
else
return rtl8367c_getAsicRegBits(RTL8367C_REG_UNKNOWN_UNICAST_DA_PORT_BEHAVE_EXT, RTL8367C_PORT8_ACTION_MASK << ((port-8) * 2), pBehavior);
}

The above function is used to read the unknown ucast to port 0/1/2/3/4/5/6/7 behavior.

When port unknown ucast is input, the following 3 actions could be set when the switch is initially configured.




NEXT




<s> static void ar934x_nfc_free_buf(struct ar934x_nfc *nfc)
{
dma_free_coherent(nfc->parent, nfc->buf_size, nfc->buf, nfc->buf_dma);
}

The above function is used to free the buffer while the host is in
slepl mode.

To avoid unnecessary wakeup, should be called by ar934x_nfc_process_tx_desc
when driver is in HALT state. However




NEXT




<s> ead_set_key(unsigned char *skey)
{
uint32_t *ivp = (uint32_t *)skey;

memset(aes_enc_ctx, 0, sizeof(aes_enc_ctx));
memset(aes_dec_ctx, 0, sizeof(aes_dec_ctx));

/* first 32 bytes of skey are used as aes key for
* encryption and decryption */
rijndaelKeySetupEnc(aes_enc_ctx, skey);
rijndaelKeySetupDec(aes_dec_ctx, skey);

/* the following bytes are used as initialization vector for messages
* (highest byte cleared to avoid overflow) */
ivp += 8;
ead_rx_iv = ntohl(*ivp) & 0x00ffffff;
ead_tx_iv = ead_rx_iv;

/* the last bytes are used to feed the random iv increment */
ivp++;
ivofs_vec = *ivp;
}

The above function is used to set up the AES encryption and decryption initialization vectors. The first 32 bytes of the secret key are used for both encryption and decryption. The next 8 bytes (ivp) form the first 32-bits of the




NEXT




<s> bool menu_has_prompt(struct menu *menu)
{
if (!menu->prompt)
return false;
return true;
}

The above function is used to check for NULL pointers and avoid segfaults.

Inside this function, NULL check may become difficult so you may try some alternative technique:

> > For instance, you can make use of assertion library. Using the




NEXT




<s> static void md5_hmac_transform(struct shash_desc *desc, u32 const *in)
{
struct md5_hmac_ctx *mctx = crypto_shash_ctx(desc->tfm);

if ( ((mctx->dbn<<4)+1) > MD5_HMAC_DBN_TEMP_SIZE )
{
//printk("MD5_HMAC_DBN_TEMP_SIZE exceeded\n");
md5_hmac_final_impl(desc, (u8 *)mctx->hash, false);
}

memcpy(&mctx->temp[mctx->dbn], in, 64); //dbn workaround
mctx->dbn += 1;
}

The above function is used to update the checksum of a payload in case of MD5-HMAC algorithm. For our purposes, though, the function is needed even if MD5 is not used over HMAC. The problem is that md5_hmac_transform function




NEXT




<s> static void rtl931x_symerr_clear(u32 sds, phy_interface_t mode)
{

switch (mode) {
case PHY_INTERFACE_MODE_NA:
break;
case PHY_INTERFACE_MODE_XGMII:
u32 xsg_sdsid_0, xsg_sdsid_1;

if (sds < 2)
xsg_sdsid_0 = sds;
else
xsg_sdsid_0 = (sds - 1) * 2;
xsg_sdsid_1 = xsg_sdsid_0 + 1;

for (int i = 0; i < 4; ++i) {
rtl9310_sds_field_w(xsg_sdsid_0, 0x1, 24,  2, 0, i);
rtl9310_sds_field_w(xsg_sdsid_0, 0x1,  3, 15, 8, 0x0);
rtl9310_sds_field_w(xsg_sdsid_0, 0x1,  2, 15, 0, 0x0);
}

for (int i = 0; i < 4; ++i) {
rtl9310_sds_field_w(xsg_sdsid_1, 0x1, 24,  2, 0, i);
rtl9310_sds_field_w(xsg_sdsid_1, 0x1,  3, 15, 8, 0x0);
rtl9310_sds_field_w(xsg_sdsid_1, 0x1,  2, 15, 0, 0x0);
}

rtl9310_sds_field_w(xsg_sdsid_0, 0x1, 0, 15, 0, 0x0);
rtl9310_sds_field_w(xsg_sdsid_0, 0x1, 1, 15, 8, 0x0);
rtl9310_sds_field_w(xsg_sdsid_1, 0x1, 0, 15, 0, 0x0);
rtl9310_sds_field_w(xsg_sdsid_1, 0x1, 1, 15, 8, 0x0);
break;
default:
break;
}

return;
}

The above function is used to clear errors recorded in the SDS and re-setting the counters to 0. When the SDS detects an error, each channel in the bank can be programmed to hold the particular error source ID, the source ID, the Error




NEXT




<s> static int psb6970_get_ports(struct switch_dev *dev, struct switch_val *val)
{
struct psb6970_priv *priv = to_psb6970(dev);
u8 ports = priv->vlan_table[val->port_vlan];
int i;

val->len = 0;
for (i = 0; i < PSB6970_NUM_PORTS; i++) {
struct switch_port *p;

if (!(ports & (1 << i)))
continue;

p = &val->value.ports[val->len++];
p->id = i;
if (priv->vlan_tagged & (1 << i))
p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
else
p->flags = 0;
}
return 0;
}

The above function is used to populate the structure switch_val (as per specs
located in the include/switchdev.h file) and returns 0 so all went well.</s>




NEXT




<s> static int rtl8366s_write_phy_reg(struct rtl8366_smi *smi,
u32 phy_no, u32 page, u32 addr, u32 data)
{
u32 reg;
int ret;

if (phy_no > RTL8366S_PHY_NO_MAX)
return -EINVAL;

if (page > RTL8366S_PHY_PAGE_MAX)
return -EINVAL;

if (addr > RTL8366S_PHY_ADDR_MAX)
return -EINVAL;

ret = rtl8366_smi_write_reg(smi, RTL8366S_PHY_ACCESS_CTRL_REG,
RTL8366S_PHY_CTRL_WRITE);
if (ret)
return ret;

reg = 0x8000 | (1 << (phy_no + RTL8366S_PHY_NO_OFFSET)) |
((page << RTL8366S_PHY_PAGE_OFFSET) & RTL8366S_PHY_PAGE_MASK) |
(addr & RTL8366S_PHY_REG_MASK);

ret = rtl8366_smi_write_reg(smi, reg, data);
if (ret)
return ret;

return 0;
}

The above function is used to write data to specific SMI page and address.</s>




NEXT




<s> static int pad_image(char *name, uint32_t pad_mask)
{
char *buf;
int fd;
int outfd;
ssize_t in_len;
ssize_t out_len;
int ret = -1;

buf = malloc(BUF_SIZE);
if (!buf) {
ERR("No memory for buffer");
goto out;
}

fd = open(name, O_RDWR);
if (fd < 0) {
ERRS("Unable to open %s", name);
goto free_buf;
}

in_len = lseek(fd, 0, SEEK_END);
if (in_len < 0)
goto close;

if (!pad_to_stdout)
outfd = fd;
else
outfd = STDOUT_FILENO;

memset(buf, '\xff', BUF_SIZE);

in_len += xtra_offset;

out_len = in_len;
while (pad_mask) {
uint32_t mask;
ssize_t t;
int i;

for (i = 10; i < 32; i++) {
mask = 1UL << i;
if (pad_mask & mask)
break;
}

in_len = ALIGN(in_len, mask);

for (i = 10; i < 32; i++) {
mask = 1UL << i;
if ((in_len & (mask - 1)) == 0)
pad_mask &= ~mask;
}

fprintf(stderr, "padding image to %08x\n", (unsigned int) in_len - xtra_offset);

while (out_len < in_len) {
ssize_t len;

len = in_len - out_len;
if (len > BUF_SIZE)
len = BUF_SIZE;

t = write(outfd, buf, len);
if (t != len) {
ERRS("Unable to write to %s", name);
goto close;
}

out_len += len;
}

/* write out the JFFS end-of-filesystem marker */
t = write(outfd, pad, pad_len);
if (t != pad_len) {
ERRS("Unable to write to %s", name);
goto close;
}
out_len += pad_len;
}

ret = 0;

close:
close(fd);
free_buf:
free(buf);
out:
return ret;
}

The above function is used to pad images.</s>




NEXT




<s> static inline bool ar934x_nfc_use_irq(struct ar934x_nfc *nfc)
{
return AR934X_NFC_USE_IRQ;
}

The above function is used to switch between polling mode and interrupt
mode for the NFC host. However, it is always returning AR934X_NFC_USE_IRQ.
That is, it will always use interrupt mode. My question is: what




NEXT




<s> ar8xxx_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
{
struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
u8 *vt = &priv->vlan_table[val->port_vlan];
int i, j;

*vt = 0;
for (i = 0; i < val->len; i++) {
struct switch_port *p = &val->value.ports[i];

if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
priv->vlan_tagged |= (1 << p->id);
} else {
priv->vlan_tagged &= ~(1 << p->id);
priv->pvid[p->id] = val->port_vlan;

/* make sure that an untagged port does not
* appear in other vlans */
for (j = 0; j < dev->vlans; j++) {
if (j == val->port_vlan)
continue;
priv->vlan_table[j] &= ~(1 << p->id);
}
}

*vt |= 1 << p->id;
}
return 0;
}

The above function is used to set individual port’s VLAN, and it contains the function calls for both VLAN tagged and untagged port.
A quick look back at the code above reveals the following:
1. There is a reference to a global variable




NEXT




<s> rtk_api_ret_t rtk_rldp_config_set(rtk_rldp_config_t *pConfig)
{
rtk_api_ret_t retVal;
ether_addr_t magic;
rtk_uint32 pmsk;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (pConfig->rldp_enable >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if (pConfig->trigger_mode >= RTK_RLDP_TRIGGER_END)
return RT_ERR_INPUT;

if (pConfig->compare_type >= RTK_RLDP_CMPTYPE_END)
return RT_ERR_INPUT;

if (pConfig->num_check >= RTK_RLDP_NUM_MAX)
return RT_ERR_INPUT;

if (pConfig->interval_check >= RTK_RLDP_INTERVAL_MAX)
return RT_ERR_INPUT;

if (pConfig->num_loop >= RTK_RLDP_NUM_MAX)
return RT_ERR_INPUT;

if (pConfig->interval_loop >= RTK_RLDP_INTERVAL_MAX)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_getAsicRldpTxPortmask(&pmsk))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRldpTxPortmask(0x00))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRldpTxPortmask(pmsk))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRldp(pConfig->rldp_enable))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRldpTriggerMode(pConfig->trigger_mode))!=RT_ERR_OK)
return retVal;

memcpy(&magic, &pConfig->magic, sizeof(ether_addr_t));
if ((retVal = rtl8367c_setAsicRldpMagicNum(magic))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRldpCompareRandomNumber(pConfig->compare_type))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRldpCompareRandomNumber(pConfig->compare_type))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRldpCheckingStatePara(pConfig->num_check, pConfig->interval_check))!=RT_ERR_OK)
return retVal;

if ((retVal = rtl8367c_setAsicRldpLoopStatePara(pConfig->num_loop, pConfig->interval_loop))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to configure the rldp parameters of the device.
The input parameter passed is pConfig, which is a pointer to the RLDP configuration structure;
the output parameter (return) is the error value.
The RT_ERR_OK




NEXT




<s> WriteMbox (u32 * mboxarray, u32 size)
{
IFX_MEI_DebugWrite (&dsl_devices[0], IMBOX_BASE, mboxarray, size);
IFX_MEI_DMSG("write to %X\n", IMBOX_BASE);
IFX_MEI_LongWordWriteOffset (&dsl_devices[0], (u32) ME_ME2ARC_INT, MEI_TO_ARC_MSGAV);
}

The above function is used to send a message to the ARC (message 2, ARC to message A), but before sending, the value of message 2 is written to MEI_TO_ARC_MSGAV. If now send a simple IMBOX dump




NEXT




<s> static void rtl930x_host_route_write(int idx, struct rtl83xx_route *rt)
{
u32 v;
/* Access L3_HOST_ROUTE_IPUC table (1) via register RTL9300_TBL_1 */
struct table_reg *r = rtl_table_get(RTL9300_TBL_1, 1);
/* The table has a size of 5 (for UC, 11 for MC) registers */

idx = ((idx / 6) * 8) + (idx % 6);

pr_debug("%s: index %d is valid: %d\n", __func__, idx, rt->attr.valid);
pr_debug("%s: next_hop: %d, hit: %d, action :%d, ttl_dec %d, ttl_check %d, dst_null %d\n",
__func__, rt->nh.id, rt->attr.hit, rt->attr.action, rt->attr.ttl_dec, rt->attr.ttl_check,
rt->attr.dst_null);
pr_debug("%s: GW: %pI4, prefix_len: %d\n", __func__, &rt->dst_ip, rt->prefix_len);

v = BIT(31); /* Entry is valid */
v |= (rt->attr.type & 0x3) << 29;
v |= rt->attr.hit ? BIT(20) : 0;
v |= rt->attr.dst_null ? BIT(19) : 0;
v |= (rt->attr.action & 0x3) << 17;
v |= (rt->nh.id & 0x7ff) << 6;
v |= rt->attr.ttl_dec ? BIT(5) : 0;
v |= rt->attr.ttl_check ? BIT(4) : 0;
v |= rt->attr.qos_as ? BIT(3) : 0;
v |= rt->attr.qos_prio & 0x7;

sw_w32(v, rtl_table_data(r, 0));
switch (rt->attr.type) {
case 0: /* IPv4 Unicast route */
sw_w32(0, rtl_table_data(r, 1));
sw_w32(0, rtl_table_data(r, 2));
sw_w32(0, rtl_table_data(r, 3));
sw_w32(rt->dst_ip, rtl_table_data(r, 4));
break;
case 2: /* IPv6 Unicast route */
sw_w32(rt->dst_ip6.s6_addr32[0], rtl_table_data(r, 1));
sw_w32(rt->dst_ip6.s6_addr32[1], rtl_table_data(r, 2));
sw_w32(rt->dst_ip6.s6_addr32[2], rtl_table_data(r, 3));
sw_w32(rt->dst_ip6.s6_addr32[3], rtl_table_data(r, 4));
break;
case 1: /* IPv4 Multicast route */
case 3: /* IPv6 Multicast route */
pr_warn("%s: route type not supported\n", __func__);
goto out;
}

rtl_table_write(r, idx);

out:
rtl_table_release(r);
}

The above function is used to write the contents of the host routes to the hardware, what we needed was to write 5 bytes. The first and the second byte is the action type (unicast, multicast and etc). The third byte is the next hop host




NEXT




<s> static int clk_mt7986_infracfg_probe(struct platform_device *pdev)
{
struct clk_onecell_data *clk_data;
struct device_node *node = pdev->dev.of_node;
int r;
void __iomem *base;
int nr = ARRAY_SIZE(infra_divs) + ARRAY_SIZE(infra_muxes) +
ARRAY_SIZE(infra_clks);

base = of_iomap(node, 0);
if (!base) {
pr_err("%s(): ioremap failed\n", __func__);
return -ENOMEM;
}

clk_data = mtk_alloc_clk_data(nr);

if (!clk_data)
return -ENOMEM;

mtk_clk_register_factors(infra_divs, ARRAY_SIZE(infra_divs), clk_data);
mtk_clk_register_muxes(infra_muxes, ARRAY_SIZE(infra_muxes), node,
&mt7986_clk_lock, clk_data);
mtk_clk_register_gates(node, infra_clks, ARRAY_SIZE(infra_clks),
clk_data);

r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
if (r) {
pr_err("%s(): could not register clock provider: %d\n",
__func__, r);
goto free_infracfg_data;
}
return r;

free_infracfg_data:
mtk_free_clk_data(clk_data);
return r;

}

The above function is used to register infra_clks which is defined as below:
const char *infra_clks[] = {
"ckcpu_ck_div_clk",
"gpp11",
"gpp10",





NEXT




<s> rtk_api_ret_t rtk_filter_igrAcl_field_add(rtk_filter_cfg_t* pFilter_cfg, rtk_filter_field_t* pFilter_field)
{
rtk_uint32 i;
rtk_filter_field_t *tailPtr;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(NULL == pFilter_cfg || NULL == pFilter_field)
return RT_ERR_NULL_POINTER;

if(pFilter_field->fieldType >= FILTER_FIELD_END)
return RT_ERR_ENTRY_INDEX;


if(0 == pFilter_field->fieldTemplateNo)
{
pFilter_field->fieldTemplateNo = filter_fieldSize[pFilter_field->fieldType];

for(i = 0; i < pFilter_field->fieldTemplateNo; i++)
{
pFilter_field->fieldTemplateIdx[i] = filter_fieldTemplateIndex[pFilter_field->fieldType][i];
}
}

if(NULL == pFilter_cfg->fieldHead)
{
pFilter_cfg->fieldHead = pFilter_field;
}
else
{
if (pFilter_cfg->fieldHead->next == NULL)
{
pFilter_cfg->fieldHead->next = pFilter_field;
}
else
{
tailPtr = pFilter_cfg->fieldHead->next;
while( tailPtr->next != NULL)
{
tailPtr = tailPtr->next;
}
tailPtr->next = pFilter_field;
}
}

return RT_ERR_OK;
}

The above function is used to add a entry in filter configuration.

Example : rtk_filter_igrAcl_field_add

Add filter field, the input parameter filter_cfg is used to configure the filter information. The input parameter filter_field is




NEXT




<s> int BN_set_word(BIGNUM *a, BN_ULONG w)
{
int i,n;
if (bn_expand(a,sizeof(BN_ULONG)*8) == NULL) return(0);

n=sizeof(BN_ULONG)/BN_BYTES;
a->neg=0;
a->top=0;
a->d[0]=(BN_ULONG)w&BN_MASK2;
if (a->d[0] != 0) a->top=1;
for (i=1; i<n; i++)
{
/* the following is done instead of
* w>>=BN_BITS2 so compilers don't complain
* on builds where sizeof(long) == BN_TYPES */
#ifndef SIXTY_FOUR_BIT /* the data item > unsigned long */
w>>=BN_BITS4;
w>>=BN_BITS4;
#else
w=0;
#endif
a->d[i]=(BN_ULONG)w&BN_MASK2;
if (a->d[i] != 0) a->top=i+1;
}
return(1);
}

The above function is used to construct a big-endian uint128.
The function `bn_word2hex(a,bn128,32)` takes uint128_t and
returns a hex string.</s>




NEXT




<s> static int ar934x_nfc_wait_dev_ready(struct ar934x_nfc *nfc)
{
unsigned long timeout;

timeout = jiffies + msecs_to_jiffies(AR934X_NFC_DEV_READY_TIMEOUT);
do {
if (__ar934x_nfc_dev_ready(nfc))
return 0;
} while time_before(jiffies, timeout);

nfc_dbg(nfc, "timeout waiting for device ready, status:%08x int:%08x\n",
ar934x_nfc_rr(nfc, AR934X_NFC_REG_STATUS),
ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS));
return -ETIMEDOUT;
}

The above function is used to poll NFC controller until device ready is
set. NFC device ready bit is set by CPU when it initializes NFC and
it is asserted till CPU sets NFC enable bit. This polling routine
needs to be removed




NEXT




<s> static void free_tx_ring(unsigned int queue)
{
unsigned long flags;
int i;
struct connection *conn = &g_atm_priv_data.conn[queue];
struct sk_buff *skb;

if (!conn)
return;

spin_lock_irqsave(&conn->lock, flags);

for (i = 0; i < dma_tx_descriptor_length; i++) {
if (conn->tx_desc[i].own == 0 && conn->tx_skb[i] != NULL) {
skb = conn->tx_skb[i];
conn->tx_skb[i] = NULL;
atm_free_tx_skb_vcc(skb, ATM_SKB(skb)->vcc);
}
}
spin_unlock_irqrestore(&conn->lock, flags);
}

The above function is used to delete ring skb as well as descriptor.</s>




NEXT




<s> static void ppe_txout_send(struct dc_ep_dev *dev,
u8 __iomem *ppe_sb_base, int num)
{
int i;
struct aca_dma_desc_2dw desc;

memset(&desc, 0, sizeof(desc));
desc.status.field.own = 1;
desc.status.field.sop = 1;
desc.status.field.eop = 1;
desc.status.field.data_len = 127;
desc.data_pointer = 0x26100000;

for (i = 0; i < num; i++) {
desc.data_pointer += roundup(desc.status.field.data_len, 4);
ep_mem_write(ppe_sb_base + i * sizeof(desc),
(void *)&desc, sizeof(desc));
}

ep_wr32(num, TXOUT_ACA_ACCUM_ADD);
}

The above function is used to start a new txout DMA transfer.

struct ppe_sb_desc_ac is just a simple memory pointer structure as shown
below

struct ppe_sb_desc_ac {
long long phy_addr




NEXT




<s> static void rt305x_init_data(struct fe_soc_data *data,
struct net_device *netdev)
{
struct fe_priv *priv = netdev_priv(netdev);

priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_PADDING_BUG |
FE_FLAG_CALIBRATE_CLK | FE_FLAG_HAS_SWITCH;
netdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |
NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_TX;
}

The above function is used to initialize FE_SOC_DATA structure, which is allocated as part of private struct fe_priv in device allocation.
priv->flags is an enum used to specify whether to calibrate clock, set padding for certain frame size, etc. Here




NEXT




<s> swconfig_create_led_trigger(struct switch_dev *swdev) { return 0; }

The above function is used to create a trigger for LED's. In my previous blog, I gave a gist, and how to set LED's to blinking through the same function.

Well, today, I'm discussing on how to set LED'




NEXT




<s> ret_t rtl8367c_getAsicStormFilterExtBroadcastEnable(rtk_uint32 *pEnabled)
{
if(NULL == pEnabled)
return RT_ERR_NULL_POINTER;

return rtl8367c_getAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_BCAST_EXT_EN_OFFSET, pEnabled);
}

The above function is used to get the AsicStormFilterExtBroadcastEnable, and the same parameter is used to indicate whether or not to set in rtl8367c_setAsicStormFilterExtBroadcastEnable function. According to the code




NEXT




<s> static inline int getscl(void)
{
return (gpio_get_value(scl_index));
}

The above function is used to measure the time difference between two PWM signals. The first PWM pulse is started by the PPS timer which is started by a Rising edge PWM0. The PPM channel which is defined by the bit array will be read 1




NEXT




<s> ret_t rtl8367c_setAsicIGMPMcDataRX(rtk_uint32 port, rtk_uint32 allow_mcdata)
{
ret_t   retVal;

if(port > RTL8367C_PORTIDMAX)
return RT_ERR_PORT_ID;

/* Allow Multicast Data */
if(port < 8)
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MC_DATA_MASK, allow_mcdata);
if(retVal != RT_ERR_OK)
return retVal;
}
else
{
retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MC_DATA_MASK, allow_mcdata);
if(retVal != RT_ERR_OK)
return retVal;
}
return RT_ERR_OK;
}

The above function is used to enable multicast data to be received. The default value is 0x0.

/* Multicast data in IP header */
/* 0: disable, 1: enable */
#define RTL8367




NEXT




<s> static void sha1_transform1 (struct sha1_ctx *sctx, u32 *state, const u32 *in)
{
int i = 0;
volatile struct deu_hash_t *hashs = (struct deu_hash_t *) HASH_START;
unsigned long flag;

CRTCL_SECT_HASH_START;

SHA_HASH_INIT;

/* For context switching purposes, the previous hash output
* is loaded back into the output register
*/
if (sctx->started) {
hashs->D1R = *((u32 *) sctx->hash + 0);
hashs->D2R = *((u32 *) sctx->hash + 1);
hashs->D3R = *((u32 *) sctx->hash + 2);
hashs->D4R = *((u32 *) sctx->hash + 3);
hashs->D5R = *((u32 *) sctx->hash + 4);
}

for (i = 0; i < 16; i++) {
hashs->MR = in[i];
};

//wait for processing
while (hashs->controlr.BSY) {
// this will not take long
}

/* For context switching purposes, the output is saved into a
* context struct which can be used later on
*/
*((u32 *) sctx->hash + 0) = hashs->D1R;
*((u32 *) sctx->hash + 1) = hashs->D2R;
*((u32 *) sctx->hash + 2) = hashs->D3R;
*((u32 *) sctx->hash + 3) = hashs->D4R;
*((u32 *) sctx->hash + 4) = hashs->D5R;

sctx->started = 1;

CRTCL_SECT_HASH_END;
}

The above function is used to update the state with a chunk of data and to
compute the hash value of the chunk. It will write the hash output into the
hash context sctx.hash.

Before using the above function, the user needs to setup the hash




NEXT




<s> static long rtcl_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate)
{
struct rtcl_clk *clk = rtcl_hw_to_clk(hw);
unsigned long rrate = max(clk->min, min(clk->max, rate));
const struct rtcl_round_set *round = &rtcl_round_set[rtcl_ccu->soc][clk->idx];

rrate = ((rrate + (round->step >> 1)) / round->step) * round->step;
rrate -= (rrate > clk->max) ? round->step : 0;
rrate += (rrate < clk->min) ? round->step : 0;

return rrate;
}

The above function is used to round the rate to the nearest supported rate. The following image depicts an example of a rate being rounded to the nearest supported rate.</s>




NEXT




<s> void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
int chan_width, int cf1, int cf2)
{
struct hostapd_data *hapd;
int i;

if (!ctx)
return;

blob_buf_init(&b, 0);
blobmsg_add_u16(&b, "frequency", frequency);
blobmsg_add_u16(&b, "width", chan_width);
blobmsg_add_u16(&b, "center1", cf1);
blobmsg_add_u16(&b, "center2", cf2);

for (i = 0; i < iface->num_bss; i++) {
hapd = iface->bss[i];
ubus_notify(ctx, &hapd->ubus.obj, "radar-detected", b.head, -1);
}
}

The above function is used to notify dmw-radar package of any radar
detections. It uses radar_detected message to notify radar
detection to dmw-radar package using json-rpc. Blobmsg is used to
create




NEXT




<s> handle_cmd_data(void)
{
struct ead_msg_cmd_data *cmd = EAD_ENC_DATA(msg, cmd_data);
int datalen = ead_decrypt_message(msg) - sizeof(struct ead_msg_cmd_data);

if (datalen < 0)
return false;

if (datalen > 0) {
write(1, cmd->data, datalen);
}

return !!cmd->done;
}

The above function is used to handle the EAD client's requests. In this example, the request is to send the data on the console. You can write your application's request handling and processing code in handle_cmd_data. When the EAD client sends a




NEXT




<s> static int nct5104d_gpio_direction_in(struct gpio_chip *chip, unsigned offset);
static int nct5104d_gpio_get(struct gpio_chip *chip, unsigned offset);
static int nct5104d_gpio_direction_out(struct gpio_chip *chip,
unsigned offset, int value);
static void nct5104d_gpio_set(struct gpio_chip *chip, unsigned offset, int value);

#define NCT5104D_GPIO_BANK(_base, _ngpio, _regbase)			\
{								\
.chip = {						\
.label            = DRVNAME,			\
.owner            = THIS_MODULE,		\
.direction_input  = nct5104d_gpio_direction_in,	\
.get              = nct5104d_gpio_get,		\
.direction_output = nct5104d_gpio_direction_out,	\
.set              = nct5104d_gpio_set,		\
.base             = _base,			\
.ngpio            = _ngpio,			\
.can_sleep        = true,			\
},							\
.regbase = _regbase,					\
}

The above function is used to determine the GPIO that NCT5104D supports.
Because the NCT5104D does not provide a number of pins to be used as GPIO,
we need to use the registers to determine the GPIO, and




NEXT




<s> rtk_api_ret_t rtk_trap_unknownMacPktAction_set(rtk_trap_ucast_action_t ucast_action)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (ucast_action >= UCAST_ACTION_FLOODING)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicPortUnknownSaBehavior(ucast_action)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to config the Trap Port's UCast Packet action.

When the UCast packet arrives, the following actions will be performed:

    Flooding
                The pkt is replicated to all other ports,  except the




NEXT




<s> void ifxdeu_fini_md5 (void)
{
crypto_unregister_shash(&ifxdeu_md5_alg);

}

The above function is used to register and deregister SHA256/SHA224
algorithm of IFX DEU device to Linux kernel frameworks. This file has
been included into a Linux kernel version 3.3.0</s>




NEXT




<s> static int rtl8367b_write_phy_reg(struct rtl8366_smi *smi,
u32 phy_addr, u32 phy_reg, u32 val)
{
int timeout;
u32 data;
int err;

dev_dbg(smi->parent, "phy_write: addr:%02x, reg:%02x, val:%04x\n",
phy_addr, phy_reg, val);

if (phy_addr > RTL8367B_PHY_ADDR_MAX)
return -EINVAL;

if (phy_reg > RTL8367B_PHY_REG_MAX)
return -EINVAL;

REG_RD(smi, RTL8367B_IA_STATUS_REG, &data);
if (data & RTL8367B_IA_STATUS_PHY_BUSY)
return -ETIMEDOUT;

/* preapre data */
REG_WR(smi, RTL8367B_IA_WRITE_DATA_REG, val);

/* prepare address */
REG_WR(smi, RTL8367B_IA_ADDRESS_REG,
RTL8367B_INTERNAL_PHY_REG(phy_addr, phy_reg));

/* send write command */
REG_WR(smi, RTL8367B_IA_CTRL_REG,
RTL8367B_IA_CTRL_CMD_MASK | RTL8367B_IA_CTRL_RW_WRITE);

timeout = 5;
do {
REG_RD(smi, RTL8367B_IA_STATUS_REG, &data);
if ((data & RTL8367B_IA_STATUS_PHY_BUSY) == 0)
break;

if (timeout--) {
dev_err(smi->parent, "phy write timed out\n");
return -ETIMEDOUT;
}

udelay(1);
} while (1);

return 0;
}

The above function is used to write to a phy address, the phy id and reg are specified in smi->rtl and phy_addr param respectively.

So far so good, the phy write works. Let’s write something. To do




NEXT




<s> mt7530_w32(struct mt7530_priv *priv, u32 reg, u32 val)
{
if (priv->bus) {
mutex_lock(&priv->bus->mdio_lock);
__mdiobus_write(priv->bus, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
__mdiobus_write(priv->bus, 0x1f, (reg >> 2) & 0xf,  val & 0xffff);
__mdiobus_write(priv->bus, 0x1f, 0x10, val >> 16);
mutex_unlock(&priv->bus->mdio_lock);
return;
}

pr_debug("MT7530 MDIO Write[%04x]=%08x\n", reg, val);
iowrite32(val, priv->base + reg);
}

The above function is used to write in mt7530 to MDIO registers
(port range 0x1f0000-0x1f3fff).

Let's analyze the above function.

Firstly, it checks if




NEXT




<s> rtk_api_ret_t rtk_vlan_UntagDscpPriorityEnable_set(rtk_enable_t enable)
{
rtk_api_ret_t retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(enable >= RTK_ENABLE_END)
return RT_ERR_ENABLE;

if ((retVal = rtl8367c_setAsicVlanUntagDscpPriorityEn((rtk_uint32)enable)) != RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to setup Untag dscp priority
rtk_api_ret_t rtk_vlan_TagUntagDscpPriorityModeEnable_set(rtk_enable_t enable)
{
rtk_




NEXT




<s> fe_next_frag(struct sk_buff *head, struct sk_buff *skb)
{
if (skb != head)
return skb->next;

if (skb_has_frag_list(skb))
return skb_shinfo(skb)->frag_list;

return NULL;
}

The above function is used to find the next fragment of the given skb.

It first checks if the skb has a list of fragments, indicated by the skb_has_frag_list() function. If the skb has fragments, it returns the first fragment list from the




NEXT




<s> static void bcm6348_iudma_chan_stop(struct bcm6348_iudma *iudma, int chan)
{
int limit = 1000;

dmac_writel(iudma, 0, DMAC_CHANCFG_REG, chan);

do {
u32 val;

val = dmac_readl(iudma, DMAC_CHANCFG_REG, chan);
if (!(val & DMAC_CHANCFG_EN_MASK))
break;

udelay(1);
} while (limit--);
}

The above function is used to stop a DMA channel. It is used by the following code:

static void bcm6348_clear_chans(struct bcm6348_priv *priv, int chans)
{
int i




NEXT




<s> uc_bpf_debug_print(enum libbpf_print_level level, const char *format,
va_list args)
{
char buf[256], *str = NULL;
uc_value_t *val;
va_list ap;
int size;

va_copy(ap, args);
size = vsnprintf(buf, sizeof(buf), format, ap);
va_end(ap);

if (size > 0 && (unsigned long)size < ARRAY_SIZE(buf) - 1) {
val = ucv_string_new(buf);
goto out;
}

if (vasprintf(&str, format, args) < 0)
return 0;

val = ucv_string_new(str);
free(str);

out:
uc_vm_stack_push(debug_vm, ucv_get(ucv_array_get(registry, 0)));
uc_vm_stack_push(debug_vm, ucv_int64_new(level));
uc_vm_stack_push(debug_vm, val);
if (uc_vm_call(debug_vm, false, 2) == EXCEPTION_NONE)
ucv_put(uc_vm_stack_pop(debug_vm));

return 0;
}

The above function is used to print debugging information. There’s something wrong when it can’t be loaded. The problem is the following:

libclang.so.7: undefined symbol: __isoc99_sscanf

There are




NEXT




<s> static int ip17xx_get_ports(struct switch_dev *dev, struct switch_val *val)
{
struct ip17xx_state *state = get_state(dev);
int b;
int ind;
unsigned int ports;

if (val->port_vlan >= dev->vlans || val->port_vlan < 0)
return -EINVAL;

ports = state->vlans[val->port_vlan].ports;
b = 0;
ind = 0;
while (b < MAX_PORTS) {
if (ports&1) {
int istagged = ((state->add_tag >> b) & 1);
val->value.ports[ind].id = b;
val->value.ports[ind].flags = (istagged << SWITCH_PORT_FLAG_TAGGED);
ind++;
}
b++;
ports >>= 1;
}
val->len = ind;

return 0;
}

The above function is used to map an existing port_vlan to list of ports using
the bit pattern in vlans[] table. This function is quite optimized to work with
vlans[] structure.

If the vlans are not configured in the switch,




NEXT




<s> rtk_api_ret_t rtk_igmp_dropLeaveZeroEnable_set(rtk_enable_t enabled)
{
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if(enabled >= RTK_ENABLE_END)
return RT_ERR_INPUT;

if ((retVal = rtl8367c_setAsicIGMPDropLeaveZero(enabled))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;

}

The above function is used to configure igmp zero Tx packet will be handled as igmp leave.</s>




NEXT




<s> ret_t rtl8367c_setAsicShareMeterType(rtk_uint32 index, rtk_uint32 type)
{
rtk_uint32 reg;

if(index > RTL8367C_METERMAX)
return RT_ERR_FILTER_METER_ID;

if(index < 32)
reg = RTL8367C_REG_METER_MODE_SETTING0 + (index / 16);
else
reg = RTL8367C_REG_METER_MODE_SETTING2 + ((index - 32) / 16);
return rtl8367c_setAsicRegBit(reg, index % 16, type);
}

The above function is used to switch on or off a certain type of meter.

For those who dont know what i mean by that, here it goes.

-rtr117w
-DSL</s>




NEXT




<s> static int msdc_drv_suspend(struct platform_device *pdev, pm_message_t state)
{
if (state.event == PM_EVENT_SUSPEND)
msdc_drv_pm(pdev, state);
return 0;
}

The above function is used to suspend the device driver during shutdown, and
msdc_drv_pm() is used to execute those parts of code that need to be invoked in
the suspend function.

static INT drv_suspend(struct msdc_




NEXT




<s> static int fe_change_mtu(struct net_device *dev, int new_mtu)
{
struct fe_priv *priv = netdev_priv(dev);
int frag_size, old_mtu;
u32 fwd_cfg;

old_mtu = dev->mtu;
dev->mtu = new_mtu;

if (!(priv->flags & FE_FLAG_JUMBO_FRAME))
return 0;

/* return early if the buffer sizes will not change */
if (old_mtu <= ETH_DATA_LEN && new_mtu <= ETH_DATA_LEN)
return 0;
if (old_mtu > ETH_DATA_LEN && new_mtu > ETH_DATA_LEN)
return 0;

if (new_mtu <= ETH_DATA_LEN)
priv->rx_ring.frag_size = fe_max_frag_size(ETH_DATA_LEN);
else
priv->rx_ring.frag_size = PAGE_SIZE;
priv->rx_ring.rx_buf_size = fe_max_buf_size(priv->rx_ring.frag_size);

if (!netif_running(dev))
return 0;

fe_stop(dev);
if (!IS_ENABLED(CONFIG_SOC_MT7621)) {
fwd_cfg = fe_r32(FE_GDMA1_FWD_CFG);
if (new_mtu <= ETH_DATA_LEN) {
fwd_cfg &= ~FE_GDM1_JMB_EN;
} else {
frag_size = fe_max_frag_size(new_mtu);
fwd_cfg &= ~(FE_GDM1_JMB_LEN_MASK << FE_GDM1_JMB_LEN_SHIFT);
fwd_cfg |= (DIV_ROUND_UP(frag_size, 1024) <<
FE_GDM1_JMB_LEN_SHIFT) | FE_GDM1_JMB_EN;
}
fe_w32(fwd_cfg, FE_GDMA1_FWD_CFG);
}

return fe_open(dev);
}

The above function is used to change the MTU size of the interface.The function gets the new_mtu from the caller and
performs the necessary steps to change the MTU size according to that.
#else
#define SMPTE_121




NEXT




<s> struct_group(psb6970_priv_volatile,
bool vlan;
u16 vlan_id[PSB6970_MAX_VLANS];
u8 vlan_table[PSB6970_MAX_VLANS];
u8 vlan_tagged;
u16 pvid[PSB6970_NUM_PORTS];
);
};

#define to_psb6970(_dev) container_of(_dev, struct psb6970_priv, dev)

static u16 psb6970_mii_read(struct phy_device *phydev, int reg)
{

The above function is used to read MII register data.

static s32 psb6970_mii_write(struct phy_device *phydev, int reg, u16 val)
{

The above function is used




NEXT




<s> void rtl931x_set_receive_management_action(int port, rma_ctrl_t type, action_type_t action)
{
u32 value = 0;

/* hack for value mapping */
if (type == GRATARP && action == COPY2CPU)
action = TRAP2MASTERCPU;

switch(action) {
case FORWARD:
value = 0;
break;
case DROP:
value = 1;
break;
case TRAP2CPU:
value = 2;
break;
case TRAP2MASTERCPU:
value = 3;
break;
case FLOODALL:
value = 4;
break;
default:
break;
}

switch(type) {
case BPDU:
sw_w32_mask(7 << ((port % 10) * 3), value << ((port % 10) * 3), RTL931X_RMA_BPDU_CTRL + ((port / 10) << 2));
break;
case PTP:
/* udp */
sw_w32_mask(3 << 2, value << 2, RTL931X_RMA_PTP_CTRL + (port << 2));
/* eth2 */
sw_w32_mask(3, value, RTL931X_RMA_PTP_CTRL + (port << 2));
break;
case PTP_UDP:
sw_w32_mask(3 << 2, value << 2, RTL931X_RMA_PTP_CTRL + (port << 2));
break;
case PTP_ETH2:
sw_w32_mask(3, value, RTL931X_RMA_PTP_CTRL + (port << 2));
break;
case LLTP:
sw_w32_mask(7 << ((port % 10) * 3), value << ((port % 10) * 3), RTL931X_RMA_LLTP_CTRL + ((port / 10) << 2));
break;
case EAPOL:
sw_w32_mask(7 << ((port % 10) * 3), value << ((port % 10) * 3), RTL931X_RMA_EAPOL_CTRL + ((port / 10) << 2));
break;
case GRATARP:
sw_w32_mask(3 << ((port & 0xf) << 1), value << ((port & 0xf) << 1), RTL931X_TRAP_ARP_GRAT_PORT_ACT + ((port >> 4) << 2));
break;
}
}

The above function is used to change receive management action. When you change the type, value will be changed according the defined value mapping. You need to change the value mapping for your action in the above code.</s>




NEXT




<s> void rtl9300_sds_rxcal_tap_manual(u32 sds_num, int tap_id, bool manual, u32 tap_list[])
{
if (manual) {
switch(tap_id) {
case 0:
/* ##REG0_LOAD_IN_INIT[0]=1; REG0_TAP0_INIT[5:0]=Tap0_Value */
rtl9300_sds_field_w(sds_num, 0x2e, 0x0f, tap_id + 7, tap_id + 7, 0x1);
rtl9300_sds_field_w(sds_num, 0x2f, 0x03, 5, 5, tap_list[0]);
rtl9300_sds_field_w(sds_num, 0x2f, 0x03, 4, 0, tap_list[1]);
break;
case 1:
rtl9300_sds_field_w(sds_num, 0x2e, 0x0f, tap_id + 7, tap_id + 7, 0x1);
rtl9300_sds_field_w(sds_num, 0x21, 0x07, 6, 6, tap_list[0]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x09, 11, 6, tap_list[1]);
rtl9300_sds_field_w(sds_num, 0x21, 0x07, 5, 5, tap_list[2]);
rtl9300_sds_field_w(sds_num, 0x2f, 0x12, 5, 0, tap_list[3]);
break;
case 2:
rtl9300_sds_field_w(sds_num, 0x2e, 0x0f, tap_id + 7, tap_id + 7, 0x1);
rtl9300_sds_field_w(sds_num, 0x2e, 0x09, 5, 5, tap_list[0]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x09, 4, 0, tap_list[1]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x0a, 11, 11, tap_list[2]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x0a, 10, 6, tap_list[3]);
break;
case 3:
rtl9300_sds_field_w(sds_num, 0x2e, 0x0f, tap_id + 7, tap_id + 7, 0x1);
rtl9300_sds_field_w(sds_num, 0x2e, 0x0a, 5, 5, tap_list[0]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x0a, 4, 0, tap_list[1]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x06, 5, 5, tap_list[2]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x06, 4, 0, tap_list[3]);
break;
case 4:
rtl9300_sds_field_w(sds_num, 0x2e, 0x0f, tap_id + 7, tap_id + 7, 0x1);
rtl9300_sds_field_w(sds_num, 0x2f, 0x01, 5, 5, tap_list[0]);
rtl9300_sds_field_w(sds_num, 0x2f, 0x01, 4, 0, tap_list[1]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x06, 11, 11, tap_list[2]);
rtl9300_sds_field_w(sds_num, 0x2e, 0x06, 10, 6, tap_list[3]);
break;
default:
break;
}
} else {
rtl9300_sds_field_w(sds_num, 0x2e, 0x0f, tap_id + 7, tap_id + 7, 0x0);
mdelay(10);
}
}

The above function is used to program (or remove) RX calibration tap for the given sds number and tap id.

The tap id will be 0~6 or 7, and the tap could be either in the form of Tap0_Value




NEXT




<s> uc_hostapd_bss_rename(uc_vm_t *vm, size_t nargs)
{
struct hostapd_data *hapd = uc_fn_thisval("hostapd.bss");
uc_value_t *ifname_arg = uc_fn_arg(0);
char prev_ifname[IFNAMSIZ + 1];
struct sta_info *sta;
const char *ifname;
int ret;

if (!hapd || ucv_type(ifname_arg) != UC_STRING)
return NULL;

os_strlcpy(prev_ifname, hapd->conf->iface, sizeof(prev_ifname));
ifname = ucv_string_get(ifname_arg);

hostapd_ubus_free_bss(hapd);
if (interfaces->ctrl_iface_deinit)
interfaces->ctrl_iface_deinit(hapd);

ret = hostapd_drv_if_rename(hapd, WPA_IF_AP_BSS, NULL, ifname);
if (ret)
goto out;

for (sta = hapd->sta_list; sta; sta = sta->next) {
char cur_name[IFNAMSIZ + 1], new_name[IFNAMSIZ + 1];

if (!(sta->flags & WLAN_STA_WDS) || sta->pending_wds_enable)
continue;

snprintf(cur_name, sizeof(cur_name), "%s.sta%d", prev_ifname, sta->aid);
snprintf(new_name, sizeof(new_name), "%s.sta%d", ifname, sta->aid);
hostapd_drv_if_rename(hapd, WPA_IF_AP_VLAN, cur_name, new_name);
}

if (!strncmp(hapd->conf->ssid.vlan, hapd->conf->iface, sizeof(hapd->conf->ssid.vlan)))
os_strlcpy(hapd->conf->ssid.vlan, ifname, sizeof(hapd->conf->ssid.vlan));
os_strlcpy(hapd->conf->iface, ifname, sizeof(hapd->conf->iface));
hostapd_ubus_add_bss(hapd);

hostapd_ucode_update_interfaces();
out:
if (interfaces->ctrl_iface_init)
interfaces->ctrl_iface_init(hapd);

return ret ? NULL : ucv_boolean_new(true);
}

The above function is used to rename the interface associated with the wifi access point in unified configuration.</s>




NEXT




<s> rtk_api_ret_t rtk_l2_ipMcastGroupEntry_add(ipaddr_t ip_addr, rtk_uint32 vid, rtk_portmask_t *pPortmask)
{
rtk_uint32      empty_idx = 0xFFFF;
rtk_int32       index;
ipaddr_t        group_addr;
rtk_uint32      group_vid;
rtk_uint32      pmask;
rtk_uint32      valid;
rtk_uint32      physicalPortmask;
rtk_api_ret_t   retVal;

/* Check initialization state */
RTK_CHK_INIT_STATE();

if (vid > RTL8367C_VIDMAX)
return RT_ERR_L2_VID;

if(NULL == pPortmask)
return RT_ERR_NULL_POINTER;

if((ip_addr & 0xF0000000) != 0xE0000000)
return RT_ERR_INPUT;

/* Get Physical port mask */
if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &physicalPortmask))!=RT_ERR_OK)
return retVal;

for(index = 0; index <= RTL8367C_LUT_IPMCGRP_TABLE_MAX; index++)
{
if ((retVal = rtl8367c_getAsicLutIPMCGroup((rtk_uint32)index, &group_addr, &group_vid, &pmask, &valid))!=RT_ERR_OK)
return retVal;

if( (valid == ENABLED) && (group_addr == ip_addr) && (group_vid == vid) )
{
if(pmask != physicalPortmask)
{
pmask = physicalPortmask;
if ((retVal = rtl8367c_setAsicLutIPMCGroup(index, ip_addr, vid, pmask, valid))!=RT_ERR_OK)
return retVal;
}

return RT_ERR_OK;
}

if( (valid == DISABLED) && (empty_idx == 0xFFFF) ) /* Unused */
empty_idx = (rtk_uint32)index;
}

if(empty_idx == 0xFFFF)
return RT_ERR_TBL_FULL;

pmask = physicalPortmask;
if ((retVal = rtl8367c_setAsicLutIPMCGroup(empty_idx, ip_addr, vid, pmask, ENABLED))!=RT_ERR_OK)
return retVal;

return RT_ERR_OK;
}

The above function is used to add the specific user defined IGMP multicast group.

To create a new IGMP multicast group, IP (IPv4) multicast address of user defined IGMP multicast group and VLAN




NEXT




<s> static int rtl8366rb_sw_set_qos_enable(struct switch_dev *dev,
const struct switch_attr *attr,
struct switch_val *val)
{
struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
u32 data;

if (val->value.i)
data = RTL8366RB_QOS_MASK;
else
data = 0;

return rtl8366_smi_rmwr(smi, RTL8366RB_SGCR, RTL8366RB_QOS_MASK, data);
}

The above function is used to set the qos value. When this function has been completed, the interrupt number can be shown as follows:</s>
